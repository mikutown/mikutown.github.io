<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-04-12T01:21:48.654Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode63.不同路径II</title>
    <link href="2023/04/12/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>2023/04/12/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</id>
    <published>2023-04-12T01:18:23.000Z</published>
    <updated>2023-04-12T01:21:48.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/robot1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/robot2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：obstacleGrid &#x3D; [[0,1],[0,0]]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道典型的动态规划问题。定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p><p>在定义dp数组时，需要特别注意：如果某个格子为障碍物，则不能通过该格子，路径数为0；如果第一列某个格子为障碍物，则其下方的所有格子均无法到达，路径数为0；如果第一行某个格子为障碍物，则其右方的所有格子均无法到达，路径数为0。</p><p>在状态转移方程中，如果某个格子为障碍物，则其路径数为0；否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p><p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int m &#x3D; obstacleGrid.size();        int n &#x3D; obstacleGrid[0].size();        &#x2F;&#x2F; 定义二维数组dp        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));        &#x2F;&#x2F; 初始化第一列        for (int i &#x3D; 0; i &lt; m; i++) &#123;            if (obstacleGrid[i][0] &#x3D;&#x3D; 1) &#123;                break;            &#125;            dp[i][0] &#x3D; 1;        &#125;        &#x2F;&#x2F; 初始化第一行        for (int j &#x3D; 0; j &lt; n; j++) &#123;            if (obstacleGrid[0][j] &#x3D;&#x3D; 1) &#123;                break;            &#125;            dp[0][j] &#x3D; 1;        &#125;        &#x2F;&#x2F; 对于其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和        for (int i &#x3D; 1; i &lt; m; i++) &#123;            for (int j &#x3D; 1; j &lt; n; j++) &#123;                if (obstacleGrid[i][j] &#x3D;&#x3D; 1) &#123;  &#x2F;&#x2F; 如果当前格子为障碍物，则不可到达，路径数为0                    dp[i][j] &#x3D; 0;                &#125; else &#123;  &#x2F;&#x2F; 否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达                    dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];                &#125;            &#125;        &#125;        &#x2F;&#x2F; 返回右下角格子的不同路径数目        return dp[m-1][n-1];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;网格中的障碍物和空位置分别用 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt; 来表示。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode62.不同路径</title>
    <link href="2023/04/12/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>2023/04/12/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2023-04-12T00:57:03.000Z</published>
    <updated>2023-04-12T01:21:20.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/robot_maze.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 7输出：28</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 7, n &#x3D; 3输出：28</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 3输出：6</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道比较典型的动态规划问题。我们定义一个二维数组<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p><p>根据题目要求，从第一行第一列出发只能向下或向右移动一步，因此<code>dp[0][j]</code>和<code>dp[i][0]</code>的值都为1。</p><p>对于其他的格子，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p><p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        &#x2F;&#x2F; 定义二维数组dp        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));        &#x2F;&#x2F; 对于除第一行第一列外的其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和        for (int i &#x3D; 1; i &lt; m; i++) &#123;            for (int j &#x3D; 1; j &lt; n; j++) &#123;                dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];            &#125;        &#125;        &#x2F;&#x2F; 返回右下角格子的不同路径数目        return dp[m-1][n-1];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode746.使用最小花费爬楼梯</title>
    <link href="2023/04/10/leetcode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>2023/04/10/leetcode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2023-04-10T07:44:23.000Z</published>
    <updated>2023-04-10T07:57:11.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：cost &#x3D; [10,15,20]输出：15解释：你将从下标为 1 的台阶开始。- 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：cost &#x3D; [1,100,1,1,1,100,1,1,100,1]输出：6解释：你将从下标为 0 的台阶开始。- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。- 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>因为上台阶可以一次1阶或者一次2阶，因此定义一个dp数组，长度为cost的大小+1，dp[i]表示到达第n个台阶需要的最小费用。因此<code>dp[i]</code>的更新公式为:</p><p>$dp[i] &#x3D; min(dp[i-1] + cost[i - 1], dp[i - 2] + cost[i - 2])$</p><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;        int len &#x3D; cost.size(); &#x2F;&#x2F; 获取cost的大小（总的台阶数）        vector&lt;int&gt; dp(len + 1); &#x2F;&#x2F; 定义一个dp数组，长度为cost的大小+1 dp[i]表示到达第n个台阶需要的最小费用。        dp[0] &#x3D; 0, dp[1] &#x3D; 0; &#x2F;&#x2F; 因为可以从下标为0或者1的台阶出发，因此dp[0]和dp[1]都初始化为0；        for (int i &#x3D; 2; i &lt; len + 1;i++) &#123;            dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); &#x2F;&#x2F; dp[i]的更新公式        &#125;        return dp[len]; &#x2F;&#x2F; 返回到达第n个台阶（也就是最后一个台阶）的最小费用。    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;cost&lt;/code&gt; ，其中 &lt;code&gt;cost[i]&lt;/code&gt; 是从楼梯第 &lt;code&gt;i&lt;/code&gt; 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。&lt;/p&gt;
&lt;p&gt;你可以选择从下标为 &lt;code&gt;0&lt;/code&gt; 或下标为 &lt;code&gt;1&lt;/code&gt; 的台阶开始爬楼梯。&lt;/p&gt;
&lt;p&gt;请你计算并返回达到楼梯顶部的最低花费。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode509.斐波那契数</title>
    <link href="2023/04/09/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>2023/04/09/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2023-04-09T06:41:47.000Z</published>
    <updated>2023-04-09T07:17:20.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre class="language-none"><code class="language-none">F(0) &#x3D; 0，F(1) &#x3D; 1F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</code></pre><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：1解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：2解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：3解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归求解</li></ol><p>在递归函数里初始化<code>f(0) = 0,f(1) = 1</code>,对于大于1的函数值，递归调用<code>f(n - 2) + f(n - 1)</code>;</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; f(0)的初始化        if (n &#x3D;&#x3D; 1) return 1; &#x2F;&#x2F; f(1)的初始化        return fib(n - 1) + fib(n - 2); &#x2F;&#x2F; 递归调用    &#125;&#125;;</code></pre><ol start="2"><li>迭代求解</li></ol><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        if (n &lt;&#x3D; 1) return n; &#x2F;&#x2F; 如果n为0或者1 直接返回它本身        int pre0 &#x3D; 0, pre1 &#x3D; 1; &#x2F;&#x2F; 初始化pre0和pre1        int answer &#x3D; 0; &#x2F;&#x2F; 初始化答案        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;            answer &#x3D; pre0 + pre1; &#x2F;&#x2F; 答案为f(n-2) + f(n-1)            pre0 &#x3D; pre1; &#x2F;&#x2F; pre0的值更新            pre1 &#x3D; answer; &#x2F;&#x2F; pre1的值更新        &#125;        return answer; &#x2F;&#x2F; 计算完毕返回答案    &#125;&#125;;</code></pre><ol start="3"><li>矩阵快速幂求解</li></ol><p>核心思路是将斐波那契数列的递推式转化为矩阵的乘法，然后使用矩阵快速幂的方法快速计算出矩阵的幂次，进而得到第 n 个斐波那契数。</p><p>首先，我们知道斐波那契数列的递推式为：</p><p>$F(n) &#x3D; F(n-1) + F(n-2)，其中 F(0) &#x3D; 0，F(1) &#x3D; 1。$</p><p>我们可以将这个递推式转化为矩阵的乘法形式：</p><p>$ \begin{bmatrix} F(n) \ F(n-1) \end{bmatrix} &#x3D; \begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} F(n-1) \ F(n-2) \end{bmatrix} $</p><p>根据这个式子，我们可以构造出初始矩阵 base 和单位矩阵 res，然后使用矩阵快速幂的方法快速计算出 base 的 n 次幂，最终得到 res。</p><p>最后，我们可以直接返回<code> res[0][1]</code>，这个值就是第 n 个斐波那契数。</p><p>总的来说，这种解法虽然比较高级，但可以在 O(log n) 的时间复杂度内计算出第 n 个斐波那契数，而且不需要使用数组或者递归来存储之前的结果，空间复杂度为 O(1)。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        &#x2F;&#x2F; 如果n小于等于1，直接返回n        if (n &lt;&#x3D; 1) &#123;            return n;        &#125;        &#x2F;&#x2F; 定义初始矩阵        vector&lt;vector&lt;int&gt;&gt; base&#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        &#x2F;&#x2F; 定义单位矩阵        vector&lt;vector&lt;int&gt;&gt; res&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;        &#x2F;&#x2F; 矩阵快速幂        while (n) &#123;            if (n &amp; 1) &#123;                res &#x3D; multiply(res, base);            &#125;            base &#x3D; multiply(base, base);            n &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 将变量 n 的二进制表示向右移动一位，并将移位后的结果赋值给 n。相当于n&#x2F;&#x3D;2        &#125;        &#x2F;&#x2F; 返回结果        return res[0][1];    &#125;    &#x2F;&#x2F; 定义矩阵乘法函数    vector&lt;vector&lt;int&gt;&gt; multiply(const vector&lt;vector&lt;int&gt;&gt;&amp; A, const vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123;        int m &#x3D; A.size(), n &#x3D; A[0].size(), l &#x3D; B[0].size();        vector&lt;vector&lt;int&gt;&gt; C(m, vector&lt;int&gt;(l));        for (int i &#x3D; 0; i &lt; m; ++i) &#123;            for (int j &#x3D; 0; j &lt; l; ++j) &#123;                for (int k &#x3D; 0; k &lt; n; ++k) &#123;                    C[i][j] +&#x3D; A[i][k] * B[k][j];                &#125;            &#125;        &#125;        return C;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt; （通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示）形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;pre class=&quot;language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;F(0) &amp;#x3D; 0，F(1) &amp;#x3D; 1
F(n) &amp;#x3D; F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-青蛙过河</title>
    <link href="2023/04/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
    <id>2023/04/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</id>
    <published>2023-04-06T12:23:29.000Z</published>
    <updated>2023-04-06T13:05:44.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里 的石头跳到对岸。</p><p>河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度, 每次小青蛙从一块石头起跳, 这块石头的高度就 会下降 1 , 当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的)。</p><p>小青蛙一共需要去学校上 $x$ 天课, 所以它需要往返 $2x$次。当小青蛙具有 一个跳跃能力 $y$ 时, 它能跳不超过 $y$的距离。</p><p>请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。</p><span id="more"></span><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含两个整数$n,x$, 分别表示河的宽度和小青蛙需要去学校 的天数。请注意$2x$ 才是实际过河的次数。</p><p>第二行包含 $n−1$ 个非负整数$H_1,H_2,⋯,H_{n−1}$, 其中 $H_i$&gt;0 表示在河中与小青蛙的家相距 $i$的地方有一块高度为 $H_i$ 的石头,$H_i&#x3D;0$ 表示这个位置没有石头。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行, 包含一个整数, 表示小青蛙需要的最低跳跃能力。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="language-txt" data-language="txt"><code class="language-txt">5 11 0 1 0</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="language-text" data-language="text"><code class="language-text">4</code></pre><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>由于只有两块高度为 1 的石头，所以往返只能各用一块。第 1 块石头和对岸的距离为 4，如果小青蛙的跳跃能力为 3 则无法满足要求。所以小青蛙最少需要 4 的跳跃能力。</p><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 30% 的评测用例, $n≤100$;</p><p>对于 60% 的评测用例, $n≤1000$;</p><p>对于所有评测用例, $1≤n≤10^5,1≤x≤10^9,1≤H_i≤10^4 $。</p><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 512M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>常规思路</li></ul><p>一只青蛙上x次课，来回走了2x次；相当于2x只青蛙上了一次课（只走一段）；每次踩石头它的高度都下降1，而且青蛙都能过河。所以可以先求前缀和之后二分法进行贪心的求解，代码的思路如下：</p><ol><li>定义数组的最大长度N，整型数字n,m，数组a用于接收输入，数组b用于计算前缀和;</li><li>得到n，m和数组a之后，定义数组<code>a[0] = a[n] = N</code>,然后进行计算前缀和的操作。例如前缀和<code>b[i]=x</code>的意思就是i之前的石头一共可以容纳x个青蛙跳过(我们一共需要2m)个;</li><li>进行二分+贪心操作，求出最小的跳跃能力值。</li><li>check函数用于计算在x的下标下，石头是否能让2m个青蛙通过。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int N &#x3D; 1e5 + 3;ll a[N],b[N];int n, m;bool check(int x) &#123;    for(int i &#x3D; 1; i + x - 1 &lt; n ;i++) &#123;        &#x2F;&#x2F; 只有一个的时候        if (b[i + x - 1] - b[i - 1] &lt; 2 * m) &#123;            &#x2F;&#x2F; 石块为0的情况            return false;        &#125;    &#125;    return true;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt; n; i++) &#123;        &#x2F;&#x2F; 循环到n-1        cin &gt;&gt; a[i];    &#125;    a[0] &#x3D; a[n] &#x3D; N;    for (int i &#x3D; 1; i &lt; n; i++) &#123;        &#x2F;&#x2F; 计算前缀和        b[i] &#x3D; b[i - 1] + a[i]; &#x2F;&#x2F; 我能让几只小青蛙在上面    &#125;    &#x2F;&#x2F; 贪心求y    int l &#x3D; 1, r &#x3D; N;    while (l &lt; r)&#123;        int mid &#x3D; (l + r) &#x2F; 2;        if (check(mid)) &#123; &#x2F;&#x2F; 石头足够青蛙分，继续贪心            r &#x3D; mid;        &#125;        else &#123; &#x2F;&#x2F; 石头不够青蛙分            l &#x3D; mid + 1;        &#125;    &#125;    cout &lt;&lt; l;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里 的石头跳到对岸。&lt;/p&gt;
&lt;p&gt;河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度, 每次小青蛙从一块石头起跳, 这块石头的高度就 会下降 1 , 当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的)。&lt;/p&gt;
&lt;p&gt;小青蛙一共需要去学校上 $x$ 天课, 所以它需要往返 $2x$次。当小青蛙具有 一个跳跃能力 $y$ 时, 它能跳不超过 $y$的距离。&lt;/p&gt;
&lt;p&gt;请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-回文日期</title>
    <link href="2023/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F/"/>
    <id>2023/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F/</id>
    <published>2023-04-05T08:01:19.000Z</published>
    <updated>2023-04-05T09:59:30.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。</p><p>有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。</p><p>也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。</p><p>给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。</p><span id="more"></span><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入包含一个八位整数 <em>N</em>，表示日期。</p><p>对于所有评测用例，10000101≤N≤89991231，保证 N 是一个合法日期的 8 位数表示。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出两行，每行 1 个八位数。第一行表示下一个回文日期，第二行表示下一个 ABABBABA 型的回文日期。</p><p><strong>输入输出样例</strong></p><p><strong>示例</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">20200202</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">2021120221211212</code></pre><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>（1）定义每个月的天数</li><li>（2）计算年份</li><li>（3）计算月份</li><li>（4）计算第几天</li><li>（5）判断是不是闰年</li><li>（6）闰年二月天数为29</li><li>（7）非闰年二月天数为28</li><li>（8）判断是不是符合日期标准</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;bool isleap(int year)&#123;    return ((year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)||year%400&#x3D;&#x3D;0); &#x2F;&#x2F; 判断是否是闰年&#125;bool legal(int n) &#x2F;&#x2F; 判断8位数是否是合规的日期&#123;    int year,month,day;    year&#x3D;n&#x2F;10000; &#x2F;&#x2F; 获取年月日的值    month&#x3D;(n%10000)&#x2F;100;    day&#x3D;n%100;    if(month&gt;12 || month&#x3D;&#x3D;0 || day&#x3D;&#x3D;0 || day&gt;31) &#x2F;&#x2F; 进行年月日的判断    return false;    if(month&#x3D;&#x3D;2) &#x2F;&#x2F; 2月针对闰年平年单独判断    &#123;        if(isleap(year)&#x3D;&#x3D;0&amp;&amp;day&gt;28)        return false;        if(isleap(year)&#x3D;&#x3D;1&amp;&amp;day&gt;29)        return false;    &#125;    if(month&#x3D;&#x3D;1||month&#x3D;&#x3D;3||month&#x3D;&#x3D;5||month&#x3D;&#x3D;7||month&#x3D;&#x3D;8||month&#x3D;&#x3D;10||month||12)    &#123;        if(day&gt;31)        return false;    &#125;    if(month&#x3D;&#x3D;4||month&#x3D;&#x3D;6||month&#x3D;&#x3D;9||month&#x3D;&#x3D;11)    &#123;        if(day&gt;30)        return false;    &#125;    return true;&#125;int main()&#123;    int n;    cin&gt;&gt;n; &#x2F;&#x2F; 获取输入    int flag&#x3D;0; &#x2F;&#x2F; 设置判断    for(int i&#x3D;n+1;i&lt;&#x3D;100000000;i++)    &#123;        int a1,a2,a3,a4,a5,a6,a7,a8; &#x2F;&#x2F; 用最笨的办法获取每一位的值        a8&#x3D;i&#x2F;10000000;        a7&#x3D;(i&#x2F;1000000)%10;        a6&#x3D;(i&#x2F;100000)%10;        a5&#x3D;(i&#x2F;10000)%10;        a4&#x3D;(i&#x2F;1000)%10;        a3&#x3D;(i&#x2F;100)%10;        a2&#x3D;(i&#x2F;10)%10;        a1&#x3D;i%10;        if(legal(i)&amp;&amp;flag&#x3D;&#x3D;0&amp;&amp;a1&#x3D;&#x3D;a8&amp;&amp;a2&#x3D;&#x3D;a7&amp;&amp;a3&#x3D;&#x3D;a6&amp;&amp;a4&#x3D;&#x3D;a5) &#x2F;&#x2F; 判断是否是普通回文日期        &#123;            cout&lt;&lt;i&lt;&lt;endl;            flag&#x3D;1;        &#125;        if(legal(i)&amp;&amp;a1&#x3D;&#x3D;a3&amp;&amp;a3&#x3D;&#x3D;a6&amp;&amp;a6&#x3D;&#x3D;a8&amp;&amp;a2&#x3D;&#x3D;a4&amp;&amp;a4&#x3D;&#x3D;a5&amp;&amp;a5&#x3D;&#x3D;a7) &#x2F;&#x2F; 判断是否是ABABBABA型回文日期        &#123;            cout&lt;&lt;i;            break;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。&lt;/p&gt;
&lt;p&gt;有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。&lt;/p&gt;
&lt;p&gt;也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。&lt;/p&gt;
&lt;p&gt;给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>一种用于网格计算中作业调度的新型多智能体强化学习方法</title>
    <link href="2023/04/04/%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97%E4%B8%AD%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B0%E5%9E%8B%E5%A4%9A%E4%BB%A3%E7%90%86%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <id>2023/04/04/%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97%E4%B8%AD%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B0%E5%9E%8B%E5%A4%9A%E4%BB%A3%E7%90%86%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</id>
    <published>2023-04-04T11:57:30.000Z</published>
    <updated>2023-04-05T11:26:26.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一种用于网格计算中作业调度的新型多智能体强化学习方法"><a href="#一种用于网格计算中作业调度的新型多智能体强化学习方法" class="headerlink" title="一种用于网格计算中作业调度的新型多智能体强化学习方法"></a>一种用于网格计算中作业调度的新型多智能体强化学习方法</h2><p>原标题：A novel multi-agent reinforcement learning approach for job scheduling in Grid computing</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>网格计算利用分布式异构资源来支持大规模或复杂的计算任务，合适的资源调度算法对于网格应用的成功至关重要。由于网格环境的复杂性和动态特性，传统的基于模型的方法在实践中可能会导致调度性能不佳。可扩展性和适应性是网格作业调度的主要目标之一。在本文中，针对作业调度问题，特别是在网格中实现负载平衡，提出了一种称为顺序共享学习 (OSL) 方法的新型多智能体强化学习方法。该方法通过使用有序的分布式学习策略规避了可扩展性问题，并基于有限通信的信息共享机制实现了多主体协调。仿真结果表明，OSL方法可以有效地达到负载均衡的目的，其性能在大多数情况下甚至可以与某些集中式调度算法相媲美。还说明了所提方法的收敛性和适应性。</p><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>主要介绍了网格计算的背景和作业调度问题，指出了传统的基于模型的方法在面对资源异构性、资源性能变化和应用程序多样性等方面存在的挑战。然后，介绍了强化学习在解决这些问题方面的优势，并提出了一种基于多智能体强化学习的作业调度方法。</p><p>在本文中，为了在大规模网格环境中实现基于学习的协调和泛化，提出了一种称为序数共享学习 (OSL) 方法的新型多智能体强化学习方法来解决网格计算的作业调度问题。在OSL方法中，基于序号信息共享机制设计了一种快速分布式学习算法。与以前用于作业调度的多智能体强化学习（MARL）方法相比，OSL 方法有两个方面的创新。一方面简化了作业调度中最优决策的建模，其中仅在线学习效用表来估计资源效率，而不是构建复杂的网格信息系统（GIS）。另一方面通过多智能体系统有限通信的有效信息共享机制规避了可扩展性和协调问题，其中有序共享策略使所有智能体共享它们的效用表并依次做出决策。在模拟的大规模网格计算环境中对所提出的方法进行了评估，结果表明了其有效性和可行性。</p><p>最后，简要介绍了本文的组织结构和贡献。</p><p><img src="http://cdn.leafii.top/img/image-20230404221510593.png" alt="image-20230404221510593" loading="lazy"></p><h3 id="Problem-statement"><a href="#Problem-statement" class="headerlink" title="Problem statement"></a>Problem statement</h3><h4 id="A-general-job-scheduling-model-in-Grids"><a href="#A-general-job-scheduling-model-in-Grids" class="headerlink" title="A general job scheduling model in Grids"></a>A general job scheduling model in Grids</h4><p>由于网格计算的NP-Complete特性和调度算法在网格场景中的最优性难以证明，现有的研究总是试图寻找次优解。为了描述网格计算的动态性，随机性以及异构性，研究了通用的 Gird 作业调度模型，如图2所示：</p><p><img src="http://cdn.leafii.top/img/image-20230404210909544.png" alt="image-20230404210909544" loading="lazy"></p><p>主要组件包括用户、调度程序和资源，其中不同的调度程序并行处理作业。他们负责从用户那里接收作业并将其分配给资源。与传统并行和分布式系统中的对应物不同，网格调度器通常不能直接控制资源，而是像代理体一样工作.每个调度器都可以向任何计算资源提交作业，并最终生成作业到资源的映射.在上述模型中，用户只是生产并向调度程序提交作业，他们的角色可以完全由作业创建者代替。工作到达或工作负荷的模型可以用泊松过程或其他基于概率的模型或自相关模型来描述.</p><p>在大型网格系统中，由于缺乏对资源的控制，资源更新周期长，调度器可用的资源信息存在时间延迟，可能不准确。因此，作业调度器的有限可观察性成为基于及时准确信息的作业调度算法的障碍，有必要开发更鲁棒和自适应的调度算法，这是本文的主要动机之一。</p><p>一般来说，Grids 中的分散作业调度问题可以建模为多智能体作业调度系统 [29]，表示为 6 元组$⟨G，R，P，D，C，SR⟩$，其中$G&#x3D;⟨g_1,…,g_N⟩$是一组智能体，$s &#x3D; {s_1,…,s_M}$是一组资源，$P:G\times N\rightarrow[0,1]$是作业提交函数,$D:G\times N \rightarrow \mathbb R$是概率作业大小函数,$C:G\times N \rightarrow \mathbb R$是概率容量函数，SR是作业调度规则。</p><p>为了专注于作业调度任务，上述模型进行了一些抽象，但保持了网格计算环境的主要特征，即动态的、大规模的用户和资源的异构性。尽管没有详细考虑实际实施的设计问题，例如网络拓扑，但图 2 中的模型<strong>足够通用</strong>，因为可以开发不同的代表性模型，包括随机作业提交函数、作业大小函数和容量函数，以描述网格工作负载的显着属性。利用网格工作负载的随机或自相关模型，可以研究处理网格作业调度问题的动态性、随机性和异构性的作业调度算法。</p><p>下面，为了便于讨论，假设所有的调度器都使用相同的调度算法，并且所有的作业只需要 CPU 资源，因此它们的持续时间 J 是唯一的。</p><h4 id="Performance-measures-for-job-scheduling-in-Grids"><a href="#Performance-measures-for-job-scheduling-in-Grids" class="headerlink" title="Performance measures for job scheduling in Grids"></a>Performance measures for job scheduling in Grids</h4><p>在上面的 Grid 调度模型中，资源执行分配的作业，并且它们的能力可能不同.每个资源都以其处理能力 C 为特征，它被定义为完成单位长度作业所需的 CPU 时间的倒数，即如果资源需要持续时间 t 来完成长度为 J &#x3D; 1 的单位作业，则其容量为$C &#x3D; 1&#x2F;t$。此外，假设队列中的所有作业都按到达时间排列优先级，因此在给定时间<strong>只有一个作业</strong>在资源上执行，而其他作业则在队列中等待。</p><p>网格作业调度中的常见性能度量是平均每个动作时间 (ATPT)。time-per-token (TPT) 是通过作业生成和完成之间经过的时间来衡量的，因此相应的平均标准，即 ATPT，可以制定如下：</p><p>$ATPT&#x3D;\frac{1}{L} \sum_{i&#x3D;1}^{L}TPT^i &#x3D; \frac{1}{L}\sum_{i&#x3D;1}^{L}(t_{wait}^i + t_{execute}^i)$</p><p>$TPT^i$是第i个作业的总耗时，它是队列等待时间$t_{wait}^i$（一个作业提交到开始执行的耗用时间）与实际执行时间$t_{execute}^i$之和，L表示所有资源完成的工作的总数。但是ATPT无法及时表征整个网格系统的调度性能，因为只有在作业完成后，才能更新此指标。如果资源中的作业队列很长，ATPT 的更新会严重延迟。最后，ATPT 的值仅仅反映了过去的作业调度效率，而不是当前的。</p><p>因此，使用了另一个有效的指标，即资源负载（LoR，或 makespan）。LoR定义为队列中作业的总长度$l_{total}$除以当前资源的容量$C_i$，系统的平均LoR（ALoR）可以<strong>完全代替</strong>平均每令牌时间。 ALoR 可以表示为：</p><p>$ALoR &#x3D; \frac{1}{M}\sum_{i&#x3D;1}^{M}LoR^i&#x3D;\frac{1}{M}\sum_{i&#x3D;1}^{M}(l_{total}^{i}&#x2F;C_i) \&#x3D;\frac{1}{M}\sum_{i&#x3D;1}^{M}(\sum_{j&#x3D;1}^{L^i}J_j^i&#x2F;C_i)$</p><p>其中 $LoR_i$ 是第 i 个资源的负载,$l^i_{total}$ 是队列中作业的总长度，它是所有排队作业长度$J_j^i$的总和,$L_i$ 是第 i 个资源队列中的作业数，$M$是资源数。新绩效指标的优点是显而易见的，因为它能够及时、全面地反映系统绩效。</p><p>作业调度算法的目标是最小化 ALoR 及其标准偏差。最小化上述两个量将确保整个系统的效率和公平性。除了上述两个指标外，资源中的最大 LoR 是反映瞬态性能的另一个指标。</p><h3 id="The-OSL-method-for-adaptive-job-scheduling"><a href="#The-OSL-method-for-adaptive-job-scheduling" class="headerlink" title="The OSL method for adaptive job scheduling"></a>The OSL method for adaptive job scheduling</h3><p>如上所述，在实际的大型网格应用中，即使有 GIS 系统的帮助，调度器中的资源信息也存在时间延迟并且可能不准确。因此，开发一种不依赖于精确模型的鲁棒调度算法是合理的。为了满足自适应作业调度的要求，协调的多智能体强化学习方法可能是一个合适的解决方案。在下文中，在对不同的 MARL 框架进行分析之后，提出了一种用于资源选择和作业调度的新型分散式 MARL 方法，其中多个智能体或调度程序之间的协作控制是通过顺序共享学习方法实现的。</p><h4 id="Basic-frameworks-for-multi-agent-reinforcement-learning"><a href="#Basic-frameworks-for-multi-agent-reinforcement-learning" class="headerlink" title="Basic frameworks for multi-agent reinforcement learning"></a>Basic frameworks for multi-agent reinforcement learning</h4><p>大多数单智能体 RL 算法都基于马尔可夫决策过程 (MDP) 的形式.然而，作为强化学习在分布式决策环境中的延伸，多智能体强化学习必须解决多个智能体共存打破环境平稳性的问题。到目前为止，许多 MARL 算法都是基于随机博弈 (SG) 模型 [33] 开发的，例如 JAL [34] 和 Team-Q 算法 [35]。然而，可扩展性差和信息利用效率低是MARL成功应用于大规模应用的两大障碍。对于图 2 中描述的作业调度问题，调度器和资源的数量非常多，因此，以前的MARL方法很难被采用。</p><p>除了SG模型，MARL的另一个框架是将单智能体强化学习技术直接扩展到多智能体系统，即让每个智能体根据局部状态和局部奖励独立学习，无需显式通信。这种技术在 MARL [34] 中称为独立学习器 (IL) 方法，并且在文献 [5,36,37] 中开发了一些 IL 算法。尽管 IL 的 MARL 方法不需要探索呈指数增长的联合状态-动作空间，但环境将不再是静止的，MARL 中将存在收敛问题和振荡行为。正如我们将在 4.1 节中说明的那样，如果在网格中的作业调度中使用没有协调和通信的 IL 方法，通常会出现羊群行为 [22]。</p><p>为了解决上述困难，多智能体强化学习的一种有前途的方法是通过信息共享和协调进行局部学习，以实现效率和最优性之间的平衡。基于这个想法，一种称为 OSL 算法的新 MARL 方法将在以下讨论中提出。</p><h4 id="The-OSL-algorithm-for-job-scheduling-in-Grids"><a href="#The-OSL-algorithm-for-job-scheduling-in-Grids" class="headerlink" title="The OSL algorithm for job scheduling in Grids"></a>The OSL algorithm for job scheduling in Grids</h4><p>为了克服 MARL 中的“维数灾难”问题，我们提出了具有降低的计算复杂性和改进的协调机制的 OSL 算法。新算法有两个主要特点。首先，它采用分布式 RL 框架并采用新颖的基于效用表的学习策略。由于 OSL 方法仅利用局部信息进行学习，因此它是一种基于独立学习者的 RL 方法。其次，它利用通信成本有限的信息共享机制来解决多主体协调问题。</p><p>OSL 的方案如图 3 所示。上面的循环表示共享实用程序表的调度程序。效用表仅随资源数量 M 线性增加，因此通信成本有限。下半部分详细表示调度程序智能体。每个调度器智能体主要包括两部分：Learner 和 Actor。 Learner 以有序的方式从前面的 agent 接收并共享效用表，并决定为 Job Buffer 中排队的作业选择资源。 Reward Converter 可以分析作业的完成信号并将其转换为奖励信号，这对于更新效用表至关重要。 Actor接收到新的job，并安排它们在Job Buffer中排队，然后根据Learner的决定将其提交到相应的资源中，并将提交记录在Submitted Job List中。最后，Actor 根据作业的完成情况更新 Submitted Job List，即如果一个作业完成了，那么它将从 Submitted Job List 中删除。</p><p><img src="http://cdn.leafii.top/img/image-20230404221455211.png" alt="image-20230404221455211" loading="lazy"></p><p>一般来说，OSL的实施需要考虑两个关键问题：</p><p>首先，虽然众所周知全局资源状态是调度器决策的基础，但由于调度器的观察和通信能力有限，很难在动态环境中获得所有调度器的准确信息。在本文中，提出了一种利用职位信息来估计状态的间接方法。调度器将提交作业的信息记录为向量$（n_r，t_s，t_e，J）$，即使用的资源名称$n_r$，作业开始时间$t_s$，作业完成时间$t_e$，作业大小$J$.然后，它抽象估计相应资源状态的信息。<strong>但是</strong>，如果调度程序从未向资源提交作业，则它对此一无所知。因此，这种来自个人经验的估计仅包含全局状态的部分信息。<strong>为提高估算精度，必须采取信息共享等有效手段。</strong></p><p>其次，很难直接获得学习的即时奖励。环境<strong>不能直接提供</strong>任何全局强化信号，而只能提供单个作业完成信号。因此调度器智能体必须将此类信息转换为奖励信息。事实上，由于其他调度器的存在，一个作业的time-per-token是由所有调度器的策略共同决定的。如何从上述信息中计算出合适的强化信号将是一个问题。更重要的是，当一个调度器等待其提交的作业的反馈时，网格环境可能会由于其他调度器的操作而发生变化，因此一个调度器只有在作业完成后才更新其效用表为时已晚。<strong>一种可能的解决方案</strong>是开发一种奖励机制，无论调度程序是否执行作业提交，都会在每个时间步创建奖励信息。</p><p>在下面的小节中，为了解决上述问题，将提出一种新颖的奖励生成机制和信息共享机制。</p><h5 id="The-decentralized-learning-strategy-using-utility-tables"><a href="#The-decentralized-learning-strategy-using-utility-tables" class="headerlink" title="The decentralized learning strategy using utility tables"></a>The decentralized learning strategy using utility tables</h5><p>在上述模型中，调度智能体被描述为 $G &#x3D; {g_1, g_2, . . . , g_N }$，其中每个调度智能体 gi 可以负责多个用户的作业调度。资源由$ S &#x3D; {s_1, s_2, . . . , S_M}$表示。类似于强盗问题 [24] 的学习方法，智能体 $g_i$ 保留一个效用表 $U_i$ 来对资源的效率进行评分，其中 $U^i{(j)}$ 表示第 j 个资源的效率，或者对从资源集 S，即 $j ∈ {1, 2, . . . , |S|} &#x3D; {1, 2, . . . , M}$中选择第 j 个资源的动作进行评分。调度程序 $g_i$的效用表如图 4 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230405092926308.png" alt="image-20230405092926308" loading="lazy"></p><p>对于去中心化学习过程中的每个时间步，agent $g_i$基于以下两个步骤执行资源选择操作和效用更新操作：</p><p>第1步：agent $g_i$检查判断是否有新的job到达。如果不是，转步骤2。如果是，重复执行步骤1，直到所有作业都被调度。 Agent $g_i$ 选择得分最高的资源 $s_j$，然后将作业提交给资源 $s_j$，并将其作为未完成的作业记录在已提交的作业列表中。如果执行第 j 个动作，则获得瞬时奖励 $r(j) &#x3D; −1$，同时更新该动作对应的效用 $U^i{(j)}$：</p><p>$U^i(j) &#x3D; (1 - \alpha) * U^i(j) + \alpha * r(j)$</p><p>其中的$\alpha$是学习率。</p><p>第 2 步：Agent $g_i$ 推进空闲调度进程并更新效用。如上所述，即使没有作业提交，也会为每个步骤设计一个瞬时奖励信号。Agent $g_i$ 根据提交的作业列表中的作业状态为每个动作创建强化信号，即：</p><p>$u(j) &#x3D;\left {<br>\begin{array}{c}<br>+1 \ \ \ only \ the \ job \ is \ finished \<br>0 \ \ \ no \ job \<br>-1 \ \ \ job\ is\ unfinished<br>\end{array}<br>\right. \ \ j \in {1,2,…,M}.$</p><p>如果多个作业被提交到同一个资源，每个作业都会有一个独立的强化信号。最后，可以通过将所有信号相加来计算<strong>相应动作的奖励</strong>：</p><p>$r(j)&#x3D;\sum_{k&#x3D;1}^{K^j}u(k)$</p><p>其中 $K^j$ 表示当前提交给第 j 个资源的作业数。例如，假设当前智能体向第一个资源提交了 3 个作业，并且在一个时间步之后，一个作业完成而另外两个作业未完成。所以选择第一个资源的瞬时奖励是：$r(1) &#x3D; 1 + 2 * (−1) &#x3D; −1$。当获得整个奖励向量$ (r(1), r(2), . . , r(N))$ 时，可以使用上面的等式更新每个资源的效用。</p><p>此时，agent $g_i$ 可以使用效用表 Ui 来估计所有资源的效率。例如，如果一个资源的队列很长或者资源的容量很差，调度器向它提交作业后，调度器必须等待很长时间才能收到资源的完成响应。因此，调度器获得奖励信号 −1 的次数要比获得奖励 +1 的次数多得多。最后，这种资源对应的效用价值会很小。显然，根据效用表，<strong>效用值越大，资源状态越好。</strong>连续更新操作及时反馈资源的工作状态，为分配连续作业做出可行的决策至关重要。</p><h5 id="Multi-agent-information-sharing-based-on-limited-communication"><a href="#Multi-agent-information-sharing-based-on-limited-communication" class="headerlink" title="Multi-agent information sharing based on limited communication"></a>Multi-agent information sharing based on limited communication</h5><p>在上面的小节中，建立了一个效用表来估计资源的效率。开发了一种改进的奖励和更新机制来指示资源的效率。然而，在网格应用程序中，有多个调度程序智能体。如果所有智能体都独立且同时学习和做出决策，则会出现协调问题。显然，调度器的任何决定都会改变资源的状态，但其他调度器在将作业提交到同一资源之前不会检测到更改（它们通过使用队列中的等待时间间接检测到这一点）。因此，特定智能体中的效用表不能准确指示资源的真实状态。此外，随着调度器数量的增加，可能的冲突将变得更加严重。因此，必须为网格作业调度问题中的分布式学习开发一种可行的协调机制。</p><p>由于每个智能体都拥有一个本地效用表来估计资源的效率，因此通过共享效用表来提高估计精度是一种自然的方式。但是，由于Grids中的scheduler agent数量非常多，不可能直接共享每个utility table。因此，本文提出了一种有限通信的序号共享机制来满足上述需求。智能体之间的协调是通过<strong>按顺序和迭代共享相邻智能体的效用表</strong>来实现的。如图4所示，效用表仅与资源规模成线性比例。因此智能体之间的总通信成本很低并且始终保持不变。</p><p>为了实现信息共享机制，通过将Agent排序 为$g_1，g_2，… . . , g_N$，为所有调度智能体定义了一个序数结构。 , 那么智能体共享它们的效用表并按顺序进行决策，即智能体 $g_i$ 共享前面智能体的效用信息如下：</p><p>$U^i(j) &#x3D; (1 - \beta) * U^i{j} + \beta * U^{i-1}(j)$</p><p>其中的$\beta$是共享因子。$U^{i-1}(j)$是相邻智能体$g_{i-1}$的效用表并且它包含了所有的之前的智能体对资源效用的估计。最终，最后一个agent的效用表返回给第一个agent再次共享。换句话说，效用共享过程是有序的和迭代的。</p><p>表 1 显示了网格作业调度中智能体 gi 的 OSL 算法的主要过程。</p><p><img src="http://cdn.leafii.top/img/image-20230405104508471.png" alt="image-20230405104508471" loading="lazy"></p><p>与其他MARL算法相比，OSL算法更适合在大规模作业调度应用中实现。作为一种基于效用表的学习方法，效用表函数中没有显式的状态变量，因此更适应资源和应用高度多样化和动态化的网格场景。此外，OSL 的另一个重要优势是协调的通信成本低。信息交换总量是简单效用表，其规模与资源数量成线性关系，远低于直接通信模式下的指数级。</p><h3 id="Performance-evaluation-and-discussions"><a href="#Performance-evaluation-and-discussions" class="headerlink" title="Performance evaluation and discussions"></a>Performance evaluation and discussions</h3><p>在本节中，将在模拟中评估和分析用于作业调度的基于 OSL 的选择 (OSLS) 规则的性能。此外，将所提出的 OSLS 方法与其他四种资源调度或选择规则进行了比较，它们是分散的最小-最小选择（DMMS）[38]、随机选择（RS）、最小负载选择（LLS）和简单学习选择（ SLS）[5]。 Min-Min算法是一种启发式调度方法，成为性能比较的基准调度算法[38]。基于分散的调度模型，每个调度器独立执行分散的Min-Min算法。即使有 GIS 系统的帮助，在动态环境中调度程序的决策也可能无法被其他人准确知晓。原因是GIS中的信息更新总是不可避免地存在时间延迟。在 RS 方法中，智能体根据均匀概率分布为作业随机选择资源。在 LLS 方法中，智能体选择负载最少的资源来提交作业。如果有多个资源具有相同的最小负载，则随机选择其中一个。该选择规则假定智能体可以获得准确的全球资源信息，例如，来自理想的 GIS 系统。在 SLS 方法中，智能体执行独立的强化学习过程。它与提议的 OSLS 方法的不同之处在于，智能体在收到来自资源的已提交作业的最终完成信号之前不会更新其效用表，并且每个智能体都在没有任何协调信息的情况下独立学习 [5]。</p><p>网格系统的规模可以定义为智能体数$(N)$和资源数$(M)$的组合$(N，M)$。在每个时间步中，每个调度智能体$g_i$ 可能会收到带有泊松过程生成的随机数的作业。工作的到达率表示为 $ξ$ 。作业的长度是从 $[J_{min}, J_{max}]$ 区间内的均匀分布中随机生成的。资源的容量也在区间 $[C_{min}, C_{max}]$ 中统一选择。所以系统可以用参数集$(N，M，ξ，[J_{min}，J_{max}]，[C_{min}，C_{max}])$来描述。因此，由Grids的总处理能力和到达的作业总数共同确定的期望系统负载$γ_{system}$可以计算为：</p><p>$γ_{system} &#x3D; \frac{J_{total}}{C_{total}} &#x3D; \frac{\sum_{j&#x3D;1}^N(J_j^{\alpha v}<em>\xi)}{\sum_{i&#x3D;1}^{N}C_i} &#x3D; \frac{\sum_{j&#x3D;1}^N((J_{min} + J_{max})&#x2F;2</em>\xi_{j})}{\sum_{i&#x3D;1}^{N}C_i} * 100%$</p><p>其中$J_j^{\alpha v}$ 是第 j 个调度程序的作业长度的中值。显然，系统负载不应超过 100%，否则调度系统会崩溃。事实上，超过 90% 的系统负载对于 Grids 来说是非常沉重的。一个有效的作业调度算法可以公平、充分地利用所有资源来平衡系统的负载。为了测试新方法的负载均衡能力，下面进行了几个实验。</p><h4 id="Performance-evaluations-under-different-system-scales"><a href="#Performance-evaluations-under-different-system-scales" class="headerlink" title="Performance evaluations under different system scales"></a>Performance evaluations under different system scales</h4><p>为了实验不同的系统规模，选择了三种系统规模，即(30, 100)、(100, 250)和(300, 1000)。这些配置足够大，可以代表典型网格计算环境的规模。作业长度的分散范围设置为 [5, 995]。资源容量的区间为[50, 350]。工作到达率分别为0.93、0.7和0.93。所以所有的系统负载大约在 70% 左右。它是网格应用程序的典型中等系统负载。仿真结果如图 5 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230405142053921.png" alt="image-20230405142053921" loading="lazy"></p><p>图5中不同作业调度方法的ALoR曲线表明，在中等系统负载下，只有OSL方法、DMMS方法和LLS方法在不同的系统规模下实现了高效的负载均衡。显然，LLS方法是一种集中式的方法，可以达到最优的调度策略。但昂贵的计算和通信成本阻碍了它在现实世界网格中的有效应用。 DMMS方法可以平衡负载，但效率低于LLS方法，因为非协调决策可能会发生冲突，导致某些资源的过度利用&#x2F;利用不足。 OSL算法是去中心化的，只需要有限的通信成本，但可以针对不同的系统规模获得更好的次优策略。结果表明，一开始，OSL 方法的性能可能比 DMMS 和 LLS 差。这是因为使用 OSL 方法的调度器没有网格的先验知识，但是使用其他两种启发式方法的调度器可以从 GIS 系统中获取环境信息。当基于 OSL 的调度器通过试验积累了足够的经验时，最终可以获得良好的调度性能。</p><p>如图所示，SLS规则的性能很差，无法完成作业调度任务。出现这种现象的主要原因是奖励机制不当和同步问题。对于 SLS 方法，无论其 bandit-like 模型如何，它都采用延迟奖励机制。此外，基于 SLS 的调度器无需协调即可独立学习和工作。显然，这种行为会导致某些资源过度利用，而导致其他资源利用不足，这会降低调度性能。这种病理被称为<strong>羊群行为</strong> [18,19]。</p><p>具有 RS 规则的智能体随机选择资源，根本不考虑它们的效率，因此低容量资源上的 LoR 将无限增长。最后，平均负载 ALoR 增加失控。此外，对于 RS 规则，确实规模越大，性能越差。</p><h4 id="Performance-evaluations-under-different-system-loads"><a href="#Performance-evaluations-under-different-system-loads" class="headerlink" title="Performance evaluations under different system loads"></a>Performance evaluations under different system loads</h4><p>为了测试新方法在不同系统负载下的自适应性能，选择了50%、70%和90%三种系统负载配置，系统规模设置为(100, 250)。其他参数与前一个实验相同。图 6 显示了不同系统负载下 ALoR 的变化曲线。很明显，OSL 方法允许智能体比 RS 和 SLS 方法更有效地在资源之间安排作业。此外，即使系统负载增加，OSL 方法也可以收敛到次优策略。因此，所提出的 OSL 方法可以适应不同的系统负载。从图 6 可以看出，对于低系统负载，OSL 甚至可以收敛到一个接近最优的策略，其性能与集中式 LLS 方法相似。当系统负载增加时，OSL 也可以找到与 LLS 相当的次优策略。</p><p><img src="http://cdn.leafii.top/img/image-20230405145121744.png" alt="image-20230405145121744" loading="lazy"></p><h4 id="Performance-evaluations-under-different-resource-capacities"><a href="#Performance-evaluations-under-different-resource-capacities" class="headerlink" title="Performance evaluations under different resource capacities"></a>Performance evaluations under different resource capacities</h4><p>在前面的模拟中，资源容量的区间很宽，即 [50, 350]。事实上，不同的时间间隔会显着影响系统性能。下面选择资源容量的一个窄区间[150, 250]，再次进行上述系统规模(200, 500)的模拟。结果如图 7 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230405150525357.png" alt="image-20230405150525357" loading="lazy"></p><p>在图 7 中，当系统负载较轻时（γsystem ≤ 70%），RS 方法可以很好地进行作业调度。 原因可能是所有资源的容量都大于 150，足以避免保持较长的作业队列。 此外，SLS 方法在系统负载较低时也可以获得良好的性能，如图 7（a）所示。 然而，RS 和 SLS 都无法在高系统负载下获得良好的性能，如图 7（b）和（c）所示。 当系统负载增加时，RS方法的性能下降，最终变得不可行。 然而，OSL 方法可以实现不同资源容量一致的负载平衡。</p><h4 id="Performance-evaluations-under-different-numbers-of-schedulers-and-resources"><a href="#Performance-evaluations-under-different-numbers-of-schedulers-and-resources" class="headerlink" title="Performance evaluations under different numbers of schedulers and resources"></a>Performance evaluations under different numbers of schedulers and resources</h4><p>在下面的模拟中，调度器数量和资源数量的不同比例被选择为（500, 200）和（1000, 500）。 作业长度的区间和资源容量的区间分别为 [5, 995] 和 [250, 750]。 作业到达率为 0.2 和 0.4（因此系统负载分别为 50% 和 80%）。 结果如图 8 所示。从图 8 可以看出，当调度器的数量远大于资源的数量时，SLS 方法具有良好的性能。 结果与文献[5]的结论一致。 如此好的成绩，可能是因为就业率低，资源能力强。 然而，对于现实世界的网格，调度器的数量多于资源的数量并不常见。 此外，请注意 SLS 规则的性能在不同条件下仍然不如 OSL 方法。</p><p><img src="http://cdn.leafii.top/img/image-20230405152315603.png" alt="image-20230405152315603" loading="lazy"></p><h4 id="Other-performance-measures"><a href="#Other-performance-measures" class="headerlink" title="Other performance measures"></a>Other performance measures</h4><p>除了平均资源负载 (ALoR) 之外，还可以使用其他指标来衡量系统性能。通常，ALoR 表示系统的宏观性能，但瞬态性能，例如资源中的最大 LoR（或完工跨度）也很重要。此外，LoR 的标准偏差是评估作业调度算法效率的另一个指标。无花果。图 9 和图 10 显示了 4.1 节中相应的实验结果。</p><p><img src="http://cdn.leafii.top/img/image-20230405153155477.png" alt="image-20230405153155477" loading="lazy"></p><p>从以上两个图中可以发现，OSLS 的最大 LoR 和偏差收敛，而 RS、SLS 和 DMMS 规则发散很快。 尽管 OSLS 曲线的幅度随着系统规模的增加而增加，但它们最终趋于平稳。 在不同的系统负载下获得了相同的结果。 换句话说，所有结果表明OSL算法的瞬态性能和效率是<strong>令人满意</strong>的。</p><h4 id="Performance-evaluation-with-different-learning-rates-and-sharing-factors"><a href="#Performance-evaluation-with-different-learning-rates-and-sharing-factors" class="headerlink" title="Performance evaluation with different learning rates and sharing factors"></a>Performance evaluation with different learning rates and sharing factors</h4><p>在上述所有模拟中，学习率和共享因子均设置为 0.5。事实上，学习因素和共享因素可以看作是新信息和过去经验之间的折衷，以及代理人自己的知识和他人的知识。可以为这两个参数选择一些不同的配置。下面进行与4.1(b)节相同条件的实验，分别评估不同的学习率和共享因子。</p><p><img src="http://cdn.leafii.top/img/image-20230405154828342.png" alt="image-20230405154828342" loading="lazy"></p><p>图 11(a) 显示了 OSL 在不同学习率下的性能变化，分别为 0.2、0.5 和 0.8，其中共享因子等于 0.5。 图 11(b) 显示了 OSL 在不同共享率下的性能变化，分别为 0.2、0.5 和 0.8，其中学习率等于 0.5。 结果表明，α 和 β 的值太大或太小都可能导致不理想的调度性能。 从实证研究中，可以选择学习率和共享因子的中间值以获得良好的性能。</p><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>根据以上实验，OSL算法的优势是显而易见的。通过使用序数共享学习机制，OSL 算法实现了与集中式和基于模型的方法（即 LLS 方法）相当的性能，但计算成本低得多且通信受限。此外，新方法对工作条件的敏感性低于其他算法，并实现了基于 MARL 的有效负载平衡。表 2 显示了本文研究的不同作业调度方法之间的比较总结。</p><p><img src="http://cdn.leafii.top/img/image-20230405155201637.png" alt="image-20230405155201637" loading="lazy"></p><h3 id="Related-works"><a href="#Related-works" class="headerlink" title="Related works"></a>Related works</h3><p>对于 Grids 中基于 RL 的作业调度问题，还有一些其他相关工作。 在[5]中，SLS 方法被用于网格作业调度。 然而，上述实验结果表明，SLS方法仅在用户数远大于资源数的某些特殊情况下具有良好的性能。 此外，其性能仍有待提高。</p><p>在 [6] 中，作者针对网格和其他分布式系统等领域的分布式任务分配问题引入了一种名为加权策略学习器 (WPL) 的新梯度上升学习算法。 WPL 可以在不观察其他智能体行为的情况下学习随机策略。然而，由于观测信息有限且难以获得平衡解，多智能体梯度上升法的收敛速度较慢，尤其是对于大规模问题。因此，作者只是针对一个小规模的问题测试了 WPL，其中服务器和用户的数量都不超过 5 个。</p><p>为了解决动态资源分配中的协调学习问题，在[39,27]中提出了一些基于价值函数的RL算法。为了将标准 Q 学习扩展到具有较大或连续状态-动作空间的资源分配问题，研究了具有函数逼近的 RL 方法。然而，大规模网格应用的问题仍然难以解决。在 [25,26] 中，一种名为 Fair Action Learner (FAL) 算法的多智能体 RL 方法被应用于以分散的方式跨集群共享资源。 FAL 采用直接策略搜索技术，即策略梯度上升 (PGA) 算法来学习决策策略。但是从他们的实验结果来看，学习过程的收敛速度还是很慢.</p><p>在 [40] 中，作者将资源分配问题视为复合 MDP，并提出了一种简化的本地化 RL 方法，其中动作、状态和奖励都是绝对本地化的。本地 RL 方法在数据中心原型的资源分配任务中进行了测试，并获得了一些有希望的结果。但是，智能体之间的适当协调对于获得更好的系统性能至关重要。</p><h3 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h3><p>网格计算的主要关注点之一是开发在动态环境中具有自配置和自优化能力的自主计算系统。 本文提出了基于多智能体强化学习的OSL方法来解决Grids中的作业调度问题。 该方法通过使用分布式学习策略规避了可扩展性问题，并实现了基于有序信息共享机制的多智能体协调。 最后，对OSL算法的性能进行了评价，并与其他算法进行了比较，研究并模拟了一种通用的网格作业调度模型，以描述网格的动态性、随机性、异构性。 仿真结果表明，适当的在线学习方法可以对异构网格系统中的负载平衡质量产生实质性的积极影响，并说明了OSL算法的有效性和效率。 未来的工作可能包括在实际网格环境中改进和应用所提出的方法。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一种用于网格计算中作业调度的新型多智能体强化学习方法&quot;&gt;&lt;a href=&quot;#一种用于网格计算中作业调度的新型多智能体强化学习方法&quot; class=&quot;headerlink&quot; title=&quot;一种用于网格计算中作业调度的新型多智能体强化学习方法&quot;&gt;&lt;/a&gt;一种用于网格计算中作业调度的新型多智能体强化学习方法&lt;/h2&gt;&lt;p&gt;原标题：A novel multi-agent reinforcement learning approach for job scheduling in Grid computing&lt;/p&gt;
&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;网格计算利用分布式异构资源来支持大规模或复杂的计算任务，合适的资源调度算法对于网格应用的成功至关重要。由于网格环境的复杂性和动态特性，传统的基于模型的方法在实践中可能会导致调度性能不佳。可扩展性和适应性是网格作业调度的主要目标之一。在本文中，针对作业调度问题，特别是在网格中实现负载平衡，提出了一种称为顺序共享学习 (OSL) 方法的新型多智能体强化学习方法。该方法通过使用有序的分布式学习策略规避了可扩展性问题，并基于有限通信的信息共享机制实现了多主体协调。仿真结果表明，OSL方法可以有效地达到负载均衡的目的，其性能在大多数情况下甚至可以与某些集中式调度算法相媲美。还说明了所提方法的收敛性和适应性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-单词分析</title>
    <link href="2023/04/04/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/"/>
    <id>2023/04/04/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/</id>
    <published>2023-04-04T07:48:17.000Z</published>
    <updated>2023-04-04T07:52:47.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组 成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。</p><p>现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这 个字母出现的次数。</p><span id="more"></span><p><strong>输入描述</strong></p><p>输入一行包含一个单词，单词只由小写英文字母组成。</p><p>对于所有的评测用例，输入的单词长度不超过 1000。</p><p><strong>输出描述</strong></p><p>输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪 个。如果有多个字母出现的次数相等，输出字典序最小的那个。</p><p>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。</p><p><strong>输入输出样例</strong></p><p><strong>示例 1</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">lanqiao</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">a2</code></pre><p><strong>示例 2</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">longlonglongistoolong</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">o6</code></pre><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    string word; &#x2F;&#x2F; 定义输入的单词变量    cin &gt;&gt; word; &#x2F;&#x2F; 用输入流为其赋值    int cnt[26] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 初始化计数器    int index &#x3D; -1; &#x2F;&#x2F; 初始化计数器所用的下标    for (char s: word) &#123;        index &#x3D; s - &#39;a&#39;; &#x2F;&#x2F; 获取当前字母在计数器中的下标        cnt[index]++; &#x2F;&#x2F; 对应的计数自增1    &#125;    int max &#x3D; -1; &#x2F;&#x2F; 计数器中的最大值    int max_index &#x3D; -1; &#x2F;&#x2F; 计数器中最大值对应的最小下标    for (int i &#x3D; 0; i &lt; 26; i++) &#123;        if (cnt[i] &gt; max) &#123;            max &#x3D; cnt[i]; &#x2F;&#x2F; 最大值迭代            max_index &#x3D; i; &#x2F;&#x2F; 最大值的最小下标迭代，若最大值未更新，下标也不会更新        &#125;    &#125;    char answer &#x3D; &#39;a&#39; + max_index; &#x2F;&#x2F; 得到字母个数最多的字母    cout &lt;&lt; answer &lt;&lt; endl; &#x2F;&#x2F; 输出题目要求的第一行答案    cout &lt;&lt; max &lt;&lt; endl; &#x2F;&#x2F; 输出题目要求的第二行答案    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组 成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。&lt;/p&gt;
&lt;p&gt;现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这 个字母出现的次数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-门牌制作</title>
    <link href="2023/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C/"/>
    <id>2023/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C/</id>
    <published>2023-04-03T08:29:27.000Z</published>
    <updated>2023-04-09T06:43:56.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小蓝要为一条街的住户制作门牌号。</p><p>这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。</p><p>小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。</p><p>请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><span id="more"></span><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int result &#x3D; 0; &#x2F;&#x2F; 初始化需要数字2的个数为0    for (int i &#x3D; 1; i &lt;&#x3D; 2020; i++) &#123; &#x2F;&#x2F; 循环，从1到2020        int temp &#x3D; i; &#x2F;&#x2F; 令temp&#x3D;i，方便后续判断字符2个数的操作        while (temp &gt; 0) &#123;            if (temp % 10 &#x3D;&#x3D; 2) &#123; &#x2F;&#x2F; 如果temp中最后一位是2                result++; &#x2F;&#x2F; result自增            &#125;            temp &#x2F;&#x3D; 10; &#x2F;&#x2F; temp&#x2F;&#x3D;10去掉最后一位数字        &#125;    &#125;    printf(&quot;%d&quot;, result);&#x2F;&#x2F; 输出结果    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小蓝要为一条街的住户制作门牌号。&lt;/p&gt;
&lt;p&gt;这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。&lt;/p&gt;
&lt;p&gt;小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。&lt;/p&gt;
&lt;p&gt;请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大运行时间：1s&lt;/li&gt;
&lt;li&gt;最大运行内存: 128M&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-质数</title>
    <link href="2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E8%B4%A8%E6%95%B0/"/>
    <id>2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E8%B4%A8%E6%95%B0/</id>
    <published>2023-04-02T06:29:27.000Z</published>
    <updated>2023-04-02T07:44:59.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们知道第一个质数是 22、第二个质数是 33、第三个质数是 55……</p><p>请你计算第 20192019 个质数是多少？</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><span id="more"></span><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int isPrime(int num) &#123;    &#x2F;&#x2F; 判断一个数字是不是质数，return 0代表不是质数， return 1 代表是质数    for (int i &#x3D; 2; i &lt; num; i++) &#123;        &#x2F;&#x2F; 循环中判断是否能被1或者它本身之外的数字整除，若能则不是质数，直接return 0        if (num % i &#x3D;&#x3D; 0) &#123;            return 0;        &#125;    &#125;    &#x2F;&#x2F; 循环结束都没发现能整除的其他数字，可以返回1    return 1;&#125;int main()&#123;    int count &#x3D; 0; &#x2F;&#x2F; 定义计数器，默认为0    int answer &#x3D; 0;    for (int i &#x3D; 2; count !&#x3D; 2019; i++) &#123; &#x2F;&#x2F; 从2开始循环是因为2是第一个质数，不要从1开始循环        if (isPrime(i) &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 若判断为是质数            count++; &#x2F;&#x2F; 计数器++；            answer &#x3D; i; &#x2F;&#x2F; 迭代更新answer        &#125;    &#125;    cout &lt;&lt; answer &lt;&lt; endl; &#x2F;&#x2F; 输出答案    return 0;&#125;</code></pre><ul><li>优化解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main() &#123;    int n &#x3D; 2019; &#x2F;&#x2F; 要计算的质数的位置    int num &#x3D; 3; &#x2F;&#x2F; 初始为3，因为第一个质数是2    int count &#x3D; 1; &#x2F;&#x2F; 已经找到了一个质数2，所以从1开始计数    while (count &lt; n) &#123;        num +&#x3D; 2; &#x2F;&#x2F; 只需要判断奇数是否为质数        bool isPrime &#x3D; true; &#x2F;&#x2F; 假设当前数是质数        for (int i &#x3D; 3; i &lt;&#x3D; sqrt(num); i +&#x3D; 2) &#123;            if (num % i &#x3D;&#x3D; 0) &#123;                isPrime &#x3D; false; &#x2F;&#x2F; 如果能被整除，则不是质数                break;            &#125;        &#125;        if (isPrime) &#123;            count++; &#x2F;&#x2F; 找到一个质数        &#125;    &#125;    cout &lt;&lt; num &lt;&lt; endl; &#x2F;&#x2F; 输出第2019个质数    return 0;&#125;</code></pre><ul><li>线性筛法（Linear Sieve）</li></ul><p>线性筛法是一种求解质数的算法，可以在$O(n)$的时间复杂度内预处理出小于等于$n$的所有质数。</p><p>线性筛法的基本思想是从小到大遍历每个正整数，如果它是质数，就将它加入质数数组中，并用它来筛掉它的倍数。在遍历过程中，对于每个数只会被它的最小质因子筛去，因此每个合数只会被筛一次，从而保证了线性时间复杂度。</p><p>下面是线性筛法的伪代码：</p><pre class="language-none"><code class="language-none">primes &#x3D; [] # 质数数组is_prime &#x3D; [True] * (n+1) # 标记是否为质数for i in range(2, n+1):    if is_prime[i]:        primes.append(i) # 将i加入质数数组    for j in range(len(primes)):        if i * primes[j] &gt; n:            break        is_prime[i * primes[j]] &#x3D; False # 将i*primes[j]标记为非质数        if i % primes[j] &#x3D;&#x3D; 0:            break # 如果i是primes[j]的倍数，就跳出循环</code></pre><blockquote><p>如果在内层循环中，$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</p><p>例如，当$i$为$2 \times 3&#x3D;6$时，在内层循环中，$i$会被$2$筛一次，被$3$筛一次，之后就不需要再被其他数筛了。因此，如果$i$是$primes[j]$的倍数，就可以跳出循环，不需要继续遍历$primes$数组中的其他质数。这样可以减少重复的筛选，提高算法的效率。</p></blockquote><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN &#x3D; 20000; &#x2F;&#x2F; 估计2019个质数的上限vector&lt;int&gt; primes; &#x2F;&#x2F; 存储质数bool isPrime[MAXN]; &#x2F;&#x2F; 标记是否为质数int main() &#123;    fill(isPrime, isPrime+MAXN, true); &#x2F;&#x2F; 初始化标记数组，全部设置为true    for (int i&#x3D;2; i&lt;MAXN; i++) &#123;        if (isPrime[i]) &#123; &#x2F;&#x2F; i是质数            primes.push_back(i); &#x2F;&#x2F; 将i加入质数数组            if (primes.size() &#x3D;&#x3D; 2019) &#123;                cout &lt;&lt; primes.back() &lt;&lt; endl;                break;            &#125;        &#125;        for (int j&#x3D;0; j&lt;primes.size() &amp;&amp; i*primes[j]&lt;MAXN; j++) &#123;            isPrime[i*primes[j]] &#x3D; false; &#x2F;&#x2F; 将i*primes[j]标记为非质数            if (i % primes[j] &#x3D;&#x3D; 0) break; &#x2F;&#x2F; 如果i是primes[j]的倍数，就跳出循环        &#125;    &#125;    return 0;&#125;</code></pre><blockquote><p>可以看到，线性筛法的实现相对简单，但需要注意以下几点：</p><ol><li>对于每个数只需要用它的最小质因子来筛去它的倍数，因此内层循环的终止条件为$i \times primes[j] &gt; n$。</li><li>在内层循环中，如果$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</li><li>在初始化标记数组时，除0和1外都初始化为True。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;我们知道第一个质数是 22、第二个质数是 33、第三个质数是 55……&lt;/p&gt;
&lt;p&gt;请你计算第 20192019 个质数是多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大运行时间：1s&lt;/li&gt;
&lt;li&gt;最大运行内存: 128M&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>leetcode968.监控二叉树</title>
    <link href="2023/03/29/leetcode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/29/leetcode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-29T06:23:53.000Z</published>
    <updated>2023-03-29T06:43:47.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/bst_cameras_01.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/bst_cameras_02.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>贪心算法</li></ul><p>本题是一道贪心算法的题目。通过对题目进行分析，我们可以发现有以下几种情况：</p><p>1.如果一个节点没有被监控，那么它必须要安装一个摄像头。</p><p>2.如果一个节点安装了摄像头，那么它的父节点就可以被监控了。</p><p>3.如果一个节点的子节点被监控了，那么这个节点也可以被监控。</p><p>因此，我们可以采用自下而上的方式进行处理，从叶子节点开始向根节点进行处理。对于每个节点，我们可以有三种状态：</p><p>0：该节点没有装摄像头，且它的子节点中也没有装摄像头的节点，此时应该给他装一个摄像头。</p><p>1：该节点没有装摄像头，但是它的子节点中至少有一个装摄像头的节点，此时应该给他的父节点装一个摄像头。</p><p>2：该节点装摄像头了，因此它无需再安装一个摄像头。</p><p>对于每个节点，我们可以采用递归的方式进行处理。当节点为叶子节点时，它的状态为0。对于其他节点，如果它的子节点中存在状态为0的节点，那么该节点的状态为1，表示需要安装摄像头。如果它的子节点中都存在状态为1或2的节点，那么该节点的状态为0，表示不需要安装摄像头，但是它的父节点需要安装摄像头。如果它的子节点中存在状态为2的节点，那么该节点的状态为1，表示不需要安装摄像头，因为它的子节点已经可以覆盖它了。</p><p>最后，根据根节点的状态来判断是否需要安装摄像头。如果根节点的状态为0或1，那么需要安装一个摄像头。如果根节点的状态为2，那么不需要安装摄像头。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minCameraCover(TreeNode* root) &#123;        int res &#x3D; 0;        if (dfs(root, res) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 根节点未被监控            res++;        &#125;        return res;    &#125;    int dfs(TreeNode* node, int&amp; res) &#123;        if (node &#x3D;&#x3D; nullptr) &#123;            return 2; &#x2F;&#x2F; 空节点不需要监控，返回2        &#125;        int left &#x3D; dfs(node-&gt;left, res);        int right &#x3D; dfs(node-&gt;right, res);        if (left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 左右子节点有未被监控的节点，该节点需要安装摄像头            res++; &#x2F;&#x2F; 安装了摄像头            return 1; &#x2F;&#x2F; return 1是指该节点没有被监控，但是它的子节点中至少有一个被监控的节点。        &#125; else if (left &#x3D;&#x3D; 1 || right &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 左右子节点中至少有一个节点被监控            return 2; &#x2F;&#x2F; return 2是指该节点被监控了。        &#125; else &#123; &#x2F;&#x2F; 左右子节点均被监控            return 0; &#x2F;&#x2F; return 0是指该节点没有装摄像头        &#125;    &#125;&#125;;</code></pre><blockquote><p>其中，dfs函数的返回值为当前节点的状态。如果返回值为0，表示当前节点需要安装摄像头；如果返回值为1，表示当前节点不需要安装摄像头，但是它的父节点需要安装摄像头；如果返回值为2，表示当前节点不需要安装摄像头。res为引用类型，表示安装摄像头的数量。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，我们在树的节点上安装摄像头。&lt;/p&gt;
&lt;p&gt;节点上的每个摄影头都可以监视&lt;strong&gt;其父对象、自身及其直接子对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算监控树的所有节点所需的最小摄像头数量。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode113.路径总和II</title>
    <link href="2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/"/>
    <id>2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</id>
    <published>2023-03-28T06:05:24.000Z</published>
    <updated>2023-03-28T06:24:39.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/pathsumii1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22输出：[[5,4,11,2],[5,8,4,5]]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/pathsum2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2], targetSum &#x3D; 0输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>本题可以使用深度优先搜索（DFS）求解。从根节点开始，依次搜索左子树和右子树，直到找到符合条件的路径。具体来说，我们可以使用递归的方式，每次遍历到一个节点时，将该节点加入路径中，并更新目标值。如果该节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径，将该路径加入结果数组中。否则，继续搜索左子树和右子树。在搜索之后，需要将当前节点从路径中删除，以便回溯到之前的状态。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        dfs(root, targetSum, res, path);        return res;    &#125;    void dfs(TreeNode* node, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;        if (!node) return;  &#x2F;&#x2F; 如果当前节点为空，则直接返回        path.push_back(node-&gt;val);  &#x2F;&#x2F; 将当前节点的值加入路径中        targetSum -&#x3D; node-&gt;val;     &#x2F;&#x2F; 更新目标值        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 如果当前节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径            res.push_back(path);    &#x2F;&#x2F; 将该路径加入结果数组        &#125; else &#123;            dfs(node-&gt;left, targetSum, res, path);   &#x2F;&#x2F; 搜索左子树            dfs(node-&gt;right, targetSum, res, path);  &#x2F;&#x2F; 搜索右子树        &#125;        path.pop_back();  &#x2F;&#x2F; 回溯：将当前节点从路径中删除，恢复到搜索之前的状态    &#125;&#125;;</code></pre><blockquote><p><code>path.pop_back()</code> 是 C++ 中 vector 容器的成员函数，用于删除 vector 容器中的最后一个元素。在本题中，由于我们在搜索过程中需要记录搜索路径，因此使用了一个 <code>path</code> 数组来保存路径。在每次搜索到一个新节点时，我们将该节点的值加入 <code>path</code> 数组中，如果搜索结束后未找到符合条件的路径，需要将该节点从 <code>path</code> 数组中删除，回溯到之前的状态，继续搜索其他节点。因此，在代码中，<code>path.pop_back()</code> 的作用是删除 <code>path</code> 数组中最后一个元素，以便回溯到之前的状态。</p></blockquote><p>时间复杂度分析：</p><p>本题的时间复杂度为$ O(N^2)$，其中 N 表示二叉树的节点数。在最坏情况下，二叉树的形态类似于一个单链表，此时需要遍历所有节点，时间复杂度为 $O(N)$。对于每个节点，由于需要将该节点加入路径中，时间复杂度为$ O(N)$，因此总时间复杂度为 $O(N^2)$。</p><p>空间复杂度分析：</p><p>本题的空间复杂度为 $O(N)$，其中 N 表示二叉树的节点数。递归调用的栈空间最多为 $O(N)$，路径数组的空间为 $O(N)$，因此总空间复杂度为 $O(N)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; 和一个整数目标和 &lt;code&gt;targetSum&lt;/code&gt; ，找出所有 &lt;strong&gt;从根节点到叶子节点&lt;/strong&gt; 路径总和等于给定目标和的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叶子节点&lt;/strong&gt; 是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode110.平衡二叉树</title>
    <link href="2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-27T07:36:41.000Z</published>
    <updated>2023-03-28T06:05:42.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/balance_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/balance_2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：true</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归但空间复杂度较高的解法</li></ul><p>本题可以使用递归的方法来解决。对于每一个节点，我们需要先递归遍历它的左右子树，计算它们的高度差。如果左右子树的高度差超过了1，那么这棵树就不是平衡二叉树。如果左右子树都是平衡二叉树，那么我们可以判断当前节点是不是平衡二叉树：如果左右子树的高度差不超过1，那么当前节点就是平衡二叉树。最后递归返回整棵树的平衡情况。</p><p>在递归函数中，我们需要同时返回当前节点的高度和平衡情况，因此可以使用pair&lt;int, bool&gt;来表示。其中，pair的第一个元素表示高度，第二个元素表示当前节点是否是平衡二叉树。同时，我们需要处理一些边界情况，例如空节点的高度为0，空节点也是平衡二叉树。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root).second;    &#125;        pair&lt;int, bool&gt; checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return make_pair(0, true);        &#125;        auto left &#x3D; checkBalance(node-&gt;left);        auto right &#x3D; checkBalance(node-&gt;right);        if (left.second &amp;&amp; right.second &amp;&amp; abs(left.first - right.first) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return make_pair(max(left.first, right.first) + 1, true);        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return make_pair(0, false);    &#125;&#125;;</code></pre><blockquote><p><code>pair</code>是C++ STL中的一个模板类，用于存储两个不同类型的变量。它将两个变量打包成一个整体，方便传递和使用。</p></blockquote><p>但是它的内存占用过高，因为对于每个节点，它都要单独存一个bool变量用于表示节点是否为二叉树的平衡结点。因此需要进行优化。</p><ul><li>递归，但优化内存占用</li></ul><p>在题目中，我们使用了<code>pair&lt;int, bool&gt;</code>来表示每个节点的高度和平衡情况，但是这种方法会浪费一定的空间，因为每个节点都需要存储一个<code>bool</code>类型的变量。实际上，我们只需要判断每个节点是否平衡，因此可以使用一个<code>int</code>类型的变量来表示平衡情况：-1表示不平衡，非0表示平衡并且代表节点的高度。这样就可以减少空间的使用。</p><p>同时，我们可以将返回值从<code>pair&lt;int, bool&gt;</code>改为<code>int</code>，表示当前节点的高度。如果当前节点不是平衡二叉树，那么直接返回-1，否则返回节点的高度。</p><p>C++代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root) !&#x3D; -1;    &#125;    int checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return 0;        &#125;        int left &#x3D; checkBalance(node-&gt;left);        int right &#x3D; checkBalance(node-&gt;right);        if (left !&#x3D; -1 &amp;&amp; right !&#x3D; -1 &amp;&amp; abs(left - right) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return max(left, right) + 1;        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>迈向智能云：云系统容错方法回顾</title>
    <link href="2023/03/27/%E8%BF%88%E5%90%91%E6%99%BA%E8%83%BD%E4%BA%91%EF%BC%9A%E4%BA%91%E7%B3%BB%E7%BB%9F%E5%AE%B9%E9%94%99%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE/"/>
    <id>2023/03/27/%E8%BF%88%E5%90%91%E6%99%BA%E8%83%BD%E4%BA%91%EF%BC%9A%E4%BA%91%E7%B3%BB%E7%BB%9F%E5%AE%B9%E9%94%99%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE/</id>
    <published>2023-03-27T02:08:06.000Z</published>
    <updated>2023-03-29T14:10:51.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems"><a href="#Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems" class="headerlink" title="Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems"></a>Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文介绍了云计算中提出的容错方法的最新研究进展。本文将容错方法分为三类：1）反应式方法（RAMs）；2）预防性方法（PRMs）；和3）弹性方法（RSMs）。RAMs允许系统进入故障状态，然后尝试恢复系统。PRMs倾向于通过实施机制来避免错误影响系统，从而防止系统进入故障状态。另一方面，最近出现的RSMs旨在最小化系统从故障中恢复所需的时间。本文还探讨了机器学习和人工智能在RSM领域中如何发挥作用以最小化恢复时间。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>首先，介绍了云计算的概念和特点，指出云计算作为一种新型的计算模式，具有高度的可扩展性、灵活性和可靠性等优势。然而，由于云计算系统规模庞大、复杂度高，因此故障率也相应增加。因此，在云计算中实现容错是至关重要的。</p><p>接着，本文介绍了目前在云计算领域中已经提出的容错方法，并指出这些方法存在一些局限性和不足之处。</p><p>常见的容错方法被分类为三类：反应式方法（RAMs）、预防性方法（PRMs）和弹性方法（RSMs）。其中，反应式方法指的是系统在发生故障后才进行恢复；预防性方法则是通过实施机制来避免错误影响系统，从而防止系统进入故障状态；弹性方法旨在最小化系统从故障中恢复所需的时间。具体而言，反应式方法（RAMs）允许系统进入故障状态，然后尝试恢复系统；预防性方法（PRMs）倾向于通过实施机制来避免错误影响系统，从而防止系统进入故障状态；最近出现的弹性方法（RSMs）旨在最小化系统从故障中恢复所需的时间。它们常用的技术如下：</p><ol><li>反应式方法（RAMs）：基于传统的分布式系统容错技术，如复制、检查点&#x2F;重启、检测和恢复等。</li><li>预防性方法（PRMs）：主要采用监控、预测和抢占等技术。在正常操作下，PRMs不断监视系统状态，并在可能发生系统故障时立即调用避免故障的步骤。 </li><li>弹性方法（RSMs）：主要采用快速恢复和自愈能力等技术。RSMs旨在最小化系统从故障中恢复所需的时间，以便尽快将系统恢复到正常状态。</li></ol><p>而传统的反应式方法（RAMs）只能在系统发生故障后才能进行恢复，而预防性方法（PRMs）则需要消耗大量资源来避免错误发生。因此，需要进一步研究新型的容错方法来解决这些问题。 </p><p>在Introduction中，作者详细描述了PRMs和RSMs之间的区别。具体而言，作者指出PRMs主要实现故障预测和避免方法，但没有学习和适应方法；而RSMs则通过不断更新模型和学习结构来适应云系统的动态变化，并根据自身计算环境特征自适应地学习和减轻PRMs的影响。因此，虽然PRMs实现了故障预测，但没有学习和适应方法；而RSMs则通过自适应地学习计算环境特征来减轻PRMs的影响，并在系统发生故障时快速恢复。</p><p>最后，本文介绍了本文所采用的研究框架，并概述了本文各个章节所涉及到的内容。</p><p><img src="http://cdn.leafii.top/img/image-20230328151324660.png" alt="image-20230328151324660" loading="lazy"></p><h2 id="Cloud-Fault-Tolerance-Model"><a href="#Cloud-Fault-Tolerance-Model" class="headerlink" title="Cloud Fault Tolerance Model"></a>Cloud Fault Tolerance Model</h2><p>故障可以是系统中发生的影响系统正常运行的任何事件。通常，故障是系统正常运行的<strong>根本损害</strong>，它们会导致错误。错误反过来会导致系统故障。容错性是衡量系统在出现故障时继续为其客户请求提供服务的能力。本文定义了四种系统错误，分别是瞬态故障（Transient Faults），间歇性故障（Intermittent Faults），永久性故障（Permanent Faults），拜占庭式故障（Byzantine Faults）：</p><ol><li>瞬态故障（Transient Faults）：指系统中的某个组件或部件在短时间内发生故障，但之后又能够自行恢复正常工作。这种故障通常是由于电压波动、电磁干扰等原因引起的。 </li><li>间歇性故障（Intermittent Faults）：指系统中的某个组件或部件在不同时间点上出现故障，但每次故障持续时间很短，并且在下一次出现之前可能会有很长一段时间没有任何问题。这种故障通常是由于松动连接、温度变化等原因引起的。</li><li>永久性故障（Permanent Faults）：指系统中的某个组件或部件发生了无法自行恢复的故障，需要进行更换或修理才能恢复正常工作。这种故障通常是由于硬件损坏、软件错误等原因引起的。</li><li>拜占庭式故障（Byzantine Faults）：指系统中的某个组件或部件出现了任意形式的错误，包括发送错误信息、篡改数据等。这种错误通常是由于恶意攻击、软件漏洞等原因引起的。</li></ol><h2 id="Fault-Tolerance-Challenges-in-cloud-systems"><a href="#Fault-Tolerance-Challenges-in-cloud-systems" class="headerlink" title="Fault Tolerance Challenges in cloud systems"></a>Fault Tolerance Challenges in cloud systems</h2><p>云计算的特点使得云系统容错面临着以下挑战：</p><ul><li>Heterogeneity and the lack of standards（异质性和缺乏标准）：不同硬件和操作系统供应商基于自己的架构部署云，因此可能在同一个大型云系统中部署在异构平台上的组件。这给容错解决方案的设计带来了压力，因为它们必须考虑整个容错解决方案中每个操作系统供应商的方面。因此，在设计容错解决方案时需要考虑到这些异构性和缺乏标准的挑战。</li><li>Need for automation（需要自动化）：未来是智能的，并需要自动化。随着托管云系统的虚拟机数量呈指数级增长，人类管理这些系统将变得几乎不可能。因此，需要考虑自动化来管理这些系统的容错解决方案。然而，自动化面临着缺乏通用框架（API）的挑战，这些框架可以应用于任何云系统以实现容错解决方案，并且需要进行很少的努力（即需要插入式容错）。因此，在未来的容错解决方案中，自动化将成为主要趋势。</li><li>Downtime in the clouds（云中的停机时间）：云架构由多个地理位置分布和由不同供应商管理的数据中心组成。一个数据中心的完全停机可能会影响许多组织。每个组织对云的服务级别协议（SLA）不同，容错提供商必须确保满足所有组织的SLA。因此，在设计容错解决方案时需要考虑到这些挑战。</li><li>Consideration for RPO and RTO（对 RPO 和 RTO 的考虑）：容错解决方案的目标是将恢复点目标（RPO）和恢复时间目标（RTO）都降到最低。其中，<strong>RPO是服务器故障时可能丢失的数据量</strong>，而<strong>RTO是系统在故障后重新运行所需的时间</strong>。通过使用弹性方法来不断最小化RPO和RTO，可以设计出容错解决方案。弹性方法的学习功能可以被定义为最小化RPO和RTO。因此，在设计容错解决方案时需要考虑到这些目标。</li><li>Workloads in the cloud(云计算中的工作负载):云计算中有两种工作负载类型，即云原生和云启用工作负载。云原生应用是完全使用云模型构建的应用程序，由多个服务组成，每个服务都具有弹性、韧性，并可用于组合其他应用程序。而云原生工作负载是由纯云原生应用程序生成的计算工作负载。在某些情况下，不可能将应用程序的所有组件迁移到云上，这导致应用程序的某些组件在企业内部托管，而另一些组件在云上托管。这通常被称为“云启用”。因此，在设计容错解决方案时需要考虑到这些工作负载类型的差异。在这种情况下，主动和弹性方法都应该适用于处理云原生和云活动模型的容错要求。</li></ul><h2 id="Fault-tolerance-and-reliability-in-the-clouds"><a href="#Fault-tolerance-and-reliability-in-the-clouds" class="headerlink" title="Fault tolerance and reliability in the clouds"></a>Fault tolerance and reliability in the clouds</h2><p>虚拟化技术用于提供计算资源，然后这些资源属于许多云用户。 这种资源虚拟化导致了复杂的基础架构设计，这些设计将硬件暴露在它们最初并非设计用于并导致故障的条件下。 故障可能发生在硬件、系统（主机或 VM）、软件或操作员级别。 云系统中的故障可能导致系统发生灾难性中断，从而影响云系统的可靠性。</p><p>云系统的可靠性是衡量云系统在预定条件下向用户提供服务的好坏程度。 此类条件通常定义为 QoS，它构成云服务提供商与客户（或用户）之间合同的一部分。 云系统的可靠性最终取决于承载服务的虚拟机的容错能力。一般来说，云系统中用于容错的技术涉及<strong>检查点 [4]、冗余 [3]、[7] 和网络带宽</strong> [9]、[10] 的优化。 检查点可以发生在进程级别或 VM 级别。 进程或 VM 状态在执行期间不断被保存。 在进程失败的情况下，执行将从检查点开始恢复，而不是从头开始。 如果 VM 发生故障，VM 映像将恢复到另一台机器，并且进程从发生故障的 VM 的检查点继续。</p><p>大多数关于云系统可靠性的研究都集中在优化检查点算法和虚拟机冗余上。刘等人。 [3] 和周等人。 [4] 描述了一种<strong>冗余 VM 方法</strong>，该方法在选择一组 VM 托管服务器时考虑了网络拓扑结构，目的是最大限度地减少网络资源消耗。 周等。 [5] 提出了一种<strong>减少虚拟机检查点期间使用的存储</strong>的解决方案。 最后，周等人。 [5] 对<strong>增强云可靠性</strong>的研究进行了研究。 在大多数情况下，云服务的采用涉及将托管在组织数据中心的现有系统迁移到云环境。 由于低维护成本、高可扩展性和按使用付费模式等特性，组织被云托管的价值主张所吸引。 除了节省托管成本外，此类迁移还应提高系统的<strong>整体可靠性</strong>。 将一些成熟的企业系统迁移到云端并不是一个容易的决定。 尽管将系统迁移到云端有明显的好处，但组织仍然必须根据为此类决策提供信息所需的科学方法做出务实的决策。 此外，还需要考虑重要的考虑因素，例如系统安全性（由组织的安全策略管理）。 一些系统组件最好在本地私有环境中运行。 因此，需要一些<strong>指南</strong>来帮助实施最佳的云迁移结构。<br>邱等。 [11] 介绍了一个<strong>基于可靠性的框架</strong>（ROCloud），在考虑系统上的云迁移时，它可以用作决策制定的一部分。 ROCloud 由两种算法（ROCloud1 和 ROCloud2）组成，用于根据应用程序的结构和历史可靠性信息对其进行<strong>排名</strong>。 ROCloud1 和 ROCloud2 分别用于对普通应用程序和混合应用程序进行排名。 排名结果用于自动选择要使用的最佳容错策略。 该框架使用<strong>四种常见的容错策略</strong>，即 Recovery Block、N-Version Programming、Parallel 和 VM Restart。 每个策略根据<strong>三个参数</strong>对每个系统组件进行排名：响应时间、资源成本和故障率。 进行了实验，结果表明，仅通过过滤一些容易出错的组件并将它们移动到云中，就有了显着的改进。</p><h2 id="Taxonomy-of-fault-tolerance-methods"><a href="#Taxonomy-of-fault-tolerance-methods" class="headerlink" title="Taxonomy of fault tolerance methods"></a>Taxonomy of fault tolerance methods</h2><p>在这部分中，论文详细描述了对容错方法的三个分类，即ReActive Methods (RAMs)、PRoactive Methods (PRMs)和ReSilient Methods (RSMs)。其中，每个分类用到的关键技术如下：</p><ul><li>RAMs（反应性方法）：重点主要是系统恢复。系统的状态在恢复过程中不断保存和使用。使用的关键技术是复制、检查点和重新启动。</li><li>PRMs（主动方法）：主要关注防止系统完全中断。这些方法通过持续监控系统和进行故障预测来工作，以便在故障发生之前很好地预防故障的影响。使用的关键技术是云资源的监控、预测和重新分配。</li><li>RSMs（弹性方法）：这些方法与主动方法具有许多共同特征。 RSM 通过预测故障和实施方法来运行以避免或最小化此类故障对系统的影响。除了监控和预测之外，弹性方法还通过与托管环境交互并结合智能学习来调整（微调）系统容错能力。这是 RSM 与 PRM 显着不同的地方。</li></ul><p><img src="http://cdn.leafii.top/img/image-20230328161146682.png" alt="image-20230328161146682" loading="lazy"></p><h3 id="Reactive-Meghods"><a href="#Reactive-Meghods" class="headerlink" title="Reactive Meghods"></a>Reactive Meghods</h3><p>反应性方法用于减轻故障发生后的影响。根据当前文献，用于反应式容错的关键技术包括检查点&#x2F;重启、复制、SGuard、重试、自定义异常处理、任务重新提交和救援工作流。本节回顾了有关 RAM 的选定论文。</p><h4 id="Checkpointing-x2F-Restarting"><a href="#Checkpointing-x2F-Restarting" class="headerlink" title="Checkpointing&#x2F;Restarting"></a>Checkpointing&#x2F;Restarting</h4><p>检查点&#x2F;重新启动技术通过<strong>不断保存系统状态</strong>来工作，如果发生故障，作业将从最近的状态开始。 这些技术适用于长时间运行的作业。 以下段落将总结一些关于基于检查点的算法的论文，即[26]、[27]、[28]、[29]、[30]、[31]、[32]、[33]、[34] ]、[35]、[36]、[37]。 这些论文的选择基于他们如何将检查点纳入他们的解决方案的变化。</p><p>冈村等。 [27] 提出了一种基于强化学习的动态检查点方案。 这种技术在系统故障分布未知的情况下会变得很有用。 首先，检查点问题被建模为半马尔可夫决策过程。 其次，应用具有代表性的强化学习算法（称为 Q-learning 算法）。 Q-learning 允许构建自适应检查点方案。 该算法由通过学习和交互体验适应环境的智能 体组成。</p><p>穆迪等。 [29] 描述了一种新颖的多级检查点系统。 这种方法旨在降低不断增长的高性能计算 (HPC) 系统的检查点成本。 系统定义了一套 L checkpointing 机制。 每个级别代表一个具有不同成本和弹性级别的检查点机制，最终映射到所使用的存储类型，例如本地内存、USB、远程内存、使用软件 RAID、本地 SSD 或远程文件系统。 第一个级别 1 是成本最低的级别，最后一个级别 L 是成本最高的级别。 较低级别采用轻量级检查点，这些检查点具有较低的开销成本，因此非常适合处理最常见的故障模式。 类似地，较高级别具有昂贵的检查点成本，并且用于不太频繁的故障模式。 Scalable Checkpoint&#x2F;Restart (SCR) 库用于实现系统，它可以将检查点保存到计算节点上的 RAM、Flash 或磁盘。 该系统使用概率马尔可夫模型进一步建模，该模型可用于预测当前和未来系统的性能。 总体结果表明，当前和未来系统的并行文件系统负载<strong>减少了两次</strong>。 迪等人。 [30] 通过开发一种进一步优化级别选择的方法，进一步优化了多级检查点。 此外，Di 等人。 [33] 通过优化核数不确定的系统的检查点间隔来改进多级检查点。</p><p>奥林纳等。 [32] 引入了协作检查点技术，这是一种健壮的检查点算法，由一组规则和策略组成，使检查点决策能够由应用程序、编译器和操作系统（看门人）共同做出。 在这种方法中，开发人员在代码中的最佳位置插入检查点请求，编译器进一步优化这些检查点请求，看门人进行最终调用以授予或拒绝检查点。 网守考虑许多系统运行时因素来授予&#x2F;拒绝检查点请求，例如 CPU 负载、磁盘 I&#x2F;O、网络 I&#x2F;O、作业调度队列、故障事件预测和 QoS 保证。 奥林纳等。 [32] 还表明协作检查点简单实用，可以应用于现有应用程序检查点机制之上。 进行了许多实验，表明协作检查点<strong>优于</strong>周期性检查点。 Jangjaimon 和 Tzeng [35] 提出了一种增强的自适应增量检查点 (EAIC) 容错机制。 EAIC 旨在基于未来的云计算资源即服务 (RaaS) 模型，为托管在多核云基础设施上的多线程云应用程序提供 FT。 调整后的马尔可夫模型 (AMM) 的构建是为了满足现场实例 (SI)、保留实例 (RI) 和硬件故障的需要。 在 RI 中，客户购买预先配置资源（如 CPU、IO 或内存）的预留实例。 对于 SI，客户可以竞标未使用的资源，而且价格通常比 RI 低得多。 结果表明，应用程序运行时间和成本的<strong>显着减少都归功</strong>于多级检查点的使用。 这个观察是在使用 RI 和 SI 时进行的。 赵等。 [36] 提出了一种新方法，该方法确定如何使用对等检查点在云计算中提供弹性和联合可靠性优化。 总的来说，这项工作 [36] 利用云实用程序的检查点技术在数据中心的资源限制下共同最大化可靠性。 主要关注点对点检查点，用于提高网络资源限制下的可靠性。 在正常情况下，VM 映像被发送到中央存储服务器，这可能会由于高带宽使用率而导致网络拥塞。 为了缓解这个问题，点对点检查点是一种分布式方法，云运营商可以选择在具有足够带宽的对等点之间路由检查点的位置。 <strong>仿真结果</strong>表明，与随机点对点检查点和集中式检查点相比，这种方法显着提高了可靠性。 Amoon [37] 描述了一种基于检查点和复制的云计算自适应容错框架。 该框架在某种意义上是<strong>自适应的</strong>，它能够选择最佳的容错方法用于客户的任务。 此外，该框架还提出了一种复制算法，可以自适应地确定应用程序所需的副本数量。 通过这种方式，复制仅适用于发生故障时对云有较大性能影响的虚拟机。 检查点也是<strong>自适应的</strong>，检查点间隔的长度是根据虚拟机的故障概率自适应确定的。</p><h4 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h4><p>复制技术的工作原理是复制一些系统组件，然后将这些组件同时部署到不同的资源中。该技术旨在使系统健壮，提高可用性并保证作业的执行 [9]、[26]、[38]、[39]、[40]、[41]、[42]、[43] , [44], [45], [46], [47]</p><p>Bodı k 等人。 [9] 提出了一种可用于云迁移的新算法。 云迁移的一个挑战是找到一个既能满足容错又能降低带宽成本的最佳部署模型。 该算法还确定了将系统组件复制到云中并实现最佳带宽和容错的最佳方式。 将系统部署到云中的主要挑战之一是服务器可用性。 这与可用带宽直接相关。 数据中心采用本地冗余构建，可让本地服务器在维护或维修时脱机。 当整个数据中心因灾难或网络设备维护而离线时，挑战就来了。 这通常会导致大量服务器脱机。 可用带宽与云系统的部署架构相关联。 部署在一个数据中心的云系统容易出现服务器不可用、网络拥塞等各种网络故障。 如果网络连接完全中断，数据中心将成为单点故障。 增加部署系统的数据中心数量会直接增加带宽使用，但会显着提高容错能力。 因此，<strong>在提供高容错性和减少带宽使用之间找到良好的平衡存在挑战。</strong> 这可以通过 [9] 中描述的算法来解决。 Balasubramanian 和 Garg [38] 描述了分布式系统中基于融合数据结构的故障管理解决方案，旨在处理<strong>数据崩溃和拜占庭故障</strong>。 融合数据结构的设计方式使得主数据结构的恢复可以通过非常有限的复制次数来完成。 融合数据结构的主要<strong>优点</strong>是节省了存储数据结构副本所需的存储空间。 该技术主要适用于基于队列、栈、向量、二叉搜索树、哈希映射和哈希表等数据结构的解决方案的分布式存储。 融合数据结构还大大<strong>节省</strong>了从故障中恢复所需的计算资源。</p><p>库利等人。 [39] 目前 Remus 主要基于检查点和复制。 Remus 的目标是实现一种透明的容错技术，不需要对现有的云应用程序进行任何更改。 在 Remus 中，托管应用程序的虚拟机被配对成一个主虚拟机和一个辅助虚拟机。 Remus 中的复制是异步完成的。 然后采用各种技术来确保主要和次要之间的异步状态复制。 主 VM 的输出被缓冲并异步复制到辅助 VM。 主 VM 在其状态被检查点后立即恢复执行，并且不等待辅助 VM 的确认。 Remus 结合了一种简单的磁盘缓冲技术来保持主虚拟机和辅助虚拟机的磁盘同步。 在主 VM 上发出的磁盘写入立即提交到其本地磁盘，它们同时传输到辅助 VM 上的缓冲区。 辅助 VM 在检查点后提交到其本地磁盘。 </p><p>Castro 和 Liskov [42] 描述了拜占庭容错 (BFT) 协议。 BFT 协议主要<strong>旨在</strong>解决可靠性和保证系统的高可用性。 大多数 BFT 系统对于实际实施而言过于昂贵，因此，据我们所知，到目前为止，还没有关于实施 BFT 技术的商业数据中心的报道。 提供异步、分布式、客户端-服务器系统的 BFT 解决方案至少需要 $(3f+1)$ 个副本，其中一个为主，其余为备份，其中$ f $是在任何给定点可以容忍的最小故障数时间。 BFT 解决方案具有高资源消耗，这可以归因于它们处理故障的方式。 BFT 解决方案依赖于服务器状态机复制 (SMR)，其中每个副本都以相同的顺序执行相同的请求。 副本使用拜占庭协议来就一组给定请求的顺序达成一致。 订单达成一致后开始执行，然后使用多数表决方案选择正确的答案发送回客户端。 以这种方式，在该投票阶段也可以检测到有故障的服务器。</p><p>郑等。 [46] 提出了一种基于组件排名（称为 FTCloud）的可配置容错方法。 FTCloud由两种算法组成； 第一种算法使用组件执行结构并监视执行频率以构建显着组件排名。 第二种算法使用这些重要组件排名以及系统设计人员输入的容错要求来识别云应用程序的重要组件。 完成组件排名后，该算法会自动为重要的云组件确定最佳容错策略。 最重要的观察是，通过容忍一小部分最重要组件的故障，云应用程序的可靠性得到显着提高。 用于重要组件的最佳容错策略基于冗余和复制。 贾瓦尔等人。 [47] 介绍了一种创新的、系统级和模块化的解决方案，用于在云中创建容错。 该解决方案向应用程序开发人员隐藏了 FT 实施细节。 因此，它创建了一个服务层，开发人员可以在其中请求 FT 作为服务。 用户可以指定和应用所需的 FT 级别，而<strong>无需了解</strong>用于实现容错的底层技术。 该解决方案假定客户端应用程序部署在虚拟机上，因此将 FT 的粒度限制为 VM 实例。 具体来说，该方案利用冗余和复制来实现容错，创建多个虚拟机副本，并在出现故障时随时可用以接管。</p><h4 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h4><p>重试技术的工作原理是简单地多次重试<strong>同一资源</strong>上的失败请求 [48]、[49]。</p><p>Ramalingam 和 Vaswani [49] 提出了一种解决方案，该解决方案依赖于重试技术来解决由于云系统中的进程或通信故障引起的故障。在这样的环境中，失败的请求只是重试。重试机制依赖于系统的无能。 Indepotence 被描述为一个标准，使得在存在重复请求和失败的情况下从应用程序获得的结果与在没有重复请求和失败的情况下从这样的应用程序获得的结果<strong>完全相同</strong>。 Indepotence 由一种名为 FAIL 的语言形式化，该语言受云平台的影响。本质上，语言 FAIL 将流程失败、重复请求、数据和事务形式化。 FAIL 的最终目标是保证无能的云服务。这样的系统是去中心化的，不需要分布式协调。结果，这产生了一个完全分散的容错实现，它处理相同请求和进程失败的多次重试。</p><p>王等。[48]分析了重试容错技术对云服务的性能影响。这是通过构建云服务处理时间的数学模型来实现的。该模型后面是处理时间的概率分布，以分析在出现故障时重试作业的影响。还通过计算在定义的阈值下可以成功服务的请求的百分比来反映服务质量。将使用重试技术的云系统的性能与使用 FT 的检查点技术的云系统的性能进行了比较。结果表明，根据检查点方法的恢复率，重试技术的性能可能比检查点技术更好或更差。</p><h4 id="Task-Resubmission"><a href="#Task-Resubmission" class="headerlink" title="Task Resubmission"></a>Task Resubmission</h4><p>在任务重新提交中，当检测到失败的任务时，它会重新提交到相同或<strong>不同的资源</strong>以执行 [44]。</p><p>Plankensteiner 等人。 [44] 描述了重新提交影响启发式，并用它来改进基于重新提交和复制技术的容错方法。 这种方法通常用于在分布在云端的工作流系统中实现容错。 改进基于引入称为重新提交影响的新算法。 重新提交和复制是广泛用于分布式系统容错的基本技术。 重新提交通过对失败资源或新资源重新执行单个任务来操作，这会显着增加任务完成时间。 复制将同一任务的多个副本同时执行到多个资源，并且存在资源使用率高的缺点。 为了<strong>在重新提交和复制之间找到平衡</strong>，该算法计算 RI（Replication Index） 启发式算法，该算法用于描述重新提交任务对工作流整体执行的影响。 RI 是为每个工作流程定义的，它用于推断生成的重复次数。 实验结果表明，与保守方法相比，RI 显着减少了超过 42% 的资源消耗。 除此之外，RI 不会对任务完成率和整体工作流性能产生负面影响。</p><h4 id="Custom-Exception-Handling"><a href="#Custom-Exception-Handling" class="headerlink" title="Custom Exception Handling"></a>Custom Exception Handling</h4><p>自定义异常处理包括软件开发人员将代码插入应用程序的方法，以便它可以在运行时处理特定故障 [50]。</p><p>刘等人。 [50] 提出了一个框架，用于解决通过业务流程执行语言 (BPEL) 引擎实现编排的事务性 Web 服务 (FACTS) 的容错问题。 Web服务主要用于开发现代商业应用程序。 FACTS 是六个组件的集合，即 EXTRA、WS-BPEL 设计器、规范模块、验证模块、实施模块和计划模块。 EXTRA 组件提供了一组高级异常处理策略，这些策略在标准的 WS-BPEL 内置异常和事务处理工具上运行。复合 Web 服务的容错需求通常源自业务需求。服务设计人员使用事件-条件-操作 (ECA) 规则来定义处理故障的逻辑。 ECA 规则又基于 EXTRA 模块中定义的异常策略。验证模块用于验证故障处理逻辑。它通过评估 ECA 规则必须遵守的原则来做到这一点。</p><h4 id="Rescue-Workflow"><a href="#Rescue-Workflow" class="headerlink" title="Rescue Workflow"></a>Rescue Workflow</h4><p>救援工作流是一种旨在解决基于工作流的系统容错的技术。 即使任务失败，工作流也可以继续，<strong>直到</strong>如果不处理失败的任务就无法继续 [51]、[52]。 对基于工作流的系统的容错机制更感兴趣的读者可以参考 [51]。 Hernandez 和 Cole [52] 提出了<strong>救援有向无环图</strong>（Rescue DAG），这是一种基于倒带和迁移的可靠工作流 DAG 调度机制。 该机制依赖于两个关键组件，即 DAG Manager (DAGMan) 和 Rescue DAG。 DAGMan 是元调度器，它负责管理整个工作流，包括将工作流调度到计算资源上。 DAGMan 还包含容错机制。 该机制执行 DAG 工作流失败部分的重新提交。 当一个 DAG 的任务失败时，DAG 中的剩余任务将继续执行，直到由于 DAG 工作流中的任务依赖性而无法继续执行。 在这种情况下，DAGMan 会输出一个名为 Rescue DAG 的特殊文件，其中包含有关成功任务和不成功任务的足够详细信息。 然后使用 Rescue DAG 来恢复工作流。 重新提交失败的任务。 成功的任务不会重新执行，因此可以节省计算资源和时间。</p><h4 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h4><p>负载均衡是云系统容错和运行的关键。 许多服务器在被客户端请求淹没后可能会因计算资源（CPU 或 RAM）耗尽而崩溃。 为了减少此类故障，云系统必须实施负载平衡作为负载保护的第一道防线 [53]、[54]、[55]、[56]。 传统的集中式负载均衡机制不适用于云系统。 云系统具有高度可扩展性，它们建立在分布式服务器上，这些服务器可以托管在多个数据中心（取决于云系统的架构）。 由于此类系统的规模和复杂性，无法将计算请求集中分配给服务器。 蜜蜂觅食行为 [55]、有偏随机抽样 [56] 和主动聚类 [53] 是云系统最常用的负载平衡算法。 分布式负载平衡算法通常具有内置机制，使它们能够协调公平地处理负载。 [54] 中介绍了这些算法的比较研究。</p><h4 id="N-Version-and-Recovery-Block"><a href="#N-Version-and-Recovery-Block" class="headerlink" title="N-Version and Recovery Block"></a>N-Version and Recovery Block</h4><p>N-version 是一种多版本编程模型。多个功能相同的程序是由不同的团队根据同一组需求规范开发的。团队独立工作，根本不交流。 N版本的思想是基于这样一个事实，即独立开发的程序大大降低了两个或多个版本中出现类似故障的概率。恢复块 (RB) 利用输入数据的不同表示来提供设计错误的容忍度 [57]、[58]、[59]、[60]、[61]。</p><p>N-Version 最近已进入云安全 [58] 和恶意攻击（反病毒 [57]）应用程序。 [60] 中介绍了 N 版本和容错之间关系的一些一般背景。 在接下来的段落中，我们将讨论一些研究工作，其中 N 版本技术已被用作云场景中容错的一部分。 </p><p>彭等。 [59] 回顾了增强型 N 版本编程 (ENVP) 和扩展恢复块 (ERB) 技术。 ENVP 和 ERB 可以联合用于提高 Web 服务 (WS) 的可靠性，因此它们对提高云系统的容错能力有直接的贡献。 ENVP 和 ERB 分别是其原始对应的 N 版本 (NVP) 和恢复块容错机制的扩展。 这些技术已经适用于为基于 WS 的容错系统提供支持。 NVP 通过利用多个功能等效的软件组件（或版本）提供容错能力。 另一方面，RB 使用不同的输入数据表示来容忍软件设计错误。</p><p>ENVP 和 ERB 的逻辑在中间件中实现，中间件负责处理服务用户（客户端）和服务提供者（服务）之间的交互。 NVP 和 RB 都通过在中间件中引入验收测试 (AT) 组件进行了扩展。 AT 组件用于在将 WS 的输出传递给决策管理器 (DM) 之前评估其输出的正确性。 实验结果表明，增加更多的 AT 组件可以提高系统的整体可靠性。</p><h3 id="Proactive-Methods"><a href="#Proactive-Methods" class="headerlink" title="Proactive Methods"></a>Proactive Methods</h3><p>主动方法持续监控系统并进行故障预测，以便在故障发生之前很好地预防故障的影响。 在监控中，系统不断地执行故障预测算法来评估系统的状态，以便采取必要的措施来防止故障。 对于运行在虚拟化环境中的云系统，此类故障管理技术更多地依赖于虚拟平台提供的迁移、暂停&#x2F;取消暂停功能。 根据当前文献，用于主动容错的关键技术包括软件更新、自我修复、抢先迁移、监控和 SGuard。 本节回顾了有关 PRM 的选定论文。</p><h4 id="Software-Rejuvenation"><a href="#Software-Rejuvenation" class="headerlink" title="Software Rejuvenation"></a>Software Rejuvenation</h4><p>软件更新 (SR) 是为定期重启而设计的 [62]、[63]、[64]，它基本上涉及优雅地终止系统并重新启动它。 SR 由另外两种技术补充：1）错误计数；和 2) N 版本编程。错误计数也称为“数黑羊”。这是一种在错误发生时对错误进行计数的技术，这些错误计数的记录会被保存下来，以便它可以用于升级和加速恢复过程。</p><h4 id="Self-Healing"><a href="#Self-Healing" class="headerlink" title="Self-Healing"></a>Self-Healing</h4><p>自愈技术是系统的一项功能，可以自动检测、诊断和修复软件和硬件故障。此类系统由部署在多个 VM 上的多个组件组成 [65]、[66]、[67]、[68]。</p><h4 id="Preemptive-Migration"><a href="#Preemptive-Migration" class="headerlink" title="Preemptive Migration"></a>Preemptive Migration</h4><p>抢先迁移是虚拟化环境的一种重要方法。它提供了将程序执行从一台机器实时迁移到另一台机器的机制。此技术可防止即将发生故障的系统组件影响系统的性能。这是通过监视和将组件从即将无法在更稳定的节点上运行的节点移开来实现的 [3]、[13]、[69]、[70]、[71]、[72]、[73] , [74], [75], [76], [77], [78]。 Applying preemptive migration for proactive FT [69] 提出了一种依赖于抢先迁移的主动容错方法的体系结构。</p><p>恩格尔曼等人。 [69] 定义了一种架构，该架构将服务器作为主动 FT 的基础。 该体系结构基于虚拟机（VM）的预先迁移，因此适用于云计算。 此外，还提供了实施选项的分类。 分类由实施所采用的监控策略定义。 该架构的核心是一个反馈回路控制机制，它构成了系统健康监测的一部分。 系统及其应用程序受到监控，并采取预防措施将应用程序组件从预计会发生故障的节点迁移到更健康的节点。 确定了监控系统健康状况的一些挑战。 其中一个关键挑战是每个解决方案目前都在使用自己的一组指标来测量和评估系统组件之间的健康和接口。 需要标准指标和接口。 </p><p>Nagarajan 等人。 [70] 为消息传递接口 (MPI) 应用程序的主动 FT 提供了一种自动和透明的机制。 该机制将虚拟化技术与健康监控和抢先迁移相结合，以实施主动 FT 解决方案。 使用了 XEN 虚拟化环境。 该解决方案利用 XEN 的实时迁移功能，允许客户操作系统与其正在运行的任务一起重新定位到另一个节点。 当检测到节点的健康状况恶化时，将触发迁移。 抢占式迁移机制运行良好，消除了迁移开销。 MPI 任务在迁移过程中继续执行。</p><p>刘等人。 [3] 提出了一种主动协调 FT (PCFT) 解决方案，旨在为并行云系统提供容错能力。 VM 协调机制用于预测恶化的物理机 (PM)。 恶化 PM 上的 VMS 迁移到最佳目标 PM。 机器性能下降的预测<strong>基于对 CPU 温度的监控</strong>。 该算法的复杂性在于找到一个最佳目标 PM，它必须确保效率、有效性和可扩展性要求。</p><h4 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h4><p>预测构成了主动容错算法的核心。提前预测故障，以便云系统有机会采取纠正措施来避免或减少故障的影响 [13]、[17]、[79]、[80]、[81]、[82] , [83], [84]。萨尔夫纳等。 [83]提供了一种通过调查的预测方法。 Tikotekar 等人提出了一个可用于评估各种 FT 方法和政策的模拟框架。 [84]。该框架非常重视使用预测组件的主动 FT。</p><p>瓦莱等人。 [13] 描述了主动容错的通用框架。 该框架基于故障预测，主要目标是避免故障。 当检测到故障时，系统会使用底层虚拟化平台的故障管理功能，例如暂停&#x2F;取消暂停或迁移进程或整个虚拟机节点。 故障预测器利用计算节点上的<strong>本地信息</strong>来预测当前发生故障的概率，故障预测器定期分析本地系统日志，如果检测到异常行为则产生告警事件。 进行了<strong>两个实验</strong>，作为证明该框架在进行迁移时对计算开销的有效性的一部分。 第一个实验是使用 XEN 虚拟化平台完成的，并测量了虚拟机占用空间对迁移成本的影响。 影响是根据虚拟机内存与总迁移时间（以秒为单位）的函数来衡量的。 第二个实验中，使用专为评估容错策略而设计的模拟器进行 [84]。 发现模拟结果与使用 XEN 的物理实验结果一致，得出的结论是该框架减少了计算开销。 </p><p>平托等人。 [17] 通过结合预测来增强 Hadoop 集群中的容错能力。 预测是使用<strong>支持向量机</strong> (SVM) 模型实现的。 SVM 是具有相关学习算法的监督学习模型，这些算法分析用于分类和回归分析的数据。 SVM 分类器托管在监控 PC 上，以对系统故障进行智能预测。 标准的 Hadoop 架构包括一个级别的容错，其中作业从故障节点重新安排到网络中的其他节点。 这会导致效率低下，因为它可能需要重新处理已经完成的子任务。 SVM 预测模型用于更早地预测故障，以便更早地做出重新安排工作的决策。 此外，还结合了强化学习模块以消除误报，从而显着增强集群的容错能力。 </p><p>哥斯达等人。 [79]描述了一种基于预测的主动容错解决方案，可以有效地避免内存错误。 该解决方案源于一项观察，即检查点&#x2F;重启可能无法有效地处理以千万亿次级执行的高性能计算中的内存故障。 这种方法嵌入到操作系统中。 它的工作原理是向操作系统公开可纠正的错误信息，迁移页面并使故障内存脱机以避免应用程序崩溃。 对内存错误模式进行分析，并使用可纠正的错误模式来预测可能发生故障的内存。 在 IBM 的 Blue Gene&#x2F;Q (BG&#x2F;Q) 系统上运行的 Linux 上实现了一个原型，该系统是一个 HPC 系统。</p><h4 id="Monitoring-Feedback-Loop"><a href="#Monitoring-Feedback-Loop" class="headerlink" title="Monitoring (Feedback Loop)"></a>Monitoring (Feedback Loop)</h4><p>监控主要用于<strong>补充</strong>其他主动算法。它用于监视正在运行的应用程序上的一组状态变量。状态变量被过滤并通过反馈循环机制 [14]、[85] 提供给策略管理器。</p><p>Egwutuoha 等人。 [14] 描述了一种主动技术，它依赖于监控为云中的 HPC 提供 FT。 这种 FT 技术的框架最初是由 Egwutuoha 等人提出的。 [85]。 根据这项研究，超过 50% 的 HPC 系统故障是由处理器、硬盘驱动器、集成电路插槽和内存引起的。 强调了与被动方法相比，HPC 计算中<strong>主动容错</strong>的优势。 与主要基于检查点和重启的反应式容错方法不同，主动容错避免了从检查点重启，因此<strong>降低</strong>了运营成本和能源消耗。 Egwutuoha 等人。 [14] 主要关注 MPI 应用程序。 MPI 应用程序实际上是在不同 CPU 或 VM 上并行运行的应用程序，它们通过消息传递交换数据来进行通信，例如 GROMACS 系统 [89]。 Egwutuoha 等人。 [14] 采用回避方法来容忍错误。 这是通过结合使用系统日志和健康监控设施来实现的。 系统日志提供有关可靠性、可用性和可服务性的信息，而健康监控则以硬件和软件的状态为主。 [14] 中提出的主动 FT 解决方案的架构由四种类型的模块组成：1）带有 lm 传感器的节点监控模块；2）故障预测器；3）主动容错策略模块； 4) 控制器模块。 [14] 还提出了容错算法的框架和一些结果的定量分析。 结果表明，通过实施此 FT 模型可显着节省成本。 节省的主要原因是由于立即放弃故障节点而节省了运营成本。</p><p>Park等。 [90] 描述了一种监控技术，可以作为移动云计算中容错的一部分应用。 虽然Park等人。 [90] 没有描述完整的容错技术，它提供了一种<strong>监控技术</strong>，该技术对于在移动云计算中实现 FT 非常有用。 移动云计算被描述为移动计算和云计算的结合。 在移动云计算的背景下，云计算是通过移动设备提供的。 移动设备上的遗留问题似乎已被克服，这些问题包括电池寿命短和 CPU 性能低下。 该论文确定了在移动云计算中使用移动设备的两类，即作为接口的移动设备和作为资源的移动设备。 大多数工作以前都是使用移动设备作为界面进行的，最近的趋势是使用移动设备作为托管云服务的资源。 使用移动设备作为资源面临着大多数与移动性相关的问题。 其中包括由于无线连接不稳定导致的波动性、电源限制、低网络带宽以及由于频繁的位置变化导致的切换问题。 因此，资源监控是在移动云计算中实现可靠的资源调度和容错技术的关键。 一种资源监控技术，需要收集和分析有关每个参与资源状态的动态信息并确保稳定性。 Park等。 [90] 提出了一种基于马尔可夫链的监控技术，旨在监控和分析资源状态。 <strong>主要目的</strong>是解决移动设备的波动性对容错问题的影响。</p><h4 id="SGuard"><a href="#SGuard" class="headerlink" title="SGuard"></a>SGuard</h4><p>SGuard 是一种基于回滚和恢复的技术，用于实时视频流。它对视频流的影响要小得多 [18]。</p><p>权等人。 [18] 向 SGuard 展示了一个弹性容错方法的示例，该方法由反应性故障技术（即检查点、回滚、恢复和复制）的合并形成。 SGuard 是一种相对较新的技术，用于处理部署在多个集群中的分布式流处理引擎 (SPE) 中的故障。这种部署模型类似于基于云的服务。这种方法使用回滚&#x2F;恢复技术来实现容错。在系统运行时，SGuard 在流服务运行时异步执行检查点。故障服务器根据最近的检查点回滚和恢复。故障服务器的检查点、回滚和恢复是<strong>异步</strong>发生的，不会造成任何服务中断。检查点状态保存在分布式文件系统 (DFS) 上，例如 GFS、HDFS 或 Amazon EC2。 SGuard 能够处理软件故障和硬件崩溃。为了掩盖故障，SGuard 进一步采用了复制技术。 SPE 的状态在多个服务器上复制，这些服务器被分类为主要或次要。因此，SGuard 为实时视频流提供了一种破坏性较小的容错解决方案。</p><h3 id="Resilient"><a href="#Resilient" class="headerlink" title="Resilient"></a>Resilient</h3><p>弹性方法使系统能够在出现故障时<strong>继续</strong>为客户端请求提供服务，并在<strong>可接受的时间段</strong>内快速恢复。 故障可能是设备故障、停电或中断造成的。 通常，弹性系统由组件组成，这些组件负责实现在出现故障时继续响应客户端的能力、系统状态的监控、学习和适应系统的能力。 Colman-Meixner 等人。 [91] 对应用于云架构不同层的弹性技术进行了全面调查。 系统监控组件对于密切关注系统状态以及检测和预测即将发生的故障至关重要。 弹性系统的<strong>目标</strong>是通过最大化系统的可用性来最小化系统的整体停机时间。 学习组件负责优化故障恢复，它通过使用环境参数来实现这一点，并使用它们来改进下次发生故障时的处理。 这样，系统就能够从环境中学习并调整其容错机制。</p><p>容错机制的适应通常涉及<strong>部署最佳资源</strong>以使系统避免完全中断。 系统可以在出现故障之前或之后按时<strong>动态</strong>地添加或删除容量。 本质上，弹性方法是通过将用于 RAM 和 PRM 的技术与通过与环境交互学习的能力<strong>相结合</strong>并<strong>适应容错</strong> [19]、[20]、[21]、[22] 、 [23]、[24]、[25]形成的。本节回顾了有关 RSM 的选定论文。</p><h4 id="Machine-Learning-Approaches"><a href="#Machine-Learning-Approaches" class="headerlink" title="Machine Learning Approaches"></a>Machine Learning Approaches</h4><p>机器学习带来了容错的智能方式。云系统能够通过与其环境交互来学习，并相应地调整其故障处理策略。强化学习似乎是 FT 领域中最常用的技术 [19]、[20]、[21]、[22]、[23]、[24]、[25]、[39]、[86]。本节中审查的大多数论文可能不会直接链接到云计算。然而，我们寻求确定信息来源，其中机器学习，特别是强化学习已被用于实施或提高系统的容错能力。这些想法可以很容易地扩展到云环境中。</p><p>董等人。 [86] 为基于优先级队列和动态路由的云提出了一种高度弹性的容错解决方案。该解决方案得到云敏捷性的进一步支持，即动态地动态配置或取消配置额外的云资源的能力。使用分类方法，云服务请求被分成高优先级请求和低优先级请求，并分别映射到高优先级队列和低优先级队列。分布式动态队列用于卸载本地和远程云节点上的请求。队列技术（例如 Rabbit MQ）增加了将请求移交到远程托管的云服务器上进行处理的能力。动态路由监视优先级队列上的负载，当优先级队列上的负载增加时，它会发出在远程站点上提供额外服务的信号。较低优先级队列（可以容忍高延迟的队列）上的服务请求被移交给辅助服务器处理。该解决方案在后端包括一个数据复制层，用于同步主从服务之间的数据，以便它们可以独立运行。</p><p>许等。 [20] 提出了 FT 的统一强化学习（URL）解决方案。 URL 是一种机器学习技术，用于为云计算自动配置 VM 和设备。 VM 是托管云系统的各种组件的虚拟机。 这些设备可以是任何基于 VM 的软件包，例如 Apache 或 Tomcat Web 设备。 VM 和设备都有大量的配置值。 配置这些值以获得最佳性能和可用性的过程很容易出错。 在论文 [20] 中，描述了两个强化学习智能体，即 VMAgent 和 App-Agent。 VM-Agent 用于重新配置 VM，App-Agent 用于重新配置设备。 每个智能体的行为都使用马尔可夫决策过程 (MDP) 建模。 每个智能体的状态被描述为 VM 或设备的配置参数向量。 由于系统的工作负载需求会随着时间的推移而变化，因此 URL 的<strong>目标</strong>是找到能够为给定工作负载产生最佳性能的良好配置。</p><p>吴等。 [21] 建议使用顺序共享学习 (OSL) 来增强弹性和 FT。 OSL 是一种用于作业调度的鲁棒多智能体强化学习 (MARL) 方法。尽管最初是为网格计算设计的，但 OSL 中的<strong>思想也可以应用于云计算</strong>。 OSL 具有高度可扩展性。 OSL 由在智能体之间迭代交换的轻量级和线性效用表组成。实用程序表用于跟踪处理计划作业的系统资源的效率。 OSL 需要非常少的网络通信带宽，智能体只交换作为每个智能体学习算法输入的效用表。 Scheduler Agent 由两个主要组件组成，即 Actor 和 Learner。 Actor 接收要调度的作业，它在队列中缓冲作业（作业缓冲区）并跟踪当前正在运行的作业（提交的作业列表）。 Leaner 收到共享效用表，它使用提交的作业列表中的信息来学习处理当前作业的资源的新分数。分数被更新，效用表被传递到网格中的相邻节点。这种方式可确保最佳性能和最可靠的资源处理作业，从而增强系统的弹性和容错能力。</p><p>Farivar 和 Ahmadabadi [19] 提出了两种策略，可用于设计鲁棒且自适应的容错控制 (FTC) 系统。 尽管 FTC 与云系统没有直接关系，但可以为云系统数据中心借鉴和实施机器学习（尤其是强化学习）和神经网络（NN）的思想和方式。 [22] 中考虑了在基于执行器的系统中使用 NN 进行容错控制的类似方法。 故障是由一些执行器和传感器产生的，这些执行器和传感器可以安装在典型的云数据中心中以监控各个方面，例如入侵和温度。 传感器可以扩展到包括软件定义的传感器，这些传感器可以监控各种软件定义的指标，例如流量或系统负载。 定义了两种 FTC 策略。 第一个策略涉及一个智能观察器，用于监视未知数量的非线性系统。 第二种策略是基于强化学习，它结合了一些未知的非线性故障系统和非线性控制理论来保证系统的稳定性和鲁棒性。 这种非线性系统可以建模为负责托管云系统的服务器基础设施。 进行了模拟，结果证实上述 FTC 策略表现良好。 此外，对于执行器故障，强化学习被发现比神经网络表现更好。 同样，神经网络在基于传感器的故障上的表现优于强化学习。</p><p>Forster 和 Murphy [23] 提出了到多个接收器的反馈路由 (FROMS)，这是一种基于强化学习的无线传感器网络 (WSN) 的基于机器学习的多播路由范例。这是通过将 WSN 中的多播路由建模为强化学习问题来实现的。尽管 WSN 不被视为与云计算直接相关，但有一种观点认为，连接不良的网络中的最终用户设备可以形成一个动态的 WSN 并使用它来访问云服务。在这种情况下，WSN 的容错解决方案可以通过使 WSN 更加健壮来帮助解决云系统的容错问题。 FROMS 基本上是 WSN 的路由协议。 FROMS 的优势包括在不同服务器条件下灵活地优化路由，例如路由长度、电池电量、故障后恢复以及对接收器移动性的支持。这些声明作为 [23] 中获得的实验结果的一部分得到了支持。</p><p>Wang 和 Usher [24] 描述了 RL 在基于智能体的计算中的应用。 RL 通常用于授权自主智能体学习选择适当的行动，通过与环境交互来实现其目标。动作的选择取决于要解决的问题。尽管与容错没有直接联系，Wang 和 Usher [24] 将 RL 应用于制造系统中的计算智能体。著名的 RL 算法 Q-Learning 用于使机器智能体能够学习普遍接受的调度规则，这依赖于先前定义的最佳调度规则。 RL 的这种应用可用于云计算中的容错。由于云计算包括许多不同类型的计算智能体，它们通过 Internet 访问服务。需要解决连接问题，尤其是在移动网络上。可以应用 Q-Learning 算法，使智能体能够根据可用网络接入点列表始终选择最可靠的 Internet 连接。</p><p>Chen 和 Marculescu [25] 提出了一种在线分布式强化学习 (OD-RL) 算法，用于在功率限制下提高多核系统的性能。 OD-RL 算法基于动态电压频率缩放 (DVFS) 技术以节省功率。大多数托管云服务的数据中心都部署在基于多核 (CPU) 系统的服务器基础设施中，因此 OD-RL 适用于云端。强化学习用于学习在 CPU 级别控制电压&#x2F;频率 (VF) 的最佳策略。定义了用于在更粗粒度全局级别管理功率预算级别的最大化-最大方法。我们更感兴趣的是 RL 在更细粒度 CPU 级别的应用。实验结果表明，OD-RL 可显着节省电能、提高吞吐量和能效。</p><h4 id="Fault-Induction"><a href="#Fault-Induction" class="headerlink" title="Fault Induction"></a>Fault Induction</h4><p>Limoncelli [87] 描述了术语反脆弱性以及故障诱导方法在谷歌和亚马逊等大公司中对 FT 的应用。 早在 2000 年代初，亚马逊就开始使用故障感应方法。 这是通过一个名为 GameDay 的程序完成的。 GameDay 是一个程序，旨在通过在给定时间故意使系统出现重大故障来提高弹性，以发现系统之间的缺陷和依赖关系。 GameDay 测试类似于组织中的消防演习。 GameDay 行动不仅关注计算机系统，还包括对软件和人员（暗示业务流程）的测试，目的是让他们为应对实际灾难事件做好准备。 GameDay 演习模拟了一场真实的灾难，因此参与者可以包括组织各个级别的工作人员 [87]。 GameDay 现象已被谷歌和亚马逊等大型组织积极使用。 GameDay 测试可以重复。 只有在重复测试时一切正常时，GameDay 练习才被标记为成功。 这种技术的部分成果是使组织能够从失败中学习。 使用 GameDay 方法已经取得了<strong>显着的成果</strong>。</p><h3 id="Strengths-and-Weaknesses"><a href="#Strengths-and-Weaknesses" class="headerlink" title="Strengths and Weaknesses"></a>Strengths and Weaknesses</h3><p>在本节中，我们将回顾容错方法的优缺点。传统方法的优点和缺点在文献中得到了很好的研究，这些包括 [26]、[12] 和 [31]。因此，在这篇评论中，我们将介绍<strong>机器学习特定方法</strong>的优缺点，因为这是一个新兴领域。</p><p>越来越多地使用云计算导致系统复杂性和规模呈指数级增长。这最终将导致传统的容错方法不再有效和可行的状态。因此，需要替代方法来处理云中的资源管理、安全性和能源效率等容错问题。本研究中审查的论文评估了各种机器学习算法，这些算法对云容错有不同的贡献。</p><p>机器学习提供了能够处理大量数据并不断学习和调整系统的工具和算法。 ML 由三个主要类别组成，即监督学习、无监督学习和强化学习 (RL)。 RL更适合实现控制优化类型的解决方案。因此，RL 是实现容错的首选 [19]、[23]、[92]。</p><p>通常，RL 算法分为两大类，即基于模型和无模型的方法 [93]。 基于模型的方法使用智能体与环境（云）交互的经验构建世界模型。 该模型用于学习价值函数。 无模型方法直接从与环境的交互中估计价值函数。 每个班级都有不同的长处和短处。 基于模型的方法的关键优势在于，在大多数情况下，他们找到了与环境交互较少的良好价值函数，因此通常被视为产生更好的性能，这被称为数据效率 [93]。 然而，这是有代价的，基于模型的方法通常需要更多的计算资源。 无模型方法的主要优势在于它们需要更少的计算资源，因此它们可以支持比基于模型的方法大得多的表示，这被称为计算效率。 无模型算法的另一个优势在于它们是可扩展的，它们随着代表环境的特征数量线性增长 [93]。</p><p>RL 的<strong>最终目标</strong>是学习用于管理智能体行为的最优策略。 RL 系统由许多智能体组成，这些智能体通过一些涉及与环境交互的反复试验的经验来学习。 RL 智能体通过最大化从动作价值函数获得的奖励来不断适应环境。智能体学习从每个系统状态采取的最佳行动。 RL 适用于状态数量极大、结构复杂的系统，因此适用于云系统。然而，此类系统的一个弱点是需要大量的计算资源，尤其是存储和内存。</p><p>一些著名的机器学习工具已与 RL 算法一起使用，包括 Q-Learning、人工神经网络 (ANN)、朴素贝叶斯、随机森林和深度学习 [15]。接下来我们看看使用每种容错解决方案的方法的优点和缺点。 </p><p>Q-Learning 是一种无模型方法，主要用于通过学习每个状态-动作转换的最佳 Q 因子来找到最佳策略。它主要应用于任何具有有限状态的马尔可夫决策过程[20]。 Q-Learning 的关键优势在于它是无模型的，而且实施起来非常直接。 Q-Learning 的主要弱点是跟踪每个 Q-factor 所需的存储量，尤其是当状态-动作对的数量增长太大时。</p><p>人工神经网络可用于补充 Q-Learning。当状态值对的数量太大并且因此不能有效地存储在 Q 因子列表中时，将应用 ANN。因此，给定动作的所有 Q 因子都存储在一个网络中。然而，训练 ANN 来表示 Q 因子可能既复杂又耗时。</p><p>支持向量机是最近应用于强化学习的数据挖掘工具的一个例子，特别是在需要分类或回归时 [94]。 SVM 的优势包括高水平的预测准确性，即使在训练示例包含错误时它们也能发挥作用。在弱点方面，SVM 需要很长的训练时间，学习到的函数很难理解，因为它以权重表示。</p><p>朴素贝叶斯是一种基于贝叶斯定理的分类器，它是基于模型的，可以与强化学习一起使用。它在模型不完全已知且存在不确定性的情况下很有用。朴素贝叶斯的主要优势在于它被认为是快速、健壮的并且可以处理不完整的模型。朴素贝叶斯可以处理非常大的数据集，并且优于许多其他复杂的分类器。朴素贝叶斯的一个主要弱点是它依赖贝叶斯定理，该定理假定所有属性（特征）都是独立的。这样的假设可能导致简单地忽略预测中属性相关性的影响。</p><p>深度强化学习是深度神经网络与 RL 的应用。当状态-动作对的数量变得太大时，这特别有用。不是为每个状态-动作对存储 Q 因子，而是使用深度神经网络来存储每个动作的 Q 因子，这些网络也称为深度 Q 网络 (DQN) [95]。这种方法的关键优势在于能够处理大数据，从而使 RL 能够扩展到以前难以解决的问题领域 [96]。同时，他们的主要弱点与训练时间有关。</p><p>随机森林是基于树的分类结构，已与 RL 一起使用。基于树的算法的优势包括显着减少分类错误（高度准确）和降低计算资源负载 [97]。它们可以处理相当大的特征变量，并且在大型数据库上非常有效。在大多数报道中，随机森林为学习函数近似提供了更好的收敛性 [97]。在弱点方面，随机森林会遇到由过度生长的树木引起的过度拟合问题。交叉验证可用于解决过度拟合问题 [98]。</p><h2 id="Emerging-directions"><a href="#Emerging-directions" class="headerlink" title="Emerging directions"></a>Emerging directions</h2><p>根据作为本研究的一部分审查的论文（见表 2），很明显，目前有大量的容错解决方案<strong>仍然主要基于被动和主动方法</strong>。在云系统的背景下，这些方法的性能、灵活性和可扩展性仍有待证明。对于其中一些方法，不确定它们将如何在部署在分布式和异构云平台上的系统上工作。当前的方法不可扩展，需要某种形式的手动干预才能顺利运行和配置，因此，我们建议云中容错的<strong>未来将基于自动化</strong>。</p><p>在尝试解决其中一些挑战时，我们开始看到基于智能体的云计算的出现作为解决自主云问题的一种手段 [99]。因此，我们认为基于智能体的解决方案（包括强化学习）是云中自主容错的新兴方向。智能体是一个功能齐全的计算节点，能够独立做出决策并通过合作、协调和协商与其他智能体进行交互[99]。我们正在见证基于智能体的<strong>自动化</strong>在云的各个核心方面的出现，例如资源分配 [100]、[101]、作业&#x2F;任务调度 [102]、[103] 和容错 [104]。此外，我们将继续看到高级机器学习技术（例如深度学习）的开发和应用，以支持基于智能体的自动化方法、硬件和基础设施监控 [105]、[106]、[107]、[108]、[ 109] 和弹性缓存 [110] 对自主容错有直接影响。</p><p>以下段落回顾了最近的一些论文，其中研究了与云计算和容错相关的基于智能体的计算和强化学习范例.</p><p>Sim [99] 介绍了基于智能体的云计算的概念，并解释了如何将基于智能体的计算范式应用于云计算基础设施和资源的管理。 根据 Sim [99]，基于智能体的云计算涉及构建云的服务发现、服务协商和服务组合功能。 服务发现由 Cloudle 实现，Cloudle 是一个基于智能体的云服务搜索引擎。 进一步表明，基于智能体的协商机制可用于实现服务协商和云商务。 此外，基于智能体的协作问题解决技术被证明可以解决自动化云服务组合的问题。 实验结果表明，使用基于智能体的云计算自动化方法，智能体在协商云资源方面取得了很高的利用率和成功率。 智能体也可以通过自主选择 Cloudle 机制支持的服务来成功组合云服务。</p><p>阿拉伯内贾德等人。 [101] 描述了另一种自动化方法，其中 RL 可用于自动化云中的动态资源分配问题。目标是实施一个云管理解决方案，该解决方案根据系统工作负载的波动进行自适应和自动缩放。强化学习用于决定何时添加或删除资源，同时仍然保证商定的系统 SLA。使用模糊逻辑方法。比较了两种基于模糊逻辑的动态学习策略，即模糊 SARSA 学习 (FSL) 和模糊 Q 学习 (FQL)。这两种方法都能够处理不同的工作负载模式，例如突发性和周期性工作负载。此外，FSL 和 FQL 能够按需交付资源，同时降低运营成本并避免违反 SLA。</p><p>Dal ılia 和 Coutinho [104] 提出了一种基于自主和强化学习的解决方案，以解决机会主义网格系统中复制和检查点之间的平衡问题。这些机会网格系统被定义为通过使用非专用计算资源的空闲处理能力动态形成的低成本和大型计算网格。此类非专用资源可以在地理上分布在许多不同的管理域中，并且此类资源随机加入和离开网格。因此，需要不断地监测和检测网格形成事件并及时做出反应。 RL 用于自动调整用于在检查点和复制之间切换的阈值。使用 RL，切换决策基于网格中计算节点的数量和可靠性。实验结果表明，该方法能够学习在复制和检查点之间切换的最佳阈值。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文回顾了在分布式或云系统中实现容错的各种方法。我们将容错方法分为三大类：<strong>1）反应性方法； 2) 主动方法； 3）弹性方法</strong>。反应式和主动式方法主要基于传统的容错方法，如复制、检查点、重试、监控和抢占式迁移。</p><p>其中一些方法已在一定程度上用于实现云系统的容错。 例如，大多数使用虚拟化技术的数据中心都依赖于抢占式迁移来处理由服务器中断引起的故障。 这些传统方法有局限性。 首先，它们基于固定的逻辑并以其实现定义的特定方式处理故障。 因此，它们缺乏处理未来可能出现的新故障的能力。 其次，这些实现在做出处理故障的决策时只考虑固有的系统属性。 对可能影响系统性能（例如温度、功率和天气）的外部或环境属性的考虑非常有限。</p><p>由于计算的未来正在向云迁移，系统将面临传统容错方法无法处理的故障。因此，需要开发能够通过与运行环境的交互来学习和适应的系统。此类系统将需要使用<strong>机器学习方法</strong>作为其容错解决方案的一部分。正如我们在本文中所见，机器学习已被用于创建容错解决方案。然而，机器学习主要用作整体容错解决方案的一个子组件。一些解决方案主要使用机器学习来使用一组定义的变量进行预测。在其他应用中，机器学习已被用于管理硬件故障。这样的系统又是固定的并且不够动态以处理未来和未知的故障。</p><p>需要通过定义可在云环境中用于处理故障的可重用框架，将机器学习的应用进一步扩展到容错。这样的框架将被称为智能云。智能云的主要组成部分将是任何一组相互关联的智能体，并通过与它们将在其中执行的环境交互来学习如何处理故障。作为此的直接结果，这些智能体将有权做出连接决策，从而使他们也能够最佳地利用能源。</p><p>本文将未来的研究方向归于自动化。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] M. Armbrust, A. Fox, R. Griffith, A. D. Joseph, R. Katz, A. Konwinski, G. Lee, D. Patterson, A. Rabkin, I. Stoica, and M. Zaharia, “A view of cloud computing,” Commun. ACM, vol. 53, no. 4, pp. 50–58, Apr. 2010. </p><p>[2] A. Abid, M. T. Khemakhem, S. Marzouk, M. B. Jemaa, T. Monteil, and K. Drira, “Toward antifragile cloud computing infrastructures,” Procedia Comput. Sci., vol. 32, pp. 850–855, 2014. </p><p>[3] J. Liu, S. Wang, A. Zhou, S. Kumar, F. Yang, and R. Buyya, “Using proactive fault-tolerance approach to enhance cloud service reliability,” IEEE Trans. Cloud Comput., vol. PP, no. 99, p. 1, 2017, doi: 10.1109&#x2F;TCC.2016.2567392. </p><p>[4] A. Zhou, S. Wang, B. Cheng, Z. Zheng, F. Yang, R. N. Chang, M. R. Lyu, and R. Buyya, “Cloud service reliability enhancement via virtual machine placement optimization,” IEEE Trans. Serv. Comput., vol. 10, no. 6, pp. 902–913, Nov. 2017. </p><p>[5] A. Zhou, S. Wang, Z. Zheng, C. H. Hsu, M. R. Lyu, and F. Yang, “On cloud service reliability enhancement with optimal resource usage,” IEEE Trans. Cloud Comput., vol. 4, no. 4, pp. 452–466, Oct. 2016. </p><p>[6] S. Ananth and A. Saranya, “Reliability enhancement for cloud services—A survey,” in Proc. Int. Conf. Comput. Commun. Inform., Jan. 2016, pp. 1–7. </p><p>[7] J. W. Lin, C. H. Chen, and J. M. Chang, “QoS-aware data replication for data-intensive applications in cloud computing systems,” IEEE Trans. Cloud Comput., vol. 1, no. 1, pp. 101–115, Jan. 2013. </p><p>[8] Z. Qiu and J. F. Prez, “Enhancing reliability and response times via replication in computing clusters,” in Proc. IEEE Int. Conf. Comput. Commun., Apr. 2015, pp. 1355–1363. </p><p>[9] P. Bodık, I. Menache, M. Chowdhury, P. Mani, D. A. Maltz, and I. Stoica, “Surviving failures in bandwidth-constrained datacenters,” in Proc. ACM SIGCOMM Conf. Appl. Technol. Archit. Protocols Comput. Commun., 2012, pp. 431–442. </p><p>[10] J. Liu, S. Wang, A. Zhou, F. Yang, and R. Buy, “Availabilityaware virtual cluster allocation in bandwidth-constrained datacenters,” IEEE Trans. Serv. Comput., vol. PP, no. 99, p. 1, 2017, doi: 10.1109&#x2F;TSC.2017.2694838. </p><p>[11] W. Qiu, Z. Zheng, X. Wang, X. Yang, and M. R. Lyu, “Reliabilitybased design optimization for cloud migration,” IEEE Trans. Serv. Comput., vol. 7, no. 2, pp. 223–236, Apr. 2014. </p><p>[12] P. K. Patra, H. Singh, and G. Singh, “Fault tolerance techniques and comparative implementation in cloud computing,” Int. J. Comput. Appl., vol. 64, no. 14, pp. 37–41, Feb. 2013. </p><p>[13] G. Vallee, K. Charoenpornwattana, C. Engelmann, A. Tikotekar, C. Leangsuksun, T. Naughton, and S. L. Scott, “A framework for proactive fault tolerance,” in Proc. 3rd Int. Conf. Availability Rel. Secur., Mar. 2008, pp. 659–664. </p><p>[14] I. Egwutuoha, S. Chen, D. Levy, B. Selic, and R. Calvo, “A proactive fault tolerance approach to high performance computing (HPC) in the cloud,” in Proc. Int. Conf. Cloud Green Comput., Nov. 2012, pp. 268–273. </p><p>[15] Z. Amin, H. Singh, and N. Sethi, “Review on fault tolerance techniques in cloud computing,” Int. J. Comput. Appl., vol. 116, no. 18, pp. 11–17, Apr. 2015. </p><p>[16] G. P. Sarmila, N. Gnanambigai, and P. Dinadayalan, “Survey on fault tolerant—Load balancing algorithms in cloud computing,” in Proc. Int. Conf. Electron. Commun. Syst., Feb. 2015, pp. 1715–1720. </p><p>[17] J. Pinto, P. Jain, and T. Kumar, “Hadoop distributed computing clusters for fault prediction,” in Proc. Int. Comput. Sci. Eng. Conf., Dec. 2016, pp. 1–6. </p><p>[18] Y. Kwon, M. Balazinska, and A. Greenberg, “Fault-tolerant stream processing using a distributed, replicated file system,” Proc. VLDB Endowment, vol. 1, no. 1, pp. 574–585, Aug. 2008. </p><p>[19] F. Farivar and M. N. Ahmadabadi, “Continuous reinforcement learning to robust fault tolerant control for a class of unknown nonlinear systems,” Appl. Soft Comput., vol. 37, pp. 702–714, 2015. </p><p>[20] C.-Z. Xu, J. Rao, and X. Bu, “URL: A unified reinforcement learning approach for autonomic cloud management,” J. Parallel Distrib. Comput., vol. 72, no. 2, pp. 95–105, 2012. </p><p>[21] J. Wu, X. Xu, P. Zhang, and C. Liu, “A novel multi-agent reinforcement learning approach for job scheduling in grid computing,” Future Generation Comput. Syst., vol. 27, no. 5, pp. 430–439, 2011. </p><p>[22] L. Liu, Z. Wang, and H. Zhang, “Adaptive NN fault-tolerant control for discrete-time systems in triangular forms with actuator fault,” Neurocomput., vol. 152, pp. 209–221, 2015. </p><p>[23] A. Forster and A. L. Murphy, “FROMS: A failure tolerant and mobility enabled multicast routing paradigm with reinforcement learning for WSNs,” Ad Hoc Netw., vol. 9, no. 5, pp. 940–965, 2011. </p><p>[24] Y.-C. Wang and J. M. Usher, “Application of reinforcement learning for agent-based production scheduling,” Eng. Appl. Artif. Intell., vol. 18, no. 1, pp. 73–82, 2005. </p><p>[25] Z. Chen and D. Marculescu, “Distributed reinforcement learning for power limited many-core system performance optimization,” in Proc. Des. Autom. Test Eur. Conf. Exhib., 2015, pp. 1521–1526. </p><p>[26] R. Jhawar and V. Piuri, “Chapter 1—Fault tolerance and resilience in cloud computing environments,” in Cyber Security and IT Infrastructure Protection, J. R. Vacca, Ed. Boston, MA, USA: Syngress, 2014, pp. 1–28. </p><p>[27] H. Okamura, Y. Nishimura, and T. Dohi, “A dynamic checkpointing scheme based on reinforcement learning,” in Proc. IEEE Pacific Rim Int. Symp. Depend. Comput., Mar. 2004, pp. 151–158. </p><p>[28] L. Bautista-Gomez, S. Tsuboi, D. Komatitsch, F. Cappello, N. Maruyama, and S. Matsuoka, “FTI: High performance fault tolerance interface for hybrid systems,” in Proc. ACM&#x2F;IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2011, pp. 32:132:32. </p><p>[29] A. Moody, G. Bronevetsky, K. Mohror, and B. R. D. Supinski, “Design, modeling, and evaluation of a scalable multi-level checkpointing system,” in Proc. ACM&#x2F;IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2010, pp. 1–11. </p><p>[30] S. Di, L. Bautista-Gomez, and F. Cappello, “Optimization of a multilevel checkpoint model with uncertain execution scales,” in Proc. ACM&#x2F;IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2014, pp. 907–918. </p><p>[31] D. Singh, J. Singh, and A. Chhabra, “High availability of clouds: Failover strategies for cloud computing using integrated checkpointing algorithms,” in Proc. Int. Conf. Commun. Syst. Netw. Technol., May 2012, pp. 698–703. </p><p>[32] A. J. Oliner, L. Rudolph, and R. K. Sahoo, “Cooperative checkpointing: A robust approach to large-scale systems reliability,” in Proc. ACM Annu. Int. Conf. Supercomput., 2006, pp. 14–23.</p><p>[33] S. Di, M. S. Bouguerra, L. Bautista-Gomez, and F. Cappello, “Optimization of multi-level checkpoint model for large scale HPC applications,” in Proc. IEEE Int. Parallel Distrib. Process. Symp., May 2014, pp. 1181–1190. </p><p>[34] B. Mohammed, M. Kiran, K. M. Maiyama, M. M. Kamala, and I.-U. Awan, “Failover strategy for fault tolerance in cloud computing environment,” Softw.: Practice Experience, vol. 47, no. 9, pp. 1243–1274, 2017. </p><p>[35] I. Jangjaimon and N. F. Tzeng, “Effective cost reduction for elastic clouds under spot instance pricing through adaptive checkpointing,” IEEE Trans. Comput., vol. 64, no. 2, pp. 396–409, Feb. 2015. </p><p>[36] J. Zhao, Y. Xiang, T. Lan, H. H. Huang, and S. Subramaniam, “Elastic reliability optimization through peer-to-peer checkpointing in cloud computing,” IEEE Trans. Parallel Distrib. Syst., vol. 28, no. 2, pp. 491–502, Feb. 2017. </p><p>[37] M. Amoon, “Adaptive framework for reliable cloud computing environment,” IEEE Access, vol. 4, pp. 9469–9478, 2016. </p><p>[38] B. Balasubramanian and V. K. Garg, “Fault tolerance in distributed systems using fused data structures,” IEEE Trans. Parallel Distrib. Syst., vol. 24, no. 4, pp. 701–715, Apr. 2013. </p><p>[39] B. Cully, G. Lefebvre, D. Meyer, M. Feeley, N. Hutchinson, and A. Warfield, “Remus: High availability via asynchronous virtual machine replication,” in Proc. USENIX Symp. Netw. Syst. Des. Implementation, 2008, pp. 161–174. </p><p>[40] W. Zhao, P. Melliar-Smith, and L. Moser, “Fault tolerance middleware for cloud computing,” in Proc. IEEE Int. Conf. Cloud Comput., Jul. 2010, pp. 67–74. </p><p>[41] T. Wood, R. Singh, A. Venkataramani, P. Shenoy, and E. Cecchet, “ZZ and the art of practical BFT execution,” in Proc. ACM EuroSys Conf. Comput. Syst., 2011, pp. 123–138. </p><p>[42] M. Castro and B. Liskov, “Practical byzantine fault tolerance and proactive recovery,” ACM Trans. Comput. Syst., vol. 20, no. 4, pp. 398–461, Nov. 2002. </p><p>[43] P. Costa, M. Pasin, A. Bessani, and M. Correia, “Byzantine faulttolerant MapReduce: Faults are not just crashes,” in Proc. IEEE Int. Conf. Cloud Comput. Technol. Sci., Nov. 2011, pp. 32–39. </p><p>[44] K. Plankensteiner, R. Prodan, and T. Fahringer, “A new fault tolerance heuristic for scientific workflows in highly distributed environments based on resubmission impact,” in Proc. IEEE Int. Conf. e-Sci., Dec. 2009, pp. 313–320. </p><p>[45] A. Zhou, S. Wang, C.-H. Hsu, M. H. Kim, and K.-S. Wong, “Network failure-aware redundant virtual machine placement in a cloud data center,” Concurrency Comput.: Practice Experience, vol. 29, no. 24, 2017, Art. no. e4290. </p><p>[46] Z. Zheng, T. C. Zhou, M. R. Lyu, and I. King, “Component ranking for fault-tolerant cloud applications,” IEEE Trans. Serv. Comput., vol. 5, no. 4, pp. 540–550, Oct.–Dec. 2012. </p><p>[47] R. Jhawar, V. Piuri, and M. Santambrogio, “Fault tolerance management in cloud computing: A system-level perspective,” IEEE Syst. J., vol. 7, no. 2, pp. 288–297, Jun. 2013. </p><p>[48] C. Wang, L. Xing, H. Wang, Z. Zhang, and Y. Dai, “Processing time analysis of cloud services with retrying fault-tolerance technique,” in Proc. IEEE Int. Conf. Commun. China, Aug. 2012, pp. 63–67. </p><p>[49] G. Ramalingam and K. Vaswani, “Fault tolerance via idempotence,” SIGPLAN Notices, vol. 48, no. 1, pp. 249–262, Jan. 2013. </p><p>[50] A. Liu, Q. Li, L. Huang, and M. Xiao, “Facts: A framework for fault-tolerant composition of transactional web services,” IEEE Trans. Serv. Comput., vol. 3, no. 1, pp. 46–59, Jan. 2010. </p><p>[51] J. Yu and R. Buyya, “A taxonomy of scientific workflow systems for grid computing,” ACM SIGMOD Rec., vol. 34, no. 3, pp. 4449, Sep. 2005. </p><p>[52] I. Hernandez and M. Cole, “Reliable DAG scheduling on grids with rewinding and migration,” in Proc. ICST Int. Conf. Netw. Grid Appl., 2007, pp. 3:1–3:8. </p><p>[53] F. Saffre, R. Tateson, J. Halloy, M. Shackleton, and J. L. Deneubourg, “Aggregation dynamics in overlay networks and their implications for self-organized distributed applications,” Comput. J.,vol.52,no. 4, pp. 397–412, Jul. 2009. </p><p>[54] M. Randles, D. Lamb, and A. Taleb-Bendiab, “A comparative study into distributed load balancing algorithms for cloud computing,” in Proc. IEEE Int. Conf. Adv. Inf. Netw. Appl. Workshops, Apr. 2010, pp. 551–556. </p><p>[55] M. Randles, A. Taleb-Bendiab, and D. Lamb, “Scalable selfgovernance using service communities as ambients,” in Proc. World Conf. Services-I, Jul. 2009, pp. 813–820. </p><p>[56] O. Rahmeh, P. Johnson, and A. Taleb-Bendiab, “A dynamic biased random sampling scheme for scalable and reliable grid networks,” INFOCOMP J. Comput. Sci., vol. 7, no. 4, pp. 1–10, 2008. </p><p>[57] J. Oberheide, E. Cooke, and F. Jahanian, “CloudAV: N-version antivirus in the network cloud,” in Proc. USENIX Conf. Secur. Symp., 2008, pp. 91–106. </p><p>[58] J. Oberheide, K. Veeraraghavan, E. Cooke, J. Flinn, and F. Jahanian, “Virtualized in-cloud security services for mobile devices,” in Proc. ACM Workshop Virtualization Mobile Comput., 2008, pp. 31–35. </p><p>[59] K.-L. Peng, C.-Y. Huang, P.-H. Wang, and C.-J. Hsu, “Enhanced N-version programming and recovery block techniques for web service systems,” in Proc. ACM Int. Workshop Innovative Softw. Develop. Methodologies Practices, 2014, pp. 11–20. </p><p>[60] A. Avizienis, “The N-version approach to fault-tolerant software,” IEEE Trans. Softw. Eng., vol. 11, no. 12, pp. 1491–1501, Dec. 1985. </p><p>[61] P. Hosek and C. Cadar, “VARAN the unbelievable: An efficient N-version execution framework,” in Proc. ACM Int. Conf. Archit. Support Program. Languages Operating Syst., 2015, pp. 339–353. </p><p>[62] R. Hanmer, “Software rejuvenation,” in Proc. ACM Conf. Pattern Languages Programs, 2010, pp. 21:1–21:13. </p><p>[63] M. Melo, J. Araujo, R. Matos, J. Menezes, and P. Maciel, “Comparative analysis of migration-based rejuvenation schedules on cloud availability,” in Proc. IEEE Int. Conf. Syst. Man Cybern., Oct. 2013, pp. 4110–4115. </p><p>[64] F. Xin-Yuan, X. Guo-Zhi, Y. Ren-Dong, Z. Hao, and J. Le-Tian, “Performance analysis of software rejuvenation,” in Proc. Int. Conf. Parallel Distrib. Comput. Appl. Technol., Aug. 2003, pp. 562–566. </p><p>[65] R. Angarita, M. Rukoz, M. Manouvrier, and Y. Cardinale, “A knowledge-based approach for self-healing service-oriented applications,” in Proc. ACM Int. Conf. Manage. Digit. EcoSyst., 2016, pp. 1–8. </p><p>[66] J. O. Kephart and D. M. Chess, “The vision of autonomic computing,” Comput., vol. 36, no. 1, pp. 41–50, Jan. 2003. </p><p>[67] S. Dobson, R. Sterritt, P. Nixon, and M. Hinchey, “Fulfilling the vision of autonomic computing,” Comput., vol. 43, no. 1, pp. 3541, Jan. 2010. </p><p>[68] S. George, D. Evans, and L. Davidson, “A biologically inspired programming model for self-healing systems,” in Proc. ACM Workshop Self-Healing Syst., 2002, pp. 102–104. </p><p>[69] C. Engelmann, G. Vallee, T. Naughton, and S. Scott, “Proactive fault tolerance using preemptive migration,” in Proc. Euromicro Int. Conf. Parallel Distrib. Netw.-Based Process., Feb. 2009, pp. 252–257. </p><p>[70] A. B. Nagarajan, F. Mueller, C. Engelmann, and S. L. Scott, “Proactive fault tolerance for HPC with Xen virtualization,” in Proc. ACM Annu. Int. Conf. Supercomput., 2007, pp. 23–32. </p><p>[71] F. Hao, T. V. Lakshman, S. Mukherjee, and H. Song, “Enhancing dynamic cloud-based services using network virtualization,” in Proc. ACM Workshop Virtualized Infrastructure Syst. Archit., 2009, pp. 37–44. </p><p>[72] T. Wood, K. K. Ramakrishnan, P. Shenoy, and J. van der Merwe, “CloudNet: Dynamic pooling of cloud resources by live wan migration of virtual machines,” ACM SIGPLAN Notices, vol. 46, no. 7, pp. 121–132, Mar. 2011. </p><p>[73] P. Lu, A. Barbalace, and B. Ravindran, “HSG-LM: Hybrid-copy speculative guest OS live migration without hypervisor,” in Proc. ACM Int. Syst. Storage Conf., 2013, pp. 2:1–2:11. </p><p>[74] G. Dhiman, G. Marchetti, and T. Rosing, “vGreen: A system for energy-efficient management of virtual machines,” ACM Trans. Des. Autom. Electron. Syst., vol. 16, no. 1, pp. 6:1–6:27, Nov. 2010. </p><p>[75] T. Knauth and C. Fetzer, “VeCycle: Recycling VM checkpoints for faster migrations,” in Proc. ACM Annu. Middleware Conf., 2015, pp. 210–221. </p><p>[76] J. Li, C. Pu, Y. Chen, V. Talwar, and D. Milojicic, “Improving preemptive scheduling with application-transparent checkpointing in shared clusters,” in Proc. ACM Annu. Middleware Conf., 2015, pp. 222–234. </p><p>[77] A. Polze, P. Troger, and F. Salfner, “Timely virtual machine migration for pro-active fault tolerance,” in Proc. IEEE Int. Symp. Object&#x2F; Component&#x2F;Service-Oriented Real-Time Distrib. Comput. Workshops, Mar. 2011, pp. 234–243. </p><p>[78] Y. Zhong, J. Xu, Q. Li, H. Zhang, and F. Liu, “Memory state transfer optimization for pre-copy based live VM migration,” in Proc. IEEE Workshop Adv. Res. Technol. Ind. Appl., Sep. 2014, pp. 290–293. </p><p>[79] C. H. A. Costa, Y. Park, B. S. Rosenburg, C.-Y. Cher, and K. D. Ryu, “A system software approach to proactive memory-error avoidance,” in Proc. IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2014, pp. 707–718.</p><p>[80] A. Gainaru, F. Cappello, M. Snir, and W. Kramer, “Fault prediction under the microscope: A closer look into HPC systems,” in Proc. IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2012, pp. 77:1–77:11. </p><p>[81] O. Hannache and M. Batouche, “Probabilistic model for evaluating a proactive fault tolerance approach in the cloud,” in Proc. IEEE Int. Conf. Service Operations Logistics Informat., Nov. 2015, pp. 94–99. </p><p>[82] R. Rajachandrasekar, X. Besseron, and D. K. Panda, “Monitoring and predicting hardware failures in HPC clusters with FTBIPMI,” in Proc. IEEE Int. Parallel Distrib. Process. Symp. Workshops PhD Forum, May 2012, pp. 1136–1143. </p><p>[83] F. Salfner, M. Lenk, and M. Malek, “A survey of online failure prediction methods,” ACM Comput. Surveys, vol. 42, no. 3, pp. 10:1–10:42, Mar. 2010. </p><p>[84] A. Tikotekar, G. Vallee, T. Naughton, S. Scott, and C. Leangsuksun, “Evaluation of fault-tolerant policies using simulation,” in Proc. IEEE Int. Conf. Cluster Comput., Sep. 2007, pp. 303–311. </p><p>[85] I. Egwutuoha, S. Chen, D. Levy, and B. Selic, “A fault tolerance framework for high performance computing in cloud,” in Proc. IEEE&#x2F;ACM Int. Symp. Cluster Cloud Grid Comput., May 2012, pp. 709–710. </p><p>[86] T. Tung, S. Y. Chaw, Q. Xie, and Q. Zhu, “Highly resilient systems for cloud,” in Proc. IEEE Int. Conf. Web Serv., Jun. 2012, pp. 678–680. </p><p>[87] T. Limoncelli, “Resilience engineering: Learning to embrace failure,” Commun. ACM, vol. 55, no. 11, pp. 40–47, Nov. 2012. </p><p>[88] A. Benso and P. Prinetto, Eds., Fault Injection Techniques and Tools for Embedded Systems Reliability Evaluation. Berlin, Germany: Springer, 2003. </p><p>[89] H. J. C. Berendsen, D. V. D. Spoel, and R. V. Drunen, “GROMACS: A message-passing parallel molecular dynamics implementation,” Comput. Phys. Commun., vol. 91, pp. 43–56, 1995. </p><p>[90] J. Park, H. Yu, K. Chung, and E. Lee, “Markov chain based monitoring service for fault tolerance in mobile cloud computing,” in Proc. IEEE Workshops Int. Conf. Adv. Inf. Netw. Appl., Mar. 2011, pp. 520–525. </p><p>[91] C. Colman-Meixner, C. Develder, M. Tornatore, and B. Mukherjee, “A survey on resiliency techniques in cloud computing infrastructures and applications,” IEEE Commun. Surveys Tuts.,vol.18,no.3, pp. 2244–2281, Jul.–Sep. 2016. </p><p>[92] H. Li and S. Venugopal, “Using reinforcement learning for controlling an elastic web application hosting platform,” in Proc. ACM Int. Conf. Autonomic Comput., 2011, pp. 205–208. </p><p>[93] R. S. Sutton and A. G. Barto, Reinforcement Learning : An Introduction. Cambridge, MA, USA: MIT Press, 1998. </p><p>[94] T. G. Dietterich and X. Wang, Support Vectors for Reinforcement Learning. Berlin, Germany: Springer, 2001, pp. 600–600. </p><p>[95] Y. Li, “Deep reinforcement learning: An overview,” CoRR, vol. abs&#x2F;1701.07274, 2017, <a href="http://arxiv.org/abs/1701.07274">http://arxiv.org/abs/1701.07274</a> </p><p>[96] K. Arulkumaran, M. P. Deisenroth, M. Brundage, and A. A. Bharath, “Deep reinforcement learning: A brief survey,” IEEE Signal Process. Mag., vol. 34, no. 6, pp. 26–38, Nov. 2017, doi: 10.1109&#x2F;MSP.2017.2743240. </p><p>[97] A. Paul and D. P. Mukherjee, “Reinforced random forest,” in Proc. ACM Indian Conf. Comput. Vis. Graph. Image Process., 2016, pp. 1:1–1:8. </p><p>[98] P. Domingos, “A few useful things to know about machine learning,” Commun. ACM, vol. 55, no. 10, pp. 78–87, Oct. 2012. </p><p>[99] K. M. Sim, “Agent-based cloud computing,” IEEE Trans. Serv. Comput., vol. 5, no. 4, pp. 564–577, Oct.–Dec. 2012. </p><p>[100] K. M. SIM, “Agent-based approaches for intelligent intercloud resource allocation,” IEEE Trans. Cloud Comput., vol. PP, no. 99, p. 1, 2016, doi: 10.1109&#x2F;TCC.2016.2628375. </p><p>[101] H. Arabnejad, C. Pahl, P. Jamshidi, and G. Estrada, “A comparison of reinforcement learning techniques for fuzzy cloud autoscaling,” in Proc. IEEE&#x2F;ACM Int. Symp. Cluster Cloud Grid Comput., May 2017, pp. 64–73. </p><p>[102] D. Cui, Z. Peng, X. Jianbin, B. Xu, and W. Lin, “A reinforcement learning-based mixed job scheduler scheme for grid or IaaS cloud,” IEEE Trans. Cloud Comput., vol. PP, no. 99, p. 1, 2017, doi: 10.1109&#x2F;TCC.2017.2773078. </p><p>[103] L. Wang and E. Gelenbe, “Adaptive dispatching of tasks in the cloud,” IEEE Trans. Cloud Comput., vol. 6, no. 1, pp. 33–45, Jan. 2018, doi: 10.1109&#x2F;TCC.2015.2474406. </p><p>[104] A. Dalılia and L. R. Coutinho, “A fault tolerance approach based on reinforcement learning in the context of autonomic opportunistic grids,” in Proc. Int. Conf. Autonomic Auton. Syst., 2014, pp. 11–17. </p><p>[105] J. F. Murray, G. F. Hughes, and D. Schuurmans, “Machine learning methods for predicting failures in hard drives: A multipleinstance application,” J. Mach. Learn. Res., vol. 6, 2005, Art. no. 816. </p><p>[106] Y. Zhao, X. Liu, S. Gan, and W. Zheng, “Predicting disk failures with HMM- and HSMM-based approaches,” in Proc. Int. Conf. Adv. Data Mining. Appl. Theoretical Aspects, 2010, pp. 390–404. </p><p>[107] B. Zhu, G. Wang, X. Liu, D. Hu, S. Lin, and J. Ma, “Proactive drive failure prediction for large scale storage systems,” in Proc. IEEE Symp. Mass Storage Syst. Technol., 2013, pp. 1–5. </p><p>[108] Y. Wang, Q. Miao, E. Ma, K.-L. Tsui, and M. Pecht, “Online anomaly detection for hard disk drives based on Mahalanobis distance,” IEEE Trans. Rel., vol. 62, no. 1, pp. 136–145, Mar. 2013. </p><p>[109] J. Li, X. Ji, Y. Jia, B. Zhu, G. Wang, Z. Li, and X. Liu, “Hard drive failure prediction using classification and regression trees,” in Proc. IEEE&#x2F;IFIP Int. Conf. Depend. Syst. Netw., 2014, pp. 383–394.</p><p>[110] X. Qin, W. Zhang, W. Wang, J. Wei, H. Zhong, and T. Huang, “On-line cache strategy reconfiguration for elastic caching platform: A machine learning approach,” in Proc. IEEE Annu. Comput. Softw. Appl. Conf., Jul. 2011, pp. 523–534.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems&quot;&gt;&lt;a href=&quot;#Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems&quot; class=&quot;headerlink&quot; title=&quot;Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems&quot;&gt;&lt;/a&gt;Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;本文介绍了云计算中提出的容错方法的最新研究进展。本文将容错方法分为三类：1）反应式方法（RAMs）；2）预防性方法（PRMs）；和3）弹性方法（RSMs）。RAMs允许系统进入故障状态，然后尝试恢复系统。PRMs倾向于通过实施机制来避免错误影响系统，从而防止系统进入故障状态。另一方面，最近出现的RSMs旨在最小化系统从故障中恢复所需的时间。本文还探讨了机器学习和人工智能在RSM领域中如何发挥作用以最小化恢复时间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode108.将有序数组转换为二叉搜索树</title>
    <link href="2023/03/26/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>2023/03/26/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2023-03-26T11:19:20.000Z</published>
    <updated>2023-03-26T11:27:07.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/btree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/btree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归构造树</li></ul><p>在这个实现中，我们采用了递归的方法构建高度平衡的二叉搜索树。在每次递归中，我们找到当前子数组的中间元素作为根节点，然后递归构建左右子树，最后将根节点返回。在递归过程中，我们使用两个指针 <code>left</code> 和 <code>right</code> 分别表示当前子数组的左右边界。如果 <code>left &gt; right</code>，则说明当前子数组为空，递归结束，返回 <code>nullptr</code>。C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F; 调用buildBST函数        return buildBST(nums, 0, nums.size() - 1);    &#125;private:    TreeNode* buildBST(vector&lt;int&gt;&amp; nums, int left, int right) &#123;        if (left &gt; right) &#123;            &#x2F;&#x2F; 若left &gt; right 则直接返回空指针            return nullptr;         &#125;        int mid &#x3D; left + (right - left) &#x2F; 2; &#x2F;&#x2F; 寻找mid的大小，将nums[mid]作为树的根节点        TreeNode* root &#x3D; new TreeNode(nums[mid]); &#x2F;&#x2F; 新建根节点，节点的值为nums[mid]        &#x2F;&#x2F; 递归调用buildBST函数构造left和right树，并将其赋值给root-&gt;left和root-&gt;right        root-&gt;left &#x3D; buildBST(nums, left, mid - 1);         root-&gt;right &#x3D; buildBST(nums, mid + 1, right);        &#x2F;&#x2F; 返回根节点        return root;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，其中元素已经按 &lt;strong&gt;升序&lt;/strong&gt; 排列，请你将其转换为一棵 &lt;strong&gt;高度平衡&lt;/strong&gt; 二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高度平衡&lt;/strong&gt; 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode214.最短回文串</title>
    <link href="2023/03/23/leetcode214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>2023/03/23/leetcode214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2023-03-23T06:14:31.000Z</published>
    <updated>2023-03-23T06:27:13.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <em><strong>s</strong></em>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;aacecaaa&quot;输出：&quot;aaacecaaa&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;输出：&quot;dcbabcd&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>KMP算法求解</li></ul><p>本题可以通过将原字符串翻转后与原字符串拼接，然后在新的字符串中找到以原字符串开头的最长回文子串，最后将翻转字符串的前缀加到原字符串前面即可得到新的字符串。为了找到以原字符串开头的最长回文子串，可以使用KMP算法中的next数组，将新的字符串l的next数组求出来，那么l.size() - 1位置处的值就是以原字符串开头的最长回文子串的长度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string shortestPalindrome(string s) &#123;        &#x2F;&#x2F; 将字符串s翻转并存储在rev_s中        string rev_s &#x3D; s;        reverse(rev_s.begin(), rev_s.end());        &#x2F;&#x2F; 将s和rev_s拼接，并用“#”分割        string l &#x3D; s + &quot;#&quot; + rev_s;        &#x2F;&#x2F; 初始化一个大小为l.size()的数组p        vector&lt;int&gt; p(l.size(), 0);        &#x2F;&#x2F; 通过循环遍历l，求出p数组        for (int i &#x3D; 1; i &lt; l.size(); i++) &#123;            int j &#x3D; p[i - 1];            while (j &gt; 0 &amp;&amp; l[i] !&#x3D; l[j]) j &#x3D; p[j - 1];            p[i] &#x3D; (j +&#x3D; l[i] &#x3D;&#x3D; l[j]);        &#125;        &#x2F;&#x2F; 返回一个由rev_s的前缀和s组成的新字符串        return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;    &#125;&#125;;</code></pre><blockquote><p>以输入<code>s=&quot;aacecaaa&quot;</code>为例，说明代码的运行过程：</p><p>首先将字符串s翻转得到rev_s&#x3D;”aaacecaa”，然后将s和rev_s用”#”分割拼接起来得到l&#x3D;”aacecaaa#aaacecaa”。</p><p>然后初始化一个大小为l.size()的数组p，数组中每个元素表示对应位置之前的字符串的最长相同前缀后缀的长度。</p><p>接下来使用KMP算法的思想，通过遍历l来求得数组p的所有元素。从i&#x3D;1开始，依次比较l[i]和l[p[i-1]]，如果不相同，则令j&#x3D;p[i-1]，并循环将j更新为p[j-1]，直到j&#x3D;0或者找到一个位置k使得l[i]和l[k]相等。如果找到了k，则令p[i]&#x3D;k+1，否则令p[i]&#x3D;0。</p><p>经过上述循环遍历后，p数组的最后一个元素p[l.size()-1]表示以原字符串开头的最长回文子串的长度，即3。因此，可以将rev_s的前缀”aa”加到s的前面，得到新的字符串为”aaacecaaa”，这个字符串是由原字符串”aacecaaa”通过添加最少字符得到的回文串。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;em&gt;&lt;strong&gt;s&lt;/strong&gt;&lt;/em&gt;，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode151.反转字符串中的单词</title>
    <link href="2023/03/22/leetcode151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>2023/03/22/leetcode151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2023-03-22T02:01:36.000Z</published>
    <updated>2023-03-22T02:31:09.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;  hello world  &quot;输出：&quot;world hello&quot;解释：反转后的字符串中不能存在前导空格和尾随空格。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;a good   example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>大致思路：将字符串中的每个单词放入动态数组中，然后将动态数组倒序遍历得到结果字符串，最后返回结果字符串，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseWords(string s) &#123;        &#x2F;&#x2F; 特判：如果s的长度为1，则只包含一个单词，此时直接返回s即可        if (s.length() &#x3D;&#x3D; 1) return s;        &#x2F;&#x2F; 新建s_vec动态数组，元素类型为string        vector&lt;string&gt; s_vec;        &#x2F;&#x2F; 定义left，它是指向字符串里第一个单词的第一个字母的指针        int left &#x3D; 0; &#x2F;&#x2F; left的初始化        while (s[left] &#x3D;&#x3D; &#39; &#39;) &#123;            left++;  &#x2F;&#x2F; 防止字符串一开始就是空格        &#125;        &#x2F;&#x2F; 开始循环        for (int i &#x3D; left; i &lt; s.length(); i++) &#123;            &#x2F;&#x2F; 当i指向一个单词右边的第一个空格或者字符串的最后一个元素时            if (s[i] &#x3D;&#x3D; &#39; &#39; || i &#x3D;&#x3D; s.length() - 1) &#123;                if (i &#x3D;&#x3D; s.length()-1) i++; &#x2F;&#x2F; 当i指向字符串的最后一个字母时，需要自增1，否则无法通过substr获得子串                string temp &#x3D; s.substr(left, i - left); &#x2F;&#x2F; 使用substr获得子串                s_vec.push_back(temp); &#x2F;&#x2F; 将子串push进动态数组s_vec中                while (s[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; i &lt; s.length()) &#123;                    i++; &#x2F;&#x2F; 令i从其之后的第一个非空字母开始遍历                &#125;                left &#x3D; i; &#x2F;&#x2F; 更新left的值            &#125;        &#125;        if (s[s.length()-1] !&#x3D; &#39; &#39; &amp;&amp; s[s.length()-2] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 针对字符串最后的一个单词只有一个字母的特判            string temp &#x3D; s.substr(s.length()-1);            s_vec.push_back(temp);        &#125;        int n &#x3D; s_vec.size(); &#x2F;&#x2F; 获取动态数组的大小（也就是总的单词个数）        string result; &#x2F;&#x2F; 定义结果字符串        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123; &#x2F;&#x2F; 反向遍历，将结果同result相加            if (i &#x3D;&#x3D; n - 1) &#123; &#x2F;&#x2F; 第一个单词前无需加空格                result &#x3D; result + s_vec[i];            &#125;            else &#123; &#x2F;&#x2F; 其他单词在同result合并前需要先加一个空格                result &#x3D; result + &quot; &quot; + s_vec[i];             &#125;        &#125;        return result; &#x2F;&#x2F; 返回result字符串    &#125;&#125;;</code></pre><ul><li>空间复杂度为O(1)的解法</li></ul><ol><li>将整个字符串进行反转</li><li>将反转后的字符串的每个单词进行反转</li><li>去除字符串中多余的空格</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseWords(string s) &#123;        reverse(s.begin(), s.end()); &#x2F;&#x2F; 翻转整个字符串        int n &#x3D; s.size();        int idx &#x3D; 0;        for (int start &#x3D; 0; start &lt; n; ++start) &#123;            if (s[start] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 找到单词的起始位置                if (idx !&#x3D; 0) s[idx++] &#x3D; &#39; &#39;; &#x2F;&#x2F; 添加单词间空格                int end &#x3D; start;                while (end &lt; n &amp;&amp; s[end] !&#x3D; &#39; &#39;) s[idx++] &#x3D; s[end++]; &#x2F;&#x2F; 翻转单词                reverse(s.begin() + idx - (end - start), s.begin() + idx); &#x2F;&#x2F; 翻转单词                start &#x3D; end;            &#125;        &#125;        s.erase(s.begin() + idx, s.end()); &#x2F;&#x2F; 删除多余的空格        return s;    &#125;&#125;;</code></pre><blockquote><p>当我们调用reverse函数时，它会将字符串中的字符进行翻转。例如，如果我们有一个字符串”hello”，那么调用reverse函数后，它会变成”olleh”。在这个题目中，我们需要将整个字符串进行翻转，所以我们调用了reverse(s.begin(), s.end())函数来实现这个功能。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你反转字符串中 &lt;strong&gt;单词&lt;/strong&gt; 的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单词&lt;/strong&gt; 是由非空格字符组成的字符串。&lt;code&gt;s&lt;/code&gt; 中使用至少一个空格将字符串中的 &lt;strong&gt;单词&lt;/strong&gt; 分隔开。&lt;/p&gt;
&lt;p&gt;返回 &lt;strong&gt;单词&lt;/strong&gt; 顺序颠倒且 &lt;strong&gt;单词&lt;/strong&gt; 之间用单个空格连接的结果字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;输入字符串 &lt;code&gt;s&lt;/code&gt;中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>基于改进差分进化算法的云端科学工作流调度自适应故障检测策略</title>
    <link href="2023/03/21/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%91%E7%AB%AF%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%B0%83%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5/"/>
    <id>2023/03/21/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%91%E7%AB%AF%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%B0%83%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5/</id>
    <published>2023-03-21T12:03:37.000Z</published>
    <updated>2023-03-21T13:12:58.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于改进差分进化算法的云端科学工作流调度自适应故障检测策略"><a href="#基于改进差分进化算法的云端科学工作流调度自适应故障检测策略" class="headerlink" title="基于改进差分进化算法的云端科学工作流调度自适应故障检测策略"></a>基于改进差分进化算法的云端科学工作流调度自适应故障检测策略</h2><p>原题目：An adaptive fault detector strategy for scientific workflow scheduling based on improved differential evolution algorithm in cloud</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>讨论了在云计算环境中执行大规模科学工作流程的挑战，并提出了一种基于改进差分进化算法的<strong>自适应故障检测器策略</strong>，以最小化能源消耗、总成本和时间，并在调度科学工作流程时<strong>容忍故障</strong>。此外，该文章还介绍了一种自适应基于网络的模糊推理系统（ANFIS）预测模型，用于主动控制资源负载波动并提高故障预测准确性。</p><span id="more"></span><p><strong>通过对文章的阅读了解容错到底是什么</strong></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>介绍了在大规模的云计算环境中，错误会导致用于计算的虚拟机不可用，因此，通过提出一个有效且高效的容错策略来对错误发生时的问题进行处理是很有必要的。</p><p>传统方法进行容错的实现是需要了解云计算结构以及大量的知识和经验的，在实施时代价昂贵，且在缺少建模的条件下无法准确地进行容错评估。</p><p>在很多现实世界的工作流调度中，多目标优化方法可以用于优化虚拟机的任务调度以满足用户需求。然而大多数的现有方法并未考虑到容错技术的使用。</p><p>Differential evolution算法很高效，但也有陷入局部最优以及收敛过慢的问题，因此本文通过优化F和CR参数来解决这些问题</p><p>总的来说，本文的贡献是提出了一种自适应故障容错工作流调度方法，该方法基于改进差分进化算法和多目标IDE算法，结合主动和反应技术。该方法通过应用自适应基于网络的模糊推理系统（ANFIS）预测模型来预测未来资源负载，从而主动控制资源负载波动并提高故障预测准确性。此外，在故障&#x2F;失败发生后，该方法还通过反应性容错控制器来保证应用程序执行的可靠性。这种方法可以最小化能源消耗、总成本和时间，并在调度科学工作流程时容忍故障。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>本文的相关工作主要讨论了故障检测和容错技术在云计算环境中的应用。文章指出，故障发生在系统中表明任务执行能力的无法实现，可能发生在网络的任何节点或任何过程中的不同组件中。相关工作还探讨了云计算环境下的工作流调度问题，并介绍了一些传统方法，如遗传算法、蚁群算法和粒子群优化算法等。此外，相关工作还介绍了一些基于云计算环境的故障检测和容错技术，如虚拟机迁移、备份和恢复等。</p><p><img src="http://cdn.leafii.top/img/image-20230321202533280.png" alt="image-20230321202533280" loading="lazy"></p><h3 id="Workflow-model"><a href="#Workflow-model" class="headerlink" title="Workflow model"></a>Workflow model</h3><p>本文的工作流模型使用了直接无环图（DAG）来表示云计算环境中的工作流。该模型由一组任务和任务之间的依赖关系组成，其中每个任务都有一个权重，表示其参考值。具体地，该模型可以表示为： $W&#x3D;(T,D)$ 其中，$T&#x3D;{T_0,T_1,…,T_n}$是一组任务，$D&#x3D;{(T_i,T_j)|T_i,T_j \in T}$是任务之间的依赖关系集合。 每个任务都有一个权重$w_i$，表示其参考值。因此，我们可以将工作流模型表示为一个带权有向无环图（weighted directed acyclic graph），如下所示： $$G&#x3D;(V,E)$$ 其中，$V&#x3D;{v_0,v_1,…,v_n}$是节点集合，对应于任务集合$T$；$E&#x3D;{(v_i,v_j)|w_{ij}\neq 0}$是边集合，对应于依赖关系集合$D$。</p><p><img src="http://cdn.leafii.top/img/image-20230321202544971.png" alt="image-20230321202544971" loading="lazy"></p><blockquote><p>DAG是一种有向无环图，其中每个节点表示一个任务，每条边表示任务之间的依赖关系。在云计算环境中，DAG通常用于表示工作流模型，其中每个任务都有一个权重，表示其参考值。DAG可以帮助我们更好地理解和可视化工作流程，并且可以用于优化工作流程的调度和执行。在本文中，作者使用了一个样例DAG来说明其应用。</p></blockquote><h3 id="Proposed-framework"><a href="#Proposed-framework" class="headerlink" title="Proposed framework"></a>Proposed framework</h3><p>本文的proposed framework主要提出了一种基于自适应故障容错技术的多目标工作流调度框架。该框架使用了主动和反应技术来控制资源负载波动，并通过反应性容错控制器来保证应用程序执行的可靠性。具体来说，该框架包括以下组件： </p><ol><li>Workflow task queue：将用户提交的工作流程按照一定规则排列在队列中，等待分配到云数据中心的虚拟机上执行。</li><li>MAPE-k control loop：该控制循环由四个组件组成，包括monitor、analyzer、planner和executer。这些组件共享一个知识库，用于监测、分析、计划和执行工作流程。</li><li>ANFIS prediction model：该模型是一种自适应基于网络的模糊推理系统，用于预测未来资源负载，并通过主动控制资源负载波动来提高故障预测准确性。</li><li>Reactive fault-tolerant controller：该控制器是一种反应性容错技术，用于在故障&#x2F;失败发生后保证应用程序执行的可靠性。</li></ol><p> 本文提出的框架可以最小化能源消耗、总成本和时间，并在调度科学工作流程时容忍故障。</p><p><img src="http://cdn.leafii.top/img/image-20230321203418941.png" alt="image-20230321203418941" loading="lazy"></p><h4 id="Monitor-component"><a href="#Monitor-component" class="headerlink" title="Monitor component"></a>Monitor component</h4><p>Monitor component被描述为一个组件，其主要职责是收集云数据中心中的工作流任务信息和资源负载率。具体来说，用户传感器和资源传感器会在预定的时间间隔内从应用程序和云环境中收集足够的数据，并将其提供给Monitor component。其中，用户传感器的职责是收集用户工作流任务的信息（如请求速率、类型、大小等），而资源传感器的职责是收集资源负载率的信息（如CPU负载、应用内存和网络流量）。Monitor component会将监测到的数据进行整合，并存储在知识库中以供分析组件使用。</p><h4 id="Analyzer-component"><a href="#Analyzer-component" class="headerlink" title="Analyzer component"></a>Analyzer component</h4><p>在本文中，Analyzer component被描述为一个组件，其主要职责是分析Monitor component收集到的负载信息，并预测未来的资源负载。具体来说，Analyzer component使用ANFIS神经网络模型来预测未来的资源负载，并根据Monitor component的反馈进行调整。预测值会被传输到Planner component中，以便根据系统条件自适应地选择工作流调度算法。通过分析和预测资源负载，Analyzer component可以帮助实现负载均衡和最佳性能。</p><p>当Analyzer component接收到Monitor component传递的数据后，它会使用ANFIS神经网络模型来预测未来的资源负载。ANFIS模型是一种自适应基于网络的模糊推理系统，可以处理非线性和动态系统，并具有良好的泛化能力。在本文中，ANFIS模型被用于预测未来的资源负载，并根据Monitor component的反馈进行调整。具体来说，当预测值与实际值不匹配时，Analyzer component会根据误差信号对ANFIS模型进行调整，以提高预测准确性。 除了资源负载预测外，Analyzer component还可以执行其他分析任务，例如检查工作流任务之间的依赖关系、计算任务权重和优先级等。通过这些分析任务，Analyzer component可以帮助实现更好的工作流调度和执行效果。</p><h4 id="Fuzzy-Planner-component"><a href="#Fuzzy-Planner-component" class="headerlink" title="Fuzzy Planner component"></a>Fuzzy Planner component</h4><p>在本文中，Fuzzy Planner component被描述为一个组件，其主要职责是根据Analyzer component预测的资源负载来分配工作流任务到高效的云资源上。具体来说，Fuzzy Planner component使用三个模糊if-then规则来进行工作流任务分配： </p><ol><li>如果资源负载被预测为正常，则执行“无变化”命令，并调用IDE调度算法。 </li><li>如果资源负载被预测为高，则执行“未来可能发生错误”的命令，并调用主动容错控制器以减少负载。</li><li>如果资源负载被预测为非常高，则执行“故障发生”的命令。</li></ol><p> 这些规则是基于模糊逻辑和经验知识设计的，并可以根据实际情况进行修改和优化。通过使用Fuzzy Planner component，可以实现更好的工作流任务分配和资源利用率。</p><h5 id="IDE算法"><a href="#IDE算法" class="headerlink" title="IDE算法"></a>IDE算法</h5><p>在本文中，IDE算法的具体设计内容如下：</p><ol><li>初始化种群：首先，随机生成一组初始解作为种群，并计算每个解的适应度值。</li><li>变异操作：对于每个个体，随机选择另外两个不同的个体，并计算它们之间的差异向量。然后，将差异向量与当前个体进行加权和操作，得到一个新的变异向量。</li><li>交叉操作：将变异向量与当前个体进行交叉操作，得到一个新的解。</li><li>选择操作：根据适应度函数选择最优解，并将其作为下一代种群中的父代。</li><li>自适应参数设置：通过自适应参数设置技术来调整IDE算法中的参数。</li></ol><p>具体来说，通过监测种群中最优解和平均适应度值之间的差异来调整缩放因子和交叉概率等参数。 通过以上步骤，IDE算法可以在连续空间中寻找最优解，并且具有较好的收敛速度和搜索能力。</p><p>在本文中，IDE算法优化的目标是最小化工作流任务的makespan、总成本和能源消耗。具体来说，IDE算法的目标函数可以表示为： </p><p>$ f(x) &#x3D; w_1 \times makespan(x) + w_2 \times cost(x) + w_3 \times energy(x) $</p><p>其中，$x$表示工作流任务的调度方案，$makespan(x)$表示完成所有任务所需的时间，$cost(x)$表示执行任务所需的总成本，$energy(x)$表示执行任务所需的总能源消耗。$w_1, w_2, w_3$是权重系数，用于平衡不同目标之间的重要性。 通过优化上述目标函数，IDE算法可以得到一个最优的工作流调度方案，以实现更好的性能和效率。</p><h5 id="Proactive-fault-tolerance-controller"><a href="#Proactive-fault-tolerance-controller" class="headerlink" title="Proactive fault-tolerance controller"></a>Proactive fault-tolerance controller</h5><p>在本文中，Proactive fault-tolerance controller被描述为一种主动容错控制器，其主要目的是防止进入故障区域并将新负载分配给异常的虚拟机。具体来说，当Analyzer component检测到资源负载过高时，Fuzzy Planner component会调用Proactive fault-tolerance controller来减少负载并防止系统进入故障状态。 </p><p>Proactive fault-tolerance controller的实现方式是通过监测虚拟机的资源利用率和性能指标来判断是否存在异常情况。如果发现某个虚拟机出现了异常情况，则Proactive fault-tolerance controller会立即将其从负载均衡中移除，并将其上的任务重新分配给其他正常的虚拟机。这样可以避免故障扩散和系统崩溃。</p><p> 总之，Proactive fault-tolerance controller是一种有效的容错控制器，可以帮助云环境实现更好的容错性能和可靠性。</p><h5 id="Reactive-fault-tolerance-controller"><a href="#Reactive-fault-tolerance-controller" class="headerlink" title="Reactive fault-tolerance controller"></a>Reactive fault-tolerance controller</h5><p>在本文中，Reactive fault-tolerance controller被描述为一种响应式容错控制器，其主要目的是在故障发生后减少故障的影响。具体来说，当Analyzer component检测到某个虚拟机出现故障时，Fuzzy Planner component会调用Reactive fault-tolerance controller来处理故障并恢复系统正常运行。 </p><p>Reactive fault-tolerance controller的实现方式是通过使用复制技术来提供容错能力。具体来说，当某个虚拟机出现故障时，Reactive fault-tolerance controller会将该虚拟机上的任务复制到其他正常的虚拟机上，并重新分配这些任务以保证系统正常运行。这样可以避免任务丢失和系统崩溃。</p><p> 需要注意的是，Reactive fault-tolerance controller的主要缺点是成本较高。因为它需要额外的资源和计算能力来处理故障和执行复制操作。因此，在实际应用中需要权衡成本和性能之间的关系，并选择合适的容错策略。 </p><p>总之，Reactive fault-tolerance controller是一种有效的容错控制器，在云环境中可以帮助提高系统可靠性和容错性能。</p><h4 id="Executer-component-for-the-workflow-tasks-allocation"><a href="#Executer-component-for-the-workflow-tasks-allocation" class="headerlink" title="Executer component for the workflow tasks allocation"></a>Executer component for the workflow tasks allocation</h4><p>执行组件负责根据调度阶段执行的算法将用户发送的所有请求分配给现有的虚拟机。该组件负责实际执行规划组件决定的操作。</p><h3 id="Performance-evaluation"><a href="#Performance-evaluation" class="headerlink" title="Performance evaluation"></a>Performance evaluation</h3><p>实验部分不作具体分析</p><p>在本文中，“Performance evaluation”部分描述了作者如何评估所提出的工作流调度算法的性能。具体来说，作者使用了WorkflowSim-1.0工具包和CloudSim模拟器来模拟云环境中的工作流，并评估所提出的算法在不同负载下的性能表现。</p><p>在实验中，作者使用了一组实验设置，包括虚拟机数量、任务数量、任务大小等参数。通过对这些参数进行不同组合和调整，作者可以模拟不同负载下的云环境，并评估所提出算法的性能表现。 </p><p>最终，作者通过比较所提出算法和其他常用算法（如HEFT、Min-Min等）在不同负载下的性能指标（如makespan、总成本等）来评估其性能。实验结果表明，所提出算法可以显著提高系统性能和效率，并且在各项指标上均优于其他常用算法。 </p><p>总之，“Performance evaluation”部分描述了作者如何评估所提出算法的性能，并给出了实验结果和结论。这些结果可以帮助读者更好地理解该算法的优点和局限性，并为进一步研究和应用提供参考。</p><h4 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h4><p>“Conclusion and future work”部分是本文的结论和未来工作方向。具体来说，该部分总结了本文的主要贡献和发现，并提出了一些未来研究的方向。 </p><p>在结论部分，作者指出所提出的工作流调度算法可以显著提高云环境中的性能和效率，并且在各项指标上均优于其他常用算法。作者还强调了该算法的可扩展性和适应性，并指出它可以应用于不同类型的云环境和工作流场景。 </p><p>在未来工作方向中，作者提出了一些有待进一步研究的问题，如如何进一步优化算法性能、如何处理更复杂的工作流场景、如何实现更高效的容错机制等。这些问题都是当前云计算领域面临的挑战，也是未来研究需要解决的重要问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&quot;&gt;&lt;a href=&quot;#基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&quot; class=&quot;headerlink&quot; title=&quot;基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&quot;&gt;&lt;/a&gt;基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&lt;/h2&gt;&lt;p&gt;原题目：An adaptive fault detector strategy for scientific workflow scheduling based on improved differential evolution algorithm in cloud&lt;/p&gt;
&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;讨论了在云计算环境中执行大规模科学工作流程的挑战，并提出了一种基于改进差分进化算法的&lt;strong&gt;自适应故障检测器策略&lt;/strong&gt;，以最小化能源消耗、总成本和时间，并在调度科学工作流程时&lt;strong&gt;容忍故障&lt;/strong&gt;。此外，该文章还介绍了一种自适应基于网络的模糊推理系统（ANFIS）预测模型，用于主动控制资源负载波动并提高故障预测准确性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="进化算法" scheme="tags/进化算法/"/>
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode28.找出字符串中第一个匹配项的下标</title>
    <link href="2023/03/21/leetcode28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/"/>
    <id>2023/03/21/leetcode28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</id>
    <published>2023-03-21T08:03:49.000Z</published>
    <updated>2023-03-21T08:55:29.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：haystack &#x3D; &quot;sadbutsad&quot;, needle &#x3D; &quot;sad&quot;输出：0解释：&quot;sad&quot; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：haystack &#x3D; &quot;leetcode&quot;, needle &#x3D; &quot;leeto&quot;输出：-1解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>暴力解法</li></ol><p>首先判断haystack的长度是否小于needle，若小于则直接返回-1.然后对haystack进行遍历，若haystack[i]&#x3D;&#x3D;needle[0]，则说明haystack同needle的第一个字符匹配了，此时直接求haystack在i上长度为needle长度的子串并比较他们是否相等，若相等则直接返回i即可，否则继续遍历haystack。C++解法如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        int m &#x3D; haystack.length();         int n &#x3D; needle.length(); &#x2F;&#x2F; 分别求两个字符串的长度        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; 此判断符合strStr函数的原始定义        if (m &lt; n) return -1; &#x2F;&#x2F; 若haystack长度小于needle长度，则直接返回-1        for (int i &#x3D; 0; i &lt; m; i++) &#123; &#x2F;&#x2F; 遍历匹配第一个字母            if (haystack[i] &#x3D;&#x3D; needle[0]) &#123; &#x2F;&#x2F; 若第一个字母成功匹配                string temp &#x3D; haystack.substr(i, n); &#x2F;&#x2F; 直接求下标为i，长度同needle相等的子串temp                if (temp &#x3D;&#x3D; needle) &#123; &#x2F;&#x2F; 判断temp与needle是否相等                    return i; &#x2F;&#x2F; 若相等，则直接返回i                &#125;            &#125;        &#125;        return -1; &#x2F;&#x2F; 否则返回-1    &#125;&#125;;</code></pre><ol start="2"><li>KMP算法</li></ol><p>KMP的详细介绍：<a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html</a></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void getNext(int* next, const string&amp; s) &#123;        int j &#x3D; -1;        next[0] &#x3D; j;        for(int i &#x3D; 1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 注意i从1开始            while (j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; s[j+1]) &#123; &#x2F;&#x2F;前后缀不相同了                j &#x3D; next[j];            &#125;            if (s[i] &#x3D;&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 找到相同的前后缀                j++;            &#125;            next[i] &#x3D; j; &#x2F;&#x2F; 将j（前缀的长度）赋给next[i]        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if (needle.size() &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);        int j &#x3D; -1;        for (int i &#x3D; 0; i &lt; haystack.size(); i++) &#123; &#x2F;&#x2F; 注意i从0开始            while(j &gt;&#x3D; 0 &amp;&amp; haystack[i] !&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 不匹配                j &#x3D; next[j]; &#x2F;&#x2F; j寻找之前匹配的位置            &#125;            if (haystack[i] &#x3D;&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 匹配，j和i同时向后移动                j++;            &#125;            if (j &#x3D;&#x3D;(needle.size() - 1))  &#123; &#x2F;&#x2F; 文本串s里出现了模式串t                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;haystack&lt;/code&gt; 和 &lt;code&gt;needle&lt;/code&gt; ，请你在 &lt;code&gt;haystack&lt;/code&gt; 字符串中找出 &lt;code&gt;needle&lt;/code&gt; 字符串的第一个匹配项的下标（下标从 0 开始）。如果 &lt;code&gt;needle&lt;/code&gt; 不是 &lt;code&gt;haystack&lt;/code&gt; 的一部分，则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer05.替换空格</title>
    <link href="2023/03/20/%E5%89%91%E6%8C%87Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>2023/03/20/%E5%89%91%E6%8C%87Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2023-03-20T08:11:28.000Z</published>
    <updated>2023-03-20T08:16:16.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><p><strong>限制：</strong></p><pre class="language-none"><code class="language-none">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>常规思路</li></ul><p>新建一个string类型的变量result，对输入的字符串s的每个字符进行判断，若字符为空格，则<code>result+=&quot;%20;&quot;</code>，否则<code>result+=s[i];</code>，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string replaceSpace(string s) &#123;        string result &#x3D; &quot;&quot;; &#x2F;&#x2F; 定义结果字符串result        int n &#x3D; s.length(); &#x2F;&#x2F; 获取输入字符串s的长度        for(int i &#x3D; 0; i &lt; n; i++) &#123; &#x2F;&#x2F; 进行遍历            if (s[i] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 若s[i]为空格，则result+&#x3D;&quot;%20&quot;;                result +&#x3D; &quot;%20&quot;;            &#125;            else &#123; &#x2F;&#x2F; 否则直接+&#x3D;s[i];                result +&#x3D; s[i];            &#125;        &#125;        return result; &#x2F;&#x2F; 最后返回结果值result    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;请实现一个函数，把字符串 &lt;code&gt;s&lt;/code&gt; 中的每个空格替换成”%20”。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
