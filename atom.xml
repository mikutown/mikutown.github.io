<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-05-07T08:05:13.633Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一种基于任务网络图聚合的多卫星多任务调度新方法</title>
    <link href="2023/05/07/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%BD%91%E7%BB%9C%E5%9B%BE%E8%81%9A%E5%90%88%E7%9A%84%E5%A4%9A%E5%8D%AB%E6%98%9F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%96%B0%E6%96%B9%E6%B3%95/"/>
    <id>2023/05/07/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%BD%91%E7%BB%9C%E5%9B%BE%E8%81%9A%E5%90%88%E7%9A%84%E5%A4%9A%E5%8D%AB%E6%98%9F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%96%B0%E6%96%B9%E6%B3%95/</id>
    <published>2023-05-07T07:37:24.000Z</published>
    <updated>2023-05-07T08:05:13.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>卫星网络任务调度时效性问题是实现空地一体化网络（STIN）的关键。传统方法将卫星任务调度问题解释为线性或非线性规划问题，忽略了任务之间的复杂关系。为了提高多卫星和多任务场景中任务调度的及时性，我们研究了解释任务相关性的网络图结构。然后，我们针对具有相似性和相关性特征的任务提出了多层网络图聚合模型。进一步，我们将任务调度问题转化为零-一规划问题，设计任务调度算法来解决任务调度时效性问题。最后，我们模拟和模拟真实世界的数据作为实验数据集，用于与三种基线算法进行比较。实验结果表明本文方法具有明显的优势和进步。</p><span id="more"></span><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文的Introduction部分首先介绍了卫星任务调度的背景和意义，指出卫星任务调度是卫星运行中最重要的环节之一，其质量直接影响到卫星系统的性能和效益。然后，介绍了传统方法在多卫星和多任务场景下存在的问题，包括复杂的任务关系、低效的任务调度及时性等。接着，本文提出了一种基于任务网络图聚合的新方法来改善任务调度及时性。该方法将不同卫星上的原子任务聚合成一个整体图，并通过优化算法实现对整体图进行调度。最后，Introduction简要介绍了本文研究内容和结构安排，包括模型构建、算法设计、仿真实验等方面。</p><p>我们的贡献可以简要总结如下：</p><ul><li>我们建立了任务的网络图表示方法，解决了多卫星多任务关系复杂难表示的问题，实现了多任务复杂关系的统一表示。首先，我们根据任务的初始执行时间、资源需求、资源类型、任务操作等任务属性设计了任务的五元组。然后，我们将任务表示为边，任务属性表示为边属性，开始和结束执行事件表示为节点。根据任务执行时间的顺序，将任务之间的关系映射到边之间的关系，构建任务网络图。另外，我们根据资源类型、资源数量、可见时间窗的起止时间属性，设计了卫星的五元组。</li><li>我们构建了任务网络图的相似性聚合和相关性聚合模型，可以解决相似任务重复执行和相关任务独立分配带来的相互约束问题，实现多任务执行时间的最大压缩.首先，我们构建了多层任务网络图的聚合模型。根据任务之间的相似性和相关性，我们将所有任务网络图重构并聚合成一个大的任务网络图。然后，我们根据网络图和任务网络图中的关键路径计算出每个任务的最早开始执行时间和最晚结束执行时间，即完成所有任务的理论最短时间。</li><li>我们设计了多星多任务调度优化算法，保证大规模任务网络图能够在最短的理论时间内执行，实现多星多任务调度的高时效性。如果任务网络图中关键路径上的任务按时执行，任务网络图中的其他任务也会在资源充足时执行。因此，我们将多卫星和多任务调度问题解释为一个零一规划问题。然后，我们优先考虑关键路径上任务的资源分配策略，然后基于零一规划模型为剩余任务分配空闲卫星资源。</li></ul><h2 id="3-问题描述-amp-模型构建"><a href="#3-问题描述-amp-模型构建" class="headerlink" title="3. 问题描述&amp;模型构建"></a>3. 问题描述&amp;模型构建</h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h3><p>原子问题五元组：$\alpha &#x3D; &lt; t_{start}, r_t, r_n, oper, t_{end}&gt;$,tstart表示原子任务的计划初始执行时间，rt表示原子任务的资源需求类型，rn表示原子任务的资源需求，oper表示原子任务在卫星上的运行，tend表示最新的计划的执行时间。</p><p>可用卫星问题五元组：$s &#x3D; &lt;st_{start}, sr_t,sr_n, soper, st_{end}&gt;$,ststart表示卫星可见时间窗的开始时间，srt表示卫星当前提供的资源类型，srn表示卫星当前时刻可以提供的资源总量，soper表示卫星运行，stend表示可见时间窗的结束时间。</p><p>定义1 原子任务α由卫星直接执行，执行过程中不允许被打断。原子任务是从任务σ中分解出来的。</p><p>任务σ的原子任务α具有顺序执行关系，原子任务之间相互包容、相互制约。也就是说，有些原子任务只有在其他原子任务执行完之后才能执行。一般来说，原子任务有不同的资源类型、数量要求和初始执行时间，多个卫星可以满足同一个原子任务的资源需求。根据医院信息网络动态时变环境下原子任务的这些特点，计算多任务原子任务的执行顺序和执行时间，保证任务执行时间最短是关键问题。</p><h3 id="3-2-最短时间内完成机载多任务执行顺序动态计算模型"><a href="#3-2-最短时间内完成机载多任务执行顺序动态计算模型" class="headerlink" title="3.2 最短时间内完成机载多任务执行顺序动态计算模型"></a>3.2 最短时间内完成机载多任务执行顺序动态计算模型</h3><p>主要解决最小化任务执行时间的问题，假设特定时间段的开始时间为 Tstart ，结束时间为 Tend 。然后，</p><p><img src="http://cdn.leafii.top/img/image-20230507152603783.png" alt="image-20230507152603783" loading="lazy"></p><p>如式(3)所示，pi表示一个离散的时间段。 C1 表示 Γ 中的任何离散周期时间未被覆盖或重叠。 C2 表示从离散时间 i 到 j 的时间段为 pς 。我们需要计算任务执行在离散时间段Γ内的最短耗时，建立优化模型如下：</p><p><img src="http://cdn.leafii.top/img/image-20230507152625126.png" alt="image-20230507152625126" loading="lazy"></p><p>如式(4)所示，表示任意时间段Γ内所有原子任务并行执行消耗的最小时间的计算方法。 p(i, j) ∈ Γ 表示在 Γ 中的一个小时间段，p(i, j) 不为零，即 i ≠ j。式(4)中，C1表示任意时间段p(i,j)的有效时间为p(θ,θ‘)。如图1所示，p(i,j)是随机考虑的某个时间段。该时间段包含的任务执行队列中最新任务的执行结束时间不一定严格等于j，即θ为p(i,j)中执行的第一个任务1的开始执行时间。同理，θ为最后一个任务8的执行结束时间。因此，我们取时间段p(i,j)内执行的第一个任务开始执行时间为θ，最后一个任务执行结束时间是θ’，p(θ, θ‘) ∈ τ 表示为 p(i, j) 中的多个任务全部执行完毕的最大起止时间。p(θ, θ’) 包含可以在 K(θ − θ’) 的时间段内完成的完整任务集。在离散时间段(θ,θ‘)中，我们取当前时间段内所有任务执行时间的最大值，max∀k∈K(t) Ct(k)表示所有任务的最大耗时值在时间 t 正在执行的任务。例如，式（4）中的C2表示单位时间的耗时约束。我们假设t是单位时间，那么任务Ct(k)的耗时为1。此时我们可以观察到在任务未执行时Ct(k)的值为0。另外，如果有正在执行的任务，则当前时刻消耗的时间记录为1，因此图1中所有任务消耗的最大时间为θ’-θ-(b-a)。</p><p><img src="http://cdn.leafii.top/img/image-20230507152752798.png" alt="image-20230507152752798" loading="lazy"></p><p>值得一提的是，式（4）中所有任务最早开始执行和最晚结束执行的时间和执行顺序<strong>并不准确</strong>，从而导致出现多种组合。不幸的是，当我们遍历所有可能的组合时，这对卫星的计算能力来说将是灾难性的。此外，它消耗了大量的计算时间，导致卫星网络执行任务的时效性差。那么，关键问题是如何快速计算出原子任务的执行顺序，并保证消耗的时间最少。</p><h2 id="4-问题转化和解决方式"><a href="#4-问题转化和解决方式" class="headerlink" title="4. 问题转化和解决方式"></a>4. 问题转化和解决方式</h2><p>将最小化执行时间的问题转化为两个子问题：<strong>计算原子任务开始和结束时间的问题</strong>以及<strong>聚合相似原子任务问题</strong></p><p>计算原子任务开始和结束时间的问题：确定原子任务的最早开始和最晚结束执行时间，以减少原子任务执行时间内的组合数量，将多种组合方案减少为少数几种可组合方案。然后，我们计算原子任务的最晚开始执行时间和最早结束执行时间，并结合结果数据确定某些任务的开始和结束执行时间。这个时候，原子任务的执行顺序也已经确定了。</p><p>聚合相似原子任务问题：我们根据原子任务之间的相似特征和相关关系特征聚合相似的任务执行，节省重复执行原子任务所消耗的时间。</p><h3 id="4-1-基于网络图表示的关键原子任务计算模型与算法"><a href="#4-1-基于网络图表示的关键原子任务计算模型与算法" class="headerlink" title="4.1 基于网络图表示的关键原子任务计算模型与算法"></a>4.1 基于网络图表示的关键原子任务计算模型与算法</h3><p>我们给定原子任务的统一表示元组。原子任务作为网络图的边，元组元素作为边的属性。节点表示原子任务开始或者结束执行的事件。原子任务之间复杂的关系由网络图结构进行表示。网络图的计算由两个元素组成：首先，每一个边的最早开始时间和最晚结束时间被用于计算原子任务的执行的时间范围。然后网络图的关键路径被计算，在关键路径上的任务必要的原子任务。如果原子任务的优先计算得到了保障，那么我们可以得到所有原子任务的最小执行时间。</p><p>我们使用网络图数据结构去表示原子任务，然后重新定义了原子任务。原子任务由以下式子表示：</p><p>$\alpha’ &#x3D; &lt;t’_{start}, t_{start}, r_t, r_n, oper, t_{end}, t’_{end}&gt;$</p><p>我们添加了原子任务的最早可能开始时间 t′ start 和允许完成执行的最晚时间 t′ end 。一个任务 σ 可以分解为多个原子任务 σ &#x3D; {α′ 1, α′ 2, α′ 3, … , α′ n}。</p><h4 id="4-1-1-任务网络图表示"><a href="#4-1-1-任务网络图表示" class="headerlink" title="4.1.1 任务网络图表示"></a>4.1.1 任务网络图表示</h4><p>根据原子任务集合中原子任务的优先级重新分配原子任务的执行顺序，并且获得新的原子任务队列。我们将网络中的边表示为网络图的原子任务。图中的节点表示为原子任务执行的事件。</p><p><img src="http://cdn.leafii.top/img/image-20230505174740721.png" alt="image-20230505174740721" loading="lazy"></p><blockquote><p>示意图显示了原子任务之间的依赖关系。子图(a)表示边代表原子任务，子图(b)节点表示原子任务执行的事件。</p></blockquote><p>在构建任务网络图之前，我们需要计算原子任务的计划完成时间。</p><p>$P(\alpha’<em>i) &#x3D; t</em>{end, i} - t_{start, i}$</p><p>这个式子里的$P(\alpha’_i)$就是原子任务$\alpha’_i$的计划完成时间。</p><p>然后边的属性可以表示为$w_i &#x3D; (t’<em>{start}, A_i, t’</em>{end})$,而且边的属性的集合为$W &#x3D; {w_1, w_2, …, w_m}$</p><h4 id="4-1-2-任务网络图计算模型"><a href="#4-1-2-任务网络图计算模型" class="headerlink" title="4.1.2 任务网络图计算模型"></a>4.1.2 任务网络图计算模型</h4><p>如图所示。$v_1$是任务执行开始的事件，$v_7$是任务执行结束时的事件。图G表示一个特定任务的所有原子任务的依赖关系。节点上的出度边所代表的原子任务可以在节点上的入度边所代表的原子任务完成后执行。边的属性信息W表示原子任务的执行时间、最早执行时间和最晚执行时间。</p><p><img src="http://cdn.leafii.top/img/image-20230505191049565.png" alt="image-20230505191049565" loading="lazy"></p><p>引理1. 关键路径的引理和证明 略</p><p>定理1. T 是关键路径上的关键任务集。除关键路径P的任务集外，其余任务集为Q。C(T) + C(Q) &#x3D; min(C(G))，其中执行 T 的时间成本是 C(T)，执行 Q 的时间成本是 C(Q)， 时间成本的证明略</p><p>从引理 1 可以看出，我们关心的是任务的开始和结束事件最早和最晚发生的时间，网络中最后一个事件的完成时间就是整个图像完成的时间。然而，定理 1 关注的是网络图中所有边所代表的任务执行时间和成本的总和。同时，时间成本是网络图上边的权重。</p><p>为了保证提升任务执行效率并缩短任务的执行时间，我们需要计算完成任务所需的最短时间以及对任务执行时间有影响的关键任务。如果我们保证关键任务的正常执行，那么理论上我们可以获得网络图执行的最短时间。对于任务网络图G，是完成最后一个事件Vm和每个原子任务的关键性的最短时间。同时，我们可以参考AOE（Activity on edge network）网络的关键路径计算方法。</p><p><img src="http://cdn.leafii.top/img/image-20230505192540505.png" alt="image-20230505192540505" loading="lazy"></p><p>te(vj )表示任务事件最早发生的时间，P(ez)表示执行原子任务所需的时间。在约束条件C1中，T是所有以顶点vk结尾的边的头顶点集合，ez代表所有以顶点vk结尾的边。ez 表示所有以顶点 vk 结尾的边。以节点vj的所有原子任务中执行时间最长的原子任务为出度，事件vi最早发生时间之和就是事件vi最早发生时间。</p><p>从已完成的顶点vn开始，令l(vn) &#x3D; e(vn)求拓扑序中剩余顶点的最晚允许出现时间。如式(8)所示，S是所有以vj为头的弧的尾顶点的集合。如约束条件 C2 所示，j 必须满足约束条件 1 ⩽ j ⩽ n − 1。</p><p><img src="http://cdn.leafii.top/img/image-20230505193310443.png" alt="image-20230505193310443" loading="lazy"></p><p>找出每个原子任务ei的最早开始时间e(i) &#x3D; e(vj ), 1 ⩽ i ⩽ m，最晚开始时间l(i) &#x3D; l(vk) − P (vj , vk)。如果一个弧**满足e(i) &#x3D; l(i)**，那么它就是一个关键任务。</p><h4 id="4-1-3-关键原子任务的计算算法"><a href="#4-1-3-关键原子任务的计算算法" class="headerlink" title="4.1.3 关键原子任务的计算算法"></a>4.1.3 关键原子任务的计算算法</h4><p>由上述的（8）和（7），我们设计了一个网络图计算算法，算法如下：</p><p><img src="http://cdn.leafii.top/img/image-20230505193623442.png" alt="image-20230505193623442" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230505193635610.png" alt="image-20230505193635610" loading="lazy"></p><p>算法2的设计参考了AOE网络的关键路径求解方法。首先，算法1被用于创建一个任务网络图并且进行拓扑排序的操作，并且初始化所有时间的发生时间为0.算法 2 以网络图作为输入数据（第 1-3 行），然后根据拓扑排序顺序从前到后更新事件的最早执行时间。用每个顶点的每个相邻点更新e(v)，其值是连接到当前节点和相邻节点的所有边的最大值与当前最早时间之和（第4-9行）。同理，按照拓扑排序顺序，从后向前更新节点最晚出现时间l(v)（第10行），求出每个原子最早出现时间e(edge)和最晚出现时间l(edge)根据 e(v) 和 l(v) 的任务。根据e(edge)和l(edge)是否相等判断原子任务是否为关键原子任务。网络图中最后一个节点的最早出现时间是整个任务的最早完成时间（第 11-22 行）。</p><h3 id="4-2-基于原子任务相似特征的多网络图聚合模型及算法"><a href="#4-2-基于原子任务相似特征的多网络图聚合模型及算法" class="headerlink" title="4.2 基于原子任务相似特征的多网络图聚合模型及算法"></a>4.2 基于原子任务相似特征的多网络图聚合模型及算法</h3><p>通过考虑原子任务的相似性和相关特征，我们将不同的网络图聚合成一整个图。拥有相似特征的原子任务可以被组合为一个简单的原子任务。同样的，有关联的多原子任务可以被聚合成一个可以在单个卫星完成的不可分解的任务集合。由于多层网络图在聚合过程有环路，会导致<strong>计算关键路径</strong>失败。因此，我们基于剪枝的思想设计了一种破环算法来实现多层网络图聚合的目的。</p><p>基于刚才提出的网络图表示方法，我们可以把多任务表示为多网络图。在网络图之间偶尔会有很多边会被合并从而形成一个大范围的网络图。定义3解释了任务聚合，也就根据特定的规则将多个网络图合并为一个网络图。任务聚合的规则有两方面：依赖聚合关系以及相似聚合关系。定义4解释了依赖聚合关系的定义，定义5解释了相似聚合关系的定义。</p><p>定义3 任务聚合是指分析多个任务的原子任务集φ并将满足特定约束的多个原子任务聚合到一颗卫星上执行，或者将多个具有相似特征的原子任务合并为一个原子任务。最终形成一组新的原子任务。聚类后的任务集仍然是原子任务集。</p><p>定义4 依赖聚合关系是指原子任务执行顺序之间的相互依赖关系。如果一个原子任务αi的执行结果是另一个或多个原子任务的执行前提，则这些原子任务满足依赖聚合关系。</p><p>依赖包括多对一的依赖以及一对一的依赖，如图所示.</p><p><img src="http://cdn.leafii.top/img/image-20230506204533547.png" alt="image-20230506204533547" loading="lazy"></p><p>定义5 相似聚合关系定义为原子任务之间存在相似的资源需求、任务需求或执行结果。如果同一卫星在同一周期内可以执行多个原子任务，则这些原子任务之间满足相似聚合关系。</p><p>如图6所示，子图(a)描述了分散在多颗卫星上的具有相似特征的多个原子任务，子图(b)描述了可以包含其他原子任务特征的原子任务，子图(c)描述了多颗卫星- 原子任务聚合成一个原子任务。</p><p><img src="http://cdn.leafii.top/img/image-20230506204630468.png" alt="image-20230506204630468" loading="lazy"></p><p>目标原子任务的执行结果数据包含所有源原子任务的执行结果数据。所以目标原子任务可以代替所有源原子任务的执行过程。</p><h4 id="4-2-1-相似原子任务聚合模型"><a href="#4-2-1-相似原子任务聚合模型" class="headerlink" title="4.2.1 相似原子任务聚合模型"></a>4.2.1 相似原子任务聚合模型</h4><p>为了降低非必要任务执行的影响，我们研究了所有相似和相关任务聚合的方法。所有的原子任务都在集合X上执行，单颗卫星可以独立完成一个原子任务，不需要多颗卫星联合执行。集合Z&#x3D;{R,B,L}中所有具有依赖关系的原子任务记为R。具有相似关系的所有原子任务的集合为B&#x3D;{S,H}，S表示具有相似关系的所有目标原子任务的集合相似关系，H表示具有所有相似关系的原子源任务集合，所有不符合聚合关系的原子任务集合为L，则原子任务集合Z由卫星集合X执行完成所需的总消耗的时间如方程式所示。 (12),</p><p><img src="http://cdn.leafii.top/img/image-20230506213501362.png" alt="image-20230506213501362" loading="lazy"></p><p>我们将执行具有依赖关系的所有目标原子任务集合R的卫星集合记为A，将执行具有依赖关系的目标原子任务αr的卫星记为xr，则所有具有依赖关系的原子任务聚合后消耗的时间模型如下所示在 (13)</p><p><img src="http://cdn.leafii.top/img/image-20230506214147818.png" alt="image-20230506214147818" loading="lazy"></p><p>T(R)表示所有具有依赖关系的原子任务集合执行所消耗时间的总和。</p><p>把10和9式子放进13中，可得到式14:</p><p><img src="http://cdn.leafii.top/img/image-20230506214341116.png" alt="image-20230506214341116" loading="lazy"></p><p>我们将执行具有相似关系S的所有目标原子任务的卫星集合表示为B，将执行目标原子任务s的卫星表示为xs。则聚合后所有具有相似关系的原子任务消耗的时间模型如式(15)所示。</p><p><img src="http://cdn.leafii.top/img/image-20230506214437470.png" alt="image-20230506214437470" loading="lazy"></p><p>C(γ(s), xs)表示目标原子任务s在卫星xs上消耗的执行时间。C1是对目标原子任务集合的距离约束，表示卫星执行原子任务时天线角度或遥感设备角度等操作的转换时间。 C2是具有相似特征的源和目标原子任务之间的约束关系。</p><p>所有原子任务集合Z中除相似特征原子任务和原子依赖任务外其余任务的执行耗时可构造为式(16)，</p><p><img src="http://cdn.leafii.top/img/image-20230506214559626.png" alt="image-20230506214559626" loading="lazy"></p><p>D是执行原子任务集合L的卫星集合，C(γ(l),xl)是执行不可聚合的原子任务所消耗的时间，xl是执行原子任务l的卫星。</p><p>综上所述，我们构建了可聚合的原子任务执行时间消耗模型和其他原子任务执行时间消耗模型。 代入方程式。 （14），（15）和（16）进入等式。 (12) 产生执行和完成所有任务 N 所消耗的时间总和。 时间消耗如方程式 (17)所示。</p><p><img src="http://cdn.leafii.top/img/image-20230506214727347.png" alt="image-20230506214727347" loading="lazy"></p><p>其中C1-C2表示所有可聚合原子任务与其他原子任务的关系和范围，所有任务执行时间T都不为0。C3-C5说明具有可聚合关系的源原子任务和目标原子任务之间的关系和约束。 C6表示原子任务执行过程中卫星完成天线或载荷设备角度调整所消耗的时间，我们默认为一个固定值。</p><p>总之，我们对多颗卫星上多任务执行的时间消耗进行建模，如式（17）所示，并求解该式。 𝑇 预先假定需要确定哪些原子任务有资格进行聚合以及选择卫星来执行它们。 一旦确定了这些要求，就可以<strong>更新聚合原子任务的网络图表示</strong>，然后可以根据算法2<strong>求解多任务执行的最小时间消耗</strong>。</p><h4 id="4-2-2-相似原子任务聚合算法"><a href="#4-2-2-相似原子任务聚合算法" class="headerlink" title="4.2.2 相似原子任务聚合算法"></a>4.2.2 相似原子任务聚合算法</h4><p>本节我们基于上述多层网络聚合模型设计相应的求解算法。在多图聚合的过程中，我们发现了多图聚合后产生循环的情况。我们设计了一种聚合后不产生循环的算法，并建立了一种消除任务网络图中循环的方法。</p><h5 id="A-层任务网络图的相似度聚合算法"><a href="#A-层任务网络图的相似度聚合算法" class="headerlink" title="A. 层任务网络图的相似度聚合算法"></a>A. 层任务网络图的相似度聚合算法</h5><p><img src="http://cdn.leafii.top/img/image-20230506215146281.png" alt="image-20230506215146281" loading="lazy"></p><p>在图7的a中有两个网络图的初始状态。我们基于原子任务的属性特征不同来计算任务之间的相似度。比如，如果多个观测任务的观测区域重叠，在观测任务的一些原子任务之间就有一个相似度。观察区域覆盖率较大的原子任务就是需要聚合的目标原子任务，我们称之为目标原子任务。观察目标区域较小的原子任务是等待聚合的原子源任务，我们称之为源原子任务。根据这些规则，我们确定要在多图中聚合的目标任务和源原子任务。</p><p>值得一提的是，目标原子任务可以有多个源原子任务与之对应，而源原子任务只有一个目标原子任务。如图b，蓝色的边表示目标原子任务，红边表示源原子任务。再决定目标和源原子任务后，我们需要跨越多个图并建立源原子任务和原子目标任务之间的关系。如图c所示，我们通过创建9-&gt;3和5-&gt;12虚拟边来聚合两个图。尽管多个图可以通过虚拟边聚合为一个图，额外的虚拟边以及属性值的设定影响着多图聚合的效果。因此，我们将虚拟边的属性值设置为0并且用最少的虚拟边将原子目标任务进行连接。子图 (c) 描绘了具有多个源节点 1,8 和多个汇点 7,14 的完整网络图。此时的网络图并没有计算使用算法2的所有任务的最小消耗时间和关键原子任务。因此我们需要把多源多沉没的网络图表示为单源单沉没的网络图。如图d所示，我们增加两个虚拟事件0，-1，虚拟事件0是网络图的源，虚拟事件1时网络图的下沉。同时，我们增加虚拟边0-&gt;1, 0-&gt;8, 7-&gt;-1, 14-&gt;-1到网络图中。此外，红色边被蓝色边合并，并且虚拟边被创建去消除原子源任务，消除了完成两个原子任务的需求以实现仅一个目标原子任务的目标。新的逻辑虚拟结点表示一个空的原子任务，它并未被执行。在消除原子源任务9-&gt;12后，与其关联的事件9,12也可消除。如图e所示，事件9和3被合并，事件12和5被合并，最终导致一个完整的网络图被聚合。</p><p><img src="http://cdn.leafii.top/img/image-20230506223615258.png" alt="image-20230506223615258" loading="lazy"></p><p>如图8所示，图a到f描述了拥有一个目标原子任务的多源原子任务的聚合过程。图a描述了两个任务的网络图的初始状态。图b表示聚合关系的计算结果，蓝色边表示原子目标任务，红色边表示要被合并的原子源任务。如图c所示，虚拟边9-&gt;3，5-&gt;12以及11-&gt;3,5-&gt;10被添加用目标原子任务去合并两个源原子任务。如图d所示，为了将多源，多下沉网络图转化为单源，单下沉网络图，我们增加两个虚拟事件0，-1，我们添加两个虚拟事件 0、-1，以及虚拟边 0 → 1、0 → 8 和 7 → −1、14 → −1。剔除源原子任务 9 → 12 和 11 → 10 后，事件 9、11、12、10 就没有有意义的存在了。因此，事件9，11需要与事件3合并。同样，事件12，10需要与事件5合并，合并结果如子图（e）所示。我们发现事件 8 和事件 3 之间有两条边，即要执行的两个原子任务。类似地，在事件 5 和事件 14 之间有两个原子任务要执行。如子图 (f) 所示，我们的任务网络图表示中不允许两个相邻事件之间存在两条或更多条边。因此，我们添加两个虚拟事件-2、-3和两个虚拟边缘8→-2和-3→14。目标原子任务的虚拟事件、虚拟边缘和事件3,5之间的关系为8→ −2 → 3 和 5 → −3 → 14 其中 8 → −2 → 3 上的原子任务是随机选择子图 (e) 中事件 5 和事件 14 之间的两个原子任务。同样，5 → -3 → 14 是在事件 5 和事件 14 之间的两个原子任务中的随机选择。最后，根据原子任务相似性，将两个网络图表示为一个完整的网络图。</p><p><img src="http://cdn.leafii.top/img/image-20230507132332862.png" alt="image-20230507132332862" loading="lazy"></p><p>如图9所示，它描述了具有数据依赖性的原子任务之间的聚合过程。子图 (a) 显示了两个图的初始状态。子图 (b) 描述了两个图中的目标和源原子任务，其中蓝色边表示原子目标任务，两条红色边表示原子源任务。原子任务 4 → 6 的执行需要原子任务 10 → 14 和 13 → 14 的执行。关联原子任务聚合不是消除原子任务，而是将具有关联的原子任务从分散状态转换为集中状态。那么我们需要尽可能将具有相关性的原子任务分配给一颗卫星执行，这样可以减少大量卫星协同处理数据所花费的时间。如图(c)所示，虚拟边14→4连接两个图，虚拟节点0和虚拟边0→1、0→8将图从多源节点转变为单源节点。子图（d）描绘了事件14,4的合并，其中原始事件10→14、13→14被转换为10→4、13→4。原子目标任务和原子源任务没有改变，但它们的关系被改变，使它们更紧凑。根据卫星资源状况，我们可以考虑将新的目标原子任务4→6和原子源任务10→4、13→4在同一颗卫星上执行，减少数据请求和数据传输的耗时。</p><p>定理 2. 给定一个单源单汇网络图 G。如果 G 中存在任务 ei，则其属性五元组为 α(ei) &#x3D; ⟨tei start, rei t, rei n, operei, tei end⟩,以及任务执行时间范围 L(ei) &#x3D; (tei start, tei end)。存在一个任务 ej，其属性为 α(ej) &#x3D; ⟨tej start, rej t, rej n, operej , tej end⟩，任务执行时间范围为 L(ej ) &#x3D; (tej start, tej end)。如果rei t &#x3D; rej t, L(ei) ∩ L(ej ) ≠ ⊘，则存在一个任务ek 可以替代任务ei 和ej 并且任务ek 的耗时小于任务ei 和ej 的总和。</p><p>证明略</p><p>根据定理 2，我们构建任务 ek 来替换网络图 G 中的任务 ei 和 ej，并且任务 ek 被执行的时间成本小于任务 ei 和 ej 的总和。</p><p>算法3描述了原子任务相似性特征的多任务聚合过程。首先获取原子任务属性数据，然后计算不同原子任务的相似性特征（第 1-7 行）。基于每个原子任务的特征数据，采用K-均值聚类算法计算原子任务在多个网络图中的相似度，选择原子目标任务作为聚类算法的质心。与每个质心相邻的原子任务可视为原子源任务（第 9 行）。我们根据计算结果得到源和目标原子任务的启动和终止事件。然后我们构建一个虚拟链接，它建立在原子源任务的起始节点和目标原子任务的起始节点之间。目标原子任务的终止节点实际上链接到源原子任务的终止节点。最后，删除所有原子源任务（第 10-11 行）。如果两个事件之间存在两个或多个原子任务，则必须重建多个原子任务连接。我们通过构建虚拟节点和虚拟边（第 12-15 行）将额外的原子任务连接到新路径。最后，源原子任务的开始和结束节点与目标原子任务的开始和结束节点合并（第 16-17 行）。</p><p><img src="http://cdn.leafii.top/img/image-20230507134025076.png" alt="image-20230507134025076" loading="lazy"></p><h5 id="B-原子任务数据依赖的识别与聚合算法"><a href="#B-原子任务数据依赖的识别与聚合算法" class="headerlink" title="B. 原子任务数据依赖的识别与聚合算法"></a>B. 原子任务数据依赖的识别与聚合算法</h5><p>定理3. 给定一个单源单汇网络图 G。如果 G 中存在任务 ei，则其属性五元组为 α(ei) &#x3D; ⟨tei start, rei t, rei n, operei, tei end⟩,以及任务执行时间范围 L(ei) &#x3D; (tei start, tei end)。存在一个任务 ej，其属性为 α(ej) &#x3D; ⟨tej start, rej t, rej n, operej , tej end⟩，任务执行时间范围为 L(ej ) &#x3D; (tej start, tej end)。将任务𝑒𝑖和𝑒𝑗的执行过程产生的成本表示为𝜇，当𝑒𝑖是任务𝑒𝑗的入口度边时，任务𝑒𝑖和𝑒𝑗的执行过程产生的成本表示为𝜈，则𝜇⩾𝜈。</p><p>证明略。</p><p><img src="http://cdn.leafii.top/img/image-20230507134813348.png" alt="image-20230507134813348" loading="lazy"></p><p>由定理3可知，将具有相关关系的任务聚合在一起执行所消耗的成本要小于聚合前所消耗的成本。因此，我们根据定理3设计了基于多任务依赖关系的聚合算法4。该算法描述了原子任务相关关系特征的识别和多任务聚合过程。首先，我们获取原子任务属性数据，然后计算不同原子任务的相似性特征（第 1-7 行）。然后，根据每个原子任务的特征数据，我们计算原子任务在多个网络图中的相关性，输入数据是其他原子任务的输出数据，可以将其视为目标原子任务。相反，其输出数据可用作其他原子任务的输入数据的原子任务可被视为源原子任务（第 9 行）。基于计算出的源任务的端点事件和目标任务的起点事件，我们在源任务的端点事件和目标任务的起点之间创建了一个虚拟链接。为了构建单源单汇网络图，创建虚拟节点和虚拟边并将其链接到网络图的多个源和汇，并删除与源原子任务关联的虚拟边，最后将端点源原子任务的起点与目标原子任务的起点合并（代码 10-12）。</p><h5 id="C-消除网络图中多环路的形成"><a href="#C-消除网络图中多环路的形成" class="headerlink" title="C. 消除网络图中多环路的形成"></a>C. 消除网络图中多环路的形成</h5><p>A小节描述的多层网络图的聚合过程属于没有出现环路的情况。然而，现有空间信息网络中任务图的合并过程会产生多个循环。因此，本节C提出了一种消散多层网络图聚合过程中的环路形成的方法，并设计了打破四种环路的算法，以解决多层网络图聚合过程中的环路形成问题。</p><p>由待聚合边的源节点的入度边引起的环路解析过程描述如示意图10所示。</p><p><img src="http://cdn.leafii.top/img/image-20230507135753688.png" alt="image-20230507135753688" loading="lazy"></p><p>子图(a)为循环生成前的状态。边 (a, b) 是目标任务，边 (53, 54) 是要聚合的任务。事件50为已经合并的事件，边(51, 53)为节点53的入度边。子图(b)描述了任务(a, b)和(53, 54)完成合并后的状态已被合并。由于边 (53, 54) 被 (a, b) 替换，因此边 (51, 53) 被移除并添加了新边 (51, a)。同时，图中存在环路。事件50、51、a形成子图(c)所示的循环。如子图（d）所示，为了打破循环，我们添加了一个新的虚拟事件 0 和一条权重为 -w 的边 (0, 51)，从而在不丢失原始边上的权重 w 的情况下打破了原始循环（ 51，a）。此外，我们需要将图的起始节点’start’连接到新的虚拟事件0。类似地，图11描述了由边的源节点的入度边引起的环路解析过程是聚合。子图(a)和(b)描述了边(53, 54)聚合的过程，任务(53, 51)是源53的出度边。子图(c)是之后形成的循环聚合，子图（d）添加虚拟时间0，添加边0,51以打破循环，最后将网络源节点start连接到虚拟节点0。</p><p><img src="http://cdn.leafii.top/img/image-20230507140348700.png" alt="image-20230507140348700" loading="lazy"></p><p>如示意图12所示，描述了由待聚合边的汇聚节点的入度边引起的环路解析过程。子图(a)为环路生成前的状态，其中边(a, b)为目标任务，边(49, 50)为待聚合任务。子图(b)描述了任务(a, b)和(49, 50)合并后的状态，由于(49, 50)被(a, b)替换，该图形成了一个循环。事件b、52、51形成一个循环，如图(c)所示。如子图 (d) 所示，我们添加了一个新的虚拟事件 0 和一条权重为 -w 的边 (0, 51) 来打破循环，从而在不丢失边 (51, b) 上的权重 w 的情况下打破了原始循环。此外，我们需要将网络源节点“start”连接到添加的虚拟事件0。类似地，图13描绘了由要聚合的边缘的汇节点的出度边缘引起的环路解决过程。子图 (a) 和子图 (b) 描述了边 (49, 50) 聚合的过程。子图(c)表示聚合后形成的环路，子图(d)加入虚拟时间0，加入新的边(0, 51)打破环路，最后将网络源节点start连接到虚拟节点0。</p><p><img src="http://cdn.leafii.top/img/image-20230507140413748.png" alt="image-20230507140413748" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230507140618038.png" alt="image-20230507140618038" loading="lazy"></p><p>定理 4. 给定一个没有循环的网络图 G 和 G’，要合并的边 e(a, b) ∈ G 和合并后的边 e(c, d) ∈ G’，其中 e( c, d) 是 I(c)，输出边的集合是 O(d)。加入一条新的边e(m, n)连接边e(a, b)和边e(c, d)，合并后的新边为e(a’, b’)。如果合并边e(a, b)和e(c, d)，则得到一个新的网络图G’’，其中生成了环路P。添加事件 v 最早发生时间 ve(v) &#x3D; ve(m) 和最晚发生时间 vl(v) &#x3D; vl(m) 的新虚拟节点 v。权重为 w 的虚拟边 ev 和反向虚拟边创建具有权重 −w 的边 e′ v 并用于打破循环。同时，得到无环合并网络图G*。如果在不考虑虚拟边权重的情况下计算网络图的总时间成本，则 min(C(G∗)) &#x3D; min(C(G) + C(G′))。</p><p>证明略。</p><p>由定理4可知，聚合后多网络图的时间成本消耗小于聚合前原始网络图的时间消耗。然而，聚合网络图不允许环路的存在。为了解决这个问题，我们设计了算法 5 来打破聚合网络图中的循环。该算法描述了消除网络图中循环歧义的过程。首先，我们获得所有聚合边的入度和出度边（第 2-3 行）。如果网络图中存在环路，则判断合并边(source, sink)的源节点source的入边suInEg或出边suOutEg是否在环路路径中。如果它在循环中，它会删除任一条边，中断循环，并添加具有权重的新边，从而保持网络权重不变（第 714 行）。类似地，伪代码（第 16-22 行）中显示了合并边的源节点源（源、汇）的循环中断。</p><p><img src="http://cdn.leafii.top/img/image-20230507140951660.png" alt="image-20230507140951660" loading="lazy"></p><h4 id="4-3-基于聚合网络图的多星资源分配方法"><a href="#4-3-基于聚合网络图的多星资源分配方法" class="headerlink" title="4.3 基于聚合网络图的多星资源分配方法"></a>4.3 基于聚合网络图的多星资源分配方法</h4><p>基于聚合后的网络图，我们需要将网络图上的任务分配给场景中的所有有效卫星。我们将任务调度问题转化为 0-1 规划问题。然后开发了基于聚合网络图的任务调度模型，并设计了求解算法以实现高时间效率的任务调度。</p><p>本节基于聚合网络图解决多星资源分配问题，实现多星多任务的高时效调度。为了更方便地描述我们的多卫星和多任务调度模型，我们根据 3.1 节中描述的原子任务和卫星元组表示简化任务集为 σ &#x3D; σ1, σ2, … , σm，其中 m 是任务。任务的属性集表示为 σi &#x3D; ai, bi, ci, di, 0 ⩽ i &lt; m，其中 A 表示卫星接触窗口的开始时间，B 表示任务资源需求数，C表示卫星接触窗口的结束时间，D表示卫星资源类型。卫星集合简化为 S &#x3D; s1, s2, … , sn，其中 n 是卫星的数量。每个卫星属性表示为 sj &#x3D; ej , fj , gj , hj , 0 ⩽ j &lt; n，其中 E 表示任务开始执行的时间，F 表示任务需要的资源数量，G 表示时间任务完成的时间点，H 表示任务要求的资源类型。</p><p>根据上述定义，我们将多星-原子任务的任务执行最小时间记为T&#x3D;min f(X)，T为任务等待执行时间与任务执行时间之和。我们可以转化多卫星多任务调度问题为 0–1 规划问题。该模型的构造如下：</p><p><img src="http://cdn.leafii.top/img/image-20230507141611179.png" alt="image-20230507141611179" loading="lazy"></p><p>如方程式 (18)所示。C1为待解矩阵X的描述。 X 是由要求解的值形成的矩阵。矩阵中的元素标识卫星是否被允许参与执行某项任务。 xi,j在矩阵X中的第j列表示任务σj在卫星si上的执行状态。如果 xi,j &#x3D; 0，则意味着卫星 si 没有资源分配给任务 σj 。</p><p>反之，则意味着卫星需要为指定的任务分配资源。 C2是根据任务数量和卫星数量生成的所有已知元素为1的矩阵。 C3表示f(X)的解需要满足任务开始执行时间大于卫星可见时间窗开始时间。 C4表示卫星可见时间窗的结束时间需要大于任务执行的结束时间。 C5是指卫星拥有的资源类型应与任务所需的资源类型相同。 C6表示卫星拥有的资源数量需要大于任务所需的资源数量。</p><p>算法6描述了多星多任务的调度过程，我们重点计算任务本身的执行顺序和执行时间的优化。首先，我们根据任务网络图表示算法 1（第 3 行）构建具有多个任务的多个网络图。然后使用算法 3 聚合多图中具有相似特征的原子任务。通过使用算法 4 聚合多图中具有数据依赖性的原子任务，获得由多个任务组成的单源单汇网络图（第 5-6 行） .根据算法 5 消除网络图中的循环。根据算法 2（第 7-8 行）计算无循环网络图中的关键原子任务和整个图要消耗的最短时间。我们使用第三方计算库P uLP 2 根据每个原子任务的最早和最晚执行时间、关键原子任务、聚合的原子任务来计算原子任务。根据每个原子任务的最早和最晚执行时间、关键原子任务、被聚合的原子任务等，为原子任务分配卫星资源。分配卫星资源，使其不超过原子任务的最早或最晚执行时间，并且通常执行关键原子任务（第 9-15 行）。 至此，多任务将在最短时间内完成，无需考虑复杂的资源约束和优化策略，即可计算出多星多任务耗时最短的调度方案。</p><p><img src="http://cdn.leafii.top/img/image-20230507142136552.png" alt="image-20230507142136552" loading="lazy"></p><h2 id="5-实验"><a href="#5-实验" class="headerlink" title="5. 实验"></a>5. 实验</h2><h3 id="5-1-算法复杂度分析"><a href="#5-1-算法复杂度分析" class="headerlink" title="5.1 算法复杂度分析"></a>5.1 算法复杂度分析</h3><p>我们着重研究了任务执行顺序和执行时间的计算，以克服多个任务混合执行耗时控制的困难，保证任务执行耗时最少。我们研究了原子任务聚合算法，可以节省不必要的原子任务执行时间消耗，进一步提高多任务执行效率。基于多任务网络图聚合的调度方法主要包括五种算法：网络图构造算法、相似原子任务聚合算法、相关关系原子任务聚合算法、网络图关键路径和最小耗时计算算法、多星多-任务调度算法。</p><p>算法1将所有原子任务视为网络图的边，将原子任务的开始执行事件和结束执行事件分别视为边的节点。算法输入是一个任务，所以算法的时间复杂度主要体现在该任务的所有原子任务的遍历过程中。如果原子任务的个数是E，那么它的时间复杂度就是O(E)。算法2主要计算特定网络图上的关键任务路径和整个网络图完成执行所需的最短时间。其计算时间消耗主要体现在网络图节点和边的遍历上，时间复杂度为O(E+V)。算法3主要计算多个网络图之间具有相似关系的原子任务的聚合。计算中使用经典的k-均值算法。</p><p>对于简单情况，𝑘 − 𝑚𝑒𝑎𝑛𝑠 算法的运行时间界限是 𝑂(𝑑𝐸4𝑀2)。 算法3的时间复杂度主要体现在多个网络图和网络图上边的遍历操作上。 若两个事件的冗余边数为𝑟，网络图数记为𝐺，则算法3的时间复杂度可表示为𝑂(𝐺𝑑𝐸4𝑀2𝑟)。 算法4主要计算多个网络图上具有相关关系的原子任务之间的聚合操作，其时间复杂度主要体现在网络图和边的遍历上。 因此，它的时间复杂度是𝑂(𝐺𝐸)。 算法6主要是在上述算法的基础上完成多图的最小时间和卫星资源分配计算，其时间复杂度为𝑂(𝐺𝐸+𝐸+𝑉+𝐺𝑑𝐸4𝑀2𝑟+𝐺𝐸)。 我们将本文提出的基于网络图聚合的多卫星多任务调度算法的时间复杂度简化为𝑂(𝐺(𝑑𝐸{4}𝑀{2}𝑟 + 𝑉 + 𝐸))。</p><h3 id="5-2-实验数据"><a href="#5-2-实验数据" class="headerlink" title="5.2 实验数据"></a>5.2 实验数据</h3><p>为研究天基信息网络的任务调度、链路优化、协同计算、网络拓扑发现等关键问题，自主研发了基于天然卫星的空间信息网络通用计算环境仿真工具包（CSTK）3和天基信息网络的共同任务数据。在本系统中，我们模拟了大量的卫星数据，包括卫星载荷数据、卫星轨道数据、星间可见时间窗、星间可见时间窗数据、卫星资源容量、卫星资源数量等。我们模拟了对地观测常见应用场景数据，包括对地观测区域数据、任务执行时间需求、任务资源类型、任务资源需求等。此外，我们开发了CSTK系统所需的多种计算库。在本文中，我们获得了基于CSTK系统的实验数据，并在该系统上实现了本文提出的模型和算法进行计算。本文提出的算法MSRA-TAG的实验数据描述如下，</p><p>如表1所示，本文共有六组实验数据。标题“Datasets”表示数据集的名称，标题“Atomic tasks”表示数据集中原子任务的数量，标题“Satellites”表示数据集中卫星的数量。</p><p><img src="http://cdn.leafii.top/img/image-20230507144250302.png" alt="image-20230507144250302" loading="lazy"></p><p>如表 2 所示，我们总共使用了四个数据集。每个数据集中包含的卫星和任务数量呈梯度增长，其中Scale表示每个数据集中的任务和卫星数量，’Minimum Strat Time’是所有任务的最短开始时间和所有卫星的最短开始时间在可见时间窗内。同样，“最大战略时间”表示所有任务或卫星的可见时间窗口的最大开始时间。 “最短结束时间”表示所有任务和卫星可见时间窗口的最短结束时间。 “最大结束时间”表示所有任务和卫星的可见时间窗口的最大结束时间。 ‘Minimum Resources Num’表示所有任务所需的最少资源数和所有卫星可用的最少资源数。‘Maximum Resources Num’表示所有任务中需要最多资源的任务和所有卫星中能提供最多资源的卫星请求的资源数量。 “资源类型”表示任务所需资源类型和卫星有效载荷的资源类型。 1表示观测资源，2表示存储资源，3表示传输资源。</p><p><img src="http://cdn.leafii.top/img/image-20230507144239318.png" alt="image-20230507144239318" loading="lazy"></p><p>为了验证 MSRA-TAG 在真实卫星观测场景中的有效性，我们添加了对真实世界数据的模拟，其中包含较少的合成数据。在真实的地球观测场景中，我们研究了两个用于观测地球区域目标的用户任务。用户任务是对用户需求的描述，是粗粒度的任务。观测场景包含两个观测需求，八颗观测卫星和两个用于发送任务指令的地面站。场景时间范围从“2022 年 3 月 5 日 04:00:00.000 UTCG”到“2022 年 3 月 6 日 04:00:00.000 UTCG”，步长为 10 秒。模拟场景如图 14 所示，子图 (a) 和 (b) 显示了两个观测任务的地球观测区域的 3D 和 2D 视图。我们可以观察到两个观测任务的目标观测区域重叠。这意味着两个用户任务被分解为原子任务后，还存在一部分相似或相关的原子任务。子图(c)和(d)显示了卫星轨道、地面站和观测区域的完整场景视图。我们可以从 3D 或 2D 场景观察卫星凌日的时间。</p><p><img src="http://cdn.leafii.top/img/image-20230507143958198.png" alt="image-20230507143958198" loading="lazy"></p><p>真实观测场景的任务数据详情如表3所示。我们可以观察到’’Real World Dataset’’表示真实世界数据集名称，’’TaskID’’指定用户任务ID，’’Areas’’表示观察区域的经纬度坐标和“离散时间范围”表示观察场景周期离散化的持续时间，以秒为单位。 “Resources Type”字段表示用户任务所需的卫星资源类型，与表1中的类型相同。</p><p>观测场景中的卫星详情如表4所示，表中卫星涉及整个观测任务，’’Common Name’’表示卫星名称，’’Launch Date’’表示发射日期卫星的“周期”表示卫星的运行周期（以分钟为单位）。 “倾角”表示卫星相对于地球的倾角，“原子序数”表示卫星上安装的天线数，双线元全称“TLE”表示卫星轨道范围。</p><h3 id="5-3-Experimental-parameter"><a href="#5-3-Experimental-parameter" class="headerlink" title="5.3 Experimental parameter"></a>5.3 Experimental parameter</h3><p>本文使用python第三方库sklearn中的Spectral Clustering(Huang et al., 2020)方法完成相似边的查找。在完成多任务聚类后，我们使用线性求解器 P uLP 4 来实现多任务资源分配的解决方案。我们在 P uLP 求解器中使用默认参数设置。 Spectral Clustering方法中的参数设置如下表5所示。</p><p>如表5所示，其中参数gamma值在0.01、0.1、1、10范围内选取，参数n_clusters在2、3、4、5、6范围内选取。我们选取最优的聚合结果从上面训练出来的集合，以及聚类完成后默认选择的三个类别的集合。所有任务的默认最短开始时间应大于 0。</p><p>我们将本文方法与用于天基信息网络电路任务调度的基线算法进行比较，5 这些算法包括粒子群优化 (PSO)（Chen 等人，2012 年；Kennedy 和 Eberhart，1995 年；Luo 等人，2020 年） ; Xia et al., 2009), Genetic Algorithm (GA) (Gerges et al., 2018; Sun et al., 2010; Xhafa et al., 2012), and Differential Evolution (DE) (Li &amp; Li, 2019; Storn &amp; Price，1997 年；Wu、Wang 等人，2015 年）算法。 在空间信息网络任务调度场景下，这些算法的参数设置如表6所示，其中参数𝑙𝑏表示各自变量的最小值，𝑢𝑏表示各自变量的最大值，参数𝑙𝑏表示各自变量的最大值， 每个变量作为卫星当前拥有的资源数量上线。 𝑝𝑟𝑜𝑏_𝑚𝑢𝑡表示方差概率，𝑝𝑟𝑒𝑐𝑖𝑠𝑖𝑜𝑛表示算法𝐺𝐴的精度，𝑤表示算法𝑃的惯性权重𝑆𝑂， 𝑐1表示算法𝑃𝑆𝑂的个体记忆，𝑐2表示算法𝑃𝑆𝑂的集体记忆，𝐹表示方差系数 算法𝐷𝐸。</p><h3 id="5-4-Experimental-results"><a href="#5-4-Experimental-results" class="headerlink" title="5.4 Experimental results"></a>5.4 Experimental results</h3><p>本节分为三个主要部分来分析和验证我们提出的方法的性能。首先，我们比较和分析了我们的聚合方法的性能。然后对多卫星多任务资源分配性能进行了精确分析。最后，将本文提出的方法 MSRA-TAG 与三个基线模型进行比较，以彻底验证方法 MSRA-TAG 的有效性和优越性。</p><h5 id="A-多任务聚合前后任务执行时间对比"><a href="#A-多任务聚合前后任务执行时间对比" class="headerlink" title="A. 多任务聚合前后任务执行时间对比"></a>A. 多任务聚合前后任务执行时间对比</h5><p>一个任务在整个调度过程中的时间成本消耗包括两个主要部分：任务执行消耗的时间和分配卫星资源时等待执行的时间。在本文中，我们提出的聚合过程发生在卫星资源分配过程之前。因此，我们比较了聚合前后计划执行任务所需的时间，以验证我们提出的相似性聚合和相关性聚合方法的有效性。</p><p>如表7所示，我们分别计算了聚合前原始任务和聚合后任务在六个数据集上的计划执行消耗时间。 我们可以观察到原始任务和聚合任务的计划耗时在数据集𝐷1 上是相同的，这表明没有执行聚合过程。 造成这种情况的原因是数据集中的任务数量太少，导致不存在相似的任务或有相关关系的任务。 因此任务无法聚合，导致聚合前后任务计划执行的成本消耗相同。 在数据集𝐷2、𝐷3、𝐷4、𝐷5、𝐷6和𝐷𝑟𝑒𝑎𝑙上，我们可以观察到聚合后任务的耗时小于原始任务的耗时，说明任务集中的某些任务具有相似或相关关系 ，它们聚合在一起并减少了任务大小。</p><p>经过上面的分析，我们可以注意到，任务的聚合操作可以减少任务执行时间的消耗，减少任务的数量。此外，如图15所示，聚合后任务总成本的降低率随着数据量的增长而增长。此外，我们可以意识到，当任务数量增加时，具有相似性和相关性的任务数量也会增加，聚合后任务执行时间消耗也会减少。因此，当空间信息网络满足许多任务请求时，我们提出的聚合方法降低的任务执行消耗成本随着任务数量的增加而增加。在真实世界数据的模拟结果中，我们可以观察到任务聚合后任务消耗的估计时间成本减少了 861。聚合后减少的时间消耗比大批量任务场景要小，因为真实数据集中只有两个用户观察任务。因此，更少的任务满足聚合条件。本文提出的任务聚合方法对真实世界数据有效。总之，我们提出的聚合方法可以适应大容量任务请求场景。</p><h5 id="B-关键路径任务优先资源分配与全图分配结果对比"><a href="#B-关键路径任务优先资源分配与全图分配结果对比" class="headerlink" title="B. 关键路径任务优先资源分配与全图分配结果对比"></a>B. 关键路径任务优先资源分配与全图分配结果对比</h5><p>任务聚合后，需要将当前时刻活跃卫星拥有的空闲资源分配给任务。本节给出了本文提出的关键路径任务优先级分配资源方法与全图分配资源结果的对比分析。如4.3节所述，关键路径任务优先分配资源法是指先将资源分配给网络图中关键路径上的原子任务，再分配给关键路径以外的剩余任务，即保证整个网络图可以在理想的时间内执行和完成。全图资源分配是指根据实际卫星资源的数量一次性为网络图中的所有任务分配资源。之后，我们分析了这两种方法的实验结果数据。</p><p>如表8所示，关键路径优先分配和整个网络图的一次性分配的成本消耗在D1数据集上是一致的。这表明卫星资源的数量足以执行网络上的所有任务，不存在资源竞争。因此，这两种方法都不会延长关键路径上任务的执行时间。然而，随着D2-Dreal数据集上的任务数量逐渐增加，卫星资源不足导致资源争用。它导致网络地图上关键原子任务的执行按时完成。结果，“一次性分配”方法导致整个网络的时间成本消耗增加。</p><p><img src="http://cdn.leafii.top/img/image-20230507145258428.png" alt="image-20230507145258428" loading="lazy"></p><p>如图16所示，随着任务的增加，对资源的竞争也越来越激烈。子图描述了与一次性分配方法一致的优先关键路径方法对数据集 D1 的成本消耗。这是因为任务数量少，不会造成资源争用。此外，网络图中关键任务的执行越来越延迟，导致整个网络图中的任务执行成本增加。在真实数据集 Dreal 上，我们可以观察到整图一次性分配方法的成本消耗大于关键路径优先方法的成本消耗。因此，关键路径任务优先执行法实现了显着的成本节约和更理想的结果。随着任务数量的增加，成本节约消耗更加出色。</p><p><img src="http://cdn.leafii.top/img/image-20230507145509413.png" alt="image-20230507145509413" loading="lazy"></p><h5 id="C-MSRA-TAG-与基线方法的调度结果对比"><a href="#C-MSRA-TAG-与基线方法的调度结果对比" class="headerlink" title="C. MSRA-TAG 与基线方法的调度结果对比"></a>C. MSRA-TAG 与基线方法的调度结果对比</h5><p>本节将本文的方法 MSRA-TAG 与基线算法 PSO、GA 和 DE 进行比较。 算法计算成本消耗越小，意味着算法对动态变化的空间信息网络的适应性越强，算法的性能就会提高。如表9所示，PSO、GA、DE算法的成本消耗在数据集D1上是一样的，都是7797。MSRA-TAG相比baseline方法是3657，消耗的时间不到所消耗时间的一半通过基线模型，显着降低了任务执行的成本消耗。但是，我们发现MSRA-TAG大于原任务的计划成本消耗时间2761，这是由于卫星可见窗口、资源数量或分配时卫星功率等任务约束的等待时间造成的任务的卫星资源。此外，我们提出的方法 MSRA-TAG 在数据集 D1 上产生的任务等待时间延迟仅为 896。基线方法GA和DE在数据集D2上的结果相同，PSO算法的结果略高于GA和DE。我们提出的方法 MSRA-TAG 计算所有方法中的次要成本消耗。</p><p><img src="http://cdn.leafii.top/img/image-20230507145904784.png" alt="image-20230507145904784" loading="lazy"></p><p>在数据集 D3 上，我们提出的方法 MSRA-TAG 计算结果为 51 604.99，远小于原始任务的计划成本消耗 62,665.09，这是由任务集中许多相似任务和具有相关性的任务引起的数据集的数量增加。因此，众多任务的聚合极大地减少了时间成本消耗。在数据集 D3 上，随着数据集数量的增加，任务集中存在许多相似的任务和具有相关性的任务。然而，尽管如此，任务的等待时间仍然存在。在数据集 D5 上，MSRA-TAG 的时间成本为 179,240.64，原始任务的时间成本为 251,749.25，其他基线方法的时间成本分别为 623,999、623 760 和 623 760。原始任务的时间成本为 72,508.61，MSRATAG 节省的其他算法的时间成本为 444,548.61。 MSRA-TAG 相对于其他算法节省了 444,758.36、444,519.36 和 444,519.36。所有数据集上的卫星资源分配过程都存在任务等待时间消耗。 baseline算法的结果大致相同，但都远大于MSRA-TAG方案消耗的时间成本。类似地，数据集 D4、D5 和 D6 上的 MSRA-TAG 显示出随着任务数量的增加任务执行时间消耗减少的增加趋势。总之，我们的方法比基线方法具有绝对优势。</p><p>在真实数据集 Dreal 上，我们可以观察到 MSRA-TAG 的成本为 370 064，大约是源任务耗时的 23 倍。种群智能算法 PSO、GA 和 DE 消耗相同的成本 518 400，大约是源任务消耗时间的 33 倍。因此，与所有基线方法相比，MSRA-TAG 的成本消耗较小，可以提高任务调度的时效性。总之，我们的方法 MSRA-TAG 与基线方法相比具有绝对优势。</p><p>如图 17 所示，“原始任务成本”表示原始任务的时间消耗。随着任务数量的增加，所提出的方法 MSRA-TAG 的上升幅度远小于基线方法，并且其时间成本在数据集 D3、D4、D5、D6 和 Dreal 上低于原始任务。</p><p><img src="http://cdn.leafii.top/img/image-20230507150103220.png" alt="image-20230507150103220" loading="lazy"></p><p>为了更清楚地比较多种方法的时间消耗趋势，我们计算了每个算法在不同数据集上固定基数的增长率，计算如下，</p><p><img src="http://cdn.leafii.top/img/image-20230507150146637.png" alt="image-20230507150146637" loading="lazy"></p><p>如方程式所示。 (19)，我们将算法集 A &#x3D; {Original Tasks Cost, MSRA-TAG, PSO, GA, DE} 定义为 y &#x3D; {a1, a2, a3, a4, a5}。定义数据集 D &#x3D; {D1, D2, D3, D4, D5, D6, Dreal} 为 x &#x3D; {d1, d2, d3, d4, d5, d6, d7}。 φx(y)表示方法ai计算的任务执行耗时，1≤i≤5在数据集dj上，1≤j≤5。γ(x)表示原始任务在数据集x中的耗时。 f (x, y) 表示算法 x 在数据集 y 上的固定基数的增长率。</p><p>如表 10 所示，我们分别使用表 9 中“原始任务成本”列的值作为数据集 D1 −Dreal 的基线。其中，MSRA-TAG方法在数据集D1和D2上的增长率为正，小于baseline方法。这意味着 MSRA-TAG 方法的计算结果对于原始任务的成本消耗具有最低的增长率，即我们提出的任务调度方法需要最少的时间成本消耗。 MSRA-TAG 在数据集 D3、D4、D5 和 D6 上的增长率均为负值，其绝对值小于其他基线算法。这意味着该方法消耗的时间成本低于原任务的计划成本，增长率均低于其他算法。在真实数据集Dreal上，随着任务和卫星数量的增加，MSRATAG成本消耗以2298.65%的速度增长，而基线模型PSO、GA和DE的成本消耗增长率为3260.12%。</p><p><img src="http://cdn.leafii.top/img/image-20230507150218903.png" alt="image-20230507150218903" loading="lazy"></p><p>通过比较，我们可以观察到 MSRA-TAG 方法具有最慢的成本增长率和较高的任务执行时间。 虽然在真实数据集中只考虑了八颗卫星，但两个用户任务分解后产生的原子任务比数据集𝐷1中包含的原子任务数量要多。 原子任务的数量越多，可聚合的任务就越多，耗时也就越少。 因此，方法 MSRA-TAG 在𝐷𝑟𝑒𝑎𝑙 上的成本增长率小于 D1。</p><p>我们提出的方法 MSRA-TAG 随着任务数量的增加使更多的任务聚合在一起执行，从而减少重复执行的大量时间成本。如图 18 所示，算法 PSO、GA 和 DE 的增长率具有相同的值，导致三种算法的增长率倍数重叠。 MSRA-TAG、PSO、GA 和 DE 的增长率在数据集 D1 和 D2 上是有利的。然而，随着任务数量的增加，MSRA-TAG 在数据集 D3、D4、D5 和 D6 上出现了负增长，增长率曲线停滞在-30.37%。 PSO、GA 和 DE 的增长率仍然为正，增长率稳定在 147.87%。 PSO、GA 和 DE 的增长率保持正增长并稳定在 147.87%。我们的方法 MSRA-TAG 显示出正增长率，低于数据集 Dreal 上 PSO、GA 和 DE 的增长率。我们可以观察到MSRA-TAG在所有数据集上相比基线算法的时间成本消耗最少，并且随着数据量的增长增长率逐渐降低，具有优异的性能。</p><p><img src="http://cdn.leafii.top/img/image-20230507150344294.png" alt="image-20230507150344294" loading="lazy"></p><p>为了验证所有算法在任务数量变化时的性能，我们根据所有算法在数据集 D1 上的基准测试结果，计算了每个算法在数据集 D2、D3、D4、D5、D6 和 Dreal 上的增长率。随着任务和卫星数量的增加，时间成本的增加是不可避免的。因此，我们提出的方法 MSRA-TAG 旨在尽我们所能减少任务的时间成本消耗。如表11所示，原任务的时间成本增长率为1102%。本文提出的算法MSRA-TAG虽然在数据集𝐷2上997%的增长率比基准算法高出900%，但并没有显着差异。 这种情况是因为数据集𝐷2中的任务和卫星数虽然相对于数据集𝐷1增长了1102%，但具有相似关系或相关关系的任务并不多，聚合效果不明显。 但随着数据量的增长，MSRA-TAG的增长率明显低于其他基准算法，这是由于任务和卫星数量的增长，出现了更多具有相似和相关关系的任务，使得MSRA- TAG充分发挥其性能。 如图19所示，随着数据量的增长，MSRA-TAG的增长率明显低于其他基线方法，其增长率曲线的斜率也远小于 其他基线算法。 然而，与其他方法相比，MSRA-TAG 在真实数据集 Dreal 上相对于 𝐷1 的增长率最高。 这是因为𝐷1数据集中的卫星比数据𝐷𝑟𝑒𝑎𝑙中的卫星多。 然而，𝐷1 中的原子任务数量少于𝐷𝑟𝑒𝑎𝑙。 因此，与 𝐷𝑟𝑒𝑎𝑙 相比，它导致 𝐷1 的成本最低，后者更广泛并导致更显着的增长率。</p><p><img src="http://cdn.leafii.top/img/image-20230507150417069.png" alt="image-20230507150417069" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230507150524224.png" alt="image-20230507150524224" loading="lazy"></p><p>综上所述，我们的方法在处理大批量任务请求时具有出色的性能，并且与其他方法相比，任务越多，我们的时间消耗就会少得多。然而，对于任务数量较少的场景，我们的方法的优异性能并不能得到充分体现。</p><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6. Conclusion"></a>6. Conclusion</h2><p>针对空间信息网络中多卫星多任务场景下任务关系复杂、任务调度时效性差的问题，研究多任务聚合方法和多卫星资源分配方法，提出了一种独创的复杂多任务聚合方法，基于合成数据集和真实世界数据，仿真验证了该方法在多卫星、多任务调度场景下的有效性和优越性。我们提出了多任务的网络图表示，建立了相似性和相关关系任务聚合模型，设计了解决多层任务网络图聚合的算法，解决了重复执行多个任务需要大量时间的问题.为了解决多卫星资源分配问题，我们提出了一种基于聚合任务网络图来优先分配关键任务资源请求的方法。我们还建立了多卫星多任务资源分配模型，并设计了算法对关键任务进行优先分配，解决了空间信息网络资源大量被占用和资源利用率低的问题。资源配置不合理。该论文突破了多任务聚合的关键技术难题，实现了空间信息网络中多卫星、多任务的高时效调度。本文通过从多个角度验证本文提出的MSRA-TAG方法的有效性，并将实验的性能与各种基线算法进行比较，验证了我们的想法的有效性和效率。 MSRA-TAG 在最大数据集 D6 上将 95 745.82 个亲属保存到原始任务中。此外，MSRA-TAG相对于其他算法分别节省了560 436.08、560 137.08和560 137.08。 MSRA-TAG方法在所有数据集上其任务和卫星数量较多的时间成本消耗负增长率最高为-30.37%，其他基线算法时间成本消耗数量增长率最高为147.38% . MSRA-TAG 对数据集 D1 的最高增长率为 10 019%，其他基线模型对 D1 的最高增长率为 9904%。因此，本文提出的方法MSRA-TAG具有更强的适应性，在空间信息网络中的多星、多任务场景下具有优异的性能。</p><p>未来，卫星信息网络必然向天地一体化网络发展。脱离地基基站的卫星自主任务规划或聚类方法研究必将成为普遍的研究趋势。纵观相关文献，目前的任务规划或聚类方法大多基于图论、强化学习或种群智能方法。然而，在未来几十年，任务规划方法将倾向于基于卫星之间自主协商的星上自主在线规划。因此，下一步将研究卫星间自主协作机制和星上任务在线规划策略，以实现卫星信息网络的智能化和自主化。同时，我们将更倾向于根据卫星网络的时变特性，研究具有高时间效率的多任务在线聚类方法。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-Abstract&quot;&gt;&lt;a href=&quot;#0-Abstract&quot; class=&quot;headerlink&quot; title=&quot;0. Abstract&quot;&gt;&lt;/a&gt;0. Abstract&lt;/h2&gt;&lt;p&gt;卫星网络任务调度时效性问题是实现空地一体化网络（STIN）的关键。传统方法将卫星任务调度问题解释为线性或非线性规划问题，忽略了任务之间的复杂关系。为了提高多卫星和多任务场景中任务调度的及时性，我们研究了解释任务相关性的网络图结构。然后，我们针对具有相似性和相关性特征的任务提出了多层网络图聚合模型。进一步，我们将任务调度问题转化为零-一规划问题，设计任务调度算法来解决任务调度时效性问题。最后，我们模拟和模拟真实世界的数据作为实验数据集，用于与三种基线算法进行比较。实验结果表明本文方法具有明显的优势和进步。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
    <category term="任务网络图" scheme="tags/任务网络图/"/>
    
  </entry>
  
  <entry>
    <title>leetcode123.买卖股票的最佳时机III</title>
    <link href="2023/04/27/leetcode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/"/>
    <id>2023/04/27/leetcode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/</id>
    <published>2023-04-27T06:13:04.000Z</published>
    <updated>2023-04-27T06:16:29.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>这道题是需要我们计算在最多进行两次买卖的情况下，所能获得的最大利润。我们可以定义四个状态分别为：</p><ul><li><code>buy1</code>表示第一次买入时的最大收益；</li></ul><ul><li><code>sell1</code>表示第一次卖出时的最大收益；</li><li><code>buy2</code>表示第二次买入时的最大收益；</li><li><code>sell2</code>表示第二次卖出时的最大收益。</li></ul><p>对于这四个状态，我们可以使用动态规划算法进行求解。具体地，对于第i天的情况，我们有以下状态转移方程：</p><pre class="language-C++" data-language="C++"><code class="language-C++">buy1 &#x3D; max(buy1, -prices[i]);    &#x2F;&#x2F;第一次买入的最大收益，可以选择不进行或进行sell1 &#x3D; max(sell1, buy1 + prices[i]);  &#x2F;&#x2F;第一次卖出的最大收益，可以选择不进行或进行buy2 &#x3D; max(buy2, sell1 - prices[i]);  &#x2F;&#x2F;第二次买入的最大收益，可以选择不进行或进行sell2 &#x3D; max(sell2, buy2 + prices[i]); &#x2F;&#x2F;第二次卖出的最大收益，可以选择不进行或进行</code></pre><p>其中，<code>buy1</code>和<code>buy2</code>的更新都使用上一次买入的最大收益减去当前股票价格来更新，因为如果当前的股票价格越低，那么买入的收益也就越大。而对于<code>sell1</code>和<code>sell2</code>的更新则使用上一次的买入收益加上当前股票价格来更新，因为如果当前的股票价格越高，那么卖出的收益也就越大。</p><p>最后，我们的最大收益就是第二次卖出时的最大收益<code>sell2</code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int buy1 &#x3D; -prices[0], sell1 &#x3D; 0, buy2 &#x3D; -prices[0], sell2 &#x3D; 0;        for(int i &#x3D; 1; i &lt; prices.size(); i++)&#123;            &#x2F;&#x2F; 第一次买入的最大收益，可以选择不进行或进行            buy1 &#x3D; max(buy1, -prices[i]);            &#x2F;&#x2F; 第一次卖出的最大收益，可以选择不进行或进行            sell1 &#x3D; max(sell1, buy1 + prices[i]);            &#x2F;&#x2F; 第二次买入的最大收益，可以选择不进行或进行            buy2 &#x3D; max(buy2, sell1 - prices[i]);            &#x2F;&#x2F; 第二次卖出的最大收益，可以选择不进行或进行            sell2 &#x3D; max(sell2, buy2 + prices[i]);        &#125;        &#x2F;&#x2F; 返回第二次卖出时的最大收益        return sell2;    &#125;&#125;;</code></pre><p>时间复杂度：O(n)，其中n是股票的天数，只需要遍历一遍数组即可求解。</p><p>空间复杂度：O(1)，使用了常数个变量来存储状态。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个数组，它的第 &lt;code&gt;i&lt;/code&gt; 个元素是一支给定的股票在第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 &lt;strong&gt;两笔&lt;/strong&gt; 交易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1049.最后一块石头的重量II</title>
    <link href="2023/04/26/leetcode1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/"/>
    <id>2023/04/26/leetcode1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/</id>
    <published>2023-04-26T06:50:18.000Z</published>
    <updated>2023-04-26T06:53:13.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：stones &#x3D; [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：stones &#x3D; [31,26,33,21,40]输出：5</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道动态规划问题。我们可以定义一个 dp 数组，其中 dp[i] 表示背包容量为 i 时能够得到的最大价值。这里价值就是石头的重量。</p><p>具体来说，对于每一块石头，我们可以选择将其放入背包中，也可以不放入背包中。如果我们选择将其放入背包中，则可以得到的最大价值为 dp[j-stones[i]]+stones[i]，其中 j-stones[i] 表示剩余背包容量，dp[j-stones[i]] 表示剩余背包容量为 j-stones[i] 时能够得到的最大价值，stones[i] 表示当前石头的重量。</p><p>遍历完所有的石头后，dp[target] 就是能够得到的最大价值，其中 target 是所有石头重量之和的一半（因为我们要得到最终得到的石头的最小可能重量，因此需要将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值）。</p><p>最终得到的石头的重量就是 sum - 2*dp[target]，其中 sum 是所有石头的重量之和。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;        int sum &#x3D; accumulate(stones.begin(), stones.end(), 0); &#x2F;&#x2F; 计算所有石头重量之和        int target &#x3D; sum &#x2F; 2; &#x2F;&#x2F; 将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值        vector&lt;int&gt; dp(target+1, 0); &#x2F;&#x2F; 定义动态规划数组        for(int i&#x3D;0; i&lt;stones.size(); i++) &#123; &#x2F;&#x2F; 遍历每一块石头            for(int j&#x3D;target; j&gt;&#x3D;stones[i]; j--) &#123; &#x2F;&#x2F; 从后往前更新 dp 数组                dp[j] &#x3D; max(dp[j], dp[j-stones[i]]+stones[i]); &#x2F;&#x2F; 更新 dp 数组            &#125;        &#125;        return sum - 2*dp[target]; &#x2F;&#x2F; 返回最终得到的石头的重量    &#125;&#125;;</code></pre><p>在上面的代码中，我们首先使用<code>std::accumulate</code>库函数对石头的重量进行求和，得到所有石头的总重量<code>sum</code>。接着，我们将原问题转化为求解容量为<code>sum/2</code>的背包能够得到的最大价值，因此定义了一个<code>target</code>变量来保存这个值。</p><p>然后，我们定义了一个长度为<code>target+1</code>的<code>dp</code>数组，其中<code>dp[i]</code>表示背包容量为<code>i</code>时能够得到的最大价值。这个数组的初始化值都是0。</p><p>接下来，我们遍历每一块石头，并对每一块石头进行背包问题的动态规划更新。具体来说，对于第<code>i</code>块石头，我们从<code>target</code>向<code>stones[i]</code>遍历，更新所有<code>dp[j]</code>（<code>j&gt;=stones[i]</code>）。更新公式为<code>dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</code></p><p>这里<code>dp[j-stones[i]]</code>表示在放入第<code>i</code>块石头前剩余的背包容量，因此需要从<code>dp[j-stones[i]]</code>中加上当前石头的重量<code>stones[i]</code>才能得到在放入第<code>i</code>块石头后的最大价值。最后，我们返回最终得到的石头的重量，即<code>sum-2*dp[target]</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;有一堆石头，用整数数组 &lt;code&gt;stones&lt;/code&gt; 表示。其中 &lt;code&gt;stones[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 块石头的重量。&lt;/p&gt;
&lt;p&gt;每一回合，从中选出&lt;strong&gt;任意两块石头&lt;/strong&gt;，然后将它们一起粉碎。假设石头的重量分别为 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，且 &lt;code&gt;x &amp;lt;= y&lt;/code&gt;。那么粉碎的可能结果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;x == y&lt;/code&gt;，那么两块石头都会被完全粉碎；&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;x != y&lt;/code&gt;，那么重量为 &lt;code&gt;x&lt;/code&gt; 的石头将会完全粉碎，而重量为 &lt;code&gt;y&lt;/code&gt; 的石头新重量为 &lt;code&gt;y-x&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，&lt;strong&gt;最多只会剩下一块&lt;/strong&gt; 石头。返回此石头 &lt;strong&gt;最小的可能重量&lt;/strong&gt; 。如果没有石头剩下，就返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode416.分割等和子集</title>
    <link href="2023/04/25/leetcode416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <id>2023/04/25/leetcode416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</id>
    <published>2023-04-25T02:19:47.000Z</published>
    <updated>2023-04-25T02:27:22.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p> <span id="more"></span><p>示例 1：</p><p>输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这个解法使用了动态规划。具体来说，我们首先计算数组中所有数字的总和。如果总和是奇数，那么无法分成等和子集，直接返回 false。否则，我们就要找到一个子集，使得它的和等于总和的一半，也就是说，我们要在数组中选择一些数字，使得它们的和等于 target。</p><p>我们使用 dp 数组来记录 target 是否可以被分成等和子集。dp[i] 表示 target 为 i 时的情况，dp[i] &#x3D; true 表示 target 可以被分成等和子集，否则为 false。</p><p>对于每一个数字 num，我们遍历 dp 数组的范围是 [target, num]，并且更新状态。具体来说，如果 dp[i - num] 为 true，那么 dp[i] 也为 true，因为我们可以在 dp[i - num] 的基础上加上 num 得到 dp[i]。最后，我们返回 dp[target]，判断是否可以分成等和子集。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int sum &#x3D; 0;        for (int num : nums) &#123;            sum +&#x3D; num;        &#125;        if (sum % 2 !&#x3D; 0) &#123;  &#x2F;&#x2F; 如果总和是奇数，无法分成等和子集            return false;        &#125;        int target &#x3D; sum &#x2F; 2;        vector&lt;bool&gt; dp(target + 1, false);  &#x2F;&#x2F; 创建一个长度为target+1的vector        dp[0] &#x3D; true;  &#x2F;&#x2F; target为0的情况是可以满足的        for (int num : nums) &#123;            for (int i &#x3D; target; i &gt;&#x3D; num; i--) &#123;  &#x2F;&#x2F; 遍历可选数字的范围是[target, num]                dp[i] &#x3D; dp[i] || dp[i - num];  &#x2F;&#x2F; 状态转移方程            &#125;        &#125;        return dp[target];  &#x2F;&#x2F; 返回target是否可以被分成等和子集    &#125;&#125;;</code></pre><blockquote><p><code> dp[i] = dp[i] || dp[i - num];</code>是一个状态转移方程，表示当前状态 dp[i] 是否可以被满足。dp[i] 初始值为 false，如果 dp[i - num] 为 true，也就是说前面已经找到了一组数字使得它们的和等于 i - num，那么我们只需要在这个基础上再加上 num，就可以得到一组数字使得它们的和等于 i，于是我们可以将 dp[i] 设置为 true。</p><p>这里使用了逻辑或运算符（<code>||</code>），如果 dp[i] 本来就是 true，那么 dp[i] 的值不会改变，因为或运算符的两个操作数有一个为 true，结果就是 true。如果 dp[i - num] 为 false，那么 dp[i] 仍然是 false。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>WorkflowSim：用于在分布式环境中模拟科学工作流程的工具包</title>
    <link href="2023/04/24/WorkflowSim%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%A8%A1%E6%8B%9F%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    <id>2023/04/24/WorkflowSim%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%A8%A1%E6%8B%9F%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85/</id>
    <published>2023-04-24T10:33:26.000Z</published>
    <updated>2023-04-25T02:38:45.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments"><a href="#WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments" class="headerlink" title="WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments"></a>WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>现有的工作流模拟器无法提供一个考虑异构系统开销和失败的框架，也缺少对广泛使用的工作流优化技术（如任务聚合）的支持。因此我们引入了WorkflowSim。在扩展CloudSim的基础上提供了更高层的工作流管理。我们还通过实验证明了忽视系统开销和故障会导致预测工作流时间的极大不准确。在两个研究领域中我们进一步验证了WorkflowSim在促进科学研究方面的价值。</p><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>首先介绍了科学工作流，然后说对于科学工作流工作的验证如果放在真实环境中验证有很多缺点，而基于模拟的验证有很多好处，比如降低实验步骤的复杂度并且通过在可重复和受控的环境中测试他们的应用程序，在工作流执行中节省了大量精力。</p><p>因此一个能够准确模拟的工作流调度模拟框架是非常需要的。易购分布式系统使开销也五花八门，考虑到全面的系统开销在工作流的运行时间中起到的重要作用，需要对这些工作流开销进行分类，这有助于提高模拟器的精确度（相较于不考虑开小的模拟器）。</p><p>此外，很多研究者已经强调了容错设计的重要性并认为现代分布式系统中的错误率不应该被忽视，我们需要一个支持随机以及分层故障的模拟器来促进相关方面的研究。</p><p>最后，工作流研究的进展还需要一个能够支持广泛接受的工作流特征和优化技术的通用框架。现有的模拟器，如 CloudSim&#x2F;GridSim[12] 无法提供细粒度的工作流模拟。</p><p>据我们所知，当前的分布式系统模拟器都不支持这些丰富的特性和技术。在本文中，我们介绍了我们在模拟满足这些要求的科学工作流程方面的早期工作。我们以任务聚类为例评估 WorkflowSim 的性能。我们进一步表明，WorkflowSim 有望为容错集群和开销鲁棒性研究等研究领域提供评估平台。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>在我们的设计中，我们在 CloudSim 现有的工作流调度层之上添加了多个层，包括 Workflow Mapper、Workflow Engine、Clustering Engine、Failure Generator、Failure Monitor 等。我们将解释这些层的细节在第三节。</p><p>CloudSim只支持单工作流，并没有考虑工作流的任务依赖关系，也没有对故障和开销进行分析。WorkflowSim 扩展了 CloudSim 以满足这些新要求。</p><p>其他模拟器是专门为工作流管理的一些理想方面（例如工作流调度）而设计的，但这种简化与不断变化的分布式计算世界和新工作流管理技术的发展不匹配。</p><p>因此，与其针对特定领域的工作流进行模拟，WorkflowSim 试图提取各种工作流系统公开的共同特征，并支持广泛使用的工作流管理技术。WorkflowSim 不仅支持调度技术的评估，还考虑了各种任务调度&#x2F;执行开销和故障。</p><p>在任务聚合方面，论文的聚合策略是静态的并且没有考虑动态的资源特征，他也没考虑到一些开销，这些开销包含在我们的模型中，其值是根据实际执行轨迹估算的。</p><p>故障分析和建模呈现系统特征，例如错误和故障分布以及危险率。在所有故障中，我们重点关注暂时性故障，因为预计它们比永久性故障更普遍。基于这些工作，我们模拟了两层（任务&#x2F;工作）的故障，并为用户提供了一个接口开发容错算法</p><h3 id="Models-and-Features"><a href="#Models-and-Features" class="headerlink" title="Models and Features"></a>Models and Features</h3><p>如图 1 所示，准备和执行工作流涉及多个组件层。工作流管理系统 (WMS) 的模型类似于 Pegasus WMS [17]，它包含： 一个工作流映射器，用于将抽象工作流映射到依赖于执行站点的具体工作流；一个工作流引擎来处理数据依赖；和一个工作流调度程序，用于将作业与资源相匹配。其他组件包括将小任务合并到大作业中的集群引擎、跟踪任务&#x2F;作业执行历史的 Provenance 收集器以及将用户工作流划分为多个子工作流的工作流分区器。</p><p><img src="http://cdn.leafii.top/img/image-20230424175929354.png" alt="image-20230424175929354" loading="lazy"></p><h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><h5 id="Workflow-Mapper"><a href="#Workflow-Mapper" class="headerlink" title="Workflow Mapper"></a>Workflow Mapper</h5><p>我们将工作流建模为有向无环图 (DAG)，其中作业代表用户要执行的计算，有向边代表作业之间的数据或控制流依赖关系.Workflow Mapper 用于导入 XML 格式的 DAG 文件和文件大小等其他元数据信息。Workflow Mapper 创建任务列表并将这些任务分配给执行站点。任务是用户想要执行的程序&#x2F;活动。</p><h5 id="Clustering-Engine"><a href="#Clustering-Engine" class="headerlink" title="Clustering Engine"></a>Clustering Engine</h5><p>我们将任务定义为用户想要执行的程序。 作业是执行系统看到的一个原子单元，它包含多个顺序或并行执行的任务。Clustering Engine将任务合并到作业中，以减少调度开销。</p><p><img src="http://cdn.leafii.top/img/image-20230424180131785.png" alt="image-20230424180131785" loading="lazy"></p><h5 id="Workflow-Engine"><a href="#Workflow-Engine" class="headerlink" title="Workflow Engine"></a>Workflow Engine</h5><p>Workflow Engine根据作业的依赖关系管理作业，以确保只有在其所有父作业都成功完成后才能发布作业。Workflow Engine 只会向 Scheduler 释放空闲作业。我们使用 DAGMan作为工作流引擎。</p><h5 id="Workflow-Scheduler-and-Job-Execution"><a href="#Workflow-Scheduler-and-Job-Execution" class="headerlink" title="Workflow Scheduler and Job Execution"></a>Workflow Scheduler and Job Execution</h5><p>Workflow Scheduler 用于根据用户选择的标准（MaxMin [2]、MinMin [1] 和许多其他试探法）将作业与工作节点匹配。 CloudSim 已经支持静态调度算法，我们添加了对动态工作流算法的支持。WorkflowSim 依靠 CloudSim 提供准确可靠的作业级执行模型，例如分时模型和空间共享模型。但是WorkflowSim引入了不同层次的开销和故障，提高了仿真的准确性.</p><p>为了关联和协调这些层，我们采用了基于事件的方法，其中每个组件维护一个消息队列。图 3 显示了具有两个执行站点的简单配置，每个执行站点都有两个节点。</p><p><img src="http://cdn.leafii.top/img/image-20230424180421142.png" alt="image-20230424180421142" loading="lazy"></p><h4 id="Layered-Overhead"><a href="#Layered-Overhead" class="headerlink" title="Layered Overhead"></a>Layered Overhead</h4><p>基于我们之前对工作流开销的研究，我们将分层开销添加到工作流模拟中。我们将工作流开销分为以下五类。</p><ul><li>Workflow Engine Delay测量作业的最后一个父作业完成与作业提交到本地队列的时间之间的时间。Workflow Engine Delay反映了工作流引擎（在我们的例子中是 DAGMan）的效率。</li><li>Queue Delay定义为工作流引擎向本地队列提交作业与本地调度程序看到作业运行（可能在远程资源上）之间的时间。它反映了工作流调度程序（例如，Condor [19]）执行作业的效率以及执行作业的资源可用性。</li><li>Postscript Delay and Prescript Delay是在某些执行系统下执行作业前后执行轻量级脚本所花费的时间。Prescripts 通常用于创建作业执行目录。Postscript在作业的计算部分完成后检查作业的退出代码。</li><li>Data Transfer Delay当数据在节点之间传输时发生。它包括三种不同类型的过程：staging data in, cleaning up, and staging data out.</li><li>Clustering Delay衡量的是实际任务运行时间的总和与工作流调度程序看到的作业运行时间之间的差异</li></ul><p>我们指出有必要考虑开销的分配，而不是简单地在作业执行后添加一个恒定的延迟。我们以工作流引擎延迟为例来说明对开销进行适当建模的必要性。</p><p><img src="http://cdn.leafii.top/img/image-20230424180933926.png" alt="image-20230424180933926" loading="lazy"></p><p>图 4 显示了 Montage 8 度工作流中开销和运行时间的真实轨迹（对于缩放问题，我们仅显示 mProjectPP 级别中的前 15 个作业）。我们可以看到，工作流引擎延迟在每五个作业后稳定增加。我们将这种工作流开销的特殊性称为循环递增。因此，在每次作业执行后简单地添加一个恒定的延迟忽略了它对性能的潜在影响。出于这个原因，我们采用基于消息队列的方法并迭代检查 WorkflowSim 中的消息队列。</p><p>图 6 显示了 mProjectPP、mDiffFit 和 mBackground 的 Clustering Delay 的平均值。很明显，随着k（每个水平级别的最大作业数）的增加，集群中的任务越来越少，因此每个作业的集群延迟减少。</p><p><img src="http://cdn.leafii.top/img/image-20230424201616337.png" alt="image-20230424201616337" loading="lazy"></p><p>根据等式1，<img src="http://cdn.leafii.top/img/image-20230424181348922.png" alt="image-20230424181348922" loading="lazy"></p><p>如果已知k&#x3D;j时的延迟，反比例模型可以直接估计k&#x3D;i时的延迟。因此，只要我们收集到一个聚类案例，我们就可以预测所有的聚类案例。</p><h4 id="Layered-Failures-and-Job-Retry"><a href="#Layered-Failures-and-Job-Retry" class="headerlink" title="Layered Failures and Job Retry"></a>Layered Failures and Job Retry</h4><p>在工作流执行期间的不同时间可能会发生故障。与任务和作业的定义一致，我们将瞬态故障分为两类：任务故障和作业故障。如果暂时性故障影响任务的计算（任务失败），作业中的其他任务不一定失败。如果暂时性故障影响集群作业（作业失败），则其所有任务都会失败。我们添加了两个组件来响应故障模拟：</p><ul><li>Failure Generator被引入以在每个执行站点注入任务&#x2F;作业失败。每个作业执行后，Failure Generator 根据用户指定的分布和平均失败率随机生成任务&#x2F;作业失败。</li><li>Failure Monitor收集故障记录并将它们返回给工作流管理系统，以便它可以动态调整调度策略。</li></ul><p>我们还修改了其他组件以支持容错优化。在容易出现故障的环境中，有多种方法可以提高工作流性能。</p><ol><li>当计算不成功时，可以简单地重试整个作业或仅重试该作业的失败部分。此功能被添加到 Workflow Scheduler，它检查作业的状态并根据用户选择的策略采取行动。</li><li>Reclustering是我们提出的一种技术，它试图根据检测到的故障率来调整任务聚类策略。</li></ol><h3 id="VALIDATION"><a href="#VALIDATION" class="headerlink" title="VALIDATION"></a>VALIDATION</h3><p>我们以任务聚类为例说明在工作流模拟中引入开销overheads的必要性。目标是比较工作流的模拟整体运行时间，以防作业运行时间和系统开销的信息已知并从先前的跟踪中提取。</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>在Application部分，作者介绍了如何使用WorkflowSim进行科学工作流研究。他们提到，WorkflowSim提供了一种灵活的框架，可以轻松地模拟各种科学工作流应用程序，并支持各种优化技术，例如任务聚类和容错性。 作者还列举了一些使用WorkflowSim进行研究的实际应用案例，包括生物信息学、气象预测、天文学和地震模拟等领域。他们指出，WorkflowSim可以帮助研究人员更好地理解和优化这些复杂的科学工作流应用程序，并提高其性能和效率。 </p><h3 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h3><p>在Conclusion and Future Work部分，作者总结了他们的研究成果，并提出了未来的研究方向。作者指出，WorkflowSim是一个可靠且有效的工作流仿真器，可以用于各种科学工作流应用程序中，并支持各种优化技术。 作者还提到，未来的研究方向包括进一步改进WorkflowSim的性能和功能，例如增加对容错性和动态资源管理的支持。此外，作者还计划将WorkflowSim扩展到更广泛的应用领域，并与其他工作流引擎进行比较。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments&quot;&gt;&lt;a href=&quot;#WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments&quot; class=&quot;headerlink&quot; title=&quot;WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments&quot;&gt;&lt;/a&gt;WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;现有的工作流模拟器无法提供一个考虑异构系统开销和失败的框架，也缺少对广泛使用的工作流优化技术（如任务聚合）的支持。因此我们引入了WorkflowSim。在扩展CloudSim的基础上提供了更高层的工作流管理。我们还通过实验证明了忽视系统开销和故障会导致预测工作流时间的极大不准确。在两个研究领域中我们进一步验证了WorkflowSim在促进科学研究方面的价值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode119.杨辉三角II</title>
    <link href="2023/04/24/leetcode119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/"/>
    <id>2023/04/24/leetcode119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</id>
    <published>2023-04-24T05:27:41.000Z</published>
    <updated>2023-04-24T05:38:24.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><span id="more"></span><p><img src="http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2-20230424132835008.gif" alt="img" loading="lazy"></p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: rowIndex &#x3D; 3输出: [1,3,3,1]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: rowIndex &#x3D; 0输出: [1]</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: rowIndex &#x3D; 1输出: [1,1]</code></pre><p><strong>提示:</strong></p><ul><li><code>0 &lt;= rowIndex &lt;= 33</code></li></ul><p><strong>进阶：</strong></p><p>你可以优化你的算法到 <code>*O*(*rowIndex*)</code> 空间复杂度吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>得到33行的所有结果，再按照要求返回对应的行的数组</li></ul><p>得到33行的结果的代码可以直接从leetcode118里复制粘贴，最后只需要修改一下return的值就行，需要返回的是result数组里需要的那一行的结果数组。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; getRow(int rowIndex) &#123;        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组        for (int i &#x3D; 0; i &lt; 34; i++) &#123; &#x2F;&#x2F; 按行进行遍历            &#x2F;&#x2F; i是当前行号            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行                     continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值                &#125;                else &#123;                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和                &#125;            &#125;            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组        &#125;        return results[rowIndex];&#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre><ul><li>空间复杂度优化</li></ul><p>本题要求生成杨辉三角的第 <code>rowIndex</code> 行，其中第 <code>i</code> 行有 <code>i+1</code> 个数，即第一行有 1 个数，第二行有 2 个数，第三行有 3 个数，以此类推。</p><p>因为杨辉三角的每一行只依赖于上一行的值，所以我们可以只存储上一行的值，不断地更新，直到得到第 <code>rowIndex</code> 行为止。</p><p>我们可以用一个一维数组来存储上一行的值，并不断地更新数组中的值，最终得到第 <code>rowIndex</code> 行的值。在更新的过程中，我们需要注意到数组的下标从 0 开始，而杨辉三角每一行的第一个数和最后一个数都是 1，所以我们需要在数组的第一个位置和最后一个位置都赋值为 1。</p><p>由于本题要求空间复杂度为 <code>O(rowIndex)</code>，因此我们不能开辟二维数组。在更新数组中的值时，我们需要用到上一行中前面的数和当前行中前面的数，因此我们需要用一个变量 <code>pre</code> 来存储上一行中前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。</p><p>时间复杂度为 <code>O(rowIndex^2)</code>，空间复杂度为 <code>O(rowIndex)</code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; getRow(int rowIndex) &#123;        vector&lt;int&gt; res(rowIndex + 1, 1);  &#x2F;&#x2F; 初始化结果数组为全 1        for (int i &#x3D; 2; i &lt;&#x3D; rowIndex; ++i) &#123;  &#x2F;&#x2F; 从第 2 行开始更新            int pre &#x3D; res[0];  &#x2F;&#x2F; 存储上一行前面的数            for (int j &#x3D; 1; j &lt; i; ++j) &#123;                int temp &#x3D; res[j];  &#x2F;&#x2F; 保存当前位置的值                res[j] +&#x3D; pre;  &#x2F;&#x2F; 更新当前位置的值                pre &#x3D; temp;  &#x2F;&#x2F; 更新 pre            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><p>在上述代码中，我们用 <code>res</code> 数组存储上一行的值，并初始化为全 1。然后从第 2 行开始更新，用变量 <code>pre</code> 存储上一行前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。最终返回更新后的结果数组即可。</p><p>由于题目要求返回的是第 <code>rowIndex</code> 行，因此数组的大小应该为 <code>rowIndex + 1</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负索引 &lt;code&gt;rowIndex&lt;/code&gt;，返回「杨辉三角」的第 &lt;code&gt;rowIndex&lt;/code&gt; 行。&lt;/p&gt;
&lt;p&gt;在「杨辉三角」中，每个数是它左上方和右上方的数的和。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode118.杨辉三角</title>
    <link href="2023/04/23/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>2023/04/23/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</id>
    <published>2023-04-23T02:34:59.000Z</published>
    <updated>2023-04-23T02:46:21.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><span id="more"></span><p><img src="http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img" loading="lazy"></p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: numRows &#x3D; 5输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: numRows &#x3D; 1输出: [[1]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接模拟</li></ul><p>直接看代码吧 就是直接模拟：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组        for (int i &#x3D; 0; i &lt; numRows; i++) &#123; &#x2F;&#x2F; 按行进行遍历            &#x2F;&#x2F; i是当前行号            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行                     continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值                &#125;                else &#123;                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和                &#125;            &#125;            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组        &#125;        return results;&#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负整数 &lt;em&gt;&lt;code&gt;numRows&lt;/code&gt;，&lt;/em&gt;生成「杨辉三角」的前 &lt;em&gt;&lt;code&gt;numRows&lt;/code&gt;&lt;/em&gt; 行。&lt;/p&gt;
&lt;p&gt;在「杨辉三角」中，每个数是它左上方和右上方的数的和。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode224.基本计算器</title>
    <link href="2023/04/19/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>2023/04/19/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2023-04-19T14:40:16.000Z</published>
    <updated>2023-04-20T02:08:21.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;1 + 1&quot;输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot; 2-1 + 2 &quot;输出：3</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li><li>‘+’ 不能用作一元运算(例如， “+1” 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</li><li>‘-‘ 可以用作一元运算(即 “-1” 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</li><li>输入中不存在两个连续的操作符</li><li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>题目要求实现一个计算器，计算一个字符串表达式的值。因为表达式中可能会存在括号，为了方便计算，可以使用递归的方法来实现。当遇到左括号时，递归调用自身来计算括号内的表达式值，当遇到右括号时，返回计算结果。当遇到加号或减号时，记录当前的操作符。当遇到数字时，记录当前的数值，并根据之前的操作符进行相应的计算。</p><p>具体步骤如下：</p><ol><li>定义一个辅助栈，用于存储之前的操作符和数字；</li><li>遍历表达式字符串，遇到数字时记录下来，遇到左括号时递归调用自身，遇到右括号时返回计算结果；</li><li>遇到加号或减号时，记录当前的操作符，遇到其他字符时忽略；</li><li>当遇到表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，并返回最终结果。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int calculate(string s) &#123;        stack&lt;int&gt; st;  &#x2F;&#x2F; 定义一个辅助栈，用于存储之前的操作符和数字        int num &#x3D; 0;  &#x2F;&#x2F; 用于记录当前的数值        int res &#x3D; 0;  &#x2F;&#x2F; 用于记录最终结果        int sign &#x3D; 1;  &#x2F;&#x2F; 用于记录当前的操作符，1表示加号，-1表示减号        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            if (isdigit(s[i])) &#123;  &#x2F;&#x2F; 如果当前字符是数字                num &#x3D; num * 10 + (s[i] - &#39;0&#39;);  &#x2F;&#x2F; 记录当前的数值            &#125; else if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;  &#x2F;&#x2F; 如果当前字符是左括号                int j &#x3D; i, cnt &#x3D; 0;                for (; i &lt; s.size(); i++) &#123;                    if (s[i] &#x3D;&#x3D; &#39;(&#39;) cnt++;                    if (s[i] &#x3D;&#x3D; &#39;)&#39;) cnt--;                    if (cnt &#x3D;&#x3D; 0) break;                &#125;                num &#x3D; calculate(s.substr(j + 1, i - j - 1));  &#x2F;&#x2F; 递归调用自身计算括号内的表达式值            &#125;            if (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;  &#x2F;&#x2F; 如果当前字符是加号或减号，或者已经遍历到表达式字符串的末尾                if (s[i] &#x3D;&#x3D; &#39;+&#39;) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中                    sign &#x3D; 1;  &#x2F;&#x2F; 更新操作符为加号                &#125; else if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中                    sign &#x3D; -1;  &#x2F;&#x2F; 更新操作符为减号                &#125; else if (s[i] &#x3D;&#x3D; &#39;)&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将最后一个数值乘上当前的操作符，并压入栈中                    int tmp &#x3D; 0;                    while (!st.empty()) &#123;  &#x2F;&#x2F; 从栈中取出数字和操作符进行计算，直到栈为空                        tmp +&#x3D; st.top();                        st.pop();                    &#125;                    res &#x3D; tmp;  &#x2F;&#x2F; 更新最终结果                &#125;                num &#x3D; 0;  &#x2F;&#x2F; 清空当前的数值            &#125;        &#125;        return res;  &#x2F;&#x2F; 返回最终结果    &#125;&#125;;</code></pre><blockquote><p>上述代码使用了一个栈来存储之前的数字和操作符，用于最后的计算。遇到左括号时，递归调用自身计算括号内的表达式值。遇到加号或减号时，记录当前的操作符和数字，当遇到右括号或表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，得到最终结果。</p></blockquote><p>需要注意的是，在遇到左括号时，需要找到对应的右括号位置，才能正确地计算括号内的表达式值。这里使用了一个变量cnt来记录遍历到的左括号数量和右括号数量的差值，当cnt为0时，说明找到了对应的右括号。</p><p>另外，需要注意的是，当遍历到表达式字符串的末尾时，也需要将之前记录的数字和操作符进行计算，得到最终结果。因此，在遍历完表达式字符串后，还需要进行一次栈中剩余数字和操作符的计算，以得到最终结果。</p><p>最后，需要注意对于操作数可能有多个位数的情况，需要在遍历字符串时将多位数字组合成一个完整的数值。这里使用了一个变量num来记录当前的数值，每次遍历到数字时，将其乘以10并加上当前位的数值即可。</p><p>综上所述，上述代码实现了一个简单的基本计算器，可以计算表达式中的加减法和括号，并返回最终结果。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串表达式 &lt;code&gt;s&lt;/code&gt; ，请你实现一个基本计算器来计算并返回它的值。&lt;/p&gt;
&lt;p&gt;注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 &lt;code&gt;eval()&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>WorkflowSim工作流仿真软件介绍+类的介绍+自创算法实现步骤</title>
    <link href="2023/04/19/WorkflowSim%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D-%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D-%E8%87%AA%E5%88%9B%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/"/>
    <id>2023/04/19/WorkflowSim%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D-%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D-%E8%87%AA%E5%88%9B%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/</id>
    <published>2023-04-19T08:00:38.000Z</published>
    <updated>2023-04-19T13:05:55.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intorduction"><a href="#Intorduction" class="headerlink" title="Intorduction"></a>Intorduction</h2><p>现在的大数据应用都非常复杂，并不仅仅能够通过一个或者几个MapReduce任务来描述。更加复杂的描述大数据应用的是工作流 (workflow)。</p><p>WorkflowSim (<a href="http://www.workflowsim.org/)%E6%98%AF%E7%94%B1%E5%8D%97%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%A6">http://www.workflowsim.org/)是由南加州大学</a>(University of Southern California)的Weiwei Chen开发的一套开源工作流仿真软件。WorkflowSim是拓展自CloudSim的工作流仿真开源软件，可以提供工作流基础上的仿真，增加了模拟不同层次延时和故障的支持，与真实分布式环境更加接近。支持了各种task scheduling, clustering, resource provisioning的算法。广泛应用在故障容错研究，成本导向调度研究，资源调度研究，能耗研究等领域。</p><span id="more"></span><p>其工作原理是在暨有的CloudSim仿真软件基础上，提供workflow层次的仿真。工作流可以用有向图来描述(Directed Acyclic Graph) DAG，图的任何一个节点都是一个由用户制定执行的任务(task)，节点之间有通过数据输入输出形成的依赖关系(dependency)。工作流引擎会依据其依赖关系按顺序执行，同时执行也会调用用户所选择的调度算法，比如HEFT，MINMIN等等算法已经在WorkflowSim里边实现并且测试通过了。</p><p>用户也可以添加自己的调度算法。</p><p>在实际运行过程中，因为很多工作流非常大，甚至到达几千上万个任务，而通常我们只有几十个计算节点。这个时候就需要使用task clustering这个技术来聚合相类似的任务从而形成任务群(clustered job)，有时候也通用称之为job。每个job包含了多个task，然后提交给运行环境的时候是整体提交的，这样可以节省很多延迟(submission delay)，等到了某一个计算节点的时候再打开任务群然后分别执行。</p><p>如何形成job就需要各种算法，有包括了balanced task clustering可以综合考虑依赖关系的，也有fault tolerant clustering可以综合考虑规避failure的。这些也都已经在WorkflowSim里边实现。</p><p>其行为最为接近Pegasus工作流管理系统。</p><p>WorkflowSim是一套开源软件，所有源代码和介绍都可以在<a href="http://www.github.com/WorkflowSim/%E6%89%BE%E5%88%B0%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9B%AE%E5%89%8D%E6%B5%81%E8%A1%8C%E7%9A%84Git%E5%81%9A%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E3%80%82">http://www.github.com/WorkflowSim/找到，使用目前流行的Git做软件版本控制。</a></p><p>使用非常简单，下载完源代码之后，只需要在任何一个WorkflowSim example里边选择所需要的dax 文档，并且修改里边的daxPath变量，即可运行。比如选择:“examples&#x2F;org&#x2F;workflowsim&#x2F;examples&#x2F;WorkflowSimBasicExample1.java”这个例子，将里边的daxPath改成在你当前环境下的文件路径即可。</p><p>WorkflowSim在config&#x2F;dax文件夹下面已经提供了很多DAX文件可供仿真。这些工作流的介绍可以参考：Documentation – Pegasus WMS</p><p>同时我们还提供WorkflowGenerator可以生成你所需要的任何工作流DAX文件<a href="https://confluence.pegasus.isi.edu/display/pegasus/WorkflowGenerator">https://confluence.pegasus.isi.edu/display/pegasus/WorkflowGenerator</a></p><p>如果对WorkflowSim感兴趣并且想进一步开发功能，可建议（但不限于）研究以下方面</p><ol><li><p>基于价格的调度算法，CloudSim本身已经实现了每个task的cost，但是WorkflowSim还没有合适的调度算法。</p></li><li><p>动态资源调度算法。WorkflowSim目前还是静态的把计算节点建立好然后运行工作流。</p></li><li><p>多数据中心支持。目前只测试了单数据中心支持。</p></li><li><p>数据日志支持。将已有的工作流管理系统的log转换成为trace从而可以在WorkflowSim里边仿真？目前只测试过Pegasus。</p></li><li><p>可靠的调度算法，在仿真Failure的情况下调度算法应该如何变得更鲁棒？目前failure的生成已经开发完成，但是相应的算法还没有。</p></li><li><p>自适应算法或者分布式算法。目前仅有一个中心调度算法，分布式算法也可以在WorkflowSim上面实现。</p></li><li><p>基于duplication的算法。在计算节点有余的时候，可以自动复制一部分任务到空闲的计算节点上。</p></li></ol><h3 id="WorkflowSim中调度算法与规划算法的区别"><a href="#WorkflowSim中调度算法与规划算法的区别" class="headerlink" title="WorkflowSim中调度算法与规划算法的区别"></a>WorkflowSim中调度算法与规划算法的区别</h3><p>WorkflowSim中有两种类型的算法：调度算法（Scheduling Algorithm）和计划算法（Planning Algorithm）。理论上它们是相同的，但是在实现方面它们是完全不同的。WorkflowSim 具有三层：Workflow Planner、Workflow Engine、Workflow Scheduler。</p><p>在 Workflow Planner 中，我们拥有整个工作流（所有任务及其依赖项）的全局视图，并且在每次迭代中，Workflow Engine 将free的任务（这意味着它们的父级已成功完成）发布到 Workflow Scheduler。Workflow Scheduler 将这些free的任务与资源（WorkflowSim 中的 Condor VM）进行匹配，并提交它们以供执行。分别来说，规划算法是一种全局调度算法，可以将任何任务绑定到任何资源（但实际执行顺序取决于资源可用性）。WorkflowSim 中的调度算法是一种本地调度算法，它只将空闲任务绑定到可用资源（并以某种方式保证它们的执行顺序）。</p><p>默认情况下，未设置规划算法。如果您已指定规划算法，则调度算法将被禁用，因为指定的规划算法强制工作流调度程序将任务映射到其分配的资源。</p><p>一些局部优化算法如MIN-MIN、MAX-MIN是调度算法，而一些全局优化算法如HEFT是WorkflowSim中的规划算法</p><h3 id="SHARED和LOCAL文件系统之间的区别"><a href="#SHARED和LOCAL文件系统之间的区别" class="headerlink" title="SHARED和LOCAL文件系统之间的区别"></a>SHARED和LOCAL文件系统之间的区别</h3><p>SHARED文件系统只有一个用于一个数据中心的存储空间，而LOCAL文件系统也有一个用于每个VM的本地文件系统。</p><p>对于 stage-in，在 SHARED 模式下，我们在stage-in作业开始时将所有的输入文件移动到共享存储中。在 LOCAL 模式下，我们将每个任务的输入文件从最近的 VM（因为 VM 也具有本地文件系统）或共享文件系统（如果该任务分配到的 VM 可用）移动。</p><p>对于数据传输成本，在 SHARED 模式下，数据传输成本已经计入任务执行时间，因此我们不计算每个作业的数据传输成本。但我们计算了初始阶段工作的成本。在 LOCAL 模式下，增加每个作业的数据传输成本。</p><p>为什么我们需要区分它们？在实践中，我们要么拥有一个共享文件系统，例如 NFS，要么拥有一个分布式系统，例如 HDFS。如果您有一些数据感知算法来提高数据局部性，则需要使用 LOCAL。否则，如果您的算法不考虑数据，您可以使用 SHARED fs 来简化建模。</p><h3 id="Task-和-Job-之间的区别（以及任务集群）"><a href="#Task-和-Job-之间的区别（以及任务集群）" class="headerlink" title="Task 和 Job 之间的区别（以及任务集群）"></a>Task 和 Job 之间的区别（以及任务集群）</h3><p>尽管在某些情况下我们可以互换使用Task和Job，但它们是完全不同的。任Task是用户指定运行的程序。它对应于 DAX 中的“job”，因为 DAX 是由用户创建的。WorkflowSim 中的Job是包含一个或多个Task的单个执行单元。但是，WorkflowSim 中的Job本身是从Task延伸扩展的，目的是简化一些代码。</p><p>任务聚类是一种将多个Task合并为一个Job的优化方法。根据不同的优化目的，我们最终可能会得到容错集群（最小化故障影响）、平衡任务集群（平衡数据传输成本和通信成本）等。</p><p>为什么任务集群即使它失去了一些并行性，也可以减少makespan？</p><p>任务集群只能在资源争用的情况下工作，这意味着我们没有足够的资源，必须将任务合并到任务中。例如，Montage工作流在每个级别最多可以有10,000个任务，而通常在一个小型数据集群中有20个节点。通过将这些任务合并为20或40个作业，我们仍然可以充分利用资源并提高整体运行时间。另一个重要问题是开销，作业提交、作业执行、作业准备都具有在现代分布式系统中非常重要的开销。单独执行10,000个任务最终可能会产生10,000倍的开销，而20个作业有20倍的开销。</p><p>有关任务聚类的好处的更多详细信息，请参阅任何任务聚类论文。</p><h3 id="如何在类中增加属性？"><a href="#如何在类中增加属性？" class="headerlink" title="如何在类中增加属性？"></a>如何在类中增加属性？</h3><p>如果你有一个新的属性要在WorkflowSim中使用，并且想要在配置文件中配置它，可以进行下面的几个步骤:</p><ol><li>假设我们想要添加一个工作流的截止日期，并且它是一个很长的变量。在org.workflowsim.utils.Parameters.java中，添加:</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> deadline<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">long</span> dl<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">//other parameters</span> deadline <span class="token operator">=</span> dl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> deadline<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><blockquote><p><em>因为<strong>Parameters</strong>是一个静态对象，通过这种方式，我们可以在任何地方访问<strong>deadline</strong>。</em></p></blockquote><ol start="2"><li><p><em>在<strong>org.workflowsim.utils.ArgumentParser.java</strong>中添加解析</em></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArgumentParser</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//other parameter parsing</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"deadline"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> deadline <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token class-name">Parameters</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> deadline<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre></li></ol><blockquote><p><em>这意味着我们在解析配置文件时设置了参数的截止日期。</em></p></blockquote><ol start="3"><li><em>在<strong>config.txt</strong>中添加截止日期</em></li></ol><p>在<em>config.txt**文件中添加：</em></p><pre class="language-java" data-language="java"><code class="language-java">deadline <span class="token operator">=</span> <span class="token number">10000</span></code></pre><ol start="4"><li><em>然后你可以在你的调度程序中得到截止日期，比如在<strong>RandomPlanner.java</strong>中：</em></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token class-name">Parameters</span><span class="token punctuation">.</span><span class="token function">getDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="类的介绍"><a href="#类的介绍" class="headerlink" title="类的介绍"></a>类的介绍</h2><h3 id="Cloudlet"><a href="#Cloudlet" class="headerlink" title="Cloudlet"></a>Cloudlet</h3><p>Cloudlet类对托管在云数据中心的容器中的应用程序进行建模。Cloudlet继承了CloudSim软件包中的功能。包括用户id，任务的大小，传入文件的大小。传出文件的大小，执行开始时间，完成时间和执行状态（CREATED，READY，QUEUED,CANCEL,PAUSED ,FAILED,SUCCESS和RESUMED等）等。详情见“sources\org\cloudbus\cloudsim\Cloudlet.java”。</p><p>Cloudlet类中包含一个静态内部类：Resource，它被用来跟踪Cloudlet在不同CloudResource中的移动。记录Cloudlet在一个CloudResource中的提交时间、等待时间、时间运行时间、成本等信息。</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Task类是CloudSim中Cloudlet类的一个扩展。它支持实现任务之间的依赖关系，其中包括一组父任务和一组其子任务。在WorkflowSim中，当所有的父任务都成功完成时，工作流引擎确保任务被释放到调度器(准备运行)。</p><p>相比Cloudlet类，Task新增了parentList，childList，taskFinishTime等属性。其中增加taskFinishTime是因为cloudlet不允许WorkflowSim更新任务的finish time。Task类中的getProcessingCost()方法用来获取处理或执行此任务的总成本。原始的Processing Cost &#x3D; input data transfer + processing cost + output transfer cost</p><p>【可根据需要进行修改】。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job是Task的扩展。它基本上是一组任务。在WorkflowSim中，ClusteringEngine将任务合并为任务(任务组)，并且job的总体运行时间是task运行时间的总和。</p><h3 id="Vm"><a href="#Vm" class="headerlink" title="Vm"></a>Vm</h3><p>Vm 类对VM进行建模。虚拟机由主机管理和托管，它运行在一个主机内，与其他虚拟机共享hostList。VM的属性有内存，处理器及其存储大小。它根据CloudletScheduler定义的策略处理cloudlet。每个虚拟机都有一个所有者，由所有者将cloudlet提交给要执行的虚拟机。</p><h3 id="CondorVM"><a href="#CondorVM" class="headerlink" title="CondorVM"></a>CondorVM</h3><p>Condor Vm扩展一个Vm，不同的是它有一个本地存储系统和一个状态来指示它是否忙碌：VM_STATUS_IDLE or VM_STATUS_READY (not used in workflowsim) or VM_STATUS_BUSY。</p><h3 id="FileItem"><a href="#FileItem" class="headerlink" title="FileItem"></a>FileItem</h3><p>这是WorkflowSim中的一个文件实现。由于CloudSim已经实现了File，我们在这里称之为FileItem。WorkflowSim有一个不同的文件视图。案例1:在org.cloudsim.File中，文件大小是integer类型，而在我们的例子中，它应该是double类型，因为我们有很多大的文件。此外，我们希望精确地估计传输延迟。案例2:我们指定与CloudSim中不同的文件的类型FileType (NONE，输入INPUT，输出OUTPUT)。</p><p>FileItem类中的isRealInputFile()方法，用于判断文件是否为输入文件。输入文件对应有一个输出文件，它不需要在工作流中阶段加入，我们有一个规则，一个文件只写一次，并多次读取，因此，如果一个文件是一个输出文件，这意味着它是在这个作业中生成的，然后由同一作业(或者其他作业)中的另一个任务使用。</p><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>Parameters类包含用户可以在配置文件中指定的大多数参数。</p><p>类中定义了调度算法、规划算法、文件类型、成本模型等枚举类型，以及虚拟机个数、调度算法、规划算法、成本模型、最大深度等属性。</p><h3 id="Datacenter"><a href="#Datacenter" class="headerlink" title="Datacenter"></a>Datacenter</h3><p>DataCenter类代表数据中心，提供虚拟化的网格资源，处理虚拟机信息的查询，包含虚拟机对资源的分配策略。数据中心类是一个CloudResource，它的主机列表是虚拟化的。它处理VM查询(即VM处理)，而不是处理与cloudlet相关的查询。即使一个分配策略将被实例化(在超类的init()方法中)，它也不会被使用，因为cloudlets的处理由CloudletScheduler处理，虚拟机的处理由VmAllocationPolicy处理。</p><p>类中包含DatacenterCharacteristics属性，DatacenterCharacteristics表示资源的静态属性，如资源架构、操作系统(OS)、管理策略(时间或空间共享)、成本和资源配置中所处的时区。</p><h3 id="WorkflowDatacenter"><a href="#WorkflowDatacenter" class="headerlink" title="WorkflowDatacenter"></a>WorkflowDatacenter</h3><p>WorkflowDatacenter扩展了Datacenter，这样我们就可以使用CondorVM和其他组件。</p><p>类中包含processCloudletSubmit()方法，它处理Cloudlet提交。cloudlet实际可以被cast到org.workflowsim.Job 。</p><p>updateTaskExecTime()方法更新job中的task的执行时间与完成时间。</p><p>stageInFile2FileSystem()方法，将处于stage-in 阶段的job所需文件加入存储。对于本地文件系统(如condor-io)，将文件添加到本地存储；对于共享文件系统(如NFS)，需要向共享存储添加文件。</p><p>processDataStageInForComputeJob()方法，返回job执行所需的文件传输时间个执行时间。</p><h3 id="WorkflowParser"><a href="#WorkflowParser" class="headerlink" title="WorkflowParser"></a>WorkflowParser</h3><p>WorkflowParser将DAX解析为任务，以便WorkflowSim可以管理它们。</p><p>DAX的文件格式如下：</p><p><img src="http://cdn.leafii.top/img/1f7d9ac573959e92928a9529130d523c.png" alt="img" loading="lazy"></p><p>类中的parseXmlFile(String path)方法，根据参数DAX文件的地址path，将其转换为工作流。它遍历整个dax文件，将所有的<code>&lt;job&gt;&lt;/job&gt;</code>标签，转换为工作流中的任务task，其中id是该任务的唯一标识；runtime为该任务的长度；其内部的<code>&lt;uses&gt;&lt;/uses&gt;</code>标签代表该任务的文件。link属性表示文件的种类（input输入文件或output输出文件）；size属性代表该文件的大小；其中file属性代表该文件的名字。【任务A的output输出文件名file和大小size需要与其对应的任务B的input输入文件名和大小相同！】</p><p><code>&lt;child&gt;&lt;parent&gt;&lt;/parent&gt;&lt;/child&gt;</code>标签表示任务之间的依赖关系，即某一个子任务child的父任务parent有哪些。其中ref属性的值对应<code>&lt;job&gt;</code>标签中的id属性。parseXmlFile()方法根据这些依赖关系，设置工作流中的某一个任务的子任务与父任务及其深度。如果一个任务没有父任务，则将其设置为root。【root可能有多个！】</p><h3 id="SimEntity"><a href="#SimEntity" class="headerlink" title="SimEntity"></a>SimEntity</h3><p>该类表示一个模拟实体。实体可以处理事件，也可以发送事件给其他实体。当这个类被扩展时，有几个方法需要被实现:</p><p>①startEntity()：在模拟启动时，由Simulation类调用。这个方法负责启动实体。</p><p>② processEvent(SimEvent)：每当延迟队列中有需要由实体处理的事件时，仿真类就会调用processEvent(SimEvent)。</p><p>③ shutdownEntity()：在模拟结束之前，仿真调用shutdownEntity()。如果你想将数据保存在日志文件中，这个方法将放置相应的代码。</p><h3 id="WorkflowScheduler"><a href="#WorkflowScheduler" class="headerlink" title="WorkflowScheduler"></a>WorkflowScheduler</h3><p>WorkflowScheduler它隐藏了虚拟机管理，例如创建虚拟机、将任务交给虚拟机以及销毁虚拟机，并根据配置选择调度算法。</p><p>一个workflowScheduler代理中绑定一个workflowEngine，即其含有一个workflowEngineId属性，并通过bindSchedulerDatacenter(int datacenterId)方法将其与一个数据中心绑定。与此同时，为了保证每个任务仅提交一次，设置一个布尔类型的变量processCloudletSubmitHasShown来标记任务是否提交。除此之外，workflowScheduler代理根据不同的指令执行对应的事件，如下图：</p><p><img src="http://cdn.leafii.top/img/78b5a2e208681634869183a8c4c14a88.png" alt="img" loading="lazy"></p><h3 id="WorkflowEngine"><a href="#WorkflowEngine" class="headerlink" title="WorkflowEngine"></a>WorkflowEngine</h3><p>WorkflowEngine为代表用户的引擎。它隐藏了虚拟机管理，例如创建虚拟机、向虚拟机提交cloudlet和销毁虚拟机。由于WorkflowEngine类继承了SimEntity类，所以他重写了startEntity()、processEvent(SimEvent)、shutdownEntity()方法。一个workflowEngine引擎控制多个workflowScheduler代理。</p><p>hasJobListContainsID(List jobList, int id)方法：用来判断一个任务列表中是否存在某个任务。</p><p>submitJobs()方法：在提交获得的任务列表时，借助hasJobListContainsID(List jobList, int id)方法来判断某个要提交的任务的所有父任务是否已经全部执行完毕。</p><h3 id="WorkflowPlanner"><a href="#WorkflowPlanner" class="headerlink" title="WorkflowPlanner"></a>WorkflowPlanner</h3><p>WorkflowPlanner根据配置选择规划算法。他有一个ClusteringEngine属性，即一个workflowPlanner代理与一个clusteringEngine引擎绑定，并通过clusteringEngine引擎绑定到一个workflowEngine引擎中。【ClusteringEngine类是WorkflowSim的一个可选组件，它可以将多个任务合并成一个大任务，由于目前本人还没有使用到，所以暂不介绍~】</p><p>WorkflowPlanner类中的getPlanningAlgorithm(PlanningAlgorithm name)方法可以根据需要选择规划算法，<strong>一般我们在使用WorkflowSim创建自己个人的算法时，写的算法是PlanningAlgorithm类型的规划算法。</strong></p><p>workflowPlanner代理可以为任务添加影响因子，这对任务平衡的聚类算法很有用，我们可以根据研究需要，选择使用。方法为：processImpactFactors(List<Task> taskList) 与addImpact(Task task, double impact)。</p><h3 id="BaseSchedulingAlgorithm"><a href="#BaseSchedulingAlgorithm" class="headerlink" title="BaseSchedulingAlgorithm"></a>BaseSchedulingAlgorithm</h3><p>BaseSchedulingAlgorithm类继承了SchedulingAlgorithmInterface接口，它是一个基本调度器实现了基本功能。如：虚拟机的get与set，cloudlet类型的任务列表的get与set，以及主要的run()方法。其他调度方法应扩展自BaseSchedulingAlgorithm，但不应直接使用。</p><h3 id="BasePlanningAlgorithm"><a href="#BasePlanningAlgorithm" class="headerlink" title="BasePlanningAlgorithm"></a>BasePlanningAlgorithm</h3><p>BasePlanningAlgorithm类继承了PlanningAlgorithmInterface接口，它是一个基本规划器实现了基本功能。如：虚拟机的get与set，任务列表的get与set，以及主要的run()方法。其他调度方法应扩展自BasePlanningAlgorithm，但不应直接使用。</p><p>与BaseSchedulingAlgorithm<strong>不同</strong>，BasePlanningAlgorithm可以直接设置并获取Task类型的任务列表，并增加了数据中心列表DatacenterList的get与set。</p><p><strong>【我们使用WorkflowSim创建个人的算法时，需要继承BasePlanningAlgorithm类】。</strong></p><h3 id="WorkflowSimBasicExample1"><a href="#WorkflowSimBasicExample1" class="headerlink" title="WorkflowSimBasicExample1"></a>WorkflowSimBasicExample1</h3><p>由其名可知，这是一个基本的WorkflowSimExample，它创建了一个工作流规划器、一个工作流引擎、一个调度器、一个数据中心和20个虚拟机。【根据实际情况在使用时更改daxPath与其他参数】。它包含4个方法：main()方法，创建虚拟机的方法createVM()，创建数据中心的方法createDatacenter()，以及输出结果的方法printJobList()。</p><p>main()方法实现了：①初始化WorkflowSim包；②初始化Parameters参数；③初始化cloudsim包；④创建数据中心；⑤创建调度算法代理；⑥创建WorkflowEngine引擎；⑦创建工作流；⑧创建虚拟机；⑨执行调度算法，完成任务到虚拟机的映射；⑩启动仿真程序、打印仿真结果以及关闭仿真程序。</p><p>我们在写好了自己的算法后，为了实现他，则需要<strong>创建一个继承了WorkflowSimExample的example来运行算法。</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="如何创建并使用调度算法"><a href="#如何创建并使用调度算法" class="headerlink" title="如何创建并使用调度算法"></a>如何创建并使用调度算法</h3><p>当我们下载好WorkflowSim源码后，便可以实现一个自己的调度算法。具体步骤如下：</p><ol><li>在source&#x2F;org&#x2F;planning中写一个继承BasePlanningAlgorithm的Class，类名如RKPNPlanningAlgorithm,重写run()方法。【可参考HEFTPlanningAlgorithm算法】，如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/71c79ef2c2ba683cd3c80a7aa23f0dde.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/dcdd7c3c49b40442515f15fc3178b30c.png" alt="img" loading="lazy"></p><ol start="2"><li>算法写完之后，需要在WorkflowPlanner的getPlanningAlgorithm()方法中增加该算法，具体操作如下：</li></ol><p><img src="http://cdn.leafii.top/img/75501f37de1f5ed5c7679f28e655203b.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/b05b6fe6250db499ccefd05b43ec576d.png" alt="img" loading="lazy"></p><p>其中的case：RKPN中的RKPN是自定义的算法名的缩写。</p><ol start="3"><li>在参数类Parameters的枚举PlanningAlgorithm里面添加步骤2的case:RKPN，具体操作如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/b9ab51fe998664ccd21b63f0157c7230.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/f957d7ca93dbc563cf4f51141b28cb51.png" alt="img" loading="lazy"></p><ol start="4"><li>这样我们的一个调度算法就编写完了，如何使用呢？需要在”examples&#x2F;org&#x2F;workflowsim.examples&#x2F;planning”中创建一个example来实现它。具体操作如下：</li></ol><p><img src="http://cdn.leafii.top/img/4f4798e0f63054ec8c031c4a21274878.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/d2f07a1477cb395186d059fa898a3f89.png" alt="img" loading="lazy"></p><p>如图所示，在main()方法中需要根据自己的dax工作流文件的存放地址修改daxPath的值。【在“config&#x2F;dax”中也有许多可供使用的工作流文件~】</p><p><img src="http://cdn.leafii.top/img/80bc660ab00519661684d2be785cd0c0.png" alt="img" loading="lazy"></p><p>上图修改Parameters的规划算法参数，值为在步骤(3)中设置的参数</p><p>除此之外，我们也可以根据需要自行设置虚拟机的个数vmNum等其他参数。具体操作见代码。</p><ol start="5"><li>运行main()函数，即可在控制台获得工作流的运行结果。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文直接复制粘贴自：<a href="https://blog.csdn.net/LaraJean/article/details/123689433">https://blog.csdn.net/LaraJean/article/details/123689433</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Intorduction&quot;&gt;&lt;a href=&quot;#Intorduction&quot; class=&quot;headerlink&quot; title=&quot;Intorduction&quot;&gt;&lt;/a&gt;Intorduction&lt;/h2&gt;&lt;p&gt;现在的大数据应用都非常复杂，并不仅仅能够通过一个或者几个MapReduce任务来描述。更加复杂的描述大数据应用的是工作流 (workflow)。&lt;/p&gt;
&lt;p&gt;WorkflowSim (&lt;a href=&quot;http://www.workflowsim.org/)%E6%98%AF%E7%94%B1%E5%8D%97%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%A6&quot;&gt;http://www.workflowsim.org/)是由南加州大学&lt;/a&gt;(University of Southern California)的Weiwei Chen开发的一套开源工作流仿真软件。WorkflowSim是拓展自CloudSim的工作流仿真开源软件，可以提供工作流基础上的仿真，增加了模拟不同层次延时和故障的支持，与真实分布式环境更加接近。支持了各种task scheduling, clustering, resource provisioning的算法。广泛应用在故障容错研究，成本导向调度研究，资源调度研究，能耗研究等领域。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode486.预测赢家</title>
    <link href="2023/04/19/leetcode486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"/>
    <id>2023/04/19/leetcode486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</id>
    <published>2023-04-19T06:44:54.000Z</published>
    <updated>2023-04-19T07:00:57.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p><p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 <code>0</code> 。每一回合，玩家从数组的任意一端取一个数字（即，<code>nums[0]</code> 或 <code>nums[nums.length - 1]</code>），取到的数字将会从数组中移除（数组长度减 <code>1</code> ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p><p>如果玩家 1 能成为赢家，返回 <code>true</code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 <code>true</code> 。你可以假设每个玩家的玩法都会使他的分数最大化。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,5,2]输出：false解释：一开始，玩家 1 可以从 1 和 2 中进行选择。如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。因此，玩家 1 永远不会成为赢家，返回 false 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,5,233,7]输出：true解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 107</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>首先，我们可以把这个问题看成是两个玩家在一堆石头上进行取石子游戏。每个玩家都可以在任何时候从石堆中取出一些石头，但是每次取石头的数量不能超过石堆中剩余石头的数量。游戏的规则是先手玩家必须先取，然后轮流取石头，直到石堆为空。每个石头的价值都不同，每个玩家在取石头时可以获得相应的价值。</p><p>我们可以用动态规划来解决这个问题。假设nums数组的长度为n，<code>dp[i][j]</code>表示在<code>nums[i...j]</code>范围内，先手玩家能获得的最大分数，那么先手玩家最终获胜的条件是<code>dp[0][n-1]</code>不小于nums中所有数之和的一半。</p><p>接下来考虑如何计算dp数组。首先，我们可以很容易地得出当区间长度为1时，<code>dp[i][i]</code>的值就是<code>nums[i]</code>。这是因为当只有一个数时，先手玩家必定获胜，得分为该数。</p><p>接下来，我们需要考虑更长的区间。假设当前处理的区间长度为len，则可以枚举区间左端点i，然后通过递推式来计算<code>dp[i][j]</code>。对于区间<code>[i,j]</code>，先手玩家可以选择<code>i</code>或<code>j</code>作为自己的选择，那么后手玩家就会在<code>[i+1, j]</code>或<code>[i, j-1]</code>区间内变成先手玩家。这样转化后的问题就可以通过<code>dp</code>数组的计算得到解决。</p><p>具体地，假设先手玩家选择了左端点i，那么后手玩家就会在<code>[i+1, j]</code>区间内变成先手玩家，此时先手玩家能获得的最大分数就是<code>nums[i]</code>加上区间<code>[i+2,j]</code>或区间<code>[i+1,j-1]</code>内先手玩家能获得的最大分数的最小值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">left &#x3D; nums[i] + min(dp[i+2][j], dp[i+1][j-1])</code></pre><p>同样地，假设先手玩家选择了右端点<code>j</code>，那么后手玩家就会在<code>[i, j-1]</code>区间内变成先手玩家，此时先手玩家能获得的最大分数就是<code>nums[j]</code>加上区间<code>[i,j-2]</code>或区间<code>[i+1,j-1]</code>内先手玩家能获得的最大分数的最小值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">right &#x3D; nums[j] + min(dp[i][j-2], dp[i+1][j-1])</code></pre><p>由于先手玩家和后手玩家的取石头顺序是交替进行的，因此先手玩家和后手玩家在不同的区间上作为先手玩家和后手玩家的情况应该分别考虑。最终，<code>dp[i][j]</code>的值就是left和right中的较大值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">dp[i][j] &#x3D; max(left, right)</code></pre><p>最终的答案就是<code>dp[0][n-1]</code>是否大于等于<code>nums</code>中所有数之和的一半。</p><p>代码实现时，我们可以使用二维数组<code>dp</code>来保存先手玩家能获得的最大分数，然后用双重循环来枚举区间长度和区间左端点，并使用上述递推式来计算<code>dp</code>数组中的每个元素。最后，比较<code>dp[0][n-1]</code>和<code>nums</code>中所有数之和的一半即可得到答案。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); &#x2F;&#x2F; 定义二维dp数组，dp[i][j]表示当剩下的数是nums[i..j]时，先手玩家比后手玩家多得的最大分数。        &#x2F;&#x2F; 处理区间长度为1的情况        for (int i &#x3D; 0; i &lt; n; i++) &#123;            dp[i][i] &#x3D; nums[i]; &#x2F;&#x2F; 当剩下的数只有一个时，先手玩家只能取这个数，并且得分就是这个数本身。        &#125;        &#x2F;&#x2F; 处理更长的区间        for (int len &#x3D; 2; len &lt;&#x3D; n; len++) &#123; &#x2F;&#x2F; 枚举区间长度            for (int i &#x3D; 0; i &lt;&#x3D; n - len; i++) &#123; &#x2F;&#x2F; 枚举区间左端点                int j &#x3D; i + len - 1; &#x2F;&#x2F; 区间右端点                int left &#x3D; nums[i] + min(i+2 &lt;&#x3D; j ? dp[i+2][j] : 0, i+1 &lt;&#x3D; j-1 ? dp[i+1][j-1] : 0); &#x2F;&#x2F; 先手玩家取nums[i]后，后手玩家就成为了先手玩家，接下来剩下的数就是nums[i+1..j]，此时先手玩家能得到的最大分数是dp[i+1][j]。如果先手玩家取nums[i]后，后手玩家也取了一个数，那么接下来剩下的数就是nums[i+2..j]，此时先手玩家能得到的最大分数是dp[i+2][j]。由于后手玩家也是聪明的，他肯定会选择让先手玩家得到更少的分数，因此先手玩家能得到的最大分数就是nums[i]加上min(dp[i+2][j], dp[i+1][j-1])。同理，我们也可以计算出先手玩家取nums[j]时能得到的最大分数right。                int right &#x3D; nums[j] + min(i &lt;&#x3D; j-2 ? dp[i][j-2] : 0, i+1 &lt;&#x3D; j-1 ? dp[i+1][j-1] : 0);                dp[i][j] &#x3D; max(left, right); &#x2F;&#x2F; 取left和right的较大值，表示先手玩家在nums[i..j]这个区间内能得到的最大分数。            &#125;        &#125;        &#x2F;&#x2F; 判断先手玩家是否能获胜        return dp[0][n-1] &gt;&#x3D; accumulate(nums.begin(), nums.end(), 0) &#x2F; 2.0; &#x2F;&#x2F; 如果先手玩家能得到的最大分数不小于nums中所有数之和的一半，那么先手玩家就能获胜。    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。&lt;/p&gt;
&lt;p&gt;玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 &lt;code&gt;0&lt;/code&gt; 。每一回合，玩家从数组的任意一端取一个数字（即，&lt;code&gt;nums[0]&lt;/code&gt; 或 &lt;code&gt;nums[nums.length - 1]&lt;/code&gt;），取到的数字将会从数组中移除（数组长度减 &lt;code&gt;1&lt;/code&gt; ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。&lt;/p&gt;
&lt;p&gt;如果玩家 1 能成为赢家，返回 &lt;code&gt;true&lt;/code&gt; 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 &lt;code&gt;true&lt;/code&gt; 。你可以假设每个玩家的玩法都会使他的分数最大化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1823.找出游戏的获胜者</title>
    <link href="2023/04/18/leetcode1823-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/"/>
    <id>2023/04/18/leetcode1823-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/</id>
    <published>2023-04-18T03:49:15.000Z</published>
    <updated>2023-04-18T04:12:22.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 <strong>顺时针顺序</strong> 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 <code>i</code> 名小伙伴顺时针移动一位会到达第 <code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code> ，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 <code>1</code> 名小伙伴的位置。</p><p>游戏遵循如下规则：</p><ol><li>从第 <code>1</code> 名小伙伴所在位置 <strong>开始</strong> 。</li><li>沿着顺时针方向数 <code>k</code> 名小伙伴，计数时需要 <strong>包含</strong> 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 <strong>顺时针下一位</strong> 小伙伴 <strong>开始</strong>，回到步骤 <code>2</code> 继续执行。</li><li>否则，圈子中最后一名小伙伴赢得游戏。</li></ol><p>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ic234-q2-ex11.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5, k &#x3D; 2输出：3解释：游戏运行步骤如下：1) 从小伙伴 1 开始。2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 6, k &#x3D; 5输出：1解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= n &lt;= 500</code></li></ul><p><strong>进阶：</strong>你能否使用线性时间复杂度和常数空间复杂度解决此问题？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>约瑟夫问题求解</li></ul><p>首先我们需要确定递推公式，假设上一轮淘汰的是第 m 个人，那么本轮淘汰的是第 $(m+k)% n$ 个人，所以我们可以得到递推公式：$f(n, k) &#x3D; (f(n-1, k)+k) % n$，其中$ f(n, k) $表示 n 个人中最后剩下的人的编号。</p><p>当只有一个人的时候，那么这个人一定是胜者，因此我们可以得到初始值：f(1, k) &#x3D; 0。</p><p>最后，我们可以通过递推得到 f(n, k) 的值，即为最后的胜者的编号。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findTheWinner(int n, int k) &#123;        int ans &#x3D; 0;  &#x2F;&#x2F; 最后胜者的编号        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;  &#x2F;&#x2F; 从第二个人开始进行游戏            ans &#x3D; (ans + k) % i;  &#x2F;&#x2F; 计算本轮淘汰的人的编号        &#125;        return ans + 1;  &#x2F;&#x2F; 将编号从 0-based 转换为 1-based 并返回    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;共有 &lt;code&gt;n&lt;/code&gt; 名小伙伴一起做游戏。小伙伴们围成一圈，按 &lt;strong&gt;顺时针顺序&lt;/strong&gt; 从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 编号。确切地说，从第 &lt;code&gt;i&lt;/code&gt; 名小伙伴顺时针移动一位会到达第 &lt;code&gt;(i+1)&lt;/code&gt; 名小伙伴的位置，其中 &lt;code&gt;1 &amp;lt;= i &amp;lt; n&lt;/code&gt; ，从第 &lt;code&gt;n&lt;/code&gt; 名小伙伴顺时针移动一位会回到第 &lt;code&gt;1&lt;/code&gt; 名小伙伴的位置。&lt;/p&gt;
&lt;p&gt;游戏遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第 &lt;code&gt;1&lt;/code&gt; 名小伙伴所在位置 &lt;strong&gt;开始&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;沿着顺时针方向数 &lt;code&gt;k&lt;/code&gt; 名小伙伴，计数时需要 &lt;strong&gt;包含&lt;/strong&gt; 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。&lt;/li&gt;
&lt;li&gt;你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。&lt;/li&gt;
&lt;li&gt;如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 &lt;strong&gt;顺时针下一位&lt;/strong&gt; 小伙伴 &lt;strong&gt;开始&lt;/strong&gt;，回到步骤 &lt;code&gt;2&lt;/code&gt; 继续执行。&lt;/li&gt;
&lt;li&gt;否则，圈子中最后一名小伙伴赢得游戏。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给你参与游戏的小伙伴总数 &lt;code&gt;n&lt;/code&gt; ，和一个整数 &lt;code&gt;k&lt;/code&gt; ，返回游戏的获胜者。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode231.2的幂</title>
    <link href="2023/04/17/leetcode231-2%E7%9A%84%E5%B9%82/"/>
    <id>2023/04/17/leetcode231-2%E7%9A%84%E5%B9%82/</id>
    <published>2023-04-17T01:09:01.000Z</published>
    <updated>2023-04-17T01:33:35.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>x</code> 使得 $n &#x3D;&#x3D; 2^x$ ，则认为 <code>n</code> 是 2 的幂次方。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：true解释：20 &#x3D; 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 16输出：true解释：24 &#x3D; 16</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：false</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：true</code></pre><p><strong>示例 5：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：false</code></pre><p><strong>提示：</strong></p><ul><li>$-2{31} &lt;&#x3D; n &lt;&#x3D; 2^{31} - 1$</li></ul><p><strong>进阶：</strong>你能够不使用循环&#x2F;递归解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归</li></ol><p>直接递归就好，注意n为0的情况</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        if (n &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; 如果n为1 直接返回true        if (n % 2 !&#x3D; 0 || n &#x3D;&#x3D; 0) return false; &#x2F;&#x2F; 如果n无法被2除尽，或者n为0，则直接返回false        return isPowerOfTwo(n &#x2F; 2); &#x2F;&#x2F; 否则返回递归的调用函数后的返回值    &#125;&#125;;</code></pre><ol start="2"><li>循环</li></ol><p>直接循环就行，简单易懂</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        while (n &gt;&#x3D; 2) &#123;            if (n % 2 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 2;            else return false; &#x2F;&#x2F; 如果n无法被2除尽，则直接返回false        &#125;        if (n &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; 如果n为1 直接返回true        return false;    &#125;&#125;;</code></pre><ol start="3"><li>使用位与运算符和掩码</li></ol><p>在这个题里面只需要检测n为正数且n的二进制里面只有一个1存在即可;</p><p>首先，我们检查n是否为正整数，这可以通过检查n是否大于0来实现。然后，我们需要检查n的二进制表示中只有一个1。如果我们将n减去1，那么所有在原来的二进制表示中为1的位都会变成0，而它后面的所有位都会变成1。例如，如果n的二进制表示为10000，那么n-1的二进制表示为01111。如果我们将n和n-1进行位与运算，结果将为0。因为n的二进制表示中只有一个1，所以n-1的二进制表示中所有的1都位于n的二进制表示中的0的位置上，因此它们不会在位与运算中重叠。如果n的二进制表示中有多个1，则n-1的二进制表示中将有一个以上的1与n的二进制表示中的1重叠，这样位与运算的结果将不为0。</p><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        return ((n &gt; 0) &amp;&amp; (n &amp; (n - 1)) &#x3D;&#x3D; 0); &#x2F;&#x2F; 检查n是否为正数，且n的二进制表示只有一个1    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;，请你判断该整数是否是 2 的幂次方。如果是，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果存在一个整数 &lt;code&gt;x&lt;/code&gt; 使得 $n &amp;#x3D;&amp;#x3D; 2^x$ ，则认为 &lt;code&gt;n&lt;/code&gt; 是 2 的幂次方。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode342.4的幂</title>
    <link href="2023/04/16/leetcode342-4%E7%9A%84%E5%B9%82/"/>
    <id>2023/04/16/leetcode342-4%E7%9A%84%E5%B9%82/</id>
    <published>2023-04-16T07:35:33.000Z</published>
    <updated>2023-04-17T01:29:58.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 4 的幂次方需满足：存在整数 <code>x</code> 使得 $n &#x3D;&#x3D; 4^x$</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 16输出：true</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：true</code></pre><p><strong>提示：</strong></p><ul><li>$-2^{31} &lt;&#x3D; n &lt;&#x3D; 2^{31} - 1$</li></ul><p><strong>进阶：</strong>你能不使用循环或者递归来完成本题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>循环</li></ol><p>直接使用循环进行<code>n/=4</code>的操作,到最后n小于3时根据n是否为1来判断原本的n是否为4的幂次</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfFour(int n) &#123;        while(n &gt; 3) &#123;            if (n % 4 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 判断n是否是4的整倍数 （在n大于3的情况下）                n &#x2F;&#x3D; 4;            &#125;            else return false; &#x2F;&#x2F; 如果不是直接返回false        &#125;        if (n &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; &#x2F;&#x3D;操作结束后判断n是否为1 or n本来就为1的时候应该直接返回true        return false;    &#125;&#125;;</code></pre><ol start="2"><li>递归</li></ol><p>如题，直接递归就完事了</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfFour(int n) &#123;        if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 4) return true; &#x2F;&#x2F; 返回true的条件        else if (n &gt; 4) &#123;            if (n % 4 !&#x3D; 0) return false; &#x2F;&#x2F; 余数不为0 直接返回false            else return isPowerOfFour(n &#x2F; 4); &#x2F;&#x2F; 通过递归完成对n的更新        &#125;        return false;     &#125;&#125;;</code></pre><ol start="3"><li>使用位与运算符和掩码</li></ol><p>首先，我们需要检查n是否为正数，并且它的二进制表示中只有一个1。这是因为4的幂次方的二进制表示中只有一个1。因此，如果n不是正数或者它的二进制表示中有多个1，则它不是4的幂。</p><p>其次，我们需要使用位运算来检查n是否为4的幂。我们可以使用位与运算符（&amp;）和一个掩码来完成此操作。掩码是一个32位整数，它的二进制表示中只有偶数位为1，奇数位为0。如果n是4的幂，则它的二进制表示中的1只能在偶数位上出现。因此，如果我们将n与掩码进行位与运算，结果应该等于n本身。</p><p>最终，如果n既是正数且只有一个1，又是4的幂，则函数返回true；否则，返回false。</p><p>详细的说，当你看到一个整数n时，你需要确定它是否是4的幂次方。一个正整数n是4的幂次方，当且仅当它满足以下两个条件：</p><ol><li>n是正整数，并且它的二进制表示中只有一个1，例如1、4、16等；</li><li>n可以表示为$4^k$的形式，其中k是一个非负整数。</li></ol><p>因此，我们需要找到一种方法来检查n是否满足这两个条件。在不使用循环或递归的前提下，我们可以使用位运算来实现这个目标。</p><p>首先，我们检查n是否为正整数，这可以通过检查n是否大于0来实现。然后，我们需要检查n的二进制表示中只有一个1。如果我们将n减去1，那么所有在原来的二进制表示中为1的位都会变成0，而它后面的所有位都会变成1。例如，如果n的二进制表示为10000，那么n-1的二进制表示为01111。如果我们将n和n-1进行位与运算，结果将为0。因为n的二进制表示中只有一个1，所以n-1的二进制表示中所有的1都位于n的二进制表示中的0的位置上，因此它们不会在位与运算中重叠。如果n的二进制表示中有多个1，则n-1的二进制表示中将有一个以上的1与n的二进制表示中的1重叠，这样位与运算的结果将不为0。</p><p>接下来，我们需要使用位运算来检查n是否可以表示为4的幂。我们知道，4的幂的二进制表示中的1只能出现在偶数位上，例如100、10000、1000000等。因此，我们可以使用一个掩码来将所有奇数位上的位设置为0，而偶数位上的位设置为1。这个掩码可以是0x55555555，它的二进制表示为01010101010101010101010101010101。如果我们将n与这个掩码进行位与运算，结果将为n本身，如果n不能表示为4的幂，则结果将不为n本身。</p><p>最后，如果n既是正整数且只有一个1，又是4的幂，则函数返回true，否则返回false。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfFour(int n) &#123;        &#x2F;&#x2F; 检查n是否为正数，且n的二进制表示只有一个1，且n是否为4的幂        return (n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) &#x3D;&#x3D; 0) &amp;&amp; ((n &amp; 0x55555555) &#x3D;&#x3D; n);     &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;整数 &lt;code&gt;n&lt;/code&gt; 是 4 的幂次方需满足：存在整数 &lt;code&gt;x&lt;/code&gt; 使得 $n &amp;#x3D;&amp;#x3D; 4^x$&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode72.编辑距离</title>
    <link href="2023/04/13/leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>2023/04/13/leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2023-04-13T12:06:19.000Z</published>
    <updated>2023-04-13T12:19:59.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这道题要求我们找到从 word1 转换到 word2 所需要的最小操作数，其中每个操作都是插入、删除或替换一个字符。这道题可以使用动态规划来解决。我们可以定义一个 dp 数组，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数。</p><p>当 i &#x3D; 0 时，表示 word1 为空，这时要将 word1 转换为 word2 的前 j 个字符，所以最小操作数就是 j。同样地，当 j &#x3D; 0 时，表示 word2 为空，这时要将 word1 转换为空字符串，所以最小操作数就是 i。</p><p>对于任意的 i 和 j，有以下两种情况：</p><ol><li>当 <code>word1[i-1] == word2[j-1] </code>时，不需要进行任何操作，所以 <code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>当 <code>word1[i-1] != word2[j-1] </code>时，有三种操作可以选择，分别为：<ol><li>在 word1 的第 i 个字符后面插入一个和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i][j-1] + 1</code>。</li><li>删除 word1 的第 i 个字符，这样就可以让 word1 的前 i-1 个字符和 word2 的前 j 个字符相等。操作数为<code> dp[i-1][j] + 1</code>。</li><li>将 word1 的第 i 个字符替换成和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i-1][j-1] + 1</code>。</li></ol></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minDistance(string word1, string word2) &#123;        int m &#x3D; word1.size();  &#x2F;&#x2F; 获取 word1 的长度        int n &#x3D; word2.size();  &#x2F;&#x2F; 获取 word2 的长度        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1));  &#x2F;&#x2F; 定义一个二维数组 dp，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 当 word2 为空字符串时，需要将 word1 转换为空字符串，所以最小操作数为 i            dp[i][0] &#x3D; i;        &#125;        for (int j &#x3D; 0; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 当 word1 为空字符串时，需要将 word1 转换为 word2 的前 j 个字符，所以最小操作数为 j            dp[0][j] &#x3D; j;        &#125;        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 从 word1 的第一个字符开始遍历            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 从 word2 的第一个字符开始遍历                if (word1[i-1] &#x3D;&#x3D; word2[j-1]) &#123;  &#x2F;&#x2F; 如果 word1 的第 i 个字符和 word2 的第 j 个字符相等，不需要进行任何操作                    dp[i][j] &#x3D; dp[i-1][j-1];                &#125; else &#123;  &#x2F;&#x2F; 否则，有三种操作可以选择                    dp[i][j] &#x3D; min(dp[i][j-1], min(dp[i-1][j], dp[i-1][j-1])) + 1;  &#x2F;&#x2F; 分别为插入、删除和替换一个字符，选择操作数最小的那个                &#125;            &#125;        &#125;        return dp[m][n];  &#x2F;&#x2F; 返回最小操作数    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个单词 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt;， &lt;em&gt;请返回将 &lt;code&gt;word1&lt;/code&gt; 转换成 &lt;code&gt;word2&lt;/code&gt; 所使用的最少操作数&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入一个字符&lt;/li&gt;
&lt;li&gt;删除一个字符&lt;/li&gt;
&lt;li&gt;替换一个字符&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode63.不同路径II</title>
    <link href="2023/04/12/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>2023/04/12/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</id>
    <published>2023-04-12T01:18:23.000Z</published>
    <updated>2023-04-12T01:21:48.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/robot1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/robot2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：obstacleGrid &#x3D; [[0,1],[0,0]]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道典型的动态规划问题。定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p><p>在定义dp数组时，需要特别注意：如果某个格子为障碍物，则不能通过该格子，路径数为0；如果第一列某个格子为障碍物，则其下方的所有格子均无法到达，路径数为0；如果第一行某个格子为障碍物，则其右方的所有格子均无法到达，路径数为0。</p><p>在状态转移方程中，如果某个格子为障碍物，则其路径数为0；否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p><p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int m &#x3D; obstacleGrid.size();        int n &#x3D; obstacleGrid[0].size();        &#x2F;&#x2F; 定义二维数组dp        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));        &#x2F;&#x2F; 初始化第一列        for (int i &#x3D; 0; i &lt; m; i++) &#123;            if (obstacleGrid[i][0] &#x3D;&#x3D; 1) &#123;                break;            &#125;            dp[i][0] &#x3D; 1;        &#125;        &#x2F;&#x2F; 初始化第一行        for (int j &#x3D; 0; j &lt; n; j++) &#123;            if (obstacleGrid[0][j] &#x3D;&#x3D; 1) &#123;                break;            &#125;            dp[0][j] &#x3D; 1;        &#125;        &#x2F;&#x2F; 对于其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和        for (int i &#x3D; 1; i &lt; m; i++) &#123;            for (int j &#x3D; 1; j &lt; n; j++) &#123;                if (obstacleGrid[i][j] &#x3D;&#x3D; 1) &#123;  &#x2F;&#x2F; 如果当前格子为障碍物，则不可到达，路径数为0                    dp[i][j] &#x3D; 0;                &#125; else &#123;  &#x2F;&#x2F; 否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达                    dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];                &#125;            &#125;        &#125;        &#x2F;&#x2F; 返回右下角格子的不同路径数目        return dp[m-1][n-1];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;网格中的障碍物和空位置分别用 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt; 来表示。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode62.不同路径</title>
    <link href="2023/04/12/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>2023/04/12/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2023-04-12T00:57:03.000Z</published>
    <updated>2023-04-12T01:21:20.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/robot_maze.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 7输出：28</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 7, n &#x3D; 3输出：28</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 3输出：6</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道比较典型的动态规划问题。我们定义一个二维数组<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p><p>根据题目要求，从第一行第一列出发只能向下或向右移动一步，因此<code>dp[0][j]</code>和<code>dp[i][0]</code>的值都为1。</p><p>对于其他的格子，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p><p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        &#x2F;&#x2F; 定义二维数组dp        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));        &#x2F;&#x2F; 对于除第一行第一列外的其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和        for (int i &#x3D; 1; i &lt; m; i++) &#123;            for (int j &#x3D; 1; j &lt; n; j++) &#123;                dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];            &#125;        &#125;        &#x2F;&#x2F; 返回右下角格子的不同路径数目        return dp[m-1][n-1];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode746.使用最小花费爬楼梯</title>
    <link href="2023/04/10/leetcode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>2023/04/10/leetcode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2023-04-10T07:44:23.000Z</published>
    <updated>2023-04-10T07:57:11.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：cost &#x3D; [10,15,20]输出：15解释：你将从下标为 1 的台阶开始。- 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：cost &#x3D; [1,100,1,1,1,100,1,1,100,1]输出：6解释：你将从下标为 0 的台阶开始。- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。- 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>因为上台阶可以一次1阶或者一次2阶，因此定义一个dp数组，长度为cost的大小+1，dp[i]表示到达第n个台阶需要的最小费用。因此<code>dp[i]</code>的更新公式为:</p><p>$dp[i] &#x3D; min(dp[i-1] + cost[i - 1], dp[i - 2] + cost[i - 2])$</p><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;        int len &#x3D; cost.size(); &#x2F;&#x2F; 获取cost的大小（总的台阶数）        vector&lt;int&gt; dp(len + 1); &#x2F;&#x2F; 定义一个dp数组，长度为cost的大小+1 dp[i]表示到达第n个台阶需要的最小费用。        dp[0] &#x3D; 0, dp[1] &#x3D; 0; &#x2F;&#x2F; 因为可以从下标为0或者1的台阶出发，因此dp[0]和dp[1]都初始化为0；        for (int i &#x3D; 2; i &lt; len + 1;i++) &#123;            dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); &#x2F;&#x2F; dp[i]的更新公式        &#125;        return dp[len]; &#x2F;&#x2F; 返回到达第n个台阶（也就是最后一个台阶）的最小费用。    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;cost&lt;/code&gt; ，其中 &lt;code&gt;cost[i]&lt;/code&gt; 是从楼梯第 &lt;code&gt;i&lt;/code&gt; 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。&lt;/p&gt;
&lt;p&gt;你可以选择从下标为 &lt;code&gt;0&lt;/code&gt; 或下标为 &lt;code&gt;1&lt;/code&gt; 的台阶开始爬楼梯。&lt;/p&gt;
&lt;p&gt;请你计算并返回达到楼梯顶部的最低花费。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode509.斐波那契数</title>
    <link href="2023/04/09/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>2023/04/09/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2023-04-09T06:41:47.000Z</published>
    <updated>2023-04-09T07:17:20.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre class="language-none"><code class="language-none">F(0) &#x3D; 0，F(1) &#x3D; 1F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</code></pre><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：1解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：2解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：3解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归求解</li></ol><p>在递归函数里初始化<code>f(0) = 0,f(1) = 1</code>,对于大于1的函数值，递归调用<code>f(n - 2) + f(n - 1)</code>;</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; f(0)的初始化        if (n &#x3D;&#x3D; 1) return 1; &#x2F;&#x2F; f(1)的初始化        return fib(n - 1) + fib(n - 2); &#x2F;&#x2F; 递归调用    &#125;&#125;;</code></pre><ol start="2"><li>迭代求解</li></ol><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        if (n &lt;&#x3D; 1) return n; &#x2F;&#x2F; 如果n为0或者1 直接返回它本身        int pre0 &#x3D; 0, pre1 &#x3D; 1; &#x2F;&#x2F; 初始化pre0和pre1        int answer &#x3D; 0; &#x2F;&#x2F; 初始化答案        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;            answer &#x3D; pre0 + pre1; &#x2F;&#x2F; 答案为f(n-2) + f(n-1)            pre0 &#x3D; pre1; &#x2F;&#x2F; pre0的值更新            pre1 &#x3D; answer; &#x2F;&#x2F; pre1的值更新        &#125;        return answer; &#x2F;&#x2F; 计算完毕返回答案    &#125;&#125;;</code></pre><ol start="3"><li>矩阵快速幂求解</li></ol><p>核心思路是将斐波那契数列的递推式转化为矩阵的乘法，然后使用矩阵快速幂的方法快速计算出矩阵的幂次，进而得到第 n 个斐波那契数。</p><p>首先，我们知道斐波那契数列的递推式为：</p><p>$F(n) &#x3D; F(n-1) + F(n-2)，其中 F(0) &#x3D; 0，F(1) &#x3D; 1。$</p><p>我们可以将这个递推式转化为矩阵的乘法形式：</p><p>$ \begin{bmatrix} F(n) \ F(n-1) \end{bmatrix} &#x3D; \begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} F(n-1) \ F(n-2) \end{bmatrix} $</p><p>根据这个式子，我们可以构造出初始矩阵 base 和单位矩阵 res，然后使用矩阵快速幂的方法快速计算出 base 的 n 次幂，最终得到 res。</p><p>最后，我们可以直接返回<code> res[0][1]</code>，这个值就是第 n 个斐波那契数。</p><p>总的来说，这种解法虽然比较高级，但可以在 O(log n) 的时间复杂度内计算出第 n 个斐波那契数，而且不需要使用数组或者递归来存储之前的结果，空间复杂度为 O(1)。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        &#x2F;&#x2F; 如果n小于等于1，直接返回n        if (n &lt;&#x3D; 1) &#123;            return n;        &#125;        &#x2F;&#x2F; 定义初始矩阵        vector&lt;vector&lt;int&gt;&gt; base&#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        &#x2F;&#x2F; 定义单位矩阵        vector&lt;vector&lt;int&gt;&gt; res&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;        &#x2F;&#x2F; 矩阵快速幂        while (n) &#123;            if (n &amp; 1) &#123;                res &#x3D; multiply(res, base);            &#125;            base &#x3D; multiply(base, base);            n &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 将变量 n 的二进制表示向右移动一位，并将移位后的结果赋值给 n。相当于n&#x2F;&#x3D;2        &#125;        &#x2F;&#x2F; 返回结果        return res[0][1];    &#125;    &#x2F;&#x2F; 定义矩阵乘法函数    vector&lt;vector&lt;int&gt;&gt; multiply(const vector&lt;vector&lt;int&gt;&gt;&amp; A, const vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123;        int m &#x3D; A.size(), n &#x3D; A[0].size(), l &#x3D; B[0].size();        vector&lt;vector&lt;int&gt;&gt; C(m, vector&lt;int&gt;(l));        for (int i &#x3D; 0; i &lt; m; ++i) &#123;            for (int j &#x3D; 0; j &lt; l; ++j) &#123;                for (int k &#x3D; 0; k &lt; n; ++k) &#123;                    C[i][j] +&#x3D; A[i][k] * B[k][j];                &#125;            &#125;        &#125;        return C;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt; （通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示）形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;pre class=&quot;language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;F(0) &amp;#x3D; 0，F(1) &amp;#x3D; 1
F(n) &amp;#x3D; F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-青蛙过河</title>
    <link href="2023/04/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
    <id>2023/04/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</id>
    <published>2023-04-06T12:23:29.000Z</published>
    <updated>2023-04-06T13:05:44.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里 的石头跳到对岸。</p><p>河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度, 每次小青蛙从一块石头起跳, 这块石头的高度就 会下降 1 , 当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的)。</p><p>小青蛙一共需要去学校上 $x$ 天课, 所以它需要往返 $2x$次。当小青蛙具有 一个跳跃能力 $y$ 时, 它能跳不超过 $y$的距离。</p><p>请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。</p><span id="more"></span><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含两个整数$n,x$, 分别表示河的宽度和小青蛙需要去学校 的天数。请注意$2x$ 才是实际过河的次数。</p><p>第二行包含 $n−1$ 个非负整数$H_1,H_2,⋯,H_{n−1}$, 其中 $H_i$&gt;0 表示在河中与小青蛙的家相距 $i$的地方有一块高度为 $H_i$ 的石头,$H_i&#x3D;0$ 表示这个位置没有石头。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行, 包含一个整数, 表示小青蛙需要的最低跳跃能力。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="language-txt" data-language="txt"><code class="language-txt">5 11 0 1 0</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="language-text" data-language="text"><code class="language-text">4</code></pre><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>由于只有两块高度为 1 的石头，所以往返只能各用一块。第 1 块石头和对岸的距离为 4，如果小青蛙的跳跃能力为 3 则无法满足要求。所以小青蛙最少需要 4 的跳跃能力。</p><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 30% 的评测用例, $n≤100$;</p><p>对于 60% 的评测用例, $n≤1000$;</p><p>对于所有评测用例, $1≤n≤10^5,1≤x≤10^9,1≤H_i≤10^4 $。</p><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 512M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>常规思路</li></ul><p>一只青蛙上x次课，来回走了2x次；相当于2x只青蛙上了一次课（只走一段）；每次踩石头它的高度都下降1，而且青蛙都能过河。所以可以先求前缀和之后二分法进行贪心的求解，代码的思路如下：</p><ol><li>定义数组的最大长度N，整型数字n,m，数组a用于接收输入，数组b用于计算前缀和;</li><li>得到n，m和数组a之后，定义数组<code>a[0] = a[n] = N</code>,然后进行计算前缀和的操作。例如前缀和<code>b[i]=x</code>的意思就是i之前的石头一共可以容纳x个青蛙跳过(我们一共需要2m)个;</li><li>进行二分+贪心操作，求出最小的跳跃能力值。</li><li>check函数用于计算在x的下标下，石头是否能让2m个青蛙通过。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int N &#x3D; 1e5 + 3;ll a[N],b[N];int n, m;bool check(int x) &#123;    for(int i &#x3D; 1; i + x - 1 &lt; n ;i++) &#123;        &#x2F;&#x2F; 只有一个的时候        if (b[i + x - 1] - b[i - 1] &lt; 2 * m) &#123;            &#x2F;&#x2F; 石块为0的情况            return false;        &#125;    &#125;    return true;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt; n; i++) &#123;        &#x2F;&#x2F; 循环到n-1        cin &gt;&gt; a[i];    &#125;    a[0] &#x3D; a[n] &#x3D; N;    for (int i &#x3D; 1; i &lt; n; i++) &#123;        &#x2F;&#x2F; 计算前缀和        b[i] &#x3D; b[i - 1] + a[i]; &#x2F;&#x2F; 我能让几只小青蛙在上面    &#125;    &#x2F;&#x2F; 贪心求y    int l &#x3D; 1, r &#x3D; N;    while (l &lt; r)&#123;        int mid &#x3D; (l + r) &#x2F; 2;        if (check(mid)) &#123; &#x2F;&#x2F; 石头足够青蛙分，继续贪心            r &#x3D; mid;        &#125;        else &#123; &#x2F;&#x2F; 石头不够青蛙分            l &#x3D; mid + 1;        &#125;    &#125;    cout &lt;&lt; l;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里 的石头跳到对岸。&lt;/p&gt;
&lt;p&gt;河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度, 每次小青蛙从一块石头起跳, 这块石头的高度就 会下降 1 , 当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的)。&lt;/p&gt;
&lt;p&gt;小青蛙一共需要去学校上 $x$ 天课, 所以它需要往返 $2x$次。当小青蛙具有 一个跳跃能力 $y$ 时, 它能跳不超过 $y$的距离。&lt;/p&gt;
&lt;p&gt;请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-回文日期</title>
    <link href="2023/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F/"/>
    <id>2023/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F/</id>
    <published>2023-04-05T08:01:19.000Z</published>
    <updated>2023-04-05T09:59:30.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。</p><p>有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。</p><p>也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。</p><p>给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。</p><span id="more"></span><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入包含一个八位整数 <em>N</em>，表示日期。</p><p>对于所有评测用例，10000101≤N≤89991231，保证 N 是一个合法日期的 8 位数表示。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出两行，每行 1 个八位数。第一行表示下一个回文日期，第二行表示下一个 ABABBABA 型的回文日期。</p><p><strong>输入输出样例</strong></p><p><strong>示例</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">20200202</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">2021120221211212</code></pre><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>（1）定义每个月的天数</li><li>（2）计算年份</li><li>（3）计算月份</li><li>（4）计算第几天</li><li>（5）判断是不是闰年</li><li>（6）闰年二月天数为29</li><li>（7）非闰年二月天数为28</li><li>（8）判断是不是符合日期标准</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;bool isleap(int year)&#123;    return ((year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)||year%400&#x3D;&#x3D;0); &#x2F;&#x2F; 判断是否是闰年&#125;bool legal(int n) &#x2F;&#x2F; 判断8位数是否是合规的日期&#123;    int year,month,day;    year&#x3D;n&#x2F;10000; &#x2F;&#x2F; 获取年月日的值    month&#x3D;(n%10000)&#x2F;100;    day&#x3D;n%100;    if(month&gt;12 || month&#x3D;&#x3D;0 || day&#x3D;&#x3D;0 || day&gt;31) &#x2F;&#x2F; 进行年月日的判断    return false;    if(month&#x3D;&#x3D;2) &#x2F;&#x2F; 2月针对闰年平年单独判断    &#123;        if(isleap(year)&#x3D;&#x3D;0&amp;&amp;day&gt;28)        return false;        if(isleap(year)&#x3D;&#x3D;1&amp;&amp;day&gt;29)        return false;    &#125;    if(month&#x3D;&#x3D;1||month&#x3D;&#x3D;3||month&#x3D;&#x3D;5||month&#x3D;&#x3D;7||month&#x3D;&#x3D;8||month&#x3D;&#x3D;10||month||12)    &#123;        if(day&gt;31)        return false;    &#125;    if(month&#x3D;&#x3D;4||month&#x3D;&#x3D;6||month&#x3D;&#x3D;9||month&#x3D;&#x3D;11)    &#123;        if(day&gt;30)        return false;    &#125;    return true;&#125;int main()&#123;    int n;    cin&gt;&gt;n; &#x2F;&#x2F; 获取输入    int flag&#x3D;0; &#x2F;&#x2F; 设置判断    for(int i&#x3D;n+1;i&lt;&#x3D;100000000;i++)    &#123;        int a1,a2,a3,a4,a5,a6,a7,a8; &#x2F;&#x2F; 用最笨的办法获取每一位的值        a8&#x3D;i&#x2F;10000000;        a7&#x3D;(i&#x2F;1000000)%10;        a6&#x3D;(i&#x2F;100000)%10;        a5&#x3D;(i&#x2F;10000)%10;        a4&#x3D;(i&#x2F;1000)%10;        a3&#x3D;(i&#x2F;100)%10;        a2&#x3D;(i&#x2F;10)%10;        a1&#x3D;i%10;        if(legal(i)&amp;&amp;flag&#x3D;&#x3D;0&amp;&amp;a1&#x3D;&#x3D;a8&amp;&amp;a2&#x3D;&#x3D;a7&amp;&amp;a3&#x3D;&#x3D;a6&amp;&amp;a4&#x3D;&#x3D;a5) &#x2F;&#x2F; 判断是否是普通回文日期        &#123;            cout&lt;&lt;i&lt;&lt;endl;            flag&#x3D;1;        &#125;        if(legal(i)&amp;&amp;a1&#x3D;&#x3D;a3&amp;&amp;a3&#x3D;&#x3D;a6&amp;&amp;a6&#x3D;&#x3D;a8&amp;&amp;a2&#x3D;&#x3D;a4&amp;&amp;a4&#x3D;&#x3D;a5&amp;&amp;a5&#x3D;&#x3D;a7) &#x2F;&#x2F; 判断是否是ABABBABA型回文日期        &#123;            cout&lt;&lt;i;            break;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。&lt;/p&gt;
&lt;p&gt;有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。&lt;/p&gt;
&lt;p&gt;也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。&lt;/p&gt;
&lt;p&gt;给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
</feed>
