<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-12-11T13:28:00.465Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode1047.删除字符串中的所有相邻重复项</title>
    <link href="2023/12/11/leetcode1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>2023/12/11/leetcode1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2023-12-11T13:16:29.000Z</published>
    <updated>2023-12-11T13:28:00.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p> <span id="more"></span><p><strong>示例：</strong></p><pre class="language-none"><code class="language-none">输入：&quot;abbaca&quot;输出：&quot;ca&quot;解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 20000</code></li><li><code>S</code> 仅由小写英文字母组成。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用栈</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string removeDuplicates(string S) &#123;        stack&lt;char&gt; charStack;  &#x2F;&#x2F; 使用栈来存储字符        for (char c : S) &#123;            &#x2F;&#x2F; 如果栈不为空且栈顶字符与当前字符相同，则移除栈顶字符            if (!charStack.empty() &amp;&amp; charStack.top() &#x3D;&#x3D; c) &#123;                charStack.pop();            &#125; else &#123;                &#x2F;&#x2F; 否则，将当前字符压入栈                charStack.push(c);            &#125;        &#125;        &#x2F;&#x2F; 将栈中字符组合成最终的结果字符串        string result &#x3D; &quot;&quot;;        while (!charStack.empty()) &#123;            result &#x3D; charStack.top() + result;            charStack.pop();        &#125;        return result;    &#125;&#125;;</code></pre><ol start="2"><li>快慢指针</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string removeDuplicates(string S) &#123;        int slow &#x3D; 0; &#x2F;&#x2F; 慢指针，指向当前处理的位置        for (int fast &#x3D; 0; fast &lt; S.size(); ++fast) &#123;            &#x2F;&#x2F; 如果慢指针不为零，且当前字符与慢指针前一个字符相同，表示发现相邻重复            if (slow !&#x3D; 0 &amp;&amp; S[fast] &#x3D;&#x3D; S[slow - 1]) &#123;                slow--;            &#125; else &#123;                &#x2F;&#x2F; 否则，将当前字符加入到慢指针指向的位置                S[slow++] &#x3D; S[fast];            &#125;        &#125;        &#x2F;&#x2F; 截断字符串，保留有效部分        return S.substr(0, slow);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给出由小写字母组成的字符串 &lt;code&gt;S&lt;/code&gt;，&lt;strong&gt;重复项删除操作&lt;/strong&gt;会选择两个相邻且相同的字母，并删除它们。&lt;/p&gt;
&lt;p&gt;在 S 上反复执行重复项删除操作，直到无法继续删除。&lt;/p&gt;
&lt;p&gt;在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>在机器人网络云系统中使用复制的静态算法调度</title>
    <link href="2023/11/14/%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%BD%91%E7%BB%9C%E4%BA%91%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E7%9A%84%E9%9D%99%E6%80%81%E7%AE%97%E6%B3%95%E8%B0%83%E5%BA%A6/"/>
    <id>2023/11/14/%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%BD%91%E7%BB%9C%E4%BA%91%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E7%9A%84%E9%9D%99%E6%80%81%E7%AE%97%E6%B3%95%E8%B0%83%E5%BA%A6/</id>
    <published>2023-11-14T09:57:51.000Z</published>
    <updated>2023-11-20T08:04:58.268Z</updated>
    
    <content type="html"><![CDATA[<p>题目：Static Algorithm Allocation With Duplication in Robotic Network Cloud Systems</p><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>机器人网络可用于完成超出单个机器人能力的任务。在机器人网络中，机器人可以协同工作来完成共同的任务。云机器人技术使机器人能够受益于云的海量存储和计算能力。以往的研究主要集中在通过提前了解资源分配来最小化机器人检索资源的成本。在多个节点上复制算法可以减少执行任务所需的总时间。<strong>我们解决了应该复制哪些算法以及应该将副本放置在哪里以提高整体性能的问题。</strong>我们开发了一个程序来回答机器人网络云系统应该执行哪些算法以及是否应该重复这些算法以在所有机器人的总体任务执行时间方面实现最佳性能。我们提出的复制程序是最佳的，因为复制算法的数量最少，而结果为所有机器人提供了最短的总体完成时间。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>为了克服单一机器人能力的限制，通常使用多个机器人共同工作去完成任务。但如果只靠增加机器人数量的方式去增加机器人网络的能力会导致模型的复杂度提升以及系统的花费增加。云机器人是一种克服计算力以及机器人的性能限制的方式。</p><p>为了达到基于云的机器人系统的最优表现，我们需要去解决调度问题。这个问题涉及决定是否应将新到达的任务上传到云、在其中一个机器人上执行（边缘计算[14]）或在服务器上处理（雾计算[15]）。云机器人系统执行任务是通过执行、收集和组合几个称为算法的基本任务的结果来实现的。在机器人执行一项任务之前，该任务所需的所有算法都应该可用，并分配给系统的至少一个处理单元。当机器人被分配任务时，机器人请求与该任务相对应的算法的输出。我们的<strong>目标</strong>是确定应该将算法分配到哪里，以便无论哪个机器人正在执行任务，它都能在尽可能短的时间内检索算法所需的所有输出。</p><p>分配给多个处理器的算法称为重复算法。由于算法是相互依赖的，因此复制算法的输出更容易被分配到其后继算法的其他处理器使用。下面用一个例子来更好的说明算法重复的重要性。</p><p>云机器人的架构如图2所示。假设我们有一个只需要单个算法输出的任务。给定算法的输出，任务可以由任何边缘节点执行。假设该算法可以在每个边缘节点、雾节点和云节点上执行，平均执行时间分别为3秒、0.5秒和0.1秒。如果不考虑算法的重复，由于我们不知道哪个边缘节点发起执行任务的请求，因此可以通过静态算法分配来实现系统的最优性能[30]。结果是将算法分配给雾节点，其中边缘节点E1、E2和E3完成任务的平均时间分别为4.5、2.5和2.5秒。如果允许我们复制算法，则在边缘节点 E1 上复制算法会将边缘节点 E1 的平均任务完成时间减少到 3 秒。因此，以最小总时间完成任务的最优方案是将算法分配给雾节点F并在边缘节点E1上复制一次。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目：Static Algorithm Allocation With Duplication in Robotic Network Cloud Systems&lt;/p&gt;</summary>
    
    
    
    
    <category term="资源调度" scheme="tags/资源调度/"/>
    
    <category term="云机器人" scheme="tags/云机器人/"/>
    
  </entry>
  
  <entry>
    <title>多智能体云机器人的资源调度和服务提供的综述</title>
    <link href="2023/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%BC%E8%BF%B0/"/>
    <id>2023/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%BC%E8%BF%B0/</id>
    <published>2023-11-12T12:46:10.000Z</published>
    <updated>2023-11-14T09:54:00.504Z</updated>
    
    <content type="html"><![CDATA[<p>原题目：Resource Allocation and Service Provisioning in Multi-Agent Cloud Robotics: A Comprehensive Survey</p><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Abstract—Robotic applications nowadays are widely adopted to enhance operational automation and performance of real-world CyberPhysical Systems (CPSs) including Industry 4.0, agriculture, healthcare, and disaster management. These applications are composed of latency-sensitive, data-heavy, and compute-intensive tasks. The robots, however, are constrained in the computational power and storage capacity. The concept of multi-agent cloud robotics enables robotto-robot cooperation and creates a complementary environment for the robots in executing large-scale applications with the capability to utilize the edge and cloud resources. However, in such a collaborative environment, the optimal resource allocation for robotic tasks is challenging to achieve. Heterogeneous energy consumption rates and application of execution costs associated with the robots and computing instances make it even more complex. In addition, the data transmission delay between local robots, edge nodes, and cloud data centres adversely affects the real-time interactions and impedes service performance guarantee. Taking all these issues into account, this paper comprehensively surveys the state-of-the-art on resource allocation and service provisioning in multi-agent cloud robotics. The paper presents the application domains of multi-agent cloud robotics through explicit comparison with the contemporary computing paradigms and identifies the specific research challenges. A complete taxonomy on resource allocation is presented for the first time, together with the discussion of resource pooling, computation offloading, and task scheduling for efficient service provisioning. Furthermore, we highlight the research gaps from the learned lessons, and present future directions deemed beneficial to further advance this emerging field.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在多信息物理系统的条件下，多智能体云机器人可以带来以下优点：</p><ul><li>通过利用不同基础设施级别的计算资源，它为 CPS 提供执行各种机器人应用程序的选项。</li><li>它提供了一种抽象，可以根据计算基础设施的特征对机器人应用程序的任务进行分类。</li><li>它提供分布式资源来处理CPS中生成的大数据，并减少通信延迟。</li><li>它增强了机器人使用本地和边缘网络共享知识的能力，而不是依赖于远程云。</li><li>通过使资源更接近机器人，它显着降低了处理多个设备的 CPS 中的带宽要求（用于将数据发送到云）。</li><li>通过多智能体云机器人技术，CPS 对云数据中心的依赖性以及云数据中心（处理多个 CPS）的负载急剧降低。</li></ul><p><img src="http://cdn.leafii.top/img/image-20231112205735164.png" alt="image-20231112205735164" loading="lazy"></p><h3 id="多智能体云机器人系统和相关的计算范例"><a href="#多智能体云机器人系统和相关的计算范例" class="headerlink" title="多智能体云机器人系统和相关的计算范例"></a>多智能体云机器人系统和相关的计算范例</h3><p>接下来，将多智能体云机器人技术同移动云计算（MCC）和多接入边缘计算（MEC）进行了对比。相较于MCC和MEC，多智能体云机器人技术的网络连接方式更多样，而且支持AI智能决策，这使其更复杂。因此，有效的资源调度很重要，尤其是在这种需求多样的条件下。</p><h3 id="多智能体云机器人系统的资源调度和服务提供的挑战"><a href="#多智能体云机器人系统的资源调度和服务提供的挑战" class="headerlink" title="多智能体云机器人系统的资源调度和服务提供的挑战"></a>多智能体云机器人系统的资源调度和服务提供的挑战</h3><ul><li>实时学习和自动的动作</li><li>复杂的数据流处理</li><li>动态的机器人合作</li><li>跨基础设施的互操作性</li><li>异步的决策</li><li>按需计算和通信权衡</li><li>系统的特定策略</li><li>能源延迟优化</li><li>综合商业模式</li><li>异构导致的安全问题</li></ul><h3 id="文章的贡献"><a href="#文章的贡献" class="headerlink" title="文章的贡献"></a>文章的贡献</h3><ul><li>在考虑资源类型，表现评价计量，应用结构，服务模型和分发机制的情况下对资源调度进行了分类。</li><li>将用于有效提供服务的资源池化，计算迁移和任务调度的现有方法进行了很好的探索。</li><li>从研究综述中学到的知识进行聚合，并且填补了在多智能体云机器人系统中机器人系统的资源调度和服务提供的gap。</li><li>探索了未来的研究方向。</li></ul><h2 id="多智能体云机器人系统技术进展概述"><a href="#多智能体云机器人系统技术进展概述" class="headerlink" title="多智能体云机器人系统技术进展概述"></a>多智能体云机器人系统技术进展概述</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;原题目：Resource Allocation and Service Provisioning in Multi-Agent Cloud Robotics: A Comprehensive Survey&lt;/p&gt;</summary>
    
    
    
    
    <category term="多智能体" scheme="tags/多智能体/"/>
    
    <category term="资源调度" scheme="tags/资源调度/"/>
    
    <category term="云机器人" scheme="tags/云机器人/"/>
    
    <category term="综述" scheme="tags/综述/"/>
    
  </entry>
  
  <entry>
    <title>一种解决复杂物流网络资源平衡问题的合作多智能体强化学习框架</title>
    <link href="2023/11/12/%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E7%89%A9%E6%B5%81%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%88%E4%BD%9C%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    <id>2023/11/12/%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E7%89%A9%E6%B5%81%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%88%E4%BD%9C%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/</id>
    <published>2023-11-12T12:45:24.000Z</published>
    <updated>2023-11-12T12:48:43.823Z</updated>
    
    <content type="html"><![CDATA[<p>原题目：A Cooperative Multi-Agent Reinforcement Learning Framework for Resource Balancing in Complex Logistics Network</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;原题目：A Cooperative Multi-Agent Reinforcement Learning Framework for Resource Balancing in Complex Logistics Network&lt;/p&gt;</summary>
    
    
    
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
    <category term="多智能体" scheme="tags/多智能体/"/>
    
    <category term="资源调度" scheme="tags/资源调度/"/>
    
    <category term="物流网络" scheme="tags/物流网络/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1447.最简分数</title>
    <link href="2023/11/03/leetcode1447-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/"/>
    <id>2023/11/03/leetcode1447-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/</id>
    <published>2023-11-03T12:21:39.000Z</published>
    <updated>2023-11-03T12:22:35.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 <code>n</code> 的 <strong>最简</strong> 分数 。分数可以以 <strong>任意</strong> 顺序返回。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：[&quot;1&#x2F;2&quot;]解释：&quot;1&#x2F;2&quot; 是唯一一个分母小于等于 2 的最简分数。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：[&quot;1&#x2F;2&quot;,&quot;1&#x2F;3&quot;,&quot;2&#x2F;3&quot;]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：[&quot;1&#x2F;2&quot;,&quot;1&#x2F;3&quot;,&quot;1&#x2F;4&quot;,&quot;2&#x2F;3&quot;,&quot;3&#x2F;4&quot;]解释：&quot;2&#x2F;4&quot; 不是最简分数，因为它可以化简为 &quot;1&#x2F;2&quot; 。</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>利用自己写的最大公约数函数直接求解即可</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int getGCD(int x, int y) &#123;        int z &#x3D; y;        while (x % y !&#x3D; 0) &#123;            z &#x3D; x % y;            x &#x3D; y;            y &#x3D; z;        &#125;        return z;    &#125;    vector&lt;string&gt; simplifiedFractions(int n) &#123;        vector&lt;string&gt; results;        if (n &gt; 1) &#123;            int numerator &#x3D; 1;            int denominator &#x3D; 2;            for (int numerator &#x3D; 1; numerator &lt;&#x3D; n - 1; numerator++) &#123;                for (int denominator &#x3D; numerator + 1; denominator &lt;&#x3D; n; denominator++) &#123;                    if(getGCD(numerator, denominator)&#x3D;&#x3D;1) &#123;                        &#x2F;&#x2F; 如果是最简分数                        string temp &#x3D; to_string(numerator) + &quot;&#x2F;&quot; + to_string(denominator);                        results.push_back(temp);                    &#125;                &#125;            &#125;        &#125;        return results;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;最简&lt;/strong&gt; 分数 。分数可以以 &lt;strong&gt;任意&lt;/strong&gt; 顺序返回。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode258.各位相加</title>
    <link href="2023/11/03/leetcode258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/"/>
    <id>2023/11/03/leetcode258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-11-03T12:19:02.000Z</published>
    <updated>2023-11-03T12:21:18.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: num &#x3D; 38输出: 2 解释: 各位相加的过程为：38 --&gt; 3 + 8 --&gt; 1111 --&gt; 1 + 1 --&gt; 2由于 2 是一位数，所以返回 2。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: num &#x3D; 0输出: 0</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= num &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接做</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int addDigits(int num) &#123;        int sum &#x3D; 0; &#x2F;&#x2F; 初始化sum        while (num &gt; 0) &#123;            int temp &#x3D; num % 10; &#x2F;&#x2F; 获取个位数的值            num &#x2F;&#x3D; 10; &#x2F;&#x2F; num移去个位数的数字            sum +&#x3D; temp; &#x2F;&#x2F; 更新sum值        &#125;        if (sum &gt;&#x3D; 10) &#123;            return addDigits(sum); &#x2F;&#x2F; 递归调用函数，        &#125;        else &#123;            return sum; &#x2F;&#x2F; 符合条件时直接return sum        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负整数 &lt;code&gt;num&lt;/code&gt;，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode914.卡牌分组</title>
    <link href="2023/10/30/leetcode914-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/"/>
    <id>2023/10/30/leetcode914-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</id>
    <published>2023-10-30T08:57:10.000Z</published>
    <updated>2023-11-03T12:19:21.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有 <code>X</code> 张牌。</li><li>组内所有的牌上都写着相同的整数。</li></ul><p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：deck &#x3D; [1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：deck &#x3D; [1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= deck.length &lt;= 104</code></li><li><code>0 &lt;= deck[i] &lt; 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>使用哈希表+最小公约数解决</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) &#123;        unordered_map&lt;int, int&gt; deck_map; &#x2F;&#x2F; 用于统计牌的数量        int n &#x3D; deck.size();        for(int num:deck) &#123;            deck_map[num]++; &#x2F;&#x2F; 统计牌的数量        &#125;        int gcd &#x3D; 0; &#x2F;&#x2F; 初始化最大公约数        for (const auto&amp; entry : deck_map) &#123;            gcd &#x3D; __gcd(gcd, entry.second); &#x2F;&#x2F; 最大公约数更新        &#125;        return gcd &gt;&#x3D; 2; &#x2F;&#x2F; 符合题目条件时才返回true    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一副牌，每张牌上都写着一个整数。&lt;/p&gt;
&lt;p&gt;此时，你需要选定一个数字 &lt;code&gt;X&lt;/code&gt;，使我们可以将整副牌按下述规则分成 1 组或更多组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每组都有 &lt;code&gt;X&lt;/code&gt; 张牌。&lt;/li&gt;
&lt;li&gt;组内所有的牌上都写着相同的整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仅当你可选的 &lt;code&gt;X &amp;gt;= 2&lt;/code&gt; 时返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode30.串联所有单词的子串</title>
    <link href="2023/10/20/leetcode30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>2023/10/20/leetcode30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</id>
    <published>2023-10-20T01:56:52.000Z</published>
    <updated>2023-11-03T12:19:16.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p><p> <code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;barfoothefoobarman&quot;, words &#x3D; [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：因为 words.length &#x3D;&#x3D; 2 同时 words[i].length &#x3D;&#x3D; 3，连接的子字符串的长度必须为 6。子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。输出顺序无关紧要。返回 [9,0] 也是可以的。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;wordgoodgoodgoodbestword&quot;, words &#x3D; [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[]解释：因为 words.length &#x3D;&#x3D; 4 并且 words[i].length &#x3D;&#x3D; 4，所以串联子串的长度必须为 16。s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。所以我们返回一个空数组。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;barfoofoobarthefoobarman&quot;, words &#x3D; [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]输出：[6,9,12]解释：因为 words.length &#x3D;&#x3D; 3 并且 words[i].length &#x3D;&#x3D; 3，所以串联子串的长度必须为 9。子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>1 &lt;= words.length &lt;= 5000</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>滑动窗口</li></ul><p>此题是438.找到字符串中所有字母异位词的进阶版。不同的是第 438 题的元素是字母，而此题的元素是单词。可以用类似438.找到字符串中所有字母异位词的官方题解的方法二的滑动窗口来解这题。<br>记 words 的长度为 m，words 中每个单词的长度为n，s 的长度为 ls。首先需要将  s划分为单词组，每个单词的大小均为 n(首尾除外) 。这样的划分方法有 n 种，即先删去前  i(i&#x3D;0~n-1)个字后，将剩下字母进行划分，如果未尾有不到 n 个字母也删去。对这 n 种划分得到的单词数组分别使用滑动窗口对 words行类似于字母异位词的搜寻。<br>划分成单词组后，一个窗口包含 s 中前 m 个单词，用一个哈希表 dier 表示窗口中单词频次和 ords 中单词频次之差。初始化 differ 时，出现在窗口中的单词，每出现一次，相应的值增加 1，出现在 ords 中的单词,每出现一次，相应的值减少 1。然后将窗口右移，右侧会加入一个单词，左侧会移出一个单词，并对 differ 做应的更新。窗口移动时，若出现 differ 中值不为 0 的键的数量为 0，则表示这个窗口中的单词频次和 words 中单词频次相同，窗口的左端点是一个待求的起始位置。划分的方法有n种，做n次滑动窗口后，即可找到所有的起始位置。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; findSubstring(string &amp;s, vector&lt;string&gt; &amp;words) &#123;        vector&lt;int&gt; res;  &#x2F;&#x2F; 存储最终结果的向量        int m &#x3D; words.size();  &#x2F;&#x2F; words中单词的数量        int n &#x3D; words[0].size();  &#x2F;&#x2F; 单个单词的长度        int ls &#x3D; s.size();  &#x2F;&#x2F; 字符串s的总长度        &#x2F;&#x2F; 遍历s中的所有可能的起始位置，确保不越界        for (int i &#x3D; 0; i &lt; n &amp;&amp; i + m * n &lt;&#x3D; ls; ++i) &#123;            unordered_map&lt;string, int&gt; differ;  &#x2F;&#x2F; 存储与words中单词的不同之处            &#x2F;&#x2F; 遍历words中的单词，统计它们在当前窗口中的出现次数            for (int j &#x3D; 0; j &lt; m; ++j) &#123;                ++differ[s.substr(i + j * n, n)];             &#125;            &#x2F;&#x2F; 对于每个单词，减少其在differ中的计数，如果计数减为0则从differ中移除            for (string &amp;word: words) &#123;                if (--differ[word] &#x3D;&#x3D; 0) &#123;                    differ.erase(word);                &#125;            &#125;            &#x2F;&#x2F; 移动窗口，开始查找可能的匹配            for (int start &#x3D; i; start &lt; ls - m * n + 1; start +&#x3D; n) &#123;                if (start !&#x3D; i) &#123;                    &#x2F;&#x2F; 更新differ，添加新单词并移除旧单词                    string word &#x3D; s.substr(start + (m - 1) * n, n);                    if (++differ[word] &#x3D;&#x3D; 0) &#123;                        differ.erase(word);                    &#125;                    word &#x3D; s.substr(start - n, n);                    if (--differ[word] &#x3D;&#x3D; 0) &#123;                        differ.erase(word);                    &#125;                &#125;                &#x2F;&#x2F; 如果differ为空，说明当前窗口中的单词与words中的单词匹配                if (differ.empty()) &#123;                    res.emplace_back(start);  &#x2F;&#x2F; 将匹配的起始位置添加到结果中                &#125;            &#125;        &#125;        return res;  &#x2F;&#x2F; 返回最终结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个字符串数组 &lt;code&gt;words&lt;/code&gt;&lt;strong&gt;。&lt;/strong&gt; &lt;code&gt;words&lt;/code&gt; 中所有字符串 &lt;strong&gt;长度相同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;s&lt;/code&gt; 中的 &lt;strong&gt;串联子串&lt;/strong&gt; 是指一个包含 &lt;code&gt;words&lt;/code&gt; 中所有字符串以任意顺序排列连接起来的子串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，如果 &lt;code&gt;words = [&amp;quot;ab&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ef&amp;quot;]&lt;/code&gt;， 那么 &lt;code&gt;&amp;quot;abcdef&amp;quot;&lt;/code&gt;， &lt;code&gt;&amp;quot;abefcd&amp;quot;&lt;/code&gt;，&lt;code&gt;&amp;quot;cdabef&amp;quot;&lt;/code&gt;， &lt;code&gt;&amp;quot;cdefab&amp;quot;&lt;/code&gt;，&lt;code&gt;&amp;quot;efabcd&amp;quot;&lt;/code&gt;， 和 &lt;code&gt;&amp;quot;efcdab&amp;quot;&lt;/code&gt; 都是串联子串。 &lt;code&gt;&amp;quot;acdbef&amp;quot;&lt;/code&gt; 不是串联子串，因为他不是任何 &lt;code&gt;words&lt;/code&gt; 排列的连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回所有串联子串在 &lt;code&gt;s&lt;/code&gt; 中的开始索引。你可以以 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode18.四数之和</title>
    <link href="2023/10/20/leetcode18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>2023/10/20/leetcode18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2023-10-20T01:34:41.000Z</published>
    <updated>2023-10-20T01:36:18.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8输出：[[2,2,2,2]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针法</li></ul><p>双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是<code>O(n^2)</code>，四数之和的时间复杂度是<code>O(n^3) </code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        for (int k &#x3D; 0; k &lt; nums.size(); k++) &#123;            &#x2F;&#x2F; 剪枝处理            if (nums[k] &gt; target &amp;&amp; nums[k] &gt;&#x3D; 0) &#123;            break; &#x2F;&#x2F; 这里使用break，统一通过最后的return返回            &#125;            &#x2F;&#x2F; 对nums[k]去重            if (k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) &#123;                continue;            &#125;            for (int i &#x3D; k + 1; i &lt; nums.size(); i++) &#123;                &#x2F;&#x2F; 2级剪枝处理                if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;&#x3D; 0) &#123;                    break;                &#125;                &#x2F;&#x2F; 对nums[i]去重                if (i &gt; k + 1 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                    continue;                &#125;                int left &#x3D; i + 1;                int right &#x3D; nums.size() - 1;                while (right &gt; left) &#123;                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;                        right--;                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出                    &#125; else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;                        left++;                    &#125; else &#123;                        result.push_back(vector&lt;int&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);                        &#x2F;&#x2F; 对nums[left]和nums[right]去重                        while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;                        while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;                        &#x2F;&#x2F; 找到答案时，双指针同时收缩                        right--;                        left++;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个由 &lt;code&gt;n&lt;/code&gt; 个整数组成的数组 &lt;code&gt;nums&lt;/code&gt; ，和一个目标值 &lt;code&gt;target&lt;/code&gt; 。请你找出并返回满足下述全部条件且&lt;strong&gt;不重复&lt;/strong&gt;的四元组 &lt;code&gt;[nums[a], nums[b], nums[c], nums[d]]&lt;/code&gt; （若两个四元组元素一一对应，则认为两个四元组重复）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= a, b, c, d &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; &lt;strong&gt;互不相同&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[a] + nums[b] + nums[c] + nums[d] == target&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回答案 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode454.四数相加II</title>
    <link href="2023/10/18/leetcode454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>2023/10/18/leetcode454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/</id>
    <published>2023-10-18T01:18:10.000Z</published>
    <updated>2023-10-18T01:36:18.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]输出：1</code></pre><p> <strong>提示：</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>哈希表</li></ul><p>直接上4个for循环铁定要超时，因为时间复杂度高达<code>O(n^4)</code>，在这里利用哈希表查找操作接近O(1)的特性将整体的查找操作的时间复杂度降低到<code>O(n^2)</code>。整体的代码思路如下：</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;        int result &#x3D; 0; &#x2F;&#x2F; 定义结果，类型为int        unordered_map&lt;int, int&gt; cnt; &#x2F;&#x2F; 哈希表cnt 用于统计nums1和nums2数组元素和的次数        for (int i &#x3D; 0; i &lt; nums1.size(); i++) &#123;            for (int j &#x3D; 0; j &lt; nums2.size(); j++) &#123;                int temp &#x3D; nums1[i] + nums2[j];                cnt[temp] &#x3D; cnt[temp]&#x3D;&#x3D;0?1:cnt[temp]+1; &#x2F;&#x2F; 统计过程            &#125;        &#125;        for (int i &#x3D; 0; i &lt; nums3.size(); i++) &#123;            for (int j &#x3D; 0; j &lt; nums4.size(); j++) &#123;                int temp &#x3D; -1 * (nums3[i] + nums4[j]);                &#x2F;&#x2F; 判断如果nums3和nums4中单个元素的和乘以-1在名为cnt的哈希表中非0，就更新result的值                if (cnt[temp] !&#x3D; 0) result +&#x3D; cnt[temp];             &#125;        &#125;        return result; &#x2F;&#x2F; 返回结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你四个整数数组 &lt;code&gt;nums1&lt;/code&gt;、&lt;code&gt;nums2&lt;/code&gt;、&lt;code&gt;nums3&lt;/code&gt; 和 &lt;code&gt;nums4&lt;/code&gt; ，数组长度都是 &lt;code&gt;n&lt;/code&gt; ，请你计算有多少个元组 &lt;code&gt;(i, j, k, l)&lt;/code&gt; 能满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i, j, k, l &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode383.赎金信</title>
    <link href="2023/10/17/leetcode383-%E8%B5%8E%E9%87%91%E4%BF%A1/"/>
    <id>2023/10/17/leetcode383-%E8%B5%8E%E9%87%91%E4%BF%A1/</id>
    <published>2023-10-17T00:53:04.000Z</published>
    <updated>2023-10-17T01:10:07.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;输出：false</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力枚举</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;            for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;                &#x2F;&#x2F; 在ransomNote中找到和magazine相同的字符                if (magazine[i] &#x3D;&#x3D; ransomNote[j]) &#123;                    ransomNote.erase(ransomNote.begin() + j); &#x2F;&#x2F; ransomNote删除这个字符                    break;                &#125;            &#125;        &#125;        &#x2F;&#x2F; 如果ransomNote为空，则说明magazine的字符可以组成ransomNote        if (ransomNote.length() &#x3D;&#x3D; 0) &#123;            return true;        &#125;        return false;    &#125;&#125;;</code></pre><ul><li>哈希表</li></ul><p>使用哈希表分别统计两个字符串中字母的个数，然后对比两个哈希表的结果，如果前者的字母统计个数大于后者，直接返回false，否则最终返回true</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        &#x2F;&#x2F; 初始化哈希表用于统计字符数        unordered_map&lt;char, int&gt; ransomNoteCnt;        unordered_map&lt;char, int&gt; magezineCnt;        for (char c:ransomNote) &#123;            ransomNoteCnt[c] &#x3D; ransomNoteCnt[c]&#x3D;&#x3D;0?1:ransomNoteCnt[c]+1;        &#125;        for (char c:magazine) &#123;            magezineCnt[c] &#x3D; magezineCnt[c]&#x3D;&#x3D;0?1:magezineCnt[c]+1;        &#125;        for (char c &#x3D; &#39;a&#39;; c &lt;&#x3D; &#39;z&#39;; c++) &#123;            if (ransomNoteCnt[c] &lt;&#x3D; magezineCnt[c]) continue;            else return false;        &#125;        return true;    &#125;&#125;;</code></pre><ul><li>更省空间的哈希表解法</li></ul><p>因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个长度为26的数组来记录magazine里字母出现的次数。</p><p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p><p>依然是数组在哈希法中的应用。</p><p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        int record[26] &#x3D; &#123;0&#125;;        &#x2F;&#x2F;add        if (ransomNote.size() &gt; magazine.size()) &#123;            return false;        &#125;        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;            &#x2F;&#x2F; 通过record数据记录 magazine里各个字符出现次数            record[magazine[i]-&#39;a&#39;] ++;        &#125;        for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;            &#x2F;&#x2F; 遍历ransomNote，在record里对应的字符个数做--操作            record[ransomNote[j]-&#39;a&#39;]--;            &#x2F;&#x2F; 如果小于零说明ransomNote里出现的字符，magazine没有            if(record[ransomNote[j]-&#39;a&#39;] &lt; 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串：&lt;code&gt;ransomNote&lt;/code&gt; 和 &lt;code&gt;magazine&lt;/code&gt; ，判断 &lt;code&gt;ransomNote&lt;/code&gt; 能不能由 &lt;code&gt;magazine&lt;/code&gt; 里面的字符构成。&lt;/p&gt;
&lt;p&gt;如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;magazine&lt;/code&gt; 中的每个字符只能在 &lt;code&gt;ransomNote&lt;/code&gt; 中使用一次。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode349.两个数组的交集</title>
    <link href="2023/10/17/leetcode349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>2023/10/17/leetcode349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2023-10-17T00:38:12.000Z</published>
    <updated>2023-10-17T00:52:36.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; deduplicate(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F; 手动去重        int n &#x3D; nums.size();        if (n &lt;&#x3D; 1) return nums;        int p &#x3D; 0,q &#x3D; 1;        while (q &lt; n) &#123;            &#x2F;&#x2F; 0 0 1 2 2 3 4            if (nums[p] &#x3D;&#x3D; nums[q])&#123;                ++q;            &#125;            else &#123;                nums[p+1] &#x3D; nums[q];                ++p;                ++q;            &#125;        &#125;        vector&lt;int&gt; newNums(nums.begin(), nums.begin() + p + 1);        return newNums;    &#125;    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        &#x2F;&#x2F; 排序        sort(nums1.begin(), nums1.end());        sort(nums2.begin(), nums2.end());        &#x2F;&#x2F; 对两个数组进行去重        vector&lt;int&gt; newNums1 &#x3D; deduplicate(nums1);        vector&lt;int&gt; newNums2 &#x3D; deduplicate(nums2);        &#x2F;&#x2F; 初始化结果数组        vector&lt;int&gt; results;        int n1 &#x3D; newNums1.size();        int n2 &#x3D; newNums2.size();        &#x2F;&#x2F; 暴力便利        for (int i &#x3D; 0; i &lt; n1; i++) &#123;            for (int j &#x3D; 0; j &lt; n2; j++) &#123;                if (newNums1[i] &#x3D;&#x3D; newNums2[j]) &#123;                    results.push_back(newNums1[i]);                &#125;            &#125;        &#125;        &#x2F;&#x2F; 返回结果数组        return results;    &#125;&#125;;</code></pre><ul><li>使用哈希表</li></ul><p>C++中，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_set&lt;int&gt; result_set;        unordered_set&lt;int&gt; nums1set(nums1.begin(), nums1.end());        for (int num:nums2) &#123;            &#x2F;&#x2F; 发现nums2的元素 在nums_set里又出现过            if (nums1set.find(num) !&#x3D; nums1set.end()) &#123;                result_set.insert(num);            &#125;        &#125;        return vector&lt;int&gt;(result_set.begin(), result_set.end());    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; ，返回 &lt;em&gt;它们的交集&lt;/em&gt; 。输出结果中的每个元素一定是 &lt;strong&gt;唯一&lt;/strong&gt; 的。我们可以 &lt;strong&gt;不考虑输出结果的顺序&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode40.组合总和II</title>
    <link href="2023/10/12/leetcode40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/"/>
    <id>2023/10/12/leetcode40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/</id>
    <published>2023-10-12T10:59:31.000Z</published>
    <updated>2023-10-12T11:10:39.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,输出:[[1,2,2],[5]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>这道题目和39.组合总和有如下区别：</p><ol><li>本题candidates 中的每个数字在每个组合中只能使用一次。</li><li>本题数组candidates的元素是有重复的，而39是无重复元素的数组candidates</li></ol><p>最后本题和39要求一样，解集不能包含重复的组合。</p><p><strong>本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p><p><img src="http://cdn.leafii.top/img/20230310000918.png" alt="40.组合总和II" loading="lazy"></p><p>同一树层上的两个重复元素不可以重新选取，使用used数组用来记录同一树枝上的元素是否使用过。</p><ul><li>递归函数参数</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span> <span class="token comment">// 存放组合集合</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span>           <span class="token comment">// 符合条件的组合</span><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> used<span class="token punctuation">)</span></code></pre><ul><li>递归终止条件</li></ul><p><code>sum &gt; target</code> 和 <code>sum == target</code></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 这个条件其实可以省略</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>单层搜索的逻辑</li></ul><p>要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。</p><p>**如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。</p><p>此时for循环里就应该做continue的操作。</p><p><img src="http://cdn.leafii.top/img/20230310000954.png" alt="40.组合总和II1" loading="lazy"></p><p>我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul><p><img src="http://cdn.leafii.top/img/20221021163812.png" alt="img" loading="lazy"></p><p>那么单层搜索的逻辑代码如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span>    <span class="token comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span>    <span class="token comment">// 要对同一树层使用过的元素进行跳过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> candidates<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    sum <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span>    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    sum <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>最终得到的整体代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) &#123;        if (sum &#x3D;&#x3D; target) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target; i++) &#123;            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过            &#x2F;&#x2F; 要对同一树层使用过的元素进行跳过            if (i &gt; 0 &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;                continue;            &#125;            sum +&#x3D; candidates[i];            path.push_back(candidates[i]);            used[i] &#x3D; true;            backtracking(candidates, target, sum, i + 1, used); &#x2F;&#x2F; 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次            used[i] &#x3D; false;            sum -&#x3D; candidates[i];            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        vector&lt;bool&gt; used(candidates.size(), false);        path.clear();        result.clear();        &#x2F;&#x2F; 首先把给candidates排序，让其相同的元素都挨在一起。        sort(candidates.begin(), candidates.end());        backtracking(candidates, target, 0, 0, used);        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个候选人编号的集合 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的每个数字在每个组合中只能使用 &lt;strong&gt;一次&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;解集不能包含重复的组合。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode39.组合总和</title>
    <link href="2023/10/11/leetcode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>2023/10/11/leetcode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</id>
    <published>2023-10-11T00:52:11.000Z</published>
    <updated>2023-10-12T11:10:36.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。7 也是一个候选， 7 &#x3D; 7 。仅有这两种组合。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入: candidates &#x3D; [2,3,5], target &#x3D; 8输出: [[2,2,2,2],[2,3,3],[3,5]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入: candidates &#x3D; [2], target &#x3D; 1输出: []</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>基础回溯法</li></ul><p>本题的搜索过程可以抽象成如下树形结构：</p><p><img src="http://cdn.leafii.top/img/20201223170730367.png" alt="39.组合总和" loading="lazy"></p><p>使用回溯三步曲：</p><ol><li>递归函数的参数</li></ol><p>定义一个二维数组results用于存储最终的组合，定义一个一维数组用于存储单次组合。这两个变量为全局变量，然后定义一个递归函数traceback,它的参数为题目自带的候选数组canditate，target，以及path元素的和sum，以及开始遍历的索引startIndex</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span></code></pre><ol start="2"><li>递归终止条件</li></ol><p>当<code>sum&gt;target</code>时，没有继续遍历下去的必要，当<code>sum==target</code>时将当前的path放进results中，并退出当前递归函数。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>单层搜索逻辑</li></ol><p>从startIndex开始遍历candidates数组，搜索组合</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sum <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span>    sum <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 回溯</span>    path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 回溯</span><span class="token punctuation">&#125;</span></code></pre><p>整个代码：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; results;    vector&lt;int&gt; path;    void tracebacking(vector&lt;int&gt; candidates, int target, int sumValue,int startIndex) &#123;        &#x2F;&#x2F;参数分别为候选数组，目标值，path中元素的和sumValue，最终结果results，单个组合path，开始遍历的索引startIndex        if (sumValue &gt; target) return; &#x2F;&#x2F; 如果sumValue比target大，直接剪枝        &#x2F;&#x2F; 终止条件        if (sumValue &#x3D;&#x3D; target) &#123;            &#x2F;&#x2F; 符合一个组合的条件            results.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; candidates.size();i++) &#123;            path.push_back(candidates[i]);            sumValue +&#x3D; candidates[i];            tracebacking(candidates, target, sumValue, i);            &#x2F;&#x2F; 回溯            path.pop_back();            sumValue -&#x3D; candidates[i];        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        results.clear();        path.clear();        tracebacking(candidates, target, 0, 0);        return results;       &#125;&#125;;</code></pre><ul><li>剪枝优化</li></ul><p>对数组进行排序，在for循环中的判断中增加一个判断，可以进行有效的剪枝。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; results;    vector&lt;int&gt; path;    void tracebacking(vector&lt;int&gt; candidates, int target, int sumValue,int startIndex) &#123;        &#x2F;&#x2F;参数分别为候选数组，目标值，path中元素的和sumValue，最终结果results，单个组合path，开始遍历的索引startIndex        if (sumValue &gt; target) return; &#x2F;&#x2F; 如果sumValue比target大，直接剪枝        &#x2F;&#x2F; 终止条件        if (sumValue &#x3D;&#x3D; target) &#123;            &#x2F;&#x2F; 符合一个组合的条件            results.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sumValue + candidates[i] &lt;&#x3D; target;i++) &#123;            &#x2F;&#x2F; for循环中的判断条件做了剪枝优化            path.push_back(candidates[i]);            sumValue +&#x3D; candidates[i];            tracebacking(candidates, target, sumValue, i);            &#x2F;&#x2F; 回溯            path.pop_back();            sumValue -&#x3D; candidates[i];        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        results.clear();        path.clear();        sort(candidates.begin(), candidates.end()); &#x2F;&#x2F; 排序，减少不必要的计算        tracebacking(candidates, target, 0, 0);        return results;       &#125;&#125;;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>代码随想录：<a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 &lt;strong&gt;无重复元素&lt;/strong&gt; 的整数数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标整数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中可以使数字和为目标数 &lt;code&gt;target&lt;/code&gt; 的 所有 &lt;strong&gt;不同组合&lt;/strong&gt; ，并以列表形式返回。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回这些组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的 &lt;strong&gt;同一个&lt;/strong&gt; 数字可以 &lt;strong&gt;无限制重复被选取&lt;/strong&gt; 。如果至少一个数字的被选数量不同，则两种组合是不同的。 &lt;/p&gt;
&lt;p&gt;对于给定的输入，保证和为 &lt;code&gt;target&lt;/code&gt; 的不同组合数少于 &lt;code&gt;150&lt;/code&gt; 个。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode83.删除排序链表中的重复元素</title>
    <link href="2023/10/10/leetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>2023/10/10/leetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2023-10-10T06:42:51.000Z</published>
    <updated>2023-10-10T06:46:43.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/list1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,1,2]输出：[1,2]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/list2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,1,2,3,3]输出：[1,2,3]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针</li></ul><p>思路与第一个题目类似，只是链表与数组的去重方式不同，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if (!head || !head-&gt;next) &#123;            &#x2F;&#x2F;如果仅有一个元素或者一个元素都没有，直接返回head本身            return head;        &#125;        &#x2F;&#x2F; 初始化指针p，q        ListNode* p &#x3D; head;         ListNode* q &#x3D; head-&gt;next;        while (q) &#123;            &#x2F;&#x2F; 当q未指到链表结尾时进行判断            if (p-&gt;val &#x3D;&#x3D; q-&gt;val) &#123;                &#x2F;&#x2F;相等元素执行断链操作                ListNode* temp &#x3D; q;                p-&gt;next &#x3D; q-&gt;next;                q &#x3D; q-&gt;next;                delete temp;            &#125;            else &#123;                &#x2F;&#x2F; 不相等两个指针全都后移                p &#x3D; p-&gt;next;                q &#x3D; q-&gt;next;            &#125;        &#125;        return head;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个已排序的链表的头 &lt;code&gt;head&lt;/code&gt; ， &lt;em&gt;删除所有重复的元素，使每个元素只出现一次&lt;/em&gt; 。返回 &lt;em&gt;已排序的链表&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode26.删除有序数组中的重复项</title>
    <link href="2023/10/10/leetcode26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>2023/10/10/leetcode26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2023-10-10T06:41:57.000Z</published>
    <updated>2023-10-10T06:45:35.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><span id="more"></span><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><pre class="language-none"><code class="language-none">int[] nums &#x3D; [...]; &#x2F;&#x2F; 输入数组int[] expectedNums &#x3D; [...]; &#x2F;&#x2F; 长度正确的期望答案int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用assert k &#x3D;&#x3D; expectedNums.length;for (int i &#x3D; 0; i &lt; k; i++) &#123;    assert nums[i] &#x3D;&#x3D; expectedNums[i];&#125;</code></pre><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]输出：5, nums &#x3D; [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n&#x3D;&#x3D;1) return n;        &#x2F;&#x2F; 初始化双指针        int p &#x3D; 0;        int q &#x3D; 1;        while (q &lt; n) &#123;            &#x2F;&#x2F; 1.比较 p 和 q 位置的元素是否相等。            &#x2F;&#x2F; 如果相等，q 后移 1 位             if (nums[p] &#x3D;&#x3D; nums[q]) &#123;                q &#x3D; q + 1;            &#125;            &#x2F;&#x2F; 如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位             else &#123;                nums[p+1] &#x3D; nums[q];                ++p;                ++q;            &#125;            &#x2F;&#x2F; 重复上述过程，直到 q 等于数组长度。        &#125;        return p + 1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 &lt;strong&gt;非严格递增排列&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，请你**&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt; 原地&lt;/a&gt;** 删除重复出现的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; ，返回删除后数组的新长度。元素的 &lt;strong&gt;相对顺序&lt;/strong&gt; 应该保持 &lt;strong&gt;一致&lt;/strong&gt; 。然后返回 &lt;code&gt;nums&lt;/code&gt; 中唯一元素的个数。&lt;/p&gt;
&lt;p&gt;考虑 &lt;code&gt;nums&lt;/code&gt; 的唯一元素的数量为 &lt;code&gt;k&lt;/code&gt; ，你需要做以下事情确保你的题解可以被通过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改数组 &lt;code&gt;nums&lt;/code&gt; ，使 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素包含唯一元素，并按照它们最初在 &lt;code&gt;nums&lt;/code&gt; 中出现的顺序排列。&lt;code&gt;nums&lt;/code&gt; 的其余元素与 &lt;code&gt;nums&lt;/code&gt; 的大小不重要。&lt;/li&gt;
&lt;li&gt;返回 &lt;code&gt;k&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode611.有效三角形的个数</title>
    <link href="2023/09/15/leetcode611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>2023/09/15/leetcode611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2023-09-15T10:27:08.000Z</published>
    <updated>2023-09-15T10:30:07.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [4,2,3,4]输出: 4</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>遍历+双指针优化</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;        int result &#x3D; 0; &#x2F;&#x2F; 初始化结果        sort(nums.begin(), nums.end()); &#x2F;&#x2F; 对数组排序        int n &#x3D; nums.size();        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;            if (nums[i] &#x3D;&#x3D; 0) continue; &#x2F;&#x2F; 跳过为0的状态            int k &#x3D; i + 2; &#x2F;&#x2F; 第二个指针的初始化位置            for (int j &#x3D; i + 1; j &lt; n - 1; j++) &#123;                while (k &lt; n &amp;&amp; nums[i] + nums[j] &gt; nums[k]) &#123;                    k++;                &#125;                result +&#x3D; k - j - 1;&#x2F;&#x2F; k - j - 1 表示的是满足条件的第三个边的数量            &#125;        &#125;        return result; &#x2F;&#x2F; 返回结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个包含非负整数的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其中可以组成三角形三条边的三元组个数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode451.根据字符出现频率排序</title>
    <link href="2023/09/12/leetcode451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"/>
    <id>2023/09/12/leetcode451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-12T13:03:45.000Z</published>
    <updated>2023-09-12T13:10:08.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，根据字符出现的 <strong>频率</strong> 对其进行 <strong>降序排序</strong> 。一个字符出现的 <strong>频率</strong> 是它出现在字符串中的次数。</p><p>返回 <em>已排序的字符串</em> 。如果有多个答案，返回其中任何一个。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;tree&quot;输出: &quot;eert&quot;解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;cccaaa&quot;输出: &quot;cccaaa&quot;解释: &#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;Aabb&quot;输出: &quot;bbAa&quot;解释: 此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 * 105</code></li><li><code>s</code> 由大小写英文字母和数字组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>思路：首先使用hashmap对字符串中的字符进行计数，然后使用vector数组将hashmap的元素进行拷贝，将vector以计数的从大到小进行排序。最后对排序后的vector进行遍历，得到最终的字符串，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string frequencySort(string s) &#123;        unordered_map&lt;char, int&gt; s_count_map;        for (char c:s) &#123;            s_count_map[c]++;        &#125;        &#x2F;&#x2F; 复制        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector(s_count_map.begin(), s_count_map.end());        &#x2F;&#x2F;从大到小排序        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123;return a.second &gt; b.second;&#125;);        string result;        for(auto cnt:s_count_vector) &#123;            int cnt_second &#x3D; cnt.second;            while (cnt_second--) &#123;                result+&#x3D;cnt.first;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><ul><li>一些细节优化后的代码（成绩没变）</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string frequencySort(string s) &#123;        unordered_map&lt;char, int&gt; s_count_map;        &#x2F;&#x2F; 统计字符频率        for (char c : s) &#123;            s_count_map[c]++;        &#125;        &#x2F;&#x2F; 构建结果字符串        string result;        result.reserve(s.size()); &#x2F;&#x2F; 预分配足够的内存        &#x2F;&#x2F; 构建频率字符对，并按频率降序排序        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector;        for (const auto&amp; kv : s_count_map) &#123;            s_count_vector.emplace_back(kv);        &#125;        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123; return a.second &gt; b.second; &#125;);        &#x2F;&#x2F; 构建结果字符串        for (const auto&amp; cnt : s_count_vector) &#123;            result.append(cnt.second, cnt.first); &#x2F;&#x2F; 使用append方法        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，根据字符出现的 &lt;strong&gt;频率&lt;/strong&gt; 对其进行 &lt;strong&gt;降序排序&lt;/strong&gt; 。一个字符出现的 &lt;strong&gt;频率&lt;/strong&gt; 是它出现在字符串中的次数。&lt;/p&gt;
&lt;p&gt;返回 &lt;em&gt;已排序的字符串&lt;/em&gt; 。如果有多个答案，返回其中任何一个。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode976.三角形的最大周长</title>
    <link href="2023/09/12/leetcode976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/"/>
    <id>2023/09/12/leetcode976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/</id>
    <published>2023-09-12T12:29:18.000Z</published>
    <updated>2023-09-12T12:30:16.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定由一些正数（代表长度）组成的数组 <code>nums</code> ，返回 <em>由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长</em> 。如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,1,2]输出：5解释：你可以用三个边长组成一个三角形:1 2 2。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,1,10]输出：0解释：你不能用边长 1,1,2 来组成三角形。不能用边长 1,1,10 来构成三角形。不能用边长 1、2 和 10 来构成三角形。因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 104</code></li><li><code>1 &lt;= nums[i] &lt;= 106</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>排序解答</li></ul><ol><li>首先对输入数组 <code>nums</code> 进行排序，按照从大到小的顺序排列。</li><li>然后，遍历排序后的数组，从大到小依次选取三个数 <code>a</code>, <code>b</code>, <code>c</code>，判断是否满足组成三角形的条件，即 <code>a + b &gt; c</code> 和 <code>a - b &lt; c</code>。如果满足条件，就找到了最大周长的三角形，直接返回 <code>a + b + c</code>。</li><li>如果遍历完整个数组都没有找到满足条件的三角形，说明不存在符合条件的三角形，返回0。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:        int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F; 将数组从大到小排序        sort(nums.begin(), nums.end(), [](int a, int b) &#123;            return a &gt; b;        &#125;);        int n &#x3D; nums.size();        &#x2F;&#x2F; 开始遍历寻找最大的能组成三角形的三个数        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;            if (nums[i] &lt; nums[i + 1] + nums[i + 2]) return nums[i] + nums[i + 1] + nums[i + 2];        &#125;        return 0;    &#125;    &#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定由一些正数（代表长度）组成的数组 &lt;code&gt;nums&lt;/code&gt; ，返回 &lt;em&gt;由其中三个长度组成的、&lt;strong&gt;面积不为零&lt;/strong&gt;的三角形的最大周长&lt;/em&gt; 。如果不能形成任何面积不为零的三角形，返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode389.找不同</title>
    <link href="2023/09/12/leetcode389-%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
    <id>2023/09/12/leetcode389-%E6%89%BE%E4%B8%8D%E5%90%8C/</id>
    <published>2023-09-12T12:29:07.000Z</published>
    <updated>2023-09-12T12:30:20.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，它们只包含小写字母。</p><p>字符串 <code>t</code> 由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <code>t</code> 中被添加的字母。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;, t &#x3D; &quot;abcde&quot;输出：&quot;e&quot;解释：&#39;e&#39; 是那个被添加的字母。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;&quot;, t &#x3D; &quot;y&quot;输出：&quot;y&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 1000</code></li><li><code>t.length == s.length + 1</code></li><li><code>s</code> 和 <code>t</code> 只包含小写字母</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>用数组辅助计数的暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    char findTheDifference(string s, string t) &#123;        vector&lt;int&gt; s_cnt(26,0);        vector&lt;int&gt; t_cnt(26,0); &#x2F;&#x2F; 使用数组存储字符串中不同字母的个数        char result; &#x2F;&#x2F; 初始化答案字符        &#x2F;&#x2F; 分别统计不同字符串的字符个数        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            int index &#x3D; int(s[i] - &#39;a&#39;);            ++s_cnt[index];        &#125;        for (int j &#x3D; 0; j &lt; t.size(); j++) &#123;            int index &#x3D; int(t[j] - &#39;a&#39;);            ++t_cnt[index];        &#125;        &#x2F;&#x2F; 对比个数，不同的索引与&#39;a&#39;相加就是需要的答案。        for (int i &#x3D; 0; i &lt; 26; i++) &#123;            if (s_cnt[i] !&#x3D; t_cnt[i]) &#123;                result &#x3D; &#39;a&#39; + i;            &#125;        &#125;        return result; &#x2F;&#x2F; 返回答案    &#125;&#125;;</code></pre><ul><li>位运算</li></ul><p>如果将两个字符串拼接成一个字符串，则问题转换成求字符串中出现奇数次的字符。我们使用异或操作来找到两个字符串中不同的字符，因为相同的字符异或后会抵消，最终剩下的是不同的字符。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    char findTheDifference(string s, string t) &#123;        char result &#x3D; 0;                &#x2F;&#x2F; 异或操作会消除相同的字符，最终结果将是不同字符的ASCII码值        for (char c : s) &#123;            result ^&#x3D; c;        &#125;                for (char c : t) &#123;            result ^&#x3D; c;        &#125;                return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，它们只包含小写字母。&lt;/p&gt;
&lt;p&gt;字符串 &lt;code&gt;t&lt;/code&gt; 由字符串 &lt;code&gt;s&lt;/code&gt; 随机重排，然后在随机位置添加一个字母。&lt;/p&gt;
&lt;p&gt;请找出在 &lt;code&gt;t&lt;/code&gt; 中被添加的字母。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
