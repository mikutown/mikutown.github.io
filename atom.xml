<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-03-28T06:24:39.637Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode113.路径总和II</title>
    <link href="2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/"/>
    <id>2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</id>
    <published>2023-03-28T06:05:24.000Z</published>
    <updated>2023-03-28T06:24:39.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/pathsumii1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22输出：[[5,4,11,2],[5,8,4,5]]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/pathsum2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2], targetSum &#x3D; 0输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>本题可以使用深度优先搜索（DFS）求解。从根节点开始，依次搜索左子树和右子树，直到找到符合条件的路径。具体来说，我们可以使用递归的方式，每次遍历到一个节点时，将该节点加入路径中，并更新目标值。如果该节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径，将该路径加入结果数组中。否则，继续搜索左子树和右子树。在搜索之后，需要将当前节点从路径中删除，以便回溯到之前的状态。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        dfs(root, targetSum, res, path);        return res;    &#125;    void dfs(TreeNode* node, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;        if (!node) return;  &#x2F;&#x2F; 如果当前节点为空，则直接返回        path.push_back(node-&gt;val);  &#x2F;&#x2F; 将当前节点的值加入路径中        targetSum -&#x3D; node-&gt;val;     &#x2F;&#x2F; 更新目标值        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 如果当前节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径            res.push_back(path);    &#x2F;&#x2F; 将该路径加入结果数组        &#125; else &#123;            dfs(node-&gt;left, targetSum, res, path);   &#x2F;&#x2F; 搜索左子树            dfs(node-&gt;right, targetSum, res, path);  &#x2F;&#x2F; 搜索右子树        &#125;        path.pop_back();  &#x2F;&#x2F; 回溯：将当前节点从路径中删除，恢复到搜索之前的状态    &#125;&#125;;</code></pre><blockquote><p><code>path.pop_back()</code> 是 C++ 中 vector 容器的成员函数，用于删除 vector 容器中的最后一个元素。在本题中，由于我们在搜索过程中需要记录搜索路径，因此使用了一个 <code>path</code> 数组来保存路径。在每次搜索到一个新节点时，我们将该节点的值加入 <code>path</code> 数组中，如果搜索结束后未找到符合条件的路径，需要将该节点从 <code>path</code> 数组中删除，回溯到之前的状态，继续搜索其他节点。因此，在代码中，<code>path.pop_back()</code> 的作用是删除 <code>path</code> 数组中最后一个元素，以便回溯到之前的状态。</p></blockquote><p>时间复杂度分析：</p><p>本题的时间复杂度为$ O(N^2)$，其中 N 表示二叉树的节点数。在最坏情况下，二叉树的形态类似于一个单链表，此时需要遍历所有节点，时间复杂度为 $O(N)$。对于每个节点，由于需要将该节点加入路径中，时间复杂度为$ O(N)$，因此总时间复杂度为 $O(N^2)$。</p><p>空间复杂度分析：</p><p>本题的空间复杂度为 $O(N)$，其中 N 表示二叉树的节点数。递归调用的栈空间最多为 $O(N)$，路径数组的空间为 $O(N)$，因此总空间复杂度为 $O(N)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; 和一个整数目标和 &lt;code&gt;targetSum&lt;/code&gt; ，找出所有 &lt;strong&gt;从根节点到叶子节点&lt;/strong&gt; 路径总和等于给定目标和的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叶子节点&lt;/strong&gt; 是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode110.平衡二叉树</title>
    <link href="2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-27T07:36:41.000Z</published>
    <updated>2023-03-28T06:05:42.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/balance_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/balance_2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：true</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归但空间复杂度较高的解法</li></ul><p>本题可以使用递归的方法来解决。对于每一个节点，我们需要先递归遍历它的左右子树，计算它们的高度差。如果左右子树的高度差超过了1，那么这棵树就不是平衡二叉树。如果左右子树都是平衡二叉树，那么我们可以判断当前节点是不是平衡二叉树：如果左右子树的高度差不超过1，那么当前节点就是平衡二叉树。最后递归返回整棵树的平衡情况。</p><p>在递归函数中，我们需要同时返回当前节点的高度和平衡情况，因此可以使用pair&lt;int, bool&gt;来表示。其中，pair的第一个元素表示高度，第二个元素表示当前节点是否是平衡二叉树。同时，我们需要处理一些边界情况，例如空节点的高度为0，空节点也是平衡二叉树。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root).second;    &#125;        pair&lt;int, bool&gt; checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return make_pair(0, true);        &#125;        auto left &#x3D; checkBalance(node-&gt;left);        auto right &#x3D; checkBalance(node-&gt;right);        if (left.second &amp;&amp; right.second &amp;&amp; abs(left.first - right.first) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return make_pair(max(left.first, right.first) + 1, true);        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return make_pair(0, false);    &#125;&#125;;</code></pre><blockquote><p><code>pair</code>是C++ STL中的一个模板类，用于存储两个不同类型的变量。它将两个变量打包成一个整体，方便传递和使用。</p></blockquote><p>但是它的内存占用过高，因为对于每个节点，它都要单独存一个bool变量用于表示节点是否为二叉树的平衡结点。因此需要进行优化。</p><ul><li>递归，但优化内存占用</li></ul><p>在题目中，我们使用了<code>pair&lt;int, bool&gt;</code>来表示每个节点的高度和平衡情况，但是这种方法会浪费一定的空间，因为每个节点都需要存储一个<code>bool</code>类型的变量。实际上，我们只需要判断每个节点是否平衡，因此可以使用一个<code>int</code>类型的变量来表示平衡情况：-1表示不平衡，非0表示平衡并且代表节点的高度。这样就可以减少空间的使用。</p><p>同时，我们可以将返回值从<code>pair&lt;int, bool&gt;</code>改为<code>int</code>，表示当前节点的高度。如果当前节点不是平衡二叉树，那么直接返回-1，否则返回节点的高度。</p><p>C++代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root) !&#x3D; -1;    &#125;    int checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return 0;        &#125;        int left &#x3D; checkBalance(node-&gt;left);        int right &#x3D; checkBalance(node-&gt;right);        if (left !&#x3D; -1 &amp;&amp; right !&#x3D; -1 &amp;&amp; abs(left - right) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return max(left, right) + 1;        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode108.将有序数组转换为二叉搜索树</title>
    <link href="2023/03/26/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>2023/03/26/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2023-03-26T11:19:20.000Z</published>
    <updated>2023-03-26T11:27:07.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/btree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/btree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归构造树</li></ul><p>在这个实现中，我们采用了递归的方法构建高度平衡的二叉搜索树。在每次递归中，我们找到当前子数组的中间元素作为根节点，然后递归构建左右子树，最后将根节点返回。在递归过程中，我们使用两个指针 <code>left</code> 和 <code>right</code> 分别表示当前子数组的左右边界。如果 <code>left &gt; right</code>，则说明当前子数组为空，递归结束，返回 <code>nullptr</code>。C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F; 调用buildBST函数        return buildBST(nums, 0, nums.size() - 1);    &#125;private:    TreeNode* buildBST(vector&lt;int&gt;&amp; nums, int left, int right) &#123;        if (left &gt; right) &#123;            &#x2F;&#x2F; 若left &gt; right 则直接返回空指针            return nullptr;         &#125;        int mid &#x3D; left + (right - left) &#x2F; 2; &#x2F;&#x2F; 寻找mid的大小，将nums[mid]作为树的根节点        TreeNode* root &#x3D; new TreeNode(nums[mid]); &#x2F;&#x2F; 新建根节点，节点的值为nums[mid]        &#x2F;&#x2F; 递归调用buildBST函数构造left和right树，并将其赋值给root-&gt;left和root-&gt;right        root-&gt;left &#x3D; buildBST(nums, left, mid - 1);         root-&gt;right &#x3D; buildBST(nums, mid + 1, right);        &#x2F;&#x2F; 返回根节点        return root;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，其中元素已经按 &lt;strong&gt;升序&lt;/strong&gt; 排列，请你将其转换为一棵 &lt;strong&gt;高度平衡&lt;/strong&gt; 二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高度平衡&lt;/strong&gt; 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode214.最短回文串</title>
    <link href="2023/03/23/leetcode214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>2023/03/23/leetcode214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2023-03-23T06:14:31.000Z</published>
    <updated>2023-03-23T06:27:13.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <em><strong>s</strong></em>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;aacecaaa&quot;输出：&quot;aaacecaaa&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;输出：&quot;dcbabcd&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>KMP算法求解</li></ul><p>本题可以通过将原字符串翻转后与原字符串拼接，然后在新的字符串中找到以原字符串开头的最长回文子串，最后将翻转字符串的前缀加到原字符串前面即可得到新的字符串。为了找到以原字符串开头的最长回文子串，可以使用KMP算法中的next数组，将新的字符串l的next数组求出来，那么l.size() - 1位置处的值就是以原字符串开头的最长回文子串的长度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string shortestPalindrome(string s) &#123;        &#x2F;&#x2F; 将字符串s翻转并存储在rev_s中        string rev_s &#x3D; s;        reverse(rev_s.begin(), rev_s.end());        &#x2F;&#x2F; 将s和rev_s拼接，并用“#”分割        string l &#x3D; s + &quot;#&quot; + rev_s;        &#x2F;&#x2F; 初始化一个大小为l.size()的数组p        vector&lt;int&gt; p(l.size(), 0);        &#x2F;&#x2F; 通过循环遍历l，求出p数组        for (int i &#x3D; 1; i &lt; l.size(); i++) &#123;            int j &#x3D; p[i - 1];            while (j &gt; 0 &amp;&amp; l[i] !&#x3D; l[j]) j &#x3D; p[j - 1];            p[i] &#x3D; (j +&#x3D; l[i] &#x3D;&#x3D; l[j]);        &#125;        &#x2F;&#x2F; 返回一个由rev_s的前缀和s组成的新字符串        return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;    &#125;&#125;;</code></pre><blockquote><p>以输入<code>s=&quot;aacecaaa&quot;</code>为例，说明代码的运行过程：</p><p>首先将字符串s翻转得到rev_s&#x3D;”aaacecaa”，然后将s和rev_s用”#”分割拼接起来得到l&#x3D;”aacecaaa#aaacecaa”。</p><p>然后初始化一个大小为l.size()的数组p，数组中每个元素表示对应位置之前的字符串的最长相同前缀后缀的长度。</p><p>接下来使用KMP算法的思想，通过遍历l来求得数组p的所有元素。从i&#x3D;1开始，依次比较l[i]和l[p[i-1]]，如果不相同，则令j&#x3D;p[i-1]，并循环将j更新为p[j-1]，直到j&#x3D;0或者找到一个位置k使得l[i]和l[k]相等。如果找到了k，则令p[i]&#x3D;k+1，否则令p[i]&#x3D;0。</p><p>经过上述循环遍历后，p数组的最后一个元素p[l.size()-1]表示以原字符串开头的最长回文子串的长度，即3。因此，可以将rev_s的前缀”aa”加到s的前面，得到新的字符串为”aaacecaaa”，这个字符串是由原字符串”aacecaaa”通过添加最少字符得到的回文串。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;em&gt;&lt;strong&gt;s&lt;/strong&gt;&lt;/em&gt;，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode151.反转字符串中的单词</title>
    <link href="2023/03/22/leetcode151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>2023/03/22/leetcode151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2023-03-22T02:01:36.000Z</published>
    <updated>2023-03-22T02:31:09.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;  hello world  &quot;输出：&quot;world hello&quot;解释：反转后的字符串中不能存在前导空格和尾随空格。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;a good   example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>大致思路：将字符串中的每个单词放入动态数组中，然后将动态数组倒序遍历得到结果字符串，最后返回结果字符串，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseWords(string s) &#123;        &#x2F;&#x2F; 特判：如果s的长度为1，则只包含一个单词，此时直接返回s即可        if (s.length() &#x3D;&#x3D; 1) return s;        &#x2F;&#x2F; 新建s_vec动态数组，元素类型为string        vector&lt;string&gt; s_vec;        &#x2F;&#x2F; 定义left，它是指向字符串里第一个单词的第一个字母的指针        int left &#x3D; 0; &#x2F;&#x2F; left的初始化        while (s[left] &#x3D;&#x3D; &#39; &#39;) &#123;            left++;  &#x2F;&#x2F; 防止字符串一开始就是空格        &#125;        &#x2F;&#x2F; 开始循环        for (int i &#x3D; left; i &lt; s.length(); i++) &#123;            &#x2F;&#x2F; 当i指向一个单词右边的第一个空格或者字符串的最后一个元素时            if (s[i] &#x3D;&#x3D; &#39; &#39; || i &#x3D;&#x3D; s.length() - 1) &#123;                if (i &#x3D;&#x3D; s.length()-1) i++; &#x2F;&#x2F; 当i指向字符串的最后一个字母时，需要自增1，否则无法通过substr获得子串                string temp &#x3D; s.substr(left, i - left); &#x2F;&#x2F; 使用substr获得子串                s_vec.push_back(temp); &#x2F;&#x2F; 将子串push进动态数组s_vec中                while (s[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; i &lt; s.length()) &#123;                    i++; &#x2F;&#x2F; 令i从其之后的第一个非空字母开始遍历                &#125;                left &#x3D; i; &#x2F;&#x2F; 更新left的值            &#125;        &#125;        if (s[s.length()-1] !&#x3D; &#39; &#39; &amp;&amp; s[s.length()-2] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 针对字符串最后的一个单词只有一个字母的特判            string temp &#x3D; s.substr(s.length()-1);            s_vec.push_back(temp);        &#125;        int n &#x3D; s_vec.size(); &#x2F;&#x2F; 获取动态数组的大小（也就是总的单词个数）        string result; &#x2F;&#x2F; 定义结果字符串        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123; &#x2F;&#x2F; 反向遍历，将结果同result相加            if (i &#x3D;&#x3D; n - 1) &#123; &#x2F;&#x2F; 第一个单词前无需加空格                result &#x3D; result + s_vec[i];            &#125;            else &#123; &#x2F;&#x2F; 其他单词在同result合并前需要先加一个空格                result &#x3D; result + &quot; &quot; + s_vec[i];             &#125;        &#125;        return result; &#x2F;&#x2F; 返回result字符串    &#125;&#125;;</code></pre><ul><li>空间复杂度为O(1)的解法</li></ul><ol><li>将整个字符串进行反转</li><li>将反转后的字符串的每个单词进行反转</li><li>去除字符串中多余的空格</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseWords(string s) &#123;        reverse(s.begin(), s.end()); &#x2F;&#x2F; 翻转整个字符串        int n &#x3D; s.size();        int idx &#x3D; 0;        for (int start &#x3D; 0; start &lt; n; ++start) &#123;            if (s[start] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 找到单词的起始位置                if (idx !&#x3D; 0) s[idx++] &#x3D; &#39; &#39;; &#x2F;&#x2F; 添加单词间空格                int end &#x3D; start;                while (end &lt; n &amp;&amp; s[end] !&#x3D; &#39; &#39;) s[idx++] &#x3D; s[end++]; &#x2F;&#x2F; 翻转单词                reverse(s.begin() + idx - (end - start), s.begin() + idx); &#x2F;&#x2F; 翻转单词                start &#x3D; end;            &#125;        &#125;        s.erase(s.begin() + idx, s.end()); &#x2F;&#x2F; 删除多余的空格        return s;    &#125;&#125;;</code></pre><blockquote><p>当我们调用reverse函数时，它会将字符串中的字符进行翻转。例如，如果我们有一个字符串”hello”，那么调用reverse函数后，它会变成”olleh”。在这个题目中，我们需要将整个字符串进行翻转，所以我们调用了reverse(s.begin(), s.end())函数来实现这个功能。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你反转字符串中 &lt;strong&gt;单词&lt;/strong&gt; 的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单词&lt;/strong&gt; 是由非空格字符组成的字符串。&lt;code&gt;s&lt;/code&gt; 中使用至少一个空格将字符串中的 &lt;strong&gt;单词&lt;/strong&gt; 分隔开。&lt;/p&gt;
&lt;p&gt;返回 &lt;strong&gt;单词&lt;/strong&gt; 顺序颠倒且 &lt;strong&gt;单词&lt;/strong&gt; 之间用单个空格连接的结果字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;输入字符串 &lt;code&gt;s&lt;/code&gt;中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>基于改进差分进化算法的云端科学工作流调度自适应故障检测策略</title>
    <link href="2023/03/21/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%91%E7%AB%AF%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%B0%83%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5/"/>
    <id>2023/03/21/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%91%E7%AB%AF%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%B0%83%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5/</id>
    <published>2023-03-21T12:03:37.000Z</published>
    <updated>2023-03-21T13:12:58.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于改进差分进化算法的云端科学工作流调度自适应故障检测策略"><a href="#基于改进差分进化算法的云端科学工作流调度自适应故障检测策略" class="headerlink" title="基于改进差分进化算法的云端科学工作流调度自适应故障检测策略"></a>基于改进差分进化算法的云端科学工作流调度自适应故障检测策略</h2><p>原题目：An adaptive fault detector strategy for scientific workflow scheduling based on improved differential evolution algorithm in cloud</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>讨论了在云计算环境中执行大规模科学工作流程的挑战，并提出了一种基于改进差分进化算法的<strong>自适应故障检测器策略</strong>，以最小化能源消耗、总成本和时间，并在调度科学工作流程时<strong>容忍故障</strong>。此外，该文章还介绍了一种自适应基于网络的模糊推理系统（ANFIS）预测模型，用于主动控制资源负载波动并提高故障预测准确性。</p><span id="more"></span><p><strong>通过对文章的阅读了解容错到底是什么</strong></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>介绍了在大规模的云计算环境中，错误会导致用于计算的虚拟机不可用，因此，通过提出一个有效且高效的容错策略来对错误发生时的问题进行处理是很有必要的。</p><p>传统方法进行容错的实现是需要了解云计算结构以及大量的知识和经验的，在实施时代价昂贵，且在缺少建模的条件下无法准确地进行容错评估。</p><p>在很多现实世界的工作流调度中，多目标优化方法可以用于优化虚拟机的任务调度以满足用户需求。然而大多数的现有方法并未考虑到容错技术的使用。</p><p>Differential evolution算法很高效，但也有陷入局部最优以及收敛过慢的问题，因此本文通过优化F和CR参数来解决这些问题</p><p>总的来说，本文的贡献是提出了一种自适应故障容错工作流调度方法，该方法基于改进差分进化算法和多目标IDE算法，结合主动和反应技术。该方法通过应用自适应基于网络的模糊推理系统（ANFIS）预测模型来预测未来资源负载，从而主动控制资源负载波动并提高故障预测准确性。此外，在故障&#x2F;失败发生后，该方法还通过反应性容错控制器来保证应用程序执行的可靠性。这种方法可以最小化能源消耗、总成本和时间，并在调度科学工作流程时容忍故障。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>本文的相关工作主要讨论了故障检测和容错技术在云计算环境中的应用。文章指出，故障发生在系统中表明任务执行能力的无法实现，可能发生在网络的任何节点或任何过程中的不同组件中。相关工作还探讨了云计算环境下的工作流调度问题，并介绍了一些传统方法，如遗传算法、蚁群算法和粒子群优化算法等。此外，相关工作还介绍了一些基于云计算环境的故障检测和容错技术，如虚拟机迁移、备份和恢复等。</p><p><img src="http://cdn.leafii.top/img/image-20230321202533280.png" alt="image-20230321202533280" loading="lazy"></p><h3 id="Workflow-model"><a href="#Workflow-model" class="headerlink" title="Workflow model"></a>Workflow model</h3><p>本文的工作流模型使用了直接无环图（DAG）来表示云计算环境中的工作流。该模型由一组任务和任务之间的依赖关系组成，其中每个任务都有一个权重，表示其参考值。具体地，该模型可以表示为： $W&#x3D;(T,D)$ 其中，$T&#x3D;{T_0,T_1,…,T_n}$是一组任务，$D&#x3D;{(T_i,T_j)|T_i,T_j \in T}$是任务之间的依赖关系集合。 每个任务都有一个权重$w_i$，表示其参考值。因此，我们可以将工作流模型表示为一个带权有向无环图（weighted directed acyclic graph），如下所示： $$G&#x3D;(V,E)$$ 其中，$V&#x3D;{v_0,v_1,…,v_n}$是节点集合，对应于任务集合$T$；$E&#x3D;{(v_i,v_j)|w_{ij}\neq 0}$是边集合，对应于依赖关系集合$D$。</p><p><img src="http://cdn.leafii.top/img/image-20230321202544971.png" alt="image-20230321202544971" loading="lazy"></p><blockquote><p>DAG是一种有向无环图，其中每个节点表示一个任务，每条边表示任务之间的依赖关系。在云计算环境中，DAG通常用于表示工作流模型，其中每个任务都有一个权重，表示其参考值。DAG可以帮助我们更好地理解和可视化工作流程，并且可以用于优化工作流程的调度和执行。在本文中，作者使用了一个样例DAG来说明其应用。</p></blockquote><h3 id="Proposed-framework"><a href="#Proposed-framework" class="headerlink" title="Proposed framework"></a>Proposed framework</h3><p>本文的proposed framework主要提出了一种基于自适应故障容错技术的多目标工作流调度框架。该框架使用了主动和反应技术来控制资源负载波动，并通过反应性容错控制器来保证应用程序执行的可靠性。具体来说，该框架包括以下组件： </p><ol><li>Workflow task queue：将用户提交的工作流程按照一定规则排列在队列中，等待分配到云数据中心的虚拟机上执行。</li><li>MAPE-k control loop：该控制循环由四个组件组成，包括monitor、analyzer、planner和executer。这些组件共享一个知识库，用于监测、分析、计划和执行工作流程。</li><li>ANFIS prediction model：该模型是一种自适应基于网络的模糊推理系统，用于预测未来资源负载，并通过主动控制资源负载波动来提高故障预测准确性。</li><li>Reactive fault-tolerant controller：该控制器是一种反应性容错技术，用于在故障&#x2F;失败发生后保证应用程序执行的可靠性。</li></ol><p> 本文提出的框架可以最小化能源消耗、总成本和时间，并在调度科学工作流程时容忍故障。</p><p><img src="http://cdn.leafii.top/img/image-20230321203418941.png" alt="image-20230321203418941" loading="lazy"></p><h4 id="Monitor-component"><a href="#Monitor-component" class="headerlink" title="Monitor component"></a>Monitor component</h4><p>Monitor component被描述为一个组件，其主要职责是收集云数据中心中的工作流任务信息和资源负载率。具体来说，用户传感器和资源传感器会在预定的时间间隔内从应用程序和云环境中收集足够的数据，并将其提供给Monitor component。其中，用户传感器的职责是收集用户工作流任务的信息（如请求速率、类型、大小等），而资源传感器的职责是收集资源负载率的信息（如CPU负载、应用内存和网络流量）。Monitor component会将监测到的数据进行整合，并存储在知识库中以供分析组件使用。</p><h4 id="Analyzer-component"><a href="#Analyzer-component" class="headerlink" title="Analyzer component"></a>Analyzer component</h4><p>在本文中，Analyzer component被描述为一个组件，其主要职责是分析Monitor component收集到的负载信息，并预测未来的资源负载。具体来说，Analyzer component使用ANFIS神经网络模型来预测未来的资源负载，并根据Monitor component的反馈进行调整。预测值会被传输到Planner component中，以便根据系统条件自适应地选择工作流调度算法。通过分析和预测资源负载，Analyzer component可以帮助实现负载均衡和最佳性能。</p><p>当Analyzer component接收到Monitor component传递的数据后，它会使用ANFIS神经网络模型来预测未来的资源负载。ANFIS模型是一种自适应基于网络的模糊推理系统，可以处理非线性和动态系统，并具有良好的泛化能力。在本文中，ANFIS模型被用于预测未来的资源负载，并根据Monitor component的反馈进行调整。具体来说，当预测值与实际值不匹配时，Analyzer component会根据误差信号对ANFIS模型进行调整，以提高预测准确性。 除了资源负载预测外，Analyzer component还可以执行其他分析任务，例如检查工作流任务之间的依赖关系、计算任务权重和优先级等。通过这些分析任务，Analyzer component可以帮助实现更好的工作流调度和执行效果。</p><h4 id="Fuzzy-Planner-component"><a href="#Fuzzy-Planner-component" class="headerlink" title="Fuzzy Planner component"></a>Fuzzy Planner component</h4><p>在本文中，Fuzzy Planner component被描述为一个组件，其主要职责是根据Analyzer component预测的资源负载来分配工作流任务到高效的云资源上。具体来说，Fuzzy Planner component使用三个模糊if-then规则来进行工作流任务分配： </p><ol><li>如果资源负载被预测为正常，则执行“无变化”命令，并调用IDE调度算法。 </li><li>如果资源负载被预测为高，则执行“未来可能发生错误”的命令，并调用主动容错控制器以减少负载。</li><li>如果资源负载被预测为非常高，则执行“故障发生”的命令。</li></ol><p> 这些规则是基于模糊逻辑和经验知识设计的，并可以根据实际情况进行修改和优化。通过使用Fuzzy Planner component，可以实现更好的工作流任务分配和资源利用率。</p><h5 id="IDE算法"><a href="#IDE算法" class="headerlink" title="IDE算法"></a>IDE算法</h5><p>在本文中，IDE算法的具体设计内容如下：</p><ol><li>初始化种群：首先，随机生成一组初始解作为种群，并计算每个解的适应度值。</li><li>变异操作：对于每个个体，随机选择另外两个不同的个体，并计算它们之间的差异向量。然后，将差异向量与当前个体进行加权和操作，得到一个新的变异向量。</li><li>交叉操作：将变异向量与当前个体进行交叉操作，得到一个新的解。</li><li>选择操作：根据适应度函数选择最优解，并将其作为下一代种群中的父代。</li><li>自适应参数设置：通过自适应参数设置技术来调整IDE算法中的参数。</li></ol><p>具体来说，通过监测种群中最优解和平均适应度值之间的差异来调整缩放因子和交叉概率等参数。 通过以上步骤，IDE算法可以在连续空间中寻找最优解，并且具有较好的收敛速度和搜索能力。</p><p>在本文中，IDE算法优化的目标是最小化工作流任务的makespan、总成本和能源消耗。具体来说，IDE算法的目标函数可以表示为： </p><p>$ f(x) &#x3D; w_1 \times makespan(x) + w_2 \times cost(x) + w_3 \times energy(x) $</p><p>其中，$x$表示工作流任务的调度方案，$makespan(x)$表示完成所有任务所需的时间，$cost(x)$表示执行任务所需的总成本，$energy(x)$表示执行任务所需的总能源消耗。$w_1, w_2, w_3$是权重系数，用于平衡不同目标之间的重要性。 通过优化上述目标函数，IDE算法可以得到一个最优的工作流调度方案，以实现更好的性能和效率。</p><h5 id="Proactive-fault-tolerance-controller"><a href="#Proactive-fault-tolerance-controller" class="headerlink" title="Proactive fault-tolerance controller"></a>Proactive fault-tolerance controller</h5><p>在本文中，Proactive fault-tolerance controller被描述为一种主动容错控制器，其主要目的是防止进入故障区域并将新负载分配给异常的虚拟机。具体来说，当Analyzer component检测到资源负载过高时，Fuzzy Planner component会调用Proactive fault-tolerance controller来减少负载并防止系统进入故障状态。 </p><p>Proactive fault-tolerance controller的实现方式是通过监测虚拟机的资源利用率和性能指标来判断是否存在异常情况。如果发现某个虚拟机出现了异常情况，则Proactive fault-tolerance controller会立即将其从负载均衡中移除，并将其上的任务重新分配给其他正常的虚拟机。这样可以避免故障扩散和系统崩溃。</p><p> 总之，Proactive fault-tolerance controller是一种有效的容错控制器，可以帮助云环境实现更好的容错性能和可靠性。</p><h5 id="Reactive-fault-tolerance-controller"><a href="#Reactive-fault-tolerance-controller" class="headerlink" title="Reactive fault-tolerance controller"></a>Reactive fault-tolerance controller</h5><p>在本文中，Reactive fault-tolerance controller被描述为一种响应式容错控制器，其主要目的是在故障发生后减少故障的影响。具体来说，当Analyzer component检测到某个虚拟机出现故障时，Fuzzy Planner component会调用Reactive fault-tolerance controller来处理故障并恢复系统正常运行。 </p><p>Reactive fault-tolerance controller的实现方式是通过使用复制技术来提供容错能力。具体来说，当某个虚拟机出现故障时，Reactive fault-tolerance controller会将该虚拟机上的任务复制到其他正常的虚拟机上，并重新分配这些任务以保证系统正常运行。这样可以避免任务丢失和系统崩溃。</p><p> 需要注意的是，Reactive fault-tolerance controller的主要缺点是成本较高。因为它需要额外的资源和计算能力来处理故障和执行复制操作。因此，在实际应用中需要权衡成本和性能之间的关系，并选择合适的容错策略。 </p><p>总之，Reactive fault-tolerance controller是一种有效的容错控制器，在云环境中可以帮助提高系统可靠性和容错性能。</p><h4 id="Executer-component-for-the-workflow-tasks-allocation"><a href="#Executer-component-for-the-workflow-tasks-allocation" class="headerlink" title="Executer component for the workflow tasks allocation"></a>Executer component for the workflow tasks allocation</h4><p>执行组件负责根据调度阶段执行的算法将用户发送的所有请求分配给现有的虚拟机。该组件负责实际执行规划组件决定的操作。</p><h3 id="Performance-evaluation"><a href="#Performance-evaluation" class="headerlink" title="Performance evaluation"></a>Performance evaluation</h3><p>实验部分不作具体分析</p><p>在本文中，“Performance evaluation”部分描述了作者如何评估所提出的工作流调度算法的性能。具体来说，作者使用了WorkflowSim-1.0工具包和CloudSim模拟器来模拟云环境中的工作流，并评估所提出的算法在不同负载下的性能表现。</p><p>在实验中，作者使用了一组实验设置，包括虚拟机数量、任务数量、任务大小等参数。通过对这些参数进行不同组合和调整，作者可以模拟不同负载下的云环境，并评估所提出算法的性能表现。 </p><p>最终，作者通过比较所提出算法和其他常用算法（如HEFT、Min-Min等）在不同负载下的性能指标（如makespan、总成本等）来评估其性能。实验结果表明，所提出算法可以显著提高系统性能和效率，并且在各项指标上均优于其他常用算法。 </p><p>总之，“Performance evaluation”部分描述了作者如何评估所提出算法的性能，并给出了实验结果和结论。这些结果可以帮助读者更好地理解该算法的优点和局限性，并为进一步研究和应用提供参考。</p><h4 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h4><p>“Conclusion and future work”部分是本文的结论和未来工作方向。具体来说，该部分总结了本文的主要贡献和发现，并提出了一些未来研究的方向。 </p><p>在结论部分，作者指出所提出的工作流调度算法可以显著提高云环境中的性能和效率，并且在各项指标上均优于其他常用算法。作者还强调了该算法的可扩展性和适应性，并指出它可以应用于不同类型的云环境和工作流场景。 </p><p>在未来工作方向中，作者提出了一些有待进一步研究的问题，如如何进一步优化算法性能、如何处理更复杂的工作流场景、如何实现更高效的容错机制等。这些问题都是当前云计算领域面临的挑战，也是未来研究需要解决的重要问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&quot;&gt;&lt;a href=&quot;#基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&quot; class=&quot;headerlink&quot; title=&quot;基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&quot;&gt;&lt;/a&gt;基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&lt;/h2&gt;&lt;p&gt;原题目：An adaptive fault detector strategy for scientific workflow scheduling based on improved differential evolution algorithm in cloud&lt;/p&gt;
&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;讨论了在云计算环境中执行大规模科学工作流程的挑战，并提出了一种基于改进差分进化算法的&lt;strong&gt;自适应故障检测器策略&lt;/strong&gt;，以最小化能源消耗、总成本和时间，并在调度科学工作流程时&lt;strong&gt;容忍故障&lt;/strong&gt;。此外，该文章还介绍了一种自适应基于网络的模糊推理系统（ANFIS）预测模型，用于主动控制资源负载波动并提高故障预测准确性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="进化算法" scheme="tags/进化算法/"/>
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode28.找出字符串中第一个匹配项的下标</title>
    <link href="2023/03/21/leetcode28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/"/>
    <id>2023/03/21/leetcode28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</id>
    <published>2023-03-21T08:03:49.000Z</published>
    <updated>2023-03-21T08:55:29.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：haystack &#x3D; &quot;sadbutsad&quot;, needle &#x3D; &quot;sad&quot;输出：0解释：&quot;sad&quot; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：haystack &#x3D; &quot;leetcode&quot;, needle &#x3D; &quot;leeto&quot;输出：-1解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>暴力解法</li></ol><p>首先判断haystack的长度是否小于needle，若小于则直接返回-1.然后对haystack进行遍历，若haystack[i]&#x3D;&#x3D;needle[0]，则说明haystack同needle的第一个字符匹配了，此时直接求haystack在i上长度为needle长度的子串并比较他们是否相等，若相等则直接返回i即可，否则继续遍历haystack。C++解法如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        int m &#x3D; haystack.length();         int n &#x3D; needle.length(); &#x2F;&#x2F; 分别求两个字符串的长度        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; 此判断符合strStr函数的原始定义        if (m &lt; n) return -1; &#x2F;&#x2F; 若haystack长度小于needle长度，则直接返回-1        for (int i &#x3D; 0; i &lt; m; i++) &#123; &#x2F;&#x2F; 遍历匹配第一个字母            if (haystack[i] &#x3D;&#x3D; needle[0]) &#123; &#x2F;&#x2F; 若第一个字母成功匹配                string temp &#x3D; haystack.substr(i, n); &#x2F;&#x2F; 直接求下标为i，长度同needle相等的子串temp                if (temp &#x3D;&#x3D; needle) &#123; &#x2F;&#x2F; 判断temp与needle是否相等                    return i; &#x2F;&#x2F; 若相等，则直接返回i                &#125;            &#125;        &#125;        return -1; &#x2F;&#x2F; 否则返回-1    &#125;&#125;;</code></pre><ol start="2"><li>KMP算法</li></ol><p>KMP的详细介绍：<a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html</a></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void getNext(int* next, const string&amp; s) &#123;        int j &#x3D; -1;        next[0] &#x3D; j;        for(int i &#x3D; 1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 注意i从1开始            while (j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; s[j+1]) &#123; &#x2F;&#x2F;前后缀不相同了                j &#x3D; next[j];            &#125;            if (s[i] &#x3D;&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 找到相同的前后缀                j++;            &#125;            next[i] &#x3D; j; &#x2F;&#x2F; 将j（前缀的长度）赋给next[i]        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if (needle.size() &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);        int j &#x3D; -1;        for (int i &#x3D; 0; i &lt; haystack.size(); i++) &#123; &#x2F;&#x2F; 注意i从0开始            while(j &gt;&#x3D; 0 &amp;&amp; haystack[i] !&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 不匹配                j &#x3D; next[j]; &#x2F;&#x2F; j寻找之前匹配的位置            &#125;            if (haystack[i] &#x3D;&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 匹配，j和i同时向后移动                j++;            &#125;            if (j &#x3D;&#x3D;(needle.size() - 1))  &#123; &#x2F;&#x2F; 文本串s里出现了模式串t                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;haystack&lt;/code&gt; 和 &lt;code&gt;needle&lt;/code&gt; ，请你在 &lt;code&gt;haystack&lt;/code&gt; 字符串中找出 &lt;code&gt;needle&lt;/code&gt; 字符串的第一个匹配项的下标（下标从 0 开始）。如果 &lt;code&gt;needle&lt;/code&gt; 不是 &lt;code&gt;haystack&lt;/code&gt; 的一部分，则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer05.替换空格</title>
    <link href="2023/03/20/%E5%89%91%E6%8C%87Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>2023/03/20/%E5%89%91%E6%8C%87Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2023-03-20T08:11:28.000Z</published>
    <updated>2023-03-20T08:16:16.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><p><strong>限制：</strong></p><pre class="language-none"><code class="language-none">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>常规思路</li></ul><p>新建一个string类型的变量result，对输入的字符串s的每个字符进行判断，若字符为空格，则<code>result+=&quot;%20;&quot;</code>，否则<code>result+=s[i];</code>，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string replaceSpace(string s) &#123;        string result &#x3D; &quot;&quot;; &#x2F;&#x2F; 定义结果字符串result        int n &#x3D; s.length(); &#x2F;&#x2F; 获取输入字符串s的长度        for(int i &#x3D; 0; i &lt; n; i++) &#123; &#x2F;&#x2F; 进行遍历            if (s[i] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 若s[i]为空格，则result+&#x3D;&quot;%20&quot;;                result +&#x3D; &quot;%20&quot;;            &#125;            else &#123; &#x2F;&#x2F; 否则直接+&#x3D;s[i];                result +&#x3D; s[i];            &#125;        &#125;        return result; &#x2F;&#x2F; 最后返回结果值result    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;请实现一个函数，把字符串 &lt;code&gt;s&lt;/code&gt; 中的每个空格替换成”%20”。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode541.反转字符串II</title>
    <link href="2023/03/19/leetcode541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II/"/>
    <id>2023/03/19/leetcode541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II/</id>
    <published>2023-03-19T06:36:21.000Z</published>
    <updated>2023-03-19T06:37:34.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2输出：&quot;bacdfeg&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;, k &#x3D; 2输出：&quot;bacd&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文组成</li><li><code>1 &lt;= k &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接进行交换即可</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int n &#x3D; s.size(); &#x2F;&#x2F; 字符串的长度        for (int i &#x3D; 0; i &lt; n; i +&#x3D; 2 * k) &#123; &#x2F;&#x2F; 每 2k 个字符为一组进行反转            int left &#x3D; i; &#x2F;&#x2F; 左边界            int right &#x3D; min(i + k - 1, n - 1); &#x2F;&#x2F; 右边界，注意防止越界            while (left &lt; right) &#123; &#x2F;&#x2F; 双指针反转                swap(s[left], s[right]); &#x2F;&#x2F; 交换左右指针对应的字符。                left++;                right--; &#x2F;&#x2F; 左右指针向中间移动。            &#125;        &#125;        return s; &#x2F;&#x2F; 返回反转后的字符串    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt;，从字符串开头算起，每计数至 &lt;code&gt;2k&lt;/code&gt; 个字符，就反转这 &lt;code&gt;2k&lt;/code&gt; 字符中的前 &lt;code&gt;k&lt;/code&gt; 个字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果剩余字符少于 &lt;code&gt;k&lt;/code&gt; 个，则将剩余字符全部反转。&lt;/li&gt;
&lt;li&gt;如果剩余字符小于 &lt;code&gt;2k&lt;/code&gt; 但大于或等于 &lt;code&gt;k&lt;/code&gt; 个，则反转前 &lt;code&gt;k&lt;/code&gt; 个字符，其余字符保持原样。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode124.二叉树中的最大路径和</title>
    <link href="2023/03/16/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>2023/03/16/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2023-03-16T07:56:05.000Z</published>
    <updated>2023-03-16T08:00:27.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/exx1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/exx2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>树形DP<ol><li>首先判断当前节点是否为 null，若为 null 则返回 0。</li><li>递归计算当前节点的左子树和右子树的最大路径和，分别为 <code>left</code> 和 <code>right</code>。</li><li>计算当前子树中包含当前节点的最大路径和 <code>curMax</code>，公式为 <code>node-&gt;val + max(0, max(left, right))</code>，其中 <code>node-&gt;val</code> 表示当前节点的值，<code>max(left, right)</code> 表示当前子树中不包含当前节点的最大路径和，<code>max(0, ...)</code> 的作用是保证当前子树中的路径和一定是非负数。</li><li>更新全局最大路径和 <code>res</code>，公式为 <code>max(res, left+right+node-&gt;val)</code>，其中 <code>left+right+node-&gt;val</code> 表示当前子树中包含当前节点的路径和。</li><li>返回当前子树的最大路径和 <code>curMax</code>。</li></ol></li></ol><p>在递归计算时，每个节点都会计算自己为根节点的最大路径和，并更新全局最大路径和。最终返回的是整棵树中的最大路径和。</p><p>这种递归思路在处理树形结构的问题时非常常见，被称为树形 DP（动态规划）。通过递归计算子树的最大路径和，并将结果传递给父节点，最终得到整棵树的最大路径和。C++代码实现如下:</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxPathSum(TreeNode* root) &#123;        int res &#x3D; INT_MIN;        dfs(root, res);        return res;    &#125;    int dfs(TreeNode* root, int&amp; res) &#123;        if (!root) return 0;        int left &#x3D; max(0, dfs(root-&gt;left, res)); &#x2F;&#x2F; 左子树的最大贡献值        int right &#x3D; max(0, dfs(root-&gt;right, res)); &#x2F;&#x2F; 右子树的最大贡献值        res &#x3D; max(res, root-&gt;val + left + right); &#x2F;&#x2F; 更新最大路径和        return root-&gt;val + max(left, right); &#x2F;&#x2F; 返回当前子树的最大路径和    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt; 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 &lt;strong&gt;至多出现一次&lt;/strong&gt; 。该路径 &lt;strong&gt;至少包含一个&lt;/strong&gt; 节点，且不一定经过根节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路径和&lt;/strong&gt; 是路径中各节点值的总和。&lt;/p&gt;
&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其 &lt;strong&gt;最大路径和&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode105.从前序与中序遍历序列构造二叉树</title>
    <link href="2023/03/16/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/16/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-16T06:24:30.000Z</published>
    <updated>2023-03-16T06:27:34.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p> <span id="more"></span><p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/tree-20230316142527347.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]输出: [3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]输出: [-1]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>同<a href="https://leafii.top/2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">106的解法</a>相似,因此在这里只提供代码.</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        &#x2F;&#x2F; 创建根节点        TreeNode* root &#x3D; build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);        return root;    &#125;        TreeNode* build(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd, vector&lt;int&gt;&amp; inorder, int inStart, int inEnd) &#123;        &#x2F;&#x2F; 特判：preStart &gt; preEnd 时，已经没有节点需要处理，返回 NULL        if (preStart &gt; preEnd) &#123;            return nullptr;        &#125;                &#x2F;&#x2F; 创建当前子树的根节点        TreeNode* root &#x3D; new TreeNode(preorder[preStart]);                &#x2F;&#x2F; 在中序遍历序列中查找当前子树根节点的位置        int inRootIndex &#x3D; inStart;        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;            inRootIndex++;        &#125;                &#x2F;&#x2F; 计算当前子树左子树的大小        int leftTreeSize &#x3D; inRootIndex - inStart;                &#x2F;&#x2F; 递归构建当前子树的左子树和右子树        root-&gt;left &#x3D; build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inRootIndex - 1);        root-&gt;right &#x3D; build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inRootIndex + 1, inEnd);                &#x2F;&#x2F; 返回当前子树的根节点        return root;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 &lt;code&gt;preorder&lt;/code&gt; 和 &lt;code&gt;inorder&lt;/code&gt; ，其中 &lt;code&gt;preorder&lt;/code&gt; 是二叉树的&lt;strong&gt;先序遍历&lt;/strong&gt;， &lt;code&gt;inorder&lt;/code&gt; 是同一棵树的&lt;strong&gt;中序遍历&lt;/strong&gt;，请构造二叉树并返回其根节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode106.从中序与后序遍历序列构造二叉树</title>
    <link href="2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-15T09:27:14.000Z</published>
    <updated>2023-03-16T06:23:59.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p> <span id="more"></span><p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/tree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]输出：[3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入：inorder &#x3D; [-1], postorder &#x3D; [-1]输出：[-1]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归构造</li></ul><p>根据题意，可以得知后序遍历的最后一个元素一定是树的根节点。然后可以在中序遍历中找到该根节点，以此将树分为左子树和右子树。对于左子树和右子树，可以再分别在中序遍历和后序遍历中找到其根节点，以此类推。</p><p>所以该问题可以使用递归的方式解决，每次递归时，先找到后序遍历的最后一个元素作为根节点，在中序遍历中找到该根节点，以此将树分为左子树和右子树。再分别递归左子树和右子树构建二叉树。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        &#x2F;&#x2F; 创建根节点        TreeNode* root &#x3D; build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);        return root;    &#125;    TreeNode* build(vector&lt;int&gt;&amp; inorder, int inStart, int inEnd, vector&lt;int&gt;&amp; postorder, int postStart, int postEnd) &#123;      &#x2F;*            inorder：中序遍历序列；            postorder：后序遍历序列；            inStart：当前子树在中序遍历序列中的起始位置；            inEnd：当前子树在中序遍历序列中的结束位置；            postStart：当前子树在后序遍历序列中的起始位置；            postEnd：当前子树在后序遍历序列中的结束位置。        *&#x2F;        &#x2F;&#x2F; 特判： 若postStart &gt; postEnd时， 无节点需要处理，返回NULL        if (postStart &gt; postEnd) &#123;            return nullptr;        &#125;        &#x2F;&#x2F; 创建新的子树根节点        TreeNode* root &#x3D; new TreeNode(postorder[postEnd]); &#x2F;&#x2F; 后续遍历的最后一个元素一定是根节点        &#x2F;&#x2F; 在中序遍历中寻找当前子树根节点的位置        int inRootIndex &#x3D; inStart;        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;            inRootIndex++;        &#125;        &#x2F;&#x2F; 计算当前子树左子树的大小        int leftTreeSize &#x3D; inRootIndex - inStart;                &#x2F;&#x2F; 根据根节点的位置， 分别递归构建左子树和右子树         root-&gt;left &#x3D; build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);        root-&gt;right &#x3D; build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1);         return root;    &#125;&#125;;</code></pre><p>关于<code>root-&gt;left = build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);</code>和<code>root-&gt;right = build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1); </code>的解释：</p><blockquote><p>在中序遍历中找到了根节点的位置后，在中序遍历中根节点的左边就是左子树的中序遍历，根节点的右边就是右子树的中序遍历，在递归调用时，左子树的中序遍历的右边界指针指向根节点索引-1，同理右子树的中序遍历的左边界指针指向根节点索引+1；计算了左子树的大小之后，可以发现在后序遍历中，从最开始到左子树的大小-1的元素即为左子树对应的后序遍历，因此从最开始索引+左子树大小到最右边索引-1的后序遍历即为右子树的后序遍历，这样一直递归即可得到完整的左右子树，将子树同根节点连接，返回根节点即可得到完整的树。</p></blockquote><p>在整个递归的过程中，我们都不需要额外的空间来存储子数组，而是通过起始和结束下标来表示子数组。这种方式使得我们可以使用较少的空间来解决问题，并且在递归过程中也不需要频繁地拷贝数组，提高了算法的效率。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 &lt;code&gt;inorder&lt;/code&gt; 和 &lt;code&gt;postorder&lt;/code&gt; ，其中 &lt;code&gt;inorder&lt;/code&gt; 是二叉树的中序遍历， &lt;code&gt;postorder&lt;/code&gt; 是同一棵树的后序遍历，请你构造并返回这颗 &lt;em&gt;二叉树&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode102.二叉树的层序遍历</title>
    <link href="2023/03/14/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>2023/03/14/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-03-14T01:57:14.000Z</published>
    <updated>2023-03-14T02:20:22.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p> <span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用队列辅助层序遍历</li></ol><p>注意看这个题的输入与输出，输出的动态数组的元素是元素为整型的数组，比如<code>[[3],[9,20],[15,7]]</code>.因此如果只定义一个队列辅助遍历，无法清晰的区分每层的元素应该插入到哪个数组中，比如如果只使用一个队列进行层次遍历，得到的结果只能是<code>[3,9,20,15,7]</code>，无法从这个结果中得知清晰的二叉树层次结构，所以在这里定义两个队列，首先向一个队列中塞入元素，接着对队首元素进行pop并且将队首元素的左右子树节点分别塞入另一队列中，再将结果数组并入result数组中，再将另一个队列进行同样的遍历操作，具体的C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        &#x2F;&#x2F; 定义两个队列 分别为q和another_q 用于层次遍历        queue&lt;TreeNode*&gt; q;        queue&lt;TreeNode*&gt; another_q;        &#x2F;&#x2F; 定义结果数组 其元素为元素为int类型的数组        vector&lt;vector&lt;int&gt;&gt; result;            &#x2F;&#x2F; 若根节点非空 则将根节点push进队列q中         if (root !&#x3D; nullptr) &#123;            q.push(root);        &#125;        &#x2F;&#x2F; 当q或者another_q队列非空时 进行遍历操作        while (!q.empty()|| !another_q.empty()) &#123;            &#x2F;&#x2F; 定义元素为int的临时数组 用于存储每一层的元素            vector&lt;int&gt; temp_vector;            &#x2F;&#x2F; 当队列q非空时 将队列q的元素逐个出队            while (!q.empty()) &#123;                TreeNode* temp_node &#x3D; q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;            &#x2F;&#x2F; 当另一个队列another_q非空时 将队列another_q的元素逐个出队            while (!another_q.empty()) &#123;                TreeNode* temp_node &#x3D; another_q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                another_q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;        &#125;        &#x2F;&#x2F; 返回结果数组        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;层序遍历&lt;/strong&gt; 。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode104.二叉树的最大深度</title>
    <link href="2023/03/13/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>2023/03/13/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2023-03-13T07:17:04.000Z</published>
    <updated>2023-03-14T02:20:19.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><pre class="language-none"><code class="language-none">  3 &#x2F; \9  20  &#x2F;  \ 15   7</code></pre><p>返回它的最大深度 3 。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>DFS（深度优先遍历）</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;      &#x2F;&#x2F; 如果当前节点为空，则返回0        if (root &#x3D;&#x3D; nullptr) return 0;      &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) return 1;        int left_depth &#x3D; -1, right_depth &#x3D; -1;      &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度        if (root-&gt;left !&#x3D; nullptr) &#123;            left_depth &#x3D; maxDepth(root-&gt;left);        &#125;      &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度        if (root-&gt;right !&#x3D; nullptr) &#123;            right_depth &#x3D; maxDepth(root-&gt;right);        &#125;      &#x2F;&#x2F; 返回左右子树深度的较大值加1        return max(left_depth, right_depth) + 1;    &#125;&#125;;</code></pre><ol start="2"><li>BFS（广度优先遍历）</li></ol><p>主要思路是使用一个队列来遍历整个二叉树。我们首先将根节点加入队列中，然后在每次循环中取出队列中的一层节点，将该层节点的左右子节点加入队列中。当遍历完所有节点时，队列中存储的即为最后一层节点，此时的深度即为树的深度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) &#123;            return 0;        &#125;        queue&lt;TreeNode*&gt; q;  &#x2F;&#x2F; 创建一个队列，用于BFS遍历        q.push(root);        &#x2F;&#x2F; 将根节点加入队列        int depth &#x3D; 0;       &#x2F;&#x2F; 初始化深度为0        while (!q.empty()) &#123; &#x2F;&#x2F; 当队列不为空时，继续遍历            int size &#x3D; q.size(); &#x2F;&#x2F; 记录队列中当前层的节点数量            for (int i &#x3D; 0; i &lt; size; i++) &#123; &#x2F;&#x2F; 遍历当前层的所有节点                TreeNode* node &#x3D; q.front();  &#x2F;&#x2F; 取出队列头部的节点                q.pop();                     &#x2F;&#x2F; 将该节点从队列中移除                if (node-&gt;left !&#x3D; NULL) &#123;    &#x2F;&#x2F; 如果该节点有左子节点，将其加入队列中                    q.push(node-&gt;left);                &#125;                if (node-&gt;right !&#x3D; NULL) &#123;   &#x2F;&#x2F; 如果该节点有右子节点，将其加入队列中                    q.push(node-&gt;right);                &#125;            &#125;            depth++;  &#x2F;&#x2F; 当前层遍历结束后，深度加1        &#125;        return depth; &#x2F;&#x2F; 返回树的深度    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;
&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode111.二叉树的最小深度</title>
    <link href="2023/03/12/leetcode111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>2023/03/12/leetcode111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</id>
    <published>2023-03-12T11:56:24.000Z</published>
    <updated>2023-03-13T07:50:42.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ex_depth.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]输出：5</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>DFS（深度优先遍历）</li></ol><p>使用了递归的方式。首先判断根节点是否为空，如果为空，则返回深度为0；如果根节点没有左右子节点，返回深度为1；如果有左右子节点，则分别递归计算左子树和右子树的深度，取两者的较小值再加1，即为该树的最小深度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        &#x2F;&#x2F; 如果当前节点为空，则返回0        if (root &#x3D;&#x3D; nullptr) &#123;            return 0;        &#125;        &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;            return 1;        &#125;        int left_depth &#x3D; INT_MAX, right_depth &#x3D; INT_MAX;        &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度        if (root-&gt;left !&#x3D; nullptr) &#123;            left_depth &#x3D; minDepth(root-&gt;left);        &#125;        &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度        if (root-&gt;right !&#x3D; nullptr) &#123;            right_depth &#x3D; minDepth(root-&gt;right);        &#125;        &#x2F;&#x2F; 返回左右子树深度的较小值加1        return min(left_depth, right_depth) + 1;    &#125;&#125;;</code></pre><ol start="2"><li>BFS（广度优先遍历）</li></ol><p>该代码使用了队列来实现广度优先搜索，从根节点开始，逐层访问该节点的左右子节点，并将子节点及其所在的层数入队，直到找到叶子节点，即没有左右子节点的节点，此时返回该节点所在的层数即可。如果整个二叉树中没有叶子节点，则返回0。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return 0;        &#125;        &#x2F;&#x2F; 创建队列， 存储节点以及其所在的层数        queue&lt;pair&lt;TreeNode*, int&gt;&gt; q;        &#x2F;&#x2F; 将根节点和所在的层数入队        q.push(make_pair(root, 1));        while (!q.empty()) &#123;            &#x2F;&#x2F; 取出队首节点和所在的层数            TreeNode* node &#x3D; q.front().first;            int depth &#x3D; q.front().second;            q.pop();            &#x2F;&#x2F; 如果该节点为叶子节点， 直接返回其所在的层数            if (node-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; node-&gt;right &#x3D;&#x3D; nullptr) &#123;                return depth;            &#125;            &#x2F;&#x2F; 如果该节点有左子节点，则将其左子节点和所在的层数入队            if (node-&gt;left !&#x3D; nullptr) &#123;                q.push(make_pair(node-&gt;left, depth+1));                &#125;            &#x2F;&#x2F; 如果该节点有右子节点，则将其右子节点和所在的层数入队            if (node-&gt;right !&#x3D; nullptr) &#123;                q.push(make_pair(node-&gt;right, depth+1));                &#125;        &#125;        return 0;    &#125;&#125;;</code></pre><blockquote><p>一般来说，DFS和BFS的效率取决于二叉树的结构和分布。如果二叉树比较平衡，那么BFS可能更快，因为它可以更早地找到最小深度的叶子节点。如果二叉树比较不平衡，那么DFS可能更快，因为它可以避免访问很多不必要的节点。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;/p&gt;
&lt;p&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;叶子节点是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode25.K个一组翻转链表</title>
    <link href="2023/03/09/leetcode25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/09/leetcode25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-09T09:07:29.000Z</published>
    <updated>2023-03-09T09:22:48.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/reverse_ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2输出：[2,1,4,3,5]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/reverse_ex2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3输出：[3,2,1,4,5]</code></pre><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>编写一个函数，用于实现反转链表的核心逻辑，思路如下：</p><ul><li><p>初始化一个前驱节点prev和一个当前节点curr，分别指向空和头节点。</p></li><li><p>循环k次，每次做以下操作：</p><ul><li><p>保存当前节点的下一个节点next，以免丢失。</p></li><li><p>将当前节点的next指针指向前驱节点prev，实现反转。</p></li><li><p>将前驱节点prev更新为当前节点curr，为下一次反转做准备。</p></li><li><p>将当前节点curr更新为下一个节点next，继续遍历链表。</p></li></ul></li></ul><p>这样就可以将链表中的k个节点反转，并返回反转后的头尾指针。</p><blockquote><p>对以上函数进行一个图示说明：</p><p>假设链表为1-&gt;2-&gt;3-&gt;4-&gt;5，k为3，那么反转后的链表应该为3-&gt;2-&gt;1-&gt;4-&gt;5。</p><p>初始状态：</p><pre class="language-text" data-language="text"><code class="language-text">prev: nullcurr: 1next: 2null &lt;- prev   curr -> next -> 3 -> 4 -> 5</code></pre><p>第一次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 1curr: 2next: 3null &lt;- prev &lt;- curr   next -> 4 -> 5</code></pre><p>第二次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 2curr: 3next: 4null &lt;- prev &lt;- curr   next -> 5</code></pre><p>第三次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 3curr: 4next: 5null &lt;- prev &lt;- curr   next </code></pre><p>结束循环，返回{prev, head}即{3,1}。</p><pre class="language-text" data-language="text"><code class="language-text"> prev        head   |           |  v           v null&lt;-3&lt;-2&lt;-1    4->5 </code></pre></blockquote><p>代码的整体思路是：</p><ul><li>定义一个虚拟头节点dummy，指向原链表的头节点head，这样可以方便处理边界情况。</li><li>定义一个前驱节点prev，初始指向dummy，用来连接反转后的链表段。</li><li>用一个while循环遍历整个链表，每次循环做以下操作：<ul><li>定义一个尾部指针tail，初始指向头部指针head，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回dummy-&gt;next即可。</li><li>保存下一段链表的头部指针nextHead，并断开与当前段的连接。</li><li>调用反转函数reverseList，输入当前段的头部指针head和长度k，返回反转后的新头部和新尾部，并将其连接到前驱和下一段上。</li><li>更新前驱为新尾部，更新头部为下一段头部。</li></ul></li></ul><p>这样就可以将整个链表按照每k个节点进行反转，并返回dummy-&gt;next作为新链表的头节点。</p><p>代码的时间复杂度是O(n)，因为我们只需要遍历一次链表，每个节点最多被访问两次。 代码的空间复杂度是O(1)，因为我们只使用了常数个额外变量，没有使用递归或栈。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 定义反转链表的函数，输入一个链表头节点和一个长度k，返回反转后的头节点和尾节点    pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, int k) &#123;        &#x2F;&#x2F; 初始化前驱节点和当前节点        ListNode* prev &#x3D; nullptr;        ListNode* curr &#x3D; head;        &#x2F;&#x2F; 遍历k次，每次将当前节点指向前驱节点，并更新前驱和当前节点        for (int i &#x3D; 0; i &lt; k; i++) &#123;            ListNode* next &#x3D; curr-&gt;next; &#x2F;&#x2F; 保存下一个节点            curr-&gt;next &#x3D; prev; &#x2F;&#x2F; 反转指针            prev &#x3D; curr; &#x2F;&#x2F; 更新前驱            curr &#x3D; next; &#x2F;&#x2F; 更新当前        &#125;        &#x2F;&#x2F; 返回反转后的头节点和尾节点，即原来的尾节点和头节点        return &#123;prev, head&#125;;    &#125;    &#x2F;&#x2F; 定义leetcode 25的主函数，输入一个链表头节点和一个整数k，返回反转后的链表头节点    ListNode* reverseKGroup(ListNode* head, int k) &#123;        &#x2F;&#x2F; 初始化虚拟头节点和前驱节点        ListNode* dummy &#x3D; new ListNode(-1);        dummy-&gt;next &#x3D; head;        ListNode* prev &#x3D; dummy;                while (head !&#x3D; nullptr) &#123; &#x2F;&#x2F; 遍历链表直到为空            &#x2F;&#x2F; 初始化尾部指针为头部指针，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回虚拟头节点的下一个即可            ListNode* tail &#x3D; head;            for (int i &#x3D; 0; i &lt; k - 1; i++) &#123;                tail &#x3D; tail-&gt;next;                if (tail &#x3D;&#x3D; nullptr) return dummy-&gt;next;            &#125;                        &#x2F;&#x2F; 保存下一段链表的头部指针，并断开与当前段的连接            ListNode* nextHead &#x3D; tail-&gt;next;            tail-&gt;next &#x3D; nullptr;            &#x2F;&#x2F; 调用反转函数，得到反转后的新头部和新尾部，并将其连接到前驱和下一段上            auto reversedPair &#x3D; reverseList(head, k);            prev-&gt;next &#x3D; reversedPair.first;            reversedPair.second-&gt;next &#x3D; nextHead;            &#x2F;&#x2F; 更新前驱为新尾部，更新头部为下一段头部            prev &#x3D; reversedPair.second;            head &#x3D; nextHead;                    &#125;            return dummy-&gt;next;     &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你链表的头节点 &lt;code&gt;head&lt;/code&gt; ，每 &lt;code&gt;k&lt;/code&gt; 个节点一组进行翻转，请你返回修改后的链表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 &lt;code&gt;k&lt;/code&gt; 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode148.排序链表</title>
    <link href="2023/03/08/leetcode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/08/leetcode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-08T05:42:24.000Z</published>
    <updated>2023-03-10T08:26:30.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [4,2,1,3]输出：[1,2,3,4]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [-1,5,3,4,0]输出：[-1,0,3,4,5]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>为了解题而解题的解法</li></ol><p>建立一个动态数组nodes，将链表中的每个元素放入动态数组中，然后使用sort排序，接着将动态数组进行遍历，将每个数字新建一个节点放入结果链表中，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        vector&lt;int&gt; nodes;        while (head !&#x3D; nullptr) &#123;            nodes.push_back(head-&gt;val); &#x2F;&#x2F; 将链表的每个节点的值放入动态数组中            head &#x3D; head-&gt;next;        &#125;        sort(nodes.begin(), nodes.end()); &#x2F;&#x2F; 对动态数组中的元素进行排序        ListNode* sortedList &#x3D; nullptr;        ListNode** cur &#x3D; &amp;sortedList; &#x2F;&#x2F; 定义一个指向指针的指针 cur                for (auto node_num: nodes) &#123;            *cur &#x3D; new ListNode(node_num); &#x2F;&#x2F; 将排序好的数字加入新链表中            cur &#x3D; &amp;((*cur)-&gt;next);        &#125;        return sortedList; &#x2F;&#x2F; 返回链表头节点    &#125;&#125;;</code></pre><blockquote><p>这段代码涉及了指针和地址的操作，可以解读为：</p><p>​        ListNode** cur：定义一个指向指针的指针 cur</p><p>​        &amp;sortedList：获取 sortedList 的地址，也就是一个指向指针 sortedList 的指针</p><p>​        cur &#x3D; &amp;sortedList：将 sortedList 的地址赋值给 cur，此时 cur 指向 sortedList 的指针</p><p> 这样做的目的是为了可以更改 sortedList 的指针，从而修改链表结构。在 for 循环中，*cur 表示指针 cur 所指向的指针，即 sortedList 的指针，将新的节点插入到 sortedList 后，cur 需要指向插入节点的 next 指针，因此使用了 cur &#x3D; &amp;((*cur)-&gt;next) 的写法。</p></blockquote><ol start="2"><li>归并排序</li></ol><p>归并排序的思路如下：利用快慢指针将链表分为左链表和右链表，分而治之，将分得的两个链表进行再一次分割和归并，最终归并得到结果。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    &#x2F;&#x2F; 归并排序    ListNode* sortList(ListNode* head) &#123;        &#x2F;&#x2F; 如果链表为空或只有一个节点，直接返回        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) return head;        &#x2F;&#x2F; 找到链表的中点，用快慢指针法        ListNode* slow &#x3D; head; &#x2F;&#x2F; 慢指针，每次走一步        ListNode* fast &#x3D; head-&gt;next; &#x2F;&#x2F; 快指针，每次走两步        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;            slow &#x3D; slow-&gt;next; &#x2F;&#x2F; 慢指针走到中点            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走到末尾或者null        &#125;        &#x2F;&#x2F; 将链表从中点断开为两个子链表        ListNode* mid &#x3D; slow-&gt;next;         slow-&gt;next &#x3D; nullptr;        &#x2F;&#x2F; 对左右子链表分别进行排序        ListNode* left &#x3D; sortList(head);         ListNode* right &#x3D; sortList(mid);        &#x2F;&#x2F; 合并两个有序的子链表为一个有序的链表        return mergeTwoLists(left, right);    &#125;    &#x2F;&#x2F; 合并两个有序的链表为一个有序的链表    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        &#x2F;&#x2F; 创建一个哑节点作为合并后链表的头结点        ListNode dummy(0);        &#x2F;&#x2F; 创建一个指针cur指向当前合并后链表的最后一个节点，初始为哑节点        ListNode* cur &#x3D; &amp;dummy;        &#x2F;&#x2F; 当l1和l2都不为空时，比较它们的值，将较小的值接在cur后面，并更新对应的指针while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;if (l1-&gt;val &lt; l2-&gt;val) &#123; cur-&gt;next &#x3D; l1; l1 &#x3D; l1-&gt;next;&#125; else &#123; cur-&gt;next &#x3D; l2; l2 &#x3D; l2-&gt;next;&#125;cur &#x3D; cur-&gt;next; &#125;        &#x2F;&#x2F; 当l1或l2有一个为空时，直接将另一个非空的链表接在cur后面即可        if (l1 !&#x3D; nullptr) cur-&gt;next &#x3D; l1;        if (l2 !&#x3D; nullptr) cur-&gt;next &#x3D; l2;        return dummy.next;  &#x2F;&#x2F; 返回哑节点的下一个节点，即合并后链表的头结点    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你链表的头结点 &lt;code&gt;head&lt;/code&gt; ，请将其按 &lt;strong&gt;升序&lt;/strong&gt; 排列并返回 &lt;strong&gt;排序后的链表&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode142.环形链表II</title>
    <link href="2023/03/06/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <id>2023/03/06/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</id>
    <published>2023-03-06T12:44:53.000Z</published>
    <updated>2023-03-06T14:22:34.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist-20230306204553902.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test2-20230306204600878.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2], pos &#x3D; 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test3-20230306204608161.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1], pos &#x3D; -1输出：返回 null解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用hashset存储链表元素的地址，当使用快慢指针确定环形链表存在时，返回相应的环形节点。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#x2F;&#x2F; 如果链表为空或者只有一个元素，则返回null            return nullptr;         ListNode* slow &#x3D; head;        ListNode* fast &#x3D; head-&gt;next;        while (slow !&#x3D; fast) &#123;            if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) return nullptr;            fast &#x3D; fast-&gt;next-&gt;next;            slow &#x3D; slow-&gt;next;        &#125;        &#x2F;&#x2F;此时已经发现有环了，使用hashset存储链表元素地址，若有相同地址的元素就返回该元素        unordered_set&lt;ListNode*&gt; nodes;        ListNode* cur &#x3D; head;        while (cur !&#x3D; nullptr) &#123;            if (nodes.count(cur)) &#123;                return cur;            &#125;            else &#123;                nodes.insert(cur);                cur &#x3D; cur-&gt;next;            &#125;        &#125;        return nullptr;    &#125;&#125;;</code></pre><ol start="2"><li>快慢指针法</li></ol><p>利用快慢指针，找到链表中是否存在环。若存在环，则将快指针重新指向链表的头结点，并将快慢指针以相同的速度向前移动，直到两个指针相遇，即为环的入口节点。</p><p>假设链表的长度为L，环的长度为C，环的入口节点距离头节点的距离为A，快慢指针相遇的节点距离环的入口节点的距离为B。</p><p>当快慢指针相遇时，快指针走过的距离是慢指针的两倍，即：$2 \times (A + B) &#x3D; A + B + n \times C$其中n是快指针在环中走过的圈数。化简得：$A &#x3D; (n - 1) \times C + (C - B)$。这个式子的意义是，从头节点到环的入口节点的距离等于从相遇点到环的入口节点的距离加上(n - 1)圈的环的长度。</p><p>因此，如果让一个新的指针cur从头节点开始走，同时让slow从相遇点开始走，每次都走一步，那么它们会在环的入口节点相遇，因为它们走过的距离都是A。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        &#x2F;&#x2F; 判断链表是否为空或只有一个元素        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) &#123;            return NULL;        &#125;        &#x2F;&#x2F; 定义快慢指针，初始值指向头结点        ListNode* fast &#x3D; head;        ListNode* slow &#x3D; head;        &#x2F;&#x2F; 判断是否存在环        while (fast !&#x3D; NULL &amp;&amp; fast-&gt;next !&#x3D; NULL) &#123;            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走两步            slow &#x3D; slow-&gt;next;       &#x2F;&#x2F; 慢指针走一步            if (fast &#x3D;&#x3D; slow) &#123;      &#x2F;&#x2F; 快慢指针相遇                ListNode* start &#x3D; head; &#x2F;&#x2F; 从头结点开始，与慢指针同时前进，相遇点即为环的起点                while (start !&#x3D; slow) &#123;                    start &#x3D; start-&gt;next;                    slow &#x3D; slow-&gt;next;                &#125;                return start;            &#125;        &#125;        return NULL; &#x2F;&#x2F; 遍历完链表，仍未找到环，返回NULL    &#125;&#125;;</code></pre><blockquote><p>注：在 while 循环中，因为 fast 比 slow 快，所以应该先判断 fast 是否为 NULL 或 fast-&gt;next 是否为 NULL，以保证程序的正确性。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个链表的头节点  &lt;code&gt;head&lt;/code&gt; ，返回链表开始入环的第一个节点。 &lt;em&gt;如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 &lt;code&gt;next&lt;/code&gt; 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（&lt;strong&gt;索引从 0 开始&lt;/strong&gt;）。如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;strong&gt;注意：&lt;code&gt;pos&lt;/code&gt; 不作为参数进行传递&lt;/strong&gt;，仅仅是为了标识链表的实际情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不允许修改&lt;/strong&gt; 链表。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode160.相交链表</title>
    <link href="2023/03/06/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/06/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-06T07:18:58.000Z</published>
    <updated>2023-03-06T07:20:59.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><span id="more"></span><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><img src="http://cdn.leafii.top/img/160_statement.png" alt="img" loading="lazy"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/160_example_1_1.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3输出：Intersected at &#39;8&#39;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/160_example_2.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1输出：Intersected at &#39;2&#39;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/160_example_3.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。</code></pre><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>尾部对齐法</li></ol><p>因为当两链表相交时，它们从相交的节点开始到尾节点都是重叠的，因此首先依次遍历两个链表，获取两个链表的长度，然后将长度更长的链表进行对齐操作，之后分别比较对齐后的两链表的元素，若不相等，则分别迭代为next指针指向的元素，若两元素相等，则返回任意一个元素，若不相等，则遍历结束后返回<code>null</code>.</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        &#x2F;&#x2F; 分别计算两个链表的长度        int lenA &#x3D; 0, lenB &#x3D; 0;        ListNode* curA &#x3D; headA;        ListNode* curB &#x3D; headB;        while (curA) &#123;            lenA++;            curA &#x3D; curA-&gt;next;        &#125;        while (curB) &#123;            lenB++;            curB &#x3D; curB-&gt;next;        &#125;        &#x2F;&#x2F; 将较长的链表向后移动，使它们的尾部对齐        curA &#x3D; headA;        curB &#x3D; headB;        if (lenA &gt; lenB) &#123;            for (int i &#x3D; 0; i &lt; (lenA - lenB); i++) &#123;                curA &#x3D; curA-&gt;next;            &#125;        &#125;        else &#123;            for (int i &#x3D; 0; i &lt; (lenB - lenA); i++) &#123;                curB &#x3D; curB-&gt;next;            &#125;        &#125;        while (curA !&#x3D; curB) &#123;            curA &#x3D; curA-&gt;next;            curB &#x3D; curB-&gt;next;        &#125;        if (curA !&#x3D; nullptr) return curA;                return nullptr;    &#125;    &#125;;</code></pre><ol start="2"><li>使用哈希表</li></ol><p>使用一个哈希表存储一个链表的所有元素的地址，接着对另一个链表进行遍历，若另一个链表中有元素的地址和哈希表中的链表地址相等，则返回该元素，否则遍历结束后返回<code>null</code></p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        unordered_set&lt;ListNode*&gt; nodes; &#x2F;&#x2F;使用unordered_set存储链表A的各个元素的地址        while (headA) &#123;            nodes.insert(headA);            headA &#x3D; headA-&gt;next;        &#125;        while (headB) &#123;            if (nodes.count(headB)) &#123; &#x2F;&#x2F; 判断headB的元素地址是否在unordered_set中                return headB;            &#125;            headB &#x3D; headB-&gt;next;        &#125;        return nullptr;    &#125;&#125;;</code></pre><blockquote><p>需要注意的是在C++中因为<code>ListNode</code>没有定义比较方法，所以在这里使用的是 <code>unordered_set&lt;ListNode*&gt;</code></p></blockquote><ol start="3"><li>”快慢指针“法</li></ol><p>使用两个指针分别指向两个链表的头结点，分别进行遍历，若指针在遍历时遍历到了尾节点，则令指向尾节点的指针指向另一个链表的头结点，若两个链表有相交，即有重叠部分时，这两个指针终究会相遇，此时返回相遇的指针即可，若不能相遇，则返回<code>null</code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        &#x2F;&#x2F; &quot;快慢指针&quot;        ListNode* pointA &#x3D; headA;        ListNode* pointB &#x3D; headB;        while (pointA !&#x3D; pointB) &#123;            pointA &#x3D; pointA !&#x3D; nullptr? pointA-&gt;next: pointA &#x3D; headB;            pointB &#x3D; pointB !&#x3D; nullptr? pointB-&gt;next: pointB &#x3D; headA;        &#125;        if (pointA !&#x3D; nullptr) return pointA; &#x2F;&#x2F; 需要注意在遍历结束后判断pointA（或pointB)是否为null        return nullptr;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个单链表的头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode141.环形链表</title>
    <link href="2023/03/05/leetcode141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/05/leetcode141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-05T08:19:39.000Z</published>
    <updated>2023-03-06T07:24:16.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test2.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2], pos &#x3D; 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test3.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1], pos &#x3D; -1输出：false解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用快慢指针判断是否存在环，如果快指针走到了链表尾部，则直接返回false，若快指针追上了慢指针，则说明链表存在环。C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return false;        ListNode* slow &#x3D; head;        ListNode* fast &#x3D; head-&gt;next;        while (fast !&#x3D; slow) &#123;            &#x2F;&#x2F; 若fast指针走至链表尾部            if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) return false;            fast &#x3D; fast-&gt;next-&gt;next;            slow &#x3D; slow-&gt;next;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 &lt;code&gt;next&lt;/code&gt; 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。&lt;strong&gt;注意：&lt;code&gt;pos&lt;/code&gt; 不作为参数进行传递&lt;/strong&gt; 。仅仅是为了标识链表的实际情况。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果链表中存在环&lt;/em&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; 。 否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
