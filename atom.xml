<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-05-16T00:02:54.205Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode845.数组中的最长山脉</title>
    <link href="2023/05/16/leetcode845-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/"/>
    <id>2023/05/16/leetcode845-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/</id>
    <published>2023-05-15T23:54:56.000Z</published>
    <updated>2023-05-16T00:02:54.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>把符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：</p><ul><li><code>arr.length &gt;= 3</code></li><li>存在下标<code>i（0 &lt; i &lt; arr.length - 1），</code>满足<ul><li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li><li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul></li></ul><p>给出一个整数数组 <code>arr</code>，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 <code>0</code> 。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,1,4,7,3,2,5]输出：5解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,2,2]输出：0解释：不存在山脉子数组。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 104</code></li><li><code>0 &lt;= arr[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>三指针法</li></ul><ol><li>首先，我们可以初始化三个指针：left、right和peak。<ul><li>left指针指向山脉数组的起点，即数组的第一个元素。</li><li>right指针指向山脉数组的终点，即数组的最后一个元素。</li><li>peak指针指向山脉数组的顶峰。</li></ul></li><li>我们可以通过移动right指针来找到山脉数组的终点。当数组的下一个元素比当前元素大的时候，我们可以继续移动right指针。如果下一个元素比当前元素小，我们将找到了山脉数组的终点。</li><li>一旦我们找到了山脉数组的终点，我们需要移动left指针。我们需要找到山脉数组的起点，即数组的第一个元素。我们可以通过移动left指针来找到山脉数组的起点。当数组的下一个元素比当前元素大的时候，我们可以继续移动left指针。</li><li>当我们找到山脉数组的起点和终点后，我们需要更新peak指针的位置。我们可以通过遍历山脉数组的起点到终点之间的元素，找到最大的元素，并更新peak指针的位置。</li><li>最后，我们可以计算山脉数组的长度，即右边界(right)减去左边界(left)再加1。如果山脉数组的长度大于等于3，就返回该长度；否则，返回0。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int longestMountain(vector&lt;int&gt;&amp; A) &#123;        int n &#x3D; A.size();        int left &#x3D; 0, right &#x3D; 0, peak &#x3D; 0;        int longestMountainLength &#x3D; 0;        while (left &lt; n) &#123;            right &#x3D; left;            &#x2F;&#x2F; 找到山脉数组的终点            if (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;                while (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;                    right++;                &#125;                &#x2F;&#x2F; 找到山脉数组的起点                if (right + 1 &lt; n &amp;&amp; A[right] &gt; A[right + 1]) &#123;                    peak &#x3D; right;                    while (peak + 1 &lt; n &amp;&amp; A[peak] &gt; A[peak + 1]) &#123;                        peak++;                    &#125;                    &#x2F;&#x2F; 更新最长山脉的长度                    longestMountainLength &#x3D; max(longestMountainLength, peak - left + 1);                &#125;            &#125;            left &#x3D; max(right, left + 1);        &#125;        return longestMountainLength &gt;&#x3D; 3 ? longestMountainLength : 0;    &#125;&#125;;</code></pre><ul><li>仅用一趟扫描,并仅用O(1)空间复杂度解决问题</li></ul><p>解题思路：</p><ol><li><p>初始化变量：</p><ul><li><code>up</code>：表示上升的长度（山脉的左半边）</li><li><code>down</code>：表示下降的长度（山脉的右半边）</li><li><code>maxLen</code>：表示最长山脉数组的长度</li></ul></li><li><p>从数组的第二个元素开始遍历：</p><ul><li><p>如果当前元素 <code>A[i]</code> 大于前一个元素 <code>A[i-1]</code>，则表示处于上升阶段，递增 <code>up</code> 的值，同时重置 <code>down</code> 的值为0。</p></li><li><p>如果当前元素 </p><pre class="language-none"><code class="language-none">A[i]</code></pre><p> 小于前一个元素 </p><pre class="language-none"><code class="language-none">A[i-1]</code></pre><p>：</p><ul><li>如果 <code>up</code> 大于0，表示已经处于山脉的下降阶段，递增 <code>down</code> 的值。</li><li>如果 <code>up</code> 等于0，表示还没有开始上升阶段，不进行任何操作。</li></ul></li></ul></li><li><p>当 <code>down</code> 大于0时，表示找到了山脉数组的终点，更新 <code>maxLen</code> 的值。然后将指针移动到山脉数组的下一个元素，即 <code>i</code> 加1，并重置 <code>up</code> 和 <code>down</code> 的值为0。</p></li><li><p>最后返回 <code>maxLen</code>，即为最长山脉数组的长度。</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int longestMountain(vector&lt;int&gt;&amp; A) &#123;        int n &#x3D; A.size();        int up &#x3D; 0, down &#x3D; 0;  &#x2F;&#x2F; 上升和下降的长度        int maxLen &#x3D; 0;  &#x2F;&#x2F; 最长山脉数组的长度        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (A[i] &gt; A[i-1]) &#123;  &#x2F;&#x2F; 上升阶段                if (down &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于下降阶段，则重置上升和下降长度                    up &#x3D; 0;                    down &#x3D; 0;                &#125;                up++;  &#x2F;&#x2F; 递增上升长度            &#125; else if (A[i] &lt; A[i-1]) &#123;  &#x2F;&#x2F; 下降阶段                if (up &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于上升阶段                    down++;  &#x2F;&#x2F; 递增下降长度                    maxLen &#x3D; max(maxLen, up + down + 1);  &#x2F;&#x2F; 更新最长山脉数组的长度                &#125;            &#125; else &#123;  &#x2F;&#x2F; 平稳阶段，重置上升和下降长度                up &#x3D; 0;                down &#x3D; 0;            &#125;        &#125;        return maxLen;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;把符合下列属性的数组 &lt;code&gt;arr&lt;/code&gt; 称为 &lt;strong&gt;山脉数组&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr.length &amp;gt;= 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;存在下标&lt;code&gt;i（0 &amp;lt; i &amp;lt; arr.length - 1），&lt;/code&gt;满足&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr[0] &amp;lt; arr[1] &amp;lt; ... &amp;lt; arr[i - 1] &amp;lt; arr[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr[i] &amp;gt; arr[i + 1] &amp;gt; ... &amp;gt; arr[arr.length - 1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个整数数组 &lt;code&gt;arr&lt;/code&gt;，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1925.统计平方和三元组的数目</title>
    <link href="2023/05/15/leetcode1925-%E7%BB%9F%E8%AE%A1%E5%B9%B3%E6%96%B9%E5%92%8C%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>2023/05/15/leetcode1925-%E7%BB%9F%E8%AE%A1%E5%B9%B3%E6%96%B9%E5%92%8C%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2023-05-15T10:10:26.000Z</published>
    <updated>2023-05-15T10:41:13.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个 <strong>平方和三元组</strong> <code>(a,b,c)</code> 指的是满足 <code>a2 + b2 = c2</code> 的 <strong>整数</strong> 三元组 <code>a</code>，<code>b</code> 和 <code>c</code> 。</p><p>给你一个整数 <code>n</code> ，请你返回满足 <code>1 &lt;= a, b, c &lt;= n</code> 的 <strong>平方和三元组</strong> 的数目。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：2解释：平方和三元组为 (3,4,5) 和 (4,3,5) 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 10输出：4解释：平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 250</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力枚举</li></ul><p>直接进行枚举即可。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int countTriples(int n) &#123;        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n                for (int c &#x3D; b + 1; c &lt;&#x3D; n; c++) &#123;  &#x2F;&#x2F; 遍历c的范围从b+1到n                    if (a * a + b * b &#x3D;&#x3D; c * c) &#123;  &#x2F;&#x2F; 检查是否满足勾股定理                        cnt +&#x3D; 2;  &#x2F;&#x2F; 满足条件的三元组数量加2                    &#125;                &#125;            &#125;        &#125;        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量    &#125;&#125;;</code></pre><ul><li>通过固定C降低时间复杂度</li></ul><p>暴力枚举法的复杂度为O(n^3)，我们可以对其进行一些优化，比如固定c，只保留a和b的循环。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int countTriples(int n) &#123;        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n                int c_square &#x3D; a * a + b * b; &#x2F;&#x2F;  定义c_square&#x3D;a*a+b*b                int c &#x3D; sqrt(c_square); &#x2F;&#x2F; 得到整型的变量c，其值为c_square的平方根                 if (c &lt;&#x3D; n &amp;&amp; c * c &#x3D;&#x3D; c_square) &#123; &#x2F;&#x2F; 因为c是被强制转换成int类型进行存储的，所以不仅要判断c是否小于n还要确定c的平方确实等于c_square                    cnt +&#x3D; 2; &#x2F;&#x2F; 若符合要求，则cnt+&#x3D;2 比如（3，4，5）和（4，3，5）只判断一次，但cnt+&#x3D;2；                &#125;            &#125;        &#125;        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个 &lt;strong&gt;平方和三元组&lt;/strong&gt; &lt;code&gt;(a,b,c)&lt;/code&gt; 指的是满足 &lt;code&gt;a2 + b2 = c2&lt;/code&gt; 的 &lt;strong&gt;整数&lt;/strong&gt; 三元组 &lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你返回满足 &lt;code&gt;1 &amp;lt;= a, b, c &amp;lt;= n&lt;/code&gt; 的 &lt;strong&gt;平方和三元组&lt;/strong&gt; 的数目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1534.统计好三元组</title>
    <link href="2023/05/14/leetcode1534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/"/>
    <id>2023/05/14/leetcode1534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/</id>
    <published>2023-05-14T06:52:41.000Z</published>
    <updated>2023-05-14T06:56:17.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p><p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li><li><code>|arr[i] - arr[j]| &lt;= a</code></li><li><code>|arr[j] - arr[k]| &lt;= b</code></li><li><code>|arr[i] - arr[k]| &lt;= c</code></li></ul><p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p><p>返回 <strong>好三元组的数量</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [3,0,1,1,9,7], a &#x3D; 7, b &#x3D; 2, c &#x3D; 3输出：4解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1,1,2,2,3], a &#x3D; 0, b &#x3D; 0, c &#x3D; 1输出：0解释：不存在满足所有条件的三元组。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= arr.length &lt;= 100</code></li><li><code>0 &lt;= arr[i] &lt;= 1000</code></li><li><code>0 &lt;= a, b, c &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力枚举</li></ul><p>直接模拟暴力枚举即可，代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123;        int len &#x3D; arr.size();  &#x2F;&#x2F; 获取数组的长度        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，记录符合条件的三元组数量        for (int i &#x3D; 0; i &lt; len - 2; i++) &#123;  &#x2F;&#x2F; 第一个数的索引范围是 [0, len - 3]            for (int j &#x3D; i + 1; j &lt; len - 1; j++) &#123;  &#x2F;&#x2F; 第二个数的索引范围是 [i+1, len - 2]                for (int k &#x3D; j + 1; k &lt; len; k++) &#123;  &#x2F;&#x2F; 第三个数的索引范围是 [j+1, len - 1]                    if (abs(arr[i] - arr[j]) &lt;&#x3D; a &amp;&amp; abs(arr[j] - arr[k]) &lt;&#x3D; b &amp;&amp; abs(arr[i] - arr[k]) &lt;&#x3D; c) &#123;                        &#x2F;&#x2F; 检查三元组的条件：两个数之间的差值都不超过给定的限制                        cnt++;  &#x2F;&#x2F; 符合条件的三元组数量加一                    &#125;                &#125;            &#125;        &#125;        return cnt;  &#x2F;&#x2F; 返回符合条件的三元组数量    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt; ，以及 &lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt; 、&lt;code&gt;c&lt;/code&gt; 三个整数。请你统计其中好三元组的数量。&lt;/p&gt;
&lt;p&gt;如果三元组 &lt;code&gt;(arr[i], arr[j], arr[k])&lt;/code&gt; 满足下列全部条件，则认为它是一个 &lt;strong&gt;好三元组&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; arr.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|arr[i] - arr[j]| &amp;lt;= a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|arr[j] - arr[k]| &amp;lt;= b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|arr[i] - arr[k]| &amp;lt;= c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 &lt;code&gt;|x|&lt;/code&gt; 表示 &lt;code&gt;x&lt;/code&gt; 的绝对值。&lt;/p&gt;
&lt;p&gt;返回 &lt;strong&gt;好三元组的数量&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode84.柱状图中最大的矩形</title>
    <link href="2023/05/12/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>2023/05/12/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</id>
    <published>2023-05-12T09:43:04.000Z</published>
    <updated>2023-05-12T09:46:16.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><span id="more"></span> <p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/histogram.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：heights &#x3D; [2,1,5,6,2,3]输出：10解释：最大的矩形为图中红色区域，面积为 10</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/histogram-1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入： heights &#x3D; [2,4]输出： 4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><ol><li>遍历给定的柱状图高度数组 <code>heights</code>，依次处理每个柱子。</li><li>使用一个栈来保存递增序列的索引。栈中的索引对应的柱子高度是递增的。</li><li>对于每个柱子，如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界。</li><li>弹出栈顶元素，并计算以栈顶元素为高度的矩形的面积。面积的宽度可以通过当前索引和新的栈顶元素索引之间的距离计算得到。</li><li>更新最大面积值。</li><li>将当前索引入栈，继续下一个柱子的处理。</li><li>遍历完所有柱子后，栈中剩余的索引对应的柱子高度没有右边界，因此以这些柱子高度计算的矩形面积可以直接得到。</li><li>返回最大面积值。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;    int n &#x3D; heights.size();    stack&lt;int&gt; st; &#x2F;&#x2F; 使用栈来保存递增序列的索引    int maxArea &#x3D; 0;    for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;        &#x2F;&#x2F; 如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界        &#x2F;&#x2F; 计算以栈顶元素为高度的矩形的面积，并更新最大面积        while (!st.empty() &amp;&amp; (i &#x3D;&#x3D; n || heights[i] &lt; heights[st.top()])) &#123;            int h &#x3D; heights[st.top()];            st.pop();            int w &#x3D; st.empty() ? i : (i - st.top() - 1);            maxArea &#x3D; max(maxArea, h * w);        &#125;        &#x2F;&#x2F; 将当前索引入栈        st.push(i);    &#125;    return maxArea;&#125;int main() &#123;    vector&lt;int&gt; heights &#x3D; &#123;2, 1, 5, 6, 2, 3&#125;;    int maxArea &#x3D; largestRectangleArea(heights);    cout &lt;&lt; &quot;最大矩形的面积为：&quot; &lt;&lt; maxArea &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
&lt;p&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>一种基于知识图谱的离散制造车间资源分配优化方法</title>
    <link href="2023/05/12/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%A6%BB%E6%95%A3%E5%88%B6%E9%80%A0%E8%BD%A6%E9%97%B4%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>2023/05/12/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%A6%BB%E6%95%A3%E5%88%B6%E9%80%A0%E8%BD%A6%E9%97%B4%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</id>
    <published>2023-05-12T08:53:33.000Z</published>
    <updated>2023-05-13T12:59:23.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops"><a href="#A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops" class="headerlink" title="A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops"></a>A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>动态订单需求和不确定的制造资源可用性是目前智能资源优化配置的研究热点。目前从制造业产生的数据量正在快速的增长。这些数据有多源头，异构和多尺度的特点。将数据转化为知识，优化个性化订单与制造资源的配置，是提高企业认知智能生产水平的有效策略。<strong>但是</strong>，制造过程在资源配置上是多样化的。数据之间有很多规则和约束。数据之间的关系是更加复杂的，从海量制造数据中挖掘语义信息，缺乏统一的信息建模和工业知识生成方法。<strong>研究挑战</strong>是如何充分整合车间资源的复杂数据，挖掘隐含的语义信息，形成可行的<strong>知识驱动的资源分配优化方法</strong>。这种方法可以有效地提供资源分配所需的相关工程信息。本研究提出了一种统一的知识图驱动的生产资源分配方法，允许根据资源加工信息和设备评估策略，为给定的订单插入任务快速做出资源分配决策。提出了车间资源知识图谱（WRKG）模型来整合机加工车间的工程语义信息。开发了一种<strong>分布式知识表示学习算法</strong>来挖掘隐式资源信息以实时更新WRKG。此外，提出了一种由 WRKG 支持的三阶段资源分配优化方法，以输出特定任务所需的设备集。以航空航天企业制造资源分配过程任务为例，论证了所提方法的可行性。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>制造资源的合理配置对提高生产效率具有重要意义，尤其是在离散制造行业。结构件的生产是离散制造的典型例子，具有多品种、小批量生产、工艺变化频繁等特点。在实际的结构件生产过程中，批量生产任务和研发任务并存，是典型的混合模式生产（见图1）。<strong>批量生产</strong>有固定的处理时间并且每个处理块都根据生产计划进行执行。<strong>研发任务</strong>的制造模式主要是在试制阶段对待加工产品进行一些加急订单，具有较大的不确定性，尤其是在加工时间和设备使用方面。混合模式生产中紧急订单的存在会<strong>引发制造车间资源配置的冲突</strong>。此外，紧急订单会影响生产效率和交货时间。此外，切换紧急订单需要大量的准备时间和等待时间，这降低了车间的整体生产效率。<strong>因此需要</strong>快速高效地配置车间制造资源，减少资源冲突，提高资源利用率，增强制造过程的灵活性。</p><p><img src="http://cdn.leafii.top/img/image-20230510203735964.png" alt="image-20230510203735964" loading="lazy"></p><p>大多数次序资源分配的现有方法主要关注于优化资源模型和算法。随着IOT和大数据行业的巨大发展，在工业生产过程有很多的数据被生成了。这些数据具有结构化和非结构化、多尺度、多源和语义关系复杂性的特点。然而，现有的资源分配模型或算法中，<strong>缺乏</strong>对企业海量制造数据的语义信息挖掘。现有的资源分配模型或算法中，<strong>缺乏</strong>对企业海量制造数据的语义信息挖掘。这些方法<strong>忽略</strong>了车间中丰富的语义信息，不利于为资源配置提供准确的关联知识，像人类一样从知识层面进行认知和决策。根据在离散制造车间进行的实地调研发现，车间资源产生的数据<strong>利用不充分</strong>，主要有以下原因：</p><ol><li>数据类型多样：过程的历史数据在生产车间以多种类型记录。此外，大多数数据是半结构化或非结构化的，这导致数据处理效率低下。如此一来，数据便无法轻易复用，以提升后续生产设备的配置效率。</li><li>复杂的数据关系：制造数据中的车间生产设备、加工零件、工艺需求之间存在多种潜在的逻辑关联。目前，由于这些数据之间关系的复杂性，利用数据关系指导生产还不够充分。</li><li>数据处理效率低：制造数据的处理延迟无法在有急单时提供及时、动态的资源调整决策。这主要是因为各个制造步骤之间的数据关系复杂，并且缺乏对制造数据的语义理解。</li></ol><p>目前，这些数据还没有很好地用于生产计划和控制的决策。有必要探索一种有效的方法来整合积累的生产资源数据，以供工业知识重用和资源配置应用。语义技术（即本体论）广泛用于知识建模。<strong>然而</strong>，本体表示模式层上的知识，而没有描述深层语义关系。产业本体是资源概念的集合，主要描述资源概念及其属性信息。这种方法灵活性有限，知识的计算效率相对较低。知识图谱是一种结构化的语义知识库，由实体-关系-实体和实体-属性-值三元组组成，能够更好地描述数据层中的数据。此外，知识图谱能够处理具有复杂结构的大规模数据，计算不同术语之间的语义相似度，以及在没有显式边的情况下推理实体之间的隐式关系。知识图谱已经出现在制造领域。<strong>然而</strong>，从海量制造数据中挖掘特定的语义信息，构建工业资源配置决策所需的语义知识，目前还<strong>缺乏统一的信息建模和知识生成方法</strong>。此外，目前知识库构建的研究多是通过关联企业已有的知识来进行的。并且对挖掘制造业中海量的隐式语义关系缺乏深入研究，不利于丰富知识库，提高知识利用率。<strong>研究的挑战</strong>在于如何充分整合车间资源的复杂数据，挖掘隐含的语义信息，形成可行的知识驱动的资源分配优化方法，高效提供资源分配所需的相关工程信息。</p><p>本论文首先研究了一种基于统一知识图谱的制造资源优化配置方法。该方法旨在<strong>挖掘制造中的隐性关系，生成驱动生产资源分配的热更新知识图谱，从知识层面实现订单插入请求的快速资源分配决策</strong>。具体来说，提出了<strong>WRKG模型</strong>来集成工程语义信息，包括制造企业中大规模生产要素（过程、设备、人员、材料）的各种数据类型。然后，开发了一种<strong>知识表示学习算法</strong>来推理设备和进程之间的深层隐式关系。通过这种方式，WRKG 可以规范机加工车间的知识，提高生产过程的效率。此外，为了使用构建的 WRKG 为订单任务提供准确的信息，提出了基于WRKG的<strong>资源分配优化三阶段方法</strong>，包括1）制造资源重构的数学模型，2）候选设备集的形成和3）候选设备集的评估和优化。最后，在航空航天加工车间对所提出的方法进行了应用和评估。</p><p>本文的主要贡献包括：</p><p>1）提出了一个<strong>统一的基于知识图谱的决策框架</strong>，集成了机加工车间环境中的隐性工程知识。该框架用于支持资源分配的优化方法</p><p>2）开发<strong>分布式表示学习算法</strong>，挖掘复杂工程数据之间的隐含关系，丰富车间资源之间的关系，高效指导生产。</p><p>3）提出了<strong>混合模型生产过程中候选设备形成和基于社区的设备评估的三阶段方法</strong>，该方法利用机加工车间WRKG为候选设备的形成和评估提供关联数据支持。</p><p>4）通过在航空航天加工车间采用结构件的生产任务来<strong>评估</strong>所提出的方法。结果表明，该方法能够在处理稳定的前提下，生成更符合逻辑、更直观的资源重构过程知识，提高设备利用率、处理任务的响应能力和设备的灵活性。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>讨论了制造业资源分配中与订单插入相关的基本问题，即如何匹配订单请求。文章重点回顾了现有的制造业资源分配研究工作，侧重于知识表示和建模方法。</p><h4 id="Knowledge-representation-and-modeling-of-manufacturing-resources"><a href="#Knowledge-representation-and-modeling-of-manufacturing-resources" class="headerlink" title="Knowledge representation and modeling of manufacturing resources"></a>Knowledge representation and modeling of manufacturing resources</h4><p>讨论了制造业中资源分配问题中的知识表示和建模方法。现有的知识表示和建模方法（如本体学）在处理大规模知识时存在灵活性和计算效率方面的限制。因此，研究者提出了基于知识图谱的决策框架和改进的知识表示学习算法，以挖掘复杂工程数据之间的隐含语义关系，提供更全面的知识支持资源分配决策。文章认为现有的方法不能直接应用于制造业，因为制造数据复杂多样，存在许多规则和约束，导致制造资源的语义表示和建模困难。因此本文提出了一个<strong>统一的基于知识图的决策制定框架</strong>用于支持资源调度的最优方法。此外，一种<strong>改进的用于挖掘复杂的工程数据之间关系的知识表示学习算法</strong>也被提出以提供更多可理解的知识。</p><h4 id="Optimization-of-resource-configuration"><a href="#Optimization-of-resource-configuration" class="headerlink" title="Optimization of resource configuration"></a>Optimization of resource configuration</h4><p>介绍了混合模式车间动态生产环境下资源分配研究的优化方法、模型和算法。文章总结了鲁棒方法、智能优化方法和重新调度方法的优缺点，并列举了相关文献。鲁棒方法广泛研究用于优化车间资源分配，智能优化方法利用各种智能算法和优化方法进行动态资源分配，重新调度方法具有良好的时效性。这些方法都有其适用范围，但没有考虑车间中所包含的丰富语义信息。作者提出使用知识图谱来提供资源分配方法所需的信息，并提高生产决策的智能水平。因此，本文的主要贡献是使用知识图谱创新地提供资源分配方法所需的信息，并从知识层面提高生产决策的智能水平。</p><p><img src="http://cdn.leafii.top/img/image-20230306165544044.png" alt="image-20230306165544044" loading="lazy"></p><p>根据表1可以得出结论，这些方法都有一定的适用范围，但都没有考虑到workshop中包含的丰富的语义信息。智能优化方法适用于解决本文所讨论的问题。本文的主要贡献是创新性地利用知识图谱为资源配置方法提供所需信息，从知识层面提高生产决策的智能化水平。</p><h3 id="The-WRKG-modeling-method-for-production-process"><a href="#The-WRKG-modeling-method-for-production-process" class="headerlink" title="The WRKG modeling method for production process"></a>The WRKG modeling method for production process</h3><p>总的来说是，WRKG的提出是为了整合车间资源知识，并且支持插入订单的资源分配方式。 WRKG模型的建立是为了<strong>获取和融合</strong>与加工资源相关的数据，<strong>包括</strong>WRKG的<strong>定义</strong>、与设备和加工相关的<strong>信息规范</strong>。然后生成与加工相关的WRKG。此外，为了丰富和更新 WRKG，挖掘制造生产中的<strong>隐式关系</strong>，开发了一种<strong>改进的表示学习算法</strong>（improved represented learning algorithm)。</p><h4 id="Construction-of-the-WRKG"><a href="#Construction-of-the-WRKG" class="headerlink" title="Construction of the WRKG"></a>Construction of the WRKG</h4><p>为了将生产车间的大量半结构化和非结构化数据转化为结构化知识，设计了WRKG构建框架，整合车间设备资源，如图2所示。</p><p><img src="http://cdn.leafii.top/img/image-20230309204056952.png" alt="image-20230309204056952" loading="lazy"></p><p>它由三部分组成。</p><ol><li>首先，获取车间制造的历史数据、生产文件数据和实时生产数据。</li><li>其次，对制造相关信息进行知识融合处理，建立加工知识本体模型。车间资源的实体和关系存储在图数据库中。</li><li>然后使用本体规则和分布式表示学习支持的推理方法来识别与加工车间使用的设备相关的隐式关系。</li><li>最后，隐式关系之间的信息和知识应用的形成都反馈到数据采集端，以动态更新研讨会资源之间的关系。</li></ol><p>为了构建 WRKG，车间资源信息由三元组构建，结合生产要素中的机器-材料-方法（Machine-Material-Method），如图 3 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230312214619994.png" alt="image-20230312214619994" loading="lazy"></p><p>三层结构包括<strong>类别层、概念层和实体层</strong>。<strong>资源类别层</strong>由四个部分组成，代表车间的<strong>生产要素</strong>，包括设备、产品、过程和操作。<strong>中间层（概念层）</strong>是资源类别层对应的<strong>各类生产资源</strong>，有利于本体的概念形成。<strong>底层（实体层）</strong>是各类工坊资源的<strong>实体信息</strong>。这有助于开发大型车间资源的知识图谱，为设备资源之间的关系推断提供数据支持。</p><h5 id="Modeling-of-the-WRKG-of-machining-device"><a href="#Modeling-of-the-WRKG-of-machining-device" class="headerlink" title="Modeling of the WRKG of machining device"></a>Modeling of the WRKG of machining device</h5><p>本节基于WRKG框架来描述WRKG的定义。</p><p>**Definition 1.**机加工车间设备概念本体可以形式化定义为$o&#x3D;〈T,S,P,R,A〉$，其含义如下：</p><p><strong>T</strong>是术语抽象，主要是图3中的中间层（概念层）设备类。</p><p><strong>S</strong>是同义词融合，由多个术语消除歧议后形成一个唯一的术语，如高速钢车刀、硬质合金车刀都归为车刀。</p><p><strong>P</strong>为属性抽象，$P &#x3D; { BasI(i), FunI(i), StaI(i)}$，其中$BasI(i)$表示设备$i$的<strong>基本信息</strong>，如设备位置、设备名称、设备编号等.$FunI(i)$ 表示关于设备$ i $的<strong>功能信息</strong>，例如可加工的腔体、复杂的表面零件。$StaI(i)$表示设备$i$的<strong>状态信息</strong>，取值0、1、2、3、4分别代表idle、full-load、overload、failure(怠速、满载、过载和故障)。设备附带的基本属性和功能属性是<strong>静态信息</strong>，状态属性是<strong>动态信息</strong>。此外，设备的状态基于传感器和MES（制造执行系统）实时更新。</p><p><strong>R</strong>是关系抽象，它基于P中的三个属性，关系包括“has_a”、“has_tool”、“has_status”等。在加工过程中，设备节点之间的关系有<strong>动态和静态</strong>的变化. &lt;概念实例、属性关系触发词、属性值&gt;三元组用于描述设备的基本信息，如&lt;Machine, has_a, Position&gt;。</p><p><strong>A</strong>$(A(i)∈A)$是一种规则，用于<strong>约束和规范</strong>设备的形成。其中，设备元素（element）描述为$M(i)&#x3D;{ BasI(i),FunI(i),StaI(i)}∈M⇒M(i)∈P$。设备模型可表示为$M &#x3D; ∑^n_{i &#x3D;1}M(i)$。机床设备数据模型M的<strong>约束规则</strong>如表2所示。</p><p><img src="http://cdn.leafii.top/img/image-20230312221444700.png" alt="image-20230312221444700" loading="lazy"></p><p>根据<strong>Definition 1</strong> 中给出的信息，开发了加工装置的概念模型（见图 4）。</p><p><img src="http://cdn.leafii.top/img/image-20230312221852950.png" alt="image-20230312221852950" loading="lazy"></p><h5 id="Formation-of-the-WRKG-of-device-relationship-network"><a href="#Formation-of-the-WRKG-of-device-relationship-network" class="headerlink" title="Formation of the WRKG of device relationship network"></a>Formation of the WRKG of device relationship network</h5><p>**Definition 2.**机加工车间设备集的知识图可以定义为$G&#x3D;〈MI,RI,PI,G〉$，其意义如下。</p><p><strong>MI</strong>是设备信息集，指的是图3中底层的设备资源<strong>（实体）</strong>，如车床、数控铣床、加工中心等。</p><p><strong>RI</strong>是设备之间的关系。Definition 1中已经用详细信息对器件实体进行了建模，但在加工过程中器件之间仍然存在复杂多变的关系，包括顺序关系、排他关系和并行关系。具体信息如下：</p><p>a) <strong>顺序关系</strong>是设备链接在加工过程中的全局关联形式。例如，设备M1和M2的顺序关系可以表示为Sequence(M1,M2)。</p><p>b) <strong>排他关系</strong>是设备链路在处理过程中的局部关联形式。 以设备M1和M2为例，如果在选择的分支结构中都在同一条分支路径上，则可以指定设备M1和M2之间存在排他关系，即Exclusive(M1, M2) .</p><p>c) <strong>并联关系</strong>是机械加工过程中常见的设备组织关系。 例如，如果设备M1和M2在并联分支结构中有不同的分支路径，则它们之间的关系可以定义为并联关系，即Parallel(M1,M2)。</p><p><strong>PI</strong>是基于制造过程信息流的<strong>过程需求信息</strong>（见图5），主要包括设备、工具、夹具、量具、量具、标识符、操作员和传感器。</p><p><img src="http://cdn.leafii.top/img/image-20230313170059637.png" alt="image-20230313170059637" loading="lazy"></p><p><strong>G</strong>是机加工车间的设备制造资源，可以描述为一个三元组$G&#x3D;{(h,l,t)}∈(MI×RI×PI)∩o$，其中$h$是WRKG的头实体，$t$是WRKG 的尾部实体，$l$是头尾实体之间的关系。结构件的制造涉及多道工序，需要多台设备才能完成规定的加工任务。</p><p>这样，可以利用集成的信息开发全面的设备关系网络。</p><h4 id="Knowledge-representation-learning-and-mining-of-the-WRKG"><a href="#Knowledge-representation-learning-and-mining-of-the-WRKG" class="headerlink" title="Knowledge representation learning and mining of the WRKG"></a>Knowledge representation learning and mining of the WRKG</h4><p>为进一步高效<strong>挖掘机加工车间资源间的隐含关系</strong>，为支持资源分配决策提供更全面的知识，提出了一种改进的分布式表示学习方法，该方法在头尾实体中加入<strong>语义权重向量</strong>$θ_i∈\mathbb R^k$对应关系 $l_i ∈ \mathbb R^k$。机加工车间资源信息知识表示模型描述如下：</p><p>$h_i &#x3D; h \circ \theta_i^h$</p><p>$t_i &#x3D; t \circ \theta_i^t$</p><p>其中$∘$为hadamma乘积算子（矩阵对应相乘相加），$h_i$和$t_i$分别由关系$l_i$语义下的头尾实体向量表示。为了提高机加工车间资源数据的语义关联准确性，基于马氏距离（表示点与一个分布之间的距离）<strong>计算设备资源的相似度</strong>。<strong>发现车间资源实体之间的隐式关系</strong>。得分函数如下所示：</p><p>$f_l(h,t) &#x3D; (h_i \circ \theta^h_i + l_i - t_i \circ \theta_i^t)W_l(h_i \circ \theta_i^h + l_i - t_i \circ \theta_i^t)$</p><p>其中$f_l(h,t)$是<strong>车间资源数据三元组的得分函数</strong>，$W_l$是自适应度量对应的特定关系对称非负权重矩阵。</p><p>优化目标函数如下：</p><p>$min \sum_{(h,l,t) \in \Delta(h’,l’,t’)\in \Delta’}[f_l(h,t) + \gamma - f_{l’}(h’,t’)]<em>+ + \lambda(\sum</em>{l \in L}||W_l||<em>F^2)+C(\sum</em>{e \in E} ||e||<em>2^2 + \sum</em>{l\in L}||l||_2^2) $</p><p>$[W_l]_{ij} \geq 0$</p><p>其中，$[\cdot]_+$是取0和一个大的值的<strong>max值</strong>，$\gamma$是正负三元组的<strong>最大语义边界间隔</strong>， $|| \cdot||_F$是矩阵的<strong>F范数</strong>，C控制<strong>缩放度</strong>，λ控制自适应权重矩阵的<strong>正则化</strong>。可以通过将式（6）(见下文)的导数设为0来求解Wl，以提高计算效率。</p><p>为了更彻底的理解算法1中WRKG的真正实现，在5.2节中举了一个例子进行说明。</p><p><img src="http://cdn.leafii.top/img/image-20230313170345648.png" alt="image-20230313170345648" loading="lazy"></p><h3 id="A-three-staged-method-based-on-the-WRKG-for-resource-allocation-optimization"><a href="#A-three-staged-method-based-on-the-WRKG-for-resource-allocation-optimization" class="headerlink" title="A three-staged method based on the WRKG for resource allocation optimization"></a>A three-staged method based on the WRKG for resource allocation optimization</h3><p>本节提出了一个结合了WRKG以驱动设备资源调度优化的三阶段方法。该方法的每个阶段都利用相应的先前生成的制造知识，在认知层面提升资源分配决策的智能性。该方法可以将制造订单要求与机加工车间的WRKG联系起来。<strong>决策过程利用了WRKG信息，并且可以学习设备评估策略以形成指导后续生产的新知识。</strong>它包含的三个阶段如下：</p><ul><li>使用模糊层次方法所需的索引构造候选设备集。</li><li>利用基于社区的设备制造资源<strong>评价模型</strong>，从设备利用率方面对候选设备集进行评价和优化。</li><li>针对处理设备组的配置优化，建立了资源分配<strong>数学模型</strong>。</li></ul><h4 id="Mathematical-model-of-manufacturing-resource-reconfiguration"><a href="#Mathematical-model-of-manufacturing-resource-reconfiguration" class="headerlink" title="Mathematical model of manufacturing resource reconfiguration"></a>Mathematical model of manufacturing resource reconfiguration</h4><p>由2.2节的分析，可以得到机械车间资源配置的数学模型。假定加工任务中的结构件是$J&#x3D;{J_1, J_2, …, J_i, …, j_n}$，其中加工过程的j节点被视为$O_j, j&#x3D;1,2,…,n_T$，其中$n_T$是操作的总数。可用设备域被设置为设备组$G&#x3D;{G_1, G_2,…,G_t,…,G_T}$，设备节点$M&#x3D;{M_1,M_2,…,M_k,…,M_m}$，因此$G_j$表示在过程$O_j$中正在处理的设备组，并且包含了一个设备节点集$M_j \in M$。过程$O_j$在设备节点$M_k$上的处理时间用$pt_{jk}$表示，使用$tt_{mn}$（transform time)表示设备节点$M_m$和$M_n$之间的转移时间。$ST_{kj}$表示过程$O_j$在设备节点$M_k$的加工开始时间，并且$ET_{kj}$表示过程$O_j$在设备节点$M_k$上的加工结束时间。$C_i$是工件$i$节点的完成时间。$W_k$表示设备节点$M_k$的工作负载，以负载率作为衡量标准。基于以上描述，以下目标函数被定义。</p><p><img src="http://cdn.leafii.top/img/image-20230313202944346.png" alt="image-20230313202944346" loading="lazy"></p><p>上面的式子需要满足以下限制:<br>$ST_{kj} &#x3D; ET_{m(j-1)} + pt_{mk}$</p><p>这个目标是为了<strong>最小化处理时间和设备资源的负载</strong>。该限制表明在之前的处理完成之后<strong>设备之间的转移时间</strong>需要被考虑进去。</p><h5 id="Formation-of-the-candidate-device-sets"><a href="#Formation-of-the-candidate-device-sets" class="headerlink" title="Formation of the candidate device sets"></a>Formation of the candidate device sets</h5><p>结构件的生产涉及各种各样的设备。因此，基于WRKG的候选设备编队如图6所示，用于对特定进程进行资源匹配。</p><p><img src="http://cdn.leafii.top/img/image-20230313205031018.png" alt="image-20230313205031018" loading="lazy"></p><p>特定的评估指标用于选择设备以构建可选设备集。基于3.1.1节（Modeling of the WRKG of machining device）提出的制造设备信息模型，有五项设备资源评价指标，包括<strong>工件特征、加工特征、加工类型、加工精度和运行状态</strong>。这些指标具有层次结构。在这项研究中，模糊层次分析法被用来量化指标之间的关系。它的<strong>优点</strong>是可以为具有明显层次结构信息的各个评价指标分配权重。该方法可用于结构件制造过程中从<strong>指标集</strong>和<strong>对象集</strong>两个方面筛选设备资源。该方法的实现分为以下几个步骤。</p><ol><li>在指标集方面，利用WRKG提供的设备间丰富的相关性信息，建立了五类评价指标的模糊矩阵$R_{ij}$。</li><li>就对象集而言，为每个评价指标分配权重，通过计算指标间的标准差$σ_j$生成设备权重向量$W_j$。</li><li>在确定不同设备的权重向量后，引入相关系数 $ξ_i(k)$来提高设备资源的匹配精度。</li><li>通过将设备信息与过程知识相关联，得到每个候选设备资源对应指标的相关系数。</li><li>进一步计算<strong>处理任务中设备与进程信息之间的资源相似度匹配度</strong>$\gamma_s$。</li><li>最终选择符合生产要求的设备。</li></ol><h5 id="Evaluation-and-optimization-of-the-candidate-device-sets"><a href="#Evaluation-and-optimization-of-the-candidate-device-sets" class="headerlink" title="Evaluation and optimization of the candidate device sets"></a>Evaluation and optimization of the candidate device sets</h5><p>候选设备在设置后需要基于社区技术进行<strong>评估</strong>和<strong>优化</strong>。在这项研究中，社区包括几个具有共同功能和属性的共享通信节点的机床。换句话说，它可以基于通信节点对设备进行集群，以方便设备的统一组织。开发了基于社区的处理的评估模型（见图 7）。</p><p><img src="http://cdn.leafii.top/img/image-20230313220047285.png" alt="image-20230313220047285" loading="lazy"></p><ul><li>首先，WRKG<strong>提供</strong>评估方法所需的<strong>相关信息</strong>，包括设备组的组成信息和当前状态信息。</li><li>其次，如果评估需要优化，进行评估分析，及时合理分配社区设备。</li><li>最后，将各器件集的分析调整方案应用到WRKG中，形成新的器件集逻辑关系和组织形式，<strong>指导后续制造过程（更新）</strong>。</li></ul><p>社区的动态调整主要针对<strong>单台机床的负载率</strong>，旨在<strong>通过加工任务的重新分配</strong>优化机床资源的配置。评价优化算法如下：</p><p><img src="http://cdn.leafii.top/img/image-20230314102517102.png" alt="image-20230314102517102" loading="lazy"></p><h3 id="Case-study"><a href="#Case-study" class="headerlink" title="Case study"></a>Case study</h3><p>案例研究是基于航空航天企业中加工结构件的具体加工任务。</p><h4 id="Processing-information-of-aerospace-machining-workshop"><a href="#Processing-information-of-aerospace-machining-workshop" class="headerlink" title="Processing information of aerospace machining workshop"></a>Processing information of aerospace machining workshop</h4><p>选择该车间为代表进行配置优化问题的分析的理由：该车间是企业内部的核心制造车间之一。车间由16台机器组成，包括加工中心、线切割机和数控车床。其中包括三台专用功能线切割机和两台 DMG 车床 (DMG CTV160)。多功能数控机床，尤其是加工中心，是影响结构件生产效率的重要因素。设备信息在表3中提供。</p><p><img src="http://cdn.leafii.top/img/image-20230314104027858.png" alt="image-20230314104027858" loading="lazy"></p><p>本研究以车间某一时期的结构件加工任务为研究对象，主要包括特定型号的电动转向架（PTVA10212）、旋转体头罩（PTVN10312）、车架背支撑板（PTVL10111），盒体（PTVM10121）。对4个航天结构件处理后的原始数据进行整理后，批处理任务详情如表4所示。</p><p><img src="http://cdn.leafii.top/img/image-20230314104538441.png" alt="image-20230314104538441" loading="lazy"></p><p>批量生产任务处理20h时发出加工新试制盒的加急单PTVC10221（见表4），加工信息见表5。</p><p><img src="http://cdn.leafii.top/img/image-20230314105347359.png" alt="image-20230314105347359" loading="lazy"></p><h4 id="Generation-of-the-WRKG-of-the-aerospace-machining-workshop"><a href="#Generation-of-the-WRKG-of-the-aerospace-machining-workshop" class="headerlink" title="Generation of the WRKG of the aerospace machining workshop"></a>Generation of the WRKG of the aerospace machining workshop</h4><p>基于图4加工装置的概念模型，将装置的基本静态属性、状态属性、功能属性信息进行整合，生成加工中心的WRKG（见图8）。</p><p><img src="http://cdn.leafii.top/img/image-20230314105535517.png" alt="image-20230314105535517" loading="lazy"></p><p>然后将各种设备的实体信息与加工产品的工艺实体信息相关联。计算过程用于演示如何挖掘车间资源实体之间的隐含关系，阐明WRKG的更新过程（见图9）。</p><p><img src="http://cdn.leafii.top/img/image-20230314105644941.png" alt="image-20230314105644941" loading="lazy"></p><p>输入是 WRKG 中的一组三元组，结合算法 1。可以训练每个三元组以生成相应的嵌入向量。如果“加工中心”与语义相似度高的实体相匹配，则可以根据马氏距离输出对应的实体。如果预测“加工中心”和“孔”之间的隐含关系，即一个三元组（machining center, ?, hole），则可以根据评分函数输出实体之间可能存在的隐含关系。此外，隐式关系在工程师评估后更新到 WRKG。给出输出从小到大排名前3的结果，作为工程师评估的参考。为此，将隐式关系更新到 WRKG。最后，在图 10 中开发了航空结构件加工过程中的 WRKG。</p><p><img src="http://cdn.leafii.top/img/image-20230314110439473.png" alt="image-20230314110439473" loading="lazy"></p><h4 id="Resource-configuration-optimization-for-processing-tasks"><a href="#Resource-configuration-optimization-for-processing-tasks" class="headerlink" title="Resource configuration optimization for processing tasks"></a>Resource configuration optimization for processing tasks</h4><p>构建了一个基于知识的航天结构件制造资源优化配置平台如图11所示，专门针对机加工车间。由于车间排除了热处理工艺，后续分析忽略热处理的加工信息。</p><p><img src="http://cdn.leafii.top/img/image-20230314143230294.png" alt="image-20230314143230294" loading="lazy"></p><p>平台集成了前面章节描述的方法，包括当前器件加工能力信息、基于算法1的WRKG嵌入式表示、制造资源重构的数学模型、候选器件集的形成和评估。</p><p>当有新的加急订单下达时，可根据当前订单状态信息，计算可行设备群并在平台上可视化，包括具体设备的状态信息（当前加工状态、加工工件、剩余加工时间等）和任务的实时细节。</p><p>将表4的处理任务导入到平台中。此外，还计算了四个加工社区，包括 PTVM10212、PTVN10312、PTVA10111 和 PTVL10121。该平台用于在表5中的加急订单下达时，针对表4中的订单任务优化加工设备配置的计算。开发了完成PTVC10221加工任务的六台设备的加工共同体。</p><p>重新配置后，与重新配置前的设备利用率和之前的平均设备利用率相比，重新配置后的<strong>整体设备利用率得到提高</strong>（见图 12（a））。此外，前半部分的利用率显着提高，而后半部分则较少。因为新机加工社区的组成主要由现有机加工社区中的原机加工设备组成。此外，紧急订单 PTVC10221 包括现有机加工社区中的第一台机加工设备。</p><p><img src="http://cdn.leafii.top/img/image-20230314143722314.png" alt="image-20230314143722314" loading="lazy"></p><p>分析了加急订单前后各机加工社区的平均负载率和负载均衡状态。重构前后各加工团体的目标状态对比曲线如图12(b)所示。可以看出，所有机加工社区的整体负载率θ从48.82%上升到56.68%。另外，**单台机床的负载率$θ_k$不过80%**。此外，整体负载均衡状态$σ(θ)$略有变化，从6.30%变为7.51%，仍然是一个可控的理想范围（$θ_k≤80%，σ(θ)&lt;15%$）如图7和算法2所示。结果表明，车间内所有设备的负载率是均衡的。因此，得出的结论是，所提出的方法促进了车间设备社区的可持续加工。</p><p>单个设备的配置演变如图13所示，其中车削设备群体、铣削设备群体和钻削设备群体发生了变化。此外，设备社区的变化是由表5中任务订单的流程要求引起的。表 5 订单发布后，设备社区发生变化，表明设备转移发生在机加工社区内。来自不同社区的设备转移表明该方法<strong>提高了设备处理的灵活性</strong>。</p><p><img src="http://cdn.leafii.top/img/image-20230314144713007.png" alt="image-20230314144713007" loading="lazy"></p><h4 id="Discussions"><a href="#Discussions" class="headerlink" title="Discussions"></a>Discussions</h4><p>正如所呈现的工业案例研究所验证的那样，基于知识图谱的方法可以链接航空航天加工车间的制造资源，以支持加工设备的优化。它能够实时查询设备状态，为平台支持调度提供准确的信息。同时，航空结构件的生产过程涉及到很多与设备相关的信息，并不局限于机加工车间。本文仅关注机加工车间设备相关信息。<strong>不能保证</strong>在设计航空航天 WRKG 时完全涵盖设备相关关系。因此，其他车间信息和更多的关系将在以后的工作中带来。</p><p>在案例验证中，本研究分析了抢单影响下的车间流程资源重构。但是，在工业实践中还有一些情况需要进行资源重构分析，例如修改订单、设备故障等。因此，进一步的研究将集中在其他情况下如何改善制造资源配置。</p><h3 id="Conclusions-and-future-work"><a href="#Conclusions-and-future-work" class="headerlink" title="Conclusions and future work"></a>Conclusions and future work</h3><p>在车间层面开发低成本、系统的工程知识生成和分配服务机制是一项关键的研究挑战。本研究提出了一种新的基于知识图谱的设备资源分配优化方法，用于快速实时响应设备资源的配置需求。提出了生产过程的WRKG建模方法，包括WRKG的构建和基于WRKG知识表示学习和挖掘的方法。预计这两个方面将整合来自不同层次的处理知识，以支持资源分配方法。</p><p>在资源分配服务方面，提出了一种集成WRKG驱动设备资源分配优化的三阶段方法。<strong>第一步</strong>是生成标准化的加工知识，如工件特征、加工特征、加工类型、加工状态等。为了支持候选设备集的决策，<strong>第二步</strong>是使用制造资源社区评估模型评估可用设备。<strong>第三步</strong>旨在利用资源分配数学模型对处理设备集进行配置优化，保证设备的利用率最大化。最后，通过案例研究产品对所提出的方法进行评估，以证明工程知识在改进车间资源配置优化方面的价值。</p><p>未来，本研究将引入航天企业其他加工车间（热处理车间、焊接车间等）的资源，丰富航天加工车间资源之间的关系。此外，考虑包含更多的不可控因素，以提高整个资源重构过程的鲁棒性，并与其他方法进行比较。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops&quot;&gt;&lt;a href=&quot;#A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops&quot; class=&quot;headerlink&quot; title=&quot;A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops&quot;&gt;&lt;/a&gt;A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;动态订单需求和不确定的制造资源可用性是目前智能资源优化配置的研究热点。目前从制造业产生的数据量正在快速的增长。这些数据有多源头，异构和多尺度的特点。将数据转化为知识，优化个性化订单与制造资源的配置，是提高企业认知智能生产水平的有效策略。&lt;strong&gt;但是&lt;/strong&gt;，制造过程在资源配置上是多样化的。数据之间有很多规则和约束。数据之间的关系是更加复杂的，从海量制造数据中挖掘语义信息，缺乏统一的信息建模和工业知识生成方法。&lt;strong&gt;研究挑战&lt;/strong&gt;是如何充分整合车间资源的复杂数据，挖掘隐含的语义信息，形成可行的&lt;strong&gt;知识驱动的资源分配优化方法&lt;/strong&gt;。这种方法可以有效地提供资源分配所需的相关工程信息。本研究提出了一种统一的知识图驱动的生产资源分配方法，允许根据资源加工信息和设备评估策略，为给定的订单插入任务快速做出资源分配决策。提出了车间资源知识图谱（WRKG）模型来整合机加工车间的工程语义信息。开发了一种&lt;strong&gt;分布式知识表示学习算法&lt;/strong&gt;来挖掘隐式资源信息以实时更新WRKG。此外，提出了一种由 WRKG 支持的三阶段资源分配优化方法，以输出特定任务所需的设备集。以航空航天企业制造资源分配过程任务为例，论证了所提方法的可行性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="知识图谱" scheme="tags/知识图谱/"/>
    
    <category term="车间调度" scheme="tags/车间调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode739.每日温度</title>
    <link href="2023/05/11/leetcode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>2023/05/11/leetcode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</id>
    <published>2023-05-11T01:07:07.000Z</published>
    <updated>2023-05-11T02:57:25.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]输出: [1,1,4,2,1,1,0,0]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: temperatures &#x3D; [30,40,50,60]输出: [1,1,1,0]</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: temperatures &#x3D; [30,60,90]输出: [1,1,0]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>单调栈</li></ul><p>解本题的第一种解题思路是直接进行暴力模拟。但是本文的样例中，若数组的长度很长而且元素都是同一个值，会导致超出时间限制，因此我们必须考虑使用其他的数据结构帮助我们进行解题。本体可以使用栈的数据结构帮助我们解题，思路如下：首先初始化答案数组为全0，数组的长度为temperatures数组的长度，栈中的元素是尚未找到下一个更高温度的索引。遍历温度列表时，如果当前温度大于栈顶索引对应的温度，说明栈顶索引对应的温度已经找到了下一个更高温度，可以计算出答案并更新结果数组。通过这种方法，可以在一次遍历中完成计算，时间复杂度为 O(n)，满足时间限制。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        int len &#x3D; temperatures.size();        vector&lt;int&gt; answers(len, 0); &#x2F;&#x2F; 储存答案数组        stack&lt;int&gt; stk; &#x2F;&#x2F; 单调栈        for (int i &#x3D; 0; i &lt; len; i++) &#123;            while (!stk.empty() &amp;&amp; temperatures[stk.top()] &lt; temperatures[i]) &#123; &#x2F;&#x2F; 当当前温度高于栈顶索引的温度时                answers[stk.top()] &#x3D; i - stk.top(); &#x2F;&#x2F; 更新对应索引的answer                stk.pop(); &#x2F;&#x2F; 较低的温度的索引出栈            &#125;            stk.push(i); &#x2F;&#x2F; 较高的温度索引入栈        &#125;        return answers; &#x2F;&#x2F; 返回答案数组    &#125;&#125;;</code></pre><p>当给定输入 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，我们可以逐步执行优化后的代码来帮助您理解它的工作原理：</p><ol><li>初始化空栈和答案数组：stk &#x3D; []，answers &#x3D; [0, 0, 0, 0, 0, 0, 0, 0]。</li><li>遍历温度列表：<ul><li>对于第一个温度 73：<ul><li>栈为空，将索引 0 压入栈。</li></ul></li><li>对于第二个温度 74：<ul><li>栈顶索引对应的温度是 73，74 &gt; 73，可以计算答案 answers[0] &#x3D; 1。</li><li>弹出栈顶索引 0，将索引 1 压入栈。</li></ul></li><li>对于第三个温度 75：<ul><li>栈顶索引对应的温度是 74，75 &gt; 74，可以计算答案 answers[1] &#x3D; 1。</li><li>弹出栈顶索引 1，将索引 2 压入栈。</li></ul></li><li>对于第四个温度 71：<ul><li>栈顶索引对应的温度是 75，71 &lt; 75，将索引 3 压入栈。</li></ul></li><li>对于第五个温度 69：<ul><li>栈顶索引对应的温度是 71，69 &lt; 71，将索引 4 压入栈。</li></ul></li><li>对于第六个温度 72：<ul><li>栈顶索引对应的温度是 69，72 &gt; 69，可以计算答案 answers[4] &#x3D; 2。</li><li>弹出栈顶索引 4，将索引 5 压入栈。</li></ul></li><li>对于第七个温度 76：<ul><li>栈顶索引对应的温度是 72，76 &gt; 72，可以计算答案 answers[5] &#x3D; 1。</li><li>弹出栈顶索引 5，将索引 6 压入栈。</li></ul></li><li>对于最后一个温度 73：<ul><li>栈顶索引对应的温度是 76，73 &lt; 76，将索引 7 压入栈。</li></ul></li></ul></li><li>完成遍历后，栈中剩余的索引对应的答案无法计算，因为它们没有找到下一个更高温度。因此，答案数组中仍然为0。</li></ol><p>最终的答案数组为 [1, 1, 4, 2, 1, 1, 0, 0]，它表示每个温度需要等待的天数，直到出现更高的温度。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;temperatures&lt;/code&gt; ，表示每天的温度，返回一个数组 &lt;code&gt;answer&lt;/code&gt; ，其中 &lt;code&gt;answer[i]&lt;/code&gt; 是指对于第 &lt;code&gt;i&lt;/code&gt; 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 &lt;code&gt;0&lt;/code&gt; 来代替。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode503.下一个更大元素II</title>
    <link href="2023/05/10/leetcode503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/"/>
    <id>2023/05/10/leetcode503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/</id>
    <published>2023-05-10T01:36:21.000Z</published>
    <updated>2023-05-10T01:38:08.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,2,3,4,3]输出: [2,3,4,-1,4]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>直接进行循环遍历判断即可。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;        int len &#x3D; nums.size();        vector&lt;int&gt; answers;        for (int i &#x3D; 0; i &lt; len; i++) &#123;            int temp &#x3D; nums[i]; &#x2F;&#x2F; 保存当前需要判断的值            int temp_index &#x3D; i; &#x2F;&#x2F; 保存当前需要判断的值的索引            int answer &#x3D; -1; &#x2F;&#x2F; 初始化answer元素            for (int j &#x3D; (i + 1) % len; j !&#x3D; temp_index; j &#x3D; (j + 1) % len) &#123;                if (nums[j] &gt; temp) &#123;                    answer &#x3D; nums[j]; &#x2F;&#x2F;找到第一个比temp大的元素，将其赋值给answer 并跳出当前for循环                    break;                &#125;            &#125;            answers.push_back(answer); &#x2F;&#x2F; 将answer放进答案数组中        &#125;        return answers; &#x2F;&#x2F; 返回答案数组    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个循环数组 &lt;code&gt;nums&lt;/code&gt; （ &lt;code&gt;nums[nums.length - 1]&lt;/code&gt; 的下一个元素是 &lt;code&gt;nums[0]&lt;/code&gt; ），返回 &lt;em&gt;&lt;code&gt;nums&lt;/code&gt; 中每个元素的 &lt;strong&gt;下一个更大元素&lt;/strong&gt;&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;数字 &lt;code&gt;x&lt;/code&gt; 的 &lt;strong&gt;下一个更大的元素&lt;/strong&gt; 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode496.下一个更大元素I</title>
    <link href="2023/05/09/leetcode496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/"/>
    <id>2023/05/09/leetcode496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</id>
    <published>2023-05-09T12:35:51.000Z</published>
    <updated>2023-05-09T12:41:44.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].输出：[3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 2 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。下一个更大元素是 3 。- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li><li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力实现</li></ul><p>直接模拟实现</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt; answers;        map&lt;int,int&gt; m;&#x2F;&#x2F; m用于存储nums2数组中每个元素的下标值        for (int i &#x3D; 0; i &lt; nums2.size(); i++) &#123;            m[nums2[i]] &#x3D; i;        &#125;        for (int i &#x3D; 0; i &lt; nums1.size(); i++)&#123;            int index &#x3D; m[nums1[i]]; &#x2F;&#x2F; 获取nums1的元素在nums2的下标值            int answer &#x3D; -1;            int temp &#x3D; nums1[i];            if (index &#x3D;&#x3D; nums2.size() - 1) answer &#x3D; -1;            else &#123;                while (index &lt; nums2.size()) &#123;                    if(index+1 &lt; nums2.size() &amp;&amp; nums2[index+1] &gt; temp) &#123;                        answer &#x3D; nums2[index+1];                        break;                    &#125;                    else &#123;                        index++;                    &#125;                &#125;            &#125;            answers.push_back(answer);        &#125;        return answers;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;code&gt;nums1&lt;/code&gt; 中数字 &lt;code&gt;x&lt;/code&gt; 的 &lt;strong&gt;下一个更大元素&lt;/strong&gt; 是指 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;nums2&lt;/code&gt; 中对应位置 &lt;strong&gt;右侧&lt;/strong&gt; 的 &lt;strong&gt;第一个&lt;/strong&gt; 比 &lt;code&gt;x&lt;/code&gt; 大的元素。&lt;/p&gt;
&lt;p&gt;给你两个 &lt;strong&gt;没有重复元素&lt;/strong&gt; 的数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; ，下标从 &lt;strong&gt;0&lt;/strong&gt; 开始计数，其中&lt;code&gt;nums1&lt;/code&gt; 是 &lt;code&gt;nums2&lt;/code&gt; 的子集。&lt;/p&gt;
&lt;p&gt;对于每个 &lt;code&gt;0 &amp;lt;= i &amp;lt; nums1.length&lt;/code&gt; ，找出满足 &lt;code&gt;nums1[i] == nums2[j]&lt;/code&gt; 的下标 &lt;code&gt;j&lt;/code&gt; ，并且在 &lt;code&gt;nums2&lt;/code&gt; 确定 &lt;code&gt;nums2[j]&lt;/code&gt; 的 &lt;strong&gt;下一个更大元素&lt;/strong&gt; 。如果不存在下一个更大元素，那么本次查询的答案是 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;返回一个长度为 &lt;code&gt;nums1.length&lt;/code&gt; 的数组 &lt;code&gt;ans&lt;/code&gt; 作为答案，满足 &lt;code&gt;ans[i]&lt;/code&gt; 是如上所述的 &lt;strong&gt;下一个更大元素&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1356.根据数字二进制下1的数目排序</title>
    <link href="2023/05/09/leetcode1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/"/>
    <id>2023/05/09/leetcode1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/</id>
    <published>2023-05-09T12:00:40.000Z</published>
    <updated>2023-05-09T12:17:09.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p><p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p><p>请你返回排序后的数组。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]解释：[0] 是唯一一个有 0 个 1 的数。[1,2,4,8] 都有 1 个 1 。[3,5,6] 有 2 个 1 。[7] 有 3 个 1 。按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [10000,10000]输出：[10000,10000]</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,3,5,7,11,13,17,19]输出：[2,3,5,17,7,11,13,19]</code></pre><p><strong>示例 5：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [10,100,1000,10000]输出：[10,100,10000,1000]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 500</code></li><li><code>0 &lt;= arr[i] &lt;= 10^4</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路如下：</p><ol><li>首先定义一个辅助函数<code>countBits</code>，用于计算一个数的二进制表示中1的个数。该函数使用位运算技巧，通过不断将数字与其自身减1的结果进行按位与运算，可以统计出二进制中1的个数。</li><li>接下来定义一个自定义的比较函数<code>compare</code>，用于在排序时比较两个数的大小。该函数首先分别计算两个数的二进制中1的个数，然后比较它们的个数。如果个数相等，则按照原始数值的大小进行比较。</li><li>然后定义<code>sortByBits</code>函数，该函数接受一个整数数组作为参数，并使用STL的<code>sort</code>函数对数组进行排序。在排序过程中，使用自定义的比较函数<code>compare</code>进行比较。</li><li>在主函数<code>main</code>中，创建一个测试数组<code>arr</code>，并调用<code>sortByBits</code>函数对数组进行排序。排序后的结果保存在<code>sortedArr</code>中。</li><li>最后，通过循环遍历<code>sortedArr</code>，将排序后的数组打印输出。</li></ol><p>整体思路是先计算每个数字的二进制中1的个数，然后根据这个个数进行排序，当个数相同时按照原始数值的大小进行排序。通过自定义比较函数和使用STL的<code>sort</code>函数，可以方便地完成这个排序任务。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int get(int x)&#123;        int res &#x3D; 0;        while (x) &#123;            res +&#x3D; (x % 2);            x &#x2F;&#x3D; 2;        &#125;        return res;    &#125;    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123;        vector&lt;int&gt; bit(10001, 0);        for (auto x: arr) &#123;            bit[x] &#x3D; get(x);        &#125;        sort(arr.begin(), arr.end(), [&amp;](int x, int y)&#123; &#x2F;&#x2F; Lambda表达式语法            if (bit[x] &lt; bit[y]) &#123;                return true;            &#125;            if (bit[x] &gt; bit[y]) &#123;                return false;            &#125;            return x &lt; y;        &#125;);        return arr;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt; 。请你将数组中的元素按照其二进制表示中数字 &lt;strong&gt;1&lt;/strong&gt; 的数目升序排序。&lt;/p&gt;
&lt;p&gt;如果存在多个数字二进制中 &lt;strong&gt;1&lt;/strong&gt; 的数目相同，则必须将它们按照数值大小升序排列。&lt;/p&gt;
&lt;p&gt;请你返回排序后的数组。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>一种基于任务网络图聚合的多卫星多任务调度新方法</title>
    <link href="2023/05/07/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%BD%91%E7%BB%9C%E5%9B%BE%E8%81%9A%E5%90%88%E7%9A%84%E5%A4%9A%E5%8D%AB%E6%98%9F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%96%B0%E6%96%B9%E6%B3%95/"/>
    <id>2023/05/07/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%BD%91%E7%BB%9C%E5%9B%BE%E8%81%9A%E5%90%88%E7%9A%84%E5%A4%9A%E5%8D%AB%E6%98%9F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%96%B0%E6%96%B9%E6%B3%95/</id>
    <published>2023-05-07T07:37:24.000Z</published>
    <updated>2023-05-10T07:39:42.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>卫星网络任务调度时效性问题是实现空地一体化网络（STIN）的关键。传统方法将卫星任务调度问题解释为线性或非线性规划问题，忽略了任务之间的复杂关系。为了提高多卫星和多任务场景中任务调度的及时性，我们<strong>研究了解释任务相关性的网络图结构</strong>。然后，我们<strong>针对具有相似性和相关性特征的任务</strong>提出了多层网络图聚合模型。进一步，我们<strong>将任务调度问题转化为零一规划问题</strong>，设计任务调度算法来解决任务调度时效性问题。最后，我们模拟和模拟真实世界的数据作为实验数据集，用于与三种基线算法进行比较。实验结果表明本文方法具有明显的优势和进步。</p><span id="more"></span><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文的Introduction部分首先介绍了卫星任务调度的背景和意义，指出卫星任务调度是卫星运行中最重要的环节之一，其质量直接影响到卫星系统的性能和效益。然后，介绍了传统方法在多卫星和多任务场景下存在的问题，包括复杂的任务关系、低效的任务调度及时性等。接着，本文提出了一种基于任务网络图聚合的新方法来<strong>改善任务调度及时性</strong>。该方法将不同卫星上的原子任务聚合成一个整体图，并通过优化算法实现对整体图进行调度。最后，Introduction简要介绍了本文研究内容和结构安排，包括模型构建、算法设计、仿真实验等方面。</p><p>我们的贡献可以简要总结如下：</p><ul><li>我们<strong>建立了任务的网络图表示方法</strong>，解决了多卫星多任务关系复杂难表示的问题，实现了多任务复杂关系的统一表示。首先，我们根据任务的初始执行时间、资源需求、资源类型、任务操作等任务属性设计了任务的五元组。然后，我们将任务表示为边，任务属性表示为边属性，开始和结束执行事件表示为节点。根据任务执行时间的顺序，将任务之间的关系映射到边之间的关系，构建任务网络图。另外，我们根据资源类型、资源数量、可见时间窗的起止时间属性，设计了卫星的五元组。</li><li>我们<strong>构建了任务网络图的相似性聚合和相关性聚合模型</strong>，可以解决相似任务重复执行和相关任务独立分配带来的相互约束问题，实现多任务执行时间的最大压缩.首先，我们构建了多层任务网络图的聚合模型。根据任务之间的相似性和相关性，我们将所有任务网络图重构并聚合成一个大的任务网络图。然后，我们根据网络图和任务网络图中的关键路径计算出每个任务的最早开始执行时间和最晚结束执行时间，即完成所有任务的理论最短时间。</li><li>我们<strong>设计了多星多任务调度优化算法</strong>，保证大规模任务网络图能够在最短的理论时间内执行，实现多星多任务调度的高时效性。如果任务网络图中关键路径上的任务按时执行，任务网络图中的其他任务也会在资源充足时执行。因此，我们将多卫星和多任务调度问题解释为一个零一规划问题。然后，我们优先考虑关键路径上任务的资源分配策略，然后基于零一规划模型为剩余任务分配空闲卫星资源。</li></ul><h2 id="3-问题描述-amp-模型构建"><a href="#3-问题描述-amp-模型构建" class="headerlink" title="3. 问题描述&amp;模型构建"></a>3. 问题描述&amp;模型构建</h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h3><p>原子问题五元组：$\alpha &#x3D; &lt; t_{start}, r_t, r_n, oper, t_{end}&gt;$,tstart表示原子任务的计划初始执行时间，rt表示原子任务的资源需求类型，rn表示原子任务的资源需求，oper表示原子任务在卫星上的运行，tend表示最新的计划的执行时间。</p><p>可用卫星问题五元组：$s &#x3D; &lt;st_{start}, sr_t,sr_n, s_{oper}, st_{end}&gt;$,ststart表示卫星可见时间窗的开始时间，srt表示卫星当前提供的资源类型，srn表示卫星当前时刻可以提供的资源总量，soper表示卫星运行，stend表示可见时间窗的结束时间。</p><p>定义1 原子任务α由卫星直接执行，执行过程中不允许被打断。原子任务是从任务σ中分解出来的。</p><p>任务σ的原子任务α具有顺序执行关系，原子任务之间相互包容、相互制约。也就是说，有些原子任务只有在其他原子任务执行完之后才能执行。一般来说，原子任务有不同的资源类型、数量要求和初始执行时间，多个卫星可以满足同一个原子任务的资源需求。根据医院信息网络动态时变环境下原子任务的这些特点，计算多任务原子任务的执行顺序和执行时间，保证任务执行时间最短是关键问题。</p><h3 id="3-2-最短时间内完成机载多任务执行顺序动态计算模型"><a href="#3-2-最短时间内完成机载多任务执行顺序动态计算模型" class="headerlink" title="3.2 最短时间内完成机载多任务执行顺序动态计算模型"></a>3.2 最短时间内完成机载多任务执行顺序动态计算模型</h3><p>主要解决最小化任务执行时间的问题，假设特定时间段的开始时间为 Tstart ，结束时间为 Tend 。然后，</p><p><img src="http://cdn.leafii.top/img/image-20230507152603783.png" alt="image-20230507152603783" loading="lazy"></p><p>如式(3)所示，pi表示一个离散的时间段。 C1 表示 Γ 中的任何离散周期时间未被覆盖或重叠。 C2 表示从离散时间 i 到 j 的时间段为 pς 。我们需要计算任务执行在离散时间段Γ内的最短耗时，建立优化模型如下：</p><p><img src="http://cdn.leafii.top/img/image-20230507152625126.png" alt="image-20230507152625126" loading="lazy"></p><p>如式(4)所示，表示<strong>任意时间段Γ内所有原子任务并行执行消耗的最小时间的计算方法。</strong> p(i, j) ∈ Γ 表示在 Γ 中的一个小时间段，p(i, j) 不为零，即 i ≠ j。式(4)中，C1表示任意时间段p(i,j)的有效时间为p(θ,θ‘)。如图1所示，p(i,j)是随机考虑的某个时间段。该时间段包含的任务执行队列中最新任务的执行结束时间不一定严格等于j，即θ为p(i,j)中执行的第一个任务1的开始执行时间。同理，θ为最后一个任务8的执行结束时间。因此，我们取时间段p(i,j)内执行的第一个任务开始执行时间为θ，最后一个任务执行结束时间是θ’，p(θ, θ‘) ∈ τ 表示为 p(i, j) 中的多个任务全部执行完毕的最大起止时间。p(θ, θ’) 包含可以在 K(θ − θ’) 的时间段内完成的完整任务集。在离散时间段(θ,θ‘)中，我们取当前时间段内所有任务执行时间的最大值，max∀k∈K(t) Ct(k)表示所有任务的最大耗时值在时间 t 正在执行的任务。例如，式（4）中的C2表示单位时间的耗时约束。我们假设t是单位时间，那么任务Ct(k)的耗时为1。此时我们可以观察到在任务未执行时Ct(k)的值为0。另外，如果有正在执行的任务，则当前时刻消耗的时间记录为1，因此图1中所有任务消耗的最大时间为θ’-θ-(b-a)。</p><p><img src="http://cdn.leafii.top/img/image-20230507152752798.png" alt="image-20230507152752798" loading="lazy"></p><p>值得一提的是，式（4）中所有任务最早开始执行和最晚结束执行的时间和执行顺序<strong>并不准确</strong>，从而导致出现多种组合。不幸的是，当我们遍历所有可能的组合时，这对卫星的计算能力来说将是灾难性的。此外，它消耗了大量的计算时间，导致卫星网络执行任务的时效性差。那么，关键问题是如何快速计算出原子任务的执行顺序，并保证消耗的时间最少。</p><h2 id="4-问题转化和解决方式"><a href="#4-问题转化和解决方式" class="headerlink" title="4. 问题转化和解决方式"></a>4. 问题转化和解决方式</h2><p>将最小化执行时间的问题转化为两个子问题：<strong>计算原子任务开始和结束时间的问题</strong>以及<strong>聚合相似原子任务问题</strong></p><p>计算原子任务开始和结束时间的问题：确定原子任务的最早开始和最晚结束执行时间，以减少原子任务执行时间内的组合数量，将多种组合方案减少为少数几种可组合方案。然后，我们计算原子任务的最晚开始执行时间和最早结束执行时间，并结合结果数据确定某些任务的开始和结束执行时间。这个时候，原子任务的执行顺序也已经确定了。</p><p>聚合相似原子任务问题：我们根据原子任务之间的相似特征和相关关系特征聚合相似的任务执行，节省重复执行原子任务所消耗的时间。</p><h3 id="4-1-基于网络图表示的关键原子任务计算模型与算法"><a href="#4-1-基于网络图表示的关键原子任务计算模型与算法" class="headerlink" title="4.1 基于网络图表示的关键原子任务计算模型与算法"></a>4.1 基于网络图表示的关键原子任务计算模型与算法</h3><p>我们给定原子任务的统一表示元组。原子任务作为网络图的边，元组元素作为边的属性。节点表示原子任务开始或者结束执行的事件。原子任务之间复杂的关系由网络图结构进行表示。网络图的计算由两个元素组成：<strong>首先</strong>，每一个边的最早开始时间和最晚结束时间被用于计算原子任务的执行的时间范围。<strong>然后</strong>网络图的关键路径被计算，在关键路径上的任务为必要的原子任务。如果原子任务的优先计算得到了保障，那么我们可以得到所有原子任务的最小执行时间。</p><p>我们使用网络图数据结构去表示原子任务，然后重新定义了原子任务。原子任务由以下式子表示：</p><p>$\alpha’ &#x3D; &lt;t’_{start}, t_{start}, r_t, r_n, oper, t_{end}, t’_{end}&gt;$</p><p>我们添加了原子任务的最早可能开始时间 t′ start 和允许完成执行的最晚时间 t′ end 。一个任务 σ 可以分解为多个原子任务 σ &#x3D; {α′ 1, α′ 2, α′ 3, … , α′ n}。</p><h4 id="4-1-1-任务网络图表示"><a href="#4-1-1-任务网络图表示" class="headerlink" title="4.1.1 任务网络图表示"></a>4.1.1 任务网络图表示</h4><p>根据原子任务集合中原子任务的优先级重新分配原子任务的执行顺序，并且获得新的原子任务队列。我们将网络中的<strong>边表示为网络图的原子任务</strong>。图中的<strong>节点表示为原子任务执行的事件</strong>。</p><p><img src="http://cdn.leafii.top/img/image-20230505174740721.png" alt="image-20230505174740721" loading="lazy"></p><blockquote><p>示意图显示了原子任务之间的依赖关系。子图(a)表示边代表原子任务，子图(b)节点表示原子任务执行的事件。</p></blockquote><p>在构建任务网络图之前，我们需要计算原子任务的<strong>计划完成时间</strong>。</p><p>$P(\alpha’<em>i) &#x3D; t</em>{end, i} - t_{start, i}$</p><p>这个式子里的$P(\alpha’_i)$就是原子任务$\alpha’_i$的计划完成时间。</p><p>然后边的属性可以表示为$w_i &#x3D; (t’<em>{start}, A_i, t’</em>{end})$,而且边的属性的集合为$W &#x3D; {w_1, w_2, …, w_m}$</p><h4 id="4-1-2-任务网络图计算模型"><a href="#4-1-2-任务网络图计算模型" class="headerlink" title="4.1.2 任务网络图计算模型"></a>4.1.2 任务网络图计算模型</h4><p>如图所示。$v_1$是任务执行开始的事件，$v_7$是任务执行结束时的事件。图G表示一个特定任务的所有原子任务的<strong>依赖关系</strong>。节点上的出度边所代表的原子任务可以在节点上的入度边所代表的原子任务完成后执行。边的属性信息W表示原子任务的执行时间、最早执行时间和最晚执行时间。</p><p><img src="http://cdn.leafii.top/img/image-20230505191049565.png" alt="image-20230505191049565" loading="lazy"></p><p>引理1. <strong>关键路径</strong>的引理和证明 略</p><p>定理1. T 是关键路径上的关键任务集。除关键路径P的任务集外，其余任务集为Q。C(T) + C(Q) &#x3D; min(C(G))，其中执行 T 的<strong>时间成本</strong>是 C(T)，执行 Q 的时间成本是 C(Q)， 时间成本的证明略</p><p>从引理 1 可以看出，我们关心的是任务的<strong>开始和结束事件最早和最晚发生的时间</strong>，网络中最后一个事件的完成时间就是整个图像完成的时间。然而，定理 1 关注的是<strong>网络图中所有边所代表的任务执行时间和成本的总和</strong>。同时，时间成本是网络图上边的权重。</p><p>为了保证提升任务执行效率并缩短任务的执行时间，我们需要<strong>计算完成任务所需的最短时间以及对任务执行时间有影响的关键任务</strong>。如果我们保证关键任务的正常执行，那么理论上我们可以获得网络图执行的最短时间。对于任务网络图G，是完成最后一个事件Vm和每个原子任务的关键性的最短时间。同时，我们可以参考AOE（Activity on edge network）网络的关键路径计算方法。</p><p><img src="http://cdn.leafii.top/img/image-20230505192540505.png" alt="image-20230505192540505" loading="lazy"></p><p>te(vj )表示<strong>任务事件最早发生的时间</strong>，P(ez)表示执行原子任务所需的时间。在约束条件C1中，T是所有以顶点vk结尾的边的头顶点集合，ez代表所有以顶点vk结尾的边。ez 表示所有以顶点 vk 结尾的边。以节点vj的所有原子任务中执行时间最长的原子任务为出度，事件vi最早发生时间之和就是事件vi最早发生时间。</p><p>从已完成的顶点vn开始，令l(vn) &#x3D; e(vn)求拓扑序中<strong>剩余顶点的最晚允许出现时间</strong>。如式(8)所示，S是所有以vj为头的弧的尾顶点的集合。如约束条件 C2 所示，j 必须满足约束条件 1 ⩽ j ⩽ n − 1。</p><p><img src="http://cdn.leafii.top/img/image-20230505193310443.png" alt="image-20230505193310443" loading="lazy"></p><p>找出每个原子任务ei的最早开始时间<strong>e(i) &#x3D; e(vj )</strong>, 1 ⩽ i ⩽ m，最晚开始时间**l(i) &#x3D; l(vk) − P (vj , vk)<strong>。如果一个弧</strong>满足e(i) &#x3D; l(i)**，那么它就是一个关键任务。</p><h4 id="4-1-3-关键原子任务的计算算法"><a href="#4-1-3-关键原子任务的计算算法" class="headerlink" title="4.1.3 关键原子任务的计算算法"></a>4.1.3 关键原子任务的计算算法</h4><p>由上述的（8）和（7），我们设计了一个<strong>网络图计算算法</strong>，算法如下：</p><p><img src="http://cdn.leafii.top/img/image-20230505193623442.png" alt="image-20230505193623442" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230505193635610.png" alt="image-20230505193635610" loading="lazy"></p><p>算法2的设计参考了AOE网络的关键路径求解方法。首先，算法1被用于创建一个任务网络图并且进行拓扑排序的操作，并且初始化所有时间的发生时间为0.算法 2 以网络图作为输入数据（第 1-3 行），然后根据拓扑排序顺序从前到后更新事件的最早执行时间。用每个顶点的每个相邻点更新e(v)，其值是连接到当前节点和相邻节点的所有边的最大值与当前最早时间之和（第4-9行）。同理，按照拓扑排序顺序，从后向前更新节点最晚出现时间l(v)（第10行），求出每个原子最早出现时间e(edge)和最晚出现时间l(edge)根据 e(v) 和 l(v) 的任务。根据e(edge)和l(edge)是否相等判断原子任务是否为关键原子任务。网络图中最后一个节点的最早出现时间是整个任务的最早完成时间（第 11-22 行）。</p><h3 id="4-2-基于原子任务相似特征的多网络图聚合模型及算法"><a href="#4-2-基于原子任务相似特征的多网络图聚合模型及算法" class="headerlink" title="4.2 基于原子任务相似特征的多网络图聚合模型及算法"></a>4.2 基于原子任务相似特征的多网络图聚合模型及算法</h3><p>通过考虑原子任务的相似性和相关特征，我们将不同的网络图聚合成一整个图。拥有相似特征的原子任务可以被组合为一个简单的原子任务。同样的，有关联的多原子任务可以被聚合成一个可以在单个卫星完成的不可分解的任务集合。由于多层网络图在聚合过程有环路，会导致<strong>计算关键路径</strong>失败。因此，我们基于剪枝的思想设计了一种破环算法来实现多层网络图聚合的目的。</p><p>基于刚才提出的网络图表示方法，我们可以把多任务表示为多网络图。在网络图之间偶尔会有很多边会被合并从而形成一个大范围的网络图。定义3解释了任务聚合，也就根据特定的规则将多个网络图合并为一个网络图。任务聚合的规则有两方面：依赖聚合关系以及相似聚合关系。定义4解释了依赖聚合关系的定义，定义5解释了相似聚合关系的定义。</p><p>定义3 <strong>任务聚合</strong>是指分析多个任务的原子任务集φ并将满足特定约束的多个原子任务聚合到一颗卫星上执行，或者将多个具有相似特征的原子任务合并为一个原子任务。最终形成一组新的原子任务。聚类后的任务集仍然是原子任务集。</p><p>定义4 <strong>依赖聚合关系</strong>是指原子任务执行顺序之间的相互依赖关系。如果一个原子任务αi的执行结果是另一个或多个原子任务的执行前提，则这些原子任务满足依赖聚合关系。</p><p>依赖包括多对一的依赖以及一对一的依赖，如图所示.</p><p><img src="http://cdn.leafii.top/img/image-20230506204533547.png" alt="image-20230506204533547" loading="lazy"></p><p>定义5 <strong>相似聚合关系</strong>定义为原子任务之间存在相似的资源需求、任务需求或执行结果。如果同一卫星在同一周期内可以执行多个原子任务，则这些原子任务之间满足相似聚合关系。</p><p>如图6所示，子图(a)描述了分散在多颗卫星上的具有相似特征的多个原子任务，子图(b)描述了可以包含其他原子任务特征的原子任务，子图(c)描述了多颗卫星- 原子任务聚合成一个原子任务。</p><p><img src="http://cdn.leafii.top/img/image-20230506204630468.png" alt="image-20230506204630468" loading="lazy"></p><p>目标原子任务的执行结果数据包含所有源原子任务的执行结果数据。所以目标原子任务可以代替所有源原子任务的执行过程。</p><h4 id="4-2-1-相似原子任务聚合模型"><a href="#4-2-1-相似原子任务聚合模型" class="headerlink" title="4.2.1 相似原子任务聚合模型"></a>4.2.1 相似原子任务聚合模型</h4><p>为了降低非必要任务执行的影响，我们研究了所有相似和相关任务聚合的方法。所有的原子任务都在集合X上执行，单颗卫星可以独立完成一个原子任务，不需要多颗卫星联合执行。集合Z&#x3D;{R,B,L}中所有具有依赖关系的原子任务记为R。具有相似关系的所有原子任务的集合为B&#x3D;{S,H}，S表示具有相似关系的所有目标原子任务的集合相似关系，H表示具有所有相似关系的原子源任务集合，所有不符合聚合关系的原子任务集合为L，则原子任务集合Z由卫星集合X执行完成所需的总消耗的时间如方程式所示。 (12),</p><p><img src="http://cdn.leafii.top/img/image-20230506213501362.png" alt="image-20230506213501362" loading="lazy"></p><p>我们将执行具有依赖关系的所有目标原子任务集合R的卫星集合记为A，将执行具有依赖关系的目标原子任务αr的卫星记为xr，则所有具有依赖关系的原子任务聚合后<strong>消耗的时间模型</strong>如下所示在 (13)</p><p><img src="http://cdn.leafii.top/img/image-20230506214147818.png" alt="image-20230506214147818" loading="lazy"></p><p>T(R)表示所有具有依赖关系的原子任务集合执行所消耗时间的总和。</p><p>把10和9式子放进13中，可得到式14:</p><p><img src="http://cdn.leafii.top/img/image-20230506214341116.png" alt="image-20230506214341116" loading="lazy"></p><p>我们将执行具有相似关系S的所有目标原子任务的卫星集合表示为B，将执行目标原子任务s的卫星表示为xs。则<strong>聚合后所有具有相似关系的原子任务消耗的时间模型</strong>如式(15)所示。</p><p><img src="http://cdn.leafii.top/img/image-20230506214437470.png" alt="image-20230506214437470" loading="lazy"></p><p>C(γ(s), xs)表示目标原子任务s在卫星xs上消耗的执行时间。C1是对目标原子任务集合的距离约束，表示卫星执行原子任务时天线角度或遥感设备角度等操作的转换时间。 C2是具有相似特征的源和目标原子任务之间的约束关系。</p><p>所有原子任务集合Z中<strong>除相似特征原子任务和原子依赖任务外其余任务的执行耗时</strong>可构造为式(16)，</p><p><img src="http://cdn.leafii.top/img/image-20230506214559626.png" alt="image-20230506214559626" loading="lazy"></p><p>D是执行原子任务集合L的卫星集合，C(γ(l),xl)是执行不可聚合的原子任务所消耗的时间，xl是执行原子任务l的卫星。</p><p>综上所述，我们构建了<strong>可聚合的原子任务执行时间消耗模型和其他原子任务执行时间消耗模型</strong>。 代入方程式。 （14），（15）和（16）进入等式。 (12) 产生执行和完成所有任务 N 所消耗的时间总和。 时间消耗如方程式 (17)所示。</p><p><img src="http://cdn.leafii.top/img/image-20230506214727347.png" alt="image-20230506214727347" loading="lazy"></p><p>其中C1-C2表示所有可聚合原子任务与其他原子任务的关系和范围，所有任务执行时间T都不为0。C3-C5说明具有可聚合关系的源原子任务和目标原子任务之间的关系和约束。 C6表示原子任务执行过程中卫星完成天线或载荷设备角度调整所消耗的时间，我们默认为一个固定值。</p><p>总之，我们对多颗卫星上多任务执行的时间消耗进行建模，如式（17）所示，并求解该式。 𝑇 预先假定需要确定哪些原子任务有资格进行聚合以及选择卫星来执行它们。 一旦确定了这些要求，就可以<strong>更新聚合原子任务的网络图表示</strong>，然后可以根据算法2<strong>求解多任务执行的最小时间消耗</strong>。</p><h4 id="4-2-2-相似原子任务聚合算法"><a href="#4-2-2-相似原子任务聚合算法" class="headerlink" title="4.2.2 相似原子任务聚合算法"></a>4.2.2 相似原子任务聚合算法</h4><p>本节我们基于上述多层网络聚合模型设计相应的求解算法。在多图聚合的过程中，我们发现了多图聚合后产生循环的情况。我们设计了一种聚合后不产生循环的算法，并建立了一种消除任务网络图中循环的方法。</p><h5 id="A-层任务网络图的相似度聚合算法"><a href="#A-层任务网络图的相似度聚合算法" class="headerlink" title="A. 层任务网络图的相似度聚合算法"></a>A. 层任务网络图的相似度聚合算法</h5><p><img src="http://cdn.leafii.top/img/image-20230506215146281.png" alt="image-20230506215146281" loading="lazy"></p><p>在图7的a中有两个网络图的初始状态。我们基于原子任务的属性特征不同来计算任务之间的相似度。比如，如果多个观测任务的观测区域重叠，在观测任务的一些原子任务之间就有一个相似度。观察区域覆盖率较大的原子任务就是需要聚合的目标原子任务，我们称之为目标原子任务。观察目标区域较小的原子任务是等待聚合的原子源任务，我们称之为源原子任务。根据这些规则，我们确定要在多图中聚合的目标任务和源原子任务。</p><p>值得一提的是，目标原子任务可以有多个源原子任务与之对应，而源原子任务只有一个目标原子任务。如图b，蓝色的边表示目标原子任务，红边表示源原子任务。再决定目标和源原子任务后，我们需要跨越多个图并建立源原子任务和原子目标任务之间的关系。如图c所示，我们通过创建9-&gt;3和5-&gt;12虚拟边来聚合两个图。尽管多个图可以通过虚拟边聚合为一个图，额外的虚拟边以及属性值的设定影响着多图聚合的效果。因此，我们将虚拟边的属性值设置为0并且用最少的虚拟边将原子目标任务进行连接。子图 (c) 描绘了具有多个源节点 1,8 和多个汇点 7,14 的完整网络图。此时的网络图并没有计算使用算法2的所有任务的最小消耗时间和关键原子任务。因此我们需要把多源多沉没的网络图表示为单源单沉没的网络图。如图d所示，我们增加两个虚拟事件0，-1，虚拟事件0是网络图的源，虚拟事件1时网络图的下沉。同时，我们增加虚拟边0-&gt;1, 0-&gt;8, 7-&gt;-1, 14-&gt;-1到网络图中。此外，红色边被蓝色边合并，并且虚拟边被创建去消除原子源任务，消除了完成两个原子任务的需求以实现仅一个目标原子任务的目标。新的逻辑虚拟结点表示一个空的原子任务，它并未被执行。在消除原子源任务9-&gt;12后，与其关联的事件9,12也可消除。如图e所示，事件9和3被合并，事件12和5被合并，最终导致一个完整的网络图被聚合。</p><p><img src="http://cdn.leafii.top/img/image-20230506223615258.png" alt="image-20230506223615258" loading="lazy"></p><p>如图8所示，图a到f描述了拥有一个目标原子任务的多源原子任务的聚合过程。图a描述了两个任务的网络图的初始状态。图b表示聚合关系的计算结果，蓝色边表示原子目标任务，红色边表示要被合并的原子源任务。如图c所示，虚拟边9-&gt;3，5-&gt;12以及11-&gt;3,5-&gt;10被添加用目标原子任务去合并两个源原子任务。如图d所示，为了将多源，多下沉网络图转化为单源，单下沉网络图，我们增加两个虚拟事件0，-1，我们添加两个虚拟事件 0、-1，以及虚拟边 0 → 1、0 → 8 和 7 → −1、14 → −1。剔除源原子任务 9 → 12 和 11 → 10 后，事件 9、11、12、10 就没有有意义的存在了。因此，事件9，11需要与事件3合并。同样，事件12，10需要与事件5合并，合并结果如子图（e）所示。我们发现事件 8 和事件 3 之间有两条边，即要执行的两个原子任务。类似地，在事件 5 和事件 14 之间有两个原子任务要执行。如子图 (f) 所示，我们的任务网络图表示中不允许两个相邻事件之间存在两条或更多条边。因此，我们添加两个虚拟事件-2、-3和两个虚拟边缘8→-2和-3→14。目标原子任务的虚拟事件、虚拟边缘和事件3,5之间的关系为8→ −2 → 3 和 5 → −3 → 14 其中 8 → −2 → 3 上的原子任务是随机选择子图 (e) 中事件 5 和事件 14 之间的两个原子任务。同样，5 → -3 → 14 是在事件 5 和事件 14 之间的两个原子任务中的随机选择。最后，根据原子任务相似性，将两个网络图表示为一个完整的网络图。</p><p><img src="http://cdn.leafii.top/img/image-20230507132332862.png" alt="image-20230507132332862" loading="lazy"></p><p>如图9所示，它描述了具有数据依赖性的原子任务之间的聚合过程。子图 (a) 显示了两个图的初始状态。子图 (b) 描述了两个图中的目标和源原子任务，其中蓝色边表示原子目标任务，两条红色边表示原子源任务。原子任务 4 → 6 的执行需要原子任务 10 → 14 和 13 → 14 的执行。关联原子任务聚合不是消除原子任务，而是将具有关联的原子任务从分散状态转换为集中状态。那么我们需要尽可能将具有相关性的原子任务分配给一颗卫星执行，这样可以减少大量卫星协同处理数据所花费的时间。如图(c)所示，虚拟边14→4连接两个图，虚拟节点0和虚拟边0→1、0→8将图从多源节点转变为单源节点。子图（d）描绘了事件14,4的合并，其中原始事件10→14、13→14被转换为10→4、13→4。原子目标任务和原子源任务没有改变，但它们的关系被改变，使它们更紧凑。根据卫星资源状况，我们可以考虑将新的目标原子任务4→6和原子源任务10→4、13→4在同一颗卫星上执行，减少数据请求和数据传输的耗时。</p><p>定理 2. 给定一个单源单汇网络图 G。如果 G 中存在任务 ei，则其属性五元组为 α(ei) &#x3D; ⟨tei start, rei t, rei n, operei, tei end⟩,以及任务执行时间范围 L(ei) &#x3D; (tei start, tei end)。存在一个任务 ej，其属性为 α(ej) &#x3D; ⟨tej start, rej t, rej n, operej , tej end⟩，任务执行时间范围为 L(ej ) &#x3D; (tej start, tej end)。如果rei t &#x3D; rej t, L(ei) ∩ L(ej ) ≠ ⊘，则存在一个任务ek 可以替代任务ei 和ej 并且任务ek 的耗时小于任务ei 和ej 的总和。</p><p>证明略</p><p>根据定理 2，我们构建任务 ek 来替换网络图 G 中的任务 ei 和 ej，并且任务 ek 被执行的时间成本小于任务 ei 和 ej 的总和。</p><p><strong>算法3描述了原子任务相似性特征的多任务聚合过程</strong>。首先获取原子任务属性数据，然后计算不同原子任务的相似性特征（第 1-7 行）。基于每个原子任务的特征数据，采用K-均值聚类算法计算原子任务在多个网络图中的相似度，选择原子目标任务作为聚类算法的质心。与每个质心相邻的原子任务可视为原子源任务（第 9 行）。我们根据计算结果得到源和目标原子任务的启动和终止事件。然后我们构建一个虚拟链接，它建立在原子源任务的起始节点和目标原子任务的起始节点之间。目标原子任务的终止节点实际上链接到源原子任务的终止节点。最后，删除所有原子源任务（第 10-11 行）。如果两个事件之间存在两个或多个原子任务，则必须重建多个原子任务连接。我们通过构建虚拟节点和虚拟边（第 12-15 行）将额外的原子任务连接到新路径。最后，源原子任务的开始和结束节点与目标原子任务的开始和结束节点合并（第 16-17 行）。</p><p><img src="http://cdn.leafii.top/img/image-20230507134025076.png" alt="image-20230507134025076" loading="lazy"></p><h5 id="B-原子任务数据依赖的识别与聚合算法"><a href="#B-原子任务数据依赖的识别与聚合算法" class="headerlink" title="B. 原子任务数据依赖的识别与聚合算法"></a>B. 原子任务数据依赖的识别与聚合算法</h5><p>定理3. 给定一个单源单汇网络图 G。如果 G 中存在任务 ei，则其属性五元组为 α(ei) &#x3D; ⟨tei start, rei t, rei n, operei, tei end⟩,以及任务执行时间范围 L(ei) &#x3D; (tei start, tei end)。存在一个任务 ej，其属性为 α(ej) &#x3D; ⟨tej start, rej t, rej n, operej , tej end⟩，任务执行时间范围为 L(ej ) &#x3D; (tej start, tej end)。将任务𝑒𝑖和𝑒𝑗的执行过程产生的成本表示为𝜇，当𝑒𝑖是任务𝑒𝑗的入口度边时，任务𝑒𝑖和𝑒𝑗的执行过程产生的成本表示为𝜈，<strong>则𝜇⩾𝜈</strong>。</p><p>证明略。</p><p><img src="http://cdn.leafii.top/img/image-20230507134813348.png" alt="image-20230507134813348" loading="lazy"></p><p>由定理3可知，<strong>将具有相关关系的任务聚合在一起执行所消耗的成本要小于聚合前所消耗的成本。</strong>因此，我们根据定理3设计了<strong>基于多任务依赖关系的聚合算法4</strong>。该算法描述了原子任务相关关系特征的识别和多任务聚合过程。首先，我们获取原子任务属性数据，然后计算不同原子任务的相似性特征（第 1-7 行）。然后，根据每个原子任务的特征数据，我们计算原子任务在多个网络图中的相关性，输入数据是其他原子任务的输出数据，可以将其视为目标原子任务。相反，其输出数据可用作其他原子任务的输入数据的原子任务可被视为源原子任务（第 9 行）。基于计算出的源任务的端点事件和目标任务的起点事件，我们在源任务的端点事件和目标任务的起点之间创建了一个虚拟链接。为了构建单源单汇网络图，创建虚拟节点和虚拟边并将其链接到网络图的多个源和汇，并删除与源原子任务关联的虚拟边，最后将端点源原子任务的起点与目标原子任务的起点合并（代码 10-12）。</p><h5 id="C-消除网络图中多环路的形成"><a href="#C-消除网络图中多环路的形成" class="headerlink" title="C. 消除网络图中多环路的形成"></a>C. 消除网络图中多环路的形成</h5><p>A小节描述的多层网络图的聚合过程属于没有出现环路的情况。然而，现有空间信息网络中任务图的合并过程会产生多个循环。因此，本节C提出了一种<strong>消散多层网络图聚合过程中的环路形成的方法</strong>，并设计了打破四种环路的算法，以解决多层网络图聚合过程中的环路形成问题。</p><p>由<strong>待聚合边的源节点的入度边引起的环路解析过程</strong>描述如示意图10所示。</p><p><img src="http://cdn.leafii.top/img/image-20230507135753688.png" alt="image-20230507135753688" loading="lazy"></p><p>子图(a)为循环生成前的状态。边 (a, b) 是目标任务，边 (53, 54) 是要聚合的任务。事件50为已经合并的事件，边(51, 53)为节点53的入度边。子图(b)描述了任务(a, b)和(53, 54)完成合并后的状态已被合并。由于边 (53, 54) 被 (a, b) 替换，因此边 (51, 53) 被移除并添加了新边 (51, a)。同时，图中存在环路。事件50、51、a形成子图(c)所示的循环。如子图（d）所示，为了打破循环，我们添加了一个新的虚拟事件 0 和一条权重为 -w 的边 (0, 51)，从而在不丢失原始边上的权重 w 的情况下打破了原始循环（ 51，a）。此外，我们需要将图的起始节点’start’连接到新的虚拟事件0。类似地，图11描述了由边的源节点的入度边引起的环路解析过程是聚合。子图(a)和(b)描述了边(53, 54)聚合的过程，任务(53, 51)是源53的出度边。子图(c)是之后形成的循环聚合，子图（d）添加虚拟时间0，添加边0,51以打破循环，最后将网络源节点start连接到虚拟节点0。</p><p><img src="http://cdn.leafii.top/img/image-20230507140348700.png" alt="image-20230507140348700" loading="lazy"></p><p>如示意图12所示，描述了由<strong>待聚合边的汇聚节点的入度边引起的环路解析过程</strong>。子图(a)为环路生成前的状态，其中边(a, b)为目标任务，边(49, 50)为待聚合任务。子图(b)描述了任务(a, b)和(49, 50)合并后的状态，由于(49, 50)被(a, b)替换，该图形成了一个循环。事件b、52、51形成一个循环，如图(c)所示。如子图 (d) 所示，我们添加了一个新的虚拟事件 0 和一条权重为 -w 的边 (0, 51) 来打破循环，从而在不丢失边 (51, b) 上的权重 w 的情况下打破了原始循环。此外，我们需要将网络源节点“start”连接到添加的虚拟事件0。类似地，图13描绘了由要聚合的边缘的汇节点的出度边缘引起的环路解决过程。子图 (a) 和子图 (b) 描述了边 (49, 50) 聚合的过程。子图(c)表示聚合后形成的环路，子图(d)加入虚拟时间0，加入新的边(0, 51)打破环路，最后将网络源节点start连接到虚拟节点0。</p><p><img src="http://cdn.leafii.top/img/image-20230507140413748.png" alt="image-20230507140413748" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230507140618038.png" alt="image-20230507140618038" loading="lazy"></p><p>定理 4. 给定一个没有循环的网络图 G 和 G’，要合并的边 e(a, b) ∈ G 和合并后的边 e(c, d) ∈ G’，其中 e( c, d) 是 I(c)，输出边的集合是 O(d)。加入一条新的边e(m, n)连接边e(a, b)和边e(c, d)，合并后的新边为e(a’, b’)。如果合并边e(a, b)和e(c, d)，则得到一个新的网络图G’’，其中生成了环路P。添加事件 v 最早发生时间 ve(v) &#x3D; ve(m) 和最晚发生时间 vl(v) &#x3D; vl(m) 的新虚拟节点 v。权重为 w 的虚拟边 ev 和反向虚拟边创建具有权重 −w 的边 e′ v 并用于打破循环。同时，得到无环合并网络图G*。如果在不考虑虚拟边权重的情况下计算网络图的总时间成本，则 **min(C(G∗)) &#x3D; min(C(G) + C(G′))**。</p><p>证明略。</p><p>由定理4可知，<strong>聚合后多网络图的时间成本消耗小于聚合前原始网络图的时间消耗</strong>。然而，聚合网络图不允许环路的存在。为了解决这个问题，我们设计了<strong>算法 5 来打破聚合网络图中的循环</strong>。该算法描述了消除网络图中循环歧义的过程。首先，我们获得所有聚合边的入度和出度边（第 2-3 行）。如果网络图中存在环路，则判断合并边(source, sink)的源节点source的入边suInEg或出边suOutEg是否在环路路径中。如果它在循环中，它会删除任一条边，中断循环，并添加具有权重的新边，从而保持网络权重不变（第 714 行）。类似地，伪代码（第 16-22 行）中显示了合并边的源节点源（源、汇）的循环中断。</p><p><img src="http://cdn.leafii.top/img/image-20230507140951660.png" alt="image-20230507140951660" loading="lazy"></p><h4 id="4-3-基于聚合网络图的多星资源分配方法"><a href="#4-3-基于聚合网络图的多星资源分配方法" class="headerlink" title="4.3 基于聚合网络图的多星资源分配方法"></a>4.3 基于聚合网络图的多星资源分配方法</h4><p>基于聚合后的网络图，我们需要将网络图上的任务分配给场景中的所有有效卫星。我们将任务调度问题转化为 0-1 规划问题。然后开发了基于聚合网络图的任务调度模型，并设计了求解算法以实现高时间效率的任务调度。</p><p>本节基于聚合网络图解决多星资源分配问题，实现多星多任务的高时效调度。为了更方便地描述我们的多卫星和多任务调度模型，我们根据 3.1 节中描述的原子任务和卫星元组表示简化任务集为 σ &#x3D; σ1, σ2, … , σm，其中 m 是任务。任务的属性集表示为 σi &#x3D; ai, bi, ci, di, 0 ⩽ i &lt; m，其中 A 表示卫星接触窗口的开始时间，B 表示任务资源需求数，C表示卫星接触窗口的结束时间，D表示卫星资源类型。卫星集合简化为 S &#x3D; s1, s2, … , sn，其中 n 是卫星的数量。每个卫星属性表示为 sj &#x3D; ej , fj , gj , hj , 0 ⩽ j &lt; n，其中 E 表示任务开始执行的时间，F 表示任务需要的资源数量，G 表示时间任务完成的时间点，H 表示任务要求的资源类型。</p><p>根据上述定义，我们将多星-原子任务的任务执行最小时间记为T&#x3D;min f(X)，T为任务等待执行时间与任务执行时间之和。我们可以<strong>转化多卫星多任务调度问题为 0–1 规划问题。</strong>该模型的构造如下：</p><p><img src="http://cdn.leafii.top/img/image-20230507141611179.png" alt="image-20230507141611179" loading="lazy"></p><p>如方程式 (18)所示。C1为待解矩阵X的描述。 X 是由要求解的值形成的矩阵。矩阵中的元素标识卫星是否被允许参与执行某项任务。 xi,j在矩阵X中的第j列表示任务σj在卫星si上的执行状态。如果 xi,j &#x3D; 0，则意味着卫星 si 没有资源分配给任务 σj 。</p><p>反之，则意味着卫星需要为指定的任务分配资源。 C2是根据任务数量和卫星数量生成的所有已知元素为1的矩阵。 C3表示f(X)的解需要满足任务开始执行时间大于卫星可见时间窗开始时间。 C4表示卫星可见时间窗的结束时间需要大于任务执行的结束时间。 C5是指卫星拥有的资源类型应与任务所需的资源类型相同。 C6表示卫星拥有的资源数量需要大于任务所需的资源数量。</p><p><strong>算法6描述了多星多任务的调度过程，我们重点计算任务本身的执行顺序和执行时间的优化。</strong>首先，我们根据任务网络图表示算法 1（第 3 行）构建具有多个任务的多个网络图。然后使用算法 3 聚合多图中具有相似特征的原子任务。通过使用算法 4 聚合多图中具有数据依赖性的原子任务，获得由多个任务组成的单源单汇网络图（第 5-6 行） .根据算法 5 消除网络图中的循环。根据算法 2（第 7-8 行）计算无循环网络图中的关键原子任务和整个图要消耗的最短时间。我们使用第三方计算库P uLP 2 根据每个原子任务的最早和最晚执行时间、关键原子任务、聚合的原子任务来计算原子任务。根据每个原子任务的最早和最晚执行时间、关键原子任务、被聚合的原子任务等，为原子任务分配卫星资源。分配卫星资源，使其不超过原子任务的最早或最晚执行时间，并且通常执行关键原子任务（第 9-15 行）。 至此，多任务将在最短时间内完成，无需考虑复杂的资源约束和优化策略，即可计算出多星多任务耗时最短的调度方案。</p><p><img src="http://cdn.leafii.top/img/image-20230507142136552.png" alt="image-20230507142136552" loading="lazy"></p><h2 id="5-实验"><a href="#5-实验" class="headerlink" title="5. 实验"></a>5. 实验</h2><h3 id="5-1-算法复杂度分析"><a href="#5-1-算法复杂度分析" class="headerlink" title="5.1 算法复杂度分析"></a>5.1 算法复杂度分析</h3><p>我们着重研究了任务执行顺序和执行时间的计算，以克服多个任务混合执行耗时控制的困难，保证任务执行耗时最少。我们研究了原子任务聚合算法，可以节省不必要的原子任务执行时间消耗，进一步提高多任务执行效率。基于多任务网络图聚合的调度方法主要包括五种算法：网络图构造算法、相似原子任务聚合算法、相关关系原子任务聚合算法、网络图关键路径和最小耗时计算算法、多星多-任务调度算法。</p><p>算法1将所有原子任务视为网络图的边，将原子任务的开始执行事件和结束执行事件分别视为边的节点。算法输入是一个任务，所以算法的时间复杂度主要体现在该任务的所有原子任务的遍历过程中。如果原子任务的个数是E，那么它的时间复杂度就是O(E)。算法2主要计算特定网络图上的关键任务路径和整个网络图完成执行所需的最短时间。其计算时间消耗主要体现在网络图节点和边的遍历上，时间复杂度为O(E+V)。算法3主要计算多个网络图之间具有相似关系的原子任务的聚合。计算中使用经典的k-均值算法。</p><p>对于简单情况，𝑘 − 𝑚𝑒𝑎𝑛𝑠 算法的运行时间界限是 𝑂(𝑑𝐸4𝑀2)。 算法3的时间复杂度主要体现在多个网络图和网络图上边的遍历操作上。 若两个事件的冗余边数为𝑟，网络图数记为𝐺，则算法3的时间复杂度可表示为𝑂(𝐺𝑑𝐸4𝑀2𝑟)。 算法4主要计算多个网络图上具有相关关系的原子任务之间的聚合操作，其时间复杂度主要体现在网络图和边的遍历上。 因此，它的时间复杂度是𝑂(𝐺𝐸)。 算法6主要是在上述算法的基础上完成多图的最小时间和卫星资源分配计算，其时间复杂度为𝑂(𝐺𝐸+𝐸+𝑉+𝐺𝑑𝐸4𝑀2𝑟+𝐺𝐸)。 我们将本文提出的基于网络图聚合的多卫星多任务调度算法的时间复杂度简化为𝑂(𝐺(𝑑𝐸{4}𝑀{2}𝑟 + 𝑉 + 𝐸))。</p><h3 id="5-2-实验数据"><a href="#5-2-实验数据" class="headerlink" title="5.2 实验数据"></a>5.2 实验数据</h3><p>为研究天基信息网络的任务调度、链路优化、协同计算、网络拓扑发现等关键问题，自主研发了基于天然卫星的空间信息网络通用计算环境仿真工具包（CSTK）3和天基信息网络的共同任务数据。在本系统中，我们模拟了大量的卫星数据，包括卫星载荷数据、卫星轨道数据、星间可见时间窗、星间可见时间窗数据、卫星资源容量、卫星资源数量等。我们模拟了对地观测常见应用场景数据，包括对地观测区域数据、任务执行时间需求、任务资源类型、任务资源需求等。此外，我们开发了CSTK系统所需的多种计算库。在本文中，我们获得了基于CSTK系统的实验数据，并在该系统上实现了本文提出的模型和算法进行计算。本文提出的算法MSRA-TAG的实验数据描述如下，</p><p>如表1所示，本文共有六组实验数据。标题“Datasets”表示数据集的名称，标题“Atomic tasks”表示数据集中原子任务的数量，标题“Satellites”表示数据集中卫星的数量。</p><p><img src="http://cdn.leafii.top/img/image-20230507144250302.png" alt="image-20230507144250302" loading="lazy"></p><p>如表 2 所示，我们总共使用了四个数据集。每个数据集中包含的卫星和任务数量呈梯度增长，其中Scale表示每个数据集中的任务和卫星数量，’Minimum Strat Time’是所有任务的最短开始时间和所有卫星的最短开始时间在可见时间窗内。同样，“最大战略时间”表示所有任务或卫星的可见时间窗口的最大开始时间。 “最短结束时间”表示所有任务和卫星可见时间窗口的最短结束时间。 “最大结束时间”表示所有任务和卫星的可见时间窗口的最大结束时间。 ‘Minimum Resources Num’表示所有任务所需的最少资源数和所有卫星可用的最少资源数。‘Maximum Resources Num’表示所有任务中需要最多资源的任务和所有卫星中能提供最多资源的卫星请求的资源数量。 “资源类型”表示任务所需资源类型和卫星有效载荷的资源类型。 1表示观测资源，2表示存储资源，3表示传输资源。</p><p><img src="http://cdn.leafii.top/img/image-20230507144239318.png" alt="image-20230507144239318" loading="lazy"></p><p>为了验证 MSRA-TAG 在真实卫星观测场景中的有效性，我们添加了对真实世界数据的模拟，其中包含较少的合成数据。在真实的地球观测场景中，我们研究了两个用于观测地球区域目标的用户任务。用户任务是对用户需求的描述，是粗粒度的任务。观测场景包含两个观测需求，八颗观测卫星和两个用于发送任务指令的地面站。场景时间范围从“2022 年 3 月 5 日 04:00:00.000 UTCG”到“2022 年 3 月 6 日 04:00:00.000 UTCG”，步长为 10 秒。模拟场景如图 14 所示，子图 (a) 和 (b) 显示了两个观测任务的地球观测区域的 3D 和 2D 视图。我们可以观察到两个观测任务的目标观测区域重叠。这意味着两个用户任务被分解为原子任务后，还存在一部分相似或相关的原子任务。子图(c)和(d)显示了卫星轨道、地面站和观测区域的完整场景视图。我们可以从 3D 或 2D 场景观察卫星凌日的时间。</p><p><img src="http://cdn.leafii.top/img/image-20230507143958198.png" alt="image-20230507143958198" loading="lazy"></p><p>真实观测场景的任务数据详情如表3所示。我们可以观察到’’Real World Dataset’’表示真实世界数据集名称，’’TaskID’’指定用户任务ID，’’Areas’’表示观察区域的经纬度坐标和“离散时间范围”表示观察场景周期离散化的持续时间，以秒为单位。 “Resources Type”字段表示用户任务所需的卫星资源类型，与表1中的类型相同。</p><p>观测场景中的卫星详情如表4所示，表中卫星涉及整个观测任务，’’Common Name’’表示卫星名称，’’Launch Date’’表示发射日期卫星的“周期”表示卫星的运行周期（以分钟为单位）。 “倾角”表示卫星相对于地球的倾角，“原子序数”表示卫星上安装的天线数，双线元全称“TLE”表示卫星轨道范围。</p><h3 id="5-3-Experimental-parameter"><a href="#5-3-Experimental-parameter" class="headerlink" title="5.3 Experimental parameter"></a>5.3 Experimental parameter</h3><p>本文使用python第三方库sklearn中的Spectral Clustering(Huang et al., 2020)方法完成相似边的查找。在完成多任务聚类后，我们使用线性求解器 P uLP 4 来实现多任务资源分配的解决方案。我们在 P uLP 求解器中使用默认参数设置。 Spectral Clustering方法中的参数设置如下表5所示。</p><p>如表5所示，其中参数gamma值在0.01、0.1、1、10范围内选取，参数n_clusters在2、3、4、5、6范围内选取。我们选取最优的聚合结果从上面训练出来的集合，以及聚类完成后默认选择的三个类别的集合。所有任务的默认最短开始时间应大于 0。</p><p>我们将本文方法与用于天基信息网络电路任务调度的基线算法进行比较，5 这些算法包括粒子群优化 (PSO)（Chen 等人，2012 年；Kennedy 和 Eberhart，1995 年；Luo 等人，2020 年） ; Xia et al., 2009), Genetic Algorithm (GA) (Gerges et al., 2018; Sun et al., 2010; Xhafa et al., 2012), and Differential Evolution (DE) (Li &amp; Li, 2019; Storn &amp; Price，1997 年；Wu、Wang 等人，2015 年）算法。 在空间信息网络任务调度场景下，这些算法的参数设置如表6所示，其中参数𝑙𝑏表示各自变量的最小值，𝑢𝑏表示各自变量的最大值，参数𝑙𝑏表示各自变量的最大值， 每个变量作为卫星当前拥有的资源数量上线。 𝑝𝑟𝑜𝑏_𝑚𝑢𝑡表示方差概率，𝑝𝑟𝑒𝑐𝑖𝑠𝑖𝑜𝑛表示算法𝐺𝐴的精度，𝑤表示算法𝑃的惯性权重𝑆𝑂， 𝑐1表示算法𝑃𝑆𝑂的个体记忆，𝑐2表示算法𝑃𝑆𝑂的集体记忆，𝐹表示方差系数 算法𝐷𝐸。</p><h3 id="5-4-Experimental-results"><a href="#5-4-Experimental-results" class="headerlink" title="5.4 Experimental results"></a>5.4 Experimental results</h3><p>本节分为三个主要部分来分析和验证我们提出的方法的性能。首先，我们比较和分析了我们的聚合方法的性能。然后对多卫星多任务资源分配性能进行了精确分析。最后，将本文提出的方法 MSRA-TAG 与三个基线模型进行比较，以彻底验证方法 MSRA-TAG 的有效性和优越性。</p><h5 id="A-多任务聚合前后任务执行时间对比"><a href="#A-多任务聚合前后任务执行时间对比" class="headerlink" title="A. 多任务聚合前后任务执行时间对比"></a>A. 多任务聚合前后任务执行时间对比</h5><p>一个任务在整个调度过程中的时间成本消耗包括两个主要部分：任务执行消耗的时间和分配卫星资源时等待执行的时间。在本文中，我们提出的聚合过程发生在卫星资源分配过程之前。因此，我们比较了聚合前后计划执行任务所需的时间，以验证我们提出的相似性聚合和相关性聚合方法的有效性。</p><p>如表7所示，我们分别计算了聚合前原始任务和聚合后任务在六个数据集上的计划执行消耗时间。 我们可以观察到原始任务和聚合任务的计划耗时在数据集𝐷1 上是相同的，这表明没有执行聚合过程。 造成这种情况的原因是数据集中的任务数量太少，导致不存在相似的任务或有相关关系的任务。 因此任务无法聚合，导致聚合前后任务计划执行的成本消耗相同。 在数据集𝐷2、𝐷3、𝐷4、𝐷5、𝐷6和𝐷𝑟𝑒𝑎𝑙上，我们可以观察到聚合后任务的耗时小于原始任务的耗时，说明任务集中的某些任务具有相似或相关关系 ，它们聚合在一起并减少了任务大小。</p><p>经过上面的分析，我们可以注意到，任务的聚合操作可以减少任务执行时间的消耗，减少任务的数量。此外，如图15所示，聚合后任务总成本的降低率随着数据量的增长而增长。此外，我们可以意识到，当任务数量增加时，具有相似性和相关性的任务数量也会增加，聚合后任务执行时间消耗也会减少。因此，当空间信息网络满足许多任务请求时，我们提出的聚合方法降低的任务执行消耗成本随着任务数量的增加而增加。在真实世界数据的模拟结果中，我们可以观察到任务聚合后任务消耗的估计时间成本减少了 861。聚合后减少的时间消耗比大批量任务场景要小，因为真实数据集中只有两个用户观察任务。因此，更少的任务满足聚合条件。本文提出的任务聚合方法对真实世界数据有效。总之，我们提出的聚合方法可以适应大容量任务请求场景。</p><h5 id="B-关键路径任务优先资源分配与全图分配结果对比"><a href="#B-关键路径任务优先资源分配与全图分配结果对比" class="headerlink" title="B. 关键路径任务优先资源分配与全图分配结果对比"></a>B. 关键路径任务优先资源分配与全图分配结果对比</h5><p>任务聚合后，需要将当前时刻活跃卫星拥有的空闲资源分配给任务。本节给出了本文提出的关键路径任务优先级分配资源方法与全图分配资源结果的对比分析。如4.3节所述，关键路径任务优先分配资源法是指先将资源分配给网络图中关键路径上的原子任务，再分配给关键路径以外的剩余任务，即保证整个网络图可以在理想的时间内执行和完成。全图资源分配是指根据实际卫星资源的数量一次性为网络图中的所有任务分配资源。之后，我们分析了这两种方法的实验结果数据。</p><p>如表8所示，关键路径优先分配和整个网络图的一次性分配的成本消耗在D1数据集上是一致的。这表明卫星资源的数量足以执行网络上的所有任务，不存在资源竞争。因此，这两种方法都不会延长关键路径上任务的执行时间。然而，随着D2-Dreal数据集上的任务数量逐渐增加，卫星资源不足导致资源争用。它导致网络地图上关键原子任务的执行按时完成。结果，“一次性分配”方法导致整个网络的时间成本消耗增加。</p><p><img src="http://cdn.leafii.top/img/image-20230507145258428.png" alt="image-20230507145258428" loading="lazy"></p><p>如图16所示，随着任务的增加，对资源的竞争也越来越激烈。子图描述了与一次性分配方法一致的优先关键路径方法对数据集 D1 的成本消耗。这是因为任务数量少，不会造成资源争用。此外，网络图中关键任务的执行越来越延迟，导致整个网络图中的任务执行成本增加。在真实数据集 Dreal 上，我们可以观察到整图一次性分配方法的成本消耗大于关键路径优先方法的成本消耗。因此，关键路径任务优先执行法实现了显着的成本节约和更理想的结果。随着任务数量的增加，成本节约消耗更加出色。</p><p><img src="http://cdn.leafii.top/img/image-20230507145509413.png" alt="image-20230507145509413" loading="lazy"></p><h5 id="C-MSRA-TAG-与基线方法的调度结果对比"><a href="#C-MSRA-TAG-与基线方法的调度结果对比" class="headerlink" title="C. MSRA-TAG 与基线方法的调度结果对比"></a>C. MSRA-TAG 与基线方法的调度结果对比</h5><p>本节将本文的方法 MSRA-TAG 与基线算法 PSO、GA 和 DE 进行比较。 算法计算成本消耗越小，意味着算法对动态变化的空间信息网络的适应性越强，算法的性能就会提高。如表9所示，PSO、GA、DE算法的成本消耗在数据集D1上是一样的，都是7797。MSRA-TAG相比baseline方法是3657，消耗的时间不到所消耗时间的一半通过基线模型，显着降低了任务执行的成本消耗。但是，我们发现MSRA-TAG大于原任务的计划成本消耗时间2761，这是由于卫星可见窗口、资源数量或分配时卫星功率等任务约束的等待时间造成的任务的卫星资源。此外，我们提出的方法 MSRA-TAG 在数据集 D1 上产生的任务等待时间延迟仅为 896。基线方法GA和DE在数据集D2上的结果相同，PSO算法的结果略高于GA和DE。我们提出的方法 MSRA-TAG 计算所有方法中的次要成本消耗。</p><p><img src="http://cdn.leafii.top/img/image-20230507145904784.png" alt="image-20230507145904784" loading="lazy"></p><p>在数据集 D3 上，我们提出的方法 MSRA-TAG 计算结果为 51 604.99，远小于原始任务的计划成本消耗 62,665.09，这是由任务集中许多相似任务和具有相关性的任务引起的数据集的数量增加。因此，众多任务的聚合极大地减少了时间成本消耗。在数据集 D3 上，随着数据集数量的增加，任务集中存在许多相似的任务和具有相关性的任务。然而，尽管如此，任务的等待时间仍然存在。在数据集 D5 上，MSRA-TAG 的时间成本为 179,240.64，原始任务的时间成本为 251,749.25，其他基线方法的时间成本分别为 623,999、623 760 和 623 760。原始任务的时间成本为 72,508.61，MSRATAG 节省的其他算法的时间成本为 444,548.61。 MSRA-TAG 相对于其他算法节省了 444,758.36、444,519.36 和 444,519.36。所有数据集上的卫星资源分配过程都存在任务等待时间消耗。 baseline算法的结果大致相同，但都远大于MSRA-TAG方案消耗的时间成本。类似地，数据集 D4、D5 和 D6 上的 MSRA-TAG 显示出随着任务数量的增加任务执行时间消耗减少的增加趋势。总之，我们的方法比基线方法具有绝对优势。</p><p>在真实数据集 Dreal 上，我们可以观察到 MSRA-TAG 的成本为 370 064，大约是源任务耗时的 23 倍。种群智能算法 PSO、GA 和 DE 消耗相同的成本 518 400，大约是源任务消耗时间的 33 倍。因此，与所有基线方法相比，MSRA-TAG 的成本消耗较小，可以提高任务调度的时效性。总之，我们的方法 MSRA-TAG 与基线方法相比具有绝对优势。</p><p>如图 17 所示，“原始任务成本”表示原始任务的时间消耗。随着任务数量的增加，所提出的方法 MSRA-TAG 的上升幅度远小于基线方法，并且其时间成本在数据集 D3、D4、D5、D6 和 Dreal 上低于原始任务。</p><p><img src="http://cdn.leafii.top/img/image-20230507150103220.png" alt="image-20230507150103220" loading="lazy"></p><p>为了更清楚地比较多种方法的时间消耗趋势，我们计算了每个算法在不同数据集上固定基数的增长率，计算如下，</p><p><img src="http://cdn.leafii.top/img/image-20230507150146637.png" alt="image-20230507150146637" loading="lazy"></p><p>如方程式所示。 (19)，我们将算法集 A &#x3D; {Original Tasks Cost, MSRA-TAG, PSO, GA, DE} 定义为 y &#x3D; {a1, a2, a3, a4, a5}。定义数据集 D &#x3D; {D1, D2, D3, D4, D5, D6, Dreal} 为 x &#x3D; {d1, d2, d3, d4, d5, d6, d7}。 φx(y)表示方法ai计算的任务执行耗时，1≤i≤5在数据集dj上，1≤j≤5。γ(x)表示原始任务在数据集x中的耗时。 f (x, y) 表示算法 x 在数据集 y 上的固定基数的增长率。</p><p>如表 10 所示，我们分别使用表 9 中“原始任务成本”列的值作为数据集 D1 −Dreal 的基线。其中，MSRA-TAG方法在数据集D1和D2上的增长率为正，小于baseline方法。这意味着 MSRA-TAG 方法的计算结果对于原始任务的成本消耗具有最低的增长率，即我们提出的任务调度方法需要最少的时间成本消耗。 MSRA-TAG 在数据集 D3、D4、D5 和 D6 上的增长率均为负值，其绝对值小于其他基线算法。这意味着该方法消耗的时间成本低于原任务的计划成本，增长率均低于其他算法。在真实数据集Dreal上，随着任务和卫星数量的增加，MSRATAG成本消耗以2298.65%的速度增长，而基线模型PSO、GA和DE的成本消耗增长率为3260.12%。</p><p><img src="http://cdn.leafii.top/img/image-20230507150218903.png" alt="image-20230507150218903" loading="lazy"></p><p>通过比较，我们可以观察到 MSRA-TAG 方法具有最慢的成本增长率和较高的任务执行时间。 虽然在真实数据集中只考虑了八颗卫星，但两个用户任务分解后产生的原子任务比数据集𝐷1中包含的原子任务数量要多。 原子任务的数量越多，可聚合的任务就越多，耗时也就越少。 因此，方法 MSRA-TAG 在𝐷𝑟𝑒𝑎𝑙 上的成本增长率小于 D1。</p><p>我们提出的方法 MSRA-TAG 随着任务数量的增加使更多的任务聚合在一起执行，从而减少重复执行的大量时间成本。如图 18 所示，算法 PSO、GA 和 DE 的增长率具有相同的值，导致三种算法的增长率倍数重叠。 MSRA-TAG、PSO、GA 和 DE 的增长率在数据集 D1 和 D2 上是有利的。然而，随着任务数量的增加，MSRA-TAG 在数据集 D3、D4、D5 和 D6 上出现了负增长，增长率曲线停滞在-30.37%。 PSO、GA 和 DE 的增长率仍然为正，增长率稳定在 147.87%。 PSO、GA 和 DE 的增长率保持正增长并稳定在 147.87%。我们的方法 MSRA-TAG 显示出正增长率，低于数据集 Dreal 上 PSO、GA 和 DE 的增长率。我们可以观察到MSRA-TAG在所有数据集上相比基线算法的时间成本消耗最少，并且随着数据量的增长增长率逐渐降低，具有优异的性能。</p><p><img src="http://cdn.leafii.top/img/image-20230507150344294.png" alt="image-20230507150344294" loading="lazy"></p><p>为了验证所有算法在任务数量变化时的性能，我们根据所有算法在数据集 D1 上的基准测试结果，计算了每个算法在数据集 D2、D3、D4、D5、D6 和 Dreal 上的增长率。随着任务和卫星数量的增加，时间成本的增加是不可避免的。因此，我们提出的方法 MSRA-TAG 旨在尽我们所能减少任务的时间成本消耗。如表11所示，原任务的时间成本增长率为1102%。本文提出的算法MSRA-TAG虽然在数据集𝐷2上997%的增长率比基准算法高出900%，但并没有显着差异。 这种情况是因为数据集𝐷2中的任务和卫星数虽然相对于数据集𝐷1增长了1102%，但具有相似关系或相关关系的任务并不多，聚合效果不明显。 但随着数据量的增长，MSRA-TAG的增长率明显低于其他基准算法，这是由于任务和卫星数量的增长，出现了更多具有相似和相关关系的任务，使得MSRA- TAG充分发挥其性能。 如图19所示，随着数据量的增长，MSRA-TAG的增长率明显低于其他基线方法，其增长率曲线的斜率也远小于 其他基线算法。 然而，与其他方法相比，MSRA-TAG 在真实数据集 Dreal 上相对于 𝐷1 的增长率最高。 这是因为𝐷1数据集中的卫星比数据𝐷𝑟𝑒𝑎𝑙中的卫星多。 然而，𝐷1 中的原子任务数量少于𝐷𝑟𝑒𝑎𝑙。 因此，与 𝐷𝑟𝑒𝑎𝑙 相比，它导致 𝐷1 的成本最低，后者更广泛并导致更显着的增长率。</p><p><img src="http://cdn.leafii.top/img/image-20230507150417069.png" alt="image-20230507150417069" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230507150524224.png" alt="image-20230507150524224" loading="lazy"></p><p>综上所述，我们的方法在处理大批量任务请求时具有出色的性能，并且与其他方法相比，任务越多，我们的时间消耗就会少得多。然而，对于任务数量较少的场景，我们的方法的优异性能并不能得到充分体现。</p><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6. Conclusion"></a>6. Conclusion</h2><p>针对空间信息网络中多卫星多任务场景下任务关系复杂、任务调度时效性差的问题，研究多任务聚合方法和多卫星资源分配方法，提出了一种<strong>独创的复杂多任务聚合方法</strong>，基于合成数据集和真实世界数据，仿真验证了该方法在多卫星、多任务调度场景下的有效性和优越性。我们提出了<strong>多任务的网络图表示</strong>，建立了<strong>相似性和相关关系任务聚合模型</strong>，设计了<strong>解决多层任务网络图聚合的算法</strong>，解决了重复执行多个任务需要大量时间的问题.为了解决多卫星资源分配问题，我们提出了一种基于聚合任务网络图来优先分配关键任务资源请求的方法。我们还建立了<strong>多卫星多任务资源分配模型</strong>，并设计了算法对关键任务进行优先分配，解决了空间信息网络资源大量被占用和资源利用率低的问题。资源配置不合理。该论文突破了多任务聚合的关键技术难题，实现了空间信息网络中多卫星、多任务的高时效调度。本文通过从多个角度验证本文提出的MSRA-TAG方法的有效性，并将实验的性能与各种基线算法进行比较，验证了我们的想法的有效性和效率。 MSRA-TAG 在最大数据集 D6 上将 95 745.82 个亲属保存到原始任务中。此外，MSRA-TAG相对于其他算法分别节省了560 436.08、560 137.08和560 137.08。 MSRA-TAG方法在所有数据集上其任务和卫星数量较多的时间成本消耗负增长率最高为-30.37%，其他基线算法时间成本消耗数量增长率最高为147.38% . MSRA-TAG 对数据集 D1 的最高增长率为 10 019%，其他基线模型对 D1 的最高增长率为 9904%。因此，本文提出的方法MSRA-TAG具有更强的适应性，在空间信息网络中的多星、多任务场景下具有优异的性能。</p><p>未来，卫星信息网络必然向天地一体化网络发展。脱离地基基站的卫星自主任务规划或聚类方法研究必将成为普遍的研究趋势。纵观相关文献，目前的任务规划或聚类方法大多基于图论、强化学习或种群智能方法。然而，在未来几十年，任务规划方法将倾向于基于卫星之间自主协商的星上自主在线规划。因此，下一步将研究卫星间自主协作机制和星上任务在线规划策略，以实现卫星信息网络的智能化和自主化。同时，我们将更倾向于根据卫星网络的时变特性，研究具有高时间效率的多任务在线聚类方法。</p><p>论文关键：<strong>拥有相似属性</strong>的任务可以进行聚合，<strong>拥有数据依赖</strong>的任务可以进行聚合，原子任务来自于大任务的分解</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-Abstract&quot;&gt;&lt;a href=&quot;#0-Abstract&quot; class=&quot;headerlink&quot; title=&quot;0. Abstract&quot;&gt;&lt;/a&gt;0. Abstract&lt;/h2&gt;&lt;p&gt;卫星网络任务调度时效性问题是实现空地一体化网络（STIN）的关键。传统方法将卫星任务调度问题解释为线性或非线性规划问题，忽略了任务之间的复杂关系。为了提高多卫星和多任务场景中任务调度的及时性，我们&lt;strong&gt;研究了解释任务相关性的网络图结构&lt;/strong&gt;。然后，我们&lt;strong&gt;针对具有相似性和相关性特征的任务&lt;/strong&gt;提出了多层网络图聚合模型。进一步，我们&lt;strong&gt;将任务调度问题转化为零一规划问题&lt;/strong&gt;，设计任务调度算法来解决任务调度时效性问题。最后，我们模拟和模拟真实世界的数据作为实验数据集，用于与三种基线算法进行比较。实验结果表明本文方法具有明显的优势和进步。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
    <category term="任务网络图" scheme="tags/任务网络图/"/>
    
  </entry>
  
  <entry>
    <title>leetcode123.买卖股票的最佳时机III</title>
    <link href="2023/04/27/leetcode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/"/>
    <id>2023/04/27/leetcode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/</id>
    <published>2023-04-27T06:13:04.000Z</published>
    <updated>2023-04-27T06:16:29.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>这道题是需要我们计算在最多进行两次买卖的情况下，所能获得的最大利润。我们可以定义四个状态分别为：</p><ul><li><code>buy1</code>表示第一次买入时的最大收益；</li></ul><ul><li><code>sell1</code>表示第一次卖出时的最大收益；</li><li><code>buy2</code>表示第二次买入时的最大收益；</li><li><code>sell2</code>表示第二次卖出时的最大收益。</li></ul><p>对于这四个状态，我们可以使用动态规划算法进行求解。具体地，对于第i天的情况，我们有以下状态转移方程：</p><pre class="language-C++" data-language="C++"><code class="language-C++">buy1 &#x3D; max(buy1, -prices[i]);    &#x2F;&#x2F;第一次买入的最大收益，可以选择不进行或进行sell1 &#x3D; max(sell1, buy1 + prices[i]);  &#x2F;&#x2F;第一次卖出的最大收益，可以选择不进行或进行buy2 &#x3D; max(buy2, sell1 - prices[i]);  &#x2F;&#x2F;第二次买入的最大收益，可以选择不进行或进行sell2 &#x3D; max(sell2, buy2 + prices[i]); &#x2F;&#x2F;第二次卖出的最大收益，可以选择不进行或进行</code></pre><p>其中，<code>buy1</code>和<code>buy2</code>的更新都使用上一次买入的最大收益减去当前股票价格来更新，因为如果当前的股票价格越低，那么买入的收益也就越大。而对于<code>sell1</code>和<code>sell2</code>的更新则使用上一次的买入收益加上当前股票价格来更新，因为如果当前的股票价格越高，那么卖出的收益也就越大。</p><p>最后，我们的最大收益就是第二次卖出时的最大收益<code>sell2</code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int buy1 &#x3D; -prices[0], sell1 &#x3D; 0, buy2 &#x3D; -prices[0], sell2 &#x3D; 0;        for(int i &#x3D; 1; i &lt; prices.size(); i++)&#123;            &#x2F;&#x2F; 第一次买入的最大收益，可以选择不进行或进行            buy1 &#x3D; max(buy1, -prices[i]);            &#x2F;&#x2F; 第一次卖出的最大收益，可以选择不进行或进行            sell1 &#x3D; max(sell1, buy1 + prices[i]);            &#x2F;&#x2F; 第二次买入的最大收益，可以选择不进行或进行            buy2 &#x3D; max(buy2, sell1 - prices[i]);            &#x2F;&#x2F; 第二次卖出的最大收益，可以选择不进行或进行            sell2 &#x3D; max(sell2, buy2 + prices[i]);        &#125;        &#x2F;&#x2F; 返回第二次卖出时的最大收益        return sell2;    &#125;&#125;;</code></pre><p>时间复杂度：O(n)，其中n是股票的天数，只需要遍历一遍数组即可求解。</p><p>空间复杂度：O(1)，使用了常数个变量来存储状态。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个数组，它的第 &lt;code&gt;i&lt;/code&gt; 个元素是一支给定的股票在第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 &lt;strong&gt;两笔&lt;/strong&gt; 交易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1049.最后一块石头的重量II</title>
    <link href="2023/04/26/leetcode1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/"/>
    <id>2023/04/26/leetcode1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/</id>
    <published>2023-04-26T06:50:18.000Z</published>
    <updated>2023-04-26T06:53:13.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：stones &#x3D; [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：stones &#x3D; [31,26,33,21,40]输出：5</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道动态规划问题。我们可以定义一个 dp 数组，其中 dp[i] 表示背包容量为 i 时能够得到的最大价值。这里价值就是石头的重量。</p><p>具体来说，对于每一块石头，我们可以选择将其放入背包中，也可以不放入背包中。如果我们选择将其放入背包中，则可以得到的最大价值为 dp[j-stones[i]]+stones[i]，其中 j-stones[i] 表示剩余背包容量，dp[j-stones[i]] 表示剩余背包容量为 j-stones[i] 时能够得到的最大价值，stones[i] 表示当前石头的重量。</p><p>遍历完所有的石头后，dp[target] 就是能够得到的最大价值，其中 target 是所有石头重量之和的一半（因为我们要得到最终得到的石头的最小可能重量，因此需要将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值）。</p><p>最终得到的石头的重量就是 sum - 2*dp[target]，其中 sum 是所有石头的重量之和。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;        int sum &#x3D; accumulate(stones.begin(), stones.end(), 0); &#x2F;&#x2F; 计算所有石头重量之和        int target &#x3D; sum &#x2F; 2; &#x2F;&#x2F; 将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值        vector&lt;int&gt; dp(target+1, 0); &#x2F;&#x2F; 定义动态规划数组        for(int i&#x3D;0; i&lt;stones.size(); i++) &#123; &#x2F;&#x2F; 遍历每一块石头            for(int j&#x3D;target; j&gt;&#x3D;stones[i]; j--) &#123; &#x2F;&#x2F; 从后往前更新 dp 数组                dp[j] &#x3D; max(dp[j], dp[j-stones[i]]+stones[i]); &#x2F;&#x2F; 更新 dp 数组            &#125;        &#125;        return sum - 2*dp[target]; &#x2F;&#x2F; 返回最终得到的石头的重量    &#125;&#125;;</code></pre><p>在上面的代码中，我们首先使用<code>std::accumulate</code>库函数对石头的重量进行求和，得到所有石头的总重量<code>sum</code>。接着，我们将原问题转化为求解容量为<code>sum/2</code>的背包能够得到的最大价值，因此定义了一个<code>target</code>变量来保存这个值。</p><p>然后，我们定义了一个长度为<code>target+1</code>的<code>dp</code>数组，其中<code>dp[i]</code>表示背包容量为<code>i</code>时能够得到的最大价值。这个数组的初始化值都是0。</p><p>接下来，我们遍历每一块石头，并对每一块石头进行背包问题的动态规划更新。具体来说，对于第<code>i</code>块石头，我们从<code>target</code>向<code>stones[i]</code>遍历，更新所有<code>dp[j]</code>（<code>j&gt;=stones[i]</code>）。更新公式为<code>dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</code></p><p>这里<code>dp[j-stones[i]]</code>表示在放入第<code>i</code>块石头前剩余的背包容量，因此需要从<code>dp[j-stones[i]]</code>中加上当前石头的重量<code>stones[i]</code>才能得到在放入第<code>i</code>块石头后的最大价值。最后，我们返回最终得到的石头的重量，即<code>sum-2*dp[target]</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;有一堆石头，用整数数组 &lt;code&gt;stones&lt;/code&gt; 表示。其中 &lt;code&gt;stones[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 块石头的重量。&lt;/p&gt;
&lt;p&gt;每一回合，从中选出&lt;strong&gt;任意两块石头&lt;/strong&gt;，然后将它们一起粉碎。假设石头的重量分别为 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，且 &lt;code&gt;x &amp;lt;= y&lt;/code&gt;。那么粉碎的可能结果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;x == y&lt;/code&gt;，那么两块石头都会被完全粉碎；&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;x != y&lt;/code&gt;，那么重量为 &lt;code&gt;x&lt;/code&gt; 的石头将会完全粉碎，而重量为 &lt;code&gt;y&lt;/code&gt; 的石头新重量为 &lt;code&gt;y-x&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，&lt;strong&gt;最多只会剩下一块&lt;/strong&gt; 石头。返回此石头 &lt;strong&gt;最小的可能重量&lt;/strong&gt; 。如果没有石头剩下，就返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode416.分割等和子集</title>
    <link href="2023/04/25/leetcode416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <id>2023/04/25/leetcode416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</id>
    <published>2023-04-25T02:19:47.000Z</published>
    <updated>2023-04-25T02:27:22.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p> <span id="more"></span><p>示例 1：</p><p>输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这个解法使用了动态规划。具体来说，我们首先计算数组中所有数字的总和。如果总和是奇数，那么无法分成等和子集，直接返回 false。否则，我们就要找到一个子集，使得它的和等于总和的一半，也就是说，我们要在数组中选择一些数字，使得它们的和等于 target。</p><p>我们使用 dp 数组来记录 target 是否可以被分成等和子集。dp[i] 表示 target 为 i 时的情况，dp[i] &#x3D; true 表示 target 可以被分成等和子集，否则为 false。</p><p>对于每一个数字 num，我们遍历 dp 数组的范围是 [target, num]，并且更新状态。具体来说，如果 dp[i - num] 为 true，那么 dp[i] 也为 true，因为我们可以在 dp[i - num] 的基础上加上 num 得到 dp[i]。最后，我们返回 dp[target]，判断是否可以分成等和子集。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int sum &#x3D; 0;        for (int num : nums) &#123;            sum +&#x3D; num;        &#125;        if (sum % 2 !&#x3D; 0) &#123;  &#x2F;&#x2F; 如果总和是奇数，无法分成等和子集            return false;        &#125;        int target &#x3D; sum &#x2F; 2;        vector&lt;bool&gt; dp(target + 1, false);  &#x2F;&#x2F; 创建一个长度为target+1的vector        dp[0] &#x3D; true;  &#x2F;&#x2F; target为0的情况是可以满足的        for (int num : nums) &#123;            for (int i &#x3D; target; i &gt;&#x3D; num; i--) &#123;  &#x2F;&#x2F; 遍历可选数字的范围是[target, num]                dp[i] &#x3D; dp[i] || dp[i - num];  &#x2F;&#x2F; 状态转移方程            &#125;        &#125;        return dp[target];  &#x2F;&#x2F; 返回target是否可以被分成等和子集    &#125;&#125;;</code></pre><blockquote><p><code> dp[i] = dp[i] || dp[i - num];</code>是一个状态转移方程，表示当前状态 dp[i] 是否可以被满足。dp[i] 初始值为 false，如果 dp[i - num] 为 true，也就是说前面已经找到了一组数字使得它们的和等于 i - num，那么我们只需要在这个基础上再加上 num，就可以得到一组数字使得它们的和等于 i，于是我们可以将 dp[i] 设置为 true。</p><p>这里使用了逻辑或运算符（<code>||</code>），如果 dp[i] 本来就是 true，那么 dp[i] 的值不会改变，因为或运算符的两个操作数有一个为 true，结果就是 true。如果 dp[i - num] 为 false，那么 dp[i] 仍然是 false。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>WorkflowSim：用于在分布式环境中模拟科学工作流程的工具包</title>
    <link href="2023/04/24/WorkflowSim%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%A8%A1%E6%8B%9F%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    <id>2023/04/24/WorkflowSim%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%A8%A1%E6%8B%9F%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85/</id>
    <published>2023-04-24T10:33:26.000Z</published>
    <updated>2023-04-25T02:38:45.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments"><a href="#WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments" class="headerlink" title="WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments"></a>WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>现有的工作流模拟器无法提供一个考虑异构系统开销和失败的框架，也缺少对广泛使用的工作流优化技术（如任务聚合）的支持。因此我们引入了WorkflowSim。在扩展CloudSim的基础上提供了更高层的工作流管理。我们还通过实验证明了忽视系统开销和故障会导致预测工作流时间的极大不准确。在两个研究领域中我们进一步验证了WorkflowSim在促进科学研究方面的价值。</p><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>首先介绍了科学工作流，然后说对于科学工作流工作的验证如果放在真实环境中验证有很多缺点，而基于模拟的验证有很多好处，比如降低实验步骤的复杂度并且通过在可重复和受控的环境中测试他们的应用程序，在工作流执行中节省了大量精力。</p><p>因此一个能够准确模拟的工作流调度模拟框架是非常需要的。易购分布式系统使开销也五花八门，考虑到全面的系统开销在工作流的运行时间中起到的重要作用，需要对这些工作流开销进行分类，这有助于提高模拟器的精确度（相较于不考虑开小的模拟器）。</p><p>此外，很多研究者已经强调了容错设计的重要性并认为现代分布式系统中的错误率不应该被忽视，我们需要一个支持随机以及分层故障的模拟器来促进相关方面的研究。</p><p>最后，工作流研究的进展还需要一个能够支持广泛接受的工作流特征和优化技术的通用框架。现有的模拟器，如 CloudSim&#x2F;GridSim[12] 无法提供细粒度的工作流模拟。</p><p>据我们所知，当前的分布式系统模拟器都不支持这些丰富的特性和技术。在本文中，我们介绍了我们在模拟满足这些要求的科学工作流程方面的早期工作。我们以任务聚类为例评估 WorkflowSim 的性能。我们进一步表明，WorkflowSim 有望为容错集群和开销鲁棒性研究等研究领域提供评估平台。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>在我们的设计中，我们在 CloudSim 现有的工作流调度层之上添加了多个层，包括 Workflow Mapper、Workflow Engine、Clustering Engine、Failure Generator、Failure Monitor 等。我们将解释这些层的细节在第三节。</p><p>CloudSim只支持单工作流，并没有考虑工作流的任务依赖关系，也没有对故障和开销进行分析。WorkflowSim 扩展了 CloudSim 以满足这些新要求。</p><p>其他模拟器是专门为工作流管理的一些理想方面（例如工作流调度）而设计的，但这种简化与不断变化的分布式计算世界和新工作流管理技术的发展不匹配。</p><p>因此，与其针对特定领域的工作流进行模拟，WorkflowSim 试图提取各种工作流系统公开的共同特征，并支持广泛使用的工作流管理技术。WorkflowSim 不仅支持调度技术的评估，还考虑了各种任务调度&#x2F;执行开销和故障。</p><p>在任务聚合方面，论文的聚合策略是静态的并且没有考虑动态的资源特征，他也没考虑到一些开销，这些开销包含在我们的模型中，其值是根据实际执行轨迹估算的。</p><p>故障分析和建模呈现系统特征，例如错误和故障分布以及危险率。在所有故障中，我们重点关注暂时性故障，因为预计它们比永久性故障更普遍。基于这些工作，我们模拟了两层（任务&#x2F;工作）的故障，并为用户提供了一个接口开发容错算法</p><h3 id="Models-and-Features"><a href="#Models-and-Features" class="headerlink" title="Models and Features"></a>Models and Features</h3><p>如图 1 所示，准备和执行工作流涉及多个组件层。工作流管理系统 (WMS) 的模型类似于 Pegasus WMS [17]，它包含： 一个工作流映射器，用于将抽象工作流映射到依赖于执行站点的具体工作流；一个工作流引擎来处理数据依赖；和一个工作流调度程序，用于将作业与资源相匹配。其他组件包括将小任务合并到大作业中的集群引擎、跟踪任务&#x2F;作业执行历史的 Provenance 收集器以及将用户工作流划分为多个子工作流的工作流分区器。</p><p><img src="http://cdn.leafii.top/img/image-20230424175929354.png" alt="image-20230424175929354" loading="lazy"></p><h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><h5 id="Workflow-Mapper"><a href="#Workflow-Mapper" class="headerlink" title="Workflow Mapper"></a>Workflow Mapper</h5><p>我们将工作流建模为有向无环图 (DAG)，其中作业代表用户要执行的计算，有向边代表作业之间的数据或控制流依赖关系.Workflow Mapper 用于导入 XML 格式的 DAG 文件和文件大小等其他元数据信息。Workflow Mapper 创建任务列表并将这些任务分配给执行站点。任务是用户想要执行的程序&#x2F;活动。</p><h5 id="Clustering-Engine"><a href="#Clustering-Engine" class="headerlink" title="Clustering Engine"></a>Clustering Engine</h5><p>我们将任务定义为用户想要执行的程序。 作业是执行系统看到的一个原子单元，它包含多个顺序或并行执行的任务。Clustering Engine将任务合并到作业中，以减少调度开销。</p><p><img src="http://cdn.leafii.top/img/image-20230424180131785.png" alt="image-20230424180131785" loading="lazy"></p><h5 id="Workflow-Engine"><a href="#Workflow-Engine" class="headerlink" title="Workflow Engine"></a>Workflow Engine</h5><p>Workflow Engine根据作业的依赖关系管理作业，以确保只有在其所有父作业都成功完成后才能发布作业。Workflow Engine 只会向 Scheduler 释放空闲作业。我们使用 DAGMan作为工作流引擎。</p><h5 id="Workflow-Scheduler-and-Job-Execution"><a href="#Workflow-Scheduler-and-Job-Execution" class="headerlink" title="Workflow Scheduler and Job Execution"></a>Workflow Scheduler and Job Execution</h5><p>Workflow Scheduler 用于根据用户选择的标准（MaxMin [2]、MinMin [1] 和许多其他试探法）将作业与工作节点匹配。 CloudSim 已经支持静态调度算法，我们添加了对动态工作流算法的支持。WorkflowSim 依靠 CloudSim 提供准确可靠的作业级执行模型，例如分时模型和空间共享模型。但是WorkflowSim引入了不同层次的开销和故障，提高了仿真的准确性.</p><p>为了关联和协调这些层，我们采用了基于事件的方法，其中每个组件维护一个消息队列。图 3 显示了具有两个执行站点的简单配置，每个执行站点都有两个节点。</p><p><img src="http://cdn.leafii.top/img/image-20230424180421142.png" alt="image-20230424180421142" loading="lazy"></p><h4 id="Layered-Overhead"><a href="#Layered-Overhead" class="headerlink" title="Layered Overhead"></a>Layered Overhead</h4><p>基于我们之前对工作流开销的研究，我们将分层开销添加到工作流模拟中。我们将工作流开销分为以下五类。</p><ul><li>Workflow Engine Delay测量作业的最后一个父作业完成与作业提交到本地队列的时间之间的时间。Workflow Engine Delay反映了工作流引擎（在我们的例子中是 DAGMan）的效率。</li><li>Queue Delay定义为工作流引擎向本地队列提交作业与本地调度程序看到作业运行（可能在远程资源上）之间的时间。它反映了工作流调度程序（例如，Condor [19]）执行作业的效率以及执行作业的资源可用性。</li><li>Postscript Delay and Prescript Delay是在某些执行系统下执行作业前后执行轻量级脚本所花费的时间。Prescripts 通常用于创建作业执行目录。Postscript在作业的计算部分完成后检查作业的退出代码。</li><li>Data Transfer Delay当数据在节点之间传输时发生。它包括三种不同类型的过程：staging data in, cleaning up, and staging data out.</li><li>Clustering Delay衡量的是实际任务运行时间的总和与工作流调度程序看到的作业运行时间之间的差异</li></ul><p>我们指出有必要考虑开销的分配，而不是简单地在作业执行后添加一个恒定的延迟。我们以工作流引擎延迟为例来说明对开销进行适当建模的必要性。</p><p><img src="http://cdn.leafii.top/img/image-20230424180933926.png" alt="image-20230424180933926" loading="lazy"></p><p>图 4 显示了 Montage 8 度工作流中开销和运行时间的真实轨迹（对于缩放问题，我们仅显示 mProjectPP 级别中的前 15 个作业）。我们可以看到，工作流引擎延迟在每五个作业后稳定增加。我们将这种工作流开销的特殊性称为循环递增。因此，在每次作业执行后简单地添加一个恒定的延迟忽略了它对性能的潜在影响。出于这个原因，我们采用基于消息队列的方法并迭代检查 WorkflowSim 中的消息队列。</p><p>图 6 显示了 mProjectPP、mDiffFit 和 mBackground 的 Clustering Delay 的平均值。很明显，随着k（每个水平级别的最大作业数）的增加，集群中的任务越来越少，因此每个作业的集群延迟减少。</p><p><img src="http://cdn.leafii.top/img/image-20230424201616337.png" alt="image-20230424201616337" loading="lazy"></p><p>根据等式1，<img src="http://cdn.leafii.top/img/image-20230424181348922.png" alt="image-20230424181348922" loading="lazy"></p><p>如果已知k&#x3D;j时的延迟，反比例模型可以直接估计k&#x3D;i时的延迟。因此，只要我们收集到一个聚类案例，我们就可以预测所有的聚类案例。</p><h4 id="Layered-Failures-and-Job-Retry"><a href="#Layered-Failures-and-Job-Retry" class="headerlink" title="Layered Failures and Job Retry"></a>Layered Failures and Job Retry</h4><p>在工作流执行期间的不同时间可能会发生故障。与任务和作业的定义一致，我们将瞬态故障分为两类：任务故障和作业故障。如果暂时性故障影响任务的计算（任务失败），作业中的其他任务不一定失败。如果暂时性故障影响集群作业（作业失败），则其所有任务都会失败。我们添加了两个组件来响应故障模拟：</p><ul><li>Failure Generator被引入以在每个执行站点注入任务&#x2F;作业失败。每个作业执行后，Failure Generator 根据用户指定的分布和平均失败率随机生成任务&#x2F;作业失败。</li><li>Failure Monitor收集故障记录并将它们返回给工作流管理系统，以便它可以动态调整调度策略。</li></ul><p>我们还修改了其他组件以支持容错优化。在容易出现故障的环境中，有多种方法可以提高工作流性能。</p><ol><li>当计算不成功时，可以简单地重试整个作业或仅重试该作业的失败部分。此功能被添加到 Workflow Scheduler，它检查作业的状态并根据用户选择的策略采取行动。</li><li>Reclustering是我们提出的一种技术，它试图根据检测到的故障率来调整任务聚类策略。</li></ol><h3 id="VALIDATION"><a href="#VALIDATION" class="headerlink" title="VALIDATION"></a>VALIDATION</h3><p>我们以任务聚类为例说明在工作流模拟中引入开销overheads的必要性。目标是比较工作流的模拟整体运行时间，以防作业运行时间和系统开销的信息已知并从先前的跟踪中提取。</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>在Application部分，作者介绍了如何使用WorkflowSim进行科学工作流研究。他们提到，WorkflowSim提供了一种灵活的框架，可以轻松地模拟各种科学工作流应用程序，并支持各种优化技术，例如任务聚类和容错性。 作者还列举了一些使用WorkflowSim进行研究的实际应用案例，包括生物信息学、气象预测、天文学和地震模拟等领域。他们指出，WorkflowSim可以帮助研究人员更好地理解和优化这些复杂的科学工作流应用程序，并提高其性能和效率。 </p><h3 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h3><p>在Conclusion and Future Work部分，作者总结了他们的研究成果，并提出了未来的研究方向。作者指出，WorkflowSim是一个可靠且有效的工作流仿真器，可以用于各种科学工作流应用程序中，并支持各种优化技术。 作者还提到，未来的研究方向包括进一步改进WorkflowSim的性能和功能，例如增加对容错性和动态资源管理的支持。此外，作者还计划将WorkflowSim扩展到更广泛的应用领域，并与其他工作流引擎进行比较。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments&quot;&gt;&lt;a href=&quot;#WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments&quot; class=&quot;headerlink&quot; title=&quot;WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments&quot;&gt;&lt;/a&gt;WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;现有的工作流模拟器无法提供一个考虑异构系统开销和失败的框架，也缺少对广泛使用的工作流优化技术（如任务聚合）的支持。因此我们引入了WorkflowSim。在扩展CloudSim的基础上提供了更高层的工作流管理。我们还通过实验证明了忽视系统开销和故障会导致预测工作流时间的极大不准确。在两个研究领域中我们进一步验证了WorkflowSim在促进科学研究方面的价值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode119.杨辉三角II</title>
    <link href="2023/04/24/leetcode119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/"/>
    <id>2023/04/24/leetcode119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</id>
    <published>2023-04-24T05:27:41.000Z</published>
    <updated>2023-04-24T05:38:24.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><span id="more"></span><p><img src="http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2-20230424132835008.gif" alt="img" loading="lazy"></p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: rowIndex &#x3D; 3输出: [1,3,3,1]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: rowIndex &#x3D; 0输出: [1]</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: rowIndex &#x3D; 1输出: [1,1]</code></pre><p><strong>提示:</strong></p><ul><li><code>0 &lt;= rowIndex &lt;= 33</code></li></ul><p><strong>进阶：</strong></p><p>你可以优化你的算法到 <code>*O*(*rowIndex*)</code> 空间复杂度吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>得到33行的所有结果，再按照要求返回对应的行的数组</li></ul><p>得到33行的结果的代码可以直接从leetcode118里复制粘贴，最后只需要修改一下return的值就行，需要返回的是result数组里需要的那一行的结果数组。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; getRow(int rowIndex) &#123;        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组        for (int i &#x3D; 0; i &lt; 34; i++) &#123; &#x2F;&#x2F; 按行进行遍历            &#x2F;&#x2F; i是当前行号            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行                     continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值                &#125;                else &#123;                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和                &#125;            &#125;            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组        &#125;        return results[rowIndex];&#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre><ul><li>空间复杂度优化</li></ul><p>本题要求生成杨辉三角的第 <code>rowIndex</code> 行，其中第 <code>i</code> 行有 <code>i+1</code> 个数，即第一行有 1 个数，第二行有 2 个数，第三行有 3 个数，以此类推。</p><p>因为杨辉三角的每一行只依赖于上一行的值，所以我们可以只存储上一行的值，不断地更新，直到得到第 <code>rowIndex</code> 行为止。</p><p>我们可以用一个一维数组来存储上一行的值，并不断地更新数组中的值，最终得到第 <code>rowIndex</code> 行的值。在更新的过程中，我们需要注意到数组的下标从 0 开始，而杨辉三角每一行的第一个数和最后一个数都是 1，所以我们需要在数组的第一个位置和最后一个位置都赋值为 1。</p><p>由于本题要求空间复杂度为 <code>O(rowIndex)</code>，因此我们不能开辟二维数组。在更新数组中的值时，我们需要用到上一行中前面的数和当前行中前面的数，因此我们需要用一个变量 <code>pre</code> 来存储上一行中前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。</p><p>时间复杂度为 <code>O(rowIndex^2)</code>，空间复杂度为 <code>O(rowIndex)</code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; getRow(int rowIndex) &#123;        vector&lt;int&gt; res(rowIndex + 1, 1);  &#x2F;&#x2F; 初始化结果数组为全 1        for (int i &#x3D; 2; i &lt;&#x3D; rowIndex; ++i) &#123;  &#x2F;&#x2F; 从第 2 行开始更新            int pre &#x3D; res[0];  &#x2F;&#x2F; 存储上一行前面的数            for (int j &#x3D; 1; j &lt; i; ++j) &#123;                int temp &#x3D; res[j];  &#x2F;&#x2F; 保存当前位置的值                res[j] +&#x3D; pre;  &#x2F;&#x2F; 更新当前位置的值                pre &#x3D; temp;  &#x2F;&#x2F; 更新 pre            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><p>在上述代码中，我们用 <code>res</code> 数组存储上一行的值，并初始化为全 1。然后从第 2 行开始更新，用变量 <code>pre</code> 存储上一行前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。最终返回更新后的结果数组即可。</p><p>由于题目要求返回的是第 <code>rowIndex</code> 行，因此数组的大小应该为 <code>rowIndex + 1</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负索引 &lt;code&gt;rowIndex&lt;/code&gt;，返回「杨辉三角」的第 &lt;code&gt;rowIndex&lt;/code&gt; 行。&lt;/p&gt;
&lt;p&gt;在「杨辉三角」中，每个数是它左上方和右上方的数的和。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode118.杨辉三角</title>
    <link href="2023/04/23/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>2023/04/23/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</id>
    <published>2023-04-23T02:34:59.000Z</published>
    <updated>2023-04-23T02:46:21.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><span id="more"></span><p><img src="http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img" loading="lazy"></p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: numRows &#x3D; 5输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: numRows &#x3D; 1输出: [[1]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接模拟</li></ul><p>直接看代码吧 就是直接模拟：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组        for (int i &#x3D; 0; i &lt; numRows; i++) &#123; &#x2F;&#x2F; 按行进行遍历            &#x2F;&#x2F; i是当前行号            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行                     continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值                &#125;                else &#123;                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和                &#125;            &#125;            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组        &#125;        return results;&#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负整数 &lt;em&gt;&lt;code&gt;numRows&lt;/code&gt;，&lt;/em&gt;生成「杨辉三角」的前 &lt;em&gt;&lt;code&gt;numRows&lt;/code&gt;&lt;/em&gt; 行。&lt;/p&gt;
&lt;p&gt;在「杨辉三角」中，每个数是它左上方和右上方的数的和。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode224.基本计算器</title>
    <link href="2023/04/19/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>2023/04/19/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2023-04-19T14:40:16.000Z</published>
    <updated>2023-04-20T02:08:21.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;1 + 1&quot;输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot; 2-1 + 2 &quot;输出：3</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li><li>‘+’ 不能用作一元运算(例如， “+1” 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</li><li>‘-‘ 可以用作一元运算(即 “-1” 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</li><li>输入中不存在两个连续的操作符</li><li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>题目要求实现一个计算器，计算一个字符串表达式的值。因为表达式中可能会存在括号，为了方便计算，可以使用递归的方法来实现。当遇到左括号时，递归调用自身来计算括号内的表达式值，当遇到右括号时，返回计算结果。当遇到加号或减号时，记录当前的操作符。当遇到数字时，记录当前的数值，并根据之前的操作符进行相应的计算。</p><p>具体步骤如下：</p><ol><li>定义一个辅助栈，用于存储之前的操作符和数字；</li><li>遍历表达式字符串，遇到数字时记录下来，遇到左括号时递归调用自身，遇到右括号时返回计算结果；</li><li>遇到加号或减号时，记录当前的操作符，遇到其他字符时忽略；</li><li>当遇到表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，并返回最终结果。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int calculate(string s) &#123;        stack&lt;int&gt; st;  &#x2F;&#x2F; 定义一个辅助栈，用于存储之前的操作符和数字        int num &#x3D; 0;  &#x2F;&#x2F; 用于记录当前的数值        int res &#x3D; 0;  &#x2F;&#x2F; 用于记录最终结果        int sign &#x3D; 1;  &#x2F;&#x2F; 用于记录当前的操作符，1表示加号，-1表示减号        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            if (isdigit(s[i])) &#123;  &#x2F;&#x2F; 如果当前字符是数字                num &#x3D; num * 10 + (s[i] - &#39;0&#39;);  &#x2F;&#x2F; 记录当前的数值            &#125; else if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;  &#x2F;&#x2F; 如果当前字符是左括号                int j &#x3D; i, cnt &#x3D; 0;                for (; i &lt; s.size(); i++) &#123;                    if (s[i] &#x3D;&#x3D; &#39;(&#39;) cnt++;                    if (s[i] &#x3D;&#x3D; &#39;)&#39;) cnt--;                    if (cnt &#x3D;&#x3D; 0) break;                &#125;                num &#x3D; calculate(s.substr(j + 1, i - j - 1));  &#x2F;&#x2F; 递归调用自身计算括号内的表达式值            &#125;            if (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;  &#x2F;&#x2F; 如果当前字符是加号或减号，或者已经遍历到表达式字符串的末尾                if (s[i] &#x3D;&#x3D; &#39;+&#39;) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中                    sign &#x3D; 1;  &#x2F;&#x2F; 更新操作符为加号                &#125; else if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中                    sign &#x3D; -1;  &#x2F;&#x2F; 更新操作符为减号                &#125; else if (s[i] &#x3D;&#x3D; &#39;)&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将最后一个数值乘上当前的操作符，并压入栈中                    int tmp &#x3D; 0;                    while (!st.empty()) &#123;  &#x2F;&#x2F; 从栈中取出数字和操作符进行计算，直到栈为空                        tmp +&#x3D; st.top();                        st.pop();                    &#125;                    res &#x3D; tmp;  &#x2F;&#x2F; 更新最终结果                &#125;                num &#x3D; 0;  &#x2F;&#x2F; 清空当前的数值            &#125;        &#125;        return res;  &#x2F;&#x2F; 返回最终结果    &#125;&#125;;</code></pre><blockquote><p>上述代码使用了一个栈来存储之前的数字和操作符，用于最后的计算。遇到左括号时，递归调用自身计算括号内的表达式值。遇到加号或减号时，记录当前的操作符和数字，当遇到右括号或表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，得到最终结果。</p></blockquote><p>需要注意的是，在遇到左括号时，需要找到对应的右括号位置，才能正确地计算括号内的表达式值。这里使用了一个变量cnt来记录遍历到的左括号数量和右括号数量的差值，当cnt为0时，说明找到了对应的右括号。</p><p>另外，需要注意的是，当遍历到表达式字符串的末尾时，也需要将之前记录的数字和操作符进行计算，得到最终结果。因此，在遍历完表达式字符串后，还需要进行一次栈中剩余数字和操作符的计算，以得到最终结果。</p><p>最后，需要注意对于操作数可能有多个位数的情况，需要在遍历字符串时将多位数字组合成一个完整的数值。这里使用了一个变量num来记录当前的数值，每次遍历到数字时，将其乘以10并加上当前位的数值即可。</p><p>综上所述，上述代码实现了一个简单的基本计算器，可以计算表达式中的加减法和括号，并返回最终结果。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串表达式 &lt;code&gt;s&lt;/code&gt; ，请你实现一个基本计算器来计算并返回它的值。&lt;/p&gt;
&lt;p&gt;注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 &lt;code&gt;eval()&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>WorkflowSim工作流仿真软件介绍+类的介绍+自创算法实现步骤</title>
    <link href="2023/04/19/WorkflowSim%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D-%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D-%E8%87%AA%E5%88%9B%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/"/>
    <id>2023/04/19/WorkflowSim%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D-%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D-%E8%87%AA%E5%88%9B%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/</id>
    <published>2023-04-19T08:00:38.000Z</published>
    <updated>2023-04-19T13:05:55.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intorduction"><a href="#Intorduction" class="headerlink" title="Intorduction"></a>Intorduction</h2><p>现在的大数据应用都非常复杂，并不仅仅能够通过一个或者几个MapReduce任务来描述。更加复杂的描述大数据应用的是工作流 (workflow)。</p><p>WorkflowSim (<a href="http://www.workflowsim.org/)%E6%98%AF%E7%94%B1%E5%8D%97%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%A6">http://www.workflowsim.org/)是由南加州大学</a>(University of Southern California)的Weiwei Chen开发的一套开源工作流仿真软件。WorkflowSim是拓展自CloudSim的工作流仿真开源软件，可以提供工作流基础上的仿真，增加了模拟不同层次延时和故障的支持，与真实分布式环境更加接近。支持了各种task scheduling, clustering, resource provisioning的算法。广泛应用在故障容错研究，成本导向调度研究，资源调度研究，能耗研究等领域。</p><span id="more"></span><p>其工作原理是在暨有的CloudSim仿真软件基础上，提供workflow层次的仿真。工作流可以用有向图来描述(Directed Acyclic Graph) DAG，图的任何一个节点都是一个由用户制定执行的任务(task)，节点之间有通过数据输入输出形成的依赖关系(dependency)。工作流引擎会依据其依赖关系按顺序执行，同时执行也会调用用户所选择的调度算法，比如HEFT，MINMIN等等算法已经在WorkflowSim里边实现并且测试通过了。</p><p>用户也可以添加自己的调度算法。</p><p>在实际运行过程中，因为很多工作流非常大，甚至到达几千上万个任务，而通常我们只有几十个计算节点。这个时候就需要使用task clustering这个技术来聚合相类似的任务从而形成任务群(clustered job)，有时候也通用称之为job。每个job包含了多个task，然后提交给运行环境的时候是整体提交的，这样可以节省很多延迟(submission delay)，等到了某一个计算节点的时候再打开任务群然后分别执行。</p><p>如何形成job就需要各种算法，有包括了balanced task clustering可以综合考虑依赖关系的，也有fault tolerant clustering可以综合考虑规避failure的。这些也都已经在WorkflowSim里边实现。</p><p>其行为最为接近Pegasus工作流管理系统。</p><p>WorkflowSim是一套开源软件，所有源代码和介绍都可以在<a href="http://www.github.com/WorkflowSim/%E6%89%BE%E5%88%B0%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9B%AE%E5%89%8D%E6%B5%81%E8%A1%8C%E7%9A%84Git%E5%81%9A%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E3%80%82">http://www.github.com/WorkflowSim/找到，使用目前流行的Git做软件版本控制。</a></p><p>使用非常简单，下载完源代码之后，只需要在任何一个WorkflowSim example里边选择所需要的dax 文档，并且修改里边的daxPath变量，即可运行。比如选择:“examples&#x2F;org&#x2F;workflowsim&#x2F;examples&#x2F;WorkflowSimBasicExample1.java”这个例子，将里边的daxPath改成在你当前环境下的文件路径即可。</p><p>WorkflowSim在config&#x2F;dax文件夹下面已经提供了很多DAX文件可供仿真。这些工作流的介绍可以参考：Documentation – Pegasus WMS</p><p>同时我们还提供WorkflowGenerator可以生成你所需要的任何工作流DAX文件<a href="https://confluence.pegasus.isi.edu/display/pegasus/WorkflowGenerator">https://confluence.pegasus.isi.edu/display/pegasus/WorkflowGenerator</a></p><p>如果对WorkflowSim感兴趣并且想进一步开发功能，可建议（但不限于）研究以下方面</p><ol><li><p>基于价格的调度算法，CloudSim本身已经实现了每个task的cost，但是WorkflowSim还没有合适的调度算法。</p></li><li><p>动态资源调度算法。WorkflowSim目前还是静态的把计算节点建立好然后运行工作流。</p></li><li><p>多数据中心支持。目前只测试了单数据中心支持。</p></li><li><p>数据日志支持。将已有的工作流管理系统的log转换成为trace从而可以在WorkflowSim里边仿真？目前只测试过Pegasus。</p></li><li><p>可靠的调度算法，在仿真Failure的情况下调度算法应该如何变得更鲁棒？目前failure的生成已经开发完成，但是相应的算法还没有。</p></li><li><p>自适应算法或者分布式算法。目前仅有一个中心调度算法，分布式算法也可以在WorkflowSim上面实现。</p></li><li><p>基于duplication的算法。在计算节点有余的时候，可以自动复制一部分任务到空闲的计算节点上。</p></li></ol><h3 id="WorkflowSim中调度算法与规划算法的区别"><a href="#WorkflowSim中调度算法与规划算法的区别" class="headerlink" title="WorkflowSim中调度算法与规划算法的区别"></a>WorkflowSim中调度算法与规划算法的区别</h3><p>WorkflowSim中有两种类型的算法：调度算法（Scheduling Algorithm）和计划算法（Planning Algorithm）。理论上它们是相同的，但是在实现方面它们是完全不同的。WorkflowSim 具有三层：Workflow Planner、Workflow Engine、Workflow Scheduler。</p><p>在 Workflow Planner 中，我们拥有整个工作流（所有任务及其依赖项）的全局视图，并且在每次迭代中，Workflow Engine 将free的任务（这意味着它们的父级已成功完成）发布到 Workflow Scheduler。Workflow Scheduler 将这些free的任务与资源（WorkflowSim 中的 Condor VM）进行匹配，并提交它们以供执行。分别来说，规划算法是一种全局调度算法，可以将任何任务绑定到任何资源（但实际执行顺序取决于资源可用性）。WorkflowSim 中的调度算法是一种本地调度算法，它只将空闲任务绑定到可用资源（并以某种方式保证它们的执行顺序）。</p><p>默认情况下，未设置规划算法。如果您已指定规划算法，则调度算法将被禁用，因为指定的规划算法强制工作流调度程序将任务映射到其分配的资源。</p><p>一些局部优化算法如MIN-MIN、MAX-MIN是调度算法，而一些全局优化算法如HEFT是WorkflowSim中的规划算法</p><h3 id="SHARED和LOCAL文件系统之间的区别"><a href="#SHARED和LOCAL文件系统之间的区别" class="headerlink" title="SHARED和LOCAL文件系统之间的区别"></a>SHARED和LOCAL文件系统之间的区别</h3><p>SHARED文件系统只有一个用于一个数据中心的存储空间，而LOCAL文件系统也有一个用于每个VM的本地文件系统。</p><p>对于 stage-in，在 SHARED 模式下，我们在stage-in作业开始时将所有的输入文件移动到共享存储中。在 LOCAL 模式下，我们将每个任务的输入文件从最近的 VM（因为 VM 也具有本地文件系统）或共享文件系统（如果该任务分配到的 VM 可用）移动。</p><p>对于数据传输成本，在 SHARED 模式下，数据传输成本已经计入任务执行时间，因此我们不计算每个作业的数据传输成本。但我们计算了初始阶段工作的成本。在 LOCAL 模式下，增加每个作业的数据传输成本。</p><p>为什么我们需要区分它们？在实践中，我们要么拥有一个共享文件系统，例如 NFS，要么拥有一个分布式系统，例如 HDFS。如果您有一些数据感知算法来提高数据局部性，则需要使用 LOCAL。否则，如果您的算法不考虑数据，您可以使用 SHARED fs 来简化建模。</p><h3 id="Task-和-Job-之间的区别（以及任务集群）"><a href="#Task-和-Job-之间的区别（以及任务集群）" class="headerlink" title="Task 和 Job 之间的区别（以及任务集群）"></a>Task 和 Job 之间的区别（以及任务集群）</h3><p>尽管在某些情况下我们可以互换使用Task和Job，但它们是完全不同的。任Task是用户指定运行的程序。它对应于 DAX 中的“job”，因为 DAX 是由用户创建的。WorkflowSim 中的Job是包含一个或多个Task的单个执行单元。但是，WorkflowSim 中的Job本身是从Task延伸扩展的，目的是简化一些代码。</p><p>任务聚类是一种将多个Task合并为一个Job的优化方法。根据不同的优化目的，我们最终可能会得到容错集群（最小化故障影响）、平衡任务集群（平衡数据传输成本和通信成本）等。</p><p>为什么任务集群即使它失去了一些并行性，也可以减少makespan？</p><p>任务集群只能在资源争用的情况下工作，这意味着我们没有足够的资源，必须将任务合并到任务中。例如，Montage工作流在每个级别最多可以有10,000个任务，而通常在一个小型数据集群中有20个节点。通过将这些任务合并为20或40个作业，我们仍然可以充分利用资源并提高整体运行时间。另一个重要问题是开销，作业提交、作业执行、作业准备都具有在现代分布式系统中非常重要的开销。单独执行10,000个任务最终可能会产生10,000倍的开销，而20个作业有20倍的开销。</p><p>有关任务聚类的好处的更多详细信息，请参阅任何任务聚类论文。</p><h3 id="如何在类中增加属性？"><a href="#如何在类中增加属性？" class="headerlink" title="如何在类中增加属性？"></a>如何在类中增加属性？</h3><p>如果你有一个新的属性要在WorkflowSim中使用，并且想要在配置文件中配置它，可以进行下面的几个步骤:</p><ol><li>假设我们想要添加一个工作流的截止日期，并且它是一个很长的变量。在org.workflowsim.utils.Parameters.java中，添加:</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> deadline<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">long</span> dl<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">//other parameters</span> deadline <span class="token operator">=</span> dl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> deadline<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><blockquote><p><em>因为<strong>Parameters</strong>是一个静态对象，通过这种方式，我们可以在任何地方访问<strong>deadline</strong>。</em></p></blockquote><ol start="2"><li><p><em>在<strong>org.workflowsim.utils.ArgumentParser.java</strong>中添加解析</em></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArgumentParser</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//other parameter parsing</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"deadline"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> deadline <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token class-name">Parameters</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> deadline<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre></li></ol><blockquote><p><em>这意味着我们在解析配置文件时设置了参数的截止日期。</em></p></blockquote><ol start="3"><li><em>在<strong>config.txt</strong>中添加截止日期</em></li></ol><p>在<em>config.txt**文件中添加：</em></p><pre class="language-java" data-language="java"><code class="language-java">deadline <span class="token operator">=</span> <span class="token number">10000</span></code></pre><ol start="4"><li><em>然后你可以在你的调度程序中得到截止日期，比如在<strong>RandomPlanner.java</strong>中：</em></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token class-name">Parameters</span><span class="token punctuation">.</span><span class="token function">getDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="类的介绍"><a href="#类的介绍" class="headerlink" title="类的介绍"></a>类的介绍</h2><h3 id="Cloudlet"><a href="#Cloudlet" class="headerlink" title="Cloudlet"></a>Cloudlet</h3><p>Cloudlet类对托管在云数据中心的容器中的应用程序进行建模。Cloudlet继承了CloudSim软件包中的功能。包括用户id，任务的大小，传入文件的大小。传出文件的大小，执行开始时间，完成时间和执行状态（CREATED，READY，QUEUED,CANCEL,PAUSED ,FAILED,SUCCESS和RESUMED等）等。详情见“sources\org\cloudbus\cloudsim\Cloudlet.java”。</p><p>Cloudlet类中包含一个静态内部类：Resource，它被用来跟踪Cloudlet在不同CloudResource中的移动。记录Cloudlet在一个CloudResource中的提交时间、等待时间、时间运行时间、成本等信息。</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Task类是CloudSim中Cloudlet类的一个扩展。它支持实现任务之间的依赖关系，其中包括一组父任务和一组其子任务。在WorkflowSim中，当所有的父任务都成功完成时，工作流引擎确保任务被释放到调度器(准备运行)。</p><p>相比Cloudlet类，Task新增了parentList，childList，taskFinishTime等属性。其中增加taskFinishTime是因为cloudlet不允许WorkflowSim更新任务的finish time。Task类中的getProcessingCost()方法用来获取处理或执行此任务的总成本。原始的Processing Cost &#x3D; input data transfer + processing cost + output transfer cost</p><p>【可根据需要进行修改】。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job是Task的扩展。它基本上是一组任务。在WorkflowSim中，ClusteringEngine将任务合并为任务(任务组)，并且job的总体运行时间是task运行时间的总和。</p><h3 id="Vm"><a href="#Vm" class="headerlink" title="Vm"></a>Vm</h3><p>Vm 类对VM进行建模。虚拟机由主机管理和托管，它运行在一个主机内，与其他虚拟机共享hostList。VM的属性有内存，处理器及其存储大小。它根据CloudletScheduler定义的策略处理cloudlet。每个虚拟机都有一个所有者，由所有者将cloudlet提交给要执行的虚拟机。</p><h3 id="CondorVM"><a href="#CondorVM" class="headerlink" title="CondorVM"></a>CondorVM</h3><p>Condor Vm扩展一个Vm，不同的是它有一个本地存储系统和一个状态来指示它是否忙碌：VM_STATUS_IDLE or VM_STATUS_READY (not used in workflowsim) or VM_STATUS_BUSY。</p><h3 id="FileItem"><a href="#FileItem" class="headerlink" title="FileItem"></a>FileItem</h3><p>这是WorkflowSim中的一个文件实现。由于CloudSim已经实现了File，我们在这里称之为FileItem。WorkflowSim有一个不同的文件视图。案例1:在org.cloudsim.File中，文件大小是integer类型，而在我们的例子中，它应该是double类型，因为我们有很多大的文件。此外，我们希望精确地估计传输延迟。案例2:我们指定与CloudSim中不同的文件的类型FileType (NONE，输入INPUT，输出OUTPUT)。</p><p>FileItem类中的isRealInputFile()方法，用于判断文件是否为输入文件。输入文件对应有一个输出文件，它不需要在工作流中阶段加入，我们有一个规则，一个文件只写一次，并多次读取，因此，如果一个文件是一个输出文件，这意味着它是在这个作业中生成的，然后由同一作业(或者其他作业)中的另一个任务使用。</p><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>Parameters类包含用户可以在配置文件中指定的大多数参数。</p><p>类中定义了调度算法、规划算法、文件类型、成本模型等枚举类型，以及虚拟机个数、调度算法、规划算法、成本模型、最大深度等属性。</p><h3 id="Datacenter"><a href="#Datacenter" class="headerlink" title="Datacenter"></a>Datacenter</h3><p>DataCenter类代表数据中心，提供虚拟化的网格资源，处理虚拟机信息的查询，包含虚拟机对资源的分配策略。数据中心类是一个CloudResource，它的主机列表是虚拟化的。它处理VM查询(即VM处理)，而不是处理与cloudlet相关的查询。即使一个分配策略将被实例化(在超类的init()方法中)，它也不会被使用，因为cloudlets的处理由CloudletScheduler处理，虚拟机的处理由VmAllocationPolicy处理。</p><p>类中包含DatacenterCharacteristics属性，DatacenterCharacteristics表示资源的静态属性，如资源架构、操作系统(OS)、管理策略(时间或空间共享)、成本和资源配置中所处的时区。</p><h3 id="WorkflowDatacenter"><a href="#WorkflowDatacenter" class="headerlink" title="WorkflowDatacenter"></a>WorkflowDatacenter</h3><p>WorkflowDatacenter扩展了Datacenter，这样我们就可以使用CondorVM和其他组件。</p><p>类中包含processCloudletSubmit()方法，它处理Cloudlet提交。cloudlet实际可以被cast到org.workflowsim.Job 。</p><p>updateTaskExecTime()方法更新job中的task的执行时间与完成时间。</p><p>stageInFile2FileSystem()方法，将处于stage-in 阶段的job所需文件加入存储。对于本地文件系统(如condor-io)，将文件添加到本地存储；对于共享文件系统(如NFS)，需要向共享存储添加文件。</p><p>processDataStageInForComputeJob()方法，返回job执行所需的文件传输时间个执行时间。</p><h3 id="WorkflowParser"><a href="#WorkflowParser" class="headerlink" title="WorkflowParser"></a>WorkflowParser</h3><p>WorkflowParser将DAX解析为任务，以便WorkflowSim可以管理它们。</p><p>DAX的文件格式如下：</p><p><img src="http://cdn.leafii.top/img/1f7d9ac573959e92928a9529130d523c.png" alt="img" loading="lazy"></p><p>类中的parseXmlFile(String path)方法，根据参数DAX文件的地址path，将其转换为工作流。它遍历整个dax文件，将所有的<code>&lt;job&gt;&lt;/job&gt;</code>标签，转换为工作流中的任务task，其中id是该任务的唯一标识；runtime为该任务的长度；其内部的<code>&lt;uses&gt;&lt;/uses&gt;</code>标签代表该任务的文件。link属性表示文件的种类（input输入文件或output输出文件）；size属性代表该文件的大小；其中file属性代表该文件的名字。【任务A的output输出文件名file和大小size需要与其对应的任务B的input输入文件名和大小相同！】</p><p><code>&lt;child&gt;&lt;parent&gt;&lt;/parent&gt;&lt;/child&gt;</code>标签表示任务之间的依赖关系，即某一个子任务child的父任务parent有哪些。其中ref属性的值对应<code>&lt;job&gt;</code>标签中的id属性。parseXmlFile()方法根据这些依赖关系，设置工作流中的某一个任务的子任务与父任务及其深度。如果一个任务没有父任务，则将其设置为root。【root可能有多个！】</p><h3 id="SimEntity"><a href="#SimEntity" class="headerlink" title="SimEntity"></a>SimEntity</h3><p>该类表示一个模拟实体。实体可以处理事件，也可以发送事件给其他实体。当这个类被扩展时，有几个方法需要被实现:</p><p>①startEntity()：在模拟启动时，由Simulation类调用。这个方法负责启动实体。</p><p>② processEvent(SimEvent)：每当延迟队列中有需要由实体处理的事件时，仿真类就会调用processEvent(SimEvent)。</p><p>③ shutdownEntity()：在模拟结束之前，仿真调用shutdownEntity()。如果你想将数据保存在日志文件中，这个方法将放置相应的代码。</p><h3 id="WorkflowScheduler"><a href="#WorkflowScheduler" class="headerlink" title="WorkflowScheduler"></a>WorkflowScheduler</h3><p>WorkflowScheduler它隐藏了虚拟机管理，例如创建虚拟机、将任务交给虚拟机以及销毁虚拟机，并根据配置选择调度算法。</p><p>一个workflowScheduler代理中绑定一个workflowEngine，即其含有一个workflowEngineId属性，并通过bindSchedulerDatacenter(int datacenterId)方法将其与一个数据中心绑定。与此同时，为了保证每个任务仅提交一次，设置一个布尔类型的变量processCloudletSubmitHasShown来标记任务是否提交。除此之外，workflowScheduler代理根据不同的指令执行对应的事件，如下图：</p><p><img src="http://cdn.leafii.top/img/78b5a2e208681634869183a8c4c14a88.png" alt="img" loading="lazy"></p><h3 id="WorkflowEngine"><a href="#WorkflowEngine" class="headerlink" title="WorkflowEngine"></a>WorkflowEngine</h3><p>WorkflowEngine为代表用户的引擎。它隐藏了虚拟机管理，例如创建虚拟机、向虚拟机提交cloudlet和销毁虚拟机。由于WorkflowEngine类继承了SimEntity类，所以他重写了startEntity()、processEvent(SimEvent)、shutdownEntity()方法。一个workflowEngine引擎控制多个workflowScheduler代理。</p><p>hasJobListContainsID(List jobList, int id)方法：用来判断一个任务列表中是否存在某个任务。</p><p>submitJobs()方法：在提交获得的任务列表时，借助hasJobListContainsID(List jobList, int id)方法来判断某个要提交的任务的所有父任务是否已经全部执行完毕。</p><h3 id="WorkflowPlanner"><a href="#WorkflowPlanner" class="headerlink" title="WorkflowPlanner"></a>WorkflowPlanner</h3><p>WorkflowPlanner根据配置选择规划算法。他有一个ClusteringEngine属性，即一个workflowPlanner代理与一个clusteringEngine引擎绑定，并通过clusteringEngine引擎绑定到一个workflowEngine引擎中。【ClusteringEngine类是WorkflowSim的一个可选组件，它可以将多个任务合并成一个大任务，由于目前本人还没有使用到，所以暂不介绍~】</p><p>WorkflowPlanner类中的getPlanningAlgorithm(PlanningAlgorithm name)方法可以根据需要选择规划算法，<strong>一般我们在使用WorkflowSim创建自己个人的算法时，写的算法是PlanningAlgorithm类型的规划算法。</strong></p><p>workflowPlanner代理可以为任务添加影响因子，这对任务平衡的聚类算法很有用，我们可以根据研究需要，选择使用。方法为：processImpactFactors(List<Task> taskList) 与addImpact(Task task, double impact)。</p><h3 id="BaseSchedulingAlgorithm"><a href="#BaseSchedulingAlgorithm" class="headerlink" title="BaseSchedulingAlgorithm"></a>BaseSchedulingAlgorithm</h3><p>BaseSchedulingAlgorithm类继承了SchedulingAlgorithmInterface接口，它是一个基本调度器实现了基本功能。如：虚拟机的get与set，cloudlet类型的任务列表的get与set，以及主要的run()方法。其他调度方法应扩展自BaseSchedulingAlgorithm，但不应直接使用。</p><h3 id="BasePlanningAlgorithm"><a href="#BasePlanningAlgorithm" class="headerlink" title="BasePlanningAlgorithm"></a>BasePlanningAlgorithm</h3><p>BasePlanningAlgorithm类继承了PlanningAlgorithmInterface接口，它是一个基本规划器实现了基本功能。如：虚拟机的get与set，任务列表的get与set，以及主要的run()方法。其他调度方法应扩展自BasePlanningAlgorithm，但不应直接使用。</p><p>与BaseSchedulingAlgorithm<strong>不同</strong>，BasePlanningAlgorithm可以直接设置并获取Task类型的任务列表，并增加了数据中心列表DatacenterList的get与set。</p><p><strong>【我们使用WorkflowSim创建个人的算法时，需要继承BasePlanningAlgorithm类】。</strong></p><h3 id="WorkflowSimBasicExample1"><a href="#WorkflowSimBasicExample1" class="headerlink" title="WorkflowSimBasicExample1"></a>WorkflowSimBasicExample1</h3><p>由其名可知，这是一个基本的WorkflowSimExample，它创建了一个工作流规划器、一个工作流引擎、一个调度器、一个数据中心和20个虚拟机。【根据实际情况在使用时更改daxPath与其他参数】。它包含4个方法：main()方法，创建虚拟机的方法createVM()，创建数据中心的方法createDatacenter()，以及输出结果的方法printJobList()。</p><p>main()方法实现了：①初始化WorkflowSim包；②初始化Parameters参数；③初始化cloudsim包；④创建数据中心；⑤创建调度算法代理；⑥创建WorkflowEngine引擎；⑦创建工作流；⑧创建虚拟机；⑨执行调度算法，完成任务到虚拟机的映射；⑩启动仿真程序、打印仿真结果以及关闭仿真程序。</p><p>我们在写好了自己的算法后，为了实现他，则需要<strong>创建一个继承了WorkflowSimExample的example来运行算法。</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="如何创建并使用调度算法"><a href="#如何创建并使用调度算法" class="headerlink" title="如何创建并使用调度算法"></a>如何创建并使用调度算法</h3><p>当我们下载好WorkflowSim源码后，便可以实现一个自己的调度算法。具体步骤如下：</p><ol><li>在source&#x2F;org&#x2F;planning中写一个继承BasePlanningAlgorithm的Class，类名如RKPNPlanningAlgorithm,重写run()方法。【可参考HEFTPlanningAlgorithm算法】，如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/71c79ef2c2ba683cd3c80a7aa23f0dde.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/dcdd7c3c49b40442515f15fc3178b30c.png" alt="img" loading="lazy"></p><ol start="2"><li>算法写完之后，需要在WorkflowPlanner的getPlanningAlgorithm()方法中增加该算法，具体操作如下：</li></ol><p><img src="http://cdn.leafii.top/img/75501f37de1f5ed5c7679f28e655203b.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/b05b6fe6250db499ccefd05b43ec576d.png" alt="img" loading="lazy"></p><p>其中的case：RKPN中的RKPN是自定义的算法名的缩写。</p><ol start="3"><li>在参数类Parameters的枚举PlanningAlgorithm里面添加步骤2的case:RKPN，具体操作如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/b9ab51fe998664ccd21b63f0157c7230.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/f957d7ca93dbc563cf4f51141b28cb51.png" alt="img" loading="lazy"></p><ol start="4"><li>这样我们的一个调度算法就编写完了，如何使用呢？需要在”examples&#x2F;org&#x2F;workflowsim.examples&#x2F;planning”中创建一个example来实现它。具体操作如下：</li></ol><p><img src="http://cdn.leafii.top/img/4f4798e0f63054ec8c031c4a21274878.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/d2f07a1477cb395186d059fa898a3f89.png" alt="img" loading="lazy"></p><p>如图所示，在main()方法中需要根据自己的dax工作流文件的存放地址修改daxPath的值。【在“config&#x2F;dax”中也有许多可供使用的工作流文件~】</p><p><img src="http://cdn.leafii.top/img/80bc660ab00519661684d2be785cd0c0.png" alt="img" loading="lazy"></p><p>上图修改Parameters的规划算法参数，值为在步骤(3)中设置的参数</p><p>除此之外，我们也可以根据需要自行设置虚拟机的个数vmNum等其他参数。具体操作见代码。</p><ol start="5"><li>运行main()函数，即可在控制台获得工作流的运行结果。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文直接复制粘贴自：<a href="https://blog.csdn.net/LaraJean/article/details/123689433">https://blog.csdn.net/LaraJean/article/details/123689433</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Intorduction&quot;&gt;&lt;a href=&quot;#Intorduction&quot; class=&quot;headerlink&quot; title=&quot;Intorduction&quot;&gt;&lt;/a&gt;Intorduction&lt;/h2&gt;&lt;p&gt;现在的大数据应用都非常复杂，并不仅仅能够通过一个或者几个MapReduce任务来描述。更加复杂的描述大数据应用的是工作流 (workflow)。&lt;/p&gt;
&lt;p&gt;WorkflowSim (&lt;a href=&quot;http://www.workflowsim.org/)%E6%98%AF%E7%94%B1%E5%8D%97%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%A6&quot;&gt;http://www.workflowsim.org/)是由南加州大学&lt;/a&gt;(University of Southern California)的Weiwei Chen开发的一套开源工作流仿真软件。WorkflowSim是拓展自CloudSim的工作流仿真开源软件，可以提供工作流基础上的仿真，增加了模拟不同层次延时和故障的支持，与真实分布式环境更加接近。支持了各种task scheduling, clustering, resource provisioning的算法。广泛应用在故障容错研究，成本导向调度研究，资源调度研究，能耗研究等领域。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode486.预测赢家</title>
    <link href="2023/04/19/leetcode486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"/>
    <id>2023/04/19/leetcode486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</id>
    <published>2023-04-19T06:44:54.000Z</published>
    <updated>2023-04-19T07:00:57.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p><p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 <code>0</code> 。每一回合，玩家从数组的任意一端取一个数字（即，<code>nums[0]</code> 或 <code>nums[nums.length - 1]</code>），取到的数字将会从数组中移除（数组长度减 <code>1</code> ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p><p>如果玩家 1 能成为赢家，返回 <code>true</code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 <code>true</code> 。你可以假设每个玩家的玩法都会使他的分数最大化。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,5,2]输出：false解释：一开始，玩家 1 可以从 1 和 2 中进行选择。如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。因此，玩家 1 永远不会成为赢家，返回 false 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,5,233,7]输出：true解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 107</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>首先，我们可以把这个问题看成是两个玩家在一堆石头上进行取石子游戏。每个玩家都可以在任何时候从石堆中取出一些石头，但是每次取石头的数量不能超过石堆中剩余石头的数量。游戏的规则是先手玩家必须先取，然后轮流取石头，直到石堆为空。每个石头的价值都不同，每个玩家在取石头时可以获得相应的价值。</p><p>我们可以用动态规划来解决这个问题。假设nums数组的长度为n，<code>dp[i][j]</code>表示在<code>nums[i...j]</code>范围内，先手玩家能获得的最大分数，那么先手玩家最终获胜的条件是<code>dp[0][n-1]</code>不小于nums中所有数之和的一半。</p><p>接下来考虑如何计算dp数组。首先，我们可以很容易地得出当区间长度为1时，<code>dp[i][i]</code>的值就是<code>nums[i]</code>。这是因为当只有一个数时，先手玩家必定获胜，得分为该数。</p><p>接下来，我们需要考虑更长的区间。假设当前处理的区间长度为len，则可以枚举区间左端点i，然后通过递推式来计算<code>dp[i][j]</code>。对于区间<code>[i,j]</code>，先手玩家可以选择<code>i</code>或<code>j</code>作为自己的选择，那么后手玩家就会在<code>[i+1, j]</code>或<code>[i, j-1]</code>区间内变成先手玩家。这样转化后的问题就可以通过<code>dp</code>数组的计算得到解决。</p><p>具体地，假设先手玩家选择了左端点i，那么后手玩家就会在<code>[i+1, j]</code>区间内变成先手玩家，此时先手玩家能获得的最大分数就是<code>nums[i]</code>加上区间<code>[i+2,j]</code>或区间<code>[i+1,j-1]</code>内先手玩家能获得的最大分数的最小值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">left &#x3D; nums[i] + min(dp[i+2][j], dp[i+1][j-1])</code></pre><p>同样地，假设先手玩家选择了右端点<code>j</code>，那么后手玩家就会在<code>[i, j-1]</code>区间内变成先手玩家，此时先手玩家能获得的最大分数就是<code>nums[j]</code>加上区间<code>[i,j-2]</code>或区间<code>[i+1,j-1]</code>内先手玩家能获得的最大分数的最小值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">right &#x3D; nums[j] + min(dp[i][j-2], dp[i+1][j-1])</code></pre><p>由于先手玩家和后手玩家的取石头顺序是交替进行的，因此先手玩家和后手玩家在不同的区间上作为先手玩家和后手玩家的情况应该分别考虑。最终，<code>dp[i][j]</code>的值就是left和right中的较大值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">dp[i][j] &#x3D; max(left, right)</code></pre><p>最终的答案就是<code>dp[0][n-1]</code>是否大于等于<code>nums</code>中所有数之和的一半。</p><p>代码实现时，我们可以使用二维数组<code>dp</code>来保存先手玩家能获得的最大分数，然后用双重循环来枚举区间长度和区间左端点，并使用上述递推式来计算<code>dp</code>数组中的每个元素。最后，比较<code>dp[0][n-1]</code>和<code>nums</code>中所有数之和的一半即可得到答案。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); &#x2F;&#x2F; 定义二维dp数组，dp[i][j]表示当剩下的数是nums[i..j]时，先手玩家比后手玩家多得的最大分数。        &#x2F;&#x2F; 处理区间长度为1的情况        for (int i &#x3D; 0; i &lt; n; i++) &#123;            dp[i][i] &#x3D; nums[i]; &#x2F;&#x2F; 当剩下的数只有一个时，先手玩家只能取这个数，并且得分就是这个数本身。        &#125;        &#x2F;&#x2F; 处理更长的区间        for (int len &#x3D; 2; len &lt;&#x3D; n; len++) &#123; &#x2F;&#x2F; 枚举区间长度            for (int i &#x3D; 0; i &lt;&#x3D; n - len; i++) &#123; &#x2F;&#x2F; 枚举区间左端点                int j &#x3D; i + len - 1; &#x2F;&#x2F; 区间右端点                int left &#x3D; nums[i] + min(i+2 &lt;&#x3D; j ? dp[i+2][j] : 0, i+1 &lt;&#x3D; j-1 ? dp[i+1][j-1] : 0); &#x2F;&#x2F; 先手玩家取nums[i]后，后手玩家就成为了先手玩家，接下来剩下的数就是nums[i+1..j]，此时先手玩家能得到的最大分数是dp[i+1][j]。如果先手玩家取nums[i]后，后手玩家也取了一个数，那么接下来剩下的数就是nums[i+2..j]，此时先手玩家能得到的最大分数是dp[i+2][j]。由于后手玩家也是聪明的，他肯定会选择让先手玩家得到更少的分数，因此先手玩家能得到的最大分数就是nums[i]加上min(dp[i+2][j], dp[i+1][j-1])。同理，我们也可以计算出先手玩家取nums[j]时能得到的最大分数right。                int right &#x3D; nums[j] + min(i &lt;&#x3D; j-2 ? dp[i][j-2] : 0, i+1 &lt;&#x3D; j-1 ? dp[i+1][j-1] : 0);                dp[i][j] &#x3D; max(left, right); &#x2F;&#x2F; 取left和right的较大值，表示先手玩家在nums[i..j]这个区间内能得到的最大分数。            &#125;        &#125;        &#x2F;&#x2F; 判断先手玩家是否能获胜        return dp[0][n-1] &gt;&#x3D; accumulate(nums.begin(), nums.end(), 0) &#x2F; 2.0; &#x2F;&#x2F; 如果先手玩家能得到的最大分数不小于nums中所有数之和的一半，那么先手玩家就能获胜。    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。&lt;/p&gt;
&lt;p&gt;玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 &lt;code&gt;0&lt;/code&gt; 。每一回合，玩家从数组的任意一端取一个数字（即，&lt;code&gt;nums[0]&lt;/code&gt; 或 &lt;code&gt;nums[nums.length - 1]&lt;/code&gt;），取到的数字将会从数组中移除（数组长度减 &lt;code&gt;1&lt;/code&gt; ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。&lt;/p&gt;
&lt;p&gt;如果玩家 1 能成为赢家，返回 &lt;code&gt;true&lt;/code&gt; 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 &lt;code&gt;true&lt;/code&gt; 。你可以假设每个玩家的玩法都会使他的分数最大化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1823.找出游戏的获胜者</title>
    <link href="2023/04/18/leetcode1823-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/"/>
    <id>2023/04/18/leetcode1823-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/</id>
    <published>2023-04-18T03:49:15.000Z</published>
    <updated>2023-04-18T04:12:22.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 <strong>顺时针顺序</strong> 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 <code>i</code> 名小伙伴顺时针移动一位会到达第 <code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code> ，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 <code>1</code> 名小伙伴的位置。</p><p>游戏遵循如下规则：</p><ol><li>从第 <code>1</code> 名小伙伴所在位置 <strong>开始</strong> 。</li><li>沿着顺时针方向数 <code>k</code> 名小伙伴，计数时需要 <strong>包含</strong> 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 <strong>顺时针下一位</strong> 小伙伴 <strong>开始</strong>，回到步骤 <code>2</code> 继续执行。</li><li>否则，圈子中最后一名小伙伴赢得游戏。</li></ol><p>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ic234-q2-ex11.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5, k &#x3D; 2输出：3解释：游戏运行步骤如下：1) 从小伙伴 1 开始。2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 6, k &#x3D; 5输出：1解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= n &lt;= 500</code></li></ul><p><strong>进阶：</strong>你能否使用线性时间复杂度和常数空间复杂度解决此问题？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>约瑟夫问题求解</li></ul><p>首先我们需要确定递推公式，假设上一轮淘汰的是第 m 个人，那么本轮淘汰的是第 $(m+k)% n$ 个人，所以我们可以得到递推公式：$f(n, k) &#x3D; (f(n-1, k)+k) % n$，其中$ f(n, k) $表示 n 个人中最后剩下的人的编号。</p><p>当只有一个人的时候，那么这个人一定是胜者，因此我们可以得到初始值：f(1, k) &#x3D; 0。</p><p>最后，我们可以通过递推得到 f(n, k) 的值，即为最后的胜者的编号。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findTheWinner(int n, int k) &#123;        int ans &#x3D; 0;  &#x2F;&#x2F; 最后胜者的编号        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;  &#x2F;&#x2F; 从第二个人开始进行游戏            ans &#x3D; (ans + k) % i;  &#x2F;&#x2F; 计算本轮淘汰的人的编号        &#125;        return ans + 1;  &#x2F;&#x2F; 将编号从 0-based 转换为 1-based 并返回    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;共有 &lt;code&gt;n&lt;/code&gt; 名小伙伴一起做游戏。小伙伴们围成一圈，按 &lt;strong&gt;顺时针顺序&lt;/strong&gt; 从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 编号。确切地说，从第 &lt;code&gt;i&lt;/code&gt; 名小伙伴顺时针移动一位会到达第 &lt;code&gt;(i+1)&lt;/code&gt; 名小伙伴的位置，其中 &lt;code&gt;1 &amp;lt;= i &amp;lt; n&lt;/code&gt; ，从第 &lt;code&gt;n&lt;/code&gt; 名小伙伴顺时针移动一位会回到第 &lt;code&gt;1&lt;/code&gt; 名小伙伴的位置。&lt;/p&gt;
&lt;p&gt;游戏遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第 &lt;code&gt;1&lt;/code&gt; 名小伙伴所在位置 &lt;strong&gt;开始&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;沿着顺时针方向数 &lt;code&gt;k&lt;/code&gt; 名小伙伴，计数时需要 &lt;strong&gt;包含&lt;/strong&gt; 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。&lt;/li&gt;
&lt;li&gt;你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。&lt;/li&gt;
&lt;li&gt;如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 &lt;strong&gt;顺时针下一位&lt;/strong&gt; 小伙伴 &lt;strong&gt;开始&lt;/strong&gt;，回到步骤 &lt;code&gt;2&lt;/code&gt; 继续执行。&lt;/li&gt;
&lt;li&gt;否则，圈子中最后一名小伙伴赢得游戏。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给你参与游戏的小伙伴总数 &lt;code&gt;n&lt;/code&gt; ，和一个整数 &lt;code&gt;k&lt;/code&gt; ，返回游戏的获胜者。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
