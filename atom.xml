<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-05-31T09:34:09.569Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DeepMAG-使用多智能体图进行深度强化学习以实现灵活的作业车间调度</title>
    <link href="2023/05/31/DeepMAG-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%9B%BE%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BD%9C%E4%B8%9A%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6/"/>
    <id>2023/05/31/DeepMAG-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%9B%BE%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BD%9C%E4%B8%9A%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6/</id>
    <published>2023-05-31T09:20:59.000Z</published>
    <updated>2023-05-31T09:34:09.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling"><a href="#DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling" class="headerlink" title="DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling"></a>DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>一般的柔性车间调度执行基于两个决策步骤：任务次序（比如在一个机器上任务的执行顺序）以及任务路由（比如一个任务到一个机器的路径）。大多数现有的研究利用DRL或者MARL在大的搜索空间进行调度。<strong>但是</strong>这些研究有两个主要的限制：在DRL和MARL之间没有进行结合，独立的智能体之间没有合作。DeepMAG有两个关键贡献：1. DRL和MARL之间的结合。DeepMAG 通过将不同的智能体与每台机器和作业相关联，将 DRL 与 MARL 集成。每个智能体都利用 DRL 来找到有关作业排序和路由的最佳操作。在作业关联智能体选择最佳机器后，该作业成为机器进行下一个操作的作业候选者，而机器关联智能体从其作业候选集中选择下一个作业进行处理。2. 合作智能体。基于机器和作业之间的操作关系构建多智能体图。一个智能体与其相邻的智能体合作采取一个合作行动。最后，我们进行实验来评估 DeepMAG 的性能，实验结果表明它优于最先进的技术。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>作业车间调度 (JSS) 是最流行的调度问题之一，由于其在实际工厂中的广泛适用性，已被研究了几十年 [1]。 JSS 的决策步骤是通过在特定时间在特定机器上执行作业来对作业进行排序，其中 (1) 每个作业的操作需要按给定顺序（即<strong>优先约束</strong>）处理，(2) 每台机器只能处理一个任何时候作业的操作（即排除约束），以及（3）每个作业操作都有一台唯一的机器（即唯一约束）。而FJSS满足<strong>优先和排除约束</strong>但将<strong>唯一约束</strong>放宽为<strong>常量约束</strong>，其中作业的每个操作都可以在给定的常量机器集(Set)中的任何机器上处理，而不是在一台唯一的机器上处理。除了 JSS 中的作业排序（即作业在机器上执行的顺序）之外，FJSS 在作业路由上还有一个额外的决策步骤（即作业的每个操作到给定恒定机器集中的机器的路线） .</p><p><img src="http://cdn.leafii.top/img/image-20230525205309249.png" alt="image-20230525205309249" loading="lazy"></p><p>在现有的近似计算方法中，调度规则（Dispatching rules）很难得到满足真实生活应用的调度解；启发式搜索方法可以有效地到达可能的解，但是容易陷入局部最优；强化学习方法表现出了潜力，并且相较于其他方法更有到达精确最优解的潜能。但是这些方法有两个主要的缺陷：</p><ol><li><p>没有把DRL和MARL进行结合。</p><p>大多数研究工作将 DRL 用于大型状态空间 或将 MARL 用于大型动作空间。他们没有将 DRL 与 MARL 集成来解决 FJSS 中同时具有大状态和动作空间的难题。</p></li><li><p>独立的智能体。</p><p>当前的研究利用多个智能体来管理大的动作空间，但这些智能体彼此独立。结果，每个智能体都为一个子空间找到了自己的最优阶乘动作，而来自所有智能体的这些阶乘动作不一定构成一个最优联合动作。</p></li></ol><p>为了解决这两个限制，本文提出了一种基于深度强化学习和多智能体图的 FJSS 新模型，称为 DeepMAG，它具有两个重要特征。 </p><ol><li>DRL与MARL的融合。 DeepMAG 通过将每台机器或作业与一个独特的智能体相关联，将 DRL 集成到 MARL 中，该智能体利用 DQN 为机器关联的智能体找到作业排序的最佳操作，以选择下一个要处理的作业（如果可用）或作业路由作业相关的智能体在当前操作完成时选择一台机器进行下一个操作。此外，所有与机器相关的智能体共享一个 DQN，而所有与作业相关的智能体共享另一个。 </li><li>合作智能体。 DeepMAG 构建了一个多智能体图，由作为节点的智能体组成，节点基于机器处理作业操作的顺序和可以处理的作业的可能操作。每个智能体通过观察它们的操作关系并在每一步聚合相邻信息以采取一个合作行动来与其相邻智能体合作。</li></ol><p>本文的主要贡献可以概括为：</p><ul><li>我们通过将 DRL 与 MARL 集成，为 FJSS 开发了一个新模型 DeepMAG。 DRL 利用 DQN 来处理大状态空间，而 MARL 利用多个智能体来管理大动作空间。</li><li>我们设计了一个多智能体图，该图源自机器和作业之间的操作关系，包括机器的处理顺序和当前时间步正在机器上处理的作业的操作。所有智能体合作寻找最佳行动，以保证 DeepMAG 的良好回报。 </li><li>我们进行了广泛的实验，使用来自真实制造工厂的设置的模拟数据来评估 DeepMAG 的性能。实验结果表明，DeepMAG 明显优于其他竞争技术。</li></ul><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>将对JSS和FJSS的研究分为四类：计算优化方法(Operational optimization methods)，调度规则(Dispatching rules)，启发式搜索方法(Heuristic search methods)，强化学习(Reinforcement learning (RL) methods)；具体介绍略</p><h2 id="Problem-statement"><a href="#Problem-statement" class="headerlink" title="Problem statement"></a>Problem statement</h2><p>我们在第 3.1 节介绍了预备知识，并在第 3.2 节定义了 DeepMAG 的研究问题。在接下来的问题定义中，（1）大写字母表示一个随机变量，它相应的小写字母表示一个随机值，比如S是状态变量，s是S的状态值；（2）粗体字母表示向量，例如，<strong>S</strong>是状态变量向量，s是<strong>S</strong>的状态值向量。(3) 书法字母表示一组值，例如，S 表示一组状态值 s的集合。 (4) 黑板上的粗体字母表示函数，例如$\mathbb{P}$ 表示概率函数。 (5) 打字机字母表示一个常数，例如，p 表示生产率。</p><h3 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h3><p>Definition 3.1 (Markov Decision Process (MDP)).有限 MDP 是一个 4 元组 (S, A, R, P)，其中 S 是状态的有限集，A 是动作的有限集，R 是数字奖励的有限集，P 是四元组参数条件概率质量函数：</p><p>$\mathbb{P}(s’,r|s,a) &#x3D; Pr{S_{t+1} &#x3D; s’, R_{t+1} &#x3D; r|S_t &#x3D;s, A_t &#x3D; a}, (1)$</p><p>对于所有 s，s′ ∈ S，r ∈ R，a ∈ A。P(s′, r|s, a) 表示状态 s′ 和奖励 r 在时间步 t + 1 发生的概率，给定前面的状态 s 和动作 a 在时间步 t，它完全体现了有限 MDP 的动态。</p><p>在 MDP 中，智能体在每个连续的离散时间步与环境交互。在每个时间步 t，智能体接收环境的状态 St，从中选择一个动作 At。一个时间步之后，作为其选择 At 的结果，智能体收到数字奖励 Rt+1，并发现自己处于新状态 St+1。智能体选择动作 At 来最大化它在未来收到的折扣奖励的总和，这称为回报(return)。</p><p>Definition 3.2 (Return).回报 Gt 定义为在时间步 t 后收到的折扣奖励的总和：</p><p>$G_t &#x3D; R_{t+1} + \gamma R_{t+2} + \gamma^2R_{t+3} + … &#x3D; \sum_{n&#x3D;1}^{\infty}\gamma^{n-1}R_{t+n}(2)$，其中$\gamma$为折扣率。</p><p>智能体的目标是最大化其奖励的总量，这意味着最大化的不是即时奖励，而是长期的累积奖励。贴现率决定未来奖励的现值：在第 n 个未来时间步收到的奖励 Rt+n 乘以贴现率的 n-1 次方，即 γ n−1Rt+n。现实世界的问题，例如 JSS 和 FJSS，对于集中式智能体来说往往太大而无法解决。因此，研究人员研究了一个分布式多智能体系统，其中多个智能体在同一环境中行动以完成特定任务。因此，MDP 的定义可以扩展到这样的多智能体系统（定义 3.3）。</p><p>Definition 3.3 (Multi-agent MDP).多智能体 MDP 是一个 5 元组$ (\mathcal{I, S, A, R}, \mathbb{P})$，其中 I 是一组智能体，S 是可以分解为 $\mathcal{I}$的状态集。分量 $S &#x3D; S_1 × · · · × S_{|I|}$，$A &#x3D; A_1 × · · · × A_{|I|}$因此，共享相同奖励集 R 的智能体要执行的联合动作集，条件概率质量函数 P 由下式给出</p><p>$\mathbb{P}(s’,r|s,a) &#x3D; Pr{S_{t+1} &#x3D; s’, R_{t+1}&#x3D;r|S_t &#x3D; s, A_t &#x3D; a},(3)$，其中的s是所有智能体的状态$s_i$，A是所有智能体的动作$A_i$；</p><p>在多智能体 MDP 中，所有智能体在环境中观察自己的局部状态，采取各自的行动，并获得相同的奖励以相互合作完成相同的任务。 MARL 基于多智能体 MDP，通过将联合行动空间划分为多个具有阶乘行动的子空间来解决具有大联合行动空间的问题。每个智能体都可以直接应用各种 RL 方法将每个状态映射到最佳动作。具体来说，基于智能体 i ∈ I 的策略 π，使用 DQN 对具有大状态空间 Si 的状态-动作值函数 Q(si, ai) 进行参数化。</p><p>Definition 3.4 (Value Function).智能体 i ∈ I 在策略 π 下在状态 si 采取行动 ai 的值，表示为 Q(si, ai)，是在时间步 t 从 si 开始采取行动 ai，然后跟随 π 的预期回报，给定经过</p><p>$\mathbb{Q}(s_i, a_i) &#x3D; \mathbb{E}[G_t|S_t^i &#x3D; s_i, A_t^i &#x3D; a_i]$;在 DQN 中，π 是关于学习到的状态-动作值函数 Q(si, ai) 的贪心策略。</p><p>Definition 3.5 (Greedy Policy).对于任何状态-动作值函数 Q，相应的贪心策略 π 是确定性地选择具有最大值的动作 $a_i^*$ 的策略：</p><p>$a_i^* &#x3D; \pi(s_i) &#x3D; arg max \mathbb{Q}(s_i, a_i), for each s_i \in S_i$</p><h3 id="Problem-definition"><a href="#Problem-definition" class="headerlink" title="Problem definition"></a>Problem definition</h3><p>在本节中，我们定义了 MARL 框架中针对 FJSS 研究问题的重要概念。</p><p>环境(Environment)。 FJSS 的环境包括一组机器和一组作业，其中作业被路由到特定机器并在特定时间顺序处理。特别地，FJSS 环境包含第 1 节中提到的三个重要约束：（1）优先约束给出每个作业中操作的处理顺序，（2）排除约束要求在任何机器上处理的作业中最多有一个操作时间，以及（3）常量约束为作业的每个操作指定一个常量机器集。</p><p>智能体(Agents).每个智能体与环境交互，从中学习，然后做出决定。为了处理具有大动作空间的 FJSS，每台机器都与一个作业排序智能体相关联，方法是从机器的本地等待队列（即其作业候选集）中选择下一个作业，以便在可用时进行处理，而每个作业都是通过在当前操作完成时选择一台机器来处理其下一个操作，与作业路由的智能体相关联，然后该作业成为该机器的作业候选者。这些智能体一起工作，根据当前环境状态确定它们的最佳行动。</p><p>状态(States).状态是指环境的表示，包括机器和作业的各种特征，例如，机器的生产率及其关系、正在执行和可用于每个操作的机器数量，以及作业的工作量已完成或保留在不同的操作中。环境有一个全局状态，但每个智能体可能会观察到不同的局部状态。智能体在每个时间步采取行动后，全局状态会转换为新状态。</p><p>动作(Actions).有两种类型的智能体用于不同的操作。 与机器相关的智能体负责作业排序，并在相应机器可用时决定选择哪个作业进行处理。 与作业相关的智能体负责作业路由，并决定在当前操作完成时选择哪台机器来处理相应作业的下一个操作。 换句话说，机器相关智能体的动作是从工作候选集中选择一个工作，而工作相关智能体的动作是从一组固定的机器中选择一台机器。 重要的是要注意，智能体不会在每个时间步都采取行动； 该动作仅在机器可用或作业的当前操作在特定时间步完成时触发。</p><p>奖励(Rewards).在智能体人在时间步 t 采取行动后，他们从环境中收到相同的数字奖励 Rt+1。在每个时间步，奖励设置为 $R_{t+1} &#x3D; r &#x3D; −1$。在 FJSS 中，RL 的目标是最大化作为折扣奖励总和的回报，比如：最小化 makespan，即完成所有工作的总时间步数。</p><p>研究问题(Research problem).给定一组机器 M 和一组作业 J，每台机器 m ∈ M 在任何时候都只处理作业的一个操作（<strong>排除约束</strong>），并且具有指定每个时间步长完成的工作负载的生产率 pm；每个作业 j ∈ J 由 K 个有序操作组成 (oj,1, . . ., oj,K)（<strong>优先约束</strong>）；每个操作 oj,k 只能由一组常量机器 Mj,k ⊂ M（<strong>常量约束</strong>）处理，并且包含工作负载量 qj,k，表示 Mj,k 中给定机器上所需的时间步长。目标是在适当的时间段为特定机器的作业操作找到最佳计划，以最大限度地减少总处理时间，即完工时间。</p><h2 id="The-proposed-DeepMAG"><a href="#The-proposed-DeepMAG" class="headerlink" title="The proposed DeepMAG"></a>The proposed DeepMAG</h2><h3 id="Overview-of-DeepMAG"><a href="#Overview-of-DeepMAG" class="headerlink" title="Overview of DeepMAG"></a>Overview of DeepMAG</h3><p>简要的介绍了用于求解FJSS问题的DeepMAG，其通过两个DQN去进行job routing和job sequencing的决策。对于每一个时间步，DeepMAG按照以下的顺序进行执行。</p><ul><li><strong>Update agent graphs.</strong> DeepMAG 根据机器和作业之间的操作关系（第 4.2 节）<strong>更新</strong>多智能体图及其两种类型的变体（特定于机器的智能体图和特定于作业的智能体图）。</li><li>**Update features for each agent.**根据更新的智能体图，它提取基本特征、以机器为中心的特征和以作业为中心的特征（第 4.3 节）。</li><li>**Update the DQN for job routing.**对于每个准备好处理其对应作业的下一个操作的作业关联智能体，首先提取当前状态和所有候选动作（机器）的表示（第 4.4.2 节），然后深度 Q 学习算法用于从候选机器中选择一个动作来处理作业的下一个操作，更新重放内存，并通过随机梯度下降优化 DQN 的参数（第 4.5 和 4.6 节）。</li><li><strong>Update the other DQN for job sequencing.</strong> 对于每个可用的机器相关智能体，首先提取当前状态和所有候选动作（作业）的表示（第 4.4.1 节），然后应用深度 Q 学习从其候选作业中选择一个动作进行处理，更新回放内存，并通过随机梯度下降优化 DQN 的参数（第 4.5 和 4.6 节）。</li></ul><p>完成所有作业后，将为 FJSS 实例生成一个作业计划。通过在大量的 FJSS 实例上训练 DeepMAG，我们可以得到 DeepMAG 的近似最优参数。</p><h3 id="Multi-agent-graphs"><a href="#Multi-agent-graphs" class="headerlink" title="Multi-agent graphs"></a>Multi-agent graphs</h3><p>为了在job sequencing 和 job routing上大的连续动作空间去掌握FJSS，DeepMAG通过将每个机器或者任务用智能体联系起来来使用MARL。此外，这些智能体能够通过基于机器和作业之间的操作关系（即机器的处理顺序和当前时间步在机器上正在处理的作业的操作）来构建多智能体图的相互协作。需要注意DeepMAG并没有假定有固定数量的operation，并且自然而然地适应具有不同操作数量的场景。以下是多智能体图的定义。</p><p><strong>Definition 4.1</strong> (Multi-agent Graph).给定一组机器 M、一组作业 J 和一组机器 Mj,k ⊂ M 对于每个作业 j ∈ J 的每个操作 k，它们构成一个多智能体图 G &#x3D; (I, Es, Eu, Ev, Ew) 在一个时间步长，其中 I 是一组节点（即智能体）：</p><p>$I &#x3D; M \cup J \ \ \ \ \ \ \ \ (6)$</p><p>Es是机器之间在连续操作方面（例如，从 k 到 k + 1）静态关系的一组有向边：</p><p>$\varepsilon_s &#x3D; {m \rightarrow m’ |\exists j\in J, m \in M_{j,k}\and m’ \in M_{j, k+1}} \ \ \ \ \ \ \ (7)$</p><p>Eu是是机器在一个时间步处理的作业的动态关系上的一组无向边：</p><p>$\varepsilon_u &#x3D; {(j,m)|j\in J \ executing \ at \ m\in M} \ \ \ \ (8)$</p><p>Ev是作业的动态关系上的一组有向边，这些作业刚刚完成第 (k − 1) 次操作，并准备好在某个时间步路由到机器进行第 k 次操作：</p><p>$\varepsilon_v &#x3D; {m \rightarrow j|j \in J routing to m \in M_{j, k}} \ \ \ \ \ (9)$</p><p>Ew是在一个时间步等待在机器上的作业的动态关系的一组有向边：</p><p>$\varepsilon_w &#x3D; {j \rightarrow m|j \in J \ waiting\ at \ m \in M} \ \ \ \ (10)$</p><p>其中有向边 i → i’ 表示父子关系，i 是父节点，i’ 是子节点。</p><p>需要强调的是，在多智能体图中，所有与作业相连的边都是<strong>动态</strong>的，并且取决于在当前时间步可以处理的可能操作。此外，每个作业最多有一种类型的边，用于随时在机器上执行、等待或路由到机器。当一个作业完成时，其关联的智能体成为一个孤立的节点。此后，智能体和节点可互换地用于机器或作业。</p><p><img src="http://cdn.leafii.top/img/image-20230529180040531.png" alt="image-20230529180040531" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230529180231978.png" alt="image-20230529180231978" loading="lazy"></p><p>以图3为例：图3描述了一个多智能体图的例子，其中的M&#x3D;{1,2,3,4,5,6}, J &#x3D; {7,8,9,10,11,12},表1显示了每个任务的每个操作的机器集合。在图3中，黑色的结点表示同机器有关的智能体，白色结点表示和job有关的智能体。根据式7，结点1和结点3之间有一个有向边，因为job&#x3D;7（8，9 或10）在机器m&#x3D;1上有两个连续的操作。结点3和结点7由无向边进行连接，这表示job j&#x3D;7在现在的时间步在机器m&#x3D;3上正在执行。此外，job&#x3D;8和9都在第二个操作刚刚完成而且等待着路由第三个操作到机器m&#x3D;5或者6上，所以由式9可知结点5和6到结点8和9需要被连接起来。最后，基于式10，从结点10，11到结点4的有向边表明job j&#x3D;10和job j&#x3D;11正在机器m&#x3D;4上进行等待，此时的机器4正在执行job j &#x3D; 12。</p><p>在FJSS中，总会有一些在所有operation中拥有相同固定机器集合的job，比如在表1中的job8，9，10.考虑到现实世界中的job的不同operation会有不同的需要，所以不同的job的相同的operation可能会需要不同的机器来执行。比如说，表1中的job 7和11在前两个操作中需要的机器是完全不同的。这意味着这两个job在执行前两个操作时并没有竞争关系。这个特性在智能体执行动作时应该被考虑到。接下来我们定义一些重要且相关的定义。</p><p>Definition 4.2 (Equivalent Jobs).给定一个机器集合M，一个任务集合J，以及一系列固定的机器$M_{j,k}$，它表示每一个$job \ j \in J$的操作k需要的机器集合。当且仅当两个job的每一个操作都有相同的固定机器集合时，这两个job就是相等的。 </p><p>job相等的例子：表1中的$J &#x3D; {7,8,9,10,11,12}$有子集({7},{8,9,10},{11,12}).这几个子集都是每一个操作的固定机器集合都相同的相等任务。因此，我们可以将相等的任务形成一个特定任务的智能体图(Job-specific Agent Graph)。</p><p>Definition 4.3 (Job-specific Agent Graph).给定一系列的机器M，一系列的任务J，以及对每一个job j的operation k的一系列固定的机器集合$M_{j,k} \subset M$，特定于作业 j ∈ J 的智能体图 G(j) 和定义 4.1 中的多智能体图 G 的子图由作业 j 的节点、其等效作业及其每个操作的机器集，以及这些节点之间的边组成。</p><p>以表1为例，G(8)就是job j &#x3D; 8的特定任务智能体图，它由包括结点8，它的相等任务（9和10）以及固定的机器（1，3，4，5和6），以及这些结点之间的边组成。因此，我们可以通过移除结点2，7，11和12以及在图3中与他们相关的边构建G(8)。请注意，所有相等任务的特定任务的智能体图是一样的。举例来说，就是G(8) &#x3D; G(9) &#x3D; G(10).同样的，我们定义一个特定机器的智能体图。</p><p>Definition 4.4 (Machine-specific Agent Graph).给你一系列的机器集合M，一系列任务集合J，以及一系列固定机器集合$M_{j,k} \subset M$对于每一个任务j的每一个操作k，特定于机器 m ∈ M 的智能体图 $G(m)&#x3D;{I(m),\varepsilon_s(m),\varepsilon_u(m),\varepsilon_v(m),\varepsilon_w(m)}$和多智能体的子图定义 4.1 中的图 G 是所有作业 $G(j)&#x3D;{I(j),\varepsilon_s(j),\varepsilon_u(j),\varepsilon_v(j),\varepsilon_w(j)}$的作业特定智能体图的并集机器m可以处理的：$G(m) &#x3D; \bigcup_{j \in {j’|\exist k, m\in M_{j’,k}}}G(j)$</p><p>其中图并集在节点集 I(j) 和边集 Es(j)、Eu(j)、Ev(j) 和 Ew(j) 上执行。</p><p>举例说明：在结点4上的特定机器的智能体图G(4)就是在结点8，9，10，11和12上特定任务的智能体图的并集。因此，我们可以通过移除结点7以及跟他相关的边来得到智能体图G(4).</p><h3 id="Feature-extraction"><a href="#Feature-extraction" class="headerlink" title="Feature extraction"></a>Feature extraction</h3><p>有两种动作，供两类智能体使用。一个同机器相关的智能体的动作就是在它的本地等待执行队列里选取一个任务来执行。同任务相关的智能体的动作就是在一系列的机器中选择一个机器，将它的下一个等待执行的operation放进这个机器对应的本地等待执行队列中。换言之，机器和工作的可交换性构成了两类智能体的状态和动作。因此，机器和作业的特征对于这些智能体人做出决定很重要。</p><p>**Basic features.**我们强调一些已知的基本特征，包括机器 m 的生产率 $p_m$ 和作业 j 在操作 k 的工作量 $q_{j,k}$ 。为了表述方便，我们还用 $q_j$ 表示作业 j 在当前操作的工作量，用 $q_{j,m}$ 表示作业 j 在机器 m 上的工作量，因为当前操作或机器 m 表示一个确定的操作 k，它可以很容易推断出来。此外，设 $x_{j,m}$ 为作业 j 在机器 m 上在当前时间步完成的工作量。则剩余工作量为 $y_{j,m} &#x3D; q_{j,m} − x_{j,m}$。除了这些基本特征外，DeepMAG 还根据 4.2 节中定义的多智能体图提取机器和作业的特征。</p><h4 id="Machine-centric-features"><a href="#Machine-centric-features" class="headerlink" title="Machine-centric features"></a>Machine-centric features</h4><p>在不失一般性的情况下，我们关注机器 m 的特性，其关联智能体负责作业排序，当机器可用时，它会从等待队列中选择一个作业进行处理。</p><p><strong>Four types of machine-centric static relationships</strong></p><p>我们在机器m和其他机器之间定义了四种静态关系。</p><p>父集合由拥有从m’指向m的有向边的每个机器m’组成。它的含义就是m’可能会发送任务的下一个operation给m。</p><p>$M_e(m) &#x3D; {m’|m’ \in M \and (m’ \rightarrow m}\ \ \ \ \ \ \ (12)$</p><p>子集合由拥有从m指向m’的有向边的每个机器m‘组成。它的含义就是m’可能会接受来自机器m的job的operation。</p><p>$M_d(m) &#x3D; {m’|m’ \in  M \and (m \rightarrow m’)}\ \ \ \ \ \ \ \ \ (13)$</p><p>双亲集合是由至少与机器m‘拥有一个公共孩子的机器m的集合。它的含义就是机器m与机器 m’在普通孩子的资源上为竞争关系。</p><p>$M_c(m) &#x3D; {m’|m’ \in M \and (M_d(m’) \cap M_d(m) \neq \emptyset} \ \ \ \ \ (14)$</p><p>兄弟集由每台机器 m’ 组成，这些机器至少有一个与 m 有共同的父代。它的含义就是与机器 m 合作完成共同父结点上即将发送来的的工作。</p><p>$M_b(m) &#x3D; {m’|m’ \in M \and (M_e(m’) \cap M_e(m)\neq \emptyset}\ \ \ \ \ (15)$</p><p>以图3来说明刚才定义的四种静态关系。$M_e(4) &#x3D; {1, 2}, M_d(4) &#x3D; {5, 6}, M_c (4) &#x3D; {3} , M_b(4) &#x3D; {3}$ 在节点4上。</p><p><strong>Two types of machine-centric dynamic relationships</strong></p><p>接着，我们定义了在机器m和任务之间在一个时间步的两种动态关系。</p><p>正在执行的集合由拥有无向边(j,m)的job j组成。需要注意的是由于exclusion constraint的存在，在每一个时间步，$J_u(m)$至多拥有一个任务。</p><p>$J_u(m) &#x3D; {j|j \in J \and (j,m} \ \ \ \ \ \ (16)$</p><p>正在等待执行的任务集合由拥有从j到m的有向边的job j组成。这个集合中的job将通过在未来消耗一定的时间的方式为机器m带来负担。</p><p>$J_w(m) &#x3D; {j|j \in J \and (j \rightarrow m} \ \ \ \ \ \ (17)$</p><p>在图3中，这两种动态关系的举例如下：对于结点4，$J_u(4) &#x3D;{12}, J_w(4) &#x3D; {10,11}$。</p><p><strong>Seven types of machine-centric numeric features.</strong></p><p>基于机器的静态和动态提取一些数量特征。</p><p>具有不同关系的机器的数量（或度（入度出度））的特征 $f_{deg}$ 由下式给出：</p><p>$f_{deg}(m) &#x3D; [|M_{(.)}(m)|] \ \ \ \ \ \ (18)$</p><p>其中的[]表示一个向量聚合，(.)是从式12到式15得到的b,c,d和e的集合，后文的式子中的符号也是如此表示。</p><p>在生产力值的总和上的特征$f_{prod}$由下式给出：</p><p>$f_{prod}(m) &#x3D; [\sum_{m’\in M(.)(m)}p_{m’}] \ \ \ \ \ \ \ \ \ \ \ (19)$</p><p>在正在执行的任务的数量特征$f_{exe}(m)$由下式给出：</p><p>$f_{exe}(m) &#x3D; [|J_u(m)|, \sum_{m’ \in M(.)(m)}|J_u(m’)|] \ \ \ \ \ \ \ \ \ (20)$</p><p>它们相应的已完成和剩余工作量的总和由下式给出:</p><p>$f_{exe}^{finish}(m) &#x3D; [\sum_{m’ \in M(.)(m)} \sum_{j \in J_u(m’)}x_{j, m’}]\ \ \ \ \ \ \ \ (21)$</p><p>$f_{exe}^{remain}(m) &#x3D; [\sum_{m’ \in M(.)(m)} \sum_{j \in J_u(m’)}y_{j, m’}]\ \ \ \ \ \ \ \ (22)$</p><p>相对的，正在等待的任务的数量特征$f_{wait}(m)$由下式给出：</p><p>$f_{wait}(m) &#x3D; [|J_w(m)|, \sum_{m’ \in M_{(.)}(m)}|J_w(m’)|] \ \ \ \ \ \ (23)$</p><p>它的负载数量由下式给出：</p><p>$f_{wait}^{qty}(m) &#x3D; [\sum_{j \in J_w(m)}q_{j, m}, \sum_{m’ \in M_{(.)}(m)}\sum_{j\in J_w(m’)q_{j,m’}}] \ \ \ \ \ \ (24)$</p><p>这些特征表示在机器m周围复杂的环境，并且它们对与机器相关的智能体决策很重要。</p><h4 id="Job-centric-features"><a href="#Job-centric-features" class="headerlink" title="Job-centric features"></a>Job-centric features</h4><p>在不失一般性的情况下，我们通过选择一台机器来处理作业的下一个操作来关注作业 j 的特征，其关联智能体已准备好进行作业路由。</p><p><strong>Three types of job-centric dynamic relationships.</strong></p><p>我们定义了三种在任务j和机器m之间的动态关系。</p><p>路由机器集合$M_v(j)$由从机器m指向任务j的有向边的机器m组成，它能够为下一个操作处理作业 j。</p><p>$M_v(j) &#x3D; {m|m \in M \and(m \rightarrow j)} \ \ \ \ \ (25)$</p><p>拥有相同的路由机器的任务j’的路由任务集合$J_v(j)$由下式表示，它与相同路由机器上的作业j竞争。</p><p>$J_v(j) &#x3D; {j’|j’ \in J \and (M_v(j’)\cap M_v(j)\neq \emptyset} \ \ \ \ \ \ (26)$</p><p>任务j的祖先集合$J_g(j)$是拥有到job j的路径的所有job $j’ \in J$的集合，式子中的虚线箭头表示一条路径，它是具有无向边$(j′, m_1)$ 或有向边 $j′ → m_1$，有向边 $m_l → m_{l+1}$ 的不同节点序列$(j’, m_1, . . . , m_n, j)$ 以及$m_n → j (l &#x3D; 1, . . ., n−1)$。</p><p>$J_g(j) &#x3D; {j’|j’ \dashrightarrow j} \ \ \ \ \ \ \ \ (27)$</p><p>祖先结点将会在未来对任务j的路由机器$m_n$带来负载。例如，在图3中，结点8上的$M_v(8) &#x3D; {5,6}, J_v(8) &#x3D; {9},J_g(8) &#x3D; {7,10,11,12}$.</p><p><strong>Four types of job-centric numeric features.</strong></p><p>我们基于任务j的路由任务集合$J_v(j)$和祖先集合$J_g(j)$提取了四种数量特征。</p><p>和任务j有不同关系的任务数量$f_{num}$由下式表示，其中[]表示一个向量聚合，(.)由式26，27得到的v和g来设定，之后的符号也是这样的含义。</p><p>$f_{num}(j) &#x3D; [|J_{(.)}(j)|]\ \ \ \ \ \ \ (28)$</p><p>这些任务的负载上的三个统计量由下式表示：</p><p>$f_{sum}(j) &#x3D; [\sum_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ (29)$</p><p>$f_{max}(j) &#x3D; [max_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ \ \ (30)$</p><p>$f_{min}(j) &#x3D; [min_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ \ \ (31)$</p><p>任务j的复杂环境由这些特征表示，这些特征在同任务相关的智能体采取最优动作时有重要作用。</p><h3 id="Representations-of-states-and-actions"><a href="#Representations-of-states-and-actions" class="headerlink" title="Representations of states and actions"></a>Representations of states and actions</h3><p>在FJSS的大型状态空间中，将每个状态表示为标识符并学习每个状态的每个动作的状态-动作值是不可行的，就像在经典的 Q-learning 算法中一样。我们的DeepMAG通过代表状态和动作作为4.3节描述的一系列特征去估计状态动作值函数$\mathbb Q(s_i,a_i)$。机器相关和任务相关的智能体拥有不同的表示。</p><h4 id="Machine-associated-agents"><a href="#Machine-associated-agents" class="headerlink" title="Machine-associated agents"></a>Machine-associated agents</h4><p>让同机器有关的智能体$i&#x3D;m\in M$处于可用状态（用式16表示的话就是$J_u(m) &#x3D; \emptyset$），并且在一个时间步有一个正在等待的任务集合$J_w(m)$（由式17表示）。状态$s_i$应该反映智能体的特征和周围环境以及应该能够使每一个动作$a_i&#x3D;J\in J_w(m)$同其他动作区分开。</p><p>**State representations.**状态由向量$s_i$表示，它通过链接生产力$p_m$以及其中机器独有的数量特征（由式18～24表示）。此外，这些从式18～24提取出的向量是由定义4.1得到的多智能体图以及定义4.4的特定机器智能体图$g(m)$提取出来的.所有提取的特征对于智能体i或者机器m都是非常特别的，它们中的大多数都是依赖机器同相邻机器以及任务之间的关系。因此，智能体可以通过观察不同的状态来和其他的智能体合作去做出动作。</p><p>**Action representations.**一个可能的动作$a_i&#x3D;j\in J_w(m)$被表示为一个向量$a_i$，这个向量是由基于定义4.3得到的特定任务的智能体图得到的工作数量$q_{j,m}$和由式18到24得到的七种以机器为中心的数量特征。所有的这些特征对于正在等待的任务j来说是特别的，并且不同于其他的任务或者正在等待的任务。值得注意的是四种以任务为中心的数量特征不适用于提取任务j的特征，因为根据式25，在机器m上等待的任务j以及它的路由机器集合式空的。</p><h4 id="Job-associated-agents"><a href="#Job-associated-agents" class="headerlink" title="Job-associated agents"></a>Job-associated agents</h4><p>相反，假设一个与工作相关的智能体 i &#x3D; j ∈ J 准备就绪并且在一个时间步,由式25得知它中有一个路由机器集 $M_v(j)$。类似地，需要用任务 j 自身和周围的特征来表示状态 $s_j$，并表征每个可能的动作 $a_i &#x3D; m ∈ M_v(j)$。</p><p>**State representations.**由一个向量$s_i$组成状态$s_i$，这个向量是通过将工作数量$q_j$和通过式28到31的四种以任务为中心的数量特征表示。这些特征由任务j和其他任务在多智能体图以及特定任务图之间提取得出。所有的特征依赖智能体i或者任务j，但是他的任何动作都是独立的。</p><p>**Action representations.**一个候选动作$a_i&#x3D;m\in M_v(j)$由一个向量$a_i$表示，它通过将生产力$p_m$和七种类型的以机器为中心的数量特征，这些特征由多智能体图，特定任务的智能体图以及特定机器的智能体图得到。需要注意，等式18到24的定义是基于机器m，而不是这些种类的智能体图。</p><p>总的来说，无论什么样的智能体，表现出的状态或者动作都包含他们独特特征以及周围特征。接下来，这些智能体就能够一同工作以发现一个最优的连续动作(optimail joint action)。</p><h3 id="Learning-on-DQNs"><a href="#Learning-on-DQNs" class="headerlink" title="Learning on DQNs"></a>Learning on DQNs</h3><p>与单独的智能体分别学习各自的DQN的简单方法不同，DeepMAG为每一种做出不同动作的智能体学习一个DQN以降低成本，增加可扩展性并且能够去改变FJSS环境中的智能体个数。所有同机器相关的智能体共享一个DQN，它们在相应的机器到达可用状态时做出任务排序的动作。所有同任务相关的智能体共享另一个DQN，它们在机器现有的操作结束时，选择一个符合条件的机器去进行它的下一个操作。此外，两个DQN拥有同样的学习算法，比如deep Q-learning，只是在状态和动作上拥有不同的输入。deep Q-learning基于经验回放，他的目标是估计状态动作值函数$\mathbb Q(s_i, a_i)$.通常这种函数被建模为深度神经网络（如DQN）。智能体的经验就是根据马尔可夫过程将得到的$(s_i,a_i,s_i’,r)$进行存储。在学习过程中，Q-learning更新被应用在经验的mini-batches上。Q-learning的更新使用如下的损失函数:</p><p>$\mathbb L(\theta_n) &#x3D; \mathbb E[\left(r + \gamma \ max_{a’_i\in A_i}\hat{\mathbb Q}(s_i’,a_i’|\hat \theta_n) - \hat{\mathbb Q}(s_i, a_i|\theta_n)\right)^2 ] \ \ \ \ \ \ \ (32)$</p><p>其中$\gamma$是折扣率，$\theta_n$是DQN的参数。$\hat \theta_n$是用来计算目标的参数。目标网络的参数只有每N步才会进行更新。参数$\theta_n$由随机梯度下降算法进行学习。</p><h3 id="Training-optimization"><a href="#Training-optimization" class="headerlink" title="Training optimization"></a>Training optimization</h3><p>标准的深度 Q 学习算法是无模型的，它通过直接使用来自模拟器的样本训练 DQN 来估计方程式中的值函数 Q(si, ai)。 （4），而不是等式 (1)中的条件概率质量函数 P（s’，r | s，a）。通过学习等式中的贪心策略 a∗ i &#x3D; π (si) 也是一种off-policy。 (5) 同时遵循确保对状态空间进行充分探索的行为分布。在实践中，行为分布通常由 ε-greedy policy 确定，该 ε-greedy policy 遵循概率为 1−ε 的贪婪策略并选择概率为 ε 的随机动作。 DeepMAG 将此算法扩展到多智能体系统，如算法 1 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230531161425827.png" alt="image-20230531161425827" loading="lazy"></p><p>在FJSS环境中，智能体的动作次序是重要的，这对他们知道其他智能体的表现以及互相合作很重要。所以，同任务相关的智能体的动作应该先进行执行，以确保在机器的等待执行队列中有已经被路由去的待执行任务的操作存在。此外，应该根据任务和机器的工作量数量递减排序，因为有大的负载的任务或者机器都对makespan有着很大的影响， 需要更多的关注。最后，两种智能体使用算法2去学习他们自己的DQN。</p><p><img src="http://cdn.leafii.top/img/image-20230531162203905.png" alt="image-20230531162203905" loading="lazy"></p><p>**Computational complexity.**略</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>在5.1定义了实验设置，在5.2分析了实验结果。</p><h3 id="Experimental-setting"><a href="#Experimental-setting" class="headerlink" title="Experimental setting"></a>Experimental setting</h3><h4 id="Emulated-data"><a href="#Emulated-data" class="headerlink" title="Emulated data"></a>Emulated data</h4><p>模拟了在现实世界工厂里用63，50，35，34个机器实现四个有序操作的场景。他们的生产力范围从每小时2400到8400不等。有四种任务，每一种都有一个相等的关系，也就是这些拥有相同类型的任务是相等的，并且构成了相等的类。每种任务在每一个操作上有固定的机器集合，这些数据在表2中被展示。需要注意的是这些数据都是真实工厂中的数据。</p><p><img src="http://cdn.leafii.top/img/image-20230531163034639.png" alt="image-20230531163034639" loading="lazy"></p><p>为了训练DQN，在每一个episode的开始，我们通过均匀分布得到机器U(16,64),任务的数量$|J|\sim U(10, 100)$来生成FJSS实例。每个人物和负载的数量$q \sim U(1,4) \times 10,000$。这些均匀分布是根据现实世界工厂的离散的值，请注意，机器 M 是从给定的常量机器集中为 J 中的每对作业类型和操作挑选的。 DQN 在 10,000 个实例上进行训练并在三个场景中进行测试。每个场景包含 100 个具有相同作业数量（即 20、60 和 100）的不同实例，并取这 100 个实例的平均性能。</p><h4 id="Evaluated-methods"><a href="#Evaluated-methods" class="headerlink" title="Evaluated methods"></a>Evaluated methods</h4><p>我们将提出的DeepMAG同竞争的分发规则，因为其他的方法对于JSS或者FJSS来说没有可扩展性。大多数现有的方法只能解决少于20个机器或者任务。尽管RL方法可以处理大量的机器或者任务，但没有现有的工作用语FJSS。我们开发了四种复合调度方法。</p><ul><li>$J_W M_{max}$：作业关联智能体选择剩余工作量最小的机器，机器关联智能体选择工作负载最大的作业。</li><li>$J_T M_{max}$：与作业相关的智能体选择剩余处理时间最少的机器，与机器相关的智能体选择工作量最大的作业。</li><li>$J_W M_{min}$：作业关联智能体选择剩余工作量最小的机器，机器关联智能体选择工作负载最小的作业。</li><li>$J_T M_{min}$：与作业相关的智能体选择剩余处理时间最少的机器，与机器相关的智能体选择工作量最小的作业。</li></ul><p>四个复合调度规则始终将较高的优先级分配给负担较低的机器，即与作业相关的智能体的最小剩余工作量或处理时间。选择负担很重的机器显然是不合适的，这会成为制造时间的瓶颈。此外，这些规则总是根据作业的工作量为机器相关智能体选择作业，因为工作量与机器上的处理时间成正比，即工作量和处理时间都会导致相同的结果。</p><h4 id="Performance-metrics"><a href="#Performance-metrics" class="headerlink" title="Performance metrics"></a>Performance metrics</h4><p>为了比较 FJSS 上评估方法的性能，我们采用标准指标，即完成所有作业的时间步长总数。请注意，我们报告了每个场景中具有相同作业数量的 100 个测试实例的平均完工时间。</p><h4 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h4><p>我们的实验平台是一个计算服务器，配备 Interl(R) Xeon (R) CPU E5-2699 v4 2.20 GHz 和 Nvidia V100 GPU (16 GB)。 OpenAI 的 Gym 和谷歌的 TensorFlow 是分别用于强化学习和深度学习的开源软件库。我们基于Gym 0.17.3 实现了FJSS 环境，通过指定环境与agent 交互的标准接口。我们基于 TensorFlow 1.14 使用 DQN 实现智能体。每个 DQN 都是一个多层感知器，其中隐藏层数设置为三层，三层神经元数设置为 64、32 和 16。折扣率设置为 γ &#x3D; 0.9，ε-greedy探索从开始时的 ε &#x3D; 1 衰减到结束时的 ε &#x3D; 0.05。为了适应 FJSS 中具有不同机器和作业分布的各种环境，我们根据训练实例估计了预期的转换和步骤总数。然后，重放内存大小 |D|由与转换总数的比率（默认为 0.25）确定，而目标网络更新频率 N 是通过将总步数除以更新次数（默认为 10）来计算的。我们基于 Adam 优化器训练两个 DQN，批量大小为 64，学习率为 0.0001。</p><h3 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h3><h4 id="Method-comparison"><a href="#Method-comparison" class="headerlink" title="Method comparison"></a>Method comparison</h4><p>表 3 比较了三种不同场景下所有评估方法的完工时间。我们可以得出以下三个重要发现。 (1) 我们的 DeepMAG 始终在所有三种场景中实现最佳性能，包括小型、中型和大量作业。与第二好的相反，根据 JT Mmax 给出的性能，DeepMAG 平均将完工时间缩短了 3.6%。这些结果证明了 DeepMAG 对于具有大搜索空间的 FJSS 的有效性，因为它充分利用了 DRL 和 MARL 之间的集成以及智能体在根据机器和作业之间的操作关系构建的各种图中的合作。 (2) JT Mmax 优于其他评估的调度规则，因为在 JT Mmax 中，作业相关智能体根据其处理时间而不是工作量来选择机器，以考虑其生产力的影响。此外，在 JT Mmax 中，与机器相关的智能体通过选择具有最大工作负载而不是最小工作负载的作业来更加关注具有较大工作负载的作业以减少完工时间，其中具有大工作负载的作业主导完工时间。 (3) 相比之下，JW Mmin 在所有三种情况下始终记录最长的 makespan，因为它根据工作量选择机器而不考虑机器生产率，并通过更多地关注工作量小的工作来选择工作。</p><p><img src="http://cdn.leafii.top/img/image-20230531171254007.png" alt="image-20230531171254007" loading="lazy"></p><h4 id="Effect-of-replay-memory-ratios"><a href="#Effect-of-replay-memory-ratios" class="headerlink" title="Effect of replay memory ratios"></a>Effect of replay memory ratios</h4><p>图 4 描绘了不同重放内存比率对 DeepMAG 上预期转换总数的影响，其中该比率与重放内存大小 |D| 成正比。重放内存比率对完工时间的影响很小。由于这三种场景的预期转换总数很大，因此较小的比率会在回放内存中贡献足够的转换，以减轻观察序列中的相关性并平滑模拟数据中的变化，从而解决 DRL 中的不稳定性（甚至发散）和 MARL 在某种程度上。尽管较大的比率提供了更多的回放转换以进一步减少不稳定性，但更多的历史转换会降低学习效率并抵消对不稳定性的改进。在实践中，采用较小的比率来节省内存成本，例如，在我们的实验中默认为 0.25。</p><p><img src="http://cdn.leafii.top/img/image-20230531171419329.png" alt="image-20230531171419329" loading="lazy"></p><h4 id="Effect-of-target-network-update-times"><a href="#Effect-of-target-network-update-times" class="headerlink" title="Effect of target network update times"></a>Effect of target network update times</h4><p>图 5 显示了 DeepMAG 中目标网络更新次数的影响，即目标网络在整个训练过程中更新了多少次。最好的结果是更新目标网络 10 次。当更新时间从 10 次减少到 5 次时，性能变差；原因是目标网络更新太慢，Eq.中的估计目标值。 (32) 经常过时。相反，随着更新时间从 10 次增加到 80 次，性能也变得更差；这个结果是由于状态-动作值和目标值之间的相关性导致的不稳定性增加造成的。因此，应该使用适当数量的目标网络更新次数来平衡不稳定性和过时的目标值。</p><p><img src="http://cdn.leafii.top/img/image-20230531171452175.png" alt="image-20230531171452175" loading="lazy"></p><h4 id="Effect-of-neuron-numbers"><a href="#Effect-of-neuron-numbers" class="headerlink" title="Effect of neuron numbers"></a>Effect of neuron numbers</h4><p>图 6 描绘了关于改变 DQN 的第一个隐藏层中的神经元数量的影响，其中每个连续的隐藏层在前一个隐藏层中具有一半数量的神经元。具有 32 个神经元的设置产生最差的性能，因为神经元数量少导致 FJSS 学习模型的表达力非常有限。当神经元数量从 32 个增加到 64 个时，性能显着提高。原因是模型的表达能力增强了，有利于发现各种状态下更好的动作。随着神经元数量从 64 变为 128，makespan 变长了一点，因为学习的模型可能会出现过度拟合数据的问题。在实践中，应采用适度的神经元数来平衡模型的表达性、泛化性、专业化和计算成本，包括 CPU 时间和内存使用。</p><p><img src="http://cdn.leafii.top/img/image-20230531171525518.png" alt="image-20230531171525518" loading="lazy"></p><h4 id="Convergence-analysis"><a href="#Convergence-analysis" class="headerlink" title="Convergence analysis"></a>Convergence analysis</h4><p>图 7 分别说明了 DeepMAG 在具有 20、60 和 100 个作业的三个测试场景中的奖励曲线，其中 x 轴是训练集的数量，y 轴是 100 个测试实例的平均奖励，如前所述在第 5.1.1 节中。从图.图.从图7可以看出，一开始曲线波动较大，因为DeepMAG的模型参数更新很大。重要的是，在大约 7,000 次训练后，这些曲线收敛到与时间步数相反的接近最大的奖励。这种收敛特性使 DeepMAG 能够在真实的制造工厂中学习 FJSS 的可行解决方案。</p><p><img src="http://cdn.leafii.top/img/image-20230531171559090.png" alt="image-20230531171559090" loading="lazy"></p><h2 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h2><p>在本文中，我们形式化了灵活的作业车间调度（FJSS）问题，包括基于作业排序和路由的基于马尔可夫决策过程的框架，并据此定义了 FJSS 中的环境、智能体、状态、动作和奖励五个重要概念。然后，我们提出了一种基于 DRL 的 FJSS 新模型 DeepMAG，该模型具有多智能体图，该图是根据机器和作业之间的操作关系构建的，即机器的操作顺序和可以处理的作业的可能操作。 DeepMAG 将 DRL 与 MARL 相结合，解决了 FJSS 在状态和动作上空间过大的问题。一方面，DeepMAG 利用两个 DQN 分别为机器相关智能体的作业排序和作业相关智能体的作业路由找到最佳操作。另一方面，DeepMAG 利用各种多智能体图使每个智能体能够与其相邻智能体合作并采取一个合作行动。最后，仿真实验结果表明，与其他最先进的方法相比，DeepMAG 在 FJSS 的三种场景下实现了最佳性能。</p><p>将来，我们将考虑更先进的方法作为基线，例如，通过升级基于启发式的方法以适应大量机器和作业。本文重点研究静态 FJSS 问题，而一些动态事件，如机器故障、新工作插入和工作取消，在现实世界的制造环境中是不可避免的。因此，在 FJSS 中结合动态事件的特征来设计方法是我们未来的研究方向之一。</p><h2 id="Data-availability"><a href="#Data-availability" class="headerlink" title="Data availability"></a>Data availability</h2><p>作者无权共享数据。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling&quot;&gt;&lt;a href=&quot;#DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling&quot; class=&quot;headerlink&quot; title=&quot;DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling&quot;&gt;&lt;/a&gt;DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;一般的柔性车间调度执行基于两个决策步骤：任务次序（比如在一个机器上任务的执行顺序）以及任务路由（比如一个任务到一个机器的路径）。大多数现有的研究利用DRL或者MARL在大的搜索空间进行调度。&lt;strong&gt;但是&lt;/strong&gt;这些研究有两个主要的限制：在DRL和MARL之间没有进行结合，独立的智能体之间没有合作。DeepMAG有两个关键贡献：1. DRL和MARL之间的结合。DeepMAG 通过将不同的智能体与每台机器和作业相关联，将 DRL 与 MARL 集成。每个智能体都利用 DRL 来找到有关作业排序和路由的最佳操作。在作业关联智能体选择最佳机器后，该作业成为机器进行下一个操作的作业候选者，而机器关联智能体从其作业候选集中选择下一个作业进行处理。2. 合作智能体。基于机器和作业之间的操作关系构建多智能体图。一个智能体与其相邻的智能体合作采取一个合作行动。最后，我们进行实验来评估 DeepMAG 的性能，实验结果表明它优于最先进的技术。&lt;/p&gt;</summary>
    
    
    
    
    <category term="知识图谱" scheme="tags/知识图谱/"/>
    
    <category term="车间调度" scheme="tags/车间调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode98.验证二叉搜索树</title>
    <link href="2023/05/31/leetcode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>2023/05/31/leetcode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2023-05-31T06:11:21.000Z</published>
    <updated>2023-05-31T06:28:58.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1-20230531141156695.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [2,1,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/tree2-20230531141159669.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>基于限定值的递归判断</li></ul><p>思路如下：对每一个需要被判断的节点，都为他设置一个最大值和最小值（防止子树的子树不符合搜索树条件），根节点的最大最小值是C++ longlong类型的最大最小值，之后判断左子树时，最大值变更为根节点的值，判断右子树时，最小值变为根节点的值，在判断节点时，若节点为空，则该子树是有效的二叉搜索树，否则就检查当前节点的值是否在minVal到maxVal的范围内。最后递归的验证左子树和右子树。C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 辅助函数，用于验证给定的子树是否为有效的二叉搜索树    bool isValidBSTHelper(TreeNode* node, long long minVal, long long maxVal) &#123;        &#x2F;&#x2F; 如果节点为空，则表示该子树是有效的二叉搜索树        if (node &#x3D;&#x3D; NULL)            return true;                &#x2F;&#x2F; 检查当前节点的值是否在[minVal, maxVal]的范围内        if (node-&gt;val &lt;&#x3D; minVal || node-&gt;val &gt;&#x3D; maxVal)            return false;                &#x2F;&#x2F; 递归验证左子树和右子树        return isValidBSTHelper(node-&gt;left, minVal, node-&gt;val) &amp;&amp;            isValidBSTHelper(node-&gt;right, node-&gt;val, maxVal);    &#125;    bool isValidBST(TreeNode* root) &#123;        &#x2F;&#x2F; 由于题目中未指定树节点的值的范围，所以我们使用长整型的最小值和最大值作为初始范围        long long minVal &#x3D; LLONG_MIN;        long long maxVal &#x3D; LLONG_MAX;                &#x2F;&#x2F; 调用辅助函数进行验证        return isValidBSTHelper(root, minVal, maxVal);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效&lt;/strong&gt; 二叉搜索树定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的左子树只包含 &lt;strong&gt;小于&lt;/strong&gt; 当前节点的数。&lt;/li&gt;
&lt;li&gt;节点的右子树只包含 &lt;strong&gt;大于&lt;/strong&gt; 当前节点的数。&lt;/li&gt;
&lt;li&gt;所有左子树和右子树自身必须也是二叉搜索树。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode617.合并二叉树</title>
    <link href="2023/05/30/leetcode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/05/30/leetcode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-05-29T23:49:07.000Z</published>
    <updated>2023-05-29T23:55:24.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/merge.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root1 &#x3D; [1], root2 &#x3D; [1,2]输出：[2,2]</code></pre><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>通过深度优先遍历进行合并</li></ol><p>如果有树为空，则直接返回另一个树；若两树都不为空，则新建一个节点，将对应的结点的值进行求和，递归调用函数，最终返回根结点。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        &#x2F;&#x2F; 如果其中一个树为空，我们可以直接返回另一个树作为合并后的结果        if (root1 &#x3D;&#x3D; nullptr) &#123;            return root2;        &#125;        if (root2 &#x3D;&#x3D; nullptr) &#123;            return root1;        &#125;                &#x2F;&#x2F; 创建一个新节点，值为两个树当前节点值的和        TreeNode *merged &#x3D; new TreeNode(root1-&gt;val + root2-&gt;val);                &#x2F;&#x2F; 递归地合并左子树和右子树        merged-&gt;left &#x3D; mergeTrees(root1-&gt;left, root2-&gt;left);        merged-&gt;right &#x3D; mergeTrees(root1-&gt;right, root2-&gt;right);                &#x2F;&#x2F; 返回合并后的树        return merged;    &#125;&#125;;</code></pre><ol start="2"><li>通过广度优先遍历实现合并</li></ol><p>我们使用三个队列，<code>q</code>用于存储合并后的树节点，<code>q1</code>和<code>q2</code>分别用于存储两棵输入树的节点。</p><p>在每一轮循环中，我们弹出<code>q</code>、<code>q1</code>和<code>q2</code>的队首元素，分别表示合并后的树的当前节点、第一棵树的当前节点和第二棵树的当前节点。</p><p>然后，我们获取当前节点的左子节点和右子节点，并根据情况进行处理。</p><ul><li>如果两棵树的左子节点都存在，我们创建一个合并后的左子节点，值为两个树的左子节点值之和，并将其连接到合并后的树的当前节点的左侧。同时，我们将合并后的左子节点、第一棵树的左子节点和第二棵树的左子节点分别入队列<code>q</code>、<code>q1</code>和<code>q2</code>中。</li><li>如果只有第一棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li><li>如果只有第二棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li></ul><p>对于右子节点，我们执行类似的逻辑。</p><p>最终，当队列<code>q1</code>和<code>q2</code>都为空时，表示已经遍历完两棵树的所有节点，此时合并过程完成，我们返回合并后的树的根节点。</p><p>这样，使用广度优先遍历的方式，我们可以合并两棵二叉树并返回合并后的结果。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> t1<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 如果其中一个树为空，直接返回另一个树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 创建一个新的节点，值为两个树当前节点值的和</span>        TreeNode<span class="token operator">*</span> merged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>t1<span class="token operator">-></span>val <span class="token operator">+</span> t2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 使用队列存储节点，初始时将根节点入队列</span>        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>merged<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q1<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q2<span class="token punctuation">;</span>        q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>        q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>q2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 弹出当前节点以及对应的两个输入树的节点</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> node1 <span class="token operator">=</span> q1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> node2 <span class="token operator">=</span> q2<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 获取当前节点的左子节点和右子节点</span>            TreeNode<span class="token operator">*</span> left1 <span class="token operator">=</span> node1<span class="token operator">-></span>left<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> left2 <span class="token operator">=</span> node2<span class="token operator">-></span>left<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> right1 <span class="token operator">=</span> node1<span class="token operator">-></span>right<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> right2 <span class="token operator">=</span> node2<span class="token operator">-></span>right<span class="token punctuation">;</span>                      <span class="token comment">// 处理左子节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> left2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>left1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> left2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果两棵树的左子节点都存在，创建合并后的左子节点，并入队列</span>                    TreeNode<span class="token operator">*</span> leftMerged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>left1<span class="token operator">-></span>val <span class="token operator">+</span> left2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node<span class="token operator">-></span>left <span class="token operator">=</span> leftMerged<span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftMerged<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第一棵树的左子节点存在，直接使用该节点</span>                    node<span class="token operator">-></span>left <span class="token operator">=</span> left1<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第二棵树的左子节点存在，直接使用该节点</span>                    node<span class="token operator">-></span>left <span class="token operator">=</span> left2<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>                      <span class="token comment">// 处理右子节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> right2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> right2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果两棵树的右子节点都存在，创建合并后的右子节点，并入队列</span>                    TreeNode<span class="token operator">*</span> rightMerged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>right1<span class="token operator">-></span>val <span class="token operator">+</span> right2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node<span class="token operator">-></span>right <span class="token operator">=</span> rightMerged<span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightMerged<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第一棵树的右子节点存在，直接使用该节点</span>                    node<span class="token operator">-></span>right <span class="token operator">=</span> right1<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第二棵树的右子节点存在</span>                    node<span class="token operator">-></span>right <span class="token operator">=</span> right2<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>              <span class="token comment">// 返回合并后的树</span>        <span class="token keyword">return</span> merged<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两棵二叉树： &lt;code&gt;root1&lt;/code&gt; 和 &lt;code&gt;root2&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，&lt;strong&gt;不为&lt;/strong&gt; null 的节点将直接作为新二叉树的节点。&lt;/p&gt;
&lt;p&gt;返回合并后的二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 合并过程必须从两个树的根节点开始。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode700.二叉搜索树中的搜索</title>
    <link href="2023/05/29/leetcode700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
    <id>2023/05/29/leetcode700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</id>
    <published>2023-05-29T07:09:15.000Z</published>
    <updated>2023-05-29T07:13:35.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><span id="more"></span> <p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2输出：[2,1,3]</code></pre><p><strong>示例 2:</strong></p><p><img src="http://cdn.leafii.top/img/tree2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>数中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接搜索</li></ul><p>在二叉搜索树中，每个节点的值大于其左子树中的所有节点的值，小于其右子树中的所有节点的值，因此可以利用这个性质进行查找操作。你的方法通过迭代方式在二叉搜索树中查找给定值，并返回匹配的节点指针。这种查找方式通常称为”二叉搜索树的查找”或”BST查找”。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* searchBST(TreeNode* root, int val) &#123;        while (root !&#x3D; nullptr) &#123; &#x2F;&#x2F; 在root非空的情况下进行循环            if (val &#x3D;&#x3D; root-&gt;val) &#123;                return root; &#x2F;&#x2F; 如果值匹配就直接返回root            &#125;            else if (val &gt; root-&gt;val) &#123;                root &#x3D; root-&gt;right; &#x2F;&#x2F; 如果值大于root现有的值，它的目标节点只有可能在他的右子树            &#125;            else &#123;                root &#x3D; root-&gt;left; &#x2F;&#x2F; 如果值小于root现有的值，它的目标节点只有可能在他的左子树            &#125;        &#125;        return nullptr; &#x2F;&#x2F; 如果root为空（不管是现有的root还是迭代后的root） 就直接返回nullptr    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定二叉搜索树（BST）的根节点 &lt;code&gt;root&lt;/code&gt; 和一个整数值 &lt;code&gt;val&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你需要在 BST 中找到节点值等于 &lt;code&gt;val&lt;/code&gt; 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode188.买卖股票的最佳时机IV</title>
    <link href="2023/05/24/leetcode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/"/>
    <id>2023/05/24/leetcode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/</id>
    <published>2023-05-24T08:54:22.000Z</published>
    <updated>2023-05-24T08:54:54.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：k &#x3D; 2, prices &#x3D; [2,4,1]输出：2解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 100</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用buy和sale数组进行动态规划，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数），sale[i] 表示进行第 i 次卖出操作后的最大利润，代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;        int n &#x3D; prices.size();        vector&lt;int&gt; buy(k, -prices[0]); &#x2F;&#x2F; 定义买入的数组，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数）        vector&lt;int&gt; sale(k); &#x2F;&#x2F; 定义卖出的数组，sale[i] 表示进行第 i 次卖出操作后的最大利润        for(int i &#x3D; 1; i &lt; n; ++i) &#123;            buy[0] &#x3D; max(buy[0], -prices[i]); &#x2F;&#x2F; 更新第一次买入的最大利润，取当前买入的最大利润和前一天的最大利润中较大的值            sale[0] &#x3D; max(sale[0], prices[i] + buy[0]); &#x2F;&#x2F; 更新第一次卖出的最大利润，取当前卖出的最大利润和前一天的最大利润加上当前股票价格的较大值            for(int j &#x3D; 1; j &lt; k; ++j) &#123;                buy[j] &#x3D; max(buy[j], sale[j - 1] - prices[i]); &#x2F;&#x2F; 更新第 j 次买入的最大利润，取当前买入的最大利润和前一次卖出的最大利润减去当前股票价格的较大值                sale[j] &#x3D; max(sale[j], buy[j] + prices[i]); &#x2F;&#x2F; 更新第 j 次卖出的最大利润，取当前卖出的最大利润和当前买入的最大利润加上当前股票价格的较大值            &#125;        &#125;        return sale[k - 1]; &#x2F;&#x2F; 返回最后一次卖出的最大利润    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;prices&lt;/code&gt; ，它的第 &lt;code&gt;i&lt;/code&gt; 个元素 &lt;code&gt;prices[i]&lt;/code&gt; 是一支给定的股票在第 &lt;code&gt;i&lt;/code&gt; 天的价格，和一个整型 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 &lt;code&gt;k&lt;/code&gt; 笔交易。也就是说，你最多可以买 &lt;code&gt;k&lt;/code&gt; 次，卖 &lt;code&gt;k&lt;/code&gt; 次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="动态规划" scheme="tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>leetcode518.零钱兑换II</title>
    <link href="2023/05/23/leetcode518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II/"/>
    <id>2023/05/23/leetcode518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II/</id>
    <published>2023-05-23T11:02:09.000Z</published>
    <updated>2023-05-23T11:04:16.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：amount &#x3D; 5, coins &#x3D; [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5&#x3D;55&#x3D;2+2+15&#x3D;2+1+1+15&#x3D;1+1+1+1+1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：amount &#x3D; 3, coins &#x3D; [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：amount &#x3D; 10, coins &#x3D; [10] 输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>在这个解答中，我们使用动态规划来解决问题。我们定义一个长度为amount+1的dp数组，其中dp[i]表示凑成金额i所需的硬币组合数。</p><p>我们初始化dp[0]为1，表示凑成金额0的组合数为1（不选择任何硬币）。然后，我们遍历硬币数组coins，对于每个硬币coin，我们从coin遍历到amount，更新dp数组的值。对于每个金额i，我们考虑是否选择硬币coin，如果选择，则组合数增加dp[i-coin]，因为我们只需要找出剩余金额i-coin的组合数即可。</p><p>最终，dp[amount]即为所需的结果，即凑成金额amount的组合数。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;        vector&lt;int&gt; dp(amount + 1, 0); &#x2F;&#x2F; 创建长度为amount+1的dp数组，初始值为0        dp[0] &#x3D; 1; &#x2F;&#x2F; 凑成金额0的组合数为1（不选择任何硬币）                for (int coin : coins) &#123; &#x2F;&#x2F; 遍历硬币数组            for (int i &#x3D; coin; i &lt;&#x3D; amount; i++) &#123; &#x2F;&#x2F; 从硬币coin遍历到amount                dp[i] +&#x3D; dp[i - coin]; &#x2F;&#x2F; 更新组合数            &#125;        &#125;                return dp[amount]; &#x2F;&#x2F; 返回凑成金额amount的组合数    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;coins&lt;/code&gt; 表示不同面额的硬币，另给一个整数 &lt;code&gt;amount&lt;/code&gt; 表示总金额。&lt;/p&gt;
&lt;p&gt;请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;假设每一种面额的硬币有无限个。 &lt;/p&gt;
&lt;p&gt;题目数据保证结果符合 32 位带符号整数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="动态规划" scheme="tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>leetcode322.零钱兑换</title>
    <link href="2023/05/22/leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>2023/05/22/leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2023-05-22T08:09:17.000Z</published>
    <updated>2023-05-22T08:11:34.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11输出：3 解释：11 &#x3D; 5 + 5 + 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：coins &#x3D; [2], amount &#x3D; 3输出：-1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：coins &#x3D; [1], amount &#x3D; 0输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>解题思路：</p><ul><li>创建一个长度为 amount + 1 的数组 <code>dp</code>，用于保存每个金额对应的最小硬币数量。初始时，将数组中所有元素的值设置为一个较大的值，表示无穷大。</li><li>将金额为 0 的最小硬币数量设为 0。</li><li>通过动态规划的方式，遍历每个金额，计算最小硬币数量。</li><li>对于当前金额 i，遍历每个硬币的面值，如果当前硬币面值小于等于当前金额 i，则计算使用当前硬币后的剩余金额 remainder。</li><li>检查剩余金额的最小硬币数量是否为有效值，如果是，则更新当前金额 i 的最小硬币数量为 <code>dp[remainder] + 1</code>（加 1 表示使用了当前硬币）。</li><li>最终，如果最终金额的最小硬币数量仍为无效值（即未被更新），则返回 -1，否则返回最小硬币数量。</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;climits&gt;class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量        vector&lt;int&gt; dp(amount + 1, INT_MAX);                &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0        dp[0] &#x3D; 0;                &#x2F;&#x2F; 遍历每个金额，计算最小硬币数量        for (int i &#x3D; 1; i &lt;&#x3D; amount; ++i) &#123;            &#x2F;&#x2F; 遍历每个硬币的面值            for (int j &#x3D; 0; j &lt; coins.size(); ++j) &#123;                &#x2F;&#x2F; 如果当前硬币面值小于等于当前金额 i                if (coins[j] &lt;&#x3D; i) &#123;                    &#x2F;&#x2F; 计算使用当前硬币后的剩余金额                    int remainder &#x3D; i - coins[j];                                        &#x2F;&#x2F; 检查剩余金额的最小硬币数量是否为有效值                    if (dp[remainder] !&#x3D; INT_MAX) &#123;                        &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量                        dp[i] &#x3D; min(dp[i], dp[remainder] + 1);                    &#125;                &#125;            &#125;        &#125;                &#x2F;&#x2F; 如果最终金额的最小硬币数量为无效值，则返回 -1，否则返回最小硬币数量        return dp[amount] &#x3D;&#x3D; INT_MAX ? -1 : dp[amount];    &#125;&#125;;</code></pre><ol start="2"><li>动态规划（优化）</li></ol><ul><li>通过使用范围-based for 循环遍历硬币面值，可以简化代码并提高可读性。</li><li>内层循环从硬币面值开始，而不是从 1 开始，这样可以避免重复计算和无效的更新。</li><li>这种优化利用了动态规划的特性，逐步计算每个金额的最小硬币数量。</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量        vector&lt;int&gt; dp(amount + 1, amount + 1);        &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0        dp[0] &#x3D; 0;        &#x2F;&#x2F; 动态规划，遍历每个金额，计算最小硬币数量        for (int coin : coins) &#123;            for (int i &#x3D; coin; i &lt;&#x3D; amount; ++i) &#123;                &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量                dp[i] &#x3D; min(dp[i], dp[i - coin] + 1);            &#125;        &#125;        &#x2F;&#x2F; 如果最终金额的最小硬币数量仍然大于 amount，则表示无法凑出该金额，返回 -1        if (dp[amount] &gt; amount) &#123;            return -1;        &#125; else &#123;            &#x2F;&#x2F; 返回最小硬币数量            return dp[amount];        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;coins&lt;/code&gt; ，表示不同面额的硬币；以及一个整数 &lt;code&gt;amount&lt;/code&gt; ，表示总金额。&lt;/p&gt;
&lt;p&gt;计算并返回可以凑成总金额所需的 &lt;strong&gt;最少的硬币个数&lt;/strong&gt; 。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;你可以认为每种硬币的数量是无限的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="动态规划" scheme="tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1207.独一无二的出现次数</title>
    <link href="2023/05/21/leetcode1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>2023/05/21/leetcode1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</id>
    <published>2023-05-21T07:23:35.000Z</published>
    <updated>2023-05-21T07:26:06.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1,2]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路： 该问题要求判断给定数组中各个元素出现的频率是否唯一。</p><p>我们可以使用两个数据结构来解决这个问题：</p><ol><li><code>unordered_map&lt;int, int&gt;</code>：用于记录每个元素出现的频率。</li><li><code>unordered_set&lt;int&gt;</code>：用于记录已经出现过的频率。</li></ol><p>我们首先遍历数组，统计每个元素出现的频率并存储在<code>frequencyMap</code>中。然后，我们遍历<code>frequencyMap</code>，对于每个出现的频率，如果该频率已经在<code>occurrenceSet</code>中存在，则说明出现的频率不是唯一的，我们返回false。否则，将该频率添加到<code>occurrenceSet</code>中。最后，如果所有频率都是唯一的，则返回true。</p><p>在示例代码中，我们使用了一个测试用例<code>arr = &#123;1, 2, 2, 1, 1, 3&#125;</code>进行验证，输出结果为<code>true</code>，说明给定数组中各个元素的频率是唯一的。</p><p>请注意，示例代码中使用了C++标准库中的<code>unordered_map</code>和<code>unordered_set</code>来实现哈希表和哈希集合的功能。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123;        unordered_map&lt;int, int&gt; frequencyMap; &#x2F;&#x2F; 存储每个元素出现的频率        unordered_set&lt;int&gt; occurrenceSet; &#x2F;&#x2F; 存储出现的频率值        &#x2F;&#x2F; 计算每个元素出现的频率        for (int num : arr) &#123;            frequencyMap[num]++;        &#125;        &#x2F;&#x2F; 检查频率是否是唯一的        for (auto it &#x3D; frequencyMap.begin(); it !&#x3D; frequencyMap.end(); ++it) &#123;            int occurrence &#x3D; it-&gt;second;            &#x2F;&#x2F; 如果出现的频率已经存在，返回false            if (occurrenceSet.count(occurrence) &gt; 0) &#123;                return false;            &#125;            &#x2F;&#x2F; 将出现的频率添加到集合中            occurrenceSet.insert(occurrence);        &#125;        &#x2F;&#x2F; 所有频率都是唯一的，返回true        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt;，请你帮忙统计数组中每个数的出现次数。&lt;/p&gt;
&lt;p&gt;如果每个数的出现次数都是独一无二的，就返回 &lt;code&gt;true&lt;/code&gt;；否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1365.有多少小于当前数字的数字</title>
    <link href="2023/05/20/leetcode1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>2023/05/20/leetcode1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2023-05-20T08:16:48.000Z</published>
    <updated>2023-05-20T08:53:08.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p><p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。</p><p>以数组形式返回答案。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [8,1,2,2,3]输出：[4,0,1,1,3]解释： 对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]&#x3D;1 不存在比它小的数字。对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [6,5,4,8]输出：[2,1,0,3]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [7,7,7,7]输出：[0,0,0,0]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>思路：直接复制一份数组，将复制得到的数组进行排序，然后进行遍历比较，将得到的值添加到答案数组中，最后返回答案数组。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; nums_sorted &#x3D; nums; &#x2F;&#x2F; 复制nums数组        sort(nums_sorted.begin(), nums_sorted.end()); &#x2F;&#x2F; 将复制后的数组进行排序        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化答案数组        int len &#x3D; nums.size(); &#x2F;&#x2F; 得到数组的总长度        for (int i &#x3D; 0; i &lt; len; i++) &#123; &#x2F;&#x2F; 进行遍历            int result &#x3D; 0; &#x2F;&#x2F; 初始化大于nums[i]的元素的数量为0            for (int j &#x3D; 0; j &lt; len; j++) &#123; &#x2F;&#x2F; 在排序后的数组中进行遍历，以便得到精确的答案                if (nums_sorted[j] &lt; nums[i]) &#123;                    result++; &#x2F;&#x2F; 如果发现数组中有比nums[i]更小的数字，就把result进行++的操作                &#125;                else&#123;                    break; &#x2F;&#x2F; 否则就跳出循环（因为这是已经排序好的数组，这个元素不小于nums[i]那么之后的元素也都大于等于nums[i] 无需继续遍历                &#125;            &#125;            results.push_back(result); &#x2F;&#x2F; 将答案push进答案数组中        &#125;        return results; &#x2F;&#x2F; 返回答案结果    &#125;&#125;;</code></pre><ul><li>使用计数数组优化</li></ul><p>思路：因为nums数组中元素的大小范围为0到100，所以可以设置一个统计各个数字分别有多少个的计数数组，然后利用计数数组计算整个数组中小于nums[i]的元素的个数。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组，范围为0到100        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化结果数组        int len &#x3D; nums.size(); &#x2F;&#x2F; 获取数组长度                &#x2F;&#x2F; 统计每个数字的出现次数        for (int i &#x3D; 0; i &lt; len; i++) &#123;            count[nums[i]]++; &#x2F;&#x2F; 统计当前数字出现的次数        &#125;                &#x2F;&#x2F; 遍历每个数字，计算小于当前数字的元素个数        for (int i &#x3D; 0; i &lt; len; i++) &#123;            int temp_num &#x3D; nums[i]; &#x2F;&#x2F; 当前数字            int result &#x3D; 0; &#x2F;&#x2F; 小于当前数字的元素个数            for (int j &#x3D; 0; j &lt; temp_num; j++) &#123; &#x2F;&#x2F; 遍历计数数组                result +&#x3D; count[j]; &#x2F;&#x2F; 累加小于当前数字的元素个数            &#125;            results.push_back(result); &#x2F;&#x2F; 将结果添加到结果数组中        &#125;                return results; &#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre><ul><li>使用计数排序和前缀和</li></ul><ol><li>使用计数排序：题目中给出了限制条件，数组元素的范围是0到100，因此可以使用计数排序来替代排序函数，以提高效率。创建一个大小为101的计数数组，统计每个数字的出现次数，然后计算小于每个数字的元素个数。</li><li>使用前缀和：通过累加计算计数数组，可以得到每个数字的前缀和数组。前缀和数组的每个元素表示小于等于该数字的元素个数。然后，通过访问前缀和数组即可获取小于每个元素的元素个数。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组        int len &#x3D; nums.size();        &#x2F;&#x2F; 统计每个数字的出现次数        for (int i &#x3D; 0; i &lt; len; i++) &#123;            count[nums[i]]++;        &#125;        &#x2F;&#x2F; 计算前缀和数组        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;            count[i] +&#x3D; count[i - 1];        &#125;        vector&lt;int&gt; results;        for (int i &#x3D; 0; i &lt; len; i++) &#123;            if (nums[i] &#x3D;&#x3D; 0) &#123;                results.push_back(0); &#x2F;&#x2F; 对于数字0，直接加入结果数组中            &#125; else &#123;                results.push_back(count[nums[i] - 1]); &#x2F;&#x2F; 获取小于当前数字的元素个数            &#125;        &#125;        return results;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt;，对于其中每个元素 &lt;code&gt;nums[i]&lt;/code&gt;，请你统计数组中比它小的所有数字的数目。&lt;/p&gt;
&lt;p&gt;换而言之，对于每个 &lt;code&gt;nums[i]&lt;/code&gt; 你必须计算出有效的 &lt;code&gt;j&lt;/code&gt; 的数量，其中 &lt;code&gt;j&lt;/code&gt; 满足 &lt;code&gt;j != i&lt;/code&gt; &lt;strong&gt;且&lt;/strong&gt; &lt;code&gt;nums[j] &amp;lt; nums[i]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;以数组形式返回答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode906.超级回文数</title>
    <link href="2023/05/19/leetcode906-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>2023/05/19/leetcode906-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/</id>
    <published>2023-05-19T09:43:18.000Z</published>
    <updated>2023-05-19T09:45:56.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</p><p>现在，给定两个正整数 <code>L</code> 和 <code>R</code> （以字符串形式表示），返回包含在范围 <code>[L, R]</code> 中的超级回文数的数目。</p> <span id="more"></span><p><strong>示例：</strong></p><pre class="language-none"><code class="language-none">输入：L &#x3D; &quot;4&quot;, R &#x3D; &quot;1000&quot;输出：4解释：4，9，121，以及 484 是超级回文数。注意 676 不是一个超级回文数： 26 * 26 &#x3D; 676，但是 26 不是回文数。</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= len(L) &lt;= 18</code></li><li><code>1 &lt;= len(R) &lt;= 18</code></li><li><code>L</code> 和 <code>R</code> 是表示 <code>[1, 10^18)</code> 范围的整数的字符串。</li><li><code>int(L) &lt;= int(R)</code></li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接求解</li></ul><ol><li>首先，将输入的左右边界转换为长整型。</li><li>然后，利用两个循环来生成所有可能的回文数：<ul><li>第一个循环从1到9，将每个数字作为回文数的中心，生成回文数。</li><li>第二个循环从1到9999，将每个数字作为回文数的前半部分，并生成回文数的后半部分。</li></ul></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int superpalindromesInRange(string left, string right) &#123;        long long leftVal &#x3D; stoll(left); &#x2F;&#x2F; 将左边界转换为长整型        long long rightVal &#x3D; stoll(right); &#x2F;&#x2F; 将右边界转换为长整型        int count &#x3D; 0;        &#x2F;&#x2F; 第一部分：生成所有可能的回文数的前半部分        for (int i &#x3D; 1; i &lt;&#x3D; 9; ++i) &#123;            generatePalindromes(to_string(i), leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数        &#125;                &#x2F;&#x2F; 第二部分：生成所有可能的回文数的中间部分        for (int i &#x3D; 1; i &lt;&#x3D; 9999; ++i) &#123;            string leftPart &#x3D; to_string(i);            string rightPart &#x3D; to_string(i);            reverse(rightPart.begin(), rightPart.end()); &#x2F;&#x2F; 反转右半部分                        generatePalindromes(leftPart + rightPart, leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数            for (int j &#x3D; 0; j &lt;&#x3D; 9; ++j) &#123;                generatePalindromes(leftPart + to_string(j) + rightPart, leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数            &#125;        &#125;                return count;    &#125;    private:    &#x2F;&#x2F; 生成回文数并判断是否为超级回文数    void generatePalindromes(string str, long long leftVal, long long rightVal, int&amp; count) &#123;        long long num &#x3D; stoll(str);        num *&#x3D; num; &#x2F;&#x2F; 平方得到回文数                if (num &gt; rightVal) &#123;            return;        &#125;                if (num &gt;&#x3D; leftVal &amp;&amp; isPalindrome(to_string(num))) &#123;            ++count;        &#125;    &#125;        &#x2F;&#x2F; 判断是否为回文数    bool isPalindrome(string str) &#123;        int left &#x3D; 0;        int right &#x3D; str.length() - 1;                while (left &lt; right) &#123;            if (str[left] !&#x3D; str[right]) &#123;                return false;            &#125;                        ++left;            --right;        &#125;                return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。&lt;/p&gt;
&lt;p&gt;现在，给定两个正整数 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; （以字符串形式表示），返回包含在范围 &lt;code&gt;[L, R]&lt;/code&gt; 中的超级回文数的数目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1291.顺次数</title>
    <link href="2023/05/17/leetcode1291-%E9%A1%BA%E6%AC%A1%E6%95%B0/"/>
    <id>2023/05/17/leetcode1291-%E9%A1%BA%E6%AC%A1%E6%95%B0/</id>
    <published>2023-05-17T05:24:23.000Z</published>
    <updated>2023-05-17T05:26:05.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 <code>1</code> 的整数。</p><p>请你返回由 <code>[low, high]</code> 范围内所有顺次数组成的 <strong>有序</strong> 列表（从小到大排序）。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输出：low &#x3D; 100, high &#x3D; 300输出：[123,234]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输出：low &#x3D; 1000, high &#x3D; 13000输出：[1234,2345,3456,4567,5678,6789,12345]</code></pre><p><strong>提示：</strong></p><ul><li><code>10 &lt;= low &lt;= high &lt;= 10^9</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接生成符合条件的数字</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; sequentialDigits(int low, int high) &#123;        vector&lt;int&gt; result; &#x2F;&#x2F; 存储符合条件的顺次数结果的向量        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;            int num &#x3D; i; &#x2F;&#x2F; 初始化当前数字为起始位            for (int j &#x3D; i + 1; j &lt;&#x3D; 9; j++) &#123;                num &#x3D; num * 10 + j; &#x2F;&#x2F; 逐位增加数字                if (num &gt;&#x3D; low &amp;&amp; num &lt;&#x3D; high) &#123;                    result.push_back(num); &#x2F;&#x2F; 如果生成的数字在给定范围内，则添加到结果向量中                &#125;            &#125;        &#125;        sort(result.begin(), result.end()); &#x2F;&#x2F; 对结果向量进行排序        return result; &#x2F;&#x2F; 返回最终的结果向量    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 &lt;code&gt;1&lt;/code&gt; 的整数。&lt;/p&gt;
&lt;p&gt;请你返回由 &lt;code&gt;[low, high]&lt;/code&gt; 范围内所有顺次数组成的 &lt;strong&gt;有序&lt;/strong&gt; 列表（从小到大排序）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode845.数组中的最长山脉</title>
    <link href="2023/05/16/leetcode845-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/"/>
    <id>2023/05/16/leetcode845-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/</id>
    <published>2023-05-15T23:54:56.000Z</published>
    <updated>2023-05-16T00:02:54.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>把符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：</p><ul><li><code>arr.length &gt;= 3</code></li><li>存在下标<code>i（0 &lt; i &lt; arr.length - 1），</code>满足<ul><li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li><li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul></li></ul><p>给出一个整数数组 <code>arr</code>，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 <code>0</code> 。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,1,4,7,3,2,5]输出：5解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,2,2]输出：0解释：不存在山脉子数组。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 104</code></li><li><code>0 &lt;= arr[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>三指针法</li></ul><ol><li>首先，我们可以初始化三个指针：left、right和peak。<ul><li>left指针指向山脉数组的起点，即数组的第一个元素。</li><li>right指针指向山脉数组的终点，即数组的最后一个元素。</li><li>peak指针指向山脉数组的顶峰。</li></ul></li><li>我们可以通过移动right指针来找到山脉数组的终点。当数组的下一个元素比当前元素大的时候，我们可以继续移动right指针。如果下一个元素比当前元素小，我们将找到了山脉数组的终点。</li><li>一旦我们找到了山脉数组的终点，我们需要移动left指针。我们需要找到山脉数组的起点，即数组的第一个元素。我们可以通过移动left指针来找到山脉数组的起点。当数组的下一个元素比当前元素大的时候，我们可以继续移动left指针。</li><li>当我们找到山脉数组的起点和终点后，我们需要更新peak指针的位置。我们可以通过遍历山脉数组的起点到终点之间的元素，找到最大的元素，并更新peak指针的位置。</li><li>最后，我们可以计算山脉数组的长度，即右边界(right)减去左边界(left)再加1。如果山脉数组的长度大于等于3，就返回该长度；否则，返回0。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int longestMountain(vector&lt;int&gt;&amp; A) &#123;        int n &#x3D; A.size();        int left &#x3D; 0, right &#x3D; 0, peak &#x3D; 0;        int longestMountainLength &#x3D; 0;        while (left &lt; n) &#123;            right &#x3D; left;            &#x2F;&#x2F; 找到山脉数组的终点            if (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;                while (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;                    right++;                &#125;                &#x2F;&#x2F; 找到山脉数组的起点                if (right + 1 &lt; n &amp;&amp; A[right] &gt; A[right + 1]) &#123;                    peak &#x3D; right;                    while (peak + 1 &lt; n &amp;&amp; A[peak] &gt; A[peak + 1]) &#123;                        peak++;                    &#125;                    &#x2F;&#x2F; 更新最长山脉的长度                    longestMountainLength &#x3D; max(longestMountainLength, peak - left + 1);                &#125;            &#125;            left &#x3D; max(right, left + 1);        &#125;        return longestMountainLength &gt;&#x3D; 3 ? longestMountainLength : 0;    &#125;&#125;;</code></pre><ul><li>仅用一趟扫描,并仅用O(1)空间复杂度解决问题</li></ul><p>解题思路：</p><ol><li><p>初始化变量：</p><ul><li><code>up</code>：表示上升的长度（山脉的左半边）</li><li><code>down</code>：表示下降的长度（山脉的右半边）</li><li><code>maxLen</code>：表示最长山脉数组的长度</li></ul></li><li><p>从数组的第二个元素开始遍历：</p><ul><li><p>如果当前元素 <code>A[i]</code> 大于前一个元素 <code>A[i-1]</code>，则表示处于上升阶段，递增 <code>up</code> 的值，同时重置 <code>down</code> 的值为0。</p></li><li><p>如果当前元素 </p><pre class="language-none"><code class="language-none">A[i]</code></pre><p> 小于前一个元素 </p><pre class="language-none"><code class="language-none">A[i-1]</code></pre><p>：</p><ul><li>如果 <code>up</code> 大于0，表示已经处于山脉的下降阶段，递增 <code>down</code> 的值。</li><li>如果 <code>up</code> 等于0，表示还没有开始上升阶段，不进行任何操作。</li></ul></li></ul></li><li><p>当 <code>down</code> 大于0时，表示找到了山脉数组的终点，更新 <code>maxLen</code> 的值。然后将指针移动到山脉数组的下一个元素，即 <code>i</code> 加1，并重置 <code>up</code> 和 <code>down</code> 的值为0。</p></li><li><p>最后返回 <code>maxLen</code>，即为最长山脉数组的长度。</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int longestMountain(vector&lt;int&gt;&amp; A) &#123;        int n &#x3D; A.size();        int up &#x3D; 0, down &#x3D; 0;  &#x2F;&#x2F; 上升和下降的长度        int maxLen &#x3D; 0;  &#x2F;&#x2F; 最长山脉数组的长度        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (A[i] &gt; A[i-1]) &#123;  &#x2F;&#x2F; 上升阶段                if (down &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于下降阶段，则重置上升和下降长度                    up &#x3D; 0;                    down &#x3D; 0;                &#125;                up++;  &#x2F;&#x2F; 递增上升长度            &#125; else if (A[i] &lt; A[i-1]) &#123;  &#x2F;&#x2F; 下降阶段                if (up &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于上升阶段                    down++;  &#x2F;&#x2F; 递增下降长度                    maxLen &#x3D; max(maxLen, up + down + 1);  &#x2F;&#x2F; 更新最长山脉数组的长度                &#125;            &#125; else &#123;  &#x2F;&#x2F; 平稳阶段，重置上升和下降长度                up &#x3D; 0;                down &#x3D; 0;            &#125;        &#125;        return maxLen;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;把符合下列属性的数组 &lt;code&gt;arr&lt;/code&gt; 称为 &lt;strong&gt;山脉数组&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr.length &amp;gt;= 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;存在下标&lt;code&gt;i（0 &amp;lt; i &amp;lt; arr.length - 1），&lt;/code&gt;满足&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr[0] &amp;lt; arr[1] &amp;lt; ... &amp;lt; arr[i - 1] &amp;lt; arr[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr[i] &amp;gt; arr[i + 1] &amp;gt; ... &amp;gt; arr[arr.length - 1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个整数数组 &lt;code&gt;arr&lt;/code&gt;，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1925.统计平方和三元组的数目</title>
    <link href="2023/05/15/leetcode1925-%E7%BB%9F%E8%AE%A1%E5%B9%B3%E6%96%B9%E5%92%8C%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>2023/05/15/leetcode1925-%E7%BB%9F%E8%AE%A1%E5%B9%B3%E6%96%B9%E5%92%8C%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2023-05-15T10:10:26.000Z</published>
    <updated>2023-05-15T10:41:13.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个 <strong>平方和三元组</strong> <code>(a,b,c)</code> 指的是满足 <code>a2 + b2 = c2</code> 的 <strong>整数</strong> 三元组 <code>a</code>，<code>b</code> 和 <code>c</code> 。</p><p>给你一个整数 <code>n</code> ，请你返回满足 <code>1 &lt;= a, b, c &lt;= n</code> 的 <strong>平方和三元组</strong> 的数目。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：2解释：平方和三元组为 (3,4,5) 和 (4,3,5) 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 10输出：4解释：平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 250</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力枚举</li></ul><p>直接进行枚举即可。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int countTriples(int n) &#123;        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n                for (int c &#x3D; b + 1; c &lt;&#x3D; n; c++) &#123;  &#x2F;&#x2F; 遍历c的范围从b+1到n                    if (a * a + b * b &#x3D;&#x3D; c * c) &#123;  &#x2F;&#x2F; 检查是否满足勾股定理                        cnt +&#x3D; 2;  &#x2F;&#x2F; 满足条件的三元组数量加2                    &#125;                &#125;            &#125;        &#125;        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量    &#125;&#125;;</code></pre><ul><li>通过固定C降低时间复杂度</li></ul><p>暴力枚举法的复杂度为O(n^3)，我们可以对其进行一些优化，比如固定c，只保留a和b的循环。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int countTriples(int n) &#123;        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n                int c_square &#x3D; a * a + b * b; &#x2F;&#x2F;  定义c_square&#x3D;a*a+b*b                int c &#x3D; sqrt(c_square); &#x2F;&#x2F; 得到整型的变量c，其值为c_square的平方根                 if (c &lt;&#x3D; n &amp;&amp; c * c &#x3D;&#x3D; c_square) &#123; &#x2F;&#x2F; 因为c是被强制转换成int类型进行存储的，所以不仅要判断c是否小于n还要确定c的平方确实等于c_square                    cnt +&#x3D; 2; &#x2F;&#x2F; 若符合要求，则cnt+&#x3D;2 比如（3，4，5）和（4，3，5）只判断一次，但cnt+&#x3D;2；                &#125;            &#125;        &#125;        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个 &lt;strong&gt;平方和三元组&lt;/strong&gt; &lt;code&gt;(a,b,c)&lt;/code&gt; 指的是满足 &lt;code&gt;a2 + b2 = c2&lt;/code&gt; 的 &lt;strong&gt;整数&lt;/strong&gt; 三元组 &lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你返回满足 &lt;code&gt;1 &amp;lt;= a, b, c &amp;lt;= n&lt;/code&gt; 的 &lt;strong&gt;平方和三元组&lt;/strong&gt; 的数目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1534.统计好三元组</title>
    <link href="2023/05/14/leetcode1534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/"/>
    <id>2023/05/14/leetcode1534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/</id>
    <published>2023-05-14T06:52:41.000Z</published>
    <updated>2023-05-14T06:56:17.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p><p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li><li><code>|arr[i] - arr[j]| &lt;= a</code></li><li><code>|arr[j] - arr[k]| &lt;= b</code></li><li><code>|arr[i] - arr[k]| &lt;= c</code></li></ul><p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p><p>返回 <strong>好三元组的数量</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [3,0,1,1,9,7], a &#x3D; 7, b &#x3D; 2, c &#x3D; 3输出：4解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1,1,2,2,3], a &#x3D; 0, b &#x3D; 0, c &#x3D; 1输出：0解释：不存在满足所有条件的三元组。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= arr.length &lt;= 100</code></li><li><code>0 &lt;= arr[i] &lt;= 1000</code></li><li><code>0 &lt;= a, b, c &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力枚举</li></ul><p>直接模拟暴力枚举即可，代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123;        int len &#x3D; arr.size();  &#x2F;&#x2F; 获取数组的长度        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，记录符合条件的三元组数量        for (int i &#x3D; 0; i &lt; len - 2; i++) &#123;  &#x2F;&#x2F; 第一个数的索引范围是 [0, len - 3]            for (int j &#x3D; i + 1; j &lt; len - 1; j++) &#123;  &#x2F;&#x2F; 第二个数的索引范围是 [i+1, len - 2]                for (int k &#x3D; j + 1; k &lt; len; k++) &#123;  &#x2F;&#x2F; 第三个数的索引范围是 [j+1, len - 1]                    if (abs(arr[i] - arr[j]) &lt;&#x3D; a &amp;&amp; abs(arr[j] - arr[k]) &lt;&#x3D; b &amp;&amp; abs(arr[i] - arr[k]) &lt;&#x3D; c) &#123;                        &#x2F;&#x2F; 检查三元组的条件：两个数之间的差值都不超过给定的限制                        cnt++;  &#x2F;&#x2F; 符合条件的三元组数量加一                    &#125;                &#125;            &#125;        &#125;        return cnt;  &#x2F;&#x2F; 返回符合条件的三元组数量    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt; ，以及 &lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt; 、&lt;code&gt;c&lt;/code&gt; 三个整数。请你统计其中好三元组的数量。&lt;/p&gt;
&lt;p&gt;如果三元组 &lt;code&gt;(arr[i], arr[j], arr[k])&lt;/code&gt; 满足下列全部条件，则认为它是一个 &lt;strong&gt;好三元组&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; arr.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|arr[i] - arr[j]| &amp;lt;= a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|arr[j] - arr[k]| &amp;lt;= b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|arr[i] - arr[k]| &amp;lt;= c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 &lt;code&gt;|x|&lt;/code&gt; 表示 &lt;code&gt;x&lt;/code&gt; 的绝对值。&lt;/p&gt;
&lt;p&gt;返回 &lt;strong&gt;好三元组的数量&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode84.柱状图中最大的矩形</title>
    <link href="2023/05/12/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>2023/05/12/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</id>
    <published>2023-05-12T09:43:04.000Z</published>
    <updated>2023-05-12T09:46:16.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><span id="more"></span> <p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/histogram.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：heights &#x3D; [2,1,5,6,2,3]输出：10解释：最大的矩形为图中红色区域，面积为 10</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/histogram-1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入： heights &#x3D; [2,4]输出： 4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><ol><li>遍历给定的柱状图高度数组 <code>heights</code>，依次处理每个柱子。</li><li>使用一个栈来保存递增序列的索引。栈中的索引对应的柱子高度是递增的。</li><li>对于每个柱子，如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界。</li><li>弹出栈顶元素，并计算以栈顶元素为高度的矩形的面积。面积的宽度可以通过当前索引和新的栈顶元素索引之间的距离计算得到。</li><li>更新最大面积值。</li><li>将当前索引入栈，继续下一个柱子的处理。</li><li>遍历完所有柱子后，栈中剩余的索引对应的柱子高度没有右边界，因此以这些柱子高度计算的矩形面积可以直接得到。</li><li>返回最大面积值。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;    int n &#x3D; heights.size();    stack&lt;int&gt; st; &#x2F;&#x2F; 使用栈来保存递增序列的索引    int maxArea &#x3D; 0;    for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;        &#x2F;&#x2F; 如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界        &#x2F;&#x2F; 计算以栈顶元素为高度的矩形的面积，并更新最大面积        while (!st.empty() &amp;&amp; (i &#x3D;&#x3D; n || heights[i] &lt; heights[st.top()])) &#123;            int h &#x3D; heights[st.top()];            st.pop();            int w &#x3D; st.empty() ? i : (i - st.top() - 1);            maxArea &#x3D; max(maxArea, h * w);        &#125;        &#x2F;&#x2F; 将当前索引入栈        st.push(i);    &#125;    return maxArea;&#125;int main() &#123;    vector&lt;int&gt; heights &#x3D; &#123;2, 1, 5, 6, 2, 3&#125;;    int maxArea &#x3D; largestRectangleArea(heights);    cout &lt;&lt; &quot;最大矩形的面积为：&quot; &lt;&lt; maxArea &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
&lt;p&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>一种基于知识图谱的离散制造车间资源分配优化方法</title>
    <link href="2023/05/12/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%A6%BB%E6%95%A3%E5%88%B6%E9%80%A0%E8%BD%A6%E9%97%B4%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>2023/05/12/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%A6%BB%E6%95%A3%E5%88%B6%E9%80%A0%E8%BD%A6%E9%97%B4%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</id>
    <published>2023-05-12T08:53:33.000Z</published>
    <updated>2023-05-13T12:59:23.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops"><a href="#A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops" class="headerlink" title="A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops"></a>A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>动态订单需求和不确定的制造资源可用性是目前智能资源优化配置的研究热点。目前从制造业产生的数据量正在快速的增长。这些数据有多源头，异构和多尺度的特点。将数据转化为知识，优化个性化订单与制造资源的配置，是提高企业认知智能生产水平的有效策略。<strong>但是</strong>，制造过程在资源配置上是多样化的。数据之间有很多规则和约束。数据之间的关系是更加复杂的，从海量制造数据中挖掘语义信息，缺乏统一的信息建模和工业知识生成方法。<strong>研究挑战</strong>是如何充分整合车间资源的复杂数据，挖掘隐含的语义信息，形成可行的<strong>知识驱动的资源分配优化方法</strong>。这种方法可以有效地提供资源分配所需的相关工程信息。本研究提出了一种统一的知识图驱动的生产资源分配方法，允许根据资源加工信息和设备评估策略，为给定的订单插入任务快速做出资源分配决策。提出了车间资源知识图谱（WRKG）模型来整合机加工车间的工程语义信息。开发了一种<strong>分布式知识表示学习算法</strong>来挖掘隐式资源信息以实时更新WRKG。此外，提出了一种由 WRKG 支持的三阶段资源分配优化方法，以输出特定任务所需的设备集。以航空航天企业制造资源分配过程任务为例，论证了所提方法的可行性。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>制造资源的合理配置对提高生产效率具有重要意义，尤其是在离散制造行业。结构件的生产是离散制造的典型例子，具有多品种、小批量生产、工艺变化频繁等特点。在实际的结构件生产过程中，批量生产任务和研发任务并存，是典型的混合模式生产（见图1）。<strong>批量生产</strong>有固定的处理时间并且每个处理块都根据生产计划进行执行。<strong>研发任务</strong>的制造模式主要是在试制阶段对待加工产品进行一些加急订单，具有较大的不确定性，尤其是在加工时间和设备使用方面。混合模式生产中紧急订单的存在会<strong>引发制造车间资源配置的冲突</strong>。此外，紧急订单会影响生产效率和交货时间。此外，切换紧急订单需要大量的准备时间和等待时间，这降低了车间的整体生产效率。<strong>因此需要</strong>快速高效地配置车间制造资源，减少资源冲突，提高资源利用率，增强制造过程的灵活性。</p><p><img src="http://cdn.leafii.top/img/image-20230510203735964.png" alt="image-20230510203735964" loading="lazy"></p><p>大多数次序资源分配的现有方法主要关注于优化资源模型和算法。随着IOT和大数据行业的巨大发展，在工业生产过程有很多的数据被生成了。这些数据具有结构化和非结构化、多尺度、多源和语义关系复杂性的特点。然而，现有的资源分配模型或算法中，<strong>缺乏</strong>对企业海量制造数据的语义信息挖掘。现有的资源分配模型或算法中，<strong>缺乏</strong>对企业海量制造数据的语义信息挖掘。这些方法<strong>忽略</strong>了车间中丰富的语义信息，不利于为资源配置提供准确的关联知识，像人类一样从知识层面进行认知和决策。根据在离散制造车间进行的实地调研发现，车间资源产生的数据<strong>利用不充分</strong>，主要有以下原因：</p><ol><li>数据类型多样：过程的历史数据在生产车间以多种类型记录。此外，大多数数据是半结构化或非结构化的，这导致数据处理效率低下。如此一来，数据便无法轻易复用，以提升后续生产设备的配置效率。</li><li>复杂的数据关系：制造数据中的车间生产设备、加工零件、工艺需求之间存在多种潜在的逻辑关联。目前，由于这些数据之间关系的复杂性，利用数据关系指导生产还不够充分。</li><li>数据处理效率低：制造数据的处理延迟无法在有急单时提供及时、动态的资源调整决策。这主要是因为各个制造步骤之间的数据关系复杂，并且缺乏对制造数据的语义理解。</li></ol><p>目前，这些数据还没有很好地用于生产计划和控制的决策。有必要探索一种有效的方法来整合积累的生产资源数据，以供工业知识重用和资源配置应用。语义技术（即本体论）广泛用于知识建模。<strong>然而</strong>，本体表示模式层上的知识，而没有描述深层语义关系。产业本体是资源概念的集合，主要描述资源概念及其属性信息。这种方法灵活性有限，知识的计算效率相对较低。知识图谱是一种结构化的语义知识库，由实体-关系-实体和实体-属性-值三元组组成，能够更好地描述数据层中的数据。此外，知识图谱能够处理具有复杂结构的大规模数据，计算不同术语之间的语义相似度，以及在没有显式边的情况下推理实体之间的隐式关系。知识图谱已经出现在制造领域。<strong>然而</strong>，从海量制造数据中挖掘特定的语义信息，构建工业资源配置决策所需的语义知识，目前还<strong>缺乏统一的信息建模和知识生成方法</strong>。此外，目前知识库构建的研究多是通过关联企业已有的知识来进行的。并且对挖掘制造业中海量的隐式语义关系缺乏深入研究，不利于丰富知识库，提高知识利用率。<strong>研究的挑战</strong>在于如何充分整合车间资源的复杂数据，挖掘隐含的语义信息，形成可行的知识驱动的资源分配优化方法，高效提供资源分配所需的相关工程信息。</p><p>本论文首先研究了一种基于统一知识图谱的制造资源优化配置方法。该方法旨在<strong>挖掘制造中的隐性关系，生成驱动生产资源分配的热更新知识图谱，从知识层面实现订单插入请求的快速资源分配决策</strong>。具体来说，提出了<strong>WRKG模型</strong>来集成工程语义信息，包括制造企业中大规模生产要素（过程、设备、人员、材料）的各种数据类型。然后，开发了一种<strong>知识表示学习算法</strong>来推理设备和进程之间的深层隐式关系。通过这种方式，WRKG 可以规范机加工车间的知识，提高生产过程的效率。此外，为了使用构建的 WRKG 为订单任务提供准确的信息，提出了基于WRKG的<strong>资源分配优化三阶段方法</strong>，包括1）制造资源重构的数学模型，2）候选设备集的形成和3）候选设备集的评估和优化。最后，在航空航天加工车间对所提出的方法进行了应用和评估。</p><p>本文的主要贡献包括：</p><p>1）提出了一个<strong>统一的基于知识图谱的决策框架</strong>，集成了机加工车间环境中的隐性工程知识。该框架用于支持资源分配的优化方法</p><p>2）开发<strong>分布式表示学习算法</strong>，挖掘复杂工程数据之间的隐含关系，丰富车间资源之间的关系，高效指导生产。</p><p>3）提出了<strong>混合模型生产过程中候选设备形成和基于社区的设备评估的三阶段方法</strong>，该方法利用机加工车间WRKG为候选设备的形成和评估提供关联数据支持。</p><p>4）通过在航空航天加工车间采用结构件的生产任务来<strong>评估</strong>所提出的方法。结果表明，该方法能够在处理稳定的前提下，生成更符合逻辑、更直观的资源重构过程知识，提高设备利用率、处理任务的响应能力和设备的灵活性。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>讨论了制造业资源分配中与订单插入相关的基本问题，即如何匹配订单请求。文章重点回顾了现有的制造业资源分配研究工作，侧重于知识表示和建模方法。</p><h4 id="Knowledge-representation-and-modeling-of-manufacturing-resources"><a href="#Knowledge-representation-and-modeling-of-manufacturing-resources" class="headerlink" title="Knowledge representation and modeling of manufacturing resources"></a>Knowledge representation and modeling of manufacturing resources</h4><p>讨论了制造业中资源分配问题中的知识表示和建模方法。现有的知识表示和建模方法（如本体学）在处理大规模知识时存在灵活性和计算效率方面的限制。因此，研究者提出了基于知识图谱的决策框架和改进的知识表示学习算法，以挖掘复杂工程数据之间的隐含语义关系，提供更全面的知识支持资源分配决策。文章认为现有的方法不能直接应用于制造业，因为制造数据复杂多样，存在许多规则和约束，导致制造资源的语义表示和建模困难。因此本文提出了一个<strong>统一的基于知识图的决策制定框架</strong>用于支持资源调度的最优方法。此外，一种<strong>改进的用于挖掘复杂的工程数据之间关系的知识表示学习算法</strong>也被提出以提供更多可理解的知识。</p><h4 id="Optimization-of-resource-configuration"><a href="#Optimization-of-resource-configuration" class="headerlink" title="Optimization of resource configuration"></a>Optimization of resource configuration</h4><p>介绍了混合模式车间动态生产环境下资源分配研究的优化方法、模型和算法。文章总结了鲁棒方法、智能优化方法和重新调度方法的优缺点，并列举了相关文献。鲁棒方法广泛研究用于优化车间资源分配，智能优化方法利用各种智能算法和优化方法进行动态资源分配，重新调度方法具有良好的时效性。这些方法都有其适用范围，但没有考虑车间中所包含的丰富语义信息。作者提出使用知识图谱来提供资源分配方法所需的信息，并提高生产决策的智能水平。因此，本文的主要贡献是使用知识图谱创新地提供资源分配方法所需的信息，并从知识层面提高生产决策的智能水平。</p><p><img src="http://cdn.leafii.top/img/image-20230306165544044.png" alt="image-20230306165544044" loading="lazy"></p><p>根据表1可以得出结论，这些方法都有一定的适用范围，但都没有考虑到workshop中包含的丰富的语义信息。智能优化方法适用于解决本文所讨论的问题。本文的主要贡献是创新性地利用知识图谱为资源配置方法提供所需信息，从知识层面提高生产决策的智能化水平。</p><h3 id="The-WRKG-modeling-method-for-production-process"><a href="#The-WRKG-modeling-method-for-production-process" class="headerlink" title="The WRKG modeling method for production process"></a>The WRKG modeling method for production process</h3><p>总的来说是，WRKG的提出是为了整合车间资源知识，并且支持插入订单的资源分配方式。 WRKG模型的建立是为了<strong>获取和融合</strong>与加工资源相关的数据，<strong>包括</strong>WRKG的<strong>定义</strong>、与设备和加工相关的<strong>信息规范</strong>。然后生成与加工相关的WRKG。此外，为了丰富和更新 WRKG，挖掘制造生产中的<strong>隐式关系</strong>，开发了一种<strong>改进的表示学习算法</strong>（improved represented learning algorithm)。</p><h4 id="Construction-of-the-WRKG"><a href="#Construction-of-the-WRKG" class="headerlink" title="Construction of the WRKG"></a>Construction of the WRKG</h4><p>为了将生产车间的大量半结构化和非结构化数据转化为结构化知识，设计了WRKG构建框架，整合车间设备资源，如图2所示。</p><p><img src="http://cdn.leafii.top/img/image-20230309204056952.png" alt="image-20230309204056952" loading="lazy"></p><p>它由三部分组成。</p><ol><li>首先，获取车间制造的历史数据、生产文件数据和实时生产数据。</li><li>其次，对制造相关信息进行知识融合处理，建立加工知识本体模型。车间资源的实体和关系存储在图数据库中。</li><li>然后使用本体规则和分布式表示学习支持的推理方法来识别与加工车间使用的设备相关的隐式关系。</li><li>最后，隐式关系之间的信息和知识应用的形成都反馈到数据采集端，以动态更新研讨会资源之间的关系。</li></ol><p>为了构建 WRKG，车间资源信息由三元组构建，结合生产要素中的机器-材料-方法（Machine-Material-Method），如图 3 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230312214619994.png" alt="image-20230312214619994" loading="lazy"></p><p>三层结构包括<strong>类别层、概念层和实体层</strong>。<strong>资源类别层</strong>由四个部分组成，代表车间的<strong>生产要素</strong>，包括设备、产品、过程和操作。<strong>中间层（概念层）</strong>是资源类别层对应的<strong>各类生产资源</strong>，有利于本体的概念形成。<strong>底层（实体层）</strong>是各类工坊资源的<strong>实体信息</strong>。这有助于开发大型车间资源的知识图谱，为设备资源之间的关系推断提供数据支持。</p><h5 id="Modeling-of-the-WRKG-of-machining-device"><a href="#Modeling-of-the-WRKG-of-machining-device" class="headerlink" title="Modeling of the WRKG of machining device"></a>Modeling of the WRKG of machining device</h5><p>本节基于WRKG框架来描述WRKG的定义。</p><p>**Definition 1.**机加工车间设备概念本体可以形式化定义为$o&#x3D;〈T,S,P,R,A〉$，其含义如下：</p><p><strong>T</strong>是术语抽象，主要是图3中的中间层（概念层）设备类。</p><p><strong>S</strong>是同义词融合，由多个术语消除歧议后形成一个唯一的术语，如高速钢车刀、硬质合金车刀都归为车刀。</p><p><strong>P</strong>为属性抽象，$P &#x3D; { BasI(i), FunI(i), StaI(i)}$，其中$BasI(i)$表示设备$i$的<strong>基本信息</strong>，如设备位置、设备名称、设备编号等.$FunI(i)$ 表示关于设备$ i $的<strong>功能信息</strong>，例如可加工的腔体、复杂的表面零件。$StaI(i)$表示设备$i$的<strong>状态信息</strong>，取值0、1、2、3、4分别代表idle、full-load、overload、failure(怠速、满载、过载和故障)。设备附带的基本属性和功能属性是<strong>静态信息</strong>，状态属性是<strong>动态信息</strong>。此外，设备的状态基于传感器和MES（制造执行系统）实时更新。</p><p><strong>R</strong>是关系抽象，它基于P中的三个属性，关系包括“has_a”、“has_tool”、“has_status”等。在加工过程中，设备节点之间的关系有<strong>动态和静态</strong>的变化. &lt;概念实例、属性关系触发词、属性值&gt;三元组用于描述设备的基本信息，如&lt;Machine, has_a, Position&gt;。</p><p><strong>A</strong>$(A(i)∈A)$是一种规则，用于<strong>约束和规范</strong>设备的形成。其中，设备元素（element）描述为$M(i)&#x3D;{ BasI(i),FunI(i),StaI(i)}∈M⇒M(i)∈P$。设备模型可表示为$M &#x3D; ∑^n_{i &#x3D;1}M(i)$。机床设备数据模型M的<strong>约束规则</strong>如表2所示。</p><p><img src="http://cdn.leafii.top/img/image-20230312221444700.png" alt="image-20230312221444700" loading="lazy"></p><p>根据<strong>Definition 1</strong> 中给出的信息，开发了加工装置的概念模型（见图 4）。</p><p><img src="http://cdn.leafii.top/img/image-20230312221852950.png" alt="image-20230312221852950" loading="lazy"></p><h5 id="Formation-of-the-WRKG-of-device-relationship-network"><a href="#Formation-of-the-WRKG-of-device-relationship-network" class="headerlink" title="Formation of the WRKG of device relationship network"></a>Formation of the WRKG of device relationship network</h5><p>**Definition 2.**机加工车间设备集的知识图可以定义为$G&#x3D;〈MI,RI,PI,G〉$，其意义如下。</p><p><strong>MI</strong>是设备信息集，指的是图3中底层的设备资源<strong>（实体）</strong>，如车床、数控铣床、加工中心等。</p><p><strong>RI</strong>是设备之间的关系。Definition 1中已经用详细信息对器件实体进行了建模，但在加工过程中器件之间仍然存在复杂多变的关系，包括顺序关系、排他关系和并行关系。具体信息如下：</p><p>a) <strong>顺序关系</strong>是设备链接在加工过程中的全局关联形式。例如，设备M1和M2的顺序关系可以表示为Sequence(M1,M2)。</p><p>b) <strong>排他关系</strong>是设备链路在处理过程中的局部关联形式。 以设备M1和M2为例，如果在选择的分支结构中都在同一条分支路径上，则可以指定设备M1和M2之间存在排他关系，即Exclusive(M1, M2) .</p><p>c) <strong>并联关系</strong>是机械加工过程中常见的设备组织关系。 例如，如果设备M1和M2在并联分支结构中有不同的分支路径，则它们之间的关系可以定义为并联关系，即Parallel(M1,M2)。</p><p><strong>PI</strong>是基于制造过程信息流的<strong>过程需求信息</strong>（见图5），主要包括设备、工具、夹具、量具、量具、标识符、操作员和传感器。</p><p><img src="http://cdn.leafii.top/img/image-20230313170059637.png" alt="image-20230313170059637" loading="lazy"></p><p><strong>G</strong>是机加工车间的设备制造资源，可以描述为一个三元组$G&#x3D;{(h,l,t)}∈(MI×RI×PI)∩o$，其中$h$是WRKG的头实体，$t$是WRKG 的尾部实体，$l$是头尾实体之间的关系。结构件的制造涉及多道工序，需要多台设备才能完成规定的加工任务。</p><p>这样，可以利用集成的信息开发全面的设备关系网络。</p><h4 id="Knowledge-representation-learning-and-mining-of-the-WRKG"><a href="#Knowledge-representation-learning-and-mining-of-the-WRKG" class="headerlink" title="Knowledge representation learning and mining of the WRKG"></a>Knowledge representation learning and mining of the WRKG</h4><p>为进一步高效<strong>挖掘机加工车间资源间的隐含关系</strong>，为支持资源分配决策提供更全面的知识，提出了一种改进的分布式表示学习方法，该方法在头尾实体中加入<strong>语义权重向量</strong>$θ_i∈\mathbb R^k$对应关系 $l_i ∈ \mathbb R^k$。机加工车间资源信息知识表示模型描述如下：</p><p>$h_i &#x3D; h \circ \theta_i^h$</p><p>$t_i &#x3D; t \circ \theta_i^t$</p><p>其中$∘$为hadamma乘积算子（矩阵对应相乘相加），$h_i$和$t_i$分别由关系$l_i$语义下的头尾实体向量表示。为了提高机加工车间资源数据的语义关联准确性，基于马氏距离（表示点与一个分布之间的距离）<strong>计算设备资源的相似度</strong>。<strong>发现车间资源实体之间的隐式关系</strong>。得分函数如下所示：</p><p>$f_l(h,t) &#x3D; (h_i \circ \theta^h_i + l_i - t_i \circ \theta_i^t)W_l(h_i \circ \theta_i^h + l_i - t_i \circ \theta_i^t)$</p><p>其中$f_l(h,t)$是<strong>车间资源数据三元组的得分函数</strong>，$W_l$是自适应度量对应的特定关系对称非负权重矩阵。</p><p>优化目标函数如下：</p><p>$min \sum_{(h,l,t) \in \Delta(h’,l’,t’)\in \Delta’}[f_l(h,t) + \gamma - f_{l’}(h’,t’)]<em>+ + \lambda(\sum</em>{l \in L}||W_l||<em>F^2)+C(\sum</em>{e \in E} ||e||<em>2^2 + \sum</em>{l\in L}||l||_2^2) $</p><p>$[W_l]_{ij} \geq 0$</p><p>其中，$[\cdot]_+$是取0和一个大的值的<strong>max值</strong>，$\gamma$是正负三元组的<strong>最大语义边界间隔</strong>， $|| \cdot||_F$是矩阵的<strong>F范数</strong>，C控制<strong>缩放度</strong>，λ控制自适应权重矩阵的<strong>正则化</strong>。可以通过将式（6）(见下文)的导数设为0来求解Wl，以提高计算效率。</p><p>为了更彻底的理解算法1中WRKG的真正实现，在5.2节中举了一个例子进行说明。</p><p><img src="http://cdn.leafii.top/img/image-20230313170345648.png" alt="image-20230313170345648" loading="lazy"></p><h3 id="A-three-staged-method-based-on-the-WRKG-for-resource-allocation-optimization"><a href="#A-three-staged-method-based-on-the-WRKG-for-resource-allocation-optimization" class="headerlink" title="A three-staged method based on the WRKG for resource allocation optimization"></a>A three-staged method based on the WRKG for resource allocation optimization</h3><p>本节提出了一个结合了WRKG以驱动设备资源调度优化的三阶段方法。该方法的每个阶段都利用相应的先前生成的制造知识，在认知层面提升资源分配决策的智能性。该方法可以将制造订单要求与机加工车间的WRKG联系起来。<strong>决策过程利用了WRKG信息，并且可以学习设备评估策略以形成指导后续生产的新知识。</strong>它包含的三个阶段如下：</p><ul><li>使用模糊层次方法所需的索引构造候选设备集。</li><li>利用基于社区的设备制造资源<strong>评价模型</strong>，从设备利用率方面对候选设备集进行评价和优化。</li><li>针对处理设备组的配置优化，建立了资源分配<strong>数学模型</strong>。</li></ul><h4 id="Mathematical-model-of-manufacturing-resource-reconfiguration"><a href="#Mathematical-model-of-manufacturing-resource-reconfiguration" class="headerlink" title="Mathematical model of manufacturing resource reconfiguration"></a>Mathematical model of manufacturing resource reconfiguration</h4><p>由2.2节的分析，可以得到机械车间资源配置的数学模型。假定加工任务中的结构件是$J&#x3D;{J_1, J_2, …, J_i, …, j_n}$，其中加工过程的j节点被视为$O_j, j&#x3D;1,2,…,n_T$，其中$n_T$是操作的总数。可用设备域被设置为设备组$G&#x3D;{G_1, G_2,…,G_t,…,G_T}$，设备节点$M&#x3D;{M_1,M_2,…,M_k,…,M_m}$，因此$G_j$表示在过程$O_j$中正在处理的设备组，并且包含了一个设备节点集$M_j \in M$。过程$O_j$在设备节点$M_k$上的处理时间用$pt_{jk}$表示，使用$tt_{mn}$（transform time)表示设备节点$M_m$和$M_n$之间的转移时间。$ST_{kj}$表示过程$O_j$在设备节点$M_k$的加工开始时间，并且$ET_{kj}$表示过程$O_j$在设备节点$M_k$上的加工结束时间。$C_i$是工件$i$节点的完成时间。$W_k$表示设备节点$M_k$的工作负载，以负载率作为衡量标准。基于以上描述，以下目标函数被定义。</p><p><img src="http://cdn.leafii.top/img/image-20230313202944346.png" alt="image-20230313202944346" loading="lazy"></p><p>上面的式子需要满足以下限制:<br>$ST_{kj} &#x3D; ET_{m(j-1)} + pt_{mk}$</p><p>这个目标是为了<strong>最小化处理时间和设备资源的负载</strong>。该限制表明在之前的处理完成之后<strong>设备之间的转移时间</strong>需要被考虑进去。</p><h5 id="Formation-of-the-candidate-device-sets"><a href="#Formation-of-the-candidate-device-sets" class="headerlink" title="Formation of the candidate device sets"></a>Formation of the candidate device sets</h5><p>结构件的生产涉及各种各样的设备。因此，基于WRKG的候选设备编队如图6所示，用于对特定进程进行资源匹配。</p><p><img src="http://cdn.leafii.top/img/image-20230313205031018.png" alt="image-20230313205031018" loading="lazy"></p><p>特定的评估指标用于选择设备以构建可选设备集。基于3.1.1节（Modeling of the WRKG of machining device）提出的制造设备信息模型，有五项设备资源评价指标，包括<strong>工件特征、加工特征、加工类型、加工精度和运行状态</strong>。这些指标具有层次结构。在这项研究中，模糊层次分析法被用来量化指标之间的关系。它的<strong>优点</strong>是可以为具有明显层次结构信息的各个评价指标分配权重。该方法可用于结构件制造过程中从<strong>指标集</strong>和<strong>对象集</strong>两个方面筛选设备资源。该方法的实现分为以下几个步骤。</p><ol><li>在指标集方面，利用WRKG提供的设备间丰富的相关性信息，建立了五类评价指标的模糊矩阵$R_{ij}$。</li><li>就对象集而言，为每个评价指标分配权重，通过计算指标间的标准差$σ_j$生成设备权重向量$W_j$。</li><li>在确定不同设备的权重向量后，引入相关系数 $ξ_i(k)$来提高设备资源的匹配精度。</li><li>通过将设备信息与过程知识相关联，得到每个候选设备资源对应指标的相关系数。</li><li>进一步计算<strong>处理任务中设备与进程信息之间的资源相似度匹配度</strong>$\gamma_s$。</li><li>最终选择符合生产要求的设备。</li></ol><h5 id="Evaluation-and-optimization-of-the-candidate-device-sets"><a href="#Evaluation-and-optimization-of-the-candidate-device-sets" class="headerlink" title="Evaluation and optimization of the candidate device sets"></a>Evaluation and optimization of the candidate device sets</h5><p>候选设备在设置后需要基于社区技术进行<strong>评估</strong>和<strong>优化</strong>。在这项研究中，社区包括几个具有共同功能和属性的共享通信节点的机床。换句话说，它可以基于通信节点对设备进行集群，以方便设备的统一组织。开发了基于社区的处理的评估模型（见图 7）。</p><p><img src="http://cdn.leafii.top/img/image-20230313220047285.png" alt="image-20230313220047285" loading="lazy"></p><ul><li>首先，WRKG<strong>提供</strong>评估方法所需的<strong>相关信息</strong>，包括设备组的组成信息和当前状态信息。</li><li>其次，如果评估需要优化，进行评估分析，及时合理分配社区设备。</li><li>最后，将各器件集的分析调整方案应用到WRKG中，形成新的器件集逻辑关系和组织形式，<strong>指导后续制造过程（更新）</strong>。</li></ul><p>社区的动态调整主要针对<strong>单台机床的负载率</strong>，旨在<strong>通过加工任务的重新分配</strong>优化机床资源的配置。评价优化算法如下：</p><p><img src="http://cdn.leafii.top/img/image-20230314102517102.png" alt="image-20230314102517102" loading="lazy"></p><h3 id="Case-study"><a href="#Case-study" class="headerlink" title="Case study"></a>Case study</h3><p>案例研究是基于航空航天企业中加工结构件的具体加工任务。</p><h4 id="Processing-information-of-aerospace-machining-workshop"><a href="#Processing-information-of-aerospace-machining-workshop" class="headerlink" title="Processing information of aerospace machining workshop"></a>Processing information of aerospace machining workshop</h4><p>选择该车间为代表进行配置优化问题的分析的理由：该车间是企业内部的核心制造车间之一。车间由16台机器组成，包括加工中心、线切割机和数控车床。其中包括三台专用功能线切割机和两台 DMG 车床 (DMG CTV160)。多功能数控机床，尤其是加工中心，是影响结构件生产效率的重要因素。设备信息在表3中提供。</p><p><img src="http://cdn.leafii.top/img/image-20230314104027858.png" alt="image-20230314104027858" loading="lazy"></p><p>本研究以车间某一时期的结构件加工任务为研究对象，主要包括特定型号的电动转向架（PTVA10212）、旋转体头罩（PTVN10312）、车架背支撑板（PTVL10111），盒体（PTVM10121）。对4个航天结构件处理后的原始数据进行整理后，批处理任务详情如表4所示。</p><p><img src="http://cdn.leafii.top/img/image-20230314104538441.png" alt="image-20230314104538441" loading="lazy"></p><p>批量生产任务处理20h时发出加工新试制盒的加急单PTVC10221（见表4），加工信息见表5。</p><p><img src="http://cdn.leafii.top/img/image-20230314105347359.png" alt="image-20230314105347359" loading="lazy"></p><h4 id="Generation-of-the-WRKG-of-the-aerospace-machining-workshop"><a href="#Generation-of-the-WRKG-of-the-aerospace-machining-workshop" class="headerlink" title="Generation of the WRKG of the aerospace machining workshop"></a>Generation of the WRKG of the aerospace machining workshop</h4><p>基于图4加工装置的概念模型，将装置的基本静态属性、状态属性、功能属性信息进行整合，生成加工中心的WRKG（见图8）。</p><p><img src="http://cdn.leafii.top/img/image-20230314105535517.png" alt="image-20230314105535517" loading="lazy"></p><p>然后将各种设备的实体信息与加工产品的工艺实体信息相关联。计算过程用于演示如何挖掘车间资源实体之间的隐含关系，阐明WRKG的更新过程（见图9）。</p><p><img src="http://cdn.leafii.top/img/image-20230314105644941.png" alt="image-20230314105644941" loading="lazy"></p><p>输入是 WRKG 中的一组三元组，结合算法 1。可以训练每个三元组以生成相应的嵌入向量。如果“加工中心”与语义相似度高的实体相匹配，则可以根据马氏距离输出对应的实体。如果预测“加工中心”和“孔”之间的隐含关系，即一个三元组（machining center, ?, hole），则可以根据评分函数输出实体之间可能存在的隐含关系。此外，隐式关系在工程师评估后更新到 WRKG。给出输出从小到大排名前3的结果，作为工程师评估的参考。为此，将隐式关系更新到 WRKG。最后，在图 10 中开发了航空结构件加工过程中的 WRKG。</p><p><img src="http://cdn.leafii.top/img/image-20230314110439473.png" alt="image-20230314110439473" loading="lazy"></p><h4 id="Resource-configuration-optimization-for-processing-tasks"><a href="#Resource-configuration-optimization-for-processing-tasks" class="headerlink" title="Resource configuration optimization for processing tasks"></a>Resource configuration optimization for processing tasks</h4><p>构建了一个基于知识的航天结构件制造资源优化配置平台如图11所示，专门针对机加工车间。由于车间排除了热处理工艺，后续分析忽略热处理的加工信息。</p><p><img src="http://cdn.leafii.top/img/image-20230314143230294.png" alt="image-20230314143230294" loading="lazy"></p><p>平台集成了前面章节描述的方法，包括当前器件加工能力信息、基于算法1的WRKG嵌入式表示、制造资源重构的数学模型、候选器件集的形成和评估。</p><p>当有新的加急订单下达时，可根据当前订单状态信息，计算可行设备群并在平台上可视化，包括具体设备的状态信息（当前加工状态、加工工件、剩余加工时间等）和任务的实时细节。</p><p>将表4的处理任务导入到平台中。此外，还计算了四个加工社区，包括 PTVM10212、PTVN10312、PTVA10111 和 PTVL10121。该平台用于在表5中的加急订单下达时，针对表4中的订单任务优化加工设备配置的计算。开发了完成PTVC10221加工任务的六台设备的加工共同体。</p><p>重新配置后，与重新配置前的设备利用率和之前的平均设备利用率相比，重新配置后的<strong>整体设备利用率得到提高</strong>（见图 12（a））。此外，前半部分的利用率显着提高，而后半部分则较少。因为新机加工社区的组成主要由现有机加工社区中的原机加工设备组成。此外，紧急订单 PTVC10221 包括现有机加工社区中的第一台机加工设备。</p><p><img src="http://cdn.leafii.top/img/image-20230314143722314.png" alt="image-20230314143722314" loading="lazy"></p><p>分析了加急订单前后各机加工社区的平均负载率和负载均衡状态。重构前后各加工团体的目标状态对比曲线如图12(b)所示。可以看出，所有机加工社区的整体负载率θ从48.82%上升到56.68%。另外，**单台机床的负载率$θ_k$不过80%**。此外，整体负载均衡状态$σ(θ)$略有变化，从6.30%变为7.51%，仍然是一个可控的理想范围（$θ_k≤80%，σ(θ)&lt;15%$）如图7和算法2所示。结果表明，车间内所有设备的负载率是均衡的。因此，得出的结论是，所提出的方法促进了车间设备社区的可持续加工。</p><p>单个设备的配置演变如图13所示，其中车削设备群体、铣削设备群体和钻削设备群体发生了变化。此外，设备社区的变化是由表5中任务订单的流程要求引起的。表 5 订单发布后，设备社区发生变化，表明设备转移发生在机加工社区内。来自不同社区的设备转移表明该方法<strong>提高了设备处理的灵活性</strong>。</p><p><img src="http://cdn.leafii.top/img/image-20230314144713007.png" alt="image-20230314144713007" loading="lazy"></p><h4 id="Discussions"><a href="#Discussions" class="headerlink" title="Discussions"></a>Discussions</h4><p>正如所呈现的工业案例研究所验证的那样，基于知识图谱的方法可以链接航空航天加工车间的制造资源，以支持加工设备的优化。它能够实时查询设备状态，为平台支持调度提供准确的信息。同时，航空结构件的生产过程涉及到很多与设备相关的信息，并不局限于机加工车间。本文仅关注机加工车间设备相关信息。<strong>不能保证</strong>在设计航空航天 WRKG 时完全涵盖设备相关关系。因此，其他车间信息和更多的关系将在以后的工作中带来。</p><p>在案例验证中，本研究分析了抢单影响下的车间流程资源重构。但是，在工业实践中还有一些情况需要进行资源重构分析，例如修改订单、设备故障等。因此，进一步的研究将集中在其他情况下如何改善制造资源配置。</p><h3 id="Conclusions-and-future-work"><a href="#Conclusions-and-future-work" class="headerlink" title="Conclusions and future work"></a>Conclusions and future work</h3><p>在车间层面开发低成本、系统的工程知识生成和分配服务机制是一项关键的研究挑战。本研究提出了一种新的基于知识图谱的设备资源分配优化方法，用于快速实时响应设备资源的配置需求。提出了生产过程的WRKG建模方法，包括WRKG的构建和基于WRKG知识表示学习和挖掘的方法。预计这两个方面将整合来自不同层次的处理知识，以支持资源分配方法。</p><p>在资源分配服务方面，提出了一种集成WRKG驱动设备资源分配优化的三阶段方法。<strong>第一步</strong>是生成标准化的加工知识，如工件特征、加工特征、加工类型、加工状态等。为了支持候选设备集的决策，<strong>第二步</strong>是使用制造资源社区评估模型评估可用设备。<strong>第三步</strong>旨在利用资源分配数学模型对处理设备集进行配置优化，保证设备的利用率最大化。最后，通过案例研究产品对所提出的方法进行评估，以证明工程知识在改进车间资源配置优化方面的价值。</p><p>未来，本研究将引入航天企业其他加工车间（热处理车间、焊接车间等）的资源，丰富航天加工车间资源之间的关系。此外，考虑包含更多的不可控因素，以提高整个资源重构过程的鲁棒性，并与其他方法进行比较。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops&quot;&gt;&lt;a href=&quot;#A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops&quot; class=&quot;headerlink&quot; title=&quot;A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops&quot;&gt;&lt;/a&gt;A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;动态订单需求和不确定的制造资源可用性是目前智能资源优化配置的研究热点。目前从制造业产生的数据量正在快速的增长。这些数据有多源头，异构和多尺度的特点。将数据转化为知识，优化个性化订单与制造资源的配置，是提高企业认知智能生产水平的有效策略。&lt;strong&gt;但是&lt;/strong&gt;，制造过程在资源配置上是多样化的。数据之间有很多规则和约束。数据之间的关系是更加复杂的，从海量制造数据中挖掘语义信息，缺乏统一的信息建模和工业知识生成方法。&lt;strong&gt;研究挑战&lt;/strong&gt;是如何充分整合车间资源的复杂数据，挖掘隐含的语义信息，形成可行的&lt;strong&gt;知识驱动的资源分配优化方法&lt;/strong&gt;。这种方法可以有效地提供资源分配所需的相关工程信息。本研究提出了一种统一的知识图驱动的生产资源分配方法，允许根据资源加工信息和设备评估策略，为给定的订单插入任务快速做出资源分配决策。提出了车间资源知识图谱（WRKG）模型来整合机加工车间的工程语义信息。开发了一种&lt;strong&gt;分布式知识表示学习算法&lt;/strong&gt;来挖掘隐式资源信息以实时更新WRKG。此外，提出了一种由 WRKG 支持的三阶段资源分配优化方法，以输出特定任务所需的设备集。以航空航天企业制造资源分配过程任务为例，论证了所提方法的可行性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="知识图谱" scheme="tags/知识图谱/"/>
    
    <category term="车间调度" scheme="tags/车间调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode739.每日温度</title>
    <link href="2023/05/11/leetcode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>2023/05/11/leetcode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</id>
    <published>2023-05-11T01:07:07.000Z</published>
    <updated>2023-05-11T02:57:25.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]输出: [1,1,4,2,1,1,0,0]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: temperatures &#x3D; [30,40,50,60]输出: [1,1,1,0]</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: temperatures &#x3D; [30,60,90]输出: [1,1,0]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>单调栈</li></ul><p>解本题的第一种解题思路是直接进行暴力模拟。但是本文的样例中，若数组的长度很长而且元素都是同一个值，会导致超出时间限制，因此我们必须考虑使用其他的数据结构帮助我们进行解题。本体可以使用栈的数据结构帮助我们解题，思路如下：首先初始化答案数组为全0，数组的长度为temperatures数组的长度，栈中的元素是尚未找到下一个更高温度的索引。遍历温度列表时，如果当前温度大于栈顶索引对应的温度，说明栈顶索引对应的温度已经找到了下一个更高温度，可以计算出答案并更新结果数组。通过这种方法，可以在一次遍历中完成计算，时间复杂度为 O(n)，满足时间限制。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        int len &#x3D; temperatures.size();        vector&lt;int&gt; answers(len, 0); &#x2F;&#x2F; 储存答案数组        stack&lt;int&gt; stk; &#x2F;&#x2F; 单调栈        for (int i &#x3D; 0; i &lt; len; i++) &#123;            while (!stk.empty() &amp;&amp; temperatures[stk.top()] &lt; temperatures[i]) &#123; &#x2F;&#x2F; 当当前温度高于栈顶索引的温度时                answers[stk.top()] &#x3D; i - stk.top(); &#x2F;&#x2F; 更新对应索引的answer                stk.pop(); &#x2F;&#x2F; 较低的温度的索引出栈            &#125;            stk.push(i); &#x2F;&#x2F; 较高的温度索引入栈        &#125;        return answers; &#x2F;&#x2F; 返回答案数组    &#125;&#125;;</code></pre><p>当给定输入 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，我们可以逐步执行优化后的代码来帮助您理解它的工作原理：</p><ol><li>初始化空栈和答案数组：stk &#x3D; []，answers &#x3D; [0, 0, 0, 0, 0, 0, 0, 0]。</li><li>遍历温度列表：<ul><li>对于第一个温度 73：<ul><li>栈为空，将索引 0 压入栈。</li></ul></li><li>对于第二个温度 74：<ul><li>栈顶索引对应的温度是 73，74 &gt; 73，可以计算答案 answers[0] &#x3D; 1。</li><li>弹出栈顶索引 0，将索引 1 压入栈。</li></ul></li><li>对于第三个温度 75：<ul><li>栈顶索引对应的温度是 74，75 &gt; 74，可以计算答案 answers[1] &#x3D; 1。</li><li>弹出栈顶索引 1，将索引 2 压入栈。</li></ul></li><li>对于第四个温度 71：<ul><li>栈顶索引对应的温度是 75，71 &lt; 75，将索引 3 压入栈。</li></ul></li><li>对于第五个温度 69：<ul><li>栈顶索引对应的温度是 71，69 &lt; 71，将索引 4 压入栈。</li></ul></li><li>对于第六个温度 72：<ul><li>栈顶索引对应的温度是 69，72 &gt; 69，可以计算答案 answers[4] &#x3D; 2。</li><li>弹出栈顶索引 4，将索引 5 压入栈。</li></ul></li><li>对于第七个温度 76：<ul><li>栈顶索引对应的温度是 72，76 &gt; 72，可以计算答案 answers[5] &#x3D; 1。</li><li>弹出栈顶索引 5，将索引 6 压入栈。</li></ul></li><li>对于最后一个温度 73：<ul><li>栈顶索引对应的温度是 76，73 &lt; 76，将索引 7 压入栈。</li></ul></li></ul></li><li>完成遍历后，栈中剩余的索引对应的答案无法计算，因为它们没有找到下一个更高温度。因此，答案数组中仍然为0。</li></ol><p>最终的答案数组为 [1, 1, 4, 2, 1, 1, 0, 0]，它表示每个温度需要等待的天数，直到出现更高的温度。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;temperatures&lt;/code&gt; ，表示每天的温度，返回一个数组 &lt;code&gt;answer&lt;/code&gt; ，其中 &lt;code&gt;answer[i]&lt;/code&gt; 是指对于第 &lt;code&gt;i&lt;/code&gt; 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 &lt;code&gt;0&lt;/code&gt; 来代替。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode503.下一个更大元素II</title>
    <link href="2023/05/10/leetcode503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/"/>
    <id>2023/05/10/leetcode503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/</id>
    <published>2023-05-10T01:36:21.000Z</published>
    <updated>2023-05-10T01:38:08.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,2,3,4,3]输出: [2,3,4,-1,4]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>直接进行循环遍历判断即可。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;        int len &#x3D; nums.size();        vector&lt;int&gt; answers;        for (int i &#x3D; 0; i &lt; len; i++) &#123;            int temp &#x3D; nums[i]; &#x2F;&#x2F; 保存当前需要判断的值            int temp_index &#x3D; i; &#x2F;&#x2F; 保存当前需要判断的值的索引            int answer &#x3D; -1; &#x2F;&#x2F; 初始化answer元素            for (int j &#x3D; (i + 1) % len; j !&#x3D; temp_index; j &#x3D; (j + 1) % len) &#123;                if (nums[j] &gt; temp) &#123;                    answer &#x3D; nums[j]; &#x2F;&#x2F;找到第一个比temp大的元素，将其赋值给answer 并跳出当前for循环                    break;                &#125;            &#125;            answers.push_back(answer); &#x2F;&#x2F; 将answer放进答案数组中        &#125;        return answers; &#x2F;&#x2F; 返回答案数组    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个循环数组 &lt;code&gt;nums&lt;/code&gt; （ &lt;code&gt;nums[nums.length - 1]&lt;/code&gt; 的下一个元素是 &lt;code&gt;nums[0]&lt;/code&gt; ），返回 &lt;em&gt;&lt;code&gt;nums&lt;/code&gt; 中每个元素的 &lt;strong&gt;下一个更大元素&lt;/strong&gt;&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;数字 &lt;code&gt;x&lt;/code&gt; 的 &lt;strong&gt;下一个更大的元素&lt;/strong&gt; 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode496.下一个更大元素I</title>
    <link href="2023/05/09/leetcode496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/"/>
    <id>2023/05/09/leetcode496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</id>
    <published>2023-05-09T12:35:51.000Z</published>
    <updated>2023-05-09T12:41:44.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].输出：[3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 2 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。下一个更大元素是 3 。- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li><li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力实现</li></ul><p>直接模拟实现</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt; answers;        map&lt;int,int&gt; m;&#x2F;&#x2F; m用于存储nums2数组中每个元素的下标值        for (int i &#x3D; 0; i &lt; nums2.size(); i++) &#123;            m[nums2[i]] &#x3D; i;        &#125;        for (int i &#x3D; 0; i &lt; nums1.size(); i++)&#123;            int index &#x3D; m[nums1[i]]; &#x2F;&#x2F; 获取nums1的元素在nums2的下标值            int answer &#x3D; -1;            int temp &#x3D; nums1[i];            if (index &#x3D;&#x3D; nums2.size() - 1) answer &#x3D; -1;            else &#123;                while (index &lt; nums2.size()) &#123;                    if(index+1 &lt; nums2.size() &amp;&amp; nums2[index+1] &gt; temp) &#123;                        answer &#x3D; nums2[index+1];                        break;                    &#125;                    else &#123;                        index++;                    &#125;                &#125;            &#125;            answers.push_back(answer);        &#125;        return answers;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;code&gt;nums1&lt;/code&gt; 中数字 &lt;code&gt;x&lt;/code&gt; 的 &lt;strong&gt;下一个更大元素&lt;/strong&gt; 是指 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;nums2&lt;/code&gt; 中对应位置 &lt;strong&gt;右侧&lt;/strong&gt; 的 &lt;strong&gt;第一个&lt;/strong&gt; 比 &lt;code&gt;x&lt;/code&gt; 大的元素。&lt;/p&gt;
&lt;p&gt;给你两个 &lt;strong&gt;没有重复元素&lt;/strong&gt; 的数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; ，下标从 &lt;strong&gt;0&lt;/strong&gt; 开始计数，其中&lt;code&gt;nums1&lt;/code&gt; 是 &lt;code&gt;nums2&lt;/code&gt; 的子集。&lt;/p&gt;
&lt;p&gt;对于每个 &lt;code&gt;0 &amp;lt;= i &amp;lt; nums1.length&lt;/code&gt; ，找出满足 &lt;code&gt;nums1[i] == nums2[j]&lt;/code&gt; 的下标 &lt;code&gt;j&lt;/code&gt; ，并且在 &lt;code&gt;nums2&lt;/code&gt; 确定 &lt;code&gt;nums2[j]&lt;/code&gt; 的 &lt;strong&gt;下一个更大元素&lt;/strong&gt; 。如果不存在下一个更大元素，那么本次查询的答案是 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;返回一个长度为 &lt;code&gt;nums1.length&lt;/code&gt; 的数组 &lt;code&gt;ans&lt;/code&gt; 作为答案，满足 &lt;code&gt;ans[i]&lt;/code&gt; 是如上所述的 &lt;strong&gt;下一个更大元素&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1356.根据数字二进制下1的数目排序</title>
    <link href="2023/05/09/leetcode1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/"/>
    <id>2023/05/09/leetcode1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/</id>
    <published>2023-05-09T12:00:40.000Z</published>
    <updated>2023-05-09T12:17:09.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p><p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p><p>请你返回排序后的数组。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]解释：[0] 是唯一一个有 0 个 1 的数。[1,2,4,8] 都有 1 个 1 。[3,5,6] 有 2 个 1 。[7] 有 3 个 1 。按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [10000,10000]输出：[10000,10000]</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,3,5,7,11,13,17,19]输出：[2,3,5,17,7,11,13,19]</code></pre><p><strong>示例 5：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [10,100,1000,10000]输出：[10,100,10000,1000]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 500</code></li><li><code>0 &lt;= arr[i] &lt;= 10^4</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路如下：</p><ol><li>首先定义一个辅助函数<code>countBits</code>，用于计算一个数的二进制表示中1的个数。该函数使用位运算技巧，通过不断将数字与其自身减1的结果进行按位与运算，可以统计出二进制中1的个数。</li><li>接下来定义一个自定义的比较函数<code>compare</code>，用于在排序时比较两个数的大小。该函数首先分别计算两个数的二进制中1的个数，然后比较它们的个数。如果个数相等，则按照原始数值的大小进行比较。</li><li>然后定义<code>sortByBits</code>函数，该函数接受一个整数数组作为参数，并使用STL的<code>sort</code>函数对数组进行排序。在排序过程中，使用自定义的比较函数<code>compare</code>进行比较。</li><li>在主函数<code>main</code>中，创建一个测试数组<code>arr</code>，并调用<code>sortByBits</code>函数对数组进行排序。排序后的结果保存在<code>sortedArr</code>中。</li><li>最后，通过循环遍历<code>sortedArr</code>，将排序后的数组打印输出。</li></ol><p>整体思路是先计算每个数字的二进制中1的个数，然后根据这个个数进行排序，当个数相同时按照原始数值的大小进行排序。通过自定义比较函数和使用STL的<code>sort</code>函数，可以方便地完成这个排序任务。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int get(int x)&#123;        int res &#x3D; 0;        while (x) &#123;            res +&#x3D; (x % 2);            x &#x2F;&#x3D; 2;        &#125;        return res;    &#125;    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123;        vector&lt;int&gt; bit(10001, 0);        for (auto x: arr) &#123;            bit[x] &#x3D; get(x);        &#125;        sort(arr.begin(), arr.end(), [&amp;](int x, int y)&#123; &#x2F;&#x2F; Lambda表达式语法            if (bit[x] &lt; bit[y]) &#123;                return true;            &#125;            if (bit[x] &gt; bit[y]) &#123;                return false;            &#125;            return x &lt; y;        &#125;);        return arr;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt; 。请你将数组中的元素按照其二进制表示中数字 &lt;strong&gt;1&lt;/strong&gt; 的数目升序排序。&lt;/p&gt;
&lt;p&gt;如果存在多个数字二进制中 &lt;strong&gt;1&lt;/strong&gt; 的数目相同，则必须将它们按照数值大小升序排列。&lt;/p&gt;
&lt;p&gt;请你返回排序后的数组。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
