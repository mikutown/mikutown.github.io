<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-08-07T03:52:55.709Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode941.有效的山脉数组</title>
    <link href="2023/08/07/leetcode941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
    <id>2023/08/07/leetcode941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</id>
    <published>2023-08-07T03:18:14.000Z</published>
    <updated>2023-08-07T03:52:55.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>arr</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p><span id="more"></span><p>让我们回顾一下，如果 <code>arr</code> 满足下述条件，那么它是一个山脉数组：</p><ul><li><p><code>arr.length &gt;= 3</code></p></li><li><p>在 </p><pre class="language-none"><code class="language-none">0 &lt; i &lt; arr.length - 1</code></pre><p> 条件下，存在 </p><pre class="language-none"><code class="language-none">i</code></pre><p> 使得：</p><ul><li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li><li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul></li></ul><p><img src="http://cdn.leafii.top/img/hint_valid_mountain_array.png" alt="img" loading="lazy"></p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,1]输出：false</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [3,5,5]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [0,3,2,1]输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 104</code></li><li><code>0 &lt;= arr[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>首先获取数组中最大的数字以及下标，然后对下标进行判断，符合条件（数组大小超过2并且最大值不是数组的第一个元素或者最后一个元素）时进行第二次循环，循环时判断相邻元素是否满足递增或者递减的关系。C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool validMountainArray(vector&lt;int&gt;&amp; arr) &#123;        &#x2F;&#x2F; 得到最大值        int maxNum &#x3D; -1;        int maxIndex &#x3D; -1;        int n &#x3D; arr.size();        if (n &lt; 3) return false;        for (int i &#x3D; 0; i &lt; n; i++) &#123;            if (arr[i] &gt; maxNum) &#123;                maxNum &#x3D; arr[i];                maxIndex &#x3D; i;            &#125;        &#125;        &#x2F;&#x2F; 得到最大值后进行一部分判断然后进行循环        if (maxIndex &#x3D;&#x3D; n-1 || maxIndex &#x3D;&#x3D; 0) return false;        for (int i &#x3D; 0; i &lt; maxIndex; i++) &#123;            if (arr[i] &gt;&#x3D; arr[i + 1]) return false;        &#125;        for (int i &#x3D; maxIndex; i &lt; n - 1; i++) &#123;            if (arr[i] &lt;&#x3D; arr[i + 1]) return false;        &#125;        return true;    &#125;&#125;;</code></pre><ul><li>只扫描一次的解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool validMountainArray(vector&lt;int&gt;&amp; A) &#123;        int n &#x3D; A.size();                &#x2F;&#x2F; 山脉数组必须至少有3个元素        if (n &lt; 3) &#123;            return false;        &#125;                int i &#x3D; 0;                &#x2F;&#x2F; 从左侧递增部分开始扫描        while (i &lt; n - 1 &amp;&amp; A[i] &lt; A[i + 1]) &#123;            i++;        &#125;                &#x2F;&#x2F; 如果i是数组的第一个元素或者最后一个元素，说明没有递增或递减的足够元素        if (i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) &#123;            return false;        &#125;                &#x2F;&#x2F; 扫描递减部分        while (i &lt; n - 1 &amp;&amp; A[i] &gt; A[i + 1]) &#123;            i++;        &#125;                &#x2F;&#x2F; 如果i已经到达数组的末尾，说明是有效的山脉数组        return i &#x3D;&#x3D; n - 1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;arr&lt;/code&gt;，如果它是有效的山脉数组就返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode115.不同的子序列</title>
    <link href="2023/08/04/leetcode115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>2023/08/04/leetcode115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2023-08-04T08:53:00.000Z</published>
    <updated>2023-08-04T08:54:47.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数。</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;rabbbit&quot;, t &#x3D; &quot;rabbit&quot;输出：3解释：如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。rabbbitrabbbitrabbbit</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;babgbag&quot;, t &#x3D; &quot;bag&quot;输出：5解释：如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 babgbagbabgbagbabgbagbabgbagbabgbag</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>解题思路：</p><p>题目要求计算字符串 s 变换为字符串 t 的不同子序列数量。这类问题可以使用动态规划来解决。</p><p>我们使用 dp<code>[i][j]</code> 表示字符串 s 的前 i 个字符和字符串 t 的前 j 个字符之间的不同子序列数量。初始时，任何字符串变换为空字符串的方式都只有一种，即不选取任何字符，因此我们将 dp<code>[i][0] </code>设置为 1。</p><p>然后，我们遍历字符串 s 和字符串 t 的所有字符组合，逐步计算 dp 数组。当 s[i-1] 和 t[j-1] 相等时，我们可以选择当前字符匹配或者不匹配。如果匹配，那么当前字符可以贡献 <code>dp[i-1][j-1] </code>个子序列；如果不匹配，那么当前字符不会贡献新的子序列，继续使用<code> dp[i-1][j]</code>。如果 s[i-1] 和 t[j-1] 不相等，那么当前字符不能匹配，只能选择不匹配，即使用<code> dp[i-1][j]</code>。</p><p>最终，dp<code>[m][n]</code> 就是字符串 s 变换为字符串 t 的不同子序列数量，其中 m 是字符串 s 的长度，n 是字符串 t 的长度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int numDistinct(string s, string t) &#123;        int m &#x3D; s.length();        int n &#x3D; t.length();                &#x2F;&#x2F; dp[i][j] 表示 s 的前 i 个字符和 t 的前 j 个字符之间的不同子序列数量        vector&lt;vector&lt;unsigned int&gt;&gt; dp(m + 1, vector&lt;unsigned int&gt;(n + 1, 0));                &#x2F;&#x2F; 初始化：任何字符串变换为空字符串的方式都只有一种，即不选取任何字符        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;            dp[i][0] &#x3D; 1;        &#125;                &#x2F;&#x2F; 状态转移        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;                &#x2F;&#x2F; 如果 s[i-1] 和 t[j-1] 相等，则可以选择当前字符匹配或者不匹配                if (s[i - 1] &#x3D;&#x3D; t[j - 1]) &#123;                    dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j];                &#125; else &#123;                    &#x2F;&#x2F; 如果不相等，则只能选择不匹配                    dp[i][j] &#x3D; dp[i - 1][j];                &#125;            &#125;        &#125;                return dp[m][n];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，统计并返回在 &lt;code&gt;s&lt;/code&gt; 的 &lt;strong&gt;子序列&lt;/strong&gt; 中 &lt;code&gt;t&lt;/code&gt; 出现的个数。&lt;/p&gt;
&lt;p&gt;题目数据保证答案符合 32 位带符号整数范围。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96.不同的二叉搜索树</title>
    <link href="2023/08/03/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>2023/08/03/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2023-08-03T00:39:28.000Z</published>
    <updated>2023-08-03T00:44:33.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/uniquebstn3.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：5</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>解题思路： 这个问题可以用动态规划来解决。我们创建一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以 <code>i</code> 个节点构建的二叉搜索树的数量。我们可以观察到，对于每个 <code>i</code>，我们可以将每个节点依次作为根节点，将问题划分为子问题。例如，以节点 <code>j</code> 作为根节点，它的左子树将有 <code>j - 1</code> 个节点，右子树将有 <code>i - j</code> 个节点。所以，以节点 <code>j</code> 作为根节点的二叉搜索树数量为 <code>dp[j - 1] * dp[i - j]</code>。我们将所有以不同节点作为根节点的情况累加起来，就得到了 <code>dp[i]</code> 的值。</p><p>在循环计算 <code>dp</code> 数组时，外层循环遍历节点数量 <code>i</code>，内层循环遍历以不同节点为根节点的情况 <code>j</code>。最终，<code>dp[n]</code> 就是我们所求的以 <code>n</code> 个节点构建的不同二叉搜索树的数量。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int numTrees(int n) &#123;        &#x2F;&#x2F; 创建一个数组来存储以1到n为节点的二叉搜索树的数量        vector&lt;int&gt; dp(n + 1, 0);        &#x2F;&#x2F; 空树也算一种情况，初始化dp[0]为1        dp[0] &#x3D; 1;                &#x2F;&#x2F; 外层循环遍历节点数量        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;            &#x2F;&#x2F; 内层循环遍历以不同节点为根节点的情况            for (int j &#x3D; 1; j &lt;&#x3D; i; ++j) &#123;                &#x2F;&#x2F; 左子树的节点数量为j-1，右子树的节点数量为i-j                &#x2F;&#x2F; 以第j个节点为根节点的BST数量等于左子树数量乘以右子树数量                dp[i] +&#x3D; dp[j - 1] * dp[i - j];            &#125;        &#125;                return dp[n];    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，求恰由 &lt;code&gt;n&lt;/code&gt; 个节点组成且节点值从 &lt;code&gt;1&lt;/code&gt; 到 </summary>
      
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode139.单词拆分</title>
    <link href="2023/08/02/leetcode139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>2023/08/02/leetcode139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</id>
    <published>2023-08-02T01:25:01.000Z</published>
    <updated>2023-08-02T01:27:05.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。     注意，你可以重复使用字典中的单词。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>思路： 这个问题可以使用动态规划来解决。我们定义一个布尔数组 dp，其中 dp[i] 表示字符串 s 的前 i 个字符能否被空格拆分成字典中出现的单词。初始时，dp[0] &#x3D; true，表示空字符串可以被拆分。</p><p>然后，我们从字符串 s 的第一个字符开始，依次遍历每个字符。对于每个字符，我们将其与前面的字符组成的子串依次与字典中的单词进行匹配。如果找到了匹配的单词，且前面的子串也可以被拆分成字典中的单词，那么 dp[i] 就为 true。具体的匹配过程可以通过在字典中使用哈希表进行优化，从而避免不必要的字符串匹配。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;        &#x2F;&#x2F; 将字典中的单词存储到哈希表中，方便进行快速查找        unordered_set&lt;string&gt; dictSet(wordDict.begin(), wordDict.end());        int n &#x3D; s.length();        &#x2F;&#x2F; 创建一个布尔数组 dp，初始时 dp[0] &#x3D; true，表示空字符串可以被拆分        vector&lt;bool&gt; dp(n + 1, false);        dp[0] &#x3D; true;        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;            for (int j &#x3D; 0; j &lt; i; j++) &#123;                &#x2F;&#x2F; 如果前面的子串 dp[j] 可以被拆分，并且剩余的子串 s[j:i] 在字典中存在，更新 dp[i] 为 true                if (dp[j] &amp;&amp; dictSet.count(s.substr(j, i - j)) &gt; 0) &#123;                    dp[i] &#x3D; true;                    break; &#x2F;&#x2F; 找到一种拆分方式即可，无需继续循环                &#125;            &#125;        &#125;        &#x2F;&#x2F; 返回 dp[n]，表示整个字符串是否可以被拆分为字典中的单词        return dp[n];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个字符串列表 &lt;code&gt;wordDict&lt;/code&gt; 作为字典。请你判断是否可以利用字典中出现的单词拼接出 &lt;code&gt;s&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode392.判断子序列</title>
    <link href="2023/08/02/leetcode392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>2023/08/02/leetcode392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2023-08-02T01:06:17.000Z</published>
    <updated>2023-08-02T01:25:24.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><span id="more"></span><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>致谢：</strong></p><p>特别感谢 <a href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 100</code></li><li><code>0 &lt;= t.length &lt;= 10^4</code></li><li>两个字符串都只由小写字符组成。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法：</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isSubsequence(string s, string t) &#123;        if (s.size() &#x3D;&#x3D; 0 &amp;&amp; t.size() &#x3D;&#x3D; 0) &#123;            return true; &#x2F;&#x2F; 如果 s 和 t 均为空，则 s 是 t 的子序列，返回 true        &#125;        int i &#x3D; 0; &#x2F;&#x2F; 定义 s 的指针 i，用于遍历 s 的字符        int temp &#x3D; -1; &#x2F;&#x2F; 定义 temp 变量，用于记录上一次匹配的 t 中的位置        int j &#x3D; 0; &#x2F;&#x2F; 定义 t 的指针 j，用于遍历 t 的字符        for (i &#x3D; 0; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 遍历 s 中的字符            for (j &#x3D; temp + 1; j &lt; t.size(); j++) &#123; &#x2F;&#x2F; 从上一次匹配的位置之后开始遍历 t 中的字符                if(s[i] &#x3D;&#x3D; t[j]) &#123; &#x2F;&#x2F; 如果当前 s 中的字符与 t 中的字符匹配                    temp &#x3D; j; &#x2F;&#x2F; 更新 temp 为当前匹配的 t 中的位置                    break; &#x2F;&#x2F; 跳出当前循环，继续下一个字符的匹配                &#125; else if (j &#x3D;&#x3D; t.size() - 1) &#123;                    return false; &#x2F;&#x2F; 如果 t 中没有字符与 s 中的字符匹配，返回 false                &#125;            &#125;        &#125;        if (i &#x3D;&#x3D; s.size() &amp;&amp; j &lt; t.size()) &#123;            return true; &#x2F;&#x2F; 如果 s 已经遍历完毕，而 t 还有剩余字符，则 s 是 t 的子序列，返回 true        &#125;        return false; &#x2F;&#x2F; 其他情况下，返回 false    &#125;&#125;;</code></pre><ul><li>更高效的方法</li></ul><p>我们可以通过一次遍历字符串 t 来判断字符串 s 是否为 t 的子序列。</p><p>思路如下：对于字符串 s 和 t，我们维护两个指针 i 和 j，分别指向 s 和 t 的开头。然后，我们逐个比较 s[i] 和 t[j]，如果相等，则将两个指针都向后移动一位，如果不相等，则只移动 t 的指针 j。最终，如果 s 的指针 i 移动到末尾，说明 s 是 t 的子序列，返回 true，否则返回 false。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isSubsequence(string s, string t) &#123;        int i &#x3D; 0;        int j &#x3D; 0;        while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;            if (s[i] &#x3D;&#x3D; t[j]) &#123;                i++; &#x2F;&#x2F; 如果当前字符匹配，移动 s 的指针            &#125;            j++; &#x2F;&#x2F; 不论当前字符是否匹配，移动 t 的指针        &#125;        return i &#x3D;&#x3D; s.size(); &#x2F;&#x2F; 如果 s 的指针移动到末尾，说明 s 是 t 的子序列，返回 true；否则返回 false    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定字符串 &lt;strong&gt;s&lt;/strong&gt; 和 &lt;strong&gt;t&lt;/strong&gt; ，判断 &lt;strong&gt;s&lt;/strong&gt; 是否为 &lt;strong&gt;t&lt;/strong&gt; 的子序列。&lt;/p&gt;
&lt;p&gt;字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt;是&lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt;的一个子序列，而&lt;code&gt;&amp;quot;aec&amp;quot;&lt;/code&gt;不是）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode338.比特位计数</title>
    <link href="2023/08/02/leetcode338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <id>2023/08/02/leetcode338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</id>
    <published>2023-08-02T00:43:43.000Z</published>
    <updated>2023-08-02T00:56:41.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：[0,1,1]解释：0 --&gt; 01 --&gt; 12 --&gt; 10</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：[0,1,1,2,1,2]解释：0 --&gt; 01 --&gt; 12 --&gt; 103 --&gt; 114 --&gt; 1005 --&gt; 101</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>很容易就能实现时间复杂度为 <code>O(n log n)</code> 的解决方案，你可以在线性时间复杂度 <code>O(n)</code> 内用一趟扫描解决此问题吗？</li><li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 <code>__builtin_popcount</code> ）</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>思路：首先新建一个数组用来保存结果，接下来从0开始一直循环到输入的n，用while循环+循环内的数字temp&#x3D;temp&amp;(temp-1)的操作获得每一个数字对应的二进制1的个数，然后把对应的个数保存在数组中，最后返回结果数组。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; countBits(int n) &#123;        vector&lt;int&gt; results; &#x2F;&#x2F; 创建一个用于存储结果的向量        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123; &#x2F;&#x2F; 循环从 0 到 n            int temp &#x3D; i; &#x2F;&#x2F; 将当前迭代的数值保存到 temp 变量中            int count &#x3D; 0; &#x2F;&#x2F; 初始化计数器为 0            while (temp) &#123; &#x2F;&#x2F; 进行求解二进制中 1 的个数的操作                temp &#x3D; temp &amp; (temp - 1); &#x2F;&#x2F; 通过该操作，每次能将 temp 中最右边的 1 变为 0，并统计操作次数，即为 1 的个数                count++; &#x2F;&#x2F; 统计 1 的个数            &#125;            results.push_back(count); &#x2F;&#x2F; 将统计得到的 1 的个数添加到结果向量中        &#125;        return results; &#x2F;&#x2F; 返回结果向量    &#125;&#125;;</code></pre><ul><li>动态规划</li></ul><p>在这个问题中，我们可以利用已经计算过的结果来求解新的结果。思路如下：对于任意的非负整数 i，其二进制表示中 1 的个数可以通过以下方式求得：</p><ol><li>如果 i 是偶数，那么 i 的二进制表示中 1 的个数等于 i&#x2F;2 的二进制表示中 1 的个数，因为 i 相当于将 i&#x2F;2 左移一位并在末尾补上一个 0。</li><li>如果 i 是奇数，那么 i 的二进制表示中 1 的个数等于 i-1 的二进制表示中 1 的个数再加 1，因为 i 相当于将 i-1 的二进制表示中最右边的 1 变为 0。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; countBits(int n) &#123;        vector&lt;int&gt; results(n + 1, 0); &#x2F;&#x2F; 创建一个长度为 n+1 的向量，并初始化所有元素为 0                for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;            if (i % 2 &#x3D;&#x3D; 0) &#123;                &#x2F;&#x2F; 对于偶数 i，其二进制表示中 1 的个数等于 i&#x2F;2 的二进制表示中 1 的个数                results[i] &#x3D; results[i &#x2F; 2];            &#125; else &#123;                &#x2F;&#x2F; 对于奇数 i，其二进制表示中 1 的个数等于 i-1 的二进制表示中 1 的个数再加 1                results[i] &#x3D; results[i - 1] + 1;            &#125;        &#125;                return results;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，对于 &lt;code&gt;0 &amp;lt;= i &amp;lt;= n&lt;/code&gt; 中的每个 &lt;code&gt;i&lt;/code&gt; ，计算其二进制表示中 &lt;strong&gt;&lt;code&gt;1&lt;/code&gt; 的个数&lt;/strong&gt; ，返回一个长度为 &lt;code&gt;n + 1&lt;/code&gt; 的数组 &lt;code&gt;ans&lt;/code&gt; 作为答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode321.拼接最大数</title>
    <link href="2023/07/28/leetcode321-%E6%8B%BC%E6%8E%A5%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <id>2023/07/28/leetcode321-%E6%8B%BC%E6%8E%A5%E6%9C%80%E5%A4%A7%E6%95%B0/</id>
    <published>2023-07-28T10:32:30.000Z</published>
    <updated>2023-07-28T10:41:04.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定长度分别为 <code>m</code> 和 <code>n</code> 的两个数组，其元素由 <code>0-9</code> 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 <code>k (k &lt;= m + n)</code> 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p><p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 <code>k</code> 的数组。</p><p><strong>说明:</strong> 请尽可能地优化你算法的时间和空间复杂度。</p><span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入:nums1 &#x3D; [3, 4, 6, 5]nums2 &#x3D; [9, 1, 2, 5, 8, 3]k &#x3D; 5输出:[9, 8, 6, 5, 3]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入:nums1 &#x3D; [6, 7]nums2 &#x3D; [6, 0, 4]k &#x3D; 5输出:[6, 7, 6, 0, 4]</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入:nums1 &#x3D; [3, 9]nums2 &#x3D; [8, 9]k &#x3D; 3输出:[9, 8, 9]</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>单调栈</li></ul><p>为了找到长度为 kkk 的最大数，需要从两个数组中分别选出最大的子序列，这两个子序列的长度之和为 kkk，然后将这两个子序列合并得到最大数。两个子序列的长度最小为 000，最大不能超过 kkk 且不能超过对应的数组长度。</p><p>令数组 $\textit{nums}_1$ 的长度为 m，数组 $\textit{nums}_2$的长度为 n，则需要从数组 $\textit{nums}_1$中选出长度为 x 的子序列，以及从数组$\textit{nums}_2$ 中选出长度为 yyy 的子序列，其中$x+y&#x3D;k$，且满足$0 \le x \le m$和$0 \le y \le n$。需要遍历所有可能的 $x$ 和 $y$ 的值，对于每一组$x$ 和 $y$ 的值，得到最大数。在整个过程中维护可以通过拼接得到的最大数。</p><p>对于每一组 $x$ 和 $y$ 的值，得到最大数的过程分成两步，第一步是分别从两个数组中得到指定长度的最大子序列，第二步是将两个最大子序列合并。</p><p>第一步可以通过单调栈实现。单调栈满足从栈底到栈顶的元素单调递减，从左到右遍历数组，遍历过程中维护单调栈内的元素，需要保证遍历结束之后单调栈内的元素个数等于指定的最大子序列的长度。遍历结束之后，将从栈底到栈顶的元素依次拼接，即得到最大子序列。</p><p>第二步需要自定义比较方法。首先比较两个子序列的当前元素，如果两个当前元素不同，则选其中较大的元素作为下一个合并的元素，否则需要比较后面的所有元素才能决定选哪个元素作为下一个合并的元素。</p><p>在下面的代码中，单调栈使用数组实现，数组最左侧为栈底。使用数组实现，可以直接从左到右遍历数组得到最大子序列。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123;        int m &#x3D; nums1.size(), n &#x3D; nums2.size();        vector&lt;int&gt; maxSubsequence(k, 0); &#x2F;&#x2F; 存储最大的子序列结果        int start &#x3D; max(0, k - n), end &#x3D; min(k, m); &#x2F;&#x2F; 确定子序列长度的起始和结束范围        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;            vector&lt;int&gt; subsequence1(MaxSubsequence(nums1, i)); &#x2F;&#x2F; 从nums1中取i个数字组成的最大子序列            vector&lt;int&gt; subsequence2(MaxSubsequence(nums2, k - i)); &#x2F;&#x2F; 从nums2中取k-i个数字组成的最大子序列            vector&lt;int&gt; curMaxSubsequence(merge(subsequence1, subsequence2)); &#x2F;&#x2F; 合并两个子序列得到当前最大结果            if (compare(curMaxSubsequence, 0, maxSubsequence, 0) &gt; 0) &#123;                maxSubsequence.swap(curMaxSubsequence); &#x2F;&#x2F; 如果当前最大结果更大，则更新maxSubsequence            &#125;        &#125;        return maxSubsequence; &#x2F;&#x2F; 返回最终的最大子序列结果    &#125;    vector&lt;int&gt; MaxSubsequence(vector&lt;int&gt;&amp; nums, int k) &#123;        int length &#x3D; nums.size();        vector&lt;int&gt; stack(k, 0); &#x2F;&#x2F; 使用stack来构建最大子序列        int top &#x3D; -1;        int remain &#x3D; length - k; &#x2F;&#x2F; 记录还需要丢弃的数字个数        for (int i &#x3D; 0; i &lt; length; i++) &#123;            int num &#x3D; nums[i];            while (top &gt;&#x3D; 0 &amp;&amp; stack[top] &lt; num &amp;&amp; remain &gt; 0) &#123;                top--; &#x2F;&#x2F; 当前数字比栈顶元素大，可以丢弃栈顶元素，继续判断下一个栈顶元素                remain--; &#x2F;&#x2F; 更新需要丢弃的数字个数            &#125;            if (top &lt; k - 1) &#123;                stack[++top] &#x3D; num; &#x2F;&#x2F; 将当前数字加入栈中            &#125; else &#123;                remain--; &#x2F;&#x2F; 否则，当前数字比栈顶元素小，丢弃当前数字，继续判断下一个数字            &#125;        &#125;        return stack; &#x2F;&#x2F; 返回最终构建的最大子序列    &#125;    vector&lt;int&gt; merge(vector&lt;int&gt;&amp; subsequence1, vector&lt;int&gt;&amp; subsequence2) &#123;        int x &#x3D; subsequence1.size(), y &#x3D; subsequence2.size();        if (x &#x3D;&#x3D; 0) &#123;            return subsequence2; &#x2F;&#x2F; 如果subsequence1为空，则直接返回subsequence2        &#125;        if (y &#x3D;&#x3D; 0) &#123;            return subsequence1; &#x2F;&#x2F; 如果subsequence2为空，则直接返回subsequence1        &#125;        int mergeLength &#x3D; x + y;        vector&lt;int&gt; merged(mergeLength); &#x2F;&#x2F; 合并结果的数组        int index1 &#x3D; 0, index2 &#x3D; 0;        for (int i &#x3D; 0; i &lt; mergeLength; i++) &#123;            if (compare(subsequence1, index1, subsequence2, index2) &gt; 0) &#123;                merged[i] &#x3D; subsequence1[index1++]; &#x2F;&#x2F; 如果subsequence1的当前元素较大，则加入到合并结果中            &#125; else &#123;                merged[i] &#x3D; subsequence2[index2++]; &#x2F;&#x2F; 否则，加入subsequence2的当前元素到合并结果中            &#125;        &#125;        return merged; &#x2F;&#x2F; 返回合并的结果    &#125;    int compare(vector&lt;int&gt;&amp; subsequence1, int index1, vector&lt;int&gt;&amp; subsequence2, int index2) &#123;        int x &#x3D; subsequence1.size(), y &#x3D; subsequence2.size();        while (index1 &lt; x &amp;&amp; index2 &lt; y) &#123;            int difference &#x3D; subsequence1[index1] - subsequence2[index2];            if (difference !&#x3D; 0) &#123;                return difference; &#x2F;&#x2F; 比较两个子序列当前位置的元素，不相等则直接返回差值            &#125;            index1++; &#x2F;&#x2F; 继续比较下一个位置            index2++;        &#125;        return (x - index1) - (y - index2); &#x2F;&#x2F; 返回长度较长的子序列对应位置多出的元素个数    &#125;&#125;;</code></pre><hr><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/create-maximum-number/solutions/505931/pin-jie-zui-da-shu-by-leetcode-solution/">https://leetcode.cn/problems/create-maximum-number/solutions/505931/pin-jie-zui-da-shu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定长度分别为 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 的两个数组，其元素由 &lt;code&gt;0-9&lt;/code&gt; 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 &lt;code&gt;k (k &amp;lt;= m + n)&lt;/code&gt; 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。&lt;/p&gt;
&lt;p&gt;求满足该条件的最大数。结果返回一个表示该最大数的长度为 &lt;code&gt;k&lt;/code&gt; 的数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 请尽可能地优化你算法的时间和空间复杂度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode636.函数的独占时间</title>
    <link href="2023/07/27/leetcode636-%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/"/>
    <id>2023/07/27/leetcode636-%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/</id>
    <published>2023-07-27T02:22:56.000Z</published>
    <updated>2023-07-27T02:25:30.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一个 <strong>单线程</strong> CPU 正在运行一个含有 <code>n</code> 道函数的程序。每道函数都有一个位于 <code>0</code> 和 <code>n-1</code> 之间的唯一标识符。</p><p>函数调用 <strong>存储在一个 <a href="https://baike.baidu.com/item/%E8%B0%83%E7%94%A8%E6%A0%88/22718047?fr=aladdin">调用栈</a> 上</strong> ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 <strong>当前正在执行的函数</strong> 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。</p><p>给你一个由日志组成的列表 <code>logs</code> ，其中 <code>logs[i]</code> 表示第 <code>i</code> 条日志消息，该消息是一个按 <code>&quot;&#123;function_id&#125;:&#123;&quot;start&quot; | &quot;end&quot;&#125;:&#123;timestamp&#125;&quot;</code> 进行格式化的字符串。例如，<code>&quot;0:start:3&quot;</code> 意味着标识符为 <code>0</code> 的函数调用在时间戳 <code>3</code> 的 <strong>起始开始执行</strong> ；而 <code>&quot;1:end:2&quot;</code> 意味着标识符为 <code>1</code> 的函数调用在时间戳 <code>2</code> 的 <strong>末尾结束执行</strong>。注意，函数可以 <strong>调用多次，可能存在递归调用</strong> 。</p><p>函数的 <strong>独占时间</strong> 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 <code>2</code> 单位时间，另一次调用执行 <code>1</code> 单位时间，那么该函数的 <strong>独占时间</strong> 为 <code>2 + 1 = 3</code> 。</p><p>以数组形式返回每个函数的 <strong>独占时间</strong> ，其中第 <code>i</code> 个下标对应的值表示标识符 <code>i</code> 的函数的独占时间。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/diag1b.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2, logs &#x3D; [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]输出：[3,4]解释：函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 所以函数 0 总共执行 2 + 1 &#x3D; 3 个单位时间，函数 1 总共执行 4 个单位时间。 </code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;0:start:6&quot;,&quot;0:end:6&quot;,&quot;0:end:7&quot;]输出：[8]解释：函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。函数 0（初始调用）恢复执行，并立刻再次调用它自身。函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。所以函数 0 总共执行 2 + 4 + 1 + 1 &#x3D; 8 个单位时间。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:6&quot;,&quot;1:end:6&quot;,&quot;0:end:7&quot;]输出：[7,1]解释：函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。函数 0（初始调用）恢复执行，并立刻调用函数 1 。函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。所以函数 0 总共执行 2 + 4 + 1 &#x3D; 7 个单位时间，函数 1 总共执行 1 个单位时间。 </code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:7&quot;,&quot;1:end:7&quot;,&quot;0:end:8&quot;]输出：[8,1]</code></pre><p><strong>示例 5：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:end:0&quot;]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= logs.length &lt;= 500</code></li><li><code>0 &lt;= function_id &lt; n</code></li><li><code>0 &lt;= timestamp &lt;= 109</code></li><li>两个开始事件不会在同一时间戳发生</li><li>两个结束事件不会在同一时间戳发生</li><li>每道函数都有一个对应 <code>&quot;start&quot;</code> 日志的 <code>&quot;end&quot;</code> 日志</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>题目要求计算多个函数在单线程CPU上的独占执行时间。给定一个由字符串日志组成的数组，每条日志包含函数的ID、开始或结束标志以及时间戳。函数可能嵌套调用，但始终是先开始再结束。要求计算每个函数的独占执行时间，返回一个长度为n的数组，其中n是函数的数量。</p><p>解题思路如下：</p><ol><li>定义一个结构体<code>FunctionCall</code>来保存函数的ID、时间戳、开始或结束标志以及执行时长。</li><li>创建一个长度为n的结果数组<code>result</code>，用于保存每个函数的独占执行时间，并初始化为0。</li><li>创建一个栈<code>callStack</code>用于保存当前正在执行的函数调用。</li><li>遍历给定的日志数组，对每条日志进行解析：<ul><li>提取函数的ID、开始或结束标志和时间戳。</li><li>若为函数开始日志：<ul><li>若栈非空，则更新栈顶函数的执行时间（上一个函数的执行时间）：当前时间戳减去栈顶函数的时间戳。</li><li>将当前函数加入调用栈。</li></ul></li><li>若为函数结束日志：<ul><li>弹出当前函数，并计算当前函数的执行时间：当前时间戳减去栈顶函数的时间戳加1。</li><li>更新栈顶函数的时间戳为当前时间戳加1（因为当前函数执行完毕后，接下来执行的代码时间戳从当前时间戳的下一时刻开始）。</li></ul></li></ul></li><li>返回结果数组<code>result</code>。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    struct FunctionCall &#123;    int id;       &#x2F;&#x2F; 函数ID    int timestamp; &#x2F;&#x2F; 时间戳    bool isStart; &#x2F;&#x2F; 是否是函数开始    int duration; &#x2F;&#x2F; 函数执行时长    &#125;;    vector&lt;int&gt; exclusiveTime(int n, vector&lt;string&gt;&amp; logs) &#123;        vector&lt;int&gt; result(n, 0);        stack&lt;FunctionCall&gt; callStack;        for (const string&amp; log : logs) &#123;            stringstream ss(log);            string token;            &#x2F;&#x2F; 提取日志信息并解析            getline(ss, token, &#39;:&#39;);            int functionId &#x3D; stoi(token);            getline(ss, token, &#39;:&#39;);            string startOrEnd &#x3D; token &#x3D;&#x3D; &quot;start&quot; ? &quot;start&quot; : &quot;end&quot;;            bool isStart &#x3D; (startOrEnd &#x3D;&#x3D; &quot;start&quot;);            getline(ss, token, &#39;:&#39;);            int timestamp &#x3D; stoi(token);            &#x2F;&#x2F; 处理函数调用            if (isStart) &#123;                if (!callStack.empty()) &#123;                    &#x2F;&#x2F; 更新上一个函数的执行时长                    FunctionCall&amp; prevCall &#x3D; callStack.top();                    result[prevCall.id] +&#x3D; timestamp - prevCall.timestamp;                &#125;                &#x2F;&#x2F; 将当前函数加入调用栈                callStack.push(&#123; functionId, timestamp, true, 0 &#125;);            &#125; else &#123;                &#x2F;&#x2F; 弹出当前函数，并计算执行时长                FunctionCall currentCall &#x3D; callStack.top();                callStack.pop();                int currentDuration &#x3D; timestamp - currentCall.timestamp + 1;                result[currentCall.id] +&#x3D; currentDuration;                &#x2F;&#x2F; 若栈非空，更新上一个函数的执行时长                if (!callStack.empty()) &#123;                    FunctionCall&amp; prevCall &#x3D; callStack.top();                    prevCall.timestamp &#x3D; timestamp + 1;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;有一个 &lt;strong&gt;单线程&lt;/strong&gt; CPU 正在运行一个含有 &lt;code&gt;n&lt;/code&gt; 道函数的程序。每道函数都有一个位于 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;n-1&lt;/code&gt; 之间的唯一标识符。&lt;/p&gt;
&lt;p&gt;函数调用 &lt;strong&gt;存储在一个 &lt;a href=&quot;https://baike.baidu.com/item/%E8%B0%83%E7%94%A8%E6%A0%88/22718047?fr=aladdin&quot;&gt;调用栈&lt;/a&gt; 上&lt;/strong&gt; ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 &lt;strong&gt;当前正在执行的函数&lt;/strong&gt; 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。&lt;/p&gt;
&lt;p&gt;给你一个由日志组成的列表 &lt;code&gt;logs&lt;/code&gt; ，其中 &lt;code&gt;logs[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 条日志消息，该消息是一个按 &lt;code&gt;&amp;quot;&amp;#123;function_id&amp;#125;:&amp;#123;&amp;quot;start&amp;quot; | &amp;quot;end&amp;quot;&amp;#125;:&amp;#123;timestamp&amp;#125;&amp;quot;&lt;/code&gt; 进行格式化的字符串。例如，&lt;code&gt;&amp;quot;0:start:3&amp;quot;&lt;/code&gt; 意味着标识符为 &lt;code&gt;0&lt;/code&gt; 的函数调用在时间戳 &lt;code&gt;3&lt;/code&gt; 的 &lt;strong&gt;起始开始执行&lt;/strong&gt; ；而 &lt;code&gt;&amp;quot;1:end:2&amp;quot;&lt;/code&gt; 意味着标识符为 &lt;code&gt;1&lt;/code&gt; 的函数调用在时间戳 &lt;code&gt;2&lt;/code&gt; 的 &lt;strong&gt;末尾结束执行&lt;/strong&gt;。注意，函数可以 &lt;strong&gt;调用多次，可能存在递归调用&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;函数的 &lt;strong&gt;独占时间&lt;/strong&gt; 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 &lt;code&gt;2&lt;/code&gt; 单位时间，另一次调用执行 &lt;code&gt;1&lt;/code&gt; 单位时间，那么该函数的 &lt;strong&gt;独占时间&lt;/strong&gt; 为 &lt;code&gt;2 + 1 = 3&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;以数组形式返回每个函数的 &lt;strong&gt;独占时间&lt;/strong&gt; ，其中第 &lt;code&gt;i&lt;/code&gt; 个下标对应的值表示标识符 &lt;code&gt;i&lt;/code&gt; 的函数的独占时间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode456.132模式</title>
    <link href="2023/07/26/leetcode456-132%E6%A8%A1%E5%BC%8F/"/>
    <id>2023/07/26/leetcode456-132%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-26T13:04:37.000Z</published>
    <updated>2023-07-26T13:09:20.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成，并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code> 。</p><p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,3,4]输出：false解释：序列中不存在 132 模式的子序列。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,1,4,2]输出：true解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-1,3,2,0]输出：true解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 2 * 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>单调栈</li></ul><p>要解决这个问题，我们可以使用单调栈。我们需要寻找132模式的形式，即[i,j,k]，其中nums[i]&lt;nums[k]&lt;nums[j]。对于每个元素nums[j]，我们需要找到最小的nums[i]和nums[k]。我们可以从右到左遍历数组，维护一个单调递减的栈，栈中存放的是可能作为nums[k]的候选元素，然后我们在栈中寻找比nums[j]小的元素来充当nums[i]。</p><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;stack&gt;bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;    int n &#x3D; nums.size();    if (n &lt; 3)        return false;    int third &#x3D; INT_MIN; &#x2F;&#x2F; 初始化为负无穷，用于存放nums[k]    stack&lt;int&gt; st; &#x2F;&#x2F; 用于存放nums[k]的单调递减栈    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;        if (nums[i] &lt; third)            return true; &#x2F;&#x2F; 如果存在满足条件的nums[i]、nums[j]和nums[k]，则返回true        while (!st.empty() &amp;&amp; nums[i] &gt; st.top()) &#123;            third &#x3D; st.top();            st.pop();        &#125;        st.push(nums[i]);    &#125;    return false;&#125;</code></pre><p>这样，我们就可以使用单调栈在O(n)的时间复杂度内解决这个问题。注意，由于我们使用了额外的栈，空间复杂度为O(n)。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，数组中共有 &lt;code&gt;n&lt;/code&gt; 个整数。&lt;strong&gt;132 模式的子序列&lt;/strong&gt; 由三个整数 &lt;code&gt;nums[i]&lt;/code&gt;、&lt;code&gt;nums[j]&lt;/code&gt; 和 &lt;code&gt;nums[k]&lt;/code&gt; 组成，并同时满足：&lt;code&gt;i &amp;lt; j &amp;lt; k&lt;/code&gt; 和 &lt;code&gt;nums[i] &amp;lt; nums[k] &amp;lt; nums[j]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;nums&lt;/code&gt; 中存在 &lt;strong&gt;132 模式的子序列&lt;/strong&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode589.N叉树的前序遍历</title>
    <link href="2023/07/25/leetcode589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>2023/07/25/leetcode589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-07-25T02:50:29.000Z</published>
    <updated>2023-07-25T03:29:56.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n 叉树的根节点 <code>root</code> ，返回 <em>其节点值的 <strong>前序遍历</strong></em> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/narytreeexample-20230725105312155.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,null,3,2,4,null,5,6]输出：[1,3,5,6,2,4]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/sample_4_964-20230725105314652.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</code></pre><p><strong>提示：</strong></p><ul><li>节点总数在范围 <code>[0, 104]</code>内</li><li><code>0 &lt;= Node.val &lt;= 104</code></li><li>n 叉树的高度小于或等于 <code>1000</code></li></ul><p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;*&#x2F;&#x2F; Definition for a Node.class Node &#123;public:    int val;    vector&lt;Node*&gt; children;    Node() &#123;&#125;    Node(int _val) &#123;        val &#x3D; _val;    &#125;    Node(int _val, vector&lt;Node*&gt; _children) &#123;        val &#x3D; _val;        children &#x3D; _children;    &#125;&#125;;*&#x2F;class Solution &#123;public:    vector&lt;int&gt; preorder(Node* root) &#123;        &#x2F;&#x2F; 结果数组result的定义        vector&lt;int&gt; result;        &#x2F;&#x2F; 如果root为空，则直接返回空数组        if (!root) return result;        &#x2F;&#x2F; 如果root不为空，则开始前序遍历        preorderHelper(root, result);        &#x2F;&#x2F; 遍历结束返回结果数组        return result;    &#125;    void preorderHelper(Node* node, vector&lt;int&gt;&amp; finalResult) &#123;        if (!node) return; &#x2F;&#x2F; 递归的终止条件：结点为空        finalResult.push_back(node-&gt;val); &#x2F;&#x2F; 前序遍历        for (Node* child: node-&gt;children) &#123; &#x2F;&#x2F; 获取当前结点的子结点            &#x2F;&#x2F; 然后分别每一个子结点进行前序遍历            preorderHelper(child, finalResult);         &#125;    &#125;&#125;;</code></pre><ul><li>迭代法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;*&#x2F;&#x2F; Definition for a Node.class Node &#123;public:    int val;    vector&lt;Node*&gt; children;    Node() &#123;&#125;    Node(int _val) &#123;        val &#x3D; _val;    &#125;    Node(int _val, vector&lt;Node*&gt; _children) &#123;        val &#x3D; _val;        children &#x3D; _children;    &#125;&#125;;*&#x2F;class Solution &#123;public:    vector&lt;int&gt; preorder(Node* root) &#123;        stack&lt;Node*&gt; st; &#x2F;&#x2F; 使用栈，先进后出        vector&lt;int&gt; result; &#x2F;&#x2F; 结果数组的定义        if (!root) return result;        st.push(root); &#x2F;&#x2F; 将根节点入栈        while (!st.empty()) &#123; &#x2F;&#x2F; 当栈非空时            Node* node &#x3D; st.top(); &#x2F;&#x2F; 将栈顶的元素赋值给node            st.pop(); &#x2F;&#x2F; 出栈            result.push_back(node-&gt;val); &#x2F;&#x2F; 前序遍历            for (int i &#x3D; node-&gt;children.size() - 1; i &gt;&#x3D; 0; i--) &#123;                if (node-&gt;children[i] !&#x3D; NULL) &#123;                    st.push(node-&gt;children[i]); &#x2F;&#x2F; 从右往左进行入栈操作                &#125;            &#125;        &#125;        return result; &#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个 n 叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回 &lt;em&gt;其节点值的 &lt;strong&gt;前序遍历&lt;/strong&gt;&lt;/e</summary>
      
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode590.N叉树的后序遍历</title>
    <link href="2023/07/24/leetcode590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>2023/07/24/leetcode590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-07-24T03:22:59.000Z</published>
    <updated>2023-07-24T03:39:27.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n 叉树的根节点 <code>root</code> ，返回 <em>其节点值的 <strong>后序遍历</strong></em> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/narytreeexample.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,null,3,2,4,null,5,6]输出：[5,6,3,2,4,1]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/sample_4_964.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]</code></pre><p><strong>提示：</strong></p><ul><li>节点总数在范围 <code>[0, 104]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 104</code></li><li>n 叉树的高度小于或等于 <code>1000</code></li></ul><p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归法</li></ul><p>直接上代码。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;*&#x2F;&#x2F; Definition for a Node.class Node &#123;public:    int val;    vector&lt;Node*&gt; children;    Node() &#123;&#125;    Node(int _val) &#123;        val &#x3D; _val;    &#125;    Node(int _val, vector&lt;Node*&gt; _children) &#123;        val &#x3D; _val;        children &#x3D; _children;    &#125;&#125;;*&#x2F;class Solution &#123;public:    vector&lt;int&gt; postorder(Node* root) &#123;        vector&lt;int&gt; result;        if (!root) return result;                postorderHelper(root, result);        return result;    &#125;        &#x2F;&#x2F; 后序遍历辅助函数    void postorderHelper(Node* node, vector&lt;int&gt;&amp; result) &#123;        if (!node) return;                for (Node* child : node-&gt;children) &#123;            postorderHelper(child, result);        &#125;                result.push_back(node-&gt;val);    &#125;&#125;;</code></pre><ul><li>迭代法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;*&#x2F;&#x2F; Definition for a Node.class Node &#123;public:    int val;    vector&lt;Node*&gt; children;    Node() &#123;&#125;    Node(int _val) &#123;        val &#x3D; _val;    &#125;    Node(int _val, vector&lt;Node*&gt; _children) &#123;        val &#x3D; _val;        children &#x3D; _children;    &#125;&#125;;*&#x2F;class Solution &#123;public:    vector&lt;int&gt; postorder(Node* root) &#123;        vector&lt;int&gt; result;        if (root &#x3D;&#x3D; NULL) return result;        stack&lt;Node*&gt; st;        st.push(root);        while (!st.empty()) &#123;            Node* node &#x3D; st.top();            st.pop();            result.push_back(node-&gt;val);            for (int i &#x3D; 0; i &lt; node-&gt;children.size(); i++) &#123; &#x2F;&#x2F; 相对于前序遍历，这里反过来                if (node-&gt;children[i] !&#x3D; NULL) &#123;                    st.push(node-&gt;children[i]);                &#125;            &#125;        &#125;        reverse(result.begin(), result.end()); &#x2F;&#x2F; 反转数组        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个 n 叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回 &lt;em&gt;其节点值的 &lt;strong&gt;后序遍历&lt;/strong&gt;&lt;/e</summary>
      
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode980.不同路径III</title>
    <link href="2023/07/21/leetcode980-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III/"/>
    <id>2023/07/21/leetcode980-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84III/</id>
    <published>2023-07-21T01:12:46.000Z</published>
    <updated>2023-07-21T01:26:26.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在二维网格 <code>grid</code> 上，有 4 种类型的方格：</p><ul><li><code>1</code> 表示起始方格。且只有一个起始方格。</li><li><code>2</code> 表示结束方格，且只有一个结束方格。</li><li><code>0</code> 表示我们可以走过的空方格。</li><li><code>-1</code> 表示我们无法跨越的障碍。</li></ul><p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目<strong>。</strong></p><p><strong>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格</strong>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]输出：2解释：我们有以下两条路径：1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]输出：4解释：我们有以下四条路径： 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：[[0,1],[2,0]]输出：0解释：没有一条路能完全穿过每一个空的方格一次。请注意，起始和结束方格可以位于网格中的任意位置。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length * grid[0].length &lt;= 20</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><blockquote><p> 答案所要求的路径其实就是从1到2在没有经过重复的位置的情况下长度为<br>【0的个数 + 2】的路径 所以其实可以直接dfs，并在dfs时记录路径的长度，当我们走到2的位置的时候，检查路径长度是否足够长即可。为了避免走重复的位置，我们在经过一个位置时将该位置标记为-1，递归函数结束时恢复为0即可。</p></blockquote><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int uniquePathsIII(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int m &#x3D; grid.size(), n &#x3D; grid[0].size();        &#x2F;&#x2F; 定义四个方向的偏移量，用于遍历上、下、左、右四个方向        short dis_x[] &#x3D; &#123;1, -1, 0, 0&#125;, dis_y[] &#x3D; &#123;0, 0, 1, -1&#125;;        int ret &#x3D; 0;        &#x2F;&#x2F; x1, y1是起点（值为1）的坐标，x2, y2是终点（值为2）的坐标，len是目标长度（包括起点和终点）        int x1, y1, x2, y2, len &#x3D; 2;        &#x2F;&#x2F; 遍历整个矩阵，计算0的个数，以及获取1和2的坐标        for (int i &#x3D; 0; i &lt; m; ++i) &#123;            for (int j &#x3D; 0; j &lt; n; ++j) &#123;                switch (grid[i][j]) &#123;                    case 0: &#x2F;&#x2F; 值为0，代表可访问的空格，目标长度len需要加1                        ++len;                        break;                    case 1: &#x2F;&#x2F; 值为1，代表起点                        x1 &#x3D; i;                        y1 &#x3D; j;                        break;                    case 2: &#x2F;&#x2F; 值为2，代表终点                        x2 &#x3D; i;                        y2 &#x3D; j;                        break;                &#125;            &#125;        &#125;                &#x2F;&#x2F; 定义深度优先搜索函数，使用lambda表达式        function&lt;void(int, int, int)&gt; dfs &#x3D; [&amp;](int x, int y, int cnt) &#123;            if (x &#x3D;&#x3D; x2 &amp;&amp; y &#x3D;&#x3D; y2) &#123; &#x2F;&#x2F; 如果当前坐标为终点坐标                if (cnt &#x3D;&#x3D; len) &#x2F;&#x2F; 如果路径长度等于目标长度（包括起点和终点），则结果ret加1                    ++ret;                return;            &#125;            grid[x][y] &#x3D; -1; &#x2F;&#x2F; 将当前坐标标记为已访问（-1）            for (int i &#x3D; 0; i &lt; 4; ++i) &#123; &#x2F;&#x2F; 尝试向四个方向进行搜索                int nx &#x3D; dis_x[i] + x; &#x2F;&#x2F; 计算下一个搜索位置的横坐标                int ny &#x3D; dis_y[i] + y; &#x2F;&#x2F; 计算下一个搜索位置的纵坐标                &#x2F;&#x2F; 检查下一个搜索位置是否合法（在矩阵范围内且不为已访问的位置）                if (nx &gt;&#x3D; 0 &amp;&amp; ny &gt;&#x3D; 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] !&#x3D; -1) &#123;                    dfs(nx, ny, cnt + 1); &#x2F;&#x2F; 继续向下一个位置进行搜索，路径长度加1                &#125;            &#125;            grid[x][y] &#x3D; 0; &#x2F;&#x2F; 恢复当前坐标的值为0，表示当前位置未被访问        &#125;;                dfs(x1, y1, 1); &#x2F;&#x2F; 调用深度优先搜索函数，初始长度为1（起点）        return ret; &#x2F;&#x2F; 返回结果    &#125;&#125;;</code></pre><hr><p>作者：吸鼠霸王<br>链接：<a href="https://leetcode.cn/problems/unique-paths-iii/solutions/2212729/dfs-hui-su-by-v-me-50-l178/">https://leetcode.cn/problems/unique-paths-iii/solutions/2212729/dfs-hui-su-by-v-me-50-l178/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在二维网格 &lt;code&gt;grid&lt;/code&gt; 上，有 4 种类型的方格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 表示起始方格。且只有一个起始方格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2&lt;/code&gt; 表示结束方格，且只有一个结束方格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 表示我们可以走过的空方格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-1&lt;/code&gt; 表示我们无法跨越的障碍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode77.组合</title>
    <link href="2023/07/21/leetcode77-%E7%BB%84%E5%90%88/"/>
    <id>2023/07/21/leetcode77-%E7%BB%84%E5%90%88/</id>
    <published>2023-07-21T00:58:17.000Z</published>
    <updated>2023-07-21T01:01:23.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4, k &#x3D; 2输出：[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1, k &#x3D; 1输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接采用回溯法</li></ul><p>回溯法的统一伪代码：</p><pre class="language-none"><code class="language-none">void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); &#x2F;&#x2F; 递归        回溯，撤销处理结果    &#125;&#125;</code></pre><p>因此本题的C++代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result; &#x2F;&#x2F; 存放符合条件结果的集合    vector&lt;int&gt; path; &#x2F;&#x2F; 用来存放符合条件结果    void backtracking(int n, int k, int startIndex) &#123;        if (path.size() &#x3D;&#x3D; k) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt;&#x3D; n - (k - path.size()) + 1; i++) &#123;            path.push_back(i); &#x2F;&#x2F; 处理节点            backtracking(n, k, i + 1); &#x2F;&#x2F; 递归            path.pop_back(); &#x2F;&#x2F; 回溯，撤销处理的节点        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;        result.clear(); &#x2F;&#x2F; 可以不写        path.clear();   &#x2F;&#x2F; 可以不写        backtracking(n, k, 1); &#x2F;&#x2F; 递归        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;，返回范围 &lt;code&gt;[1, n]&lt;/code&gt; 中所有可能的 &lt;code&gt;k&lt;/code&gt; 个数的组合。&lt;/p&gt;
&lt;p&gt;你可以按 &lt;strong&gt;任何顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode17.电话号码的字母组合</title>
    <link href="2023/07/18/leetcode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>2023/07/18/leetcode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</id>
    <published>2023-07-18T00:56:06.000Z</published>
    <updated>2023-07-18T01:01:57.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><span id="more"></span><p><img src="http://cdn.leafii.top/img/200px-telephone-keypad2svg.png" alt="img" loading="lazy"></p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：digits &#x3D; &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：digits &#x3D; &quot;&quot;输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：digits &#x3D; &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>回溯法</li></ul><p>理解本题后，要解决如下三个问题：</p><ol><li>数字和字母如何映射？使用二维数组即可。</li><li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来，此时的思路就是使用增加了遍历深度的参数的辅助函数进行辅助，得到一种符合要求的结果后进行回溯继续遍历。</li><li>输入1 * #按键等等异常情况（异常情况在leetcode样例中不存在，所以不考虑也没关系）</li></ol><p>C++代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    &#x2F;&#x2F; 字母和数字的映射    const string letterMap[10] &#x3D; &#123;        &quot;&quot;, &#x2F;&#x2F; 0        &quot;&quot;, &#x2F;&#x2F; 1        &quot;abc&quot;, &#x2F;&#x2F; 2        &quot;def&quot;, &#x2F;&#x2F; 3        &quot;ghi&quot;, &#x2F;&#x2F; 4        &quot;jkl&quot;, &#x2F;&#x2F; 5        &quot;mno&quot;, &#x2F;&#x2F; 6        &quot;pqrs&quot;, &#x2F;&#x2F; 7        &quot;tuv&quot;, &#x2F;&#x2F; 8        &quot;wxyz&quot;, &#x2F;&#x2F; 9    &#125;;public:    vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储最终结果的全局变量动态数组result    string s; &#x2F;&#x2F; 用于临时存储一个组合的字符串s    void backtracking(const string&amp; digits, int index) &#123;        &#x2F;&#x2F; 辅助函数，增加了一个index用于辅助遍历的过程，index表示遍历到digits的第几位        if (index &#x3D;&#x3D; digits.size()) &#123;            &#x2F;&#x2F; 判断index是否和digits的大小相等，如果相等则说明当前已经遍历完了最后一位            result.push_back(s); &#x2F;&#x2F; 此时直接把保存的字符串s放进结果数组result中即可            return; &#x2F;&#x2F; 遍历结束直接return        &#125;        int digit &#x3D; digits[index] - &#39;0&#39;; &#x2F;&#x2F; 把字符串中的单个数字转为int类型        string letters &#x3D; letterMap[digit]; &#x2F;&#x2F; 通过获得的int类型数字得到对应的字符串映射        for (int i &#x3D; 0; i &lt; letters.size(); i++) &#123;            s.push_back(letters[i]); &#x2F;&#x2F; 将第i个字母进行push            backtracking(digits, index + 1); &#x2F;&#x2F; 递归进一步遍历            s.pop_back(); &#x2F;&#x2F; 回溯        &#125;    &#125;    vector&lt;string&gt; letterCombinations(string digits) &#123;        s.clear(); &#x2F;&#x2F; 初始化参数        result.clear(); &#x2F;&#x2F; 初始化参数        if (digits.size() &#x3D;&#x3D; 0) return result; &#x2F;&#x2F; 如果digits数组的长度为0 直接返回空结果数组        backtracking(digits, 0); &#x2F;&#x2F; 递归调用，从0开始遍历        return result; &#x2F;&#x2F; 返回最终的结果数组    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。答案可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode401.二进制手表</title>
    <link href="2023/07/17/leetcode401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/"/>
    <id>2023/07/17/leetcode401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</id>
    <published>2023-07-17T12:39:41.000Z</published>
    <updated>2023-07-17T12:54:24.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>二进制手表顶部有 4 个 LED 代表 <strong>小时（0-11）</strong>，底部的 6 个 LED 代表 <strong>分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p><ul><li>例如，下面的二进制手表读取 <code>&quot;3:25&quot;</code> 。</li></ul><p><img src="http://cdn.leafii.top/img/binary_clock_samui_moon.jpg" alt="img" loading="lazy"></p><p><em>（图源：<a href="https://commons.m.wikimedia.org/wiki/File:Binary_clock_samui_moon.jpg">WikiMedia - Binary clock samui moon.jpg</a> ，许可协议：<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.en">Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)</a> ）</em></p><p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>小时不会以零开头：</p><ul><li>例如，<code>&quot;01:00&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;1:00&quot;</code> 。</li></ul><p>分钟必须由两位数组成，可能会以零开头：</p><ul><li>例如，<code>&quot;10:2&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;10:02&quot;</code> 。</li></ul><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：turnedOn &#x3D; 1输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：turnedOn &#x3D; 9输出：[]</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= turnedOn &lt;= 10</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>基础的解法：</li></ul><p>思路：</p><ol><li>创建一个函数 <code>countBits</code>，用于计算一个整数中二进制表示中 1 的个数。该函数可以使用位运算的技巧来进行计算，例如通过不断将数字右移并与 1 进行按位与操作来判断最低位是否为 1。</li><li>在 <code>readBinaryWatch</code> 函数内部，创建一个空的结果数组 <code>result</code>。</li><li>使用两个嵌套的循环，外层循环遍历小时的取值范围从 0 到 11，内层循环遍历分钟的取值范围从 0 到 59。</li><li>对于每个小时和分钟的组合，计算二进制表示中 1 的个数。如果小时的二进制表示中 1 的个数加上分钟的二进制表示中 1 的个数等于给定的 <code>turnedOn</code>，则该组合满足要求。</li><li>如果满足要求，将小时和分钟格式化为时间字符串，并将其添加到结果数组 <code>result</code> 中。</li><li>循环结束后，返回结果数组 <code>result</code>。</li></ol><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;string&gt; readBinaryWatch(int turnedOn) &#123;        vector&lt;string&gt; result;        for (int hour &#x3D; 0; hour &lt; 12; hour++) &#123;            int hourCount &#x3D; countBits(hour);            for (int min &#x3D; 0; min &lt;&#x3D; 59; min++) &#123;                int minCount &#x3D; countBits(min);                if (hourCount + minCount &#x3D;&#x3D; turnedOn) &#123;                     &#x2F;&#x2F; 如果时间符合要求                    result.push_back(makeTime(hour, min));                &#125;            &#125;        &#125;        return result;    &#125;    int countBits(int num) &#123;         &#x2F;&#x2F; 计算一个整数中二进制表示中 1 的个数        int count &#x3D; 0;        while (num !&#x3D; 0) &#123;            count +&#x3D; num &amp; 1;            num &gt;&gt;&#x3D; 1;        &#125;        return count;    &#125;    string makeTime(int hour, int min) &#123;        &#x2F;&#x2F; 用于将符合条件的时间组装成符合要求的字符串并返回        string answer  &#x3D; to_string(hour) + &quot;:&quot; + (min &lt; 10 ? &quot;0&quot; : &quot;&quot;) + to_string(min);        return answer;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;二进制手表顶部有 4 个 LED 代表 &lt;strong&gt;小时（0-11）&lt;/strong&gt;，底部的 6 个 LED 代表 &lt;strong&gt;分</summary>
      
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode191.位1的个数</title>
    <link href="2023/07/17/leetcode191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>2023/07/17/leetcode191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2023-07-17T11:57:38.000Z</published>
    <updated>2023-07-17T12:01:54.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p> <span id="more"></span><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><p><strong>进阶</strong>：</p><ul><li>如果多次调用这个函数，你将如何优化你的算法？</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>循环求解</li></ul><p>思路：当输入的数字为n时，我们想判断它的二进制数字的最后一位是否为1，可以使用<code>n &amp; 1</code>得到，如果结果为1，则说明他的最后一位是1，否则则为0，当判断完最后一位时，我们直接使用<code>&gt;&gt;</code>对n进行除以2的操作。C++代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int hammingWeight(uint32_t n) &#123;        int count &#x3D; 0; &#x2F;&#x2F; 初始化答案        while (n !&#x3D; 0) &#123;            count +&#x3D; n &amp; 1; &#x2F;&#x2F; 检查最低位是否为 1            n &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 将数字右移一位，相当于除以 2        &#125;        return count; &#x2F;&#x2F; 返回count值    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为&lt;a href=&quot;https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F&quot;&gt;汉明重量&lt;/a&gt;）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode701.二叉搜索树中的插入操作</title>
    <link href="2023/06/29/leetcode701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <id>2023/06/29/leetcode701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</id>
    <published>2023-06-29T09:06:58.000Z</published>
    <updated>2023-06-29T09:16:54.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5输出：[4,2,7,1,3,5]解释：另一个满足题目要求可以通过的树是：</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25输出：[40,20,60,10,30,50,70,null,null,25]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5输出：[4,2,7,1,3,5]</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-108 &lt;= Node.val &lt;= 108</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-108 &lt;= val &lt;= 108</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>见代码</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            &#x2F;&#x2F; 当前节点为空，创建一个新节点并赋值            return new TreeNode(val);        &#125;        if (val &lt; root-&gt;val) &#123;            &#x2F;&#x2F; 要插入的值小于当前节点的值，向左子树递归插入            root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val);        &#125; else &#123;            &#x2F;&#x2F; 要插入的值大于等于当前节点的值，向右子树递归插入            root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val);        &#125;        return root;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定二叉搜索树（BST）的根节点 &lt;code&gt;root&lt;/code&gt; 和要插入树中的值 &lt;code&gt;value&lt;/code&gt; ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 &lt;strong&gt;保证&lt;/strong&gt; ，新值和原始二叉搜索树中的任意节点值都不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 &lt;strong&gt;任意有效的结果&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode450.删除二叉树中的节点</title>
    <link href="2023/06/29/leetcode450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>2023/06/29/leetcode450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2023-06-29T09:06:41.000Z</published>
    <updated>2023-06-29T09:11:20.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol> <span id="more"></span><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3输出：[5,4,6,2,null,null,7]解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0输出: [5,3,6,2,4,null,7]解释: 二叉树不包含值为 0 的节点</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: root &#x3D; [], key &#x3D; 0输出: []</code></pre><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>直接上代码：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* deleteNode(TreeNode* root, int key) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return nullptr;        &#125;        if (root-&gt;val &#x3D;&#x3D; key) &#123;            &#x2F;&#x2F; 当前节点需要删除            if (root-&gt;left &#x3D;&#x3D; nullptr) &#123;                &#x2F;&#x2F; 没有左子树，返回右子树                return root-&gt;right;            &#125; else if (root-&gt;right &#x3D;&#x3D; nullptr) &#123;                &#x2F;&#x2F; 没有右子树，返回左子树                return root-&gt;left;            &#125; else &#123;                &#x2F;&#x2F; 左右子树都存在，找到右子树中的最小节点                TreeNode* minNode &#x3D; findMin(root-&gt;right);                &#x2F;&#x2F; 将最小节点的值赋给当前节点                root-&gt;val &#x3D; minNode-&gt;val;                &#x2F;&#x2F; 在右子树中递归删除最小节点                root-&gt;right &#x3D; deleteNode(root-&gt;right, minNode-&gt;val);            &#125;        &#125; else if (root-&gt;val &gt; key) &#123;            &#x2F;&#x2F; 要删除的值小于当前节点的值，递归在左子树中删除            root-&gt;left &#x3D; deleteNode(root-&gt;left, key);        &#125; else &#123;            &#x2F;&#x2F; 要删除的值大于当前节点的值，递归在右子树中删除            root-&gt;right &#x3D; deleteNode(root-&gt;right, key);        &#125;        return root;    &#125;private:    &#x2F;&#x2F; 在二叉搜索树中找到最小节点    TreeNode* findMin(TreeNode* node) &#123;        while (node-&gt;left !&#x3D; nullptr) &#123;            node &#x3D; node-&gt;left;        &#125;        return node;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉搜索树的根节点 &lt;strong&gt;root&lt;/strong&gt; 和一个值 &lt;strong&gt;key&lt;/strong&gt;，删除二叉搜索树中的 &lt;strong&gt;key&lt;/strong&gt; 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。&lt;/p&gt;
&lt;p&gt;一般来说，删除节点可分为两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先找到需要删除的节点；&lt;/li&gt;
&lt;li&gt;如果找到了，删除它。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode226.翻转二叉树</title>
    <link href="2023/06/28/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/06/28/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-06-28T02:09:48.000Z</published>
    <updated>2023-06-28T02:15:06.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/invert1-tree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/invert2-tree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [2,1,3]输出：[2,3,1]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>深度优先遍历</li></ul><p>使用dfs函数辅助遍历过程。代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL || (root-&gt;left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;right &#x3D;&#x3D; NULL)) &#123;             &#x2F;&#x2F; 如果root为空或者root左右子树都为空，则直接返回root            return root;        &#125;        dfs(root); &#x2F;&#x2F; 否则，则对root进行深度优先遍历        return root;    &#125;    void dfs(TreeNode* node) &#123;        if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123;            return; &#x2F;&#x2F; 如果被遍历的结点左右子树都为空，则直接跳出        &#125;        TreeNode* rightCopy &#x3D; node-&gt;right; &#x2F;&#x2F; 新建一个节点rightCopy用于复制当前被遍历结点的右子树        node-&gt;right &#x3D; node-&gt;left; &#x2F;&#x2F; 将节点的左子树直接赋值给右子树        node-&gt;left &#x3D; rightCopy; &#x2F;&#x2F; 将rightCopy赋值给左子树，完成当前结点的交换        if (node-&gt;left !&#x3D; NULL) &#123; &#x2F;&#x2F; 如果当前结点的左子树不为空，则对该子树进行遍历            dfs(node-&gt;left);        &#125;        if (node-&gt;right !&#x3D; NULL) &#123; &#x2F;&#x2F; 如果当前结点的右子树不为空，则对该子树进行遍历            dfs(node-&gt;right);        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一棵二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，翻转这棵二叉树，并返回其根节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode257.二叉树的所有路径</title>
    <link href="2023/06/28/leetcode257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>2023/06/28/leetcode257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</id>
    <published>2023-06-28T01:43:38.000Z</published>
    <updated>2023-06-28T01:58:54.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/paths-tree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3,null,5]输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[&quot;1&quot;]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>深度优先搜索</li></ul><p>思路：直接深度优先搜索，设置一个dfs辅助函数。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;        vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储所有路径的结果集        if (root &#x3D;&#x3D; NULL) &#123;            return result;        &#125;         string path; &#x2F;&#x2F; 当前的路径的字符串表示        &#x2F;&#x2F; 从根节点开始深度优先搜索        dfs(root, path, result);        return result;    &#125;    void dfs(TreeNode* node, string path, vector&lt;string&gt;&amp; result) &#123;        path +&#x3D; to_string(node-&gt;val); &#x2F;&#x2F; 将当前结点的值加入到当前路径                &#x2F;&#x2F; 如果是叶子结点，将当前路径加入结果集        if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123;            result.push_back(path);            return;        &#125;        &#x2F;&#x2F; 如果存在左子树        if (node-&gt;left !&#x3D; NULL) &#123;            dfs(node-&gt;left, path + &quot;-&gt;&quot;, result);        &#125;        &#x2F;&#x2F; 如果存在右子树        if (node-&gt;right !&#x3D; NULL) &#123;            dfs(node-&gt;right, path + &quot;-&gt;&quot;, result);        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，按 &lt;strong&gt;任意顺序&lt;/strong&gt; ，返回所有从根节点到叶子节点的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叶子节点&lt;/strong&gt; 是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
</feed>
