<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-10-10T06:46:43.120Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode83.删除排序链表中的重复元素</title>
    <link href="2023/10/10/leetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>2023/10/10/leetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2023-10-10T06:42:51.000Z</published>
    <updated>2023-10-10T06:46:43.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/list1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,1,2]输出：[1,2]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/list2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,1,2,3,3]输出：[1,2,3]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针</li></ul><p>思路与第一个题目类似，只是链表与数组的去重方式不同，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if (!head || !head-&gt;next) &#123;            &#x2F;&#x2F;如果仅有一个元素或者一个元素都没有，直接返回head本身            return head;        &#125;        &#x2F;&#x2F; 初始化指针p，q        ListNode* p &#x3D; head;         ListNode* q &#x3D; head-&gt;next;        while (q) &#123;            &#x2F;&#x2F; 当q未指到链表结尾时进行判断            if (p-&gt;val &#x3D;&#x3D; q-&gt;val) &#123;                &#x2F;&#x2F;相等元素执行断链操作                ListNode* temp &#x3D; q;                p-&gt;next &#x3D; q-&gt;next;                q &#x3D; q-&gt;next;                delete temp;            &#125;            else &#123;                &#x2F;&#x2F; 不相等两个指针全都后移                p &#x3D; p-&gt;next;                q &#x3D; q-&gt;next;            &#125;        &#125;        return head;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个已排序的链表的头 &lt;code&gt;head&lt;/code&gt; ， &lt;em&gt;删除所有重复的元素，使每个元素只出现一次&lt;/em&gt; 。返回 &lt;em&gt;已排序的链表&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode26.删除有序数组中的重复项</title>
    <link href="2023/10/10/leetcode26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>2023/10/10/leetcode26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2023-10-10T06:41:57.000Z</published>
    <updated>2023-10-10T06:45:35.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><span id="more"></span><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><pre class="language-none"><code class="language-none">int[] nums &#x3D; [...]; &#x2F;&#x2F; 输入数组int[] expectedNums &#x3D; [...]; &#x2F;&#x2F; 长度正确的期望答案int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用assert k &#x3D;&#x3D; expectedNums.length;for (int i &#x3D; 0; i &lt; k; i++) &#123;    assert nums[i] &#x3D;&#x3D; expectedNums[i];&#125;</code></pre><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]输出：5, nums &#x3D; [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n&#x3D;&#x3D;1) return n;        &#x2F;&#x2F; 初始化双指针        int p &#x3D; 0;        int q &#x3D; 1;        while (q &lt; n) &#123;            &#x2F;&#x2F; 1.比较 p 和 q 位置的元素是否相等。            &#x2F;&#x2F; 如果相等，q 后移 1 位             if (nums[p] &#x3D;&#x3D; nums[q]) &#123;                q &#x3D; q + 1;            &#125;            &#x2F;&#x2F; 如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位             else &#123;                nums[p+1] &#x3D; nums[q];                ++p;                ++q;            &#125;            &#x2F;&#x2F; 重复上述过程，直到 q 等于数组长度。        &#125;        return p + 1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 &lt;strong&gt;非严格递增排列&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，请你**&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt; 原地&lt;/a&gt;** 删除重复出现的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; ，返回删除后数组的新长度。元素的 &lt;strong&gt;相对顺序&lt;/strong&gt; 应该保持 &lt;strong&gt;一致&lt;/strong&gt; 。然后返回 &lt;code&gt;nums&lt;/code&gt; 中唯一元素的个数。&lt;/p&gt;
&lt;p&gt;考虑 &lt;code&gt;nums&lt;/code&gt; 的唯一元素的数量为 &lt;code&gt;k&lt;/code&gt; ，你需要做以下事情确保你的题解可以被通过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改数组 &lt;code&gt;nums&lt;/code&gt; ，使 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素包含唯一元素，并按照它们最初在 &lt;code&gt;nums&lt;/code&gt; 中出现的顺序排列。&lt;code&gt;nums&lt;/code&gt; 的其余元素与 &lt;code&gt;nums&lt;/code&gt; 的大小不重要。&lt;/li&gt;
&lt;li&gt;返回 &lt;code&gt;k&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode611.有效三角形的个数</title>
    <link href="2023/09/15/leetcode611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>2023/09/15/leetcode611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2023-09-15T10:27:08.000Z</published>
    <updated>2023-09-15T10:30:07.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [4,2,3,4]输出: 4</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>遍历+双指针优化</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;        int result &#x3D; 0; &#x2F;&#x2F; 初始化结果        sort(nums.begin(), nums.end()); &#x2F;&#x2F; 对数组排序        int n &#x3D; nums.size();        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;            if (nums[i] &#x3D;&#x3D; 0) continue; &#x2F;&#x2F; 跳过为0的状态            int k &#x3D; i + 2; &#x2F;&#x2F; 第二个指针的初始化位置            for (int j &#x3D; i + 1; j &lt; n - 1; j++) &#123;                while (k &lt; n &amp;&amp; nums[i] + nums[j] &gt; nums[k]) &#123;                    k++;                &#125;                result +&#x3D; k - j - 1;&#x2F;&#x2F; k - j - 1 表示的是满足条件的第三个边的数量            &#125;        &#125;        return result; &#x2F;&#x2F; 返回结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个包含非负整数的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其中可以组成三角形三条边的三元组个数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode451.根据字符出现频率排序</title>
    <link href="2023/09/12/leetcode451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"/>
    <id>2023/09/12/leetcode451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-12T13:03:45.000Z</published>
    <updated>2023-09-12T13:10:08.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，根据字符出现的 <strong>频率</strong> 对其进行 <strong>降序排序</strong> 。一个字符出现的 <strong>频率</strong> 是它出现在字符串中的次数。</p><p>返回 <em>已排序的字符串</em> 。如果有多个答案，返回其中任何一个。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;tree&quot;输出: &quot;eert&quot;解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;cccaaa&quot;输出: &quot;cccaaa&quot;解释: &#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;Aabb&quot;输出: &quot;bbAa&quot;解释: 此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 * 105</code></li><li><code>s</code> 由大小写英文字母和数字组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>思路：首先使用hashmap对字符串中的字符进行计数，然后使用vector数组将hashmap的元素进行拷贝，将vector以计数的从大到小进行排序。最后对排序后的vector进行遍历，得到最终的字符串，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string frequencySort(string s) &#123;        unordered_map&lt;char, int&gt; s_count_map;        for (char c:s) &#123;            s_count_map[c]++;        &#125;        &#x2F;&#x2F; 复制        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector(s_count_map.begin(), s_count_map.end());        &#x2F;&#x2F;从大到小排序        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123;return a.second &gt; b.second;&#125;);        string result;        for(auto cnt:s_count_vector) &#123;            int cnt_second &#x3D; cnt.second;            while (cnt_second--) &#123;                result+&#x3D;cnt.first;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><ul><li>一些细节优化后的代码（成绩没变）</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string frequencySort(string s) &#123;        unordered_map&lt;char, int&gt; s_count_map;        &#x2F;&#x2F; 统计字符频率        for (char c : s) &#123;            s_count_map[c]++;        &#125;        &#x2F;&#x2F; 构建结果字符串        string result;        result.reserve(s.size()); &#x2F;&#x2F; 预分配足够的内存        &#x2F;&#x2F; 构建频率字符对，并按频率降序排序        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector;        for (const auto&amp; kv : s_count_map) &#123;            s_count_vector.emplace_back(kv);        &#125;        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123; return a.second &gt; b.second; &#125;);        &#x2F;&#x2F; 构建结果字符串        for (const auto&amp; cnt : s_count_vector) &#123;            result.append(cnt.second, cnt.first); &#x2F;&#x2F; 使用append方法        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，根据字符出现的 &lt;strong&gt;频率&lt;/strong&gt; 对其进行 &lt;strong&gt;降序排序&lt;/strong&gt; 。一个字符出现的 &lt;strong&gt;频率&lt;/strong&gt; 是它出现在字符串中的次数。&lt;/p&gt;
&lt;p&gt;返回 &lt;em&gt;已排序的字符串&lt;/em&gt; 。如果有多个答案，返回其中任何一个。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode976.三角形的最大周长</title>
    <link href="2023/09/12/leetcode976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/"/>
    <id>2023/09/12/leetcode976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/</id>
    <published>2023-09-12T12:29:18.000Z</published>
    <updated>2023-09-12T12:30:16.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定由一些正数（代表长度）组成的数组 <code>nums</code> ，返回 <em>由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长</em> 。如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,1,2]输出：5解释：你可以用三个边长组成一个三角形:1 2 2。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,1,10]输出：0解释：你不能用边长 1,1,2 来组成三角形。不能用边长 1,1,10 来构成三角形。不能用边长 1、2 和 10 来构成三角形。因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 104</code></li><li><code>1 &lt;= nums[i] &lt;= 106</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>排序解答</li></ul><ol><li>首先对输入数组 <code>nums</code> 进行排序，按照从大到小的顺序排列。</li><li>然后，遍历排序后的数组，从大到小依次选取三个数 <code>a</code>, <code>b</code>, <code>c</code>，判断是否满足组成三角形的条件，即 <code>a + b &gt; c</code> 和 <code>a - b &lt; c</code>。如果满足条件，就找到了最大周长的三角形，直接返回 <code>a + b + c</code>。</li><li>如果遍历完整个数组都没有找到满足条件的三角形，说明不存在符合条件的三角形，返回0。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:        int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F; 将数组从大到小排序        sort(nums.begin(), nums.end(), [](int a, int b) &#123;            return a &gt; b;        &#125;);        int n &#x3D; nums.size();        &#x2F;&#x2F; 开始遍历寻找最大的能组成三角形的三个数        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;            if (nums[i] &lt; nums[i + 1] + nums[i + 2]) return nums[i] + nums[i + 1] + nums[i + 2];        &#125;        return 0;    &#125;    &#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定由一些正数（代表长度）组成的数组 &lt;code&gt;nums&lt;/code&gt; ，返回 &lt;em&gt;由其中三个长度组成的、&lt;strong&gt;面积不为零&lt;/strong&gt;的三角形的最大周长&lt;/em&gt; 。如果不能形成任何面积不为零的三角形，返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode389.找不同</title>
    <link href="2023/09/12/leetcode389-%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
    <id>2023/09/12/leetcode389-%E6%89%BE%E4%B8%8D%E5%90%8C/</id>
    <published>2023-09-12T12:29:07.000Z</published>
    <updated>2023-09-12T12:30:20.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，它们只包含小写字母。</p><p>字符串 <code>t</code> 由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <code>t</code> 中被添加的字母。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;, t &#x3D; &quot;abcde&quot;输出：&quot;e&quot;解释：&#39;e&#39; 是那个被添加的字母。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;&quot;, t &#x3D; &quot;y&quot;输出：&quot;y&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 1000</code></li><li><code>t.length == s.length + 1</code></li><li><code>s</code> 和 <code>t</code> 只包含小写字母</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>用数组辅助计数的暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    char findTheDifference(string s, string t) &#123;        vector&lt;int&gt; s_cnt(26,0);        vector&lt;int&gt; t_cnt(26,0); &#x2F;&#x2F; 使用数组存储字符串中不同字母的个数        char result; &#x2F;&#x2F; 初始化答案字符        &#x2F;&#x2F; 分别统计不同字符串的字符个数        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            int index &#x3D; int(s[i] - &#39;a&#39;);            ++s_cnt[index];        &#125;        for (int j &#x3D; 0; j &lt; t.size(); j++) &#123;            int index &#x3D; int(t[j] - &#39;a&#39;);            ++t_cnt[index];        &#125;        &#x2F;&#x2F; 对比个数，不同的索引与&#39;a&#39;相加就是需要的答案。        for (int i &#x3D; 0; i &lt; 26; i++) &#123;            if (s_cnt[i] !&#x3D; t_cnt[i]) &#123;                result &#x3D; &#39;a&#39; + i;            &#125;        &#125;        return result; &#x2F;&#x2F; 返回答案    &#125;&#125;;</code></pre><ul><li>位运算</li></ul><p>如果将两个字符串拼接成一个字符串，则问题转换成求字符串中出现奇数次的字符。我们使用异或操作来找到两个字符串中不同的字符，因为相同的字符异或后会抵消，最终剩下的是不同的字符。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    char findTheDifference(string s, string t) &#123;        char result &#x3D; 0;                &#x2F;&#x2F; 异或操作会消除相同的字符，最终结果将是不同字符的ASCII码值        for (char c : s) &#123;            result ^&#x3D; c;        &#125;                for (char c : t) &#123;            result ^&#x3D; c;        &#125;                return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，它们只包含小写字母。&lt;/p&gt;
&lt;p&gt;字符串 &lt;code&gt;t&lt;/code&gt; 由字符串 &lt;code&gt;s&lt;/code&gt; 随机重排，然后在随机位置添加一个字母。&lt;/p&gt;
&lt;p&gt;请找出在 &lt;code&gt;t&lt;/code&gt; 中被添加的字母。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode60.排列序列</title>
    <link href="2023/09/08/leetcode60-%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/"/>
    <id>2023/09/08/leetcode60-%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</id>
    <published>2023-09-08T09:55:28.000Z</published>
    <updated>2023-09-08T13:50:45.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p><ol><li><code>&quot;123&quot;</code></li><li><code>&quot;132&quot;</code></li><li><code>&quot;213&quot;</code></li><li><code>&quot;231&quot;</code></li><li><code>&quot;312&quot;</code></li><li><code>&quot;321&quot;</code></li></ol><p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3, k &#x3D; 3输出：&quot;213&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4, k &#x3D; 9输出：&quot;2314&quot;</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3, k &#x3D; 1输出：&quot;123&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li><code>1 &lt;= k &lt;= n!</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>思路<br>首先可以根据全排列树发现，第 iii 层的每个结点有(n - i)!个分支，对于每一层我们只需要找到第 j 个结点使得$j\times(n - i)! \ge k$，然后再$k&#x3D;k−(j−1)×(n−i)!$ 再然后迭代下一层以此类推。 对于找第 j 个结点可以使用状态压缩，记录之前哪些点用过了。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:        vector&lt;int&gt; fact;  &#x2F;&#x2F; 存储阶乘的数组    Solution(): fact(10) &#123;  &#x2F;&#x2F; 构造函数，初始化fact数组为长度10的数组        fact[0] &#x3D; 1;  &#x2F;&#x2F; 阶乘0的值为1        iota(fact.begin() + 1, fact.end(), 1);  &#x2F;&#x2F; 填充fact数组，从1到9        partial_sum(fact.begin(), fact.end(), fact.begin(), multiplies&lt;int&gt;());  &#x2F;&#x2F; 计算部分和，得到1!到9!的值    &#125;    string getPermutation(int n, int k) &#123;  &#x2F;&#x2F; 返回第k个排列的字符串        string res;  &#x2F;&#x2F; 存储结果的字符串        int state &#x3D; 0;  &#x2F;&#x2F; 表示已经使用的数字的状态        for (int i &#x3D; n - 1; ~i; -- i) &#123;  &#x2F;&#x2F; 从最高位到最低位遍历            int pre &#x3D; 0;  &#x2F;&#x2F; 记录前一个状态下的排列数量            for (int j &#x3D; 1; j &lt;&#x3D; n; ++ j) &#123;  &#x2F;&#x2F; 遍历1到n                if (state &gt;&gt; j &amp; 1) continue;  &#x2F;&#x2F; 如果数字已被使用，跳过                if (pre + fact[i] &gt;&#x3D; k) &#123;  &#x2F;&#x2F; 如果前一个状态下的排列数量加上当前位的阶乘大于等于k                    res.push_back(j + &#39;0&#39;);  &#x2F;&#x2F; 将当前数字加入结果字符串                    k -&#x3D; pre;  &#x2F;&#x2F; 更新k值                    state |&#x3D; 1 &lt;&lt; j;  &#x2F;&#x2F; 更新已使用数字的状态                    break;  &#x2F;&#x2F; 跳出内层循环                &#125;                pre +&#x3D; fact[i];  &#x2F;&#x2F; 更新前一个状态下的排列数量            &#125;        &#125;        return res;  &#x2F;&#x2F; 返回结果字符串    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给出集合 &lt;code&gt;[1,2,3,...,n]&lt;/code&gt;，其所有元素共有 &lt;code&gt;n!&lt;/code&gt; 种排列。&lt;/p&gt;
&lt;p&gt;按大小顺序列出所有排列情况，并一一标记，当 &lt;code&gt;n = 3&lt;/code&gt; 时, 所有排列如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;123&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;132&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;213&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;231&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;312&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;321&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;，返回第 &lt;code&gt;k&lt;/code&gt; 个排列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode22.括号生成</title>
    <link href="2023/09/07/leetcode22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>2023/09/07/leetcode22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2023-09-07T07:55:19.000Z</published>
    <updated>2023-09-07T08:22:23.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[&quot;()&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储最终结果的向量        &#x2F;&#x2F; 调用递归函数开始生成括号        generate(result, &quot;&quot;, 0, 0, n);        return result;    &#125;private:    &#x2F;&#x2F; 递归生成括号的辅助函数    void generate(vector&lt;string&gt;&amp; result, string current, int open, int close, int max) &#123;        &#x2F;&#x2F; 当前生成的括号串长度等于2 * n时，将其加入结果向量        if (current.length() &#x3D;&#x3D; 2 * max) &#123;            result.push_back(current);            return;        &#125;        &#x2F;&#x2F; 如果左括号的数量小于n，可以添加左括号        if (open &lt; max) &#123;            generate(result, current + &quot;(&quot;, open + 1, close, max);        &#125;        &#x2F;&#x2F; 如果右括号的数量小于左括号，可以添加右括号        if (close &lt; open) &#123;            generate(result, current + &quot;)&quot;, open, close + 1, max);        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1828.统计一个圆中点的数目</title>
    <link href="2023/09/07/leetcode1828-%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%9C%86%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>2023/09/07/leetcode1828-%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%9C%86%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2023-09-07T07:54:16.000Z</published>
    <updated>2023-09-07T08:04:02.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> ，表示第 <code>i</code> 个点在二维平面上的坐标。多个点可能会有 <strong>相同</strong> 的坐标。</p><p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [xj, yj, rj]</code> ，表示一个圆心在 <code>(xj, yj)</code> 且半径为 <code>rj</code> 的圆。</p><p>对于每一个查询 <code>queries[j]</code> ，计算在第 <code>j</code> 个圆 <strong>内</strong> 点的数目。如果一个点在圆的 <strong>边界上</strong> ，我们同样认为它在圆 <strong>内</strong> 。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/chrome_2021-03-25_22-34-16.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：points &#x3D; [[1,3],[3,3],[5,3],[2,2]], queries &#x3D; [[2,3,1],[4,3,1],[1,1,2]]输出：[3,2,2]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/chrome_2021-03-25_22-42-07.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：points &#x3D; [[1,1],[2,2],[3,3],[4,4],[5,5]], queries &#x3D; [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]输出：[2,3,2,4]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= points.length &lt;= 500</code></li><li><code>points[i].length == 2</code></li><li><code>0 &lt;= xi, yi &lt;= 500</code></li><li><code>1 &lt;= queries.length &lt;= 500</code></li><li><code>queries[j].length == 3</code></li><li><code>0 &lt;= xj, yj &lt;= 500</code></li><li><code>1 &lt;= rj &lt;= 500</code></li><li>所有的坐标都是整数。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接模拟</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        int pointNum &#x3D; points.size(); &#x2F;&#x2F; 点的数目        int queriesNum &#x3D; queries.size(); &#x2F;&#x2F; 圆的数目        vector&lt;int&gt; ans(queriesNum, 0);        for (int i &#x3D; 0; i &lt; queriesNum; i++) &#123;            &#x2F;&#x2F; 获取当前遍历的圆的圆心和半径            int round_x &#x3D; queries[i][0];            int round_y &#x3D; queries[i][1];            int round_r &#x3D; queries[i][2];            for (int j &#x3D; 0; j &lt; pointNum; j++) &#123;                int point_x &#x3D; points[j][0]; &#x2F;&#x2F; 获取点的坐标                int point_y &#x3D; points[j][1];                &#x2F;&#x2F; 开始判断点是否在圆内                double dx &#x3D; round_x - point_x;                double dy &#x3D; round_y - point_y;                double dis &#x3D; sqrt(dx * dx + dy * dy);                if (dis &lt;&#x3D; round_r) ++ans[i]; &#x2F;&#x2F; 如果确实在圆内，ans数组对应元素增加！            &#125;        &#125;        return ans; &#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个数组 &lt;code&gt;points&lt;/code&gt; ，其中 &lt;code&gt;points[i] = [xi, yi]&lt;/code&gt; ，表示第 &lt;code&gt;i&lt;/code&gt; 个点在二维平面上的坐标。多个点可能会有 &lt;strong&gt;相同&lt;/strong&gt; 的坐标。&lt;/p&gt;
&lt;p&gt;同时给你一个数组 &lt;code&gt;queries&lt;/code&gt; ，其中 &lt;code&gt;queries[j] = [xj, yj, rj]&lt;/code&gt; ，表示一个圆心在 &lt;code&gt;(xj, yj)&lt;/code&gt; 且半径为 &lt;code&gt;rj&lt;/code&gt; 的圆。&lt;/p&gt;
&lt;p&gt;对于每一个查询 &lt;code&gt;queries[j]&lt;/code&gt; ，计算在第 &lt;code&gt;j&lt;/code&gt; 个圆 &lt;strong&gt;内&lt;/strong&gt; 点的数目。如果一个点在圆的 &lt;strong&gt;边界上&lt;/strong&gt; ，我们同样认为它在圆 &lt;strong&gt;内&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;请你返回一个数组 &lt;code&gt;answer&lt;/code&gt; ，其中 &lt;code&gt;answer[j]&lt;/code&gt;是第 &lt;code&gt;j&lt;/code&gt; 个查询的答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode463.岛屿的周长</title>
    <link href="2023/09/05/leetcode463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>2023/09/05/leetcode463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2023-09-05T08:26:04.000Z</published>
    <updated>2023-09-05T09:43:45.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p><p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/island.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：grid &#x3D; [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]输出：16解释：它的周长是上面图片中的 16 个黄色的边</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：grid &#x3D; [[1]]输出：4</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：grid &#x3D; [[1,0]]输出：4</code></pre><p><strong>提示：</strong></p><ul><li><code>row == grid.length</code></li><li><code>col == grid[i].length</code></li><li><code>1 &lt;= row, col &lt;= 100</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力遍历</li></ul><p>思路：对每一个方格进行遍历，在当前方格为1时，将result的值增加4，接下来判断当前的方格周围的方格是否为1，如果它的下方或右方有同样是1的方格时，将res减少2（分别在当前方格和相邻方格方面的边长减去）。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int res &#x3D; 0; &#x2F;&#x2F; 初始化结果        int rows &#x3D; grid.size(); &#x2F;&#x2F; 获取行数        int cols &#x3D; grid[0].size(); &#x2F;&#x2F; 获取列数        &#x2F;&#x2F; 开始遍历        for (int i &#x3D; 0; i &lt; rows; ++i) &#123;             for (int j &#x3D; 0; j &lt; cols; ++j) &#123;                if (grid[i][j] &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果当前被遍历的方格值为1                    res +&#x3D; 4; &#x2F;&#x2F; 结果增加4                    if (i &lt; rows - 1 &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) res -&#x3D; 2; &#x2F;&#x2F; 判断当前遍历的方格的下方的方格是否也是1                    if (j &lt; cols - 1 &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) res -&#x3D; 2;&#x2F;&#x2F; 判断当前遍历的方格的右方的方格是否也是1                &#125;            &#125;        &#125;        return res; &#x2F;&#x2F; 返回结果    &#125;&#125;;</code></pre><ul><li>数学方法</li></ul><p>思路：一块土地原则上会带来 4 个周长，但岛上的土地存在接壤，每一条接壤，会减掉 2 个边长。</p><p>所以，总周长 &#x3D; 4 * 土地个数 - 2 * 接壤边的条数。</p><p>遍历矩阵，遍历到土地，就 land++，如果它的右&#x2F;下边也是土地，则 border++，遍历结束后代入公式。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int land &#x3D; 0;&#x2F;&#x2F;土地数量        int border &#x3D; 0;&#x2F;&#x2F;接壤边的条数        for (int i &#x3D; 0; i &lt; grid.size(); ++i) &#123;            for (int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123;                if (grid[i][j] &#x3D;&#x3D; 1) &#123;                    ++land;                    if (i &lt; grid.size() - 1 &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;该土地的下方有土地就说明下面这条边就是接壤边                        ++border;                    &#125;                    if (j &lt; grid[0].size() - 1 &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;该土地的右方有土地就说明右面这条边就是接壤边                        ++border;                    &#125;                &#125;            &#125;        &#125;        return 4 * land - 2 * border;    &#125;&#125;;</code></pre><ul><li>DFS</li></ul><p>思路：岛就一个，我们从第一个遇到的土地开始深搜。</p><p>对于每个土地节点，做一些事情，基于它，递归上下左右四个点，做同样的事情。做什么事情呢？</p><p>从土地到土地，之间不会产生周长，但从土地迈入海洋，之间会产生 1 个周长，从土地迈出矩阵边界，也会产生 1 个周长。</p><p>dfs 的过程中，对当前点的上下左右递归，下一个递归的点又对上下左右递归，就会造成重复访问，造成周长的重复计算。</p><p>遍历过的土地节点，将值改为 2，区分于 1 和 0，代表访问过了。</p><p>总结：DFS 从一个点，向四周扩散，目标是遇到矩阵边界或海水，它们是答案已知的 base case，是位于递归树底部的 case，是递归的终止条件。</p><p>从上而下递归调用，随着递归的出栈，子问题的解自下而上地返回，最后得出大问题的解。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        for (int i &#x3D; 0; i &lt; grid.size(); ++i) &#123;            for (int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123;                if (grid[i][j] &#x3D;&#x3D; 1) &#123;                    return dfsHelper(grid, i, j);                &#125;            &#125;        &#125;        return 0;    &#125;    int dfsHelper(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j) &#123;        int rows &#x3D; grid.size();        int cols &#x3D; grid[0].size();        if (i &lt; 0 || i &gt;&#x3D; rows || j &lt; 0 || j &gt;&#x3D; cols) &#123;            &#x2F;&#x2F;越界的情况，直接返回1            return 1;        &#125;        if (grid[i][j] &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F; 从土地到达海水            return 1;        &#125;        if (grid[i][j] &#x3D;&#x3D; 2) &#123;            &#x2F;&#x2F; 之前已经访问过这块方格了，直接返回0            return 0;        &#125;        &#x2F;&#x2F; 修改方格的值为2，说明已经来过了        grid[i][j] &#x3D; 2;        return dfsHelper(grid, i - 1, j) + dfsHelper(grid, i + 1, j) + dfsHelper(grid, i, j - 1) + dfsHelper(grid, i, j + 1);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个 &lt;code&gt;row x col&lt;/code&gt; 的二维网格地图 &lt;code&gt;grid&lt;/code&gt; ，其中：&lt;code&gt;grid[i][j] = 1&lt;/code&gt; 表示陆地， &lt;code&gt;grid[i][j] = 0&lt;/code&gt; 表示水域。&lt;/p&gt;
&lt;p&gt;网格中的格子 &lt;strong&gt;水平和垂直&lt;/strong&gt; 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。&lt;/p&gt;
&lt;p&gt;岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode2511.最多可以摧毁的敌人城堡数目</title>
    <link href="2023/09/04/leetcode2511-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E6%91%A7%E6%AF%81%E7%9A%84%E6%95%8C%E4%BA%BA%E5%9F%8E%E5%A0%A1%E6%95%B0%E7%9B%AE/"/>
    <id>2023/09/04/leetcode2511-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E6%91%A7%E6%AF%81%E7%9A%84%E6%95%8C%E4%BA%BA%E5%9F%8E%E5%A0%A1%E6%95%B0%E7%9B%AE/</id>
    <published>2023-09-04T12:31:04.000Z</published>
    <updated>2023-09-04T12:34:17.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个长度为 <code>n</code> ，下标从 <strong>0</strong> 开始的整数数组 <code>forts</code> ，表示一些城堡。<code>forts[i]</code> 可以是 <code>-1</code> ，<code>0</code> 或者 <code>1</code> ，其中：</p><ul><li><code>-1</code> 表示第 <code>i</code> 个位置 <strong>没有</strong> 城堡。</li><li><code>0</code> 表示第 <code>i</code> 个位置有一个 <strong>敌人</strong> 的城堡。</li><li><code>1</code> 表示第 <code>i</code> 个位置有一个你控制的城堡。</li></ul><p>现在，你需要决定，将你的军队从某个你控制的城堡位置 <code>i</code> 移动到一个空的位置 <code>j</code> ，满足：</p><ul><li><code>0 &lt;= i, j &lt;= n - 1</code></li><li>军队经过的位置 <strong>只有</strong> 敌人的城堡。正式的，对于所有 <code>min(i,j) &lt; k &lt; max(i,j)</code> 的 <code>k</code> ，都满足 <code>forts[k] == 0</code> 。</li></ul><p>当军队移动时，所有途中经过的敌人城堡都会被 <strong>摧毁</strong> 。</p><p>请你返回 <strong>最多</strong> 可以摧毁的敌人城堡数目。如果 <strong>无法</strong> 移动你的军队，或者没有你控制的城堡，请返回 <code>0</code> 。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：forts &#x3D; [1,0,0,-1,0,0,0,0,1]输出：4解释：- 将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2 。- 将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：forts &#x3D; [0,0,1,-1]输出：0解释：由于无法摧毁敌人的城堡，所以返回 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= forts.length &lt;= 1000</code></li><li><code>-1 &lt;= forts[i] &lt;= 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int captureForts(vector&lt;int&gt;&amp; forts) &#123;        int ans &#x3D; 0, pre &#x3D; -1; &#x2F;&#x2F; 双指针        for (int i &#x3D; 0; i &lt; forts.size(); i++) &#123;            if (forts[i] &#x3D;&#x3D; 1 || forts[i] &#x3D;&#x3D; -1) &#123;                if (pre &gt;&#x3D; 0 &amp;&amp; forts[i] !&#x3D; forts[pre]) &#123; &#x2F;&#x2F; 保证i与pre指着的元素不是同一个数字                    ans &#x3D; max(ans, i - pre - 1); &#x2F;&#x2F; 更新ans                &#125;                pre &#x3D; i; &#x2F;&#x2F; 更新pre，保证i和pre之间无其他1或者-1；            &#125;        &#125;        return ans; &#x2F;&#x2F; 返回最终结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; ，下标从 &lt;strong&gt;0&lt;/strong&gt; 开始的整数数组 &lt;code&gt;forts&lt;/code&gt; ，表示一些城堡。&lt;code&gt;forts[i]&lt;/code&gt; 可以是 &lt;code&gt;-1&lt;/code&gt; ，&lt;code&gt;0&lt;/code&gt; 或者 &lt;code&gt;1&lt;/code&gt; ，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-1&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个位置 &lt;strong&gt;没有&lt;/strong&gt; 城堡。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个位置有一个 &lt;strong&gt;敌人&lt;/strong&gt; 的城堡。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个位置有一个你控制的城堡。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，你需要决定，将你的军队从某个你控制的城堡位置 &lt;code&gt;i&lt;/code&gt; 移动到一个空的位置 &lt;code&gt;j&lt;/code&gt; ，满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i, j &amp;lt;= n - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;军队经过的位置 &lt;strong&gt;只有&lt;/strong&gt; 敌人的城堡。正式的，对于所有 &lt;code&gt;min(i,j) &amp;lt; k &amp;lt; max(i,j)&lt;/code&gt; 的 &lt;code&gt;k&lt;/code&gt; ，都满足 &lt;code&gt;forts[k] == 0&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当军队移动时，所有途中经过的敌人城堡都会被 &lt;strong&gt;摧毁&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;请你返回 &lt;strong&gt;最多&lt;/strong&gt; 可以摧毁的敌人城堡数目。如果 &lt;strong&gt;无法&lt;/strong&gt; 移动你的军队，或者没有你控制的城堡，请返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="双指针" scheme="tags/双指针/"/>
    
  </entry>
  
  <entry>
    <title>leetcode940.不同的子序列II</title>
    <link href="2023/09/01/leetcode940-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97II/"/>
    <id>2023/09/01/leetcode940-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97II/</id>
    <published>2023-09-01T08:36:44.000Z</published>
    <updated>2023-09-01T08:44:12.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code>，计算 <code>s</code> 的 <strong>不同非空子序列</strong> 的个数。因为结果可能很大，所以返回答案需要对 <strong><code>10^9 + 7</code> 取余</strong> 。</p><p>字符串的 <strong>子序列</strong> 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;***a***b***c***d***e***&quot;</code> 的一个子序列，但 <code>&quot;aec&quot;</code> 不是。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abc&quot;输出：7解释：7 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, 以及 &quot;abc&quot;。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;aba&quot;输出：6解释：6 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;aa&quot; 以及 &quot;aba&quot;。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;aaa&quot;输出：3解释：3 个不同的子序列分别是 &quot;a&quot;, &quot;aa&quot; 以及 &quot;aaa&quot;。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>思路：</p><p><img src="http://cdn.leafii.top/img/image-20230901164319947.png" alt="**image-20230901164319947**" loading="lazy"></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int distinctSubseqII(string s) &#123;        vector&lt;int&gt; last(26, -1);                int n &#x3D; s.size();        vector&lt;int&gt; f(n, 1);        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            for (int j &#x3D; 0; j &lt; 26; ++j) &#123;                if (last[j] !&#x3D; -1) &#123;                    f[i] &#x3D; (f[i] + f[last[j]]) % mod;                &#125;            &#125;            last[s[i] - &#39;a&#39;] &#x3D; i;        &#125;                int ans &#x3D; 0;        for (int i &#x3D; 0; i &lt; 26; ++i) &#123;            if (last[i] !&#x3D; -1) &#123;                ans &#x3D; (ans + f[last[i]]) % mod;            &#125;        &#125;        return ans;    &#125;private:    static constexpr int mod &#x3D; 1000000007;&#125;;</code></pre><hr><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/distinct-subsequences-ii/solutions/1888523/bu-tong-de-zi-xu-lie-ii-by-leetcode-solu-k2h5/">https://leetcode.cn/problems/distinct-subsequences-ii/solutions/1888523/bu-tong-de-zi-xu-lie-ii-by-leetcode-solu-k2h5/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt;，计算 &lt;code&gt;s&lt;/code&gt; 的 &lt;strong&gt;不同非空子序列&lt;/strong&gt; 的个数。因为结果可能很大，所以返回答案需要对 &lt;strong&gt;&lt;code&gt;10^9 + 7&lt;/code&gt; 取余&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;字符串的 &lt;strong&gt;子序列&lt;/strong&gt; 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;***a***b***c***d***e***&amp;quot;&lt;/code&gt; 的一个子序列，但 &lt;code&gt;&amp;quot;aec&amp;quot;&lt;/code&gt; 不是。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
  <entry>
    <title>leetcode522.最长特殊序列II</title>
    <link href="2023/08/31/leetcode522-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97II/"/>
    <id>2023/08/31/leetcode522-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97II/</id>
    <published>2023-08-31T01:22:21.000Z</published>
    <updated>2023-08-31T01:28:34.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定字符串列表 <code>strs</code> ，返回其中 <strong>最长的特殊序列</strong> 的长度。如果最长特殊序列不存在，返回 <code>-1</code> 。</p><p><strong>特殊序列</strong> 定义如下：该序列为某字符串 <strong>独有的子序列（即不能是其他字符串的子序列）</strong>。</p><p> <code>s</code> 的 <strong>子序列</strong>可以通过删去字符串 <code>s</code> 中的某些字符实现。</p><ul><li>例如，<code>&quot;abc&quot;</code> 是 <code>&quot;aebdc&quot;</code> 的子序列，因为您可以删除<code>&quot;aebdc&quot;</code>中的下划线字符来得到 <code>&quot;abc&quot;</code> 。<code>&quot;aebdc&quot;</code>的子序列还包括<code>&quot;aebdc&quot;</code>、 <code>&quot;aeb&quot;</code> 和 “” (空字符串)。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;aba&quot;,&quot;cdc&quot;,&quot;eae&quot;]输出: 3</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;aaa&quot;,&quot;aaa&quot;,&quot;aa&quot;]输出: -1</code></pre><p><strong>提示:</strong></p><ul><li><code>2 &lt;= strs.length &lt;= 50</code></li><li><code>1 &lt;= strs[i].length &lt;= 10</code></li><li><code>strs[i]</code> 只包含小写英文字母</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><ol><li>首先，我们需要对字符串数组进行排序，将较长的字符串排在前面。这是因为如果一个字符串是另一个字符串的子序列，那么较长的字符串必定不能成为特殊序列。</li><li>排序之后，我们遍历每个字符串，判断它是否是特殊序列。我们需要检查当前字符串是否在剩余的字符串中存在子序列。</li><li>对于每个字符串，我们逐个比较它与剩余字符串的关系。如果当前字符串不是任何其他字符串的子序列，那么它就是一个特殊序列。</li><li>我们只需要返回最长的特殊序列的长度即可。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    &#x2F;&#x2F; 判断字符串a是否是字符串b的子序列    bool isSubsequence(const string&amp; a, const string&amp; b) &#123;        int i &#x3D; 0, j &#x3D; 0;        while (i &lt; a.size() &amp;&amp; j &lt; b.size()) &#123;            if (a[i] &#x3D;&#x3D; b[j]) &#123;                i++;            &#125;            j++;        &#125;        return i &#x3D;&#x3D; a.size();    &#125;    &#x2F;&#x2F; 找到最长特殊序列的长度    int findLUSlength(vector&lt;string&gt;&amp; strs) &#123;        &#x2F;&#x2F; 根据字符串长度排序，较长的字符串排在前面        sort(strs.begin(), strs.end(), [](const string&amp; a, const string&amp; b) &#123;            return a.size() &gt; b.size();        &#125;);        for (int i &#x3D; 0; i &lt; strs.size(); ++i) &#123;            bool is_special &#x3D; true;            for (int j &#x3D; 0; j &lt; strs.size(); ++j) &#123;                if (i !&#x3D; j &amp;&amp; isSubsequence(strs[i], strs[j])) &#123;                    is_special &#x3D; false;                    break;                &#125;            &#125;            if (is_special) &#123;                return strs[i].size();            &#125;        &#125;                return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定字符串列表 &lt;code&gt;strs&lt;/code&gt; ，返回其中 &lt;strong&gt;最长的特殊序列&lt;/strong&gt; 的长度。如果最长特殊序列不存在，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特殊序列&lt;/strong&gt; 定义如下：该序列为某字符串 &lt;strong&gt;独有的子序列（即不能是其他字符串的子序列）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;s&lt;/code&gt; 的 &lt;strong&gt;子序列&lt;/strong&gt;可以通过删去字符串 &lt;code&gt;s&lt;/code&gt; 中的某些字符实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt; 的子序列，因为您可以删除&lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt;中的下划线字符来得到 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 。&lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt;的子序列还包括&lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt;、 &lt;code&gt;&amp;quot;aeb&amp;quot;&lt;/code&gt; 和 “” (空字符串)。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
  <entry>
    <title>leetcode300.最长递增子序列</title>
    <link href="2023/08/30/leetcode300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>2023/08/30/leetcode300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2023-08-30T08:26:25.000Z</published>
    <updated>2023-08-30T09:49:50.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,0,3,2,3]输出：4</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [7,7,7,7,7,7,7]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>n2复杂度动态规划</li></ul><p>解题思路：</p><ol><li>dp[i]:以nums[i]为结尾的最长递增子序列的长度</li><li>递推公式：max(dp[i],dp[j]+1),</li><li>dp[i]至少为1（初始化条件）</li><li>遍历顺序：i从小到大 j从大到小，从小到大都可以（0到i之间的每一个元素）</li><li>最终返回dp数组中的最大值</li></ol><p><img src="http://cdn.leafii.top/img/image-20230830164100634.png" alt="image-20230830164100634" loading="lazy"></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n &#x3D;&#x3D; 0) return 0;        vector&lt;int&gt; dp(n, 1); &#x2F;&#x2F; 初始化dp数组，每个元素默认长度为1        for (int i &#x3D; 0; i &lt; n; i++) &#123;            for (int j &#x3D; 0; j &lt; i; j++) &#123;                if (nums[i] &gt; nums[j]) &#123;                    dp[i] &#x3D; max(dp[i], dp[j] + 1); &#x2F;&#x2F; dp数组的更新                &#125;            &#125;        &#125;        return *max_element(dp.begin(), dp.end());    &#125;&#125;;</code></pre><ul><li>n log(n)复杂度贪心</li></ul><p>交换状态与状态值</p><p>令g[i]表示长度为i+1的IS的末尾元素的最小值 </p><p><img src="http://cdn.leafii.top/img/image-20230830172521363.png" alt="image-20230830172521363" loading="lazy"></p><p>g是严格递增的。</p><p>推论1:一次只能更新一个位置，单调递增序列不能有相同元素。</p><p>推论2:更新的位置是第一个大于等于nums[i]的数的下标。</p><p>算法：在g上用二分查找快速找到第一个大于等于nums[i]的下标j。如果j不存在，那么nums[i]直接加到g末尾;否则修改g[j]为nums[i].</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; tails; &#x2F;&#x2F; 用于存储递增子序列的末尾元素        for (int num : nums) &#123;            &#x2F;&#x2F; lower_bound 返回一个迭代器，指向容器中第一个大于等于给定值的元素。            auto it &#x3D; lower_bound(tails.begin(), tails.end(), num); &#x2F;&#x2F; 在 tails 中寻找第一个大于等于 num 的元素            if (it &#x3D;&#x3D; tails.end()) &#123;                tails.push_back(num); &#x2F;&#x2F; 如果找不到，则将 num 添加到末尾            &#125; else &#123;                *it &#x3D; num; &#x2F;&#x2F; 否则，更新找到的元素，因为它可以作为更长递增子序列的末尾元素            &#125;        &#125;        return tails.size(); &#x2F;&#x2F; 返回 tails 数组的长度，即为结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到其中最长严格递增子序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子序列&lt;/strong&gt; 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，&lt;code&gt;[3,6,2,7]&lt;/code&gt; 是数组 &lt;code&gt;[0,3,1,6,2,2,7]&lt;/code&gt; 的子序列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
  <entry>
    <title>leetcode521.最长特殊序列I</title>
    <link href="2023/08/30/leetcode521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97I/"/>
    <id>2023/08/30/leetcode521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97I/</id>
    <published>2023-08-30T08:20:02.000Z</published>
    <updated>2023-08-30T08:26:49.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串 <code>a</code> 和 <code>b</code>，请返回 <em>这两个字符串中 <strong>最长的特殊序列</strong></em> 的长度。如果不存在，则返回 <code>-1</code> 。</p><p><strong>「最长特殊序列」</strong> 定义如下：该序列为 <strong>某字符串独有的最长子序列（即不能是其他字符串的子序列）</strong> 。</p><p>字符串 <code>s</code> 的子序列是在从 <code>s</code> 中删除任意数量的字符后可以获得的字符串。</p><ul><li>例如，<code>&quot;abc&quot;</code> 是 <code>&quot;aebdc&quot;</code> 的子序列，因为删除 <code>&quot;a***e***b***d\***c&quot;</code> 中斜体加粗的字符可以得到 <code>&quot;abc&quot;</code> 。 <code>&quot;aebdc&quot;</code> 的子序列还包括 <code>&quot;aebdc&quot;</code> 、 <code>&quot;aeb&quot;</code> 和 <code>&quot;&quot;</code> (空字符串)。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入: a &#x3D; &quot;aba&quot;, b &#x3D; &quot;cdc&quot;输出: 3解释: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;)，两者均为自身的子序列且不是对方的子序列。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：a &#x3D; &quot;aaa&quot;, b &#x3D; &quot;bbb&quot;输出：3解释: 最长特殊序列是 &quot;aaa&quot; 和 &quot;bbb&quot; 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：a &#x3D; &quot;aaa&quot;, b &#x3D; &quot;aaa&quot;输出：-1解释: 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a.length, b.length &lt;= 100</code></li><li><code>a</code> 和 <code>b</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><p>首先，我们判断两个字符串是否相等。如果相等，那么它们之间不存在特殊序列，直接返回-1。</p><p>如果两个字符串不相等，那么其中一个字符串肯定不是另一个字符串的子序列。因此，我们只需返回较长字符串的长度作为最长特殊序列的长度。这是因为如果较长字符串的长度都不是另一个字符串的子序列，那么较短的字符串也不可能是另一个字符串的子序列。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findLUSlength(string a, string b) &#123;        &#x2F;&#x2F; 如果两个字符串相等，则没有特殊序列        if (a &#x3D;&#x3D; b) &#123;            return -1;        &#125;        &#x2F;&#x2F; 返回较长字符串的长度作为最长特殊序列的长度        return max(a.length(), b.length());    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，请返回 &lt;em&gt;这两个字符串中 &lt;strong&gt;最长的特殊序列&lt;/strong&gt;&lt;/em&gt; 的长度。如果不存在，则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「最长特殊序列」&lt;/strong&gt; 定义如下：该序列为 &lt;strong&gt;某字符串独有的最长子序列（即不能是其他字符串的子序列）&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;字符串 &lt;code&gt;s&lt;/code&gt; 的子序列是在从 &lt;code&gt;s&lt;/code&gt; 中删除任意数量的字符后可以获得的字符串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt; 的子序列，因为删除 &lt;code&gt;&amp;quot;a***e***b***d\***c&amp;quot;&lt;/code&gt; 中斜体加粗的字符可以得到 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 。 &lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt; 的子序列还包括 &lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt; 、 &lt;code&gt;&amp;quot;aeb&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; (空字符串)。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
  <entry>
    <title>leetcode674.最长连续递增序列</title>
    <link href="2023/08/30/leetcode674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <id>2023/08/30/leetcode674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</id>
    <published>2023-08-30T08:13:58.000Z</published>
    <updated>2023-08-30T08:26:57.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2], 长度为1。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>直接看代码</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n &#x3D;&#x3D; 0) &#123;            return 0;        &#125;                int maxLength &#x3D; 1; &#x2F;&#x2F; 初始化最大长度为1，因为至少有一个元素存在        int currentLength &#x3D; 1; &#x2F;&#x2F; 当前递增序列的长度，初始为1        for (int i &#x3D; 1; i &lt; n; ++i) &#123;            if (nums[i] &gt; nums[i - 1]) &#123;                currentLength++; &#x2F;&#x2F; 如果当前元素大于前一个元素，则当前递增序列长度加一                maxLength &#x3D; max(maxLength, currentLength); &#x2F;&#x2F; 更新最大长度            &#125; else &#123;                currentLength &#x3D; 1; &#x2F;&#x2F; 重置当前递增序列长度为1，因为递增中断            &#125;        &#125;                return maxLength;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个未经排序的整数数组，找到最长且 &lt;strong&gt;连续递增的子序列&lt;/strong&gt;，并返回该序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连续递增的子序列&lt;/strong&gt; 可以由两个下标 &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;r&lt;/code&gt;（&lt;code&gt;l &amp;lt; r&lt;/code&gt;）确定，如果对于每个 &lt;code&gt;l &amp;lt;= i &amp;lt; r&lt;/code&gt;，都有 &lt;code&gt;nums[i] &amp;lt; nums[i + 1]&lt;/code&gt; ，那么子序列 &lt;code&gt;[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]&lt;/code&gt; 就是连续递增子序列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
  <entry>
    <title>leetcode283.移动零</title>
    <link href="2023/08/08/leetcode283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>2023/08/08/leetcode283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</id>
    <published>2023-08-08T11:48:39.000Z</published>
    <updated>2023-08-08T11:50:12.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><span id="more"></span> <p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [0]输出: [0]</code></pre><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size(); &#x2F;&#x2F; 获取数组长度        int right &#x3D; 0; &#x2F;&#x2F; 定义指向数组右边的指针        int left &#x3D; 0; &#x2F;&#x2F; 定义指向数组左边的指针        while (right &lt; nums.size()) &#123; &#x2F;&#x2F; 循环遍历数组            if (nums[right] &#x3D;&#x3D; 0); &#x2F;&#x2F; 如果当前元素为零，跳过该步骤（注：这里存在逻辑错误，应该去掉分号，即 if (nums[right] &#x3D;&#x3D; 0)）            else &#123;                nums[left] &#x3D; nums[right]; &#x2F;&#x2F; 如果当前元素不为零，将其移动到左边（注：这里将非零元素移到了左边，而不是把零元素移到右边）                left++; &#x2F;&#x2F; 左指针右移一位            &#125;            right++; &#x2F;&#x2F; 右指针右移一位        &#125;        while (left &lt; nums.size()) &#123; &#x2F;&#x2F; 将剩余的位置填充为零            nums[left++] &#x3D; 0; &#x2F;&#x2F; 将左指针位置及其右边的元素都置为零        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意&lt;/strong&gt; ，必须在不复制数组的情况下原地对数组进行操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode941.有效的山脉数组</title>
    <link href="2023/08/07/leetcode941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
    <id>2023/08/07/leetcode941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</id>
    <published>2023-08-07T03:18:14.000Z</published>
    <updated>2023-08-07T03:52:55.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>arr</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p><span id="more"></span><p>让我们回顾一下，如果 <code>arr</code> 满足下述条件，那么它是一个山脉数组：</p><ul><li><p><code>arr.length &gt;= 3</code></p></li><li><p>在 </p><pre class="language-none"><code class="language-none">0 &lt; i &lt; arr.length - 1</code></pre><p> 条件下，存在 </p><pre class="language-none"><code class="language-none">i</code></pre><p> 使得：</p><ul><li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li><li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul></li></ul><p><img src="http://cdn.leafii.top/img/hint_valid_mountain_array.png" alt="img" loading="lazy"></p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,1]输出：false</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [3,5,5]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [0,3,2,1]输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 104</code></li><li><code>0 &lt;= arr[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>首先获取数组中最大的数字以及下标，然后对下标进行判断，符合条件（数组大小超过2并且最大值不是数组的第一个元素或者最后一个元素）时进行第二次循环，循环时判断相邻元素是否满足递增或者递减的关系。C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool validMountainArray(vector&lt;int&gt;&amp; arr) &#123;        &#x2F;&#x2F; 得到最大值        int maxNum &#x3D; -1;        int maxIndex &#x3D; -1;        int n &#x3D; arr.size();        if (n &lt; 3) return false;        for (int i &#x3D; 0; i &lt; n; i++) &#123;            if (arr[i] &gt; maxNum) &#123;                maxNum &#x3D; arr[i];                maxIndex &#x3D; i;            &#125;        &#125;        &#x2F;&#x2F; 得到最大值后进行一部分判断然后进行循环        if (maxIndex &#x3D;&#x3D; n-1 || maxIndex &#x3D;&#x3D; 0) return false;        for (int i &#x3D; 0; i &lt; maxIndex; i++) &#123;            if (arr[i] &gt;&#x3D; arr[i + 1]) return false;        &#125;        for (int i &#x3D; maxIndex; i &lt; n - 1; i++) &#123;            if (arr[i] &lt;&#x3D; arr[i + 1]) return false;        &#125;        return true;    &#125;&#125;;</code></pre><ul><li>只扫描一次的解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool validMountainArray(vector&lt;int&gt;&amp; A) &#123;        int n &#x3D; A.size();                &#x2F;&#x2F; 山脉数组必须至少有3个元素        if (n &lt; 3) &#123;            return false;        &#125;                int i &#x3D; 0;                &#x2F;&#x2F; 从左侧递增部分开始扫描        while (i &lt; n - 1 &amp;&amp; A[i] &lt; A[i + 1]) &#123;            i++;        &#125;                &#x2F;&#x2F; 如果i是数组的第一个元素或者最后一个元素，说明没有递增或递减的足够元素        if (i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) &#123;            return false;        &#125;                &#x2F;&#x2F; 扫描递减部分        while (i &lt; n - 1 &amp;&amp; A[i] &gt; A[i + 1]) &#123;            i++;        &#125;                &#x2F;&#x2F; 如果i已经到达数组的末尾，说明是有效的山脉数组        return i &#x3D;&#x3D; n - 1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;arr&lt;/code&gt;，如果它是有效的山脉数组就返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode115.不同的子序列</title>
    <link href="2023/08/04/leetcode115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>2023/08/04/leetcode115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2023-08-04T08:53:00.000Z</published>
    <updated>2023-08-04T08:54:47.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数。</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;rabbbit&quot;, t &#x3D; &quot;rabbit&quot;输出：3解释：如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。rabbbitrabbbitrabbbit</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;babgbag&quot;, t &#x3D; &quot;bag&quot;输出：5解释：如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 babgbagbabgbagbabgbagbabgbagbabgbag</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>解题思路：</p><p>题目要求计算字符串 s 变换为字符串 t 的不同子序列数量。这类问题可以使用动态规划来解决。</p><p>我们使用 dp<code>[i][j]</code> 表示字符串 s 的前 i 个字符和字符串 t 的前 j 个字符之间的不同子序列数量。初始时，任何字符串变换为空字符串的方式都只有一种，即不选取任何字符，因此我们将 dp<code>[i][0] </code>设置为 1。</p><p>然后，我们遍历字符串 s 和字符串 t 的所有字符组合，逐步计算 dp 数组。当 s[i-1] 和 t[j-1] 相等时，我们可以选择当前字符匹配或者不匹配。如果匹配，那么当前字符可以贡献 <code>dp[i-1][j-1] </code>个子序列；如果不匹配，那么当前字符不会贡献新的子序列，继续使用<code> dp[i-1][j]</code>。如果 s[i-1] 和 t[j-1] 不相等，那么当前字符不能匹配，只能选择不匹配，即使用<code> dp[i-1][j]</code>。</p><p>最终，dp<code>[m][n]</code> 就是字符串 s 变换为字符串 t 的不同子序列数量，其中 m 是字符串 s 的长度，n 是字符串 t 的长度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int numDistinct(string s, string t) &#123;        int m &#x3D; s.length();        int n &#x3D; t.length();                &#x2F;&#x2F; dp[i][j] 表示 s 的前 i 个字符和 t 的前 j 个字符之间的不同子序列数量        vector&lt;vector&lt;unsigned int&gt;&gt; dp(m + 1, vector&lt;unsigned int&gt;(n + 1, 0));                &#x2F;&#x2F; 初始化：任何字符串变换为空字符串的方式都只有一种，即不选取任何字符        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;            dp[i][0] &#x3D; 1;        &#125;                &#x2F;&#x2F; 状态转移        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;                &#x2F;&#x2F; 如果 s[i-1] 和 t[j-1] 相等，则可以选择当前字符匹配或者不匹配                if (s[i - 1] &#x3D;&#x3D; t[j - 1]) &#123;                    dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j];                &#125; else &#123;                    &#x2F;&#x2F; 如果不相等，则只能选择不匹配                    dp[i][j] &#x3D; dp[i - 1][j];                &#125;            &#125;        &#125;                return dp[m][n];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，统计并返回在 &lt;code&gt;s&lt;/code&gt; 的 &lt;strong&gt;子序列&lt;/strong&gt; 中 &lt;code&gt;t&lt;/code&gt; 出现的个数。&lt;/p&gt;
&lt;p&gt;题目数据保证答案符合 32 位带符号整数范围。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96.不同的二叉搜索树</title>
    <link href="2023/08/03/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>2023/08/03/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2023-08-03T00:39:28.000Z</published>
    <updated>2023-08-03T00:44:33.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/uniquebstn3.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：5</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>解题思路： 这个问题可以用动态规划来解决。我们创建一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以 <code>i</code> 个节点构建的二叉搜索树的数量。我们可以观察到，对于每个 <code>i</code>，我们可以将每个节点依次作为根节点，将问题划分为子问题。例如，以节点 <code>j</code> 作为根节点，它的左子树将有 <code>j - 1</code> 个节点，右子树将有 <code>i - j</code> 个节点。所以，以节点 <code>j</code> 作为根节点的二叉搜索树数量为 <code>dp[j - 1] * dp[i - j]</code>。我们将所有以不同节点作为根节点的情况累加起来，就得到了 <code>dp[i]</code> 的值。</p><p>在循环计算 <code>dp</code> 数组时，外层循环遍历节点数量 <code>i</code>，内层循环遍历以不同节点为根节点的情况 <code>j</code>。最终，<code>dp[n]</code> 就是我们所求的以 <code>n</code> 个节点构建的不同二叉搜索树的数量。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int numTrees(int n) &#123;        &#x2F;&#x2F; 创建一个数组来存储以1到n为节点的二叉搜索树的数量        vector&lt;int&gt; dp(n + 1, 0);        &#x2F;&#x2F; 空树也算一种情况，初始化dp[0]为1        dp[0] &#x3D; 1;                &#x2F;&#x2F; 外层循环遍历节点数量        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;            &#x2F;&#x2F; 内层循环遍历以不同节点为根节点的情况            for (int j &#x3D; 1; j &lt;&#x3D; i; ++j) &#123;                &#x2F;&#x2F; 左子树的节点数量为j-1，右子树的节点数量为i-j                &#x2F;&#x2F; 以第j个节点为根节点的BST数量等于左子树数量乘以右子树数量                dp[i] +&#x3D; dp[j - 1] * dp[i - j];            &#125;        &#125;                return dp[n];    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，求恰由 &lt;code&gt;n&lt;/code&gt; 个节点组成且节点值从 &lt;code&gt;1&lt;/code&gt; 到 </summary>
      
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
