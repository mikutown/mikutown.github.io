<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-01-28T08:19:39.612Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode:15/16.三数之和/最接近的三数之和</title>
    <link href="2023/01/28/leetcode-15-16-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>2023/01/28/leetcode-15-16-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2023-01-28T07:53:18.000Z</published>
    <updated>2023-01-28T08:19:39.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><span id="more"></span><p>**<br>示例 1：**</p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,0], target &#x3D; 1输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 1000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><blockquote><p>这两道题目求解思路很相似，只是第一个题目需要返回所有满足求和条件的组合，第二个题目返回最接近target的sum值。</p></blockquote><p><strong>方法一：排序 + 双指针</strong></p><p>题目要求找到与目标值 $target$ 最接近的三元组，这里的「最接近」即为差值的绝对值最小。我们可以考虑直接使用三重循环枚举三元组，找出与目标值最接近的作为答案，时间复杂度为 $O(N^3)$。然而本题的 $N$ 最大为 $1000$，会超出时间限制。</p><p>那么如何进行优化呢？我们首先考虑枚举第一个元素 $a$，对于剩下的两个元素 $b$ 和 $c$，我们希望它们的和最接近 $target-a$。对于 $b$ 和 $c$，如果它们在原数组中枚举的范围（既包括下标的范围，也包括元素值的范围）没有任何规律可言，那么我们还是只能使用两重循环来枚举所有的可能情况。因此，我们可以考虑对整个数组进行升序排序，这样一来：</p><p>假设数组的长度为 $N$，我们先枚举 $a$，它在数组中的位置为 iii；</p><p>为了防止重复枚举，我们在位置$[i+1,n)$的范围内枚举 $b$ 和 $c$。</p><p>当我们知道了 $b$ 和 $c$ 可以枚举的下标范围，并且知道这一范围对应的数组元素是有序（升序）的，那么我们是否可以对枚举的过程进行优化呢？</p><p>答案是可以的。借助双指针，我们就可以对枚举的过程进行优化。我们用 $p_b$和 $p_c$分别表示指向 $b$ 和 $c$ 的指针，初始时，$p_b$指向位置$i+1$，即左边界；$p_c$指向位置 $n-1$，即右边界。在每一步枚举的过程中，我们用 $a+b+c$ 来更新答案，并且：</p><p>如果 $a+b+c \ge target$，那么就将 $p_c$向左移动一个位置；</p><p>如果 $a+b+c \le target$，那么就将 $p_b$向右移动一个位置。</p><p>这是为什么呢？我们对 $a+b+c \ge target$ 的情况进行一个详细的分析：</p><p>如果 $a+b+c \ge target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_c$不变而 $p_b$向右移动，那么 $a+b+c$ 的值就会不断地增加，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_c$的情况下，此时的 $p_b$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_c$了，就可以将 $p_c$向左移动一个位置。</p><p>同样地，在 $a+b+c \le target$ 时：</p><p>如果 $a+b+c \le target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_b$不变而 $p_c$向左移动，那么 $a+b+c$ 的值就会不断地减小，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_b$的情况下，此时的 $p_c$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_b$了，就可以将 $p_b$向右移动一个位置。</p><p>实际上，$p_b$和 $p_c$就表示了我们当前可以选择的数的范围，而每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 $target$ 的值的关系，选择「抛弃」左边界的元素还是右边界的元素，从而减少了枚举的范围。这种思路与 11. 盛最多水的容器 中的双指针解法也是类似的。</p><p><strong>小优化</strong></p><p>本题也有一些可以减少运行时间（但不会减少时间复杂度）的小优化。当我们枚举到恰好等于 $target$ 的 $a+b+c$ 时，可以直接返回 $target$ 作为答案，因为不会有再比这个更接近的值了。</p><p>另一个优化与 15. 三数之和的官方题解 中提到的类似。当我们枚举 $a,b,c$中任意元素并移动指针时，可以直接将其移动到下一个与这次枚举到的不相同的元素，减少枚举的次数。</p><h3 id="15题C-实现："><a href="#15题C-实现：" class="headerlink" title="15题C++实现："></a>15题C++实现：</h3><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        &#x2F;&#x2F;对数组进行排序        sort(nums.begin(), nums.end());        int n &#x3D; nums.size();        &#x2F;&#x2F;枚举a        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            &#x2F;&#x2F;保证和上一次枚举的元素不相等            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                continue;            &#125;            int target &#x3D; -nums[i];            &#x2F;&#x2F;使用双指针枚举b和c            int j &#x3D; i + 1, k &#x3D; n - 1;            while (j &lt; k) &#123;                int sum &#x3D;  nums[j] + nums[k];                &#x2F;&#x2F; 如果和为target则直接返回答案                 if (sum &#x3D;&#x3D; target) &#123;                    result.push_back(&#123;nums[i], nums[j], nums[k]&#125;);                &#125;                if (sum &gt; target) &#123;                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针                    int k0 &#x3D; k - 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;                        --k0;                    &#125;                    k &#x3D; k0;                &#125; else &#123;                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针                    int j0 &#x3D; j + 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;                        ++j0;                    &#125;                    j &#x3D; j0;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h3 id="16题C-实现："><a href="#16题C-实现：" class="headerlink" title="16题C++实现："></a>16题C++实现：</h3><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;        &#x2F;&#x2F;对数组进行排序        sort(nums.begin(), nums.end());        int n &#x3D; nums.size();        int best &#x3D; 1e7;&#x2F;&#x2F; initial                &#x2F;&#x2F;根据差值的绝对值来更新答案        &#x2F;*            auto toNumber &#x3D; [&amp;](string const&amp; s) -&gt; unsigned &#123;                ...            &#125;            []：定义匿名函数            [&amp;]：以引用形式捕获所有外部变量，也就是外部变量均可用            (string const &amp;s) ：匿名函数的参数            -&gt;：定义匿名函数            unsigned：函数返回值类型            &#123;...&#125;：函数实现体        *&#x2F;                auto update &#x3D; [&amp;](int cur) &#123;            if (abs(cur - target) &lt; abs(best - target)) &#123;                best &#x3D; cur;            &#125;        &#125;;        &#x2F;&#x2F;枚举 a        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            &#x2F;&#x2F;保证和上一次枚举的元素不相等            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                continue;            &#125;            &#x2F;&#x2F;使用双指针枚举b和c            int j &#x3D; i + 1, k &#x3D; n - 1;            while (j &lt; k) &#123;                int sum &#x3D; nums[i] + nums[j] + nums[k];                &#x2F;&#x2F; 如果和为target则直接返回答案                 if (sum &#x3D;&#x3D; target) &#123;                    return target;                &#125;                update(sum);                if (sum &gt; target) &#123;                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针                    int k0 &#x3D; k - 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;                        --k0;                    &#125;                    k &#x3D; k0;                &#125; else &#123;                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针                    int j0 &#x3D; j + 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;                        ++j0;                    &#125;                    j &#x3D; j0;                &#125;            &#125;        &#125;        return best;    &#125;&#125;;</code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/">https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;15-三数之和&quot;&gt;&lt;a href=&quot;#15-三数之和&quot; class=&quot;headerlink&quot; title=&quot;15. 三数之和&quot;&gt;&lt;/a&gt;15. 三数之和&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，判断是否存在三元组 &lt;code&gt;[nums[i], nums[j], nums[k]]&lt;/code&gt; 满足 &lt;code&gt;i != j&lt;/code&gt;、&lt;code&gt;i != k&lt;/code&gt; 且 &lt;code&gt;j != k&lt;/code&gt; ，同时还满足 &lt;code&gt;nums[i] + nums[j] + nums[k] == 0&lt;/code&gt; 。请&lt;/p&gt;
&lt;p&gt;你返回所有和为 &lt;code&gt;0&lt;/code&gt; 且不重复的三元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;答案中不可以包含重复的三元组。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:94.二叉树的中序遍历</title>
    <link href="2023/01/27/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>2023/01/27/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-01-27T06:59:43.000Z</published>
    <updated>2023-01-27T08:22:12.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/inorder_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,3,2]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归算法</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123;      &#x2F;&#x2F;原函数没办法对vector数组的内容进行添加        if(!root) &#123;            return;        &#125;      &#x2F;&#x2F;中 左 右        inorder(root-&gt;left, res);        res.push_back(root -&gt; val);        inorder(root-&gt;right, res);    &#125;    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        inorder(root, result);        return result;    &#125;&#125;;</code></pre><ol start="2"><li>迭代</li></ol><p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; stk;        while (root !&#x3D; nullptr || !stk.empty()) &#123;            &#x2F;&#x2F;结点非空时，将root结点push进去， root迭代至左结点            while(root !&#x3D; nullptr) &#123;                stk.push(root);                root &#x3D; root -&gt; left;            &#125;            &#x2F;&#x2F;符合条件的结点都push进去之后，出栈，然后将root结点的值push进res数组中，            root &#x3D; stk.top();            stk.pop();            res.push_back(root -&gt; val);            &#x2F;&#x2F; 将root结点迭代至右结点            root &#x3D; root -&gt; right;         &#125;        return res;    &#125;    &#125;;</code></pre><ol start="3"><li>Morris遍历算法</li></ol><p>思路与算法</p><p>Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 $O(1)$。</p><p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 $x$）：</p><p>如果 $x$ 无左孩子，先将 $x$ 的值加入答案数组，再访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>如果 $x$ 有左孩子，则找到 $x$ 左子树上最右的节点（即左子树中序遍历的最后一个节点，$x$ 在中序遍历中的前驱节点），我们记为 $predecessor $。根据 $predecessor $ 的右孩子是否为空，进行如下操作。<br>如果 $predecessor $ 的右孩子为空，则将其右孩子指向 $x$，然后访问 $x$ 的左孩子，即 $x &#x3D; x.left $。<br>如果 $predecessor $ 的右孩子不为空，则此时其右孩子指向 $x$，说明我们已经遍历完 $x$ 的左子树，我们将 $predecessor $ 的右孩子置空，将 $x$ 的值加入答案数组，然后访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>重复上述操作，直至访问完整棵树。</p><p>其实整个过程我们就多做一步：假设当前遍历到的节点为 xxx，将 xxx 的左子树中最右边的节点的右孩子指向 xxx，这样在左子树遍历完成后我们通过这个指向走回了 xxx，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        TreeNode *predecessor &#x3D; nullptr;        while (root !&#x3D; nullptr) &#123;            if(root -&gt; left !&#x3D; nullptr) &#123;                &#x2F;&#x2F;predecessor就是当前root节点向左走一步，再一直向右走到无法走为止                predecessor &#x3D; root -&gt; left;                while(predecessor -&gt; right !&#x3D; nullptr &amp;&amp; predecessor -&gt; right !&#x3D; root) &#123;                    predecessor &#x3D; predecessor -&gt; right;                &#125;            &#x2F;&#x2F;让predecessor的右指针指向root，继续遍历左子树            if (predecessor -&gt; right &#x3D;&#x3D; nullptr) &#123;                predecessor -&gt; right &#x3D; root;                root &#x3D; root -&gt; left;            &#125;            &#x2F;&#x2F;说明左子树已经访问完了， 需要断开连接            else &#123;                res.push_back(root -&gt; val);                predecessor -&gt; right &#x3D; nullptr;                root &#x3D; root -&gt; right;                &#125;            &#125;            &#x2F;&#x2F;如果没有左孩子，则直接访问右孩子            else &#123;                res.push_back(root -&gt; val);                root &#x3D; root -&gt; right;            &#125;                    &#125;        return res;            &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>力扣官方题解：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回 &lt;em&gt;它的 &lt;strong&gt;中序&lt;/strong&gt; 遍历&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:27.移除元素</title>
    <link href="2023/01/26/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>2023/01/26/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</id>
    <published>2023-01-26T06:02:42.000Z</published>
    <updated>2023-01-26T06:20:07.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><span id="more"></span><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre class="language-none"><code class="language-none">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len &#x3D; removeElement(nums, val);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;</code></pre><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li><p>双指针直接遍历</p><p>使用双指针，左指针为要被修改的元素，右指针为遍历主体，判断元素是否为<code>val</code>。最后返回left即可。C++代码实现如下：</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        &#x2F;&#x2F;双指针        int n &#x3D; nums.size();        int left &#x3D; 0;        for(int right &#x3D; 0; right &lt; n; right++) &#123;            if(nums[right] !&#x3D; val) &#123;                nums[left] &#x3D; nums[right];                left++;            &#125;        &#125;        return left;    &#125;&#125;;</code></pre><ol start="2"><li><p>双指针优化</p><p>初始化两个指针时，左指针为0，右指针为数组的最后一个元素，然后从两边向中间遍历.C++代码实现如下：</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int left &#x3D; 0, right &#x3D; nums.size();        while(left &lt; right) &#123;            if(nums[left] &#x3D;&#x3D; val) &#123;                nums[left] &#x3D; nums[right - 1];                right--;            &#125;            else &#123;                left++;            &#125;        &#125;        return left;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt; 移除所有数值等于 &lt;code&gt;val&lt;/code&gt; 的元素，并返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须仅使用 &lt;code&gt;O(1)&lt;/code&gt; 额外空间并 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt;原地 &lt;/a&gt;修改输入数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:51.N皇后</title>
    <link href="2023/01/17/leetcode-51-N%E7%9A%87%E5%90%8E/"/>
    <id>2023/01/17/leetcode-51-N%E7%9A%87%E5%90%8E/</id>
    <published>2023-01-17T08:52:01.000Z</published>
    <updated>2023-01-17T09:08:56.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[[&quot;Q&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>首先来看一下皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p><p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p><p><img src="http://cdn.leafii.top/img/20210130182532303.jpg" alt="51.N皇后" loading="lazy"></p><p>从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p><p>按照我总结的如下回溯模板，我们来依次分析：</p><pre class="language-C++" data-language="C++"><code class="language-C++">void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); &#x2F;&#x2F; 递归        回溯，撤销处理结果    &#125;&#125;</code></pre><ul><li>递归函数参数</li></ul><p>我依然是定义全局变量二维数组result来记录最终结果。</p><p>参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。</p><p>代码如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> result<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></code></pre><ul><li>递归终止条件</li></ul><p>在如下树形结构中： <img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后" loading="lazy"></p><p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。</p><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">if (row &#x3D;&#x3D; n) &#123;    result.push_back(chessboard);    return;&#125;</code></pre><ul><li>单层搜索的逻辑</li></ul><p>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</p><p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">for (int col &#x3D; 0; col &lt; n; col++) &#123;    if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放        chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后        backtracking(n, row + 1, chessboard);        chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后    &#125;&#125;</code></pre><ul><li>验证棋盘是否合法</li></ul><p>按照如下标准去重：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线 （45度和135度角）</li></ol><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;    &#x2F;&#x2F; 检查列    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 45度角是否有皇后    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 135度角是否有皇后    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p><p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p><p>那么按照这个模板不难写出如下C++代码：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:vector&lt;vector&lt;string&gt;&gt; result;&#x2F;&#x2F; n 为输入的棋盘大小&#x2F;&#x2F; row 是当前递归到棋盘的第几行了void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;    if (row &#x3D;&#x3D; n) &#123;        result.push_back(chessboard);        return;    &#125;    for (int col &#x3D; 0; col &lt; n; col++) &#123;        if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放            chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后            backtracking(n, row + 1, chessboard);            chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后        &#125;    &#125;&#125;bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;    &#x2F;&#x2F; 检查列    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 45度角是否有皇后    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 135度角是否有皇后    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    return true;&#125;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        result.clear();        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#39;.&#39;));        backtracking(n, 0, chessboard);        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n 皇后问题&lt;/strong&gt; 研究的是如何将 &lt;code&gt;n&lt;/code&gt; 个皇后放置在 &lt;code&gt;n×n&lt;/code&gt; 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，返回所有不同的 &lt;strong&gt;n 皇后问题&lt;/strong&gt; 的解决方案。&lt;/p&gt;
&lt;p&gt;每一种解法包含一个不同的 &lt;strong&gt;n 皇后问题&lt;/strong&gt; 的棋子放置方案，该方案中 &lt;code&gt;&amp;#39;Q&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 分别代表了皇后和空位。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer64.求1+2+…+n</title>
    <link href="2023/01/17/%E5%89%91%E6%8C%87Offer64-%E6%B1%821-2-%E2%80%A6-n/"/>
    <id>2023/01/17/%E5%89%91%E6%8C%87Offer64-%E6%B1%821-2-%E2%80%A6-n/</id>
    <published>2023-01-17T05:17:16.000Z</published>
    <updated>2023-01-17T06:10:05.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入: n &#x3D; 3输出: 6</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入: n &#x3D; 9输出: 45</code></pre><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 10000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>错误解法（使用了if）,虽然通过了但是不符合题意。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        if(n &#x3D;&#x3D; 1)        &#123;            return 1;        &#125;        else        &#123;            return n + sumNums(n - 1);        &#125;    &#125;&#125;;</code></pre><ol start="2"><li>由于不能使用乘除法，<code>for</code>，<code>while</code>等关键字以及条件判断语句，因此我们能用的挚友加减法，赋值，位运算符和逻辑运算符。</li></ol><p>但是如果使用递归方法，那么递归的结束条件很难不用条件判断语句，那么怎么解决？答案是使用逻辑运算符<code>&amp;&amp;</code>或者<code>||</code>，利用它的短路性质，对于<code> A &amp;&amp; B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>False</code> ，那么 <code>A &amp;&amp; B</code> 已经确定为 <code>False</code>，此时不会去执行表达式 <code>B</code>。同理，对于逻辑运算符 <code>||</code>， 对于 <code>A || B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>True</code> ，那么<code> A || B</code> 已经确定为<code> True</code> ，此时不会去执行表达式<code> B</code>。</p><p>因此我们可以将判断是否为递归的出口看作<code>A&amp;B</code>表达式中的<code>A</code>部分，递归的主体函数看作<code>B</code>部分。如果不是递归出口，就返回<code>True</code>，并继续执行表达式<code>B</code>的部分，否则递归结束。结合逻辑运算符<code>&amp;&amp;</code>的递归实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        n &amp;&amp; (n +&#x3D; sumNums(n-1));        return n;    &#125;&#125;;</code></pre><p>用逻辑运算符<code>||</code>的递归实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        n&#x3D;&#x3D;1 || (n +&#x3D; sumNums(n-1));        return n;    &#125;&#125;;</code></pre><ol start="3"><li>使用C++的sizeof函数进行$\frac{1}{2}(n \times (n+1))$的模拟：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        bool a[n][n+1]; &#x2F;&#x2F;bool一个元素占一bit        return sizeof(a) &gt;&gt; 1; &#x2F;&#x2F;sizeof(a) 计算了n*(n+1)    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;求 &lt;code&gt;1+2+...+n&lt;/code&gt; ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:2.两数相加</title>
    <link href="2023/01/17/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>2023/01/17/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-01-17T04:34:08.000Z</published>
    <updated>2023-01-17T05:03:43.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/addtwonumber1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]输出：[7,0,8]解释：342 + 465 &#x3D; 807.</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [0], l2 &#x3D; [0]输出：[0]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>将两个链表遍历相加，大致思路如下：</li></ol><blockquote><p>1.相加的过程中可能存在进位的操作，所以需要采用一个变量carry来记录进位的情况，初始化carry &#x3D; 0;</p><p>2.因为链表的数字是倒着放的，所以相加起来很方便，将两个链表从头到尾一起遍历，如果有值的话就将它们的值相加sum &#x3D; val1+val2+carry。</p><p>3.如果是两个长度不一样的链表，则需要注意将不再继续向后，且让相应位的和为val1+0.</p><p>4.carry的更新，carry &#x3D; sum&#x2F;10, 而当前节点和 curr-&gt;val &#x3D; sum%10.</p><p>5.循环直至l1,l2都为空。</p><p>6.遍历完之后如果carry &#x3D;&#x3D; 1, 新建一个节点存在进位。</p></blockquote><p>代码实现：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode *newHead &#x3D; new ListNode(0);        ListNode *p &#x3D; l1;        ListNode *q &#x3D; l2;        ListNode *curr &#x3D; newHead;        int carry &#x3D; 0; &#x2F;&#x2F;进位        while(p !&#x3D; NULL || q !&#x3D; NULL) &#123;            int sum &#x3D; 0, x &#x3D; 0, y &#x3D; 0;            if(p) &#123;                x &#x3D; p -&gt; val;                p &#x3D; p -&gt; next;            &#125;            if(q) &#123;                y &#x3D; q -&gt; val;                q &#x3D; q -&gt; next;            &#125;            sum &#x3D; x + y + carry;            carry &#x3D; sum &#x2F; 10;            curr -&gt; next &#x3D; new ListNode(sum % 10);            curr &#x3D; curr -&gt; next;        &#125;        if(carry) &#123;            curr -&gt; next &#x3D; new ListNode(carry);        &#125;        return newHead -&gt; next;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:35.搜索插入位置</title>
    <link href="2023/01/16/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>2023/01/16/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</id>
    <published>2023-01-16T07:04:57.000Z</published>
    <updated>2023-01-16T07:18:17.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 5输出: 2</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 2输出: 1</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 7输出: 4</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>目标元素有以下几种情况：</p><p>1.插入在数组头部</p><p>2.插入数组中某个位置</p><p>3.在数组中找到该元素</p><p>4.插入数组尾部</p><p>因此可用顺序遍历或者二分查找来解题</p><ol><li>顺序遍历整个数组的暴力解法</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        for(int i &#x3D; 0; i &lt; nums.size(); i++)        &#123;            if(nums[i] &#x3D;&#x3D; target)            &#123;                return i;            &#125;            else if(nums[i] &gt; target)&#123;                return i;            &#125;        &#125;        return nums.size();    &#125;&#125;;</code></pre><ol start="2"><li>使用二分查找法进行位置的查找</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int l&#x3D;0,r&#x3D;nums.size()-1;&#x2F;&#x2F; 我们定义target在左闭右闭的区间里，[left, right] ，当left&#x3D;&#x3D;right，区间[left, right]依然有效        while(l&lt;&#x3D;r)        &#123;            int mid&#x3D;l+(r-l)&#x2F;2;            if(nums[mid]&lt;target)            &#123;                l&#x3D;mid+1;&#x2F;&#x2F; target 在右区间，所以[middle + 1, right]            &#125;            else if(nums[mid]&#x3D;&#x3D;target)            &#123;                return mid;            &#125;            else            &#123;                r&#x3D;mid-1;&#x2F;&#x2F; target 在左区间，所以[left, middle - 1]            &#125;        &#125;        return r+1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;请必须使用时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 的算法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:20.有效的括号</title>
    <link href="2023/01/15/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>2023/01/15/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2023-01-15T05:24:30.000Z</published>
    <updated>2023-01-15T08:01:36.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;()&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;输出：true</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;(]&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用栈进行左半边括号的存储，遍历字符串，当遇到右半边括号时进行匹配，若是相匹配的括号则继续遍历字符串直到最后一个字符，否则返回false。实现代码如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt; sc; &#x2F;&#x2F;创建栈        for(char a:s)&#123; &#x2F;&#x2F;遍历并判断，首先判断栈是否为空，                       &#x2F;&#x2F;接下来判断两个括号是否匹配。            if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;)&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;(&#39;)                sc.pop(); &#x2F;&#x2F;匹配成功后将栈内的左括号弹出            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;]&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;[&#39;)                sc.pop();            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;&#125;&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;&#123;&#39;)                sc.pop();            else                 sc.push(a); &#x2F;&#x2F;若是左括号，则压入栈内        &#125;        return sc.empty(); &#x2F;&#x2F;遍历结束后，若栈为空，则返回true    &#125;&#125;;</code></pre><ol start="2"><li>官方解答</li></ol><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>我们遍历给定的字符串 sss。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 sss 无效，返回 False\text{False}False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 sss 中的所有左括号闭合，返回<code>True</code>，否则返回 <code>False</code>。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 <code>False</code>，省去后续的遍历判断过程。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isValid(string s) &#123;        int n &#x3D; s.size();        if (n % 2 &#x3D;&#x3D; 1) &#123;            return false;        &#125;        unordered_map&lt;char, char&gt; pairs &#x3D; &#123;            &#123;&#39;)&#39;, &#39;(&#39;&#125;,            &#123;&#39;]&#39;, &#39;[&#39;&#125;,            &#123;&#39;&#125;&#39;, &#39;&#123;&#39;&#125;        &#125;;        stack&lt;char&gt; stk;        for (char ch: s) &#123;            if (pairs.count(ch)) &#123;                if (stk.empty() || stk.top() !&#x3D; pairs[ch]) &#123;                    return false;                &#125;                stk.pop();            &#125;            else &#123;                stk.push(ch);            &#125;        &#125;        return stk.empty();    &#125;&#125;;</code></pre><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/">https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;&amp;#123;&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;&amp;#125;&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;]&amp;#39;&lt;/code&gt; 的字符串 &lt;code&gt;s&lt;/code&gt; ，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;li&gt;每个右括号都有一个对应的相同类型的左括号。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:23.合并K个升序链表</title>
    <link href="2023/01/12/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>2023/01/12/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2023-01-12T09:23:49.000Z</published>
    <updated>2023-01-12T09:25:45.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：lists &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：lists &#x3D; [[]]输出：[]</code></pre><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>写一个可以合并两个有序链表的函数，然后对传入的list进行遍历，将list的两个元素两两合并，最后返回头结点。实现代码如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F;合并两个有序链表    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)    &#123;        ListNode* head &#x3D; nullptr;        ListNode* curNode &#x3D; nullptr;        ListNode** temp &#x3D; nullptr;        bool isFirst &#x3D; true;        while(list1 !&#x3D; nullptr &amp;&amp; list2 !&#x3D; nullptr)        &#123;            temp &#x3D; (list1 -&gt; val &lt; list2 -&gt; val)? &amp;list1:&amp;list2; &#x2F;&#x2F;使用二级指针，因为temp如果是一级指针，那么temp &#x3D; temp-&gt;next;是无法改变list1和list2的值的，而二级指针可以间接改变list1和list2的地址。            if(isFirst)            &#123;                head &#x3D; *temp;                curNode &#x3D; *temp;                isFirst &#x3D; false;            &#125;            else            &#123;                curNode -&gt; next &#x3D; *temp;                curNode &#x3D; curNode -&gt; next;            &#125;            *temp &#x3D; (*temp) -&gt; next;        &#125;        if(nullptr !&#x3D; list1)        &#123;            if(isFirst)  &#x2F;&#x2F;有一方链表为空            &#123;                head &#x3D; list1;            &#125;            else         &#x2F;&#x2F;剩下结点直接补齐            &#123;                curNode -&gt; next &#x3D; list1;            &#125;        &#125;        if(nullptr !&#x3D; list2)        &#123;            if(isFirst)            &#123;                head &#x3D; list2;            &#125;            else            &#123;                curNode-&gt;next &#x3D; list2;            &#125;        &#125;        return head;    &#125;    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        ListNode* head &#x3D; nullptr;        for(int i &#x3D; 0; i &lt; lists.size(); i++)        &#123;            head &#x3D; mergeTwoLists(head, lists[i]);        &#125;        return head;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。&lt;/p&gt;
&lt;p&gt;请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:19.删除链表的倒数第N个结点</title>
    <link href="2023/01/11/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>2023/01/11/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2023-01-11T07:20:46.000Z</published>
    <updated>2023-01-11T07:39:19.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/remove_ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2输出：[1,2,3,5]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1], n &#x3D; 1输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2], n &#x3D; 1输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>双指针遍历一次链表，思路如下：</li></ol><p>设置两个指针p，q，分别初始为头结点，然后p指针向后移动n次，接着p和q指针同时移动直到p指针指向链表的最后一个元素，此时q指针指向的是被删除元素的前一个元素，因此将需要被删除的元素进行删除，最终返回头结点即可，需要注意<strong>删除头结点的情况</strong>。实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode *q &#x3D; head, *p &#x3D; head, *t &#x3D; head -&gt; next;        if(head &#x3D;&#x3D; NULL)        &#123;            return head;        &#125;        while(n-- &amp;&amp; p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;p指针向后移动n位        &#123;            p &#x3D; p -&gt; next;        &#125;        if(n !&#x3D; -1) &#x2F;&#x2F;删除头结点        &#123;            t &#x3D; head;            head &#x3D; head -&gt; next;            delete t;            return head;        &#125;        while(p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;此时p和q指针一起向后移动，直到p指向最后一个结点        &#123;            q &#x3D; q -&gt; next;            p &#x3D; p -&gt; next;        &#125;        t &#x3D; q -&gt; next;        q -&gt; next &#x3D; t -&gt; next;        delete t;        return head;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表，删除链表的倒数第 &lt;code&gt;n&lt;/code&gt; 个结点，并且返回链表的头结点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:7.整数反转</title>
    <link href="2023/01/10/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>2023/01/10/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2023-01-10T06:59:15.000Z</published>
    <updated>2023-01-10T07:19:49.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; 123输出：321</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; -123输出：-321</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; 120输出：21</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; 0输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>将数字的每位分别提取并进行字符串拼接，最终将字符串转为int型数字，思路如下：</li></ol><p>因为负数对10取余数得到的结果依然为负数，所以如果x为负数，则将minus标记设置为true，并且将x转化为正数，如果x为正数，则minus标记为false，进行x的正负判断之后可以将string类型的ans_str变量进行初始化，接着进行x的特殊值的判断，因为int型的范围是$-2^{31} 到  2^{31}-1$，所以当<code>x=-2147483648</code>时，它无法被转化为正数进行计算，因此需要单独判断，需要单独判断的还有<code>x=0</code>的情况。接着在while循环中进行倒置的过程。倒置结束后对倒置结果进行判断，如果超过范围的话直接返回0（因为无法通过C++的stoi方法转化为int型结果。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int reverse(int x) &#123;        bool minus &#x3D; false;        string ans_str &#x3D; &quot;0&quot;;        &#x2F;&#x2F;特例判断        if(x &#x3D;&#x3D; -2147483648)&#123;            return 0;        &#125;        if(x &#x3D;&#x3D; 0)        &#123;            return 0;        &#125;        &#x2F;&#x2F;对负数的处理        if(x &lt; 0)        &#123;            ans_str &#x3D; &quot;-0&quot;;            x &#x3D; x * -1;            minus &#x3D; true;        &#125;        &#x2F;&#x2F;在while循环中进行倒置操作，倒置结果储存在ans_str变量中。        while(x !&#x3D; 0)&#123;            int temp_num &#x3D; x % 10;            x &#x3D; x &#x2F; 10;            string temp_str &#x3D; to_string(temp_num);            ans_str &#x3D; ans_str + temp_str;        &#125;        &#x2F;&#x2F;2^31-1 &#x3D; 2147483647        &#x2F;&#x2F;-2^31 &#x3D; -2147483648        &#x2F;&#x2F;通过int型范围设置两个对比的string类型，防止倒置结果超过范围。        string upper &#x3D; &quot;02147483647&quot;;        string lower &#x3D; &quot;-02147483648&quot;;        &#x2F;&#x2F;倒置结果是否超限的判断        if(minus &#x3D;&#x3D; true &amp;&amp; ans_str.length() &#x3D;&#x3D; 12)&#123;            for(int i &#x3D; 0; i &lt; 12; i++)&#123;                if(ans_str[i] &lt; lower[i])&#123;                    break;                &#125;                if(ans_str[i] &gt; lower[i])&#123;                    return 0;                 &#125;            &#125;        &#125;        if(minus &#x3D;&#x3D; false &amp;&amp; ans_str.length() &#x3D;&#x3D; 11)&#123;            for(int i &#x3D; 0; i &lt; 11; i++)&#123;                if(ans_str[i] &lt; upper[i])&#123;                    break;                &#125;                if(ans_str[i] &gt; upper[i])&#123;                    return 0;                &#125;            &#125;        &#125;        &#x2F;&#x2F;最终结果的转化        &#x2F;&#x2F;stoi函数：string -&gt; int        &#x2F;&#x2F;to_string函数：int -&gt; string        int ans &#x3D; stoi(ans_str);        return ans;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 32 位的有符号整数 &lt;code&gt;x&lt;/code&gt; ，返回将 &lt;code&gt;x&lt;/code&gt; 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数超过 32 位的有符号整数的范围 &lt;code&gt;[−231, 231 − 1]&lt;/code&gt; ，就返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设环境不允许存储 64 位整数（有符号或无符号）。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>Decima-Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers</title>
    <link href="2023/01/10/Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers/"/>
    <id>2023/01/10/Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers/</id>
    <published>2023-01-09T17:03:38.000Z</published>
    <updated>2023-01-17T14:49:26.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers"><a href="#Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers" class="headerlink" title="Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)"></a>Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>我们设计了黑盒扰动系统，其中训练了一个代理模型来模仿基于 DRL 的调度策略，并且表明，高可信代理模型可以帮助制作有效的扰动。扰动的意思是对作业的节点特性或依赖性进行轻微调整，同时不改变其功能。</p><p>最终，我们研究了提高基于 DRL 的调度程序对此类扰动的鲁棒性的解决方案：我们提出了一种对抗性训练框架，以强制神经模型在训练过程中适应扰动模式，从而消除应用过程中的潜在损害。</p><span id="more"></span><ul><li><strong>提出问题</strong></li></ul><p>各种研究发现深度神经模型（如DRL模型）容易受到对抗性数据实例的影响（如其观察空间或动作空间输入的扰动）产生错误决策，并且缺乏鲁棒性；而在云计算调度问题中，对鲁棒性也有很高的要求，即使系统中没有恶意用户也有可能会有一些特征模式触发调度程序的不当行为，因此这种鲁棒性问题并不总是与对抗性扰动相关联，但研究它的重要性是绝对的。</p><ul><li><strong>解决思路</strong></li></ul><ol><li>研究如何开发一种有效扰乱工作特征的方法。</li><li>在成功模拟有效扰乱工作特征之后，提出对抗训练方法以提升模型的鲁棒性</li></ol><ul><li><strong>实验结果</strong></li></ul><p>我们的实验表明，这种鲁棒性的提高显着降低了工作扰动的成功率。即使扰动成功，它也会降低扰动作业的性能增益。具有对抗性训练的 DRL 调度器能够实现与原始 DRL 调度器相当的调度性能。</p><h3 id="黑盒扰动系统"><a href="#黑盒扰动系统" class="headerlink" title="黑盒扰动系统"></a>黑盒扰动系统</h3><p>首先提出之前有人设计的白盒扰动系统，白盒方法假设用户可以访问 DRL 模型的详细信息，包括模型架构和参数。但白盒扰动系统存在这样一个问题：对于调度策略未知的许多云系统，该假设通常不成立。</p><p>因此工作扰动系统采用黑盒假设来解决这个问题，这意味着恶意用户无法访问 DRL 模型和其他用户的工作，如下图中的阴影方块所示。</p><p><img src="http://cdn.leafii.top/img/image-20230116152713038.png" alt="image-20230116152713038" loading="lazy"></p><p>其核心技术是模型窃取，即利用制造的数据集训练本地代理模型作为目标模型的替代品。代理模型不需要与其目标具有相同的结构，而只是模仿功能。</p><p>恶意用户通过模仿得到相同种类但细节不同的job，然后将job在空闲时间提交以获得调度程序的神经模型。通过执行完成后的调度轨迹，可以得知调度程序在每个时间步做出怎样的决策。因此，它只通过几个调度轨迹就得到了一个比较可信的代理神经网络。并且通过job状态和决策形成的元组，它将一个调度问题解耦成了一个分类问题。</p><p>在该代理模型的帮助下，恶意用户就可以在job提交之前计算并且应用扰动（增加一些任务的并行度或者在任务之间增加依赖关系）来获得额外的计算资源以达成早一些完成任务的目的。</p><h3 id="作业扰动"><a href="#作业扰动" class="headerlink" title="作业扰动"></a>作业扰动</h3><p>作业扰动的目的是在某些时间步将调度决策偏向错误的方向。</p><p><strong>成功施加扰动的难点</strong>：</p><p>首先，扰动可以应用于作业中多达数百个特征，并且很难获得最优计划。</p><p>其次，扰动作业试图抢占动态系统中的资源。它会在调度过程中的一个确定的时间步发生。具体成功时间由当时的系统状态快照决定，这是系统禁止的。</p><h4 id="基于梯度的扰动"><a href="#基于梯度的扰动" class="headerlink" title="基于梯度的扰动"></a>基于梯度的扰动</h4><h5 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h5><p>$job_k$ 的特征形成一个 $m \times n $矩阵 $X_k : (x_i,j)$，其中 $m_k$ 是任务数，$n$ 是特征数。此外，只有解决了任务的依赖关系才能执行任务，这些依赖关系由相邻矩阵 $E_k : (e_i,j)$ 表示，其中 $i, j \in [1, m_k]$。</p><p><strong>关于扰动</strong>：我们只会扰乱<strong>并行性</strong>和<strong>依赖性</strong>。</p><h5 id="特征扰动"><a href="#特征扰动" class="headerlink" title="特征扰动"></a>特征扰动</h5><p>在调度程序执行的过程中，一个任务是否被优先调度取决于它的得分。为了让被扰动的作业优先执行且占用更多资源，必须通过扰动让被扰动的作业获得更高的分数，只有获得更高的分数，它才能被执行。被扰动的作业优先被调度时必须满足下面公式：</p><p>$O_t[\bar{o_t}] &gt; O_t[o_t]$</p><p>但是本身被扰动的作业在被扰动前它的$O_t[\bar{o_t}]$就同$O_t[o_t]$相差很大，因此需要通过扰动使其获得更高的分数。为了决定扰动哪个特征可以使分数增加更多，提出了特征梯度的概念。</p><p>$\nabla \chi_tO_t[\bar{o_t}] &#x3D; \frac{\partial O_t[\bar{o_t}]}{\partial \chi_t}$</p><p>通过特征梯度可以得知作业中哪个特征的扰动对$O_t[o_t]$值的影响更显著。因此可以通过下面式子得知哪个task的哪个feature应该被选择去扰动。</p><p>$T^*, f^* &#x3D; argmax[\frac{\partial O_t[\bar{o_t}]}{\partial \chi_t}]$</p><p>确定了对哪个特征进行扰动，就该进行扰动的实际操作了，沿着值方向对特征进行增量应用扰动，如下式：</p><p>$x_{T^*, f^*} &#x3D; x_{T^*, f^*} + sign([\frac{\partial O_t[\bar{o_t}]}{\partial \chi_t}]_{T^*, f^*}) \times \delta$</p><h5 id="依赖扰动"><a href="#依赖扰动" class="headerlink" title="依赖扰动"></a>依赖扰动</h5><p>因此不能破坏原有任务的依赖性，因此所谓的依赖扰动就是通过加入以前独立的任务来应用依赖性扰动。它的评判标准被定义为下面的式子：</p><p>$\nabla \varepsilon_tO_t[\bar{o_t}] &#x3D; avg[\frac{\partial O_t[\bar{o_t}]}{\partial \varepsilon_t^i}] &#x3D; \frac{1}{K}\sum_{i&#x3D;1}^{K} \frac{\partial \bar{\pi_\theta}(\chi_t, \varepsilon_t^i)}{\partial \varepsilon_t^i}$</p><p>边缘梯度在相邻矩阵 $E_t$ 上形成显着图，其中较高的值表示在应用扰动时输出分量的改进更为显着。因此，在任务$T_f^*$和任务$T_t^*$之间的边被添加了：</p><p>$T_f^*, T_t^* &#x3D; argmax(avg[\frac{\partial O_t[\bar{o_t}]}{\partial \varepsilon_t^i}])$</p><p>识别出的边缘还应该满足这两个任务都属于恶意用户的工作并且之前是独立的。否则，上面的式子将继续寻找下一条除了不满足条件外显着性值最大的边。</p><h4 id="近似扰动"><a href="#近似扰动" class="headerlink" title="近似扰动"></a>近似扰动</h4><p>由于矩阵$\chi_t$和$\varepsilon_t$ 的一些部分不可访问，因此在训练过程中，通过自己的定义，将之前方程中梯度的专用分量可以通过每个独立输入作业的梯度来近似。</p><p>$T^*, f^* \approx argmax[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{X_t}}]$</p><p>$T_f^*, T_t^* \approx argmax(avg[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{E_t^i}}])$</p><p>当原始调度决策不那么明显时，在时间步长 t 应用扰动是至关重要的。我们通过近似来解决决定时间步长的问题。</p><p>通过用原始工作特征$\hat{X}$和$\hat{E^i}$替换即时的工作特征$\hat{X_t}$和$\hat{E_t^i}$。我们以工作的关键路径上的所有任务为目标进行综合考虑，将上面的两个近似式子重构成了以下式子：</p><p>$T^*, f^* \approx argmax[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{X}}]$</p><p>$T_f^*, T_t^* \approx argmax(avg[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{E^i}}])$</p><p>由于特征和依赖扰动计划都是时不变的，因此可以通过以 O(1) 时间成本提交的作业来计算。</p><h3 id="基于-DRL-的调度器的稳健性改进"><a href="#基于-DRL-的调度器的稳健性改进" class="headerlink" title="基于 DRL 的调度器的稳健性改进"></a>基于 DRL 的调度器的稳健性改进</h3><p>我们描述了一个对抗训练框架来提高 DRL 调度器的稳健性。它通过让调度程序在训练期间学习工作扰动的模式来提高鲁棒性。</p><p>在强化学习中，用来更新策略$\pi$的参数$\theta$的梯度可以通过以下式子获得：</p><p>$g &#x3D; E[\sum_{t&#x3D;0}^{\infin}R_t \nabla log_\theta (\pi_\theta(A_t|S_t))]$</p><p>在对抗训练期间，扰动状态 $S_t^*$ 和原始状态 $S_t$ 一起学习，以将梯度引向$\nabla log_\theta (\pi_\theta(A_t|S_t)) + \nabla log_\theta (\pi_\theta(A_t|S_t^*))$。</p><p>在训练阶段添加这种对抗性扰动可以使模型在寻找最高奖励时不那么极端，如果扰动发生在应用阶段 ，则模型会更加稳健。</p><p>对抗训练的整体工作流程为：</p><p><img src="http://cdn.leafii.top/img/image-20230116165033169.png" alt="image-20230116165033169" loading="lazy"></p><p>对抗训练框架的示意图：</p><p><img src="http://cdn.leafii.top/img/image-20230116165112449.png" alt="image-20230116165112449" loading="lazy"></p><p>原始状态和扰动状态被馈送到模型中进行梯度计算，并使用相同的奖励信号更新模型。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h4><p>我们使用 Decima的作业执行引擎作为我们的测试平台。</p><p>在我们的实验中，我们将集群的执行器数量设置为 10 和 20。我们使用 TPC-H 作业 [41] 作为工作负载。作业的统计信息，包括每个作业 DAG 中的级别、任务数以及每个任务的并行度和持续时间，如表 2 所示。作业运行时间遵循重尾分布，大约 20% 的作业占用所有作业运行时间的 80%。</p><p><img src="http://cdn.leafii.top/img/image-20230116171153629.png" alt="image-20230116171153629" loading="lazy"></p><p>我们实现了三种 DRL 算法作为 Decima 调度框架的插件，以证明这个问题对于不同的 DRL 算法是常见的。</p><p>第一种算法是REINFORCE，其每个时间步的奖励是通过使用情景样本的蒙特卡洛方法估计的，原始 Decima 调度程序也使用该方法。</p><p>第二种算法是off-policy policy gradient(OPPG),它使用行为策略来推导调度决策并计算另一个目标策略的重要性采样。</p><p>第三种算法是同步优势演员评论家 (A2C)，参与者(actor)使用策略模型生成动作，而评论家(critic)则使用另一个神经模型来预测每个动作的优势.每个模型中的核心策略都是用全连接神经网络实现的。实际上，A2C 使用 5 种不同的陈旧版本。 A2C 中的演员和评论家由不同的全连接层组成。actor 具有动态数量的输出，形成任务的概率分布，而 critic 仅输出一个单元。</p><p>图神经网络结合了非线性激活和聚合函数，这为调度程序提供了输入的全局视图，以获得更好的调度策略。</p><p>调度程序的脆弱性是通过它们受工作扰动影响的可能性来衡量的。成功的扰动会抢占资源以提前完成扰动的工作，同时延迟其他工作.</p><p>评估脆弱性的三个指标：扰动的成功率、扰动工作的好处（通过降低 JCT(任务完成时间) 来衡量）以及显着延迟的工作数量。而稳健性的提高是通过这些指标的减少来衡量的。</p><h4 id="模型窃取"><a href="#模型窃取" class="headerlink" title="模型窃取"></a>模型窃取</h4><p>忠实的代理神经模型对于<strong>黑盒扰动</strong>的成功至关重要。我们启动 50 个查询来窃取作业调度程序中的模型。每个查询包含 20 个根据时间步长安排的模拟作业。总的来说，我们从 11,000 个调度时间步长中获得了状态和动作对。其中 80% 用于训练，其余 20% 用于测试。代理模型学习如何在每个时间步将调度程序从数百个其他任务中选择的任务分类。最终实验结果表明：CNN 模型达到了 82.2% 的精度来近似 REINFORCE，而 GCN 达到了 85.0% 的精度来近似 OPPG。</p><p><img src="http://cdn.leafii.top/img/image-20230116181602908.png" alt="image-20230116181602908" loading="lazy"></p><h4 id="基于-DRL-的调度程序的脆弱性"><a href="#基于-DRL-的调度程序的脆弱性" class="headerlink" title="基于 DRL 的调度程序的脆弱性"></a>基于 DRL 的调度程序的脆弱性</h4><p>在本节中，进行了多次实验来评估漏洞。在每个实验中，提交了 50 个作业，其中一个作业被扰动了。独立评估不同的基于 DRL 的调度程序。将每个作业的作业完成时间与在相同设置但没有作业扰动的情况下获得的作业完成时间进行比较。</p><p><img src="http://cdn.leafii.top/img/image-20230116181800279.png" alt="image-20230116181800279" loading="lazy"></p><p>(a) 黑盒作业扰动干扰每个基于 DRL 的调度程序的成功率。 (b) 受扰动工作的好处（以减少的 JCT 衡量）和由于扰动工作的好处而严重延迟的正常工作（其 JCT 增加超过 5%）的数量。</p><p><strong>最终结果</strong>：REINFORCE 比其他两个调度程序更容易受到扰动，因为后者有超过 10 个正常作业被显着延迟。 OPPG和A2C的鲁棒性更强主要是因为独立行为策略或批评模型达到了一定的鲁棒性。</p><h4 id="对于扰动的详细说明"><a href="#对于扰动的详细说明" class="headerlink" title="对于扰动的详细说明"></a>对于扰动的详细说明</h4><p>为了理解基于 DRL 的调度器的脆弱性，我们首先给出扰动的统计数据，然后给出一个详细的例子来说明扰动是如何产生影响的。</p><p><strong>在改变并行度方面</strong>：并行度的降低是通过为数据分区插入“合并”运算符来实现的，而并行度的增加是通过在任务代码的开头添加运算符“repartition”来实现的。</p><p><strong>在增加依赖方面</strong>：两个任务的连接是通过“连接”的运算符实现的。</p><p>通过以上方式成功实现了扰动。</p><p><img src="http://cdn.leafii.top/img/image-20230116182309070.png" alt="image-20230116182309070" loading="lazy"></p><p>不同类型的扰动。从左到右，作业受到 (i) 仅增加任务并行度，(ii) 降低作业并行度并添加依赖项，以及 (iii) 仅添加依赖项的干扰。</p><h4 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h4><p>我们提供了一个案例研究来解释用不同方法扰乱的工作如何使他们的 JCT 受益，如图9所示：</p><p><img src="http://cdn.leafii.top/img/image-20230116183729916.png" alt="image-20230116183729916" loading="lazy"></p><p>扰动或调整后的并行度由每个任务节点周围的数字显示。示例作业没有依赖性变化，因为显着性值太低，即改变依赖性不会导致成功的扰动。</p><p>我们使用 REINFORCE 调度程序比较每个扰动作业的任务执行模式和同一环境中的原始作业，如图10所示：</p><p><img src="http://cdn.leafii.top/img/image-20230116183920593.png" alt="image-20230116183920593" loading="lazy"></p><p><strong>实验结果表明</strong>：经过扰动后，这些任务能够在某些调度步骤中具有更高的优先级。这些任务以更高的并行度执行，因此更早完成。它们的完成也可能导致依赖于它们的后续任务的提前执行。</p><h4 id="鲁棒性的提升"><a href="#鲁棒性的提升" class="headerlink" title="鲁棒性的提升"></a>鲁棒性的提升</h4><p>在本节中，我们评估了对抗训练在提高基于 DRL 的调度程序处理扰动工作的鲁棒性方面的有效性。</p><h5 id="对抗训练"><a href="#对抗训练" class="headerlink" title="对抗训练"></a>对抗训练</h5><p>一个健壮的基于 DRL 的调度器的实现方式与第 6.1 节中详述的方式类似。我们还在调度程序中包含了不同的强化学习实现，即 REINFORCE、OPPG 和 A2C。</p><p>每个调度器的正常训练和对抗训练的过程如图11的左栏所示：</p><p><img src="http://cdn.leafii.top/img/image-20230116184150766.png" alt="image-20230116184150766" loading="lazy"></p><blockquote><p>左列显示了基于 DRL 的调度程序的正常和对抗训练过程。每个模型的收敛由平均奖励的扁平化表示。右列显示了基本调度程序和鲁棒调度程序在 50 个作业集上的调度性能。剩余作业数量减少得越快，调度性能越好。具体来说，Reinforce的图如(a)和(b)所示，OPPG的图如(c)和(d)所示，A2C的图如(e)和(f)所示。</p></blockquote><p>该过程的特点是在每个情节中获得的归一化平均奖励。在训练过程中包括受扰动的工作会使收敛花费更长的时间，并且收到的奖励会波动（图 11a 和 11e）。</p><h5 id="调度表现"><a href="#调度表现" class="headerlink" title="调度表现"></a>调度表现</h5><p>我们将每个基于 DRL 的鲁棒调度程序的调度性能与基本对应调度程序进行比较。Jobs的执行流程如图11右栏所示。</p><p>总而言之，强大的 DRL 调度器保持了令人满意的调度性能。</p><h5 id="鲁棒性评估"><a href="#鲁棒性评估" class="headerlink" title="鲁棒性评估"></a>鲁棒性评估</h5><p>我们在“基于 DRL 的调度程序的脆弱性”的相同实验设置下评估了基于 DRL 的鲁棒调度程序的脆弱性，并将展示鲁棒性改进。</p><p>总的来说，我们的对抗训练方法可以提高基于 DRL 的调度程序的鲁棒性并减少工作扰动的影响。</p><h4 id="白盒扰动的脆弱性"><a href="#白盒扰动的脆弱性" class="headerlink" title="白盒扰动的脆弱性"></a>白盒扰动的脆弱性</h4><p>在“Whitebox”中，它拥有了一个更强的假设，即用户可以完全访问 DRL 模型。特征中的所有显着性值空间是在原始 DRL 模型而不是代理模型上计算的。在本节中，我们评估鲁棒调度程序是否也对白盒扰动具有鲁棒性。</p><p><img src="http://cdn.leafii.top/img/image-20230116185045106.png" alt="image-20230116185045106" loading="lazy"></p><p>总的来说，通过代理模型训练的鲁棒调度器可以有效地处理白盒模型产生的扰动作业。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本文中，我们探讨了基于 DRL 的调度程序的稳健性问题。 我们展示了用户可以在代理模型的帮助下扰乱作业以进行抢占，代理模型是为模仿基于 DRL 的调度程序的调度行为而开发的。 就工作自然具有某些特征模式而言，扰动可能是无意的。 这可能导致调度行为的不确定性。 我们提出了一种计算作业扰动的算法，并表明扰动作业具有很高的成功率以获得高调度优先级。 我们表明这种扰动对调度程序有害，因为它会导致系统中其他作业的意外延迟。 我们设计了一个对抗训练框架来提高 DRL 调度程序的稳健性。 广泛的实验表明，鲁棒调度器在保持高调度性能的同时不易受到扰动的影响。</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>TPC-H, 2020. [Online]. Available: <a href="http://www.tpc.org/tpch/">http://www.tpc.org/tpch/</a> default5.asp</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ieeexplore.ieee.org/abstract/document/9937194">Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers&quot;&gt;&lt;a href=&quot;#Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers&quot; class=&quot;headerlink&quot; title=&quot;Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)&quot;&gt;&lt;/a&gt;Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)&lt;/h2&gt;&lt;h3 id=&quot;解决的问题&quot;&gt;&lt;a href=&quot;#解决的问题&quot; class=&quot;headerlink&quot; title=&quot;解决的问题&quot;&gt;&lt;/a&gt;解决的问题&lt;/h3&gt;&lt;p&gt;我们设计了黑盒扰动系统，其中训练了一个代理模型来模仿基于 DRL 的调度策略，并且表明，高可信代理模型可以帮助制作有效的扰动。扰动的意思是对作业的节点特性或依赖性进行轻微调整，同时不改变其功能。&lt;/p&gt;
&lt;p&gt;最终，我们研究了提高基于 DRL 的调度程序对此类扰动的鲁棒性的解决方案：我们提出了一种对抗性训练框架，以强制神经模型在训练过程中适应扰动模式，从而消除应用过程中的潜在损害。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
  </entry>
  
  <entry>
    <title>Decima-Learning Scheduling Algorithms for Data Processing Clusters</title>
    <link href="2023/01/09/Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters/"/>
    <id>2023/01/09/Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters/</id>
    <published>2023-01-09T09:39:18.000Z</published>
    <updated>2023-01-17T11:56:50.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters-用强化学习解决调度问题"><a href="#Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters-用强化学习解决调度问题" class="headerlink" title="Decima(Learning Scheduling Algorithms for Data Processing Clusters):用强化学习解决调度问题"></a>Decima(Learning Scheduling Algorithms for Data Processing Clusters):用强化学习解决调度问题</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>解决了在云上的多个以DAG图表示的任务在多个Executor上运行时的调度问题。该问题为NP-Hard难度的问题，在该论文中，作者使用RL和GNN来解决它。</p><span id="more"></span><ul><li><strong>任务描述</strong></li></ul><p>每一个节点表示一个计算的阶段(computation stage)， 每个阶段都包含可以并行计算的任务；</p><p>每一条边表示数据依赖(Data dependencies)，父节点完成之后子节点才可以开始运行。</p><p><img src="http://cdn.leafii.top/img/image-20230115181529685.png" alt="image-20230115181529685" loading="lazy"></p><ul><li><strong>交互过程</strong></li></ul><ol><li>调度器接受任务，并且将挂起的计算阶段映射到可用服务器上运行。</li><li>与此同时不断有新的、随机的任务请求出现，即待分配的任务和可用的服务器都处于动态变化的环境中。</li><li>智能体的观测(Observation)：所有可用作业的信息和服务器在每个调度事件上的状态。(the information of all available jobs and the status of the servers at every scheduling event.)</li><li>目标：最小化任务的平均完成时间。</li></ol><p><img src="http://cdn.leafii.top/img/image-20230115184822403.png" alt="image-20230115184822403" loading="lazy"></p><ul><li>论文贡献：<ul><li>针对具有依赖关系的任务，使用RL训练workload-specific调度算法：Decima</li><li>使用可伸缩的GNN来表示调度策略，可以处理任意形状和大小的DAG表示的任务</li><li>任务随机到达，可以进行在线学习</li></ul></li></ul><h3 id="强化学习模型"><a href="#强化学习模型" class="headerlink" title="强化学习模型"></a>强化学习模型</h3><ul><li>Action组成：(node, 服务器数量)</li><li>当服务器池中有空闲服务器的时候，选择一个node，为其分配相应的节点数量，重复该过程直至所有服务器都处于忙碌状态。这样的<strong>优点</strong>是减少动作空间大小和动作序列的长度，降低强化学习的难度，作者称这是唯一work的设计。</li></ul><p><img src="http://cdn.leafii.top/img/image-20230115190117750.png" alt="image-20230115190117750" loading="lazy"></p><ul><li>State：DAG信息（包括任务数量、平均任务时间、可用服务器数量、待决策的任务数量等</li></ul><h3 id="GNN（DAG信息聚合）"><a href="#GNN（DAG信息聚合）" class="headerlink" title="GNN（DAG信息聚合）"></a>GNN（DAG信息聚合）</h3><p>$e_v &#x3D; g[\sum_{w\in\xi(v)}f(e_w)]+x_v$</p><p>其中x表示节点的特征，w表示所有的子节点，因此节点的打分因子是由子节点分数之和以及节点特征决定的。</p><p><img src="http://cdn.leafii.top/img/image-20230115192627762.png" alt="image-20230115192627762" loading="lazy"></p><p>使用两个非线性函数是因为它能让Decima表达更加广泛多变的聚合函数，例如$f\sim log(\cdot&#x2F;n),g\sim exp(n \times \cdot)$时，Decima能表示下图的关键路径：</p><p><img src="http://cdn.leafii.top/img/image-20230115192642575.png" alt="image-20230115192642575" loading="lazy"></p><p>$e_t^i &#x3D; g[\sum_{w\in \xi(v)}f(e_w^i)]+x_v^i$</p><p>上式为Per-node embeddings表达式，体现了子节点的信息向当前节点汇聚的过程。与Per-node embedding类似，作者为每个Job和所有的任务都分别设计了Per-job embeddings</p><p>${(x_v^i,e_v^i), v\in G_i} \rightarrow y^i$</p><p>以及global embeddings</p><p>${y^1, y^2, …} \rightarrow z$</p><p>GNN(节点信息聚合)的全过程在论文中由下图表示：</p><p><img src="http://cdn.leafii.top/img/image-20230115192235075.png" loading="lazy"></p><p>因此，每个层级的信息聚合由两个非线性变换(f and g)表示；整个GNN由6个非线性变换构成。</p><h3 id="决策网络设计"><a href="#决策网络设计" class="headerlink" title="决策网络设计"></a>决策网络设计</h3><ul><li>调度过程：当某个job完成或者有新job到达时，系统开始调度。</li><li>动作(action)$&lt;v,l_i&gt;$有两个维度，决策网络的输出包括两部分，v是选择哪个任务节点($P_{node}$)，$l_i$是为这个任务分配多少计算资源(Parallelism limit on job)。调度包括以下三个阶段：<ul><li>当任务i使用的服务器比$l_i$少时，Decima为节点$v$分配executors直到executors的数量到达$l_i$.</li><li>上一步完成后，如果有多余的executors，Deciam将继续运行agent得到stage($v$)和parallelism($l_i$).</li><li>上述步骤一直运行，直至没有空闲的executors和未处理的stage($v$).</li></ul></li></ul><p>网络结构如下图所示，包括了GNN部分以及决策网络部分，GNN负责聚合DAG的信息，决策网络负责输出stage($v$)以及并行度上线(parallelism limit)($l_i$):</p><p><img src="http://cdn.leafii.top/img/image-20230115201806948.png" alt="image-20230115201806948" loading="lazy"></p><h3 id="决策网络运行过程"><a href="#决策网络运行过程" class="headerlink" title="决策网络运行过程"></a>决策网络运行过程</h3><ol><li>得到stage(v)</li></ol><ul><li>用非线形网络$q(\cdot)$，得到$q_v^i\triangleq q(e_v^i, y^i, z)$</li><li>使用softmax层，选择调度的stage(v)</li></ul><p>$P(node &#x3D; v) &#x3D; \frac{exp(q_v^i)}{\sum_{u\in A_t}exp(q_u^{j(u)})}$</p><ol start="2"><li>为任务节点分配服务器数量parallelism limit($l_i$)</li></ol><p>计算过程与得到stage(v)类似</p><h3 id="训练模型与实验"><a href="#训练模型与实验" class="headerlink" title="训练模型与实验"></a>训练模型与实验</h3><p>系统的整体结构图如下：</p><p><img src="http://cdn.leafii.top/img/image-20230115203338248.png" alt="image-20230115203338248" loading="lazy"></p><p>模型训练采用的是策略梯度法(PG):</p><p><img src="https://pic2.zhimg.com/v2-83eb2d85ec07441692e6da4f59954399_r.jpg" alt="img" loading="lazy"></p><p><img src="https://pic2.zhimg.com/80/v2-0d73ffcf998e888ae8ad7d745ccb0591_1440w.webp" alt="img" loading="lazy"></p><p>作者在训练时采用以下公式更新策略梯度：</p><p>$\theta \leftarrow \theta + \alpha \sum_{k&#x3D;1}^{T} \nabla_\theta log \pi_\theta (s_k, a_k)(\sum_{k’ &#x3D; k}^{T}r_{k’} - b_k)$</p><p>其中$\alpha$为学习率， $b_k$为baseline，添加baseline是参见此<a href="https://leafii.top/2022/09/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0_PPO%E7%AE%97%E6%B3%95(Proximal%20Policy%20Optimization)/">链接</a></p><p>在训练初期使用较短的任务序列，逐渐加长序列。</p><ul><li>因为在训练初期，agent比较笨，它无法对长序列进行很好的处理，反而会导致任务堆积，学习效率也很低。因此作者的构想为先处理简单的，再逐渐增加难度，效率会高一些。</li><li>这是一种课程学习(curriculum learning)的模式</li></ul><p><strong>与(朴素的)传统方法比较</strong></p><ul><li>朴素的先进任务先执行、最短任务优先会导致资源闲置等待。朴素的公平分配虽然会使服务器没有闲置，但是会导致大量IO开销从而拖慢速度。</li></ul><p>而<strong>Decima</strong></p><ul><li>有选择的将服务器集中在某些小任务上，同时仍然不留下任何资源空闲。</li><li>为每个作业分配适当数量的服务器，这样就不会产生不必要的IO工作。</li></ul><p><strong>实验</strong></p><ul><li>在任务batched arrivals、按泊松分布continuous arrivals两个实验里，Decima完爆传统方法。</li><li>ppt里暂时没看到对任务信息的更进一步描述，比如复杂度分布之类的。不过讲到了Decima完成小任务特别快，并且倾向于对小任务分配更多（但不会过多）的服务器。</li><li>其他实验：解决其他资源调度问题、评估算法各个部分的影响、大规模集群泛化、训练及推理速度、离线优化等，ppt里没讲，等我看了论文再补充</li></ul><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>我们已经将 Decima 实现为一种可插入的调度服务，并行数据处理平台可以通过 RPC 接口与之通信。在 §6.1 中，我们描述了 Decima 与 Spark 的集成。接下来，我们将描述我们基于 Python 的训练基础设施，其中包括一个准确的 Spark 集群模拟器（§6.2）。</p><h4 id="Spark集成"><a href="#Spark集成" class="headerlink" title="Spark集成"></a>Spark集成</h4><p>Spark集群的结构图如图所示：</p><p><img src="http://cdn.leafii.top/img/image-20230117181231455.png" alt="image-20230117181231455" loading="lazy"></p><p>为了在 Spark 中集成 Decima，我们做了两个主要更改：</p><ol><li>每个应用程序的 DAG 调度程序在启动时和调度事件发生时联系 Decima。 Decima 响应下一阶段的工作和并行度限制（§5.2）。</li><li>当新作业到达时，Spark master 会联系 Decima 以确定为其启动多少执行程序，并通过在完成一个阶段后将执行程序从作业中撤走来帮助 Decima。</li></ol><p><strong>State observations.</strong></p><p>(i) 阶段中剩余的任务数量，(ii) 平均任务持续时间，(iii) 当前在该节点上工作的执行者数量，(iv) 可用执行者数量，以及 (v) 可用执行者是否可用当地的工作。我们通过尝试包含捕获集群状态所需的信息来选择这些功能（例如，当前分配给每个阶段的执行者数量），以及可能有助于调度决策（例如，一个阶段的平均任务持续时间）。这些统计数据取决于可用信息（例如，同一作业过去执行的配置文件或运行时指标）和所使用的系统（此处为 Spark）。 Decima 可以很容易地合并额外的信号。</p><p><strong>Neural network architecture.</strong></p><p>图神经网络的六个转换函数 f (·) 和g(·) (§5.1)（节点级、作业级和全局嵌入各两个）和策略网络的两个评分函数 q(·) 和 w( ·) (§5.2) 是使用双隐藏层神经网络实现的，每层有 32 和 16 个隐藏单元。由于这些神经网络可重复用于所有作业和所有并行限制，因此 Decima 的模型是轻量级的——它总共包含 12,736 个参数 (50KB)。将集群状态映射到调度决策所需的时间不到 15 毫秒（图 15b）。</p><p><img src="http://cdn.leafii.top/img/image-20230117181739095.png" alt="image-20230117181739095" loading="lazy"></p><h4 id="Spark模拟"><a href="#Spark模拟" class="headerlink" title="Spark模拟"></a>Spark模拟</h4><p>为了忠实地模拟 Decima 的决策如何与集群交互，我们的模拟器捕获了几个真实世界的效果：</p><p>(1) 来自特定阶段的第一波任务通常比后续任务运行得慢。这是由于 Spark 的流水线任务执行 [63]、任务代码的 JIT 编译 [47] 和预热成本（例如，与其他执行程序建立 TCP 连接）。因此，Decima 的模拟环境从不同的分布中选择<strong>第一波</strong>任务的实际运行时间，而不是后来的波。 </p><p>(2) 为Spark作业添加执行器需要启动JVM进程，耗时2-3秒。 Executors 与工作相关联以进行隔离，因为 Spark 假定它们是长期存在的。因此，每次 Decima 跨作业移动执行程序时，Decima 的环境都会施加空闲时间以反映启动延迟。 </p><p>(3) 高度并行会减慢单个 Spark 任务，因为更广泛的混洗需要额外的 TCP 连接，并在合并来自许多分片的数据时创建更多工作。 Decima 的环境通过从不同并行级别收集的分布中抽样任务持续时间来捕获这些影响（如果此数据可用）</p><p>我们通过将其与真实的 Spark 执行进行比较来验证我们的模拟器的保真度。（结果当然是模拟器的保真度很高啦）</p><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>我们在真实的 Spark 集群测试台上和<strong>阿里巴巴的生产工作负载</strong>模拟中评估了 Decima。</p><p>我们的实验解决了以下问题：</p><p>(1) 与真实 Spark 集群中精心调整的启发式算法相比，Decima 的性能如何 (§7.2)？ </p><p>(2) Decima 的学习能否推广到具有不同机器配置的多资源设置（§7.3）？</p><p>(3) 我们的每一个关键想法如何为 Decima 的业绩做出贡献；当调度环境发生变化时，Decima 如何适应；以及 Decima 训练和训练后做出调度决策的速度有多快？</p><h4 id="现有的baseline算法"><a href="#现有的baseline算法" class="headerlink" title="现有的baseline算法"></a>现有的baseline算法</h4><p>(1) Spark 的默认 FIFO 调度，它按照作业到达的相同顺序运行作业，并根据用户请求为每个作业授予尽可能多的执行程序。 </p><p>(2) 最短作业优先的关键路径启发式 (SJF-CP)，它根据作业的总工作量确定作业的优先级，并在每个作业中运行其关键路径上下一阶段的任务。</p><p>(3) 简单的公平调度，它为每个作业提供平等公平的执行者份额，并轮询来自可运行阶段的任务，以同时耗尽所有分支。 </p><p>(4) 朴素加权公平调度，将执行者分配给与其总工作成比例的工作。 </p><p>(5) 一个精心调整的加权公平调度，给每个作业 Tα i &#x2F;Í iTα i 的总执行者数，其中 Ti 是每个作业 i 的总工作量，α 是一个调整因子。请注意，α &#x3D; 0 简化为简单公平方案，而 α &#x3D; 1 简化为朴素加权公平方案。我们遍历 α ∈ {−2,−1.9,…,2} 以获得最佳因子。 </p><p>(6) 来自俄罗斯方块 [34] 的标准多资源打包算法，它贪婪地调度最大化请求资源向量和可用资源向量的点积的阶段。 </p><p>(7) Graphene<em>，Graphene [36] 对 Decima 的离散执行器类的改编。 Graphene</em> 使用 Graphene 的算法 [36, §4.1] 检测和分组“有问题的”节点，并将它们与（5）中优化调整的并行性一起调度，实现 Graphene 规划策略的本质。我们执行网格搜索以优化超参数（附录 F 中的详细信息）。</p><h4 id="Spark-cluster"><a href="#Spark-cluster" class="headerlink" title="Spark cluster"></a>Spark cluster</h4><p>我们使用运行 Spark v2.2 的 OpenStack 集群，在 <strong>Chameleon Cloud 测试平台</strong>中按照 §6.1 中的描述进行了修改。该集群包括25 个工作虚拟机，每个虚拟机在 m1.xlarge 实例（8 个 CPU，16 GB RAM）上运行两个执行器，在 m1.xxxlarge 实例（16 个 CPU，32 GB RAM）上运行一个主虚拟机。我们的实验考虑 <strong>(i) 批量到达</strong>，其中多个作业同时开始并运行直到完成，以及 <strong>(ii) 连续到达</strong>，其中作业以随机到达间隔分布到达或遵循跟踪。</p><h5 id="批量到达"><a href="#批量到达" class="headerlink" title="批量到达"></a>批量到达</h5><p>最后，Decima 优于所有基线算法，并且比最接近的启发式算法（“优化加权公平”）将平均 JCT 提高了 21%。这是因为 Decima 更好地确定工作的优先级，将高效的执行者份额分配给不同的工作，并利用工作 DAG 结构（§7.4 分解了每个因素的好处）。 Decima 通过端到端 RL 训练自主学习此策略，而性能最佳的基线算法需要仔细调整。</p><p><img src="http://cdn.leafii.top/img/image-20230117184924463.png" alt="image-20230117184924463" loading="lazy"></p><h5 id="连续到达"><a href="#连续到达" class="headerlink" title="连续到达"></a>连续到达</h5><p>Decima 的性能提升来自于更快地完成小作业，Decima 通过为小型作业分配更多执行程序来实现这一点（图 10d）。每个作业的正确执行程序数量取决于工作负载：不加选择地为小型作业提供更多执行程序会低效地使用集群资源（§2.2）。Decima 的执行者分配产生的总工作量与手动调整启发式相似。图 10e 显示了这一点：在对角线以下的作业使用 Decima 的总工作量小于启发式，而在对角线以上的工作在 Decima 中的总工作量更大。大多数小型作业都在对角线上，这表明 Decima 仅在额外的执行程序仍然有效时才增加并行度限制。因此，Decima 成功地在为小型作业提供额外资源以更快完成它们和有效利用资源之间取得平衡。</p><p><img src="http://cdn.leafii.top/img/image-20230117184610020.png" alt="image-20230117184610020" loading="lazy"></p><h4 id="多维资源打包"><a href="#多维资源打包" class="headerlink" title="多维资源打包"></a>多维资源打包</h4><p>我们之前实验中使用的独立 Spark 调度程序只为作业提供对预定义执行程序槽的访问权限。更高级的集群调度器，例如 YARN [75] 或 Mesos [41]，允许作业指定其任务的资源需求并创建适当大小的执行器。将具有多维资源需求（例如，⟨CPU、内存⟩）的任务打包到固定容量的服务器上，进一步增加了调度问题的复杂性 [34、36]。我们使用来自阿里巴巴的生产跟踪来调查 Decima 是否可以使用相同的核心方法学习良好的多维调度策略。</p><h5 id="Industrial-trace"><a href="#Industrial-trace" class="headerlink" title="Industrial trace."></a>Industrial trace.</h5><p>跟踪包含来自生产集群的大约 20,000 个作业。我们使用轨迹的前半部分进行训练，然后将 Decima 的性能与其余部分的其他方案进行比较。</p><h5 id="Multi-resource-environment"><a href="#Multi-resource-environment" class="headerlink" title="Multi-resource environment"></a>Multi-resource environment</h5><p>我们修改 Decima 的环境以提供几个具有不同内存大小的离散执行器类。我们的实验使用了四种类型的执行器，每一种都有 1 个 CPU 内核和 (0.25,0.5,0.75,1) 单位的标准化内存；每个执行器类别占集群执行器总数的 25%。</p><h5 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h5><p> Decima 的平均 JCT 比最佳竞争算法 (Graphene*) 低 32%，表明它在多资源环境中学习了良好的策略。</p><p><img src="http://cdn.leafii.top/img/image-20230117185433516.png" alt="image-20230117185433516" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230117185729841.png" alt="image-20230117185729841" loading="lazy"></p><h4 id="Decima深挖"><a href="#Decima深挖" class="headerlink" title="Decima深挖"></a>Decima深挖</h4><p>最后，我们展示了 Decima 可以学习的各种调度策略，并分解了我们的关键思想和技术对 Decima 性能的影响。</p><p>在附录中，我们通过详尽搜索工作顺序（附录 H）、学习策略对不断变化的环境的稳健性（附录 I）以及 Decima 对不完整信息的敏感性（附录 J）进一步评估 Decima 的最优性。</p><ul><li><p><strong>学习策略：</strong>Decima 优于其他算法，因为它可以根据高级目标、工作负载和环境条件学习不同的策略。</p></li><li><p><strong>学习架构的影响：</strong>图 14 显示，从 Decima 中删除任何一个组件会导致平均 JCT 比在高集群负载下调整的加权公平启发式更差。这个结果有四个要点。</p><ul><li>首先，并行度控制对 Decima 的性能影响最大。在没有并行控制的情况下，Decima 在每个调度事件中将所有可用的执行程序分配到一个阶段。即使在中等集群负载（例如 55%）下，这也会导致无法跟上传入作业到达率的不稳定策略。</li><li>其次，省略图形嵌入（即，直接将每个节点上的原始特征作为 §5.2 中评分函数的输入）使得 Decima 无法估计作业中的剩余工作并考虑集群中的其他作业。因此，Decima 没有小作业或集群负载的概念，并且随着负载的增加，其学习的策略很快变得不稳定。</li><li>第三，在训练集中使用不固定的工作序列会增加奖励信号的方差（§5.3）。</li><li>第四，仅针对批量工作到达的培训不能推广到连续工作到达。在对分批到达进行训练时，Decima 学会了系统地推迟大型作业，因为这会导致 JCT 总和最低（惩罚总和最低）。</li></ul></li><li><p><strong>推广到不同的工作负载：</strong>我们通过改变 TPC-H 实验（§7.2）中的训练工作量来测试 Decima 的泛化能力。最终结果显著表明，多样化的训练工作负载集有助于使 Decima 的学习策略对工作负载变化具有鲁棒性；我们在§8 中讨论了可能的在线学习。</p></li><li><p><strong>训练和推理性能：</strong></p><ul><li>图 15a 显示了 Decima 在连续 TPC-H 作业到达 (§7.2) 上的学习曲线（蓝色），每 100 次迭代（看不见的）作业到达序列测试模型的快照。每次训练迭代大约需要 5 秒。 Decima 的设计（§5.3）对于训练效率至关重要：省略输入中的并行度限制值（黄色曲线）迫使 Decima 对不同的限制使用单独的评分函数，显着增加要优化的参数数量；对节点（绿色曲线）进行细粒度并行控制会减慢训练速度，因为它增加了 Decima 必须探索的算法空间。</li><li>图 15b 显示了 Decima 在我们的 Spark 测试平台 (§7.2) 中决定调度操作（红色）和调度事件之间的时间间隔（蓝色）所花费的时间的累积分布。 Decima 的平均调度延迟小于 15 毫秒，而调度事件之间的间隔通常在秒级。在不到 5% 的情况下，调度间隔比调度延迟短（例如，当集群在单个调度事件中请求多个调度操作时）。因此，Decima 的调度延迟不会对任务运行时造成可测量的开销。<img src="http://cdn.leafii.top/img/image-20230117193600319.png" alt="image-20230117193600319" loading="lazy"></li></ul></li></ul><h3 id="Decima的讨论"><a href="#Decima的讨论" class="headerlink" title="Decima的讨论"></a>Decima的讨论</h3><p>在本节中，我们将讨论 Decima 技术的未来研究方向和其他潜在应用。</p><ul><li>稳健性和泛化性。</li><li>其他学习目标</li><li>抢占式调度</li><li>潜在的网络和系统应用程序。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Decima 证明了使用强化学习自动学习复杂的集群调度策略是可行的，并且学习到的策略灵活高效。 Decima 的学习创新，例如其图形嵌入技术和流式处理训练框架，可能适用于处理 DAG 的其他系统（例如，查询优化器）。我们将在 <a href="https://web.mit.edu/decima">https://web.mit.edu/decima</a> 上开源 Decima、我们的模型和我们的实验基础设施。这项工作不会引发任何伦理问题。</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>Chameleon Cloud 测试平台.</p><p>阿里巴巴的生产工作负载（感谢来自阿里云智能的 Haiyang Ding 和 Yihui Feng 分享生产集群数据集。）</p><p>我们使用了阿里巴巴早期版本的public cluster-trace-v2018 trace[6,52]</p><blockquote><p>[6]Cluster data collected from production clusters in Alibaba for cluster management research(<a href="https://github.com/alibaba/clusterdata">https://github.com/alibaba/clusterdata</a>.)</p><p>[52]Imbalance in the cloud: An analysis on alibaba cluster trace.</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://zhuanlan.zhihu.com/p/133427987">RL for Scheduling，如何用强化学习解决调度问题？ - 知乎 (zhihu.com)</a></p><p><a href="https://link.zhihu.com/?target=https://web.mit.edu/decima/">Decima (mit.edu)</a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1MW411w79n?spm_id_from=333.999.0.0">李宏毅深度强化学习(国语)课程(2018)_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters-用强化学习解决调度问题&quot;&gt;&lt;a href=&quot;#Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters-用强化学习解决调度问题&quot; class=&quot;headerlink&quot; title=&quot;Decima(Learning Scheduling Algorithms for Data Processing Clusters):用强化学习解决调度问题&quot;&gt;&lt;/a&gt;Decima(Learning Scheduling Algorithms for Data Processing Clusters):用强化学习解决调度问题&lt;/h2&gt;&lt;h3 id=&quot;解决的问题&quot;&gt;&lt;a href=&quot;#解决的问题&quot; class=&quot;headerlink&quot; title=&quot;解决的问题&quot;&gt;&lt;/a&gt;解决的问题&lt;/h3&gt;&lt;p&gt;解决了在云上的多个以DAG图表示的任务在多个Executor上运行时的调度问题。该问题为NP-Hard难度的问题，在该论文中，作者使用RL和GNN来解决它。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:202.快乐数</title>
    <link href="2023/01/09/leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>2023/01/09/leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/</id>
    <published>2023-01-09T03:25:47.000Z</published>
    <updated>2023-01-10T07:14:43.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 19输出：true解释：12 + 92 &#x3D; 8282 + 22 &#x3D; 6862 + 82 &#x3D; 10012 + 02 + 02 &#x3D; 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归暴力求解（C++实现）</li></ol><p>首先确定递归判断的条件：<code>n==1</code>时返回true，当<code>n &lt; 10 &amp;&amp; n % 2 == 0</code>时返回false。</p><p>对输入数字<code>n</code>的每一位数的计算方法为<code>temp = n % 10</code>，取余的结果的平方与sum累加，同时<code>n = n / 10</code>，求得的sum递归传入判断函数中。代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isHappy(int n) &#123;        &#x2F;&#x2F;递归函数的终止条件        if(n &#x3D;&#x3D; 1)        &#123;            return true;        &#125;        if(n &lt; 10 &amp;&amp; n % 2 &#x3D;&#x3D; 0)        &#123;            return false;        &#125;        &#x2F;&#x2F;初始化变量，便于接下来的计算        int sum &#x3D; 0;        int temp &#x3D; 0;        &#x2F;&#x2F;在循环中求每一位的平方值并且加到sum中        while(n !&#x3D; 0)        &#123;            temp &#x3D; n % 10;            n &#x3D; n &#x2F; 10;            sum &#x3D; sum + temp * temp;        &#125;        &#x2F;&#x2F;返回递归函数的返回值        return isHappy(sum);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;编写一个算法来判断一个数 &lt;code&gt;n&lt;/code&gt; 是不是快乐数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「快乐数」&lt;/strong&gt; 定义为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。&lt;/li&gt;
&lt;li&gt;然后重复这个过程直到这个数变为 1，也可能是 &lt;strong&gt;无限循环&lt;/strong&gt; 但始终变不到 1。&lt;/li&gt;
&lt;li&gt;如果这个过程 &lt;strong&gt;结果为&lt;/strong&gt; 1，那么这个数就是快乐数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 &lt;code&gt;n&lt;/code&gt; 是 &lt;em&gt;快乐数&lt;/em&gt; 就返回 &lt;code&gt;true&lt;/code&gt; ；不是，则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:242.有效的字母异位词</title>
    <link href="2023/01/08/leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>2023/01/08/leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</id>
    <published>2023-01-08T06:59:51.000Z</published>
    <updated>2023-01-10T07:19:01.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p><span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;输出: false</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>暴力解法，用C++实现</li></ol><p>主要思路：首先对两个字符串的长度进行比较，若不一致则返回false，接下来，因为字符串的字母共有26个，因此遍历统计字符串中每个字母的个数，并用一个大小为26的对应数组进行存储，最后遍历对比两个字符串对应的统计个数的数组是否一致，对比的结果即为最终结果，代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isAnagram(string s, string t) &#123;        &#x2F;&#x2F;对每个字符串的字母个数统计数组的初始化        int arr_s[26] &#x3D; &#123;0&#125;;        int arr_t[26] &#x3D; &#123;0&#125;;        &#x2F;&#x2F;计算两个字符串的长度，如果长度不同，那么一定不是字母异位词        int len_s &#x3D; s.length();        int len_t &#x3D; t.length();        if(len_s !&#x3D; len_t)        &#123;            return false;        &#125;        &#x2F;&#x2F;在遍历中确定每个字母统计的下标，并且+1        for(int i &#x3D; 0; i &lt; len_s; i++)&#123;            int index_s &#x3D; (int)(s[i] - &#39;a&#39;);            int index_t &#x3D; (int)(t[i] - &#39;a&#39;);            arr_s[index_s] &#x3D; arr_s[index_s] + 1;            arr_t[index_t] &#x3D; arr_t[index_t] + 1;        &#125;        &#x2F;&#x2F;对比两个字符串的字母的种类和个数是否一致        for(int i &#x3D; 0; i &lt; 26; i++)&#123;            if(arr_s[i] !&#x3D; arr_t[i])                return false;        &#125;        &#x2F;&#x2F;最终返回结果        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，编写一个函数来判断 &lt;code&gt;t&lt;/code&gt; 是否是 &lt;code&gt;s&lt;/code&gt; 的字母异位词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;若 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; 中每个字符出现的次数都相同，则称 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; 互为字母异位词。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>A_Bi-Level_Framework_for_Learning_to_Solve_Combinatorial_Optimization_on_Graph</title>
    <link href="2022/11/05/A-Bi-Level-Framework-for-Learning-to-Solve-Combinatorial-Optimization-on-Graph/"/>
    <id>2022/11/05/A-Bi-Level-Framework-for-Learning-to-Solve-Combinatorial-Optimization-on-Graph/</id>
    <published>2022-11-05T10:04:44.000Z</published>
    <updated>2022-11-05T12:05:40.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一种双层优化方法"><a href="#一种双层优化方法" class="headerlink" title="一种双层优化方法"></a>一种双层优化方法</h1><ul><li><p>引言:</p><p>论文题目:A Bi-Level Framework for Learning to Solve Combinatorial Optimization on Graphs</p><p>论文对应代码: <a href="https://github.com/Thinklab-SJTU/PPO-BiHyb">https://github.com/Thinklab-SJTU/PPO-BiHyb</a>.</p></li></ul><span id="more"></span><h2 id="Abstract-x2F-Background"><a href="#Abstract-x2F-Background" class="headerlink" title="Abstract&#x2F;Background"></a>Abstract&#x2F;Background</h2><p>组合优化 (CO) 以其NP-hard性质为特征，一直是一个具有挑战性的研究课题。当前，用于组合优化的机器学习 (MLCO) 已成为热门研究主题，但是大多数现有的MLCO方法都通过直接学习端到端解决方案来将CO视为单层优化，由于CO的高度复杂性，很难扩大规模，并且主要受ML模型容量的限制。在本文中，我们提出了一种混合方法来结合两个世界的优点，其中使用上层学习方法开发了一个双层框架来优化图 (例如添加，删除或修改图中的边)，与优化图上的低级启发式算法进行融合求解。这种双层方法简化了对原始硬CO的学习，并可以有效地减轻对模型容量的需求。对几个流行的CO问题 (例如有向无环图调度，图编辑距离和哈密顿循环问题) 的实验和结果表明，它比手动设计的启发式方法和单层学习方法有效。</p><p>本文解决的问题在实际中的例子:</p><ol><li><p>例如计算任务的调度问题，在调度问题中需合理安排计算资源及数据中的CPU的核数指派到合适的任务，实现最大效率的完成，优化目标是最小化完成所有任务的时间；</p></li><li><p>图学习或机器学习中常用到的，图编辑距离，图学习中常用的图之间的距离度量，它通过衡量从图1到图2之间最短的编辑路径所对应的最小的编辑代价来衡量两张图的相似程度，也是一个NP-hard的优化问题，目标为最小化图上的编辑代价；或汉密尔顿回路问题以及著名的欧拉七桥问题等。</p></li></ol><p><img src="http://cdn.leafii.top/img/v2-19dedc188ceaa2e46cc66af55e8b8cc6_1440w.webp" alt="图1 Combinatorial Optimization Problems on Graphs" loading="lazy"></p><h2 id="当前的研究方法-Single-Level-Optimization"><a href="#当前的研究方法-Single-Level-Optimization" class="headerlink" title="当前的研究方法:Single-Level Optimization"></a>当前的研究方法:Single-Level Optimization</h2><h3 id="当前方法"><a href="#当前方法" class="headerlink" title="当前方法"></a>当前方法</h3><p>当前关于此类问题的研究方法都可被总结为Single-Level optimization的优化形式,如下式:寻找合适的x以最小化函数f.式中的x为决策变量,f(x)为目标函数,s.t.为约束条件.</p><p>$$\min _{\mathbf{x}} f(\mathbf{x} \mid \mathcal{G}) \quad s.t. \quad h_i(\mathbf{x}, \mathcal{G}) \leq 0, for\ i&#x3D;1 \ldots I$$</p><p>当前主流思路是直接使用强化学习对其进行端到端的学习,由于问题本身单独为NP-hard问题,因此大部分问题得不到最优解,无法进行端到端的训练.在RL框架下,决策变量会被一系列的决策替代,目标函数对应RL中的reward,约束条件通过限制RL的agent动作的范围来实现.</p><p>在使用强化学习直接处理规模较大的问题时,由于动作序列变长,导致动作空间增大,最终导致稀疏奖励(sparse reward),使得RL比较难以学到有用的信息,而且在默认的求解过程中,框架暗含的假设为:模型存在直接从G(graph)学习到x(solution)的能力–&gt;学习端到端的映射.这为模型的容量设计带来了挑战,也就意味着需要为特定的问题,特定的数据分布去设计不同的模型结构才能实现如此大的模型容量.为了解决上述问题,传统的解决方法(no-learning)通过修改问题本身的结构来辅助问题的求解.例如在求解整数规划问题时使用割平面法(cutting planes)为求解整数规划问题添加额外的约束,来辅助问题能够得到更好更快的解决.</p><h3 id="对当前研究方法的优化"><a href="#对当前研究方法的优化" class="headerlink" title="对当前研究方法的优化"></a>对当前研究方法的优化</h3><p>本文发现,在计算任务调度的过程中,通过修改原先数据有向无环图的结构,比如加两条边,同样一个算法能够在两种修改条件下获得不一样的结果.原来21s完成的任务现在16s就能完成.通过这个思路,可以实现对问题求解的优化.</p><p><img src="http://cdn.leafii.top/img/v2-7a91e3e2eff95e4b00d451531d46eb20_1440w.jpeg" alt="图2 Modify the graph structure to aid problem solving" loading="lazy"></p><h2 id="Our-Formulation-Bi-Level-Optimization"><a href="#Our-Formulation-Bi-Level-Optimization" class="headerlink" title="Our Formulation: Bi-Level Optimization"></a>Our Formulation: Bi-Level Optimization</h2><p>基于以上观察和思路，本文提出了一个双层优化（Bi-Level）方法，其核心引入一个新的变量称为优化过的图结构G’，基于G’给出双层优化的形式，如图3所示。图中上方红色框内表示上层优化部分（Upper-Level Optimization），蓝色框内表示下层优化部分（Lower-Level Optimization）。其中上层优化目标为G’，下层优化目标为一个决策变量与单层优化形式类似。可以发现目标函数及约束条件都是相对于G’。而对于上层优化，通过优化后的G’来实现对最终目标函数值在原先图中G目标函数值的优化。</p><p><img src="http://cdn.leafii.top/img/v2-e3124cd8a67c7b54d85e2f698e43ff65_1440w.webp" alt="图3 Bi-Level Optimization" loading="lazy"></p><p>基于上述框架，本文提出了一个强化学习-传统算法融合的方法如图4所示。针对输入的图结构，首先调用一个传统算法可以求出一个解，在此基础上，加入ReNet Attention GNN 组成的强化学习模型进行决策，该模型在图上预测图如何修改的概率，图中红色的深浅代表了不同的预测概率。</p><p>基于预测概率，进行决策，对图的结构进行修改。基于新的图结构，再次调用传统算法得到新的解，继续调用RL修改图结构，不断循环。图中蓝色为用来做决策的上层算法，通过PPO进行学习。下层黄色表示传统求解算法。蓝色G’表示上层优化需解决的问题，黄色X’表示下层优化需要处理的内容。由于采用强化学习进行学习，总目标函数会作为回馈函数来指导搜索与学习。</p><p><img src="http://cdn.leafii.top/img/v2-bd9fa312c45a18758b841ae450a4cbb8_1440w.webp" alt="图4 Bi-Level Optimization by Reinforcement Learning" loading="lazy"></p><p>该方法的伪代码如下:</p><p><img src="http://cdn.leafii.top/img/image-20221105194049785.png" alt="图5 伪代码" loading="lazy"></p><p>假设:图G的最优解X*可以通过修改G来获得.通过引入以下的主张去验证该假设的可行性:</p><p>Proposition.我们将从图g修改的所有图的集合定义为$\mathbb G$,并且$\mathbb X$是图g的所有可行解的集合.如果启发式算法是一个从$\mathbb G$到$\mathbb X$的超射(surjection),对图g和他的最优解x*,应该存在g*$\in \mathbb G$,使得x*成为求解g*的启发式算法的输出.</p><p>Proof.由超射的定义可知, 因为x* $\in X$,因此必须至少存在一个图G*$\in G$使得X*是通过求解g*的启发式算法的输出.</p><p>在进行完理论上的分析之后,本文基于假设内容原先图上的最优解x*可以通过不断修改图结构来得到.由于直接证明难度较大,因此添加一定限制条件, 如图6所示,但必须注意的是寻找最优的修改过的图这个问题本身也是一个NP-hard问题,本文通过理论上的分析证明优化图结构本身是可行的,同时可启发通过该方向开发性能更强更有用的算法.</p><p><img src="http://cdn.leafii.top/img/v2-e7bf0965896c544159ba0237e8e4f20d_1440w.jpeg" alt="图6 限制条件" loading="lazy"></p><p>在三个问题上使用该算法实现可以发现该框架的通用性,该方法在三个问题都维持了比较general的特性,如图7所示:</p><p><img src="http://cdn.leafii.top/img/v2-6c461ab6a5dee7ad8f73ea2df50ce713_1440w.webp" alt="图7 Implement on 3 Combinatorial Optimization Problems" loading="lazy"></p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>To be continued…</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一种双层优化方法&quot;&gt;&lt;a href=&quot;#一种双层优化方法&quot; class=&quot;headerlink&quot; title=&quot;一种双层优化方法&quot;&gt;&lt;/a&gt;一种双层优化方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;引言:&lt;/p&gt;
&lt;p&gt;论文题目:A Bi-Level Framework for Learning to Solve Combinatorial Optimization on Graphs&lt;/p&gt;
&lt;p&gt;论文对应代码: &lt;a href=&quot;https://github.com/Thinklab-SJTU/PPO-BiHyb&quot;&gt;https://github.com/Thinklab-SJTU/PPO-BiHyb&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
  </entry>
  
  <entry>
    <title>在macOS上为自己的Latex安装LaTeX.sty文件</title>
    <link href="2022/11/04/%E5%9C%A8macOS%E4%B8%8A%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84Latex%E5%AE%89%E8%A3%85LaTeX-sty%E6%96%87%E4%BB%B6/"/>
    <id>2022/11/04/%E5%9C%A8macOS%E4%B8%8A%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84Latex%E5%AE%89%E8%A3%85LaTeX-sty%E6%96%87%E4%BB%B6/</id>
    <published>2022-11-04T11:34:22.000Z</published>
    <updated>2022-11-04T12:07:29.883Z</updated>
    
    <content type="html"><![CDATA[<p>当latex编译报错提醒“xxxx.sty文件不存在”时,mac用户可参考此方法</p><span id="more"></span><p>解决方法:下载目标的sty文件,可以在类似与<a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/8015-m-code-latex-package">此链接</a>寻找</p><p>下载成功后,将解压后的sty文件复制到macOS的路径中,我的参考路径为:<code>/usr/local/texlive/2022/texmf-dist/tex/latex/base/</code>(复制时需要sudo)</p><p>复制后在终端中输入命令:<code>sudo -s texhash</code></p><p>此时再打开texmaker等对文件进行编译即可…</p><p>参考链接:<a href="https://qa.1r1g.com/sf/ask/97357991/">https://qa.1r1g.com/sf/ask/97357991/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当latex编译报错提醒“xxxx.sty文件不存在”时,mac用户可参考此方法&lt;/p&gt;</summary>
    
    
    
    
    <category term="macOS" scheme="tags/macOS/"/>
    
    <category term="LaTeX" scheme="tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>MAPPO源代码分析</title>
    <link href="2022/09/30/MAPPO%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>2022/09/30/MAPPO%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-09-30T10:22:03.000Z</published>
    <updated>2022-10-31T06:36:08.403Z</updated>
    
    <content type="html"><![CDATA[<p>代码地址：<a href="https://github.com/marlbenchmark/on-policy">https://github.com/marlbenchmark/on-policy</a></p><p>官方出品轻量化mappo代码：<a href="https://github.com/tinyzqh/light_mappo">https://github.com/tinyzqh/light_mappo</a></p><p>对应论文：The Surprising Effectiveness of MAPPO in Cooperative, Multi-Agent Games</p><span id="more"></span><h2 id="代码运行"><a href="#代码运行" class="headerlink" title="代码运行"></a>代码运行</h2><p>使用conda新建环境，python版本推荐为3.6.7，并且安装readme中的MPE环境，然后将pycharm中train_mpe.py文件的configuration中的参数设置为<code>--env_name &quot;MPE&quot; --algorithm_name &quot;rmappo&quot; --experiment_name &quot;check&quot; --scenario_name &quot;simple_spread&quot; --num_agents 3 --num_landmarks 3 --seed 1 --n_training_threads 1 --n_rollout_threads 4 --num_mini_batch 1 --episode_length 25 --num_env_steps 10000 --ppo_epoch 10 --use_ReLU --gain 0.01 --lr 7e-4 --critic_lr 7e-4 --wandb_name &quot;leafii&quot; --user_name &quot;leafii&quot;</code>，以免因为电脑配置不足无法运行。安装其他包时要参考文件夹中requirement.txt中的版本，以免由于版本兼容问题造成代码无法正常运行，debug。</p><h2 id="MAPPO算法伪代码"><a href="#MAPPO算法伪代码" class="headerlink" title="MAPPO算法伪代码"></a>MAPPO算法伪代码</h2><p><img src="http://cdn.leafii.top/img/mappo.png" alt="img" loading="lazy"></p><p>有两个网络，分别是策略$\pi_{\theta}$和值函数$V_{\phi}$。（作者在文中说如果智能体是同种类的就采用相同的网络参数，对于每个智能体内部也可以采用各自的actor和critic网络，为了符号的便利性，作者直接使用一个网络参数来表示）。值函数$V_{\phi}$需要学习一个映射： $S \rightarrow \mathbb R$。策略函数$\pi_{\theta}$学习一个映射从观测$o_t^{a}$到一个范围的分布或者是映射到一个高斯函数的动作均值和方差用于之后采样动作。</p><ul><li>Actor的优化目标为：</li></ul><p>$$L(\theta) &#x3D; [\frac{1}{B_n}\sum_{i&#x3D;1}^{B}\sum_{k-1}^{n}min(r_{\theta,i}^{(k)}A_{i}^{(k)},clip(r_{\theta,i}^{(k)},1-\epsilon,1+\epsilon)A_i^{(k)})]+\sigma \frac{1}{B_n}\sum_{i&#x3D;1}^{B}\sum_{k-1}^{n}S[\pi_{\theta}(o_i^{(k)})],where r_{\theta,i}^{(k)}&#x3D;\frac{\pi_{\theta}(a_i^{(k)}|o_i^{(k)})}{\pi_{\theta_{old}}(a_i^{(k)}|o_i^{(k)})}$$</p><p>其中优势函数$A_i^{(k)}$是采用GAE方法的，S表示策略的熵，$\sigma$是控制熵系数的一个超参数。</p><ul><li>Critic网络优化目标为：</li></ul><p>$$L(\phi)&#x3D;\frac{1}{B_n}\sum_{i&#x3D;1}^{B}\sum_{k&#x3D;1}^{n}(max[(V_\phi(s_i^{(k)})-\hat R_i)^2,(clip(V_\phi(s_i^{(k)}),V_{\phi_{old}}(s_i^{(k)}-\varepsilon),V_{\phi_{old}}(s_i^{(k)}+\varepsilon)-\hat R_i)^2]$$</p><p>其中$\hat R_i$是折扣奖励。B表示batch_size的大小，n表示智能体的数量。</p><h2 id="代码整体流程"><a href="#代码整体流程" class="headerlink" title="代码整体流程"></a>代码整体流程</h2><p>每个局部智能体接收一个局部的观察obs，输出一个动作概率，所有的actor智能体都采用一个actor网络。critic网络接收所有智能体的观测obs，<code>cent_obs_space = n * obs_space</code>，其中n为智能体的个数，输出一个V值，V值用于actor的更新。actor的loss和PPO的loss类似，有添加一个熵的loss。Critic的loss更多的是对value的值做normalizer，并且在计算episode的折扣奖励的时候不是单纯的算折扣奖励，有采用gae算折扣回报的方式。</p><ul><li><p>网络定义</p><p>代码定义在<code>onpolicy/algorithms/r_mappo/algorithm/rMAPPOPolicy.py</code></p><p>每一个智能体的观测obs_space为一个18维的向量，有3个智能体，cent_obs_space为一个54维的向量，单个智能体的动作空间act_space 为一个离散的5维的向量</p></li></ul><ol><li><p>actor</p><p>在<code>onpolicy/algorithms/utils/act.py</code>中，输入一个观测（18维），输出一个确切的动作actions和这个动作对数概率。</p></li></ol><pre class="language-python" data-language="python"><code class="language-python">action_dim <span class="token operator">=</span> action_space<span class="token punctuation">.</span>nself<span class="token punctuation">.</span>action_out <span class="token operator">=</span> Categorical<span class="token punctuation">(</span>inputs_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> use_orthogonal<span class="token punctuation">,</span> gain<span class="token punctuation">)</span>action_logits <span class="token operator">=</span> self<span class="token punctuation">.</span>action_out<span class="token punctuation">(</span>x<span class="token punctuation">,</span> available_actions<span class="token punctuation">)</span>actions <span class="token operator">=</span> action_logits<span class="token punctuation">.</span>mode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> deterministic <span class="token keyword">else</span> action_logits<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">)</span> action_log_probs <span class="token operator">=</span> action_logits<span class="token punctuation">.</span>log_probs<span class="token punctuation">(</span>actions<span class="token punctuation">)</span></code></pre><ol start="2"><li><p>critic</p><p>critic输入维度为<code>cent_obs_space = n * obs_space = 54</code>，输出维度为1。</p></li></ol><pre class="language-python" data-language="python"><code class="language-python">critic_features <span class="token operator">=</span> self<span class="token punctuation">.</span>base<span class="token punctuation">(</span>cent_obs<span class="token punctuation">)</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>_use_naive_recurrent_policy <span class="token keyword">or</span> self<span class="token punctuation">.</span>_use_recurrent_policy<span class="token punctuation">:</span>        critic_features<span class="token punctuation">,</span> rnn_states <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>critic_features<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> masks<span class="token punctuation">)</span>values <span class="token operator">=</span> self<span class="token punctuation">.</span>v_out<span class="token punctuation">(</span>critic_features<span class="token punctuation">)</span></code></pre><h2 id="采样流程"><a href="#采样流程" class="headerlink" title="采样流程"></a>采样流程</h2><ul><li>初始化obs</li></ul><p>在on policy&#x2F;scripts&#x2F;train&#x2F;train_mpe.py的make_train_env(all_args)函数中实例化4个环境：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">return</span> SubprocVecEnv<span class="token punctuation">(</span><span class="token punctuation">[</span>get_env_fn<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>all_args<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>在onpolicy&#x2F;runner&#x2F;shared&#x2F;mpe_runner.py中的的warmup函数中，如果采用centralized_V值函数的训练方式（？？？），那么需要初始化的时候构造出多个智能体的share_obs：</p><pre class="language-python" data-language="python"><code class="language-python">obs <span class="token operator">=</span> self<span class="token punctuation">.</span>envs<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># shape = (4, 3, 18)</span>share_obs <span class="token operator">=</span> obs<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># shape = (4, 54)</span><span class="token comment"># 指定3个智能体</span>share_obs <span class="token operator">=</span> np<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>share_obs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_agents<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># shape = (4, 3, 54)</span></code></pre><p>在share_obs中会将n&#x3D;3个智能体的obs叠加在一起作为share_obs。</p><ul><li><code>collect()</code>采用<code>rollout</code>方式采样数据</li></ul><p>在onpolicy&#x2F;runner&#x2F;shared&#x2F;mpe_runner.py中的的collect函数中，调用<code>self.trainer.prep_rollout()</code>函数将actor和critic都设置为<code>eval()</code>格式,然后用<code>np.concatenate()</code>函数将并行的环境的数据拼接在一起，这一步是将并行采样的那个纬度降掉:</p><pre class="language-python" data-language="python"><code class="language-python">value<span class="token punctuation">,</span> action<span class="token punctuation">,</span> action_log_prob<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> rnn_states_critic \    <span class="token operator">=</span> self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>policy<span class="token punctuation">.</span>get_actions<span class="token punctuation">(</span>np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>share_obs<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>obs<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>rnn_states<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment"># ?</span>                            np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>rnn_states_critic<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>masks<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>将数据传入总的MAPPO策略网络R_MAPPOPolicy(onpolicy&#x2F;algorithms&#x2F;r_mappo&#x2F;algorithm&#x2F;rMAPPOPolicy.py)中去获取一个时间步的数据。在get_actions()里面调用actor去获取动作以及动作的对数概率，critic网络去获取对于cent_obs的状态值函数的输出：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 调用actor去获取动作和动作的对数概率                                      </span>actions<span class="token punctuation">,</span> action_log_probs<span class="token punctuation">,</span> rnn_states_actor <span class="token operator">=</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>obs<span class="token punctuation">,</span>rnn_states_actor<span class="token punctuation">,</span> masks<span class="token punctuation">,</span> available_actions<span class="token punctuation">,</span> deterministic<span class="token punctuation">)</span></code></pre><p>在这里obs的shape是(4*3, 18),输出actions和action_log_probs的shape都为(12,1).</p><pre class="language-python" data-language="python"><code class="language-python">values<span class="token punctuation">,</span> rnn_states_critic <span class="token operator">=</span> self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>cent_obs<span class="token punctuation">,</span> rnn_states_critic<span class="token punctuation">,</span> masks<span class="token punctuation">)</span>   <span class="token comment"># 调用critic去对动作打分，得到values</span></code></pre><p>cent_obs’s shape is (5*2, 14),values’s shape is (12,1),and rnn_states’s shape is (12, 1, 64).</p><pre class="language-python" data-language="python"><code class="language-python">values <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 将value转化成4层3行1列的数据</span>actions <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 这action转化成4层3行1列的数据</span>action_log_probs <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>action_log_prob<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>rnn_states <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>rnn_states<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>rnn_states_critic <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>rnn_states_critic<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>actions_env <span class="token operator">=</span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span>self<span class="token punctuation">.</span>envs<span class="token punctuation">.</span>action_space<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">[</span>actions<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># 5维 (4, 3, 5)</span></code></pre><p>最后将(<code>12 , 1</code>)的<code>actions</code>转换成(<code>4, 3, 1</code>)的形式，方便之后并行送到并行的环境中去，作者这里还将动作进行了<code>one-hot</code>编码，最后变成了(<code>4, 3, 5</code>)的形式送入到环境中去。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># Obser reward and next obs</span>obs<span class="token punctuation">,</span> rewards<span class="token punctuation">,</span> dones<span class="token punctuation">,</span> infos <span class="token operator">=</span> self<span class="token punctuation">.</span>envs<span class="token punctuation">.</span>step<span class="token punctuation">(</span>actions_env<span class="token punctuation">)</span>data <span class="token operator">=</span> obs<span class="token punctuation">,</span> rewards<span class="token punctuation">,</span> dones<span class="token punctuation">,</span> infos<span class="token punctuation">,</span> values<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> action_log_probs<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> rnn_states_critic<span class="token comment"># insert data into buffer</span>self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre><p>环境下一次输出的<code>obs</code>还是(<code>4, 3, 18</code>)的形式，之后调<code>insert</code>方法将数据添加到<code>buffer</code>里面，在<code>insert</code>方法里面会将局部观测构造一个全局观测<code>share_obs</code>其shape&#x3D;(<code>4, 3, 54</code>)出来：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>    obs<span class="token punctuation">,</span> rewards<span class="token punctuation">,</span> dones<span class="token punctuation">,</span> infos<span class="token punctuation">,</span> values<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> action_log_probs<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> rnn_states_critic <span class="token operator">=</span> data    rnn_states<span class="token punctuation">[</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>recurrent_N<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    rnn_states_critic<span class="token punctuation">[</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>rnn_states_critic<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    masks <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_agents<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    masks<span class="token punctuation">[</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>use_centralized_V<span class="token punctuation">:</span>        share_obs <span class="token operator">=</span> obs<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        share_obs <span class="token operator">=</span> np<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>share_obs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_agents<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        share_obs <span class="token operator">=</span> obs    self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>insert<span class="token punctuation">(</span>share_obs<span class="token punctuation">,</span> obs<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> rnn_states_critic<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> action_log_probs<span class="token punctuation">,</span> values<span class="token punctuation">,</span> rewards<span class="token punctuation">,</span> masks<span class="token punctuation">)</span></code></pre><p>上述过程循环迭代<code>self.episode_length=100</code>次。</p><h2 id="训练流程"><a href="#训练流程" class="headerlink" title="训练流程"></a>训练流程</h2><ul><li>计算优势函数</li></ul><p>在训练之前，首先调用<code>self.compute()</code>函数计算<code>episode</code>的折扣回报，在计算折扣回报之前，先算这个<code>episode</code>最后一个状态的状态值函数<code>next_values</code>，其<code>shape=(12, 1)</code>然后调用<code>compute_returns</code>函数计算折扣回报:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 计算这个episode的折扣回报，先用rMAPPOPolicy.py里面的get_values计算一下next_values</span>    <span class="token triple-quoted-string string">"""Calculate returns for the collected data."""</span>    self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>prep_rollout<span class="token punctuation">(</span><span class="token punctuation">)</span>    next_values <span class="token operator">=</span> self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>policy<span class="token punctuation">.</span>get_values<span class="token punctuation">(</span>np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>share_obs<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                             np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>rnn_states_critic<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                             np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>masks<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    next_values <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>next_values<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>compute_returns<span class="token punctuation">(</span>next_values<span class="token punctuation">,</span> self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>value_normalizer<span class="token punctuation">)</span>  <span class="token comment"># 折扣回报的的计算方式</span></code></pre><p>有了数据之后就可以开始计算<strong>折扣回报</strong>了（在这里有采用<code>gae</code>算折扣回报的方式，并且有将<code>value</code>做<code>normalizer</code>）。<code>compute_returns</code>函数在<code>onpolicy/utils/shared_buffer.py</code> 中，核心代码如下：</p><pre class="language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> next_valuegae <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> step <span class="token keyword">in</span> <span class="token builtin">reversed</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>rewards<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> self<span class="token punctuation">.</span>_use_popart <span class="token keyword">or</span> self<span class="token punctuation">.</span>_use_valuenorm<span class="token punctuation">:</span>    delta <span class="token operator">=</span> self<span class="token punctuation">.</span>rewards<span class="token punctuation">[</span>step<span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> value_normalizer<span class="token punctuation">.</span>denormalize<span class="token punctuation">(</span>      self<span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span>step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>masks<span class="token punctuation">[</span>step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> \     <span class="token operator">-</span> value_normalizer<span class="token punctuation">.</span>denormalize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span>    gae <span class="token operator">=</span> delta <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> self<span class="token punctuation">.</span>gae_lambda <span class="token operator">*</span> self<span class="token punctuation">.</span>masks<span class="token punctuation">[</span>step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> gae    self<span class="token punctuation">.</span>returns<span class="token punctuation">[</span>step<span class="token punctuation">]</span> <span class="token operator">=</span> gae <span class="token operator">+</span> value_normalizer<span class="token punctuation">.</span>denormalize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>算完折扣回报后调用<code>self.train()</code>函数进行训练:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 算完折扣回报之后调用self.train()函数进行训练</span>  <span class="token triple-quoted-string string">"""Train policies with data in buffer. """</span>  self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>prep_training<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 将网络设置为train（）的格式</span>  train_infos <span class="token operator">=</span> self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>train<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>after_update<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 将buffer的第一个元素设置为其episode最后的一个元素</span>  <span class="token keyword">return</span> train_infos</code></pre><p>在<code>self.trainer.train(self.buffer)</code>函数中先基于数据，计算优势函数(优势函数是针对全局的观测信息所得到的)：</p><pre class="language-python" data-language="python"><code class="language-python">advantages <span class="token operator">=</span> <span class="token builtin">buffer</span><span class="token punctuation">.</span>returns<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>value_normalizer<span class="token punctuation">.</span>denormalize<span class="token punctuation">(</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>advantages_copy <span class="token operator">=</span> advantages<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>advantages_copy<span class="token punctuation">[</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>active_masks<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0.0</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>nanmean_advantages <span class="token operator">=</span> np<span class="token punctuation">.</span>nanmean<span class="token punctuation">(</span>advantages_copy<span class="token punctuation">)</span> <span class="token comment"># float, shape = (1)</span>std_advantages <span class="token operator">=</span> np<span class="token punctuation">.</span>nanstd<span class="token punctuation">(</span>advantages_copy<span class="token punctuation">)</span>  <span class="token comment"># float, shape = (1)</span>advantages <span class="token operator">=</span> <span class="token punctuation">(</span>advantages <span class="token operator">-</span> mean_advantages<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>std_advantages <span class="token operator">+</span> <span class="token number">1e-5</span><span class="token punctuation">)</span></code></pre><p>然后从<code>buffer</code>中采样数据，把线程、智能体的纬度全部降掉</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 从 data_generator 中采样</span><span class="token keyword">for</span> sample <span class="token keyword">in</span> data_generator<span class="token punctuation">:</span>  <span class="token comment"># 进行一次 PPO 更新</span>  value_loss<span class="token punctuation">,</span> critic_grad_norm<span class="token punctuation">,</span> policy_loss<span class="token punctuation">,</span> dist_entropy<span class="token punctuation">,</span> actor_grad_norm<span class="token punctuation">,</span> imp_weights \                        <span class="token operator">=</span> self<span class="token punctuation">.</span>ppo_update<span class="token punctuation">(</span>sample<span class="token punctuation">,</span> update_actor<span class="token punctuation">)</span></code></pre><p><code>ppo_update</code>函数大体流程是:</p><ol><li>从buffer中抽样建立sample</li><li>将抽样的数据传递给rMAPPOPolicy.py中的evaluate_actions函数，得到 values, action_log_probs, dist_entropy</li><li>计算actor的loss</li><li>计算critic的loss</li></ol><p>然后在<code>onpolicy/algorithms/r_mappo/r_mappo.py</code>中</p><pre class="language-python" data-language="python"><code class="language-python">share_obs_batch<span class="token punctuation">,</span> obs_batch<span class="token punctuation">,</span> rnn_states_batch<span class="token punctuation">,</span> rnn_states_critic_batch<span class="token punctuation">,</span> actions_batch<span class="token punctuation">,</span>\         value_preds_batch<span class="token punctuation">,</span> return_batch<span class="token punctuation">,</span>masks_batch<span class="token punctuation">,</span>active_masks_batch<span class="token punctuation">,</span>old_action_log_probs_batch<span class="token punctuation">,</span> \        adv_targ<span class="token punctuation">,</span> available_actions_batch <span class="token operator">=</span> sample</code></pre><p>拿到采样之后的数据，把<code>obs</code>送给<code>actor</code>网络，得到<code>action_log_probs</code>, <code>dist_entropy</code>。把<code>cent_obs</code>送到<code>critic</code>得到新的<code>values</code>。</p><ul><li>计算actor的loss</li></ul><p>在<code>ppo_update()</code>中，利用新老动作的概率分布和优势函数之后就可以更新<code>actor</code>网络了：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># actor update</span>imp_weights <span class="token operator">=</span> torch<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>action_log_probs <span class="token operator">-</span> old_action_log_probs_batch<span class="token punctuation">)</span>surr1 <span class="token operator">=</span> imp_weights <span class="token operator">*</span> adv_targsurr2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>clamp<span class="token punctuation">(</span>imp_weights<span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>clip_param<span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>clip_param<span class="token punctuation">)</span> <span class="token operator">*</span> adv_targpolicy_action_loss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span>torch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>surr1<span class="token punctuation">,</span> surr2<span class="token punctuation">)</span><span class="token punctuation">,</span>                                             dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>                                             keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token operator">*</span> active_masks_batch<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> active_masks_batch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>policy_loss <span class="token operator">-</span> dist_entropy <span class="token operator">*</span> self<span class="token punctuation">.</span>entropy_coef<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>计算critic的loss</li></ul><p>新的<code>value</code>和老的<code>value_preds_batch</code>和计算的<code>return_batch</code>送到<code>onpolicy/algorithms/r_mappo/r_mappo.py</code>文件的<code>cal_value_loss</code>函数中去计算<code>critic</code>的<code>loss</code>：</p><pre class="language-python" data-language="python"><code class="language-python">value_loss <span class="token operator">=</span> self<span class="token punctuation">.</span>cal_value_loss<span class="token punctuation">(</span>values<span class="token punctuation">,</span> value_preds_batch<span class="token punctuation">,</span> return_batch<span class="token punctuation">,</span> active_masks_batch<span class="token punctuation">)</span></code></pre><p>and then</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 对value做一个clipped</span>value_pred_clipped <span class="token operator">=</span> value_preds_batch <span class="token operator">+</span> <span class="token punctuation">(</span>values <span class="token operator">-</span> value_preds_batch<span class="token punctuation">)</span><span class="token punctuation">.</span>clamp<span class="token punctuation">(</span><span class="token operator">-</span>self<span class="token punctuation">.</span>clip_param<span class="token punctuation">,</span> self<span class="token punctuation">.</span>clip_param<span class="token punctuation">)</span><span class="token comment"># 然后计算误差的clip</span>error_clipped <span class="token operator">=</span> return_batch <span class="token operator">-</span> value_pred_clippederror_original <span class="token operator">=</span> return_batch <span class="token operator">-</span> values<span class="token comment"># 然后直接计算loss</span>value_loss_clipped <span class="token operator">=</span> mse_loss<span class="token punctuation">(</span>error_clipped<span class="token punctuation">)</span>value_loss_original <span class="token operator">=</span> mse_loss<span class="token punctuation">(</span>error_original<span class="token punctuation">)</span><span class="token comment"># 算出loss之后反向传播即可</span><span class="token punctuation">(</span>value_loss <span class="token operator">*</span> self<span class="token punctuation">.</span>value_loss_coef<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><p>以下实验来源于Policy Regularization via Noisy Advantage Values for<br>Cooperative Multi-agent Actor-Critic methods(arXiv:2106.14334v13 )</p><h3 id="算法表现对比"><a href="#算法表现对比" class="headerlink" title="算法表现对比"></a>算法表现对比</h3><p>首先展示了论文介绍的算法以及其对比算法在SMAC各种场景下的胜率,将自己算法效果好于或者等于其他算法的效果的场景下的胜率进行加粗展示:</p><p><img src="http://cdn.leafii.top/img/image-20221031140635091.png" alt="image-20221031140635091" loading="lazy"></p><p>论文对该表的解释:</p><blockquote><p>表 2 中的实验结果表明 (1) NV-MAPPO 在大多数困难场景 2 上的性能显着超过 MAPPO，例如 5m_vs_6m (+65%)、走廊 (+97%)、6h_vs_8z (+87%) 和 3s5z_vs_3s6z (+31%)。 （2）NV-IPPO在Super Hard场景3s5z_vs_3s6z（96%）和6h_vs_8z（94%）中取得了超高的胜率；我们推测这是因为噪声还可以防止 IPPO 由于非平稳性而过拟合。 (3) NV-MAPPO 在硬场景上的平均性能优于 Fine-tuned QMIX 和 MAPPO-FP。 (4) 我们在附录 B.1 中比较了 MAPG 和 NV-MAPG，发现 NV-MAPG 的性能也明显优于 MAPG。</p><p>所有这些结果表明，噪声值函数在实际任务中效果很好。由于我们使用 Fine-tuned QMIX [5] 作为基线，QMIX 的中位测试获胜率明显优于过去文献中的实验结果 [14, 19, 20, 26]。至此，NV-MAPPO 和 NV-IPPO 在 SMAC 中共同实现了 SOTA。具体来说，NV-IPPO（适用于 3s5z_vs_3s6z 和 6h_vs_8z）和 NVMAPPO（适用于其他硬场景）在所有硬场景中的平均胜率为 97%。</p></blockquote><h3 id="NA-MAPPO和NV-MAPPO的对比"><a href="#NA-MAPPO和NV-MAPPO的对比" class="headerlink" title="NA-MAPPO和NV-MAPPO的对比"></a>NA-MAPPO和NV-MAPPO的对比</h3><p>接着又对NA-MAPPO和NV-MAPPO进行了对比,并对NA-MAPPO算法胜率的较大方差进行了解释,算法胜率的方差可以显示出算法的稳定性.</p><p><img src="http://cdn.leafii.top/img/image-20221031141622734.png" alt="image-20221031141622734" loading="lazy"></p><blockquote><p>如图4所示，我们发现噪声优势方法在某些情况下可能会损害算法的稳定性，即噪声优势方法的胜率有很大的方差。我们推测，可能是显性噪声破坏了政策梯度的原有方向。 但是，在smac的某些困难情况下，NA-MAPPO的性能仍可与NV-MAPPO媲美; 我们注意到NA-MAPPO非常容易实现。所有这些结果表明，噪声优势值确实改善了vanilla MAPPO的性能。</p></blockquote><p>然后对NV-MAPPO的噪声值函数如何影响性能进行进一步的实验分析:</p><p><img src="http://cdn.leafii.top/img/image-20221031141816194.png" alt="image-20221031141816194" loading="lazy"></p><blockquote><p>接下来，我们对NV-MAPPO的噪声值函数如何影响性能进行进一步的实验分析。我们在图 5 中展示了一些 Hard 场景下代理维度中值函数𝑣𝑖的标准差。我们发现，<strong>在某些场景中，𝑣𝑖 的大方差意味着 NV-MAPPO 在这些场景中相对于 vanilla MAPPO 的性能提升也很大</strong>，如3s5z_vs_3s6z和6h_vs_8z（见图5和图4）。该定律表明，NV-MAPPO 的性能提升确实来自价值函数的噪声扰动。</p></blockquote><p>最后分析了噪声值函数在3𝑠5𝑧_𝑣𝑠_3𝑠6𝑧场景下对策略熵的影响</p><p><img src="http://cdn.leafii.top/img/image-20221031142025436.png" alt="image-20221031142025436" loading="lazy"></p><blockquote><p>最后分析了噪声值函数对方案3 𝑠 5 𝑧 _ 𝑣𝑠 _ 3 𝑠 6 𝑧 策略熵的影响。如图6所示，vanilla MAPPO策略的熵迅速下降，并落入局部最优解，因此胜率始终为零。对于NV-MAPPO，我们平滑了采样的优势值，并且噪声可以防止策略过拟合，因此策略的熵会更加谨慎地降低。</p></blockquote><h3 id="策略熵和好奇心探索的异同"><a href="#策略熵和好奇心探索的异同" class="headerlink" title="策略熵和好奇心探索的异同"></a>策略熵和好奇心探索的异同</h3><p>policy entropy，从动作空间的角度出发，尽可能探索各种不同的动作，使得策略熵最大化，隐含着各种状态空间也会被探索到。policy entropy依据action的Q值来分配探索的概率，而不是$\epsilon-greedy$中固定概率$\epsilon&#x2F;|A|$探索较低Q值的action.另外policy entropy不简单是一个正则项,有另一个完整的RL框架来描述它,参见<a href="https://zhuanlan.zhihu.com/p/57210858">此链接</a></p><p>curiosity，从状态空间的角度出发，尽可能探索环境的状态转移方式，并把未知的状态转移方式作为内部rewards，以期改变agent的行为。参考<a href="https://zhuanlan.zhihu.com/p/58923482">此链接</a></p><p>应用上，policy entropy适合连续动作空间，如操作机械臂等，得到的策略更鲁棒；curiosity适合sparse rewards的问题，如走迷宫，它能为训练提供更丰富的学习信号。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>多智能体强化学习(二) MAPPO算法详解 <a href="https://blog.csdn.net/weixin_39059031/article/details/117283800">https://blog.csdn.net/weixin_39059031/article/details/117283800</a></li><li>多智能体强化学习MAPPO源代码解读 <a href="https://blog.csdn.net/onlyyyyyyee/article/details/118888711">https://blog.csdn.net/onlyyyyyyee/article/details/118888711</a></li><li>如何理解强化学习中的”好奇心探索”和”策略熵”的异同？ - bigiceberg M的回答 - 知乎 <a href="https://www.zhihu.com/question/311267842/answer/631757642">https://www.zhihu.com/question/311267842/answer/631757642</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/marlbenchmark/on-policy&quot;&gt;https://github.com/marlbenchmark/on-policy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方出品轻量化mappo代码：&lt;a href=&quot;https://github.com/tinyzqh/light_mappo&quot;&gt;https://github.com/tinyzqh/light_mappo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应论文：The Surprising Effectiveness of MAPPO in Cooperative, Multi-Agent Games&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
  </entry>
  
  <entry>
    <title>强化学习_PPO算法(Proximal Policy Optimization)</title>
    <link href="2022/09/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0_PPO%E7%AE%97%E6%B3%95(Proximal%20Policy%20Optimization)/"/>
    <id>2022/09/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0_PPO%E7%AE%97%E6%B3%95(Proximal%20Policy%20Optimization)/</id>
    <published>2022-09-20T13:15:18.000Z</published>
    <updated>2022-10-30T07:38:33.058Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍强化学习中的PPO(Proximal Policy Optimization)算法。</p><span id="more"></span><p>PPO(Proximal Policy Optimization)是OpenAI使用的默认RL方法，PPO方法可以被理解为</p><p><code>Policy Gradient -&gt; (On Policy -&gt; Off Policy) -&gt; (Add Constraint) -&gt; PPO(Proximal Policy Optimization)</code></p><h2 id="RL相关要素"><a href="#RL相关要素" class="headerlink" title="RL相关要素"></a>RL相关要素</h2><p>强化学习是指智能体在给定环境中进行动作的选择，在动作选择并执行之后同环境交互获得新的状态，每一对State（状态）和Action（动作）可以得到相应的Reward（奖励），强化学习的目标就是最大化Reward。</p><p>状态，动作更替可以用Trajectory（迹）来表示：</p><p>$$Trajectory\ \tau &#x3D; {s_1,a_1,s_2,a_2,…,s_T,a_T}\tag{1}$$</p><p>每一条Trajectory的概率为:</p><p>$$p_\theta(\tau) &#x3D;p(s_1)p_\theta(a_1|s_1)p(s_2|s_1,a_1)p_\theta(a_2|s_2)p(s_3|s_2,a_2)…&#x3D;p(s_1)\prod_{t&#x3D;1}^{T}p_\theta(a_t|s_t)p(s_{t+1}|s_t,a_t)\tag{2}$$</p><p>在这个式子中我们可以看到，$p_\theta(a_t|s_t)$是Actor得出的，这个是我们可以控制的，但是$p(s_{t+1}|s_t,a_t)$是动作$a_t$在状态$s_t$下与环境交互转移到状态$s_{t+1}$的概率，这是由环境本身决定的，我们自己无法控制它。</p><p>在强化学习中一条Trajectory的Expected Reward为：</p><p>$$\overline R_\theta &#x3D; \sum_{\tau}R(\tau)p_\theta(\tau)&#x3D;E_{\tau\sim p_\theta(\tau)}[R(\tau)]\tag{3})$$</p><p>其中的$R(\tau)$为：</p><p>$$R(\tau) &#x3D; \sum_{t&#x3D;1}^{T} r_t\tag{4}$$</p><h2 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h2><p>想要最大化Reward，在上一节我们又获得了$\overline R_\theta$的公式，此时我们对$\overline R_\theta$求梯度:</p><p>$$\nabla \overline R_\theta &#x3D; \sum_{\tau}R(\tau)\nabla p_\theta(\tau)&#x3D;\sum_{\tau}R(\tau)p_\theta(\tau)\frac{\nabla p_\theta(\tau)}{p_\theta(\tau)}\tag{5}$$</p><p>在上式中，$R(\tau)$不一定是需要可微的，它甚至可以是一个黑盒。</p><p>$$\nabla f(x) &#x3D; f(x)\nabla logf(x)\tag{6}$$</p><p>接着将梯度公式(6)代入(5)中，得：</p><p>$$\nabla \overline R_\theta &#x3D; \sum_{\tau}R(\tau)p_\theta(\tau)\nabla logp_\theta(\tau)&#x3D; E_{\tau \sim p_\theta(\tau)}[R(\tau)\nabla logp_\theta(\tau)] \approx \frac{1}{N}\sum_{n&#x3D;1}^{N}R(\tau^n)\nabla logp_\theta(\tau^n)$$</p><p>$$&#x3D; \frac{1}{N}\sum_{n&#x3D;1}^{N}\sum_{t&#x3D;1}^{T_n}R(\tau^n)\nabla logp_\theta(a_t^n|s_t^n)\tag{7}$$</p><p>在式子(7)中，由于$\sum_{\tau}$和$p_{\theta}(\tau)$的存在，因此将它们写成期望$E_{\tau \sim p_\theta(\tau)}$的形式。$p_{\theta}(\tau)$相当于$\nabla logp_\theta(\tau)$的一个weight（权重）。并且在$p_\theta(\tau)$中，$\tau$相当于有两项，一项是来自环境本身（无法求梯度），另一项来自智能体Agent，因此将$\nabla logp_\theta(\tau)$更进一步写作$logp_\theta(a_t^n|s_t^n)$</p><p>因此的Policy Gradient的基本过程可以这样描述：在环境中取得数据，在给定的策略$\pi_\theta$下，获得不同的Trajectory，每个Trajectory拥有不同的状态，动作以及对应的奖励值，收集状态动作对之后，将其带入式(7)中，进行参数$\theta$的更新：$\theta \leftarrow \theta + \eta\nabla \overline R_\theta$,在更新之后对新的环境重新获取数据，循环往复，我们可以看到在这个流程中，在环境中取得的数据仅被使用了一次，因此Policy Gradient是一个严格的On-Policy算法。</p><h3 id="Tip-1-Add-a-Baseline"><a href="#Tip-1-Add-a-Baseline" class="headerlink" title="Tip 1: Add a Baseline"></a>Tip 1: Add a Baseline</h3><p>在某些情况下，$\theta \leftarrow \theta + \eta\nabla \overline R_\theta$中的$R(\tau^n)$始终为正，如果采样数量足够多，即使是奖励都为正的动作，我们也可以按照奖励值的大小决定每个动作的优劣，并以此修改下个动作被选中的概率（好的动作增加被选中的概率，差的动作降低被选中的概率），但是在训练的环境下，总会有一些奖励为正的动作无法被采样，但是其他动作的奖励都为正，它们被选中的概率增加好，这就导致未被采样的动作的概率降低，哪怕未被采样的动作实质上优于一部分甚至全部被采样的动作。因此可以将式(7)进行如下修改：</p><p>$$\nabla \overline R_\theta &#x3D; \frac{1}{N}\sum_{n&#x3D;1}^{N}\sum_{t&#x3D;1}^{T_n}(R(\tau^n)-b)\nabla logp_\theta(a_t^n|s_t^n)\tag{8}$$</p><p>在这里的b就是新增的baseline，通常$b \approx E[R(\tau)]$，这样就可以有效的降低未被采样的动作被“误杀”。</p><h3 id="Tip-2-Assign-Suitable-Credit"><a href="#Tip-2-Assign-Suitable-Credit" class="headerlink" title="Tip 2: Assign Suitable Credit"></a>Tip 2: Assign Suitable Credit</h3><p>在一条Trajectory中，每个动作如果只由总的R来反映权重是不合适的，比如在$(s_a,a_1),(s_b,a_2),(s_c,a_3)$中的单步奖励值分别为+5，+0，-2，R&#x3D;5-2&#x3D;+3 但是对于a2，a3这种并未对Reward结果最大化做出正向贡献的action反而也被赋予了值为+3的Reward作为权重，这是不合理的。我们应该让每一个action前的R值都正确的反映它在当前Trajectory中的作用，到底是好还是坏。我们可以把式(8)中的$R(\tau^n)$改写为$\sum_{t’&#x3D;t}^{T_n}r_{t’}^{n}$:</p><p>$$\nabla \overline R_\theta \approx \frac{1}{N}\sum_{n&#x3D;1}^{N}\sum_{t&#x3D;1}^{T_n}(\sum_{t’&#x3D;t}^{T_n}r_{t’}^{n}-b)\nabla p_\theta(a_t^n|s_t^n)\tag{9}$$</p><p>$\sum_{t’&#x3D;t}^{T_n}r_{t’}^{n}$又可以进一步写为$\sum_{t’&#x3D;t}^{T_n}\gamma^{t’-t} r_{t’}^{n}$，其中$\gamma$作为discount factor(折扣因子)并且$\gamma &lt; 1$，因此可以得到：</p><p>$$\nabla \overline R_\theta \approx \frac{1}{N}\sum_{n&#x3D;1}^{N}\sum_{t&#x3D;1}^{T_n}(\sum_{t’&#x3D;t}^{T_n}\gamma^{t’-t} r_{t’}^{n}-b)\nabla p_\theta(a_t^n|s_t^n)\tag{10}$$</p><h2 id="On-policy-v-s-Off-policy"><a href="#On-policy-v-s-Off-policy" class="headerlink" title="On-policy v.s. Off-policy"></a>On-policy v.s. Off-policy</h2><ul><li>On-policy：agent学习与交互的环境是相同的。<strong>On-Policy可以翻译为”同策略”</strong></li><li>Off-policy：agent学习的环境和交互的环境并不相同。<strong>Off-Policy可以翻译为”异策略”</strong></li></ul><h3 id="从On-policy转向Off-policy的分析"><a href="#从On-policy转向Off-policy的分析" class="headerlink" title="从On- policy转向Off-policy的分析"></a>从On- policy转向Off-policy的分析</h3><p>On-policy的情况下，Policy Gradient的公式为:</p><p>$$\nabla \overline R_\theta &#x3D; E_{\tau \sim p_\theta(\tau)}[R(\tau)\nabla logp_\theta(\tau)]\tag{11}$$</p><p>在On-policy中，我们使用$\pi_{\theta}$去收集数据，当$\theta$被更新的时候，我们必须去重新采样训练数据。</p><p>我们现在的目标是：使用$\pi_{\theta’}$采样获得数据去训练$\theta$。$\theta’$是一个固定的值，因此我们可以重复利用采样的数据。</p><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><p>如果正常从p中进行采样获得x的期望值：</p><p>$$E_{x\sim p}[f(x)] \approx \frac{1}{N}\sum_{i&#x3D;1}^{N}f(x^i)\tag{12}$$</p><p>但是现在我们不从p中采样，只能从q中采样呢？</p><p>$$E_{x\sim p}[f(x)] \approx \frac{1}{N}\sum_{i&#x3D;1}^{N}f(x^i)&#x3D;\int f(x)p(x)dx&#x3D; \int f(x) \frac{p(x)}{q(x)}q(x)dx&#x3D; E_{x\sim q}[f(x)\frac{p(x)}{q(x)}]\tag{13}$$</p><p>通过这样的变换，我们就达到了从q中采样获取x期望值的效果。</p><p>重要性采样公式为：</p><p>$$E_{x\sim p}[f(x)]&#x3D; E_{x\sim q}[f(x)\frac{p(x)}{q(x)}]\tag{14}$$</p><h3 id="On-policy-gt-Off-policy"><a href="#On-policy-gt-Off-policy" class="headerlink" title="On-policy-&gt;Off-policy"></a>On-policy-&gt;Off-policy</h3><p>$$\nabla \overline R_\theta &#x3D; E_{(s_t,a_t)\sim \pi_\theta}[A^\theta(s_t,a_t)\nabla logp_\theta(a_t^n|s_t^n)]&#x3D;E_{(s_t,a_t)\sim \pi_\theta’}[\frac{P_\theta(s_t,a_t)}{P_\theta’(s_t,a_t)}A^{\theta’}(s_t,a_t)\nabla logp_\theta(a_t^n|s_t^n)]$$</p><p>$$&#x3D;E_{(s_t,a_t)\sim \pi_\theta’}[\frac{p_\theta(a_t|s_t)}{p_\theta’(a_t|s_t)}\frac{p_\theta(s_t)}{p_\theta’(s_t)}A^{\theta’}(s_t,a_t)\nabla logp_\theta(a_t^n|s_t^n)]\tag{15}$$</p><p>由于我们假设$\theta$与$\theta’$是一样的，因此${p_\theta(s_t)}$和 $ p_\theta’(s_t)$这两个同环境相关的参数可以约掉，而${p_\theta(a_t|s_t)}$和${p_\theta’(a_t|s_t)}$是同动作选择相关，并没有假设它们的动作选择一致，因此不能约掉。因此我们得到：</p><p>$$J^{\theta’}(\theta) &#x3D; E_{(s_t,a_t)\sim \pi_{\theta’}}[\frac{p_\theta(a_t|s_t)}{p_{\theta’}(a_t|s_t)}A^{\theta’}(s_t,a_t)]\tag{16}$$</p><h3 id="Add-Constraint"><a href="#Add-Constraint" class="headerlink" title="Add Constraint"></a>Add Constraint</h3><p>$\theta$和$\theta’$的区别是一个值得讨论的问题。在这里我们所说的区别并不是$\theta$和$\theta’$参数上的不同，而是说它们在表现上的不同的程度需要被限制，而想要这个区别被限制，就必须要使它可以被量化。因此，在PPO中，使用$KL(\theta,\theta’)$对$\theta$和$\theta’$在表现上的不同的程度进行量化。由此可以得到两个算法，即Proximal Policy Optimization(PPO)和TRPO(Trust Region Policy Optimization)：</p><ul><li>Proximal Policy Optimization(PPO)</li></ul><p>$$J_{PPO}^{\theta’}(\theta) &#x3D; J^{\theta’}(\theta) - \beta KL(\theta,\theta’)\tag{17}$$</p><ul><li>TRPO(Trust Region Policy Optimization)</li></ul><p>$$J_{TRPO}^{\theta’}(\theta) &#x3D; E_{(s_t,a_t)\sim \pi_{\theta’}}[\frac{p_\theta(a_t|s_t)}{p_{\theta’}(a_t|s_t)}A^{\theta’}(s_t,a_t)]\tag{18}$$</p><p>在TRPO中，$KL(\theta,\theta’)$以单独的限制存在，一般为$KL(\theta,\theta’)&lt;\delta$.</p><p>因此，PPO算法的伪代码如下：</p><ul><li><p>Initial policy parameters $\theta^0$</p></li><li><p>In each iteration:</p><ul><li>Using $\theta^k$ to interact with the environment to collect ${s_t,a_t}$ and compute advatage $A_{\theta^k}(st,at)$</li><li>Find $\theta$ optimizing $J_{PPO}(\theta)$</li><li>$J_{PPO}^{\theta^k} &#x3D; J^{\theta^k}(\theta) - \beta \times KL(\theta,\theta^k)$ # Update parameters several times</li></ul></li><li><p>与此同时，动态调整$\beta$:</p><ul><li>If $KL(\theta,\theta^k) &gt; KL_{max}$,increase $\beta$</li><li>If $KL(\theta,\theta^k) &lt; KL_{min}$,decrease $\beta$</li></ul></li></ul><p>这就完成了 KL Penalty的建立。</p><h2 id="第二种PPO算法"><a href="#第二种PPO算法" class="headerlink" title="第二种PPO算法"></a>第二种PPO算法</h2><p>在这个PPO算法中，并不是使用KL函数，而是使用clip函数，所谓的clip函数是指$clip(\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)},1-\epsilon,1+\epsilon)$，当$\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)}$的值小于$1-\epsilon$时，它的值取$1-\epsilon$,当$\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)}$的值大于$1+\epsilon$时，它的值取$1+\epsilon$.因此可得：</p><p>$$J_{PPO2}^{\theta^k}(\theta) \approx \sum_{(s_t,a_t)}min(\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t|s_t)}A^{\theta^k}(s_t,a_t),clip(\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)},1-\epsilon,1+\epsilon)A^{\theta^k}(s_t,a_t))\tag{19}$$</p><p>$\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t|s_t)}$和$clip(\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)},1-\epsilon,1+\epsilon)$的图像如图所示：</p><p><img src="http://cdn.leafii.top/img/secondppo.png" alt="secondppo" loading="lazy"></p><h2 id="PPO的网络结构"><a href="#PPO的网络结构" class="headerlink" title="PPO的网络结构"></a>PPO的网络结构</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>一个actor网络，一个critic网络</p><p><img src="http://cdn.leafii.top/img/v2-1c0bdce5fe4df17df7c4a987c4f7c9b1_1440w.jpeg" alt="img" loading="lazy"></p><ul><li>actor网络的输入为状态，输出为动作概率$\pi(a_t|s_t)$(对于离散动作空间而言)或者动作概率分布参数（对于连续动作空间而言）</li><li>critic网络的输入为状态，输出为状态的价值。</li></ul><p>显然，如果actor网络输出的动作能够使优势（$A^\theta(s_t,a_t)$）变大，那么就越好。如果critic网络输出的状态价值越准确，那么就越好。</p><h3 id="产生experience的过程"><a href="#产生experience的过程" class="headerlink" title="产生experience的过程"></a>产生experience的过程</h3><p>已知一个状态$s_0$，通过actor网络得到所有动作的概率（图中以三个动作：$a,b,c$为例），然后依概率采样得到动作$a_0$，然后将$a_0$输入到环境中，得到$s_1$和$r_1$。状态价值$v(s_0)$是通过critic网络输出得到的，这样就得到一个experience：$(s_0,a_0,r_1,v(s_0),logP(a_0|s_0))$，然后将experience放入经验池中(当然之后还会计算$A(s_0,a_0))$以及$G_0$，经验池中也存放了这两个信息)。</p><p><img src="http://cdn.leafii.top/img/v2-053ff8d2e893a3ce59c67dac0406eeb6_1440w.jpeg" alt="img" loading="lazy"></p><blockquote><p>注：虽然$v(s_0)$可以用一条轨迹的折扣回报得到，即：$v(s_0)&#x3D;r_1+\gamma r_2+…+\gamma^{T}r_{T+1}+\gamma^{T+1}v(s_{T+1})$,但是轨迹末状态的下一状态$s_{T+1}$的$v(s_{T+1})$还是需要critic网络来估计，当然如果$s_{T+1}$是正常游戏结束，而不是达到了最大步长，那么令$v(s_{T+1}&#x3D;0$)。与其这样，还不如直接用critic网络直接估计$v(s_0)$，而且值得注意的是，$v(s_0)&#x3D;r_1+\gamma r_2+…+\gamma^{T}r_{T+1}+\gamma^{T+1}v(s_{T+1})$正是我们critic网络作为监督学习的真值</p></blockquote><p>以上是离散动作的情况，如果是连续动作，就输出概率分布的参数（比如高斯分布的均值和方差），然后按照概率分布去采样得到动作$a_0$。</p><p><strong>经验池</strong>存在的意义是更加方便的计算一条轨迹上状态的累积折扣回报$v(s_t)$以及优势$A(s_t,a_t)$而不是消除experience的相关性。</p><h3 id="Actor网络的更新流程"><a href="#Actor网络的更新流程" class="headerlink" title="Actor网络的更新流程"></a>Actor网络的更新流程</h3><p>对优势函数进行定义：</p><p>$$\hat A_t &#x3D; \delta_t+(\gamma \lambda)\delta_{t+1}+…+…+(\gamma \lambda)^{T-t+1}\delta_{T-1},\tag{20}$$</p><p>$$where \delta_t &#x3D; r_t + \gamma V(s_{t+1}) - V(s_t)\tag{21}$$</p><p>因为Actor网络需要输出的动作优势尽可能的大，所以它的训练需要用以下表达式作为Loss函数:</p><p>$$L^{CLIP}(\theta) &#x3D; \hat {\mathbb E}_t[min(r_t(\theta)\hat A_t,clip(r_t(\theta),1-\epsilon,1+\epsilon)\hat A_t\tag{22}$$</p><p>其中$$r_t(\theta) &#x3D; \frac{\pi_\theta(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t)}$$</p><p><strong>值得注意的是：</strong> 和TD3算法的单步TD不同，PPO算法使用多步TD，因此它需要跑完一条轨迹后，才开始计算各个<strong>状态的累积回报</strong>和<strong>动作的优势</strong>。具体而言，状态价值 ，$v(s_0)$，$v(s_1)$ 是通过critic网络输出得到的，动作优势 $A(s_0,a_0)$ 是通过首先计算$ \delta_0&#x3D;r_1+v(s_1)−v(s_0) $，然后用 $\gamma \lambda$作为折扣因子去计算动作优势 $A(s_0,a_0)$ ，具体可以看公式（20）。</p><p>因此训练actor网络的时候需要将经验池中的所有数据都拿出来，计算loss，然后用梯度上升法，多更新几步梯度。更新完成后即将经验池清空，等待下一个新的actor网络与环境互动去收集数据。</p><p>PyTorch 代码如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># train actor net</span>        all_pi_tensor <span class="token operator">=</span> self<span class="token punctuation">.</span>actor_net<span class="token punctuation">(</span>state_tensor<span class="token punctuation">)</span>        pi_tensor <span class="token operator">=</span> all_pi_tensor<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> action_tensor<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        surrogate_advantage_tensor <span class="token operator">=</span> <span class="token punctuation">(</span>pi_tensor <span class="token operator">/</span> old_pi_tensor<span class="token punctuation">)</span> <span class="token operator">*</span>                 advantage_tensor        clip_times_advantage_tensor <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token operator">*</span> surrogate_advantage_tensor        max_surrogate_advantage_tensor <span class="token operator">=</span> advantage_tensor <span class="token operator">+</span>                 torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>advantage_tensor <span class="token operator">></span> <span class="token number">0.</span><span class="token punctuation">,</span>                clip_times_advantage_tensor<span class="token punctuation">,</span> <span class="token operator">-</span>clip_times_advantage_tensor<span class="token punctuation">)</span>        clipped_surrogate_advantage_tensor <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>                surrogate_advantage_tensor<span class="token punctuation">,</span> max_surrogate_advantage_tensor<span class="token punctuation">)</span>        actor_loss_tensor <span class="token operator">=</span> <span class="token operator">-</span>clipped_surrogate_advantage_tensor<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        actor_loss_tensor<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="Critic网络的更新流程"><a href="#Critic网络的更新流程" class="headerlink" title="Critic网络的更新流程"></a>Critic网络的更新流程</h3><p>Actor网络更新后，接着拿从经验池buffer中采出的数据进行Critic网络的更新（数据已经计算了状态价值，折扣回报$G_t$的计算是基于多步TD的方法，从那个状态开始，用每一步环境返回的奖励 R 与折扣因子相乘后累加，即：$G_t &#x3D; r_{t+1} + \gamma r_{t+2} + … + \gamma^{T-t}r_{T+1} + \gamma^{T+1-t}v(s_{T+1})$，其中$v(s_{T+1})$为网络的估计值，更新方式即为：计算好的折扣回报 $G_T$与Critic网络预测当前状态价值 $v(s_t)$ 做差，用MSEloss作为Loss函数，对神经网络进行训练。</p><p>pytorch代码如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># train critic net</span>        pred_tensor <span class="token operator">=</span> self<span class="token punctuation">.</span>critic_net<span class="token punctuation">(</span>state_tensor<span class="token punctuation">)</span>        critic_loss_tensor <span class="token operator">=</span> self<span class="token punctuation">.</span>critic_loss<span class="token punctuation">(</span>pred_tensor<span class="token punctuation">,</span> return_tensor<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        critic_loss_tensor<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="为什么说TRPO和PPO是On-policy的？"><a href="#为什么说TRPO和PPO是On-policy的？" class="headerlink" title="为什么说TRPO和PPO是On-policy的？"></a>为什么说TRPO和PPO是On-policy的？</h2><p><strong>首先我们明确什么是on-policy，什么是off-policy？</strong></p><ul><li>on-policy：就是要训练的agent跟环境互动的agent是同一个agent,也就是我们采样的网络和要优化的网络是否是同一个网络。</li><li>off-policy：那肯定就是跟上面相反的。</li></ul><p>那么进入正题，我们一般认为PPO是off-policy的原因就是因为PPO使用actor网络去sampler然后填充经验池，然后使用这个经验池中的数据去更新这个actor多个epoch，当更新到第二个epoch的时候那么actor就变成了actor1,然而经验池中的数据仍然是actor网络采样得到的，那么就造成了从更新第二个epoch开始采样的actor和要优化的actor不是同一个网络，那么可能就会认为它是off-pocliy的。</p><p>其实可以很简单的解释这个问题，根据off-policy的定义，采样的网络和要优化的网络不是一个网络，那么对于PPO来说，<strong>使用一批数据从更新actor的第二个epoch开始，数据虽然都是旧的actor采样得到的，但是我们并没有直接使用这批数据去更新我们的新的actor，而是使用imporance sampling先将数据分布不同导致的误差进行了修正</strong>。那么这个importance sampling的目的就是让这两者数据分布之间的差异尽可能的缩小，<strong>那么就可以近似理解成做了importance sampling之后的数据就是我们的更新（这里的更新指的是多个epoch更新的中间过程）后的actor采样得来的，这样就可以理解成我们要优化得actor和采样得actor是同一个actor，那么他就是on-policy的。</strong></p><h2 id="Conclusion-3"><a href="#Conclusion-3" class="headerlink" title="Conclusion[3]"></a>Conclusion[3]</h2><p>We have introduced proximal policy optimization, a family of policy optimization methods that <strong>use multiple epochs of stochastic gradient ascent to perform each policy update</strong>.These methods <strong>have the stability and reliability of trust-region methods but are much simpler to implement</strong>**, requiring only few lines of code change to a vanilla policy gradient implementation, applicable in more general settings (for example, when <strong>using a joint architecture for the policy and value function</strong>), and have better overall performance.</p><p>我们介绍了近程策略优化，这是一系列策略优化方法，使用随机梯度上升的多个周期来执行每个策略更新。 这些方法具有信任域方法的稳定性和可靠性，但实现起来要简单得多，只需要很少的代码行就可以改变成一个普通的策略梯度实现，适用于更一般的设置（例如，当使用策略和值函数的联合体系结构时），并且具有更好的整体性能。 </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p>【DRL-16】Proximal Policy Optimization : <a href="https://zhuanlan.zhihu.com/p/142312072">https://zhuanlan.zhihu.com/p/142312072</a></p></li><li><p>为什么说TRPO和PPO是on-policy的？:<a href="https://zhuanlan.zhihu.com/p/387193698">https://zhuanlan.zhihu.com/p/387193698</a></p></li><li><p>Proximal Policy Optimization Algorithms:arXiv:1707.06347v2 [cs.LG] 28 Aug 2017</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍强化学习中的PPO(Proximal Policy Optimization)算法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
  </entry>
  
  <entry>
    <title>用SHAP解释机器学习</title>
    <link href="2022/08/09/%E7%94%A8SHAP%E8%A7%A3%E9%87%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>2022/08/09/%E7%94%A8SHAP%E8%A7%A3%E9%87%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-08-09T09:41:28.000Z</published>
    <updated>2022-09-23T12:20:38.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用SHAP解释机器学习"><a href="#用SHAP解释机器学习" class="headerlink" title="用SHAP解释机器学习"></a>用SHAP解释机器学习</h1><h2 id="什么是Explainable-AI？"><a href="#什么是Explainable-AI？" class="headerlink" title="什么是Explainable AI？"></a>什么是Explainable AI？</h2><p>关于要如何解释自己模型预测出来的结果，我们都需要了解为何我们训练出的模型会做出如此判断，是基于什么原因作出这种判断，会不会model完全用了非常诡异的特征去下决策（但说不定是对的？）以下归纳出几个我们为什么想知道我们训练出来的模型到底在说什么？</p><ul><li>确认模型的合理性：在我们需要做出决策，倚重模型做判断时，我们需要知道，这个模型所参考的数据特征是否正如我们想象的一样。若我们不知道演算法建议的理由，那下决策肯定会觉得害怕，如同依赖了一个名为AI的黑盒子一般。</li><li>改良模型：这点其实和第一点略为相同，如果我们能知道我们的模型所预测的依据，我们就可以去试着改善它。特别是当模型和资料中，存在了一些恰恰好的bias，若我们没试着看背后的原因的话，通常很难发现一些问题。以过去的专案经验当作例子，我们使用影像检验在找瑕疵物件时，预测的效果不错，但取细看背后的原因，却发现模型依赖背景而做出决断。详细的情况是物件的缺陷在拍摄当天时有个固定的光影，模型判断defect的依据竟然是用那个光影，而非物件上的瑕疵。</li><li>从模型上学习：当模型真正的从品质良好的训练资料集中得到了有用的判断依据，人类就可以从模型中学到一些东西。例如为期，人类目前很显然已经被AI击败，但在无关输赢的时候，职业棋手目前早已寻求AI的帮助，让自己的技术更上一层楼。</li></ul><h2 id="SHAP-Value"><a href="#SHAP-Value" class="headerlink" title="SHAP Value"></a>SHAP Value</h2><p>以上几点让我们了解Explainable AI的必要性，那我们该如何下手去理解每个预测我们的模型是如何理解的呢？</p><p>SHAP values（SHapley Additive exPlanations）是一个Python的视觉化分析套件，让我们能轻易地了解我们的模型做出决策的依据。</p><p>那对我们来说，什么时候该用SHAP value呢？</p><p>举例：</p><ul><li>制造业的入料控制以达到最佳化结果，你如何正确地减少不必要的入料，也可以达到一样的产能。</li><li>利用Users的使用行为，找到诈骗账号。并对模型做出解释，借此在各种features中找到诈骗账号一般性具有的行为。</li></ul><h2 id="SHAP估计"><a href="#SHAP估计" class="headerlink" title="SHAP估计"></a>SHAP估计</h2><p>除了这个方法，还可以使用SHAP（SHapley Additive exPlanations）来估计Shapley values，SHAP将模型的预测值解释为每个输入特征的归因值之和。换句话说，就是计算每一个特征的Shapley value，依此来衡量特征对最终预测值的影响。用公式表示：</p><p>$$g(z’)&#x3D;\phi_0+\sum_{j&#x3D;1}^{M}\phi_jz’_j$$</p><ul><li>g(z’)为被简化的可解释的模型</li><li>z’表示相应的特征是否存在（1或0），M是输入特征的个数，因此可以表示成$z’\in{0,1}^M$</li><li>$\phi_i$代表我们要求的Shapley value</li><li>$\phi_0$代表平均值</li></ul><h2 id="Kernel-SHAP"><a href="#Kernel-SHAP" class="headerlink" title="Kernel SHAP"></a>Kernel SHAP</h2><p>$$g(z’)&#x3D;\phi_0+\sum_{k&#x3D;1}^{M}\phi_kz’_k$$</p><p>Kernel SHAP 的计算流程：</p><ul><li>Sample coalitions $z’_k\in{0,1}^M,k\in{1,…,K}$(1&#x3D;feature present in coalition,0 &#x3D; feature absent).</li><li>Get prediction for each $z’_k$ by first converting z’k to the original feature space and then applying model f:$f(h_x(z’_k))$</li><li>Compute the weight for each $z’_k$ with the SHAP kernel.</li><li>Fit weighted linear model.</li><li>Return Shapley values $\phi_k$, the coefficients from the linear model.</li></ul><p>Kernel SHAP 计算流程的详细说明：</p><p>Step 1:</p><ul><li>Sample coalitions $z’_k\in{0,1}^M,k\in{1,…,K}$(1&#x3D;feature present in coalition,0 &#x3D; feature absent).</li></ul><p>我们只想要求Age的Shapley value，而Weight和Color都嫌不要求，因此将Age，Weight，Color的z设为（1，0，0）</p><p><img src="http://cdn.leafii.top/img/1*tBYED5khakp0zlEV-mWdfQ.png" alt="Step 1" loading="lazy"></p><p>Step 2:</p><ul><li>Get prediction for each $z’_k$ by first converting z’k to the original feature space and then applying model f:$f(h_x(z’_k))$</li></ul><p>我们取得DATA里的值，假设有一笔资料的Age，Weight，Color为0.5,20,Blue,由于我们Age，Weight，Color的z设为（1，0，0），因此只需保留Age的正确性（0.5），其他两个都随机替代其他资料存在的值，例如Weight从20换成17，Color从Blue换成Pink，注意，17和Pink必须要是DATA里有存在的值，不能随机填。</p><p><img src="http://cdn.leafii.top/img/1*l8aco7sQ4LcjLWFUggBSmg.png" alt="Step 2" loading="lazy"></p><p>Step 3:</p><ul><li>Compute the weight for each $z’_k$ with the SHAP kernel.</li></ul><p>Kernel SHAP中权重的计算根据Simplified Features中0或1的数量，若有很多0或是很多1，我们取较高的权重，若0和1的数量相近则取较低的权重。</p><p><img src="http://cdn.leafii.top/img/1*RxUaGj_RH6FfCSwklWQVzA.png" alt="Step 3" loading="lazy"></p><p>Step 4:</p><ul><li>Fit weighted linear model.</li></ul><p>最后再根据资料来fit一个weighted linear model，而获得的weight其实就是特征对应的Shapley values</p><p><img src="http://cdn.leafii.top/img/1*Q8KsY0ehupv_VxMzYcHWTg.png" alt="Step 4" loading="lazy"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://medium.com/ai-academy-taiwan/%E5%8F%AF%E8%A7%A3%E9%87%8B-ai-xai-%E7%B3%BB%E5%88%97-shap-2c600b4bdc9e">可解釋 AI (XAI) 系列 — SHAP</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用SHAP解释机器学习&quot;&gt;&lt;a href=&quot;#用SHAP解释机器学习&quot; class=&quot;headerlink&quot; title=&quot;用SHAP解释机器学习&quot;&gt;&lt;/a&gt;用SHAP解释机器学习&lt;/h1&gt;&lt;h2 id=&quot;什么是Explainable-AI？&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="机器学习基础" scheme="tags/机器学习基础/"/>
    
    <category term="博弈论基础" scheme="tags/博弈论基础/"/>
    
  </entry>
  
</feed>
