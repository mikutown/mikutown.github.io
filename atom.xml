<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-06-29T09:16:54.172Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode701.二叉搜索树中的插入操作</title>
    <link href="2023/06/29/leetcode701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <id>2023/06/29/leetcode701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</id>
    <published>2023-06-29T09:06:58.000Z</published>
    <updated>2023-06-29T09:16:54.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5输出：[4,2,7,1,3,5]解释：另一个满足题目要求可以通过的树是：</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25输出：[40,20,60,10,30,50,70,null,null,25]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5输出：[4,2,7,1,3,5]</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-108 &lt;= Node.val &lt;= 108</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-108 &lt;= val &lt;= 108</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>见代码</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            &#x2F;&#x2F; 当前节点为空，创建一个新节点并赋值            return new TreeNode(val);        &#125;        if (val &lt; root-&gt;val) &#123;            &#x2F;&#x2F; 要插入的值小于当前节点的值，向左子树递归插入            root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val);        &#125; else &#123;            &#x2F;&#x2F; 要插入的值大于等于当前节点的值，向右子树递归插入            root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val);        &#125;        return root;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定二叉搜索树（BST）的根节点 &lt;code&gt;root&lt;/code&gt; 和要插入树中的值 &lt;code&gt;value&lt;/code&gt; ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 &lt;strong&gt;保证&lt;/strong&gt; ，新值和原始二叉搜索树中的任意节点值都不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 &lt;strong&gt;任意有效的结果&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode450.删除二叉树中的节点</title>
    <link href="2023/06/29/leetcode450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>2023/06/29/leetcode450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2023-06-29T09:06:41.000Z</published>
    <updated>2023-06-29T09:11:20.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol> <span id="more"></span><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3输出：[5,4,6,2,null,null,7]解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0输出: [5,3,6,2,4,null,7]解释: 二叉树不包含值为 0 的节点</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: root &#x3D; [], key &#x3D; 0输出: []</code></pre><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>直接上代码：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* deleteNode(TreeNode* root, int key) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return nullptr;        &#125;        if (root-&gt;val &#x3D;&#x3D; key) &#123;            &#x2F;&#x2F; 当前节点需要删除            if (root-&gt;left &#x3D;&#x3D; nullptr) &#123;                &#x2F;&#x2F; 没有左子树，返回右子树                return root-&gt;right;            &#125; else if (root-&gt;right &#x3D;&#x3D; nullptr) &#123;                &#x2F;&#x2F; 没有右子树，返回左子树                return root-&gt;left;            &#125; else &#123;                &#x2F;&#x2F; 左右子树都存在，找到右子树中的最小节点                TreeNode* minNode &#x3D; findMin(root-&gt;right);                &#x2F;&#x2F; 将最小节点的值赋给当前节点                root-&gt;val &#x3D; minNode-&gt;val;                &#x2F;&#x2F; 在右子树中递归删除最小节点                root-&gt;right &#x3D; deleteNode(root-&gt;right, minNode-&gt;val);            &#125;        &#125; else if (root-&gt;val &gt; key) &#123;            &#x2F;&#x2F; 要删除的值小于当前节点的值，递归在左子树中删除            root-&gt;left &#x3D; deleteNode(root-&gt;left, key);        &#125; else &#123;            &#x2F;&#x2F; 要删除的值大于当前节点的值，递归在右子树中删除            root-&gt;right &#x3D; deleteNode(root-&gt;right, key);        &#125;        return root;    &#125;private:    &#x2F;&#x2F; 在二叉搜索树中找到最小节点    TreeNode* findMin(TreeNode* node) &#123;        while (node-&gt;left !&#x3D; nullptr) &#123;            node &#x3D; node-&gt;left;        &#125;        return node;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉搜索树的根节点 &lt;strong&gt;root&lt;/strong&gt; 和一个值 &lt;strong&gt;key&lt;/strong&gt;，删除二叉搜索树中的 &lt;strong&gt;key&lt;/strong&gt; 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。&lt;/p&gt;
&lt;p&gt;一般来说，删除节点可分为两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先找到需要删除的节点；&lt;/li&gt;
&lt;li&gt;如果找到了，删除它。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode226.翻转二叉树</title>
    <link href="2023/06/28/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/06/28/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-06-28T02:09:48.000Z</published>
    <updated>2023-06-28T02:15:06.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/invert1-tree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/invert2-tree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [2,1,3]输出：[2,3,1]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>深度优先遍历</li></ul><p>使用dfs函数辅助遍历过程。代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL || (root-&gt;left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;right &#x3D;&#x3D; NULL)) &#123;             &#x2F;&#x2F; 如果root为空或者root左右子树都为空，则直接返回root            return root;        &#125;        dfs(root); &#x2F;&#x2F; 否则，则对root进行深度优先遍历        return root;    &#125;    void dfs(TreeNode* node) &#123;        if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123;            return; &#x2F;&#x2F; 如果被遍历的结点左右子树都为空，则直接跳出        &#125;        TreeNode* rightCopy &#x3D; node-&gt;right; &#x2F;&#x2F; 新建一个节点rightCopy用于复制当前被遍历结点的右子树        node-&gt;right &#x3D; node-&gt;left; &#x2F;&#x2F; 将节点的左子树直接赋值给右子树        node-&gt;left &#x3D; rightCopy; &#x2F;&#x2F; 将rightCopy赋值给左子树，完成当前结点的交换        if (node-&gt;left !&#x3D; NULL) &#123; &#x2F;&#x2F; 如果当前结点的左子树不为空，则对该子树进行遍历            dfs(node-&gt;left);        &#125;        if (node-&gt;right !&#x3D; NULL) &#123; &#x2F;&#x2F; 如果当前结点的右子树不为空，则对该子树进行遍历            dfs(node-&gt;right);        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一棵二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，翻转这棵二叉树，并返回其根节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode257.二叉树的所有路径</title>
    <link href="2023/06/28/leetcode257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>2023/06/28/leetcode257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</id>
    <published>2023-06-28T01:43:38.000Z</published>
    <updated>2023-06-28T01:58:54.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/paths-tree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3,null,5]输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[&quot;1&quot;]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>深度优先搜索</li></ul><p>思路：直接深度优先搜索，设置一个dfs辅助函数。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;        vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储所有路径的结果集        if (root &#x3D;&#x3D; NULL) &#123;            return result;        &#125;         string path; &#x2F;&#x2F; 当前的路径的字符串表示        &#x2F;&#x2F; 从根节点开始深度优先搜索        dfs(root, path, result);        return result;    &#125;    void dfs(TreeNode* node, string path, vector&lt;string&gt;&amp; result) &#123;        path +&#x3D; to_string(node-&gt;val); &#x2F;&#x2F; 将当前结点的值加入到当前路径                &#x2F;&#x2F; 如果是叶子结点，将当前路径加入结果集        if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123;            result.push_back(path);            return;        &#125;        &#x2F;&#x2F; 如果存在左子树        if (node-&gt;left !&#x3D; NULL) &#123;            dfs(node-&gt;left, path + &quot;-&gt;&quot;, result);        &#125;        &#x2F;&#x2F; 如果存在右子树        if (node-&gt;right !&#x3D; NULL) &#123;            dfs(node-&gt;right, path + &quot;-&gt;&quot;, result);        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，按 &lt;strong&gt;任意顺序&lt;/strong&gt; ，返回所有从根节点到叶子节点的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叶子节点&lt;/strong&gt; 是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode107.二叉树的层序遍历II</title>
    <link href="2023/06/20/leetcode107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II/"/>
    <id>2023/06/20/leetcode107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II/</id>
    <published>2023-06-20T08:22:14.000Z</published>
    <updated>2023-06-20T05:52:16.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用了层次遍历的思想，利用队列实现。具体解题思路如下：</p><ol><li>首先定义树的节点结构 <code>TreeNode</code>，包含节点值 <code>val</code>、左子节点指针 <code>left</code> 和右子节点指针 <code>right</code>。</li><li>定义一个函数 <code>levelOrderBottom</code>，该函数接受树的根节点 <code>root</code>，并返回层次遍历的结果。</li><li>在 <code>levelOrderBottom</code> 函数中，首先创建一个空的二维向量 <code>result</code>，用于保存最终的结果。</li><li>若根节点为空，直接返回空的结果向量 <code>result</code>。</li><li>创建一个队列 <code>q</code>，将根节点 <code>root</code> 入队。</li><li>进入循环，直到队列为空：<ul><li>获取当前层的节点数量 <code>levelSize</code>，这是为了在遍历当前层时，仅遍历当前层的节点。</li><li>创建一个空的向量 <code>level</code>，用于保存当前层的节点值。</li><li>进入内层循环，遍历当前层的节点：<ul><li>取出队首节点 <code>node</code>。</li><li>弹出队首节点。</li><li>将节点值 <code>node-&gt;val</code> 添加到当前层的结果向量 <code>level</code> 中。</li><li>若节点的左子节点不为空，将左子节点入队。</li><li>若节点的右子节点不为空，将右子节点入队。</li></ul></li><li>将当前层的结果向量 <code>level</code> 插入到结果向量 <code>result</code> 的开头，这是为了保持结果的逆序。</li></ul></li><li>循环结束后，返回结果向量 <code>result</code>。</li><li>在 <code>main</code> 函数中，创建一个测试用例 <code>[3,9,20,null,null,15,7]</code> 的树。</li><li>调用 <code>levelOrderBottom</code> 函数，获取层次遍历的结果，并输出结果。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result; &#x2F;&#x2F; 保存最终的结果        if (root &#x3D;&#x3D; NULL) &#123;            return result;        &#125;        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 创建一个队列，用于层次遍历        q.push(root); &#x2F;&#x2F; 将根节点入队        while (!q.empty()) &#123;            int levelSize &#x3D; q.size(); &#x2F;&#x2F; 当前层的节点数量            vector&lt;int&gt; level; &#x2F;&#x2F; 保存当前层的节点值            for (int i &#x3D; 0; i &lt; levelSize; i++) &#123;                TreeNode* node &#x3D; q.front(); &#x2F;&#x2F; 取出队首节点                q.pop(); &#x2F;&#x2F; 弹出队首节点                level.push_back(node-&gt;val); &#x2F;&#x2F; 将节点值保存到当前层的结果中                if (node-&gt;left !&#x3D; NULL) &#123;                    q.push(node-&gt;left); &#x2F;&#x2F; 将左子节点入队                &#125;                if (node-&gt;right !&#x3D; NULL) &#123;                    q.push(node-&gt;right); &#x2F;&#x2F; 将右子节点入队                &#125;            &#125;            result.insert(result.begin(), level); &#x2F;&#x2F; 将当前层的结果插入到结果向量的开头        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值 &lt;strong&gt;自底向上的层序遍历&lt;/strong&gt; 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode110.平衡二叉树</title>
    <link href="2023/06/20/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/06/20/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-06-20T07:36:41.000Z</published>
    <updated>2023-06-20T05:51:13.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/balance_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/balance_2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：true</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归但空间复杂度较高的解法</li></ul><p>本题可以使用递归的方法来解决。对于每一个节点，我们需要先递归遍历它的左右子树，计算它们的高度差。如果左右子树的高度差超过了1，那么这棵树就不是平衡二叉树。如果左右子树都是平衡二叉树，那么我们可以判断当前节点是不是平衡二叉树：如果左右子树的高度差不超过1，那么当前节点就是平衡二叉树。最后递归返回整棵树的平衡情况。</p><p>在递归函数中，我们需要同时返回当前节点的高度和平衡情况，因此可以使用pair&lt;int, bool&gt;来表示。其中，pair的第一个元素表示高度，第二个元素表示当前节点是否是平衡二叉树。同时，我们需要处理一些边界情况，例如空节点的高度为0，空节点也是平衡二叉树。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root).second;    &#125;        pair&lt;int, bool&gt; checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return make_pair(0, true);        &#125;        auto left &#x3D; checkBalance(node-&gt;left);        auto right &#x3D; checkBalance(node-&gt;right);        if (left.second &amp;&amp; right.second &amp;&amp; abs(left.first - right.first) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return make_pair(max(left.first, right.first) + 1, true);        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return make_pair(0, false);    &#125;&#125;;</code></pre><blockquote><p><code>pair</code>是C++ STL中的一个模板类，用于存储两个不同类型的变量。它将两个变量打包成一个整体，方便传递和使用。</p></blockquote><p>但是它的内存占用过高，因为对于每个节点，它都要单独存一个bool变量用于表示节点是否为二叉树的平衡结点。因此需要进行优化。</p><ul><li>递归，但优化内存占用</li></ul><p>在题目中，我们使用了<code>pair&lt;int, bool&gt;</code>来表示每个节点的高度和平衡情况，但是这种方法会浪费一定的空间，因为每个节点都需要存储一个<code>bool</code>类型的变量。实际上，我们只需要判断每个节点是否平衡，因此可以使用一个<code>int</code>类型的变量来表示平衡情况：-1表示不平衡，非0表示平衡并且代表节点的高度。这样就可以减少空间的使用。</p><p>同时，我们可以将返回值从<code>pair&lt;int, bool&gt;</code>改为<code>int</code>，表示当前节点的高度。如果当前节点不是平衡二叉树，那么直接返回-1，否则返回节点的高度。</p><p>C++代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root) !&#x3D; -1;    &#125;    int checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return 0;        &#125;        int left &#x3D; checkBalance(node-&gt;left);        int right &#x3D; checkBalance(node-&gt;right);        if (left !&#x3D; -1 &amp;&amp; right !&#x3D; -1 &amp;&amp; abs(left - right) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return max(left, right) + 1;        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode101.对称二叉树</title>
    <link href="2023/06/20/leetcode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/06/20/leetcode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-06-20T07:18:47.000Z</published>
    <updated>2023-06-20T05:51:52.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/symtree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,4,4,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/symtree2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,null,3,null,3]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路（<strong>无法通过</strong>）：</li></ol><p>本来是想直接通过中序遍历获得一个数组，然后从数组的两端向中间进行判断，最后样例通过数为192&#x2F;199，原因是如果输入为<code>[1,2,2,2,null,2]</code>时，中序遍历得到的数组是对称的，但是实际上这个二叉树不是对称的。因此该思路被我放弃了。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F; &#x2F;&#x2F; 3241423 中序遍历 先左再中间最后右子树class Solution &#123;public:    void Middle_order_traversal(TreeNode* rootNode, vector&lt;int&gt;&amp; rst) &#123;        if (rootNode) &#123;            Middle_order_traversal(rootNode -&gt; left, rst);            rst.push_back(rootNode -&gt; val);            Middle_order_traversal(rootNode -&gt; right, rst);        &#125;        else &#123;            rst.push_back(-1);        &#125;    &#125;    bool isSymmetric(TreeNode* root) &#123;        vector&lt;int&gt; rst;        Middle_order_traversal(root, rst);        if (rst.size()%2&#x3D;&#x3D;0) &#123;            return false;        &#125;        int left &#x3D; 0, right &#x3D; rst.size() - 1;        while(left &lt; right) &#123;            if (rst[left] !&#x3D; rst[right]) &#123;                return false;            &#125;            left++;            right--;        &#125;        return true;    &#125;&#125;;</code></pre><ol start="2"><li>使用递归：</li></ol><p>在对root进行判断之后，就使用一个辅助函数对root的左子树和右子树进行判断，判断完成后分别对左子树的左子树和右子树的右子树；左子树的右子树以及右子树的左子树进行判断，两个判断结果进行与运算，递归得到最终结果。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若根节点为空，则返回true        return isSymmetricHelper(root-&gt;left, root-&gt;right);    &#125;    bool isSymmetricHelper(TreeNode* left, TreeNode* right) &#123;        if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若左右都为空，则返回true      &#x2F;&#x2F; if ((left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) || (left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL)) return false; &#x2F;&#x2F; 左右子树一个空一个不空，返回false (下面这行更简练)        if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;若左右节点有一个不为空，则返回false        if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F;若左右节点的值不相等，则返回false        &#x2F;&#x2F;递归检查左右子树是否对称        return isSymmetricHelper(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetricHelper(left-&gt;right, right-&gt;left);    &#125;&#125;;</code></pre><ol start="3"><li>使用迭代</li></ol><p>该解决方案使用队列来存储树的节点，首先将左子树和右子树的根节点加入队列中。然后在循环中，每次取出队列的头两个节点，并比较它们是否对称，如果不对称则返回false。如果对称，则将左节点的左子树节点和右节点的右子树节点加入队列，再将左节点的右子树节点和右节点的左子树节点加入队列。如果队列为空，则说明树是对称的，返回true。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;节点为空，返回true        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 定义一个队列存储节点        q.push(root-&gt;left);        q.push(root-&gt;right);        while (!q.empty()) &#123;            TreeNode* left &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为左节点            TreeNode* right &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为右节点            if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) continue; &#x2F;&#x2F;如果左右节点都为空，则继续迭代            if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;左右节点只有一个不为空，直接返回false            if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F; 左右节点值不等，直接返回false            q.push(left-&gt;left);            q.push(right-&gt;right);            q.push(left-&gt;right);            q.push(right-&gt;left); &#x2F;&#x2F; 注意push的顺序！！！        &#125;         return true; &#x2F;&#x2F;若队列为空，则说明该二叉树是对称的。    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ， 检查它是否轴对称。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode987.二叉树的垂序遍历</title>
    <link href="2023/06/20/leetcode987-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>2023/06/20/leetcode987-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-06-20T06:47:33.000Z</published>
    <updated>2023-06-27T07:25:44.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根结点 <code>root</code> ，请你设计算法计算二叉树的 <strong>垂序遍历</strong> 序列。</p><p>对位于 <code>(row, col)</code> 的每个结点而言，其左右子结点分别位于 <code>(row + 1, col - 1)</code> 和 <code>(row + 1, col + 1)</code> 。树的根结点位于 <code>(0, 0)</code> 。</p><p>二叉树的 <strong>垂序遍历</strong> 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p><p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/vtree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[9],[3,15],[20],[7]]解释：列 -1 ：只有结点 9 在此列中。列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。列  1 ：只有结点 20 在此列中。列  2 ：只有结点 7 在此列中。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/vtree2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3,4,5,6,7]输出：[[4],[2],[1,5,6],[3],[7]]解释：列 -2 ：只有结点 4 在此列中。列 -1 ：只有结点 2 在此列中。列  0 ：结点 1 、5 和 6 都在此列中。          1 在上面，所以它出现在前面。          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。列  1 ：只有结点 3 在此列中。列  2 ：只有结点 7 在此列中。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/vtree3.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3,4,6,5,7]输出：[[4],[2],[1,5,6],[3],[7]]解释：这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</code></pre><p><strong>提示：</strong></p><ul><li>树中结点数目总数在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路如下：</p><ol><li>编写了一个辅助函数 <code>verticalTraversalHelper</code>，用于递归处理二叉树。该函数的参数包括当前结点 <code>root</code>、当前结点所在的列数 <code>x</code>、当前结点所在的行数 <code>y</code>，以及一个用于存储结点值的 <code>map</code> 结构 <code>nodes</code>。在该函数中，首先判断当前结点是否为空，若为空则直接返回；否则，将当前结点的值添加到 <code>nodes</code> 结构中对应的列和行中，并递归调用该函数处理左右子树，列数 <code>x</code> 根据左右移动。</li><li>定义了主函数 <code>verticalTraversal</code>，用于实现按照列的顺序遍历二叉树。在该函数中，首先定义了一个二维数组 <code>result</code>，用于存储最终结果。然后判断根结点是否为空，若为空则直接返回空数组。接下来使用 <code>map</code> 结构 <code>nodes</code> 来存储每一列的结点值，其中 key 为列数，value 为行数和结点值的映射。</li><li>调用辅助函数 <code>verticalTraversalHelper</code> 处理二叉树，将结点按照列的顺序分组，存储在 <code>nodes</code> 结构中。</li><li>使用队列 <code>columns</code> 对列数进行排序，然后按照列数从小到大遍历结点值，并将其添加到结果数组 <code>result</code> 中。在遍历过程中，首先从队列中取出一个列数 <code>col</code>，然后使用优先队列 <code>pq</code> 对该列的行数和结点值进行排序。将当前列的结点值按照行数加入优先队列。</li><li>将优先队列中的结点值按照行数顺序取出，存储在一个临时数组 <code>colValues</code> 中。</li><li>将 <code>colValues</code> 数组添加到结果数组 <code>result</code> 中。</li><li>最后返回结果数组 <code>result</code>。</li><li>在 <code>main</code> 函数中，创建了一个测试二叉树，并调用 <code>verticalTraversal</code> 函数进行遍历，然后打印结果。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 辅助函数，用于将二叉树的结点按照列的顺序进行分组    void verticalTraversalHelper(TreeNode *root, int x, int y, map&lt;int, map&lt;int, vector&lt;int&gt;&gt;&gt; &amp;nodes) &#123;        if (!root)            return;        &#x2F;&#x2F; 在对应的列和行中添加当前结点的值        nodes[x][y].push_back(root-&gt;val);        &#x2F;&#x2F; 递归处理左子树和右子树，列数x根据左右移动        verticalTraversalHelper(root-&gt;left, x - 1, y + 1, nodes);        verticalTraversalHelper(root-&gt;right, x + 1, y + 1, nodes);    &#125;    &#x2F;&#x2F; 主函数，返回按照列的顺序遍历的结点值的二维数组    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode *root) &#123;        &#x2F;&#x2F; 存储结点值的二维数组        vector&lt;vector&lt;int&gt;&gt; result;        &#x2F;&#x2F; 如果根结点为空，直接返回空数组        if (!root)            return result;        &#x2F;&#x2F; 使用map来存储每一列的结点值，key为列数，value为行数和结点值的映射        map&lt;int, map&lt;int, vector&lt;int&gt;&gt;&gt; nodes;        &#x2F;&#x2F; 递归处理二叉树，将结点按照列的顺序分组        verticalTraversalHelper(root, 0, 0, nodes);        &#x2F;&#x2F; 使用队列对列数进行排序        queue&lt;int&gt; columns;        for (auto &amp;node : nodes)            columns.push(node.first);        &#x2F;&#x2F; 按照列数从小到大遍历结点值，并添加到结果数组中        while (!columns.empty()) &#123;            int col &#x3D; columns.front();            columns.pop();            &#x2F;&#x2F; 使用优先队列对行数和结点值进行排序            priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;            &#x2F;&#x2F; 将当前列的结点值按照行数加入优先队列            for (auto &amp;node : nodes[col]) &#123;                int row &#x3D; node.first;                for (int val : node.second) &#123;                    pq.push(&#123;row, val&#125;);                &#125;            &#125;            &#x2F;&#x2F; 将当前列的结点值按照行数顺序添加到结果数组中            vector&lt;int&gt; colValues;            while (!pq.empty()) &#123;                colValues.push_back(pq.top().second);                pq.pop();            &#125;            result.push_back(colValues);        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根结点 &lt;code&gt;root&lt;/code&gt; ，请你设计算法计算二叉树的 &lt;strong&gt;垂序遍历&lt;/strong&gt; 序列。&lt;/p&gt;
&lt;p&gt;对位于 &lt;code&gt;(row, col)&lt;/code&gt; 的每个结点而言，其左右子结点分别位于 &lt;code&gt;(row + 1, col - 1)&lt;/code&gt; 和 &lt;code&gt;(row + 1, col + 1)&lt;/code&gt; 。树的根结点位于 &lt;code&gt;(0, 0)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;二叉树的 &lt;strong&gt;垂序遍历&lt;/strong&gt; 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。&lt;/p&gt;
&lt;p&gt;返回二叉树的 &lt;strong&gt;垂序遍历&lt;/strong&gt; 序列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode102.二叉树的层序遍历</title>
    <link href="2023/06/20/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>2023/06/20/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-06-20T01:57:14.000Z</published>
    <updated>2023-06-20T05:52:09.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p> <span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用队列辅助层序遍历</li></ol><p>注意看这个题的输入与输出，输出的动态数组的元素是元素为整型的数组，比如<code>[[3],[9,20],[15,7]]</code>.因此如果只定义一个队列辅助遍历，无法清晰的区分每层的元素应该插入到哪个数组中，比如如果只使用一个队列进行层次遍历，得到的结果只能是<code>[3,9,20,15,7]</code>，无法从这个结果中得知清晰的二叉树层次结构，所以在这里定义两个队列，首先向一个队列中塞入元素，接着对队首元素进行pop并且将队首元素的左右子树节点分别塞入另一队列中，再将结果数组并入result数组中，再将另一个队列进行同样的遍历操作，具体的C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        &#x2F;&#x2F; 定义两个队列 分别为q和another_q 用于层次遍历        queue&lt;TreeNode*&gt; q;        queue&lt;TreeNode*&gt; another_q;        &#x2F;&#x2F; 定义结果数组 其元素为元素为int类型的数组        vector&lt;vector&lt;int&gt;&gt; result;            &#x2F;&#x2F; 若根节点非空 则将根节点push进队列q中         if (root !&#x3D; nullptr) &#123;            q.push(root);        &#125;        &#x2F;&#x2F; 当q或者another_q队列非空时 进行遍历操作        while (!q.empty()|| !another_q.empty()) &#123;            &#x2F;&#x2F; 定义元素为int的临时数组 用于存储每一层的元素            vector&lt;int&gt; temp_vector;            &#x2F;&#x2F; 当队列q非空时 将队列q的元素逐个出队            while (!q.empty()) &#123;                TreeNode* temp_node &#x3D; q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;            &#x2F;&#x2F; 当另一个队列another_q非空时 将队列another_q的元素逐个出队            while (!another_q.empty()) &#123;                TreeNode* temp_node &#x3D; another_q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                another_q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;        &#125;        &#x2F;&#x2F; 返回结果数组        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;层序遍历&lt;/strong&gt; 。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode297.二叉树的序列化与反序列化</title>
    <link href="2023/06/02/leetcode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>2023/06/02/leetcode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-06-02T10:13:21.000Z</published>
    <updated>2023-06-02T10:29:32.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode.cn/hc/kb/article/1567641/">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/serdeser.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[1]</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 104]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>层序遍历序列化</li></ul><p>解题思路：</p><p>对于序列化操作，我们使用层序遍历将二叉树转化为字符串。使用队列辅助遍历，从根节点开始，依次处理每个节点，若节点为空则用字符串”null”表示，否则将节点值转化为字符串，并将其左右子节点加入队列。最后去掉最后一个多余的分隔符”,”并返回结果字符串。</p><p>对于反序列化操作，我们使用stringstream来分割字符串，并依次处理每个节点。首先根据第一个值创建根节点，并加入队列。然后依次处理队列中的节点，每次从字符串中读取两个值，分别表示当前节点的左右子节点的值。若值为”null”，则表示该节点为空，否则创建相应的节点，并加入队列。重复上述过程直到队列为空。最后返回根节点即可。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Codec &#123;public:    &#x2F;&#x2F; Encodes a tree to a single string.    string serialize(TreeNode* root) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return &quot;null&quot;;        &#125;                &#x2F;&#x2F; 使用层序遍历将二叉树转化为字符串        string result;        queue&lt;TreeNode*&gt; q;        q.push(root);                while (!q.empty()) &#123;            TreeNode* node &#x3D; q.front();            q.pop();                        if (node !&#x3D; nullptr) &#123;                &#x2F;&#x2F; 非空节点，将节点值转化为字符串                result +&#x3D; to_string(node-&gt;val);                                &#x2F;&#x2F; 将左右子节点加入队列                q.push(node-&gt;left);                q.push(node-&gt;right);            &#125; else &#123;                &#x2F;&#x2F; 空节点，用&quot;null&quot;表示                result +&#x3D; &quot;null&quot;;            &#125;                        &#x2F;&#x2F; 每个节点值后面加上分隔符&quot;,&quot;            result +&#x3D; &quot;,&quot;;        &#125;                &#x2F;&#x2F; 去掉最后一个多余的分隔符&quot;,&quot;        result.pop_back();                return result;    &#125;    &#x2F;&#x2F; Decodes your encoded data to tree.    TreeNode* deserialize(string data) &#123;        if (data &#x3D;&#x3D; &quot;null&quot;) &#123;            return nullptr;        &#125;                &#x2F;&#x2F; 使用stringstream分割字符串        stringstream ss(data);        string item;        queue&lt;TreeNode*&gt; q;                &#x2F;&#x2F; 获取根节点值        getline(ss, item, &#39;,&#39;);        int rootVal &#x3D; stoi(item);        TreeNode* root &#x3D; new TreeNode(rootVal);        q.push(root);                while (!q.empty()) &#123;            TreeNode* node &#x3D; q.front();            q.pop();                        &#x2F;&#x2F; 依次获取当前节点的左右子节点值            &#x2F;&#x2F; 并创建相应的节点            &#x2F;&#x2F; 左右子节点值为&quot;null&quot;时表示为空节点            getline(ss, item, &#39;,&#39;);            if (item !&#x3D; &quot;null&quot;) &#123;                int leftVal &#x3D; stoi(item);                TreeNode* leftNode &#x3D; new TreeNode(leftVal);                node-&gt;left &#x3D; leftNode;                q.push(leftNode);            &#125;                        getline(ss, item, &#39;,&#39;);            if (item !&#x3D; &quot;null&quot;) &#123;                int rightVal &#x3D; stoi(item);                TreeNode* rightNode &#x3D; new TreeNode(rightVal);                node-&gt;right &#x3D; rightNode;                q.push(rightNode);            &#125;        &#125;                return root;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。&lt;/p&gt;
&lt;p&gt;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &amp;#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 &lt;a href=&quot;https://support.leetcode.cn/hc/kb/article/1567641/&quot;&gt;LeetCode 序列化二叉树的格式&lt;/a&gt;。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode236.二叉树的最近公共祖先</title>
    <link href="2023/06/01/leetcode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>2023/06/01/leetcode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2023-06-01T01:57:12.000Z</published>
    <updated>2023-06-01T01:59:02.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/binarytree.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/binarytree-20230601095804160.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2输出：1</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归遍历求解</li></ul><p>解题思路如下：</p><ol><li>首先，我们需要明确最近公共祖先的定义。在二叉树中，节点A是节点B和节点C的最近公共祖先，意味着节点A是同时包含节点B和节点C的子树中最深的节点。</li><li>从根节点开始遍历二叉树。如果当前节点是p或q中的一个，我们可以返回该节点，因为我们已经找到了一个目标节点。</li><li>递归地在左子树和右子树中寻找p和q。如果在左子树中找到了p或q的最近公共祖先，或者在右子树中找到了p或q的最近公共祖先，那么返回该节点。</li><li>如果左子树和右子树都没有找到p和q的最近公共祖先，那么返回根节点。</li></ol><p>这个思路的关键在于理解最近公共祖先的定义，并通过递归的方式遍历二叉树。通过在左右子树中的递归调用，我们可以找到p和q的最近公共祖先，或者在当前节点返回p或q其中的一个节点，从而实现最近公共祖先的查找。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        &#x2F;&#x2F; 如果当前节点是p或q或者为空，直接返回该节点        if (root &#x3D;&#x3D; nullptr || root &#x3D;&#x3D; p || root &#x3D;&#x3D; q) return root;                TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q); &#x2F;&#x2F; 得到root左子树拥有p或者q的最近祖先        TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q); &#x2F;&#x2F; 得到root右子树拥有p或者q的最近祖先                if (left &amp;&amp; right) return root; &#x2F;&#x2F; 如果左子树和右子树得到的结果都不为空，那么它们的最近公共祖先就是根节点        return left ? left : right; &#x2F;&#x2F; 返回left和right中不为空的那个，如果都为空，那么返回哪个都一样咯    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin&quot;&gt;百度百科&lt;/a&gt;中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;strong&gt;一个节点也可以是它自己的祖先&lt;/strong&gt;）。”&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>DeepMAG-使用多智能体图进行深度强化学习以实现灵活的作业车间调度</title>
    <link href="2023/05/31/DeepMAG-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%9B%BE%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BD%9C%E4%B8%9A%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6/"/>
    <id>2023/05/31/DeepMAG-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%9B%BE%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BD%9C%E4%B8%9A%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6/</id>
    <published>2023-05-31T09:20:59.000Z</published>
    <updated>2023-06-27T08:04:41.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling"><a href="#DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling" class="headerlink" title="DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling"></a>DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>一般的柔性车间调度执行基于两个决策步骤：任务次序（比如在一个机器上任务的执行顺序）以及任务路由（比如一个任务到一个机器的路径）。大多数现有的研究利用DRL或者MARL在大的搜索空间进行调度。<strong>但是</strong>这些研究有两个主要的限制：在DRL和MARL之间没有进行结合，独立的智能体之间没有合作。DeepMAG有两个关键贡献：1. DRL和MARL之间的结合。DeepMAG 通过将不同的智能体与每台机器和作业相关联，将 DRL 与 MARL 集成。每个智能体都利用 DRL 来找到有关作业排序和路由的最佳操作。在作业关联智能体选择最佳机器后，该作业成为机器进行下一个操作的作业候选者，而机器关联智能体从其作业候选集中选择下一个作业进行处理。2. 合作智能体。基于机器和作业之间的操作关系构建多智能体图。一个智能体与其相邻的智能体合作采取一个合作行动。最后，我们进行实验来评估 DeepMAG 的性能，实验结果表明它优于最先进的技术。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>作业车间调度 (JSS) 是最流行的调度问题之一，由于其在实际工厂中的广泛适用性，已被研究了几十年 [1]。 JSS 的决策步骤是通过在特定时间在特定机器上执行作业来对作业进行排序，其中 (1) 每个作业的操作需要按给定顺序（即<strong>优先约束</strong>）处理，(2) 每台机器只能处理一个任何时候作业的操作（即排除约束），以及（3）每个作业操作都有一台唯一的机器（即唯一约束）。而FJSS满足<strong>优先和排除约束</strong>但将<strong>唯一约束</strong>放宽为<strong>常量约束</strong>，其中作业的每个操作都可以在给定的常量机器集(Set)中的任何机器上处理，而不是在一台唯一的机器上处理。除了 JSS 中的作业排序（即作业在机器上执行的顺序）之外，FJSS 在作业路由上还有一个额外的决策步骤（即作业的每个操作到给定恒定机器集中的机器的路线） .</p><p><img src="http://cdn.leafii.top/img/image-20230525205309249.png" alt="image-20230525205309249" loading="lazy"></p><p>在现有的近似计算方法中，调度规则（Dispatching rules）很难得到满足真实生活应用的调度解；启发式搜索方法可以有效地到达可能的解，但是容易陷入局部最优；强化学习方法表现出了潜力，并且相较于其他方法更有到达精确最优解的潜能。但是这些方法有两个主要的缺陷：</p><ol><li><p>没有把DRL和MARL进行结合。</p><p>大多数研究工作将 DRL 用于大型状态空间 或将 MARL 用于大型动作空间。他们没有将 DRL 与 MARL 集成来解决 FJSS 中同时具有大状态和动作空间的难题。</p></li><li><p>独立的智能体。</p><p>当前的研究利用多个智能体来管理大的动作空间，但这些智能体彼此独立。结果，每个智能体都为一个子空间找到了自己的最优阶乘动作，而来自所有智能体的这些阶乘动作不一定构成一个最优联合动作。</p></li></ol><p>为了解决这两个限制，本文提出了一种基于深度强化学习和多智能体图的 FJSS 新模型，称为 DeepMAG，它具有两个重要特征。 </p><ol><li>DRL与MARL的融合。 DeepMAG 通过将每台机器或作业与一个独特的智能体相关联，将 DRL 集成到 MARL 中，该智能体利用 DQN 为机器关联的智能体找到作业排序的最佳操作，以选择下一个要处理的作业（如果可用）或作业路由作业相关的智能体在当前操作完成时选择一台机器进行下一个操作。此外，所有与机器相关的智能体共享一个 DQN，而所有与作业相关的智能体共享另一个。 </li><li>合作智能体。 DeepMAG 构建了一个多智能体图，由作为节点的智能体组成，节点基于机器处理作业操作的顺序和可以处理的作业的可能操作。每个智能体通过观察它们的操作关系并在每一步聚合相邻信息以采取一个合作行动来与其相邻智能体合作。</li></ol><p>本文的主要贡献可以概括为：</p><ul><li>我们通过将 DRL 与 MARL 集成，为 FJSS 开发了一个新模型 DeepMAG。 DRL 利用 DQN 来处理大状态空间，而 MARL 利用多个智能体来管理大动作空间。</li><li>我们设计了一个多智能体图，该图源自机器和作业之间的操作关系，包括机器的处理顺序和当前时间步正在机器上处理的作业的操作。所有智能体合作寻找最佳行动，以保证 DeepMAG 的良好回报。 </li><li>我们进行了广泛的实验，使用来自真实制造工厂的设置的模拟数据来评估 DeepMAG 的性能。实验结果表明，DeepMAG 明显优于其他竞争技术。</li></ul><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>将对JSS和FJSS的研究分为四类：计算优化方法(Operational optimization methods)，调度规则(Dispatching rules)，启发式搜索方法(Heuristic search methods)，强化学习(Reinforcement learning (RL) methods)；具体介绍略</p><h2 id="Problem-statement"><a href="#Problem-statement" class="headerlink" title="Problem statement"></a>Problem statement</h2><p>我们在第 3.1 节介绍了预备知识，并在第 3.2 节定义了 DeepMAG 的研究问题。在接下来的问题定义中，（1）大写字母表示一个随机变量，它相应的小写字母表示一个随机值，比如S是状态变量，s是S的状态值；（2）粗体字母表示向量，例如，<strong>S</strong>是状态变量向量，s是<strong>S</strong>的状态值向量。(3) 书法字母表示一组值，例如，S 表示一组状态值 s的集合。 (4) 黑板上的粗体字母表示函数，例如$\mathbb{P}$ 表示概率函数。 (5) 打字机字母表示一个常数，例如，p 表示生产率。</p><h3 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h3><p>Definition 3.1 (Markov Decision Process (MDP)).有限 MDP 是一个 4 元组 (S, A, R, P)，其中 S 是状态的有限集，A 是动作的有限集，R 是数字奖励的有限集，P 是四元组参数条件概率质量函数：</p><p>$\mathbb{P}(s’,r|s,a) &#x3D; Pr{S_{t+1} &#x3D; s’, R_{t+1} &#x3D; r|S_t &#x3D;s, A_t &#x3D; a}, (1)$</p><p>对于所有 s，s′ ∈ S，r ∈ R，a ∈ A。P(s′, r|s, a) 表示状态 s′ 和奖励 r 在时间步 t + 1 发生的概率，给定前面的状态 s 和动作 a 在时间步 t，它完全体现了有限 MDP 的动态。</p><p>在 MDP 中，智能体在每个连续的离散时间步与环境交互。在每个时间步 t，智能体接收环境的状态 St，从中选择一个动作 At。一个时间步之后，作为其选择 At 的结果，智能体收到数字奖励 Rt+1，并发现自己处于新状态 St+1。智能体选择动作 At 来最大化它在未来收到的折扣奖励的总和，这称为回报(return)。</p><p>Definition 3.2 (Return).回报 Gt 定义为在时间步 t 后收到的折扣奖励的总和：</p><p>$G_t &#x3D; R_{t+1} + \gamma R_{t+2} + \gamma^2R_{t+3} + … &#x3D; \sum_{n&#x3D;1}^{\infty}\gamma^{n-1}R_{t+n}(2)$，其中$\gamma$为折扣率。</p><p>智能体的目标是最大化其奖励的总量，这意味着最大化的不是即时奖励，而是长期的累积奖励。贴现率决定未来奖励的现值：在第 n 个未来时间步收到的奖励 Rt+n 乘以贴现率的 n-1 次方，即 γ n−1Rt+n。现实世界的问题，例如 JSS 和 FJSS，对于集中式智能体来说往往太大而无法解决。因此，研究人员研究了一个分布式多智能体系统，其中多个智能体在同一环境中行动以完成特定任务。因此，MDP 的定义可以扩展到这样的多智能体系统（定义 3.3）。</p><p>Definition 3.3 (Multi-agent MDP).多智能体 MDP 是一个 5 元组$ (\mathcal{I, S, A, R}, \mathbb{P})$，其中 I 是一组智能体，S 是可以分解为 $\mathcal{I}$的状态集。分量 $S &#x3D; S_1 × · · · × S_{|I|}$，$A &#x3D; A_1 × · · · × A_{|I|}$因此，共享相同奖励集 R 的智能体要执行的联合动作集，条件概率质量函数 P 由下式给出</p><p>$\mathbb{P}(s’,r|s,a) &#x3D; Pr{S_{t+1} &#x3D; s’, R_{t+1}&#x3D;r|S_t &#x3D; s, A_t &#x3D; a},(3)$，其中的s是所有智能体的状态$s_i$，A是所有智能体的动作$A_i$；</p><p>在多智能体 MDP 中，所有智能体在环境中观察自己的局部状态，采取各自的行动，并获得相同的奖励以相互合作完成相同的任务。 MARL 基于多智能体 MDP，通过将联合行动空间划分为多个具有阶乘行动的子空间来解决具有大联合行动空间的问题。每个智能体都可以直接应用各种 RL 方法将每个状态映射到最佳动作。具体来说，基于智能体 i ∈ I 的策略 π，使用 DQN 对具有大状态空间 Si 的状态-动作值函数 Q(si, ai) 进行参数化。</p><p>Definition 3.4 (Value Function).智能体 i ∈ I 在策略 π 下在状态 si 采取行动 ai 的值，表示为 Q(si, ai)，是在时间步 t 从 si 开始采取行动 ai，然后跟随 π 的预期回报，给定经过</p><p>$\mathbb{Q}(s_i, a_i) &#x3D; \mathbb{E}[G_t|S_t^i &#x3D; s_i, A_t^i &#x3D; a_i]$;在 DQN 中，π 是关于学习到的状态-动作值函数 Q(si, ai) 的贪心策略。</p><p>Definition 3.5 (Greedy Policy).对于任何状态-动作值函数 Q，相应的贪心策略 π 是确定性地选择具有最大值的动作 $a_i^*$ 的策略：</p><p>$a_i^* &#x3D; \pi(s_i) &#x3D; arg max \mathbb{Q}(s_i, a_i), for each s_i \in S_i$</p><h3 id="Problem-definition"><a href="#Problem-definition" class="headerlink" title="Problem definition"></a>Problem definition</h3><p>在本节中，我们定义了 MARL 框架中针对 FJSS 研究问题的重要概念。</p><p>环境(Environment)。 FJSS 的环境包括一组机器和一组作业，其中作业被路由到特定机器并在特定时间顺序处理。特别地，FJSS 环境包含第 1 节中提到的三个重要约束：（1）优先约束给出每个作业中操作的处理顺序，（2）排除约束要求在任何机器上处理的作业中最多有一个操作时间，以及（3）常量约束为作业的每个操作指定一个常量机器集。</p><p>智能体(Agents).每个智能体与环境交互，从中学习，然后做出决定。为了处理具有大动作空间的 FJSS，每台机器都与一个作业排序智能体相关联，方法是从机器的本地等待队列（即其作业候选集）中选择下一个作业，以便在可用时进行处理，而每个作业都是通过在当前操作完成时选择一台机器来处理其下一个操作，与作业路由的智能体相关联，然后该作业成为该机器的作业候选者。这些智能体一起工作，根据当前环境状态确定它们的最佳行动。</p><p>状态(States).状态是指环境的表示，包括机器和作业的各种特征，例如，机器的生产率及其关系、正在执行和可用于每个操作的机器数量，以及作业的工作量已完成或保留在不同的操作中。环境有一个全局状态，但每个智能体可能会观察到不同的局部状态。智能体在每个时间步采取行动后，全局状态会转换为新状态。</p><p>动作(Actions).有两种类型的智能体用于不同的操作。 与机器相关的智能体负责作业排序，并在相应机器可用时决定选择哪个作业进行处理。 与作业相关的智能体负责作业路由，并决定在当前操作完成时选择哪台机器来处理相应作业的下一个操作。 换句话说，机器相关智能体的动作是从工作候选集中选择一个工作，而工作相关智能体的动作是从一组固定的机器中选择一台机器。 重要的是要注意，智能体不会在每个时间步都采取行动； 该动作仅在机器可用或作业的当前操作在特定时间步完成时触发。</p><p>奖励(Rewards).在智能体人在时间步 t 采取行动后，他们从环境中收到相同的数字奖励 Rt+1。在每个时间步，奖励设置为 $R_{t+1} &#x3D; r &#x3D; −1$。在 FJSS 中，RL 的目标是最大化作为折扣奖励总和的回报，比如：最小化 makespan，即完成所有工作的总时间步数。</p><p>研究问题(Research problem).给定一组机器 M 和一组作业 J，每台机器 m ∈ M 在任何时候都只处理作业的一个操作（<strong>排除约束</strong>），并且具有指定每个时间步长完成的工作负载的生产率 pm；每个作业 j ∈ J 由 K 个有序操作组成 (oj,1, . . ., oj,K)（<strong>优先约束</strong>）；每个操作 oj,k 只能由一组常量机器 Mj,k ⊂ M（<strong>常量约束</strong>）处理，并且包含工作负载量 qj,k，表示 Mj,k 中给定机器上所需的时间步长。目标是在适当的时间段为特定机器的作业操作找到最佳计划，以最大限度地减少总处理时间，即完工时间。</p><h2 id="The-proposed-DeepMAG"><a href="#The-proposed-DeepMAG" class="headerlink" title="The proposed DeepMAG"></a>The proposed DeepMAG</h2><h3 id="Overview-of-DeepMAG"><a href="#Overview-of-DeepMAG" class="headerlink" title="Overview of DeepMAG"></a>Overview of DeepMAG</h3><p>简要的介绍了用于求解FJSS问题的DeepMAG，其通过两个DQN去进行job routing和job sequencing的决策。对于每一个时间步，DeepMAG按照以下的顺序进行执行。</p><ul><li><strong>Update agent graphs.</strong> DeepMAG 根据机器和作业之间的操作关系（第 4.2 节）<strong>更新</strong>多智能体图及其两种类型的变体（特定于机器的智能体图和特定于作业的智能体图）。</li><li>**Update features for each agent.**根据更新的智能体图，它提取基本特征、以机器为中心的特征和以作业为中心的特征（第 4.3 节）。</li><li>**Update the DQN for job routing.**对于每个准备好处理其对应作业的下一个操作的作业关联智能体，首先提取当前状态和所有候选动作（机器）的表示（第 4.4.2 节），然后深度 Q 学习算法用于从候选机器中选择一个动作来处理作业的下一个操作，更新重放内存，并通过随机梯度下降优化 DQN 的参数（第 4.5 和 4.6 节）。</li><li><strong>Update the other DQN for job sequencing.</strong> 对于每个可用的机器相关智能体，首先提取当前状态和所有候选动作（作业）的表示（第 4.4.1 节），然后应用深度 Q 学习从其候选作业中选择一个动作进行处理，更新回放内存，并通过随机梯度下降优化 DQN 的参数（第 4.5 和 4.6 节）。</li></ul><p>完成所有作业后，将为 FJSS 实例生成一个作业计划。通过在大量的 FJSS 实例上训练 DeepMAG，我们可以得到 DeepMAG 的近似最优参数。</p><h3 id="Multi-agent-graphs"><a href="#Multi-agent-graphs" class="headerlink" title="Multi-agent graphs"></a>Multi-agent graphs</h3><p>为了在job sequencing 和 job routing上大的连续动作空间去掌握FJSS，DeepMAG通过将每个机器或者任务用智能体联系起来来使用MARL。此外，这些智能体能够通过基于机器和作业之间的操作关系（即机器的处理顺序和当前时间步在机器上正在处理的作业的操作）来构建多智能体图的相互协作。需要注意DeepMAG并没有假定有固定数量的operation，并且自然而然地适应具有不同操作数量的场景。以下是多智能体图的定义。</p><p><strong>Definition 4.1</strong> (Multi-agent Graph).给定一组机器 M、一组作业 J 和一组机器 Mj,k ⊂ M 对于每个作业 j ∈ J 的每个操作 k，它们构成一个多智能体图 G &#x3D; (I, Es, Eu, Ev, Ew) 在一个时间步长，其中 I 是一组节点（即智能体）：</p><p>$I &#x3D; M \cup J \ \ \ \ \ \ \ \ (6)$</p><p>Es是机器之间在连续操作方面（例如，从 k 到 k + 1）静态关系的一组有向边：</p><p>$\varepsilon_s &#x3D; {m \rightarrow m’ |\exists j\in J, m \in M_{j,k}\and m’ \in M_{j, k+1}} \ \ \ \ \ \ \ (7)$</p><p>Eu是是机器在一个时间步处理的作业的动态关系上的一组无向边：</p><p>$\varepsilon_u &#x3D; {(j,m)|j\in J \ executing \ at \ m\in M} \ \ \ \ (8)$</p><p>Ev是作业的动态关系上的一组有向边，这些作业刚刚完成第 (k − 1) 次操作，并准备好在某个时间步路由到机器进行第 k 次操作：</p><p>$\varepsilon_v &#x3D; {m \rightarrow j|j \in J routing to m \in M_{j, k}} \ \ \ \ \ (9)$</p><p>Ew是在一个时间步等待在机器上的作业的动态关系的一组有向边：</p><p>$\varepsilon_w &#x3D; {j \rightarrow m|j \in J \ waiting\ at \ m \in M} \ \ \ \ (10)$</p><p>其中有向边 i → i’ 表示父子关系，i 是父节点，i’ 是子节点。</p><p>需要强调的是，在多智能体图中，所有与作业相连的边都是<strong>动态</strong>的，并且取决于在当前时间步可以处理的可能操作。此外，每个作业最多有一种类型的边，用于随时在机器上执行、等待或路由到机器。当一个作业完成时，其关联的智能体成为一个孤立的节点。此后，智能体和节点可互换地用于机器或作业。</p><p><img src="http://cdn.leafii.top/img/image-20230529180040531.png" alt="image-20230529180040531" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230529180231978.png" alt="image-20230529180231978" loading="lazy"></p><p>以图3为例：图3描述了一个多智能体图的例子，其中的M&#x3D;{1,2,3,4,5,6}, J &#x3D; {7,8,9,10,11,12},表1显示了每个任务的每个操作的机器集合。在图3中，黑色的结点表示同机器有关的智能体，白色结点表示和job有关的智能体。根据式7，结点1和结点3之间有一个有向边，因为job&#x3D;7（8，9 或10）在机器m&#x3D;1上有两个连续的操作。结点3和结点7由无向边进行连接，这表示job j&#x3D;7在现在的时间步在机器m&#x3D;3上正在执行。此外，job&#x3D;8和9都在第二个操作刚刚完成而且等待着路由第三个操作到机器m&#x3D;5或者6上，所以由式9可知结点5和6到结点8和9需要被连接起来。最后，基于式10，从结点10，11到结点4的有向边表明job j&#x3D;10和job j&#x3D;11正在机器m&#x3D;4上进行等待，此时的机器4正在执行job j &#x3D; 12。</p><p>在FJSS中，总会有一些在所有operation中拥有相同固定机器集合的job，比如在表1中的job8，9，10.考虑到现实世界中的job的不同operation会有不同的需要，所以不同的job的相同的operation可能会需要不同的机器来执行。比如说，表1中的job 7和11在前两个操作中需要的机器是完全不同的。这意味着这两个job在执行前两个操作时并没有竞争关系。这个特性在智能体执行动作时应该被考虑到。接下来我们定义一些重要且相关的定义。</p><p>Definition 4.2 (Equivalent Jobs).给定一个机器集合M，一个任务集合J，以及一系列固定的机器$M_{j,k}$，它表示每一个$job \ j \in J$的操作k需要的机器集合。当且仅当两个job的每一个操作都有相同的固定机器集合时，这两个job就是相等的。 </p><p>job相等的例子：表1中的$J &#x3D; {7,8,9,10,11,12}$有子集({7},{8,9,10},{11,12}).这几个子集都是每一个操作的固定机器集合都相同的相等任务。因此，我们可以将相等的任务形成一个特定任务的智能体图(Job-specific Agent Graph)。</p><p><strong>Definition 4.3</strong> (Job-specific Agent Graph).给定一系列的机器M，一系列的任务J，以及对每一个job j的operation k的一系列固定的机器集合$M_{j,k} \subset M$，特定于作业 j ∈ J 的智能体图 G(j) 和定义 4.1 中的多智能体图 G 的子图由作业 j 的节点、其等效作业及其每个操作的机器集，以及这些节点之间的边组成。</p><p>以表1为例，G(8)就是job j &#x3D; 8的特定任务智能体图，它由包括结点8，它的相等任务（9和10）以及固定的机器（1，3，4，5和6），以及这些结点之间的边组成。因此，我们可以通过移除结点2，7，11和12以及在图3中与他们相关的边构建G(8)。请注意，所有相等任务的特定任务的智能体图是一样的。举例来说，就是G(8) &#x3D; G(9) &#x3D; G(10).同样的，我们定义一个特定机器的智能体图。</p><p><strong>Definition 4.4</strong> (Machine-specific Agent Graph).给你一系列的机器集合M，一系列任务集合J，以及一系列固定机器集合$M_{j,k} \subset M$对于每一个任务j的每一个操作k，特定于机器 m ∈ M 的智能体图 $G(m)&#x3D;{I(m),\varepsilon_s(m),\varepsilon_u(m),\varepsilon_v(m),\varepsilon_w(m)}$和多智能体的子图定义 4.1 中的图 G 是所有作业 $G(j)&#x3D;{I(j),\varepsilon_s(j),\varepsilon_u(j),\varepsilon_v(j),\varepsilon_w(j)}$的作业特定智能体图的并集机器m可以处理的：$G(m) &#x3D; \bigcup_{j \in {j’|\exist k, m\in M_{j’,k}}}G(j)$</p><p>其中图并集在节点集 I(j) 和边集 Es(j)、Eu(j)、Ev(j) 和 Ew(j) 上执行。</p><p>举例说明：在结点4上的特定机器的智能体图G(4)就是在结点8，9，10，11和12上特定任务的智能体图的并集。因此，我们可以通过移除结点7以及跟他相关的边来得到智能体图G(4).</p><h3 id="Feature-extraction"><a href="#Feature-extraction" class="headerlink" title="Feature extraction"></a>Feature extraction</h3><p>有两种动作，供两类智能体使用。一个同机器相关的智能体的动作就是在它的本地等待执行队列里选取一个任务来执行。同任务相关的智能体的动作就是在一系列的机器中选择一个机器，将它的下一个等待执行的operation放进这个机器对应的本地等待执行队列中。换言之，机器和工作的可交换性构成了两类智能体的状态和动作。因此，机器和作业的特征对于这些智能体人做出决定很重要。</p><p>**Basic features.**我们强调一些已知的基本特征，包括机器 m 的生产率 $p_m$ 和作业 j 在操作 k 的工作量 $q_{j,k}$ 。为了表述方便，我们还用 $q_j$ 表示作业 j 在当前操作的工作量，用 $q_{j,m}$ 表示作业 j 在机器 m 上的工作量，因为当前操作或机器 m 表示一个确定的操作 k，它可以很容易推断出来。此外，设 $x_{j,m}$ 为作业 j 在机器 m 上在当前时间步完成的工作量。则剩余工作量为 $y_{j,m} &#x3D; q_{j,m} − x_{j,m}$。除了这些基本特征外，DeepMAG 还根据 4.2 节中定义的多智能体图提取机器和作业的特征。</p><h4 id="Machine-centric-features"><a href="#Machine-centric-features" class="headerlink" title="Machine-centric features"></a>Machine-centric features</h4><p>在不失一般性的情况下，我们关注机器 m 的特性，其关联智能体负责作业排序，当机器可用时，它会从等待队列中选择一个作业进行处理。</p><p><strong>Four types of machine-centric static relationships</strong></p><p>我们在机器m和其他机器之间定义了四种静态关系。</p><p>父集合由拥有从m’指向m的有向边的每个机器m’组成。它的含义就是m’可能会发送任务的下一个operation给m。</p><p>$M_e(m) &#x3D; {m’|m’ \in M \and (m’ \rightarrow m}\ \ \ \ \ \ \ (12)$</p><p>子集合由拥有从m指向m’的有向边的每个机器m‘组成。它的含义就是m’可能会接受来自机器m的job的operation。</p><p>$M_d(m) &#x3D; {m’|m’ \in  M \and (m \rightarrow m’)}\ \ \ \ \ \ \ \ \ (13)$</p><p>双亲集合是由至少与机器m‘拥有一个公共孩子的机器m的集合。它的含义就是机器m与机器 m’在普通孩子的资源上为竞争关系。</p><p>$M_c(m) &#x3D; {m’|m’ \in M \and (M_d(m’) \cap M_d(m) \neq \emptyset} \ \ \ \ \ (14)$</p><p>兄弟集由每台机器 m’ 组成，这些机器至少有一个与 m 有共同的父代。它的含义就是与机器 m 合作完成共同父结点上即将发送来的的工作。</p><p>$M_b(m) &#x3D; {m’|m’ \in M \and (M_e(m’) \cap M_e(m)\neq \emptyset}\ \ \ \ \ (15)$</p><p>以图3来说明刚才定义的四种静态关系。$M_e(4) &#x3D; {1, 2}, M_d(4) &#x3D; {5, 6}, M_c (4) &#x3D; {3} , M_b(4) &#x3D; {3}$ 在节点4上。</p><p><strong>Two types of machine-centric dynamic relationships</strong></p><p>接着，我们定义了在机器m和任务之间在一个时间步的两种动态关系。</p><p>正在执行的集合由拥有无向边(j,m)的job j组成。需要注意的是由于exclusion constraint的存在，在每一个时间步，$J_u(m)$至多拥有一个任务。</p><p>$J_u(m) &#x3D; {j|j \in J \and (j,m} \ \ \ \ \ \ (16)$</p><p>正在等待执行的任务集合由拥有从j到m的有向边的job j组成。这个集合中的job将通过在未来消耗一定的时间的方式为机器m带来负担。</p><p>$J_w(m) &#x3D; {j|j \in J \and (j \rightarrow m} \ \ \ \ \ \ (17)$</p><p>在图3中，这两种动态关系的举例如下：对于结点4，$J_u(4) &#x3D;{12}, J_w(4) &#x3D; {10,11}$。</p><p><strong>Seven types of machine-centric numeric features.</strong></p><p>基于机器的静态和动态提取一些数量特征。</p><p>具有不同关系的机器的数量（或度（入度出度））的特征 $f_{deg}$ 由下式给出：</p><p>$f_{deg}(m) &#x3D; [|M_{(.)}(m)|] \ \ \ \ \ \ (18)$</p><p>其中的[]表示一个向量聚合，(.)是从式12到式15得到的b,c,d和e的集合，后文的式子中的符号也是如此表示。</p><p>在生产力值的总和上的特征$f_{prod}$由下式给出：</p><p>$f_{prod}(m) &#x3D; [\sum_{m’\in M(.)(m)}p_{m’}] \ \ \ \ \ \ \ \ \ \ \ (19)$</p><p>在正在执行的任务的数量特征$f_{exe}(m)$由下式给出：</p><p>$f_{exe}(m) &#x3D; [|J_u(m)|, \sum_{m’ \in M(.)(m)}|J_u(m’)|] \ \ \ \ \ \ \ \ \ (20)$</p><p>它们相应的已完成和剩余工作量的总和由下式给出:</p><p>$f_{exe}^{finish}(m) &#x3D; [\sum_{m’ \in M(.)(m)} \sum_{j \in J_u(m’)}x_{j, m’}]\ \ \ \ \ \ \ \ (21)$</p><p>$f_{exe}^{remain}(m) &#x3D; [\sum_{m’ \in M(.)(m)} \sum_{j \in J_u(m’)}y_{j, m’}]\ \ \ \ \ \ \ \ (22)$</p><p>相对的，正在等待的任务的数量特征$f_{wait}(m)$由下式给出：</p><p>$f_{wait}(m) &#x3D; [|J_w(m)|, \sum_{m’ \in M_{(.)}(m)}|J_w(m’)|] \ \ \ \ \ \ (23)$</p><p>它的负载数量由下式给出：</p><p>$f_{wait}^{qty}(m) &#x3D; [\sum_{j \in J_w(m)}q_{j, m}, \sum_{m’ \in M_{(.)}(m)}\sum_{j\in J_w(m’)q_{j,m’}}] \ \ \ \ \ \ (24)$</p><p>这些特征表示在机器m周围复杂的环境，并且它们对与机器相关的智能体决策很重要。</p><h4 id="Job-centric-features"><a href="#Job-centric-features" class="headerlink" title="Job-centric features"></a>Job-centric features</h4><p>在不失一般性的情况下，我们通过选择一台机器来处理作业的下一个操作来关注作业 j 的特征，其关联智能体已准备好进行作业路由。</p><p><strong>Three types of job-centric dynamic relationships.</strong></p><p>我们定义了三种在任务j和机器m之间的动态关系。</p><p>路由机器集合$M_v(j)$由从机器m指向任务j的有向边的机器m组成，它能够为下一个操作处理作业 j。</p><p>$M_v(j) &#x3D; {m|m \in M \and(m \rightarrow j)} \ \ \ \ \ (25)$</p><p>拥有相同的路由机器的任务j’的路由任务集合$J_v(j)$由下式表示，它与相同路由机器上的作业j竞争。</p><p>$J_v(j) &#x3D; {j’|j’ \in J \and (M_v(j’)\cap M_v(j)\neq \emptyset} \ \ \ \ \ \ (26)$</p><p>任务j的祖先集合$J_g(j)$是拥有到job j的路径的所有job $j’ \in J$的集合，式子中的虚线箭头表示一条路径，它是具有无向边$(j′, m_1)$ 或有向边 $j′ → m_1$，有向边 $m_l → m_{l+1}$ 的不同节点序列$(j’, m_1, . . . , m_n, j)$ 以及$m_n → j (l &#x3D; 1, . . ., n−1)$。</p><p>$J_g(j) &#x3D; {j’|j’ \dashrightarrow j} \ \ \ \ \ \ \ \ (27)$</p><p>祖先结点将会在未来对任务j的路由机器$m_n$带来负载。例如，在图3中，结点8上的$M_v(8) &#x3D; {5,6}, J_v(8) &#x3D; {9},J_g(8) &#x3D; {7,10,11,12}$.</p><p><strong>Four types of job-centric numeric features.</strong></p><p>我们基于任务j的路由任务集合$J_v(j)$和祖先集合$J_g(j)$提取了四种数量特征。</p><p>和任务j有不同关系的任务数量$f_{num}$由下式表示，其中[]表示一个向量聚合，(.)由式26，27得到的v和g来设定，之后的符号也是这样的含义。</p><p>$f_{num}(j) &#x3D; [|J_{(.)}(j)|]\ \ \ \ \ \ \ (28)$</p><p>这些任务的负载上的三个统计量由下式表示：</p><p>$f_{sum}(j) &#x3D; [\sum_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ (29)$</p><p>$f_{max}(j) &#x3D; [max_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ \ \ (30)$</p><p>$f_{min}(j) &#x3D; [min_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ \ \ (31)$</p><p>任务j的复杂环境由这些特征表示，这些特征在同任务相关的智能体采取最优动作时有重要作用。</p><h3 id="Representations-of-states-and-actions"><a href="#Representations-of-states-and-actions" class="headerlink" title="Representations of states and actions"></a>Representations of states and actions</h3><p>在FJSS的大型状态空间中，将每个状态表示为标识符并学习每个状态的每个动作的状态-动作值是不可行的，就像在经典的 Q-learning 算法中一样。我们的DeepMAG通过代表状态和动作作为4.3节描述的一系列特征去估计状态动作值函数$\mathbb Q(s_i,a_i)$。机器相关和任务相关的智能体拥有不同的表示。</p><h4 id="Machine-associated-agents"><a href="#Machine-associated-agents" class="headerlink" title="Machine-associated agents"></a>Machine-associated agents</h4><p>让同机器有关的智能体$i&#x3D;m\in M$处于可用状态（用式16表示的话就是$J_u(m) &#x3D; \emptyset$），并且在一个时间步有一个正在等待的任务集合$J_w(m)$（由式17表示）。状态$s_i$应该反映智能体的特征和周围环境以及应该能够使每一个动作$a_i&#x3D;J\in J_w(m)$同其他动作区分开。</p><p>**State representations.**状态由向量$s_i$表示，它通过链接生产力$p_m$以及其中机器独有的数量特征（由式18～24表示）。此外，这些从式18～24提取出的向量是由定义4.1得到的多智能体图以及定义4.4的特定机器智能体图$g(m)$提取出来的.所有提取的特征对于智能体i或者机器m都是非常特别的，它们中的大多数都是依赖机器同相邻机器以及任务之间的关系。因此，智能体可以通过观察不同的状态来和其他的智能体合作去做出动作。</p><p>**Action representations.**一个可能的动作$a_i&#x3D;j\in J_w(m)$被表示为一个向量$a_i$，这个向量是由基于定义4.3得到的特定任务的智能体图得到的工作数量$q_{j,m}$和由式18到24得到的七种以机器为中心的数量特征。所有的这些特征对于正在等待的任务j来说是特别的，并且不同于其他的任务或者正在等待的任务。值得注意的是四种以任务为中心的数量特征不适用于提取任务j的特征，因为根据式25，在机器m上等待的任务j以及它的路由机器集合式空的。</p><h4 id="Job-associated-agents"><a href="#Job-associated-agents" class="headerlink" title="Job-associated agents"></a>Job-associated agents</h4><p>相反，假设一个与工作相关的智能体 i &#x3D; j ∈ J 准备就绪并且在一个时间步,由式25得知它中有一个路由机器集 $M_v(j)$。类似地，需要用任务 j 自身和周围的特征来表示状态 $s_j$，并表征每个可能的动作 $a_i &#x3D; m ∈ M_v(j)$。</p><p>**State representations.**由一个向量$s_i$组成状态$s_i$，这个向量是通过将工作数量$q_j$和通过式28到31的四种以任务为中心的数量特征表示。这些特征由任务j和其他任务在多智能体图以及特定任务图之间提取得出。所有的特征依赖智能体i或者任务j，但是他的任何动作都是独立的。</p><p>**Action representations.**一个候选动作$a_i&#x3D;m\in M_v(j)$由一个向量$a_i$表示，它通过将生产力$p_m$和七种类型的以机器为中心的数量特征，这些特征由多智能体图，特定任务的智能体图以及特定机器的智能体图得到。需要注意，等式18到24的定义是基于机器m，而不是这些种类的智能体图。</p><p>总的来说，无论什么样的智能体，表现出的状态或者动作都包含他们独特特征以及周围特征。接下来，这些智能体就能够一同工作以发现一个最优的连续动作(optimail joint action)。</p><h3 id="Learning-on-DQNs"><a href="#Learning-on-DQNs" class="headerlink" title="Learning on DQNs"></a>Learning on DQNs</h3><p>与单独的智能体分别学习各自的DQN的简单方法不同，DeepMAG为每一种做出不同动作的智能体学习一个DQN以降低成本，增加可扩展性并且能够去改变FJSS环境中的智能体个数。所有同机器相关的智能体共享一个DQN，它们在相应的机器到达可用状态时做出任务排序的动作。所有同任务相关的智能体共享另一个DQN，它们在机器现有的操作结束时，选择一个符合条件的机器去进行它的下一个操作。此外，两个DQN拥有同样的学习算法，比如deep Q-learning，只是在状态和动作上拥有不同的输入。deep Q-learning基于经验回放，他的目标是估计状态动作值函数$\mathbb Q(s_i, a_i)$.通常这种函数被建模为深度神经网络（如DQN）。智能体的经验就是根据马尔可夫过程将得到的$(s_i,a_i,s_i’,r)$进行存储。在学习过程中，Q-learning更新被应用在经验的mini-batches上。Q-learning的更新使用如下的损失函数:</p><p>$\mathbb L(\theta_n) &#x3D; \mathbb E[\left(r + \gamma \ max_{a’_i\in A_i}\hat{\mathbb Q}(s_i’,a_i’|\hat \theta_n) - \hat{\mathbb Q}(s_i, a_i|\theta_n)\right)^2 ] \ \ \ \ \ \ \ (32)$</p><p>其中$\gamma$是折扣率，$\theta_n$是DQN的参数。$\hat \theta_n$是用来计算目标的参数。目标网络的参数只有每N步才会进行更新。参数$\theta_n$由随机梯度下降算法进行学习。</p><h3 id="Training-optimization"><a href="#Training-optimization" class="headerlink" title="Training optimization"></a>Training optimization</h3><p>标准的深度 Q 学习算法是无模型的，它通过直接使用来自模拟器的样本训练 DQN 来估计方程式中的值函数 Q(si, ai)。 （4），而不是等式 (1)中的条件概率质量函数 P（s’，r | s，a）。通过学习等式中的贪心策略 a∗ i &#x3D; π (si) 也是一种off-policy。 (5) 同时遵循确保对状态空间进行充分探索的行为分布。在实践中，行为分布通常由 ε-greedy policy 确定，该 ε-greedy policy 遵循概率为 1−ε 的贪婪策略并选择概率为 ε 的随机动作。 DeepMAG 将此算法扩展到多智能体系统，如算法 1 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230531161425827.png" alt="image-20230531161425827" loading="lazy"></p><p>在FJSS环境中，智能体的动作次序是重要的，这对他们知道其他智能体的表现以及互相合作很重要。所以，同任务相关的智能体的动作应该先进行执行，以确保在机器的等待执行队列中有已经被路由去的待执行任务的操作存在。此外，应该根据任务和机器的工作量数量递减排序，因为有大的负载的任务或者机器都对makespan有着很大的影响， 需要更多的关注。最后，两种智能体使用算法2去学习他们自己的DQN。</p><p><img src="http://cdn.leafii.top/img/image-20230531162203905.png" alt="image-20230531162203905" loading="lazy"></p><p>**Computational complexity.**略</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>在5.1定义了实验设置，在5.2分析了实验结果。</p><h3 id="Experimental-setting"><a href="#Experimental-setting" class="headerlink" title="Experimental setting"></a>Experimental setting</h3><h4 id="Emulated-data"><a href="#Emulated-data" class="headerlink" title="Emulated data"></a>Emulated data</h4><p>模拟了在现实世界工厂里用63，50，35，34个机器实现四个有序操作的场景。他们的生产力范围从每小时2400到8400不等。有四种任务，每一种都有一个相等的关系，也就是这些拥有相同类型的任务是相等的，并且构成了相等的类。每种任务在每一个操作上有固定的机器集合，这些数据在表2中被展示。需要注意的是这些数据都是真实工厂中的数据。</p><p><img src="http://cdn.leafii.top/img/image-20230531163034639.png" alt="image-20230531163034639" loading="lazy"></p><p>为了训练DQN，在每一个episode的开始，我们通过均匀分布得到机器U(16,64),任务的数量$|J|\sim U(10, 100)$来生成FJSS实例。每个人物和负载的数量$q \sim U(1,4) \times 10,000$。这些均匀分布是根据现实世界工厂的离散的值，请注意，机器 M 是从给定的常量机器集中为 J 中的每对作业类型和操作挑选的。 DQN 在 10,000 个实例上进行训练并在三个场景中进行测试。每个场景包含 100 个具有相同作业数量（即 20、60 和 100）的不同实例，并取这 100 个实例的平均性能。</p><h4 id="Evaluated-methods"><a href="#Evaluated-methods" class="headerlink" title="Evaluated methods"></a>Evaluated methods</h4><p>我们将提出的DeepMAG同竞争的分发规则，因为其他的方法对于JSS或者FJSS来说没有可扩展性。大多数现有的方法只能解决少于20个机器或者任务。尽管RL方法可以处理大量的机器或者任务，但没有现有的工作用语FJSS。我们开发了四种复合调度方法。</p><ul><li>$J_W M_{max}$：作业关联智能体选择剩余工作量最小的机器，机器关联智能体选择工作负载最大的作业。</li><li>$J_T M_{max}$：与作业相关的智能体选择剩余处理时间最少的机器，与机器相关的智能体选择工作量最大的作业。</li><li>$J_W M_{min}$：作业关联智能体选择剩余工作量最小的机器，机器关联智能体选择工作负载最小的作业。</li><li>$J_T M_{min}$：与作业相关的智能体选择剩余处理时间最少的机器，与机器相关的智能体选择工作量最小的作业。</li></ul><p>四个复合调度规则始终将较高的优先级分配给负担较低的机器，即与作业相关的智能体的最小剩余工作量或处理时间。选择负担很重的机器显然是不合适的，这会成为制造时间的瓶颈。此外，这些规则总是根据作业的工作量为机器相关智能体选择作业，因为工作量与机器上的处理时间成正比，即工作量和处理时间都会导致相同的结果。</p><h4 id="Performance-metrics"><a href="#Performance-metrics" class="headerlink" title="Performance metrics"></a>Performance metrics</h4><p>为了比较 FJSS 上评估方法的性能，我们采用标准指标，即完成所有作业的时间步长总数。请注意，我们报告了每个场景中具有相同作业数量的 100 个测试实例的平均完工时间。</p><h4 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h4><p>我们的实验平台是一个计算服务器，配备 Interl(R) Xeon (R) CPU E5-2699 v4 2.20 GHz 和 Nvidia V100 GPU (16 GB)。 OpenAI 的 Gym 和谷歌的 TensorFlow 是分别用于强化学习和深度学习的开源软件库。我们基于Gym 0.17.3 实现了FJSS 环境，通过指定环境与agent 交互的标准接口。我们基于 TensorFlow 1.14 使用 DQN 实现智能体。每个 DQN 都是一个多层感知器，其中隐藏层数设置为三层，三层神经元数设置为 64、32 和 16。折扣率设置为 γ &#x3D; 0.9，ε-greedy探索从开始时的 ε &#x3D; 1 衰减到结束时的 ε &#x3D; 0.05。为了适应 FJSS 中具有不同机器和作业分布的各种环境，我们根据训练实例估计了预期的转换和步骤总数。然后，重放内存大小 |D|由与转换总数的比率（默认为 0.25）确定，而目标网络更新频率 N 是通过将总步数除以更新次数（默认为 10）来计算的。我们基于 Adam 优化器训练两个 DQN，批量大小为 64，学习率为 0.0001。</p><h3 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h3><h4 id="Method-comparison"><a href="#Method-comparison" class="headerlink" title="Method comparison"></a>Method comparison</h4><p>表 3 比较了三种不同场景下所有评估方法的完工时间。我们可以得出以下三个重要发现。 (1) 我们的 DeepMAG 始终在所有三种场景中实现最佳性能，包括小型、中型和大量作业。与第二好的相反，根据 JT Mmax 给出的性能，DeepMAG 平均将完工时间缩短了 3.6%。这些结果证明了 DeepMAG 对于具有大搜索空间的 FJSS 的有效性，因为它充分利用了 DRL 和 MARL 之间的集成以及智能体在根据机器和作业之间的操作关系构建的各种图中的合作。 (2) JT Mmax 优于其他评估的调度规则，因为在 JT Mmax 中，作业相关智能体根据其处理时间而不是工作量来选择机器，以考虑其生产力的影响。此外，在 JT Mmax 中，与机器相关的智能体通过选择具有最大工作负载而不是最小工作负载的作业来更加关注具有较大工作负载的作业以减少完工时间，其中具有大工作负载的作业主导完工时间。 (3) 相比之下，JW Mmin 在所有三种情况下始终记录最长的 makespan，因为它根据工作量选择机器而不考虑机器生产率，并通过更多地关注工作量小的工作来选择工作。</p><p><img src="http://cdn.leafii.top/img/image-20230531171254007.png" alt="image-20230531171254007" loading="lazy"></p><h4 id="Effect-of-replay-memory-ratios"><a href="#Effect-of-replay-memory-ratios" class="headerlink" title="Effect of replay memory ratios"></a>Effect of replay memory ratios</h4><p>图 4 描绘了不同重放内存比率对 DeepMAG 上预期转换总数的影响，其中该比率与重放内存大小 |D| 成正比。重放内存比率对完工时间的影响很小。由于这三种场景的预期转换总数很大，因此较小的比率会在回放内存中贡献足够的转换，以减轻观察序列中的相关性并平滑模拟数据中的变化，从而解决 DRL 中的不稳定性（甚至发散）和 MARL 在某种程度上。尽管较大的比率提供了更多的回放转换以进一步减少不稳定性，但更多的历史转换会降低学习效率并抵消对不稳定性的改进。在实践中，采用较小的比率来节省内存成本，例如，在我们的实验中默认为 0.25。</p><p><img src="http://cdn.leafii.top/img/image-20230531171419329.png" alt="image-20230531171419329" loading="lazy"></p><h4 id="Effect-of-target-network-update-times"><a href="#Effect-of-target-network-update-times" class="headerlink" title="Effect of target network update times"></a>Effect of target network update times</h4><p>图 5 显示了 DeepMAG 中目标网络更新次数的影响，即目标网络在整个训练过程中更新了多少次。最好的结果是更新目标网络 10 次。当更新时间从 10 次减少到 5 次时，性能变差；原因是目标网络更新太慢，Eq.中的估计目标值。 (32) 经常过时。相反，随着更新时间从 10 次增加到 80 次，性能也变得更差；这个结果是由于状态-动作值和目标值之间的相关性导致的不稳定性增加造成的。因此，应该使用适当数量的目标网络更新次数来平衡不稳定性和过时的目标值。</p><p><img src="http://cdn.leafii.top/img/image-20230531171452175.png" alt="image-20230531171452175" loading="lazy"></p><h4 id="Effect-of-neuron-numbers"><a href="#Effect-of-neuron-numbers" class="headerlink" title="Effect of neuron numbers"></a>Effect of neuron numbers</h4><p>图 6 描绘了关于改变 DQN 的第一个隐藏层中的神经元数量的影响，其中每个连续的隐藏层在前一个隐藏层中具有一半数量的神经元。具有 32 个神经元的设置产生最差的性能，因为神经元数量少导致 FJSS 学习模型的表达力非常有限。当神经元数量从 32 个增加到 64 个时，性能显着提高。原因是模型的表达能力增强了，有利于发现各种状态下更好的动作。随着神经元数量从 64 变为 128，makespan 变长了一点，因为学习的模型可能会出现过度拟合数据的问题。在实践中，应采用适度的神经元数来平衡模型的表达性、泛化性、专业化和计算成本，包括 CPU 时间和内存使用。</p><p><img src="http://cdn.leafii.top/img/image-20230531171525518.png" alt="image-20230531171525518" loading="lazy"></p><h4 id="Convergence-analysis"><a href="#Convergence-analysis" class="headerlink" title="Convergence analysis"></a>Convergence analysis</h4><p>图 7 分别说明了 DeepMAG 在具有 20、60 和 100 个作业的三个测试场景中的奖励曲线，其中 x 轴是训练集的数量，y 轴是 100 个测试实例的平均奖励，如前所述在第 5.1.1 节中。从图.图.从图7可以看出，一开始曲线波动较大，因为DeepMAG的模型参数更新很大。重要的是，在大约 7,000 次训练后，这些曲线收敛到与时间步数相反的接近最大的奖励。这种收敛特性使 DeepMAG 能够在真实的制造工厂中学习 FJSS 的可行解决方案。</p><p><img src="http://cdn.leafii.top/img/image-20230531171559090.png" alt="image-20230531171559090" loading="lazy"></p><h2 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h2><p>在本文中，我们形式化了灵活的作业车间调度（FJSS）问题，包括基于作业排序和路由的基于马尔可夫决策过程的框架，并据此定义了 FJSS 中的环境、智能体、状态、动作和奖励五个重要概念。然后，我们提出了一种基于 DRL 的 FJSS 新模型 DeepMAG，该模型具有多智能体图，该图是根据机器和作业之间的操作关系构建的，即机器的操作顺序和可以处理的作业的可能操作。 DeepMAG 将 DRL 与 MARL 相结合，解决了 FJSS 在状态和动作上空间过大的问题。一方面，DeepMAG 利用两个 DQN 分别为机器相关智能体的作业排序和作业相关智能体的作业路由找到最佳操作。另一方面，DeepMAG 利用各种多智能体图使每个智能体能够与其相邻智能体合作并采取一个合作行动。最后，仿真实验结果表明，与其他最先进的方法相比，DeepMAG 在 FJSS 的三种场景下实现了最佳性能。</p><p>将来，我们将考虑更先进的方法作为基线，例如，通过升级基于启发式的方法以适应大量机器和作业。本文重点研究静态 FJSS 问题，而一些动态事件，如机器故障、新工作插入和工作取消，在现实世界的制造环境中是不可避免的。因此，在 FJSS 中结合动态事件的特征来设计方法是我们未来的研究方向之一。</p><h2 id="Data-availability"><a href="#Data-availability" class="headerlink" title="Data availability"></a>Data availability</h2><p>作者无权共享数据。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling&quot;&gt;&lt;a href=&quot;#DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling&quot; class=&quot;headerlink&quot; title=&quot;DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling&quot;&gt;&lt;/a&gt;DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;一般的柔性车间调度执行基于两个决策步骤：任务次序（比如在一个机器上任务的执行顺序）以及任务路由（比如一个任务到一个机器的路径）。大多数现有的研究利用DRL或者MARL在大的搜索空间进行调度。&lt;strong&gt;但是&lt;/strong&gt;这些研究有两个主要的限制：在DRL和MARL之间没有进行结合，独立的智能体之间没有合作。DeepMAG有两个关键贡献：1. DRL和MARL之间的结合。DeepMAG 通过将不同的智能体与每台机器和作业相关联，将 DRL 与 MARL 集成。每个智能体都利用 DRL 来找到有关作业排序和路由的最佳操作。在作业关联智能体选择最佳机器后，该作业成为机器进行下一个操作的作业候选者，而机器关联智能体从其作业候选集中选择下一个作业进行处理。2. 合作智能体。基于机器和作业之间的操作关系构建多智能体图。一个智能体与其相邻的智能体合作采取一个合作行动。最后，我们进行实验来评估 DeepMAG 的性能，实验结果表明它优于最先进的技术。&lt;/p&gt;</summary>
    
    
    
    
    <category term="知识图谱" scheme="tags/知识图谱/"/>
    
    <category term="车间调度" scheme="tags/车间调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode98.验证二叉搜索树</title>
    <link href="2023/05/31/leetcode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>2023/05/31/leetcode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2023-05-31T06:11:21.000Z</published>
    <updated>2023-05-31T06:28:58.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1-20230531141156695.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [2,1,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/tree2-20230531141159669.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>基于限定值的递归判断</li></ul><p>思路如下：对每一个需要被判断的节点，都为他设置一个最大值和最小值（防止子树的子树不符合搜索树条件），根节点的最大最小值是C++ longlong类型的最大最小值，之后判断左子树时，最大值变更为根节点的值，判断右子树时，最小值变为根节点的值，在判断节点时，若节点为空，则该子树是有效的二叉搜索树，否则就检查当前节点的值是否在minVal到maxVal的范围内。最后递归的验证左子树和右子树。C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 辅助函数，用于验证给定的子树是否为有效的二叉搜索树    bool isValidBSTHelper(TreeNode* node, long long minVal, long long maxVal) &#123;        &#x2F;&#x2F; 如果节点为空，则表示该子树是有效的二叉搜索树        if (node &#x3D;&#x3D; NULL)            return true;                &#x2F;&#x2F; 检查当前节点的值是否在[minVal, maxVal]的范围内        if (node-&gt;val &lt;&#x3D; minVal || node-&gt;val &gt;&#x3D; maxVal)            return false;                &#x2F;&#x2F; 递归验证左子树和右子树        return isValidBSTHelper(node-&gt;left, minVal, node-&gt;val) &amp;&amp;            isValidBSTHelper(node-&gt;right, node-&gt;val, maxVal);    &#125;    bool isValidBST(TreeNode* root) &#123;        &#x2F;&#x2F; 由于题目中未指定树节点的值的范围，所以我们使用长整型的最小值和最大值作为初始范围        long long minVal &#x3D; LLONG_MIN;        long long maxVal &#x3D; LLONG_MAX;                &#x2F;&#x2F; 调用辅助函数进行验证        return isValidBSTHelper(root, minVal, maxVal);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效&lt;/strong&gt; 二叉搜索树定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的左子树只包含 &lt;strong&gt;小于&lt;/strong&gt; 当前节点的数。&lt;/li&gt;
&lt;li&gt;节点的右子树只包含 &lt;strong&gt;大于&lt;/strong&gt; 当前节点的数。&lt;/li&gt;
&lt;li&gt;所有左子树和右子树自身必须也是二叉搜索树。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode617.合并二叉树</title>
    <link href="2023/05/30/leetcode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/05/30/leetcode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-05-29T23:49:07.000Z</published>
    <updated>2023-05-29T23:55:24.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/merge.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root1 &#x3D; [1], root2 &#x3D; [1,2]输出：[2,2]</code></pre><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>通过深度优先遍历进行合并</li></ol><p>如果有树为空，则直接返回另一个树；若两树都不为空，则新建一个节点，将对应的结点的值进行求和，递归调用函数，最终返回根结点。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        &#x2F;&#x2F; 如果其中一个树为空，我们可以直接返回另一个树作为合并后的结果        if (root1 &#x3D;&#x3D; nullptr) &#123;            return root2;        &#125;        if (root2 &#x3D;&#x3D; nullptr) &#123;            return root1;        &#125;                &#x2F;&#x2F; 创建一个新节点，值为两个树当前节点值的和        TreeNode *merged &#x3D; new TreeNode(root1-&gt;val + root2-&gt;val);                &#x2F;&#x2F; 递归地合并左子树和右子树        merged-&gt;left &#x3D; mergeTrees(root1-&gt;left, root2-&gt;left);        merged-&gt;right &#x3D; mergeTrees(root1-&gt;right, root2-&gt;right);                &#x2F;&#x2F; 返回合并后的树        return merged;    &#125;&#125;;</code></pre><ol start="2"><li>通过广度优先遍历实现合并</li></ol><p>我们使用三个队列，<code>q</code>用于存储合并后的树节点，<code>q1</code>和<code>q2</code>分别用于存储两棵输入树的节点。</p><p>在每一轮循环中，我们弹出<code>q</code>、<code>q1</code>和<code>q2</code>的队首元素，分别表示合并后的树的当前节点、第一棵树的当前节点和第二棵树的当前节点。</p><p>然后，我们获取当前节点的左子节点和右子节点，并根据情况进行处理。</p><ul><li>如果两棵树的左子节点都存在，我们创建一个合并后的左子节点，值为两个树的左子节点值之和，并将其连接到合并后的树的当前节点的左侧。同时，我们将合并后的左子节点、第一棵树的左子节点和第二棵树的左子节点分别入队列<code>q</code>、<code>q1</code>和<code>q2</code>中。</li><li>如果只有第一棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li><li>如果只有第二棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li></ul><p>对于右子节点，我们执行类似的逻辑。</p><p>最终，当队列<code>q1</code>和<code>q2</code>都为空时，表示已经遍历完两棵树的所有节点，此时合并过程完成，我们返回合并后的树的根节点。</p><p>这样，使用广度优先遍历的方式，我们可以合并两棵二叉树并返回合并后的结果。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> t1<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 如果其中一个树为空，直接返回另一个树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 创建一个新的节点，值为两个树当前节点值的和</span>        TreeNode<span class="token operator">*</span> merged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>t1<span class="token operator">-></span>val <span class="token operator">+</span> t2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 使用队列存储节点，初始时将根节点入队列</span>        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>merged<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q1<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q2<span class="token punctuation">;</span>        q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>        q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>q2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 弹出当前节点以及对应的两个输入树的节点</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> node1 <span class="token operator">=</span> q1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> node2 <span class="token operator">=</span> q2<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 获取当前节点的左子节点和右子节点</span>            TreeNode<span class="token operator">*</span> left1 <span class="token operator">=</span> node1<span class="token operator">-></span>left<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> left2 <span class="token operator">=</span> node2<span class="token operator">-></span>left<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> right1 <span class="token operator">=</span> node1<span class="token operator">-></span>right<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> right2 <span class="token operator">=</span> node2<span class="token operator">-></span>right<span class="token punctuation">;</span>                      <span class="token comment">// 处理左子节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> left2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>left1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> left2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果两棵树的左子节点都存在，创建合并后的左子节点，并入队列</span>                    TreeNode<span class="token operator">*</span> leftMerged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>left1<span class="token operator">-></span>val <span class="token operator">+</span> left2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node<span class="token operator">-></span>left <span class="token operator">=</span> leftMerged<span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftMerged<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第一棵树的左子节点存在，直接使用该节点</span>                    node<span class="token operator">-></span>left <span class="token operator">=</span> left1<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第二棵树的左子节点存在，直接使用该节点</span>                    node<span class="token operator">-></span>left <span class="token operator">=</span> left2<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>                      <span class="token comment">// 处理右子节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> right2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> right2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果两棵树的右子节点都存在，创建合并后的右子节点，并入队列</span>                    TreeNode<span class="token operator">*</span> rightMerged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>right1<span class="token operator">-></span>val <span class="token operator">+</span> right2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node<span class="token operator">-></span>right <span class="token operator">=</span> rightMerged<span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightMerged<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第一棵树的右子节点存在，直接使用该节点</span>                    node<span class="token operator">-></span>right <span class="token operator">=</span> right1<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第二棵树的右子节点存在</span>                    node<span class="token operator">-></span>right <span class="token operator">=</span> right2<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>              <span class="token comment">// 返回合并后的树</span>        <span class="token keyword">return</span> merged<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两棵二叉树： &lt;code&gt;root1&lt;/code&gt; 和 &lt;code&gt;root2&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，&lt;strong&gt;不为&lt;/strong&gt; null 的节点将直接作为新二叉树的节点。&lt;/p&gt;
&lt;p&gt;返回合并后的二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 合并过程必须从两个树的根节点开始。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode700.二叉搜索树中的搜索</title>
    <link href="2023/05/29/leetcode700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
    <id>2023/05/29/leetcode700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</id>
    <published>2023-05-29T07:09:15.000Z</published>
    <updated>2023-05-29T07:13:35.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><span id="more"></span> <p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2输出：[2,1,3]</code></pre><p><strong>示例 2:</strong></p><p><img src="http://cdn.leafii.top/img/tree2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>数中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接搜索</li></ul><p>在二叉搜索树中，每个节点的值大于其左子树中的所有节点的值，小于其右子树中的所有节点的值，因此可以利用这个性质进行查找操作。你的方法通过迭代方式在二叉搜索树中查找给定值，并返回匹配的节点指针。这种查找方式通常称为”二叉搜索树的查找”或”BST查找”。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* searchBST(TreeNode* root, int val) &#123;        while (root !&#x3D; nullptr) &#123; &#x2F;&#x2F; 在root非空的情况下进行循环            if (val &#x3D;&#x3D; root-&gt;val) &#123;                return root; &#x2F;&#x2F; 如果值匹配就直接返回root            &#125;            else if (val &gt; root-&gt;val) &#123;                root &#x3D; root-&gt;right; &#x2F;&#x2F; 如果值大于root现有的值，它的目标节点只有可能在他的右子树            &#125;            else &#123;                root &#x3D; root-&gt;left; &#x2F;&#x2F; 如果值小于root现有的值，它的目标节点只有可能在他的左子树            &#125;        &#125;        return nullptr; &#x2F;&#x2F; 如果root为空（不管是现有的root还是迭代后的root） 就直接返回nullptr    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定二叉搜索树（BST）的根节点 &lt;code&gt;root&lt;/code&gt; 和一个整数值 &lt;code&gt;val&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你需要在 BST 中找到节点值等于 &lt;code&gt;val&lt;/code&gt; 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="二叉树" scheme="tags/二叉树/"/>
    
  </entry>
  
  <entry>
    <title>leetcode188.买卖股票的最佳时机IV</title>
    <link href="2023/05/24/leetcode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/"/>
    <id>2023/05/24/leetcode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/</id>
    <published>2023-05-24T08:54:22.000Z</published>
    <updated>2023-05-24T08:54:54.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：k &#x3D; 2, prices &#x3D; [2,4,1]输出：2解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 100</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用buy和sale数组进行动态规划，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数），sale[i] 表示进行第 i 次卖出操作后的最大利润，代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;        int n &#x3D; prices.size();        vector&lt;int&gt; buy(k, -prices[0]); &#x2F;&#x2F; 定义买入的数组，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数）        vector&lt;int&gt; sale(k); &#x2F;&#x2F; 定义卖出的数组，sale[i] 表示进行第 i 次卖出操作后的最大利润        for(int i &#x3D; 1; i &lt; n; ++i) &#123;            buy[0] &#x3D; max(buy[0], -prices[i]); &#x2F;&#x2F; 更新第一次买入的最大利润，取当前买入的最大利润和前一天的最大利润中较大的值            sale[0] &#x3D; max(sale[0], prices[i] + buy[0]); &#x2F;&#x2F; 更新第一次卖出的最大利润，取当前卖出的最大利润和前一天的最大利润加上当前股票价格的较大值            for(int j &#x3D; 1; j &lt; k; ++j) &#123;                buy[j] &#x3D; max(buy[j], sale[j - 1] - prices[i]); &#x2F;&#x2F; 更新第 j 次买入的最大利润，取当前买入的最大利润和前一次卖出的最大利润减去当前股票价格的较大值                sale[j] &#x3D; max(sale[j], buy[j] + prices[i]); &#x2F;&#x2F; 更新第 j 次卖出的最大利润，取当前卖出的最大利润和当前买入的最大利润加上当前股票价格的较大值            &#125;        &#125;        return sale[k - 1]; &#x2F;&#x2F; 返回最后一次卖出的最大利润    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;prices&lt;/code&gt; ，它的第 &lt;code&gt;i&lt;/code&gt; 个元素 &lt;code&gt;prices[i]&lt;/code&gt; 是一支给定的股票在第 &lt;code&gt;i&lt;/code&gt; 天的价格，和一个整型 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 &lt;code&gt;k&lt;/code&gt; 笔交易。也就是说，你最多可以买 &lt;code&gt;k&lt;/code&gt; 次，卖 &lt;code&gt;k&lt;/code&gt; 次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="动态规划" scheme="tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>leetcode518.零钱兑换II</title>
    <link href="2023/05/23/leetcode518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II/"/>
    <id>2023/05/23/leetcode518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II/</id>
    <published>2023-05-23T11:02:09.000Z</published>
    <updated>2023-05-23T11:04:16.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：amount &#x3D; 5, coins &#x3D; [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5&#x3D;55&#x3D;2+2+15&#x3D;2+1+1+15&#x3D;1+1+1+1+1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：amount &#x3D; 3, coins &#x3D; [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：amount &#x3D; 10, coins &#x3D; [10] 输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>在这个解答中，我们使用动态规划来解决问题。我们定义一个长度为amount+1的dp数组，其中dp[i]表示凑成金额i所需的硬币组合数。</p><p>我们初始化dp[0]为1，表示凑成金额0的组合数为1（不选择任何硬币）。然后，我们遍历硬币数组coins，对于每个硬币coin，我们从coin遍历到amount，更新dp数组的值。对于每个金额i，我们考虑是否选择硬币coin，如果选择，则组合数增加dp[i-coin]，因为我们只需要找出剩余金额i-coin的组合数即可。</p><p>最终，dp[amount]即为所需的结果，即凑成金额amount的组合数。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;        vector&lt;int&gt; dp(amount + 1, 0); &#x2F;&#x2F; 创建长度为amount+1的dp数组，初始值为0        dp[0] &#x3D; 1; &#x2F;&#x2F; 凑成金额0的组合数为1（不选择任何硬币）                for (int coin : coins) &#123; &#x2F;&#x2F; 遍历硬币数组            for (int i &#x3D; coin; i &lt;&#x3D; amount; i++) &#123; &#x2F;&#x2F; 从硬币coin遍历到amount                dp[i] +&#x3D; dp[i - coin]; &#x2F;&#x2F; 更新组合数            &#125;        &#125;                return dp[amount]; &#x2F;&#x2F; 返回凑成金额amount的组合数    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;coins&lt;/code&gt; 表示不同面额的硬币，另给一个整数 &lt;code&gt;amount&lt;/code&gt; 表示总金额。&lt;/p&gt;
&lt;p&gt;请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;假设每一种面额的硬币有无限个。 &lt;/p&gt;
&lt;p&gt;题目数据保证结果符合 32 位带符号整数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="动态规划" scheme="tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>leetcode322.零钱兑换</title>
    <link href="2023/05/22/leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>2023/05/22/leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2023-05-22T08:09:17.000Z</published>
    <updated>2023-05-22T08:11:34.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11输出：3 解释：11 &#x3D; 5 + 5 + 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：coins &#x3D; [2], amount &#x3D; 3输出：-1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：coins &#x3D; [1], amount &#x3D; 0输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>解题思路：</p><ul><li>创建一个长度为 amount + 1 的数组 <code>dp</code>，用于保存每个金额对应的最小硬币数量。初始时，将数组中所有元素的值设置为一个较大的值，表示无穷大。</li><li>将金额为 0 的最小硬币数量设为 0。</li><li>通过动态规划的方式，遍历每个金额，计算最小硬币数量。</li><li>对于当前金额 i，遍历每个硬币的面值，如果当前硬币面值小于等于当前金额 i，则计算使用当前硬币后的剩余金额 remainder。</li><li>检查剩余金额的最小硬币数量是否为有效值，如果是，则更新当前金额 i 的最小硬币数量为 <code>dp[remainder] + 1</code>（加 1 表示使用了当前硬币）。</li><li>最终，如果最终金额的最小硬币数量仍为无效值（即未被更新），则返回 -1，否则返回最小硬币数量。</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;climits&gt;class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量        vector&lt;int&gt; dp(amount + 1, INT_MAX);                &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0        dp[0] &#x3D; 0;                &#x2F;&#x2F; 遍历每个金额，计算最小硬币数量        for (int i &#x3D; 1; i &lt;&#x3D; amount; ++i) &#123;            &#x2F;&#x2F; 遍历每个硬币的面值            for (int j &#x3D; 0; j &lt; coins.size(); ++j) &#123;                &#x2F;&#x2F; 如果当前硬币面值小于等于当前金额 i                if (coins[j] &lt;&#x3D; i) &#123;                    &#x2F;&#x2F; 计算使用当前硬币后的剩余金额                    int remainder &#x3D; i - coins[j];                                        &#x2F;&#x2F; 检查剩余金额的最小硬币数量是否为有效值                    if (dp[remainder] !&#x3D; INT_MAX) &#123;                        &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量                        dp[i] &#x3D; min(dp[i], dp[remainder] + 1);                    &#125;                &#125;            &#125;        &#125;                &#x2F;&#x2F; 如果最终金额的最小硬币数量为无效值，则返回 -1，否则返回最小硬币数量        return dp[amount] &#x3D;&#x3D; INT_MAX ? -1 : dp[amount];    &#125;&#125;;</code></pre><ol start="2"><li>动态规划（优化）</li></ol><ul><li>通过使用范围-based for 循环遍历硬币面值，可以简化代码并提高可读性。</li><li>内层循环从硬币面值开始，而不是从 1 开始，这样可以避免重复计算和无效的更新。</li><li>这种优化利用了动态规划的特性，逐步计算每个金额的最小硬币数量。</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量        vector&lt;int&gt; dp(amount + 1, amount + 1);        &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0        dp[0] &#x3D; 0;        &#x2F;&#x2F; 动态规划，遍历每个金额，计算最小硬币数量        for (int coin : coins) &#123;            for (int i &#x3D; coin; i &lt;&#x3D; amount; ++i) &#123;                &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量                dp[i] &#x3D; min(dp[i], dp[i - coin] + 1);            &#125;        &#125;        &#x2F;&#x2F; 如果最终金额的最小硬币数量仍然大于 amount，则表示无法凑出该金额，返回 -1        if (dp[amount] &gt; amount) &#123;            return -1;        &#125; else &#123;            &#x2F;&#x2F; 返回最小硬币数量            return dp[amount];        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;coins&lt;/code&gt; ，表示不同面额的硬币；以及一个整数 &lt;code&gt;amount&lt;/code&gt; ，表示总金额。&lt;/p&gt;
&lt;p&gt;计算并返回可以凑成总金额所需的 &lt;strong&gt;最少的硬币个数&lt;/strong&gt; 。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;你可以认为每种硬币的数量是无限的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="动态规划" scheme="tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1207.独一无二的出现次数</title>
    <link href="2023/05/21/leetcode1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>2023/05/21/leetcode1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</id>
    <published>2023-05-21T07:23:35.000Z</published>
    <updated>2023-05-21T07:26:06.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1,2]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路： 该问题要求判断给定数组中各个元素出现的频率是否唯一。</p><p>我们可以使用两个数据结构来解决这个问题：</p><ol><li><code>unordered_map&lt;int, int&gt;</code>：用于记录每个元素出现的频率。</li><li><code>unordered_set&lt;int&gt;</code>：用于记录已经出现过的频率。</li></ol><p>我们首先遍历数组，统计每个元素出现的频率并存储在<code>frequencyMap</code>中。然后，我们遍历<code>frequencyMap</code>，对于每个出现的频率，如果该频率已经在<code>occurrenceSet</code>中存在，则说明出现的频率不是唯一的，我们返回false。否则，将该频率添加到<code>occurrenceSet</code>中。最后，如果所有频率都是唯一的，则返回true。</p><p>在示例代码中，我们使用了一个测试用例<code>arr = &#123;1, 2, 2, 1, 1, 3&#125;</code>进行验证，输出结果为<code>true</code>，说明给定数组中各个元素的频率是唯一的。</p><p>请注意，示例代码中使用了C++标准库中的<code>unordered_map</code>和<code>unordered_set</code>来实现哈希表和哈希集合的功能。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123;        unordered_map&lt;int, int&gt; frequencyMap; &#x2F;&#x2F; 存储每个元素出现的频率        unordered_set&lt;int&gt; occurrenceSet; &#x2F;&#x2F; 存储出现的频率值        &#x2F;&#x2F; 计算每个元素出现的频率        for (int num : arr) &#123;            frequencyMap[num]++;        &#125;        &#x2F;&#x2F; 检查频率是否是唯一的        for (auto it &#x3D; frequencyMap.begin(); it !&#x3D; frequencyMap.end(); ++it) &#123;            int occurrence &#x3D; it-&gt;second;            &#x2F;&#x2F; 如果出现的频率已经存在，返回false            if (occurrenceSet.count(occurrence) &gt; 0) &#123;                return false;            &#125;            &#x2F;&#x2F; 将出现的频率添加到集合中            occurrenceSet.insert(occurrence);        &#125;        &#x2F;&#x2F; 所有频率都是唯一的，返回true        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt;，请你帮忙统计数组中每个数的出现次数。&lt;/p&gt;
&lt;p&gt;如果每个数的出现次数都是独一无二的，就返回 &lt;code&gt;true&lt;/code&gt;；否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1365.有多少小于当前数字的数字</title>
    <link href="2023/05/20/leetcode1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>2023/05/20/leetcode1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2023-05-20T08:16:48.000Z</published>
    <updated>2023-05-20T08:53:08.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p><p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。</p><p>以数组形式返回答案。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [8,1,2,2,3]输出：[4,0,1,1,3]解释： 对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]&#x3D;1 不存在比它小的数字。对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [6,5,4,8]输出：[2,1,0,3]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [7,7,7,7]输出：[0,0,0,0]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>思路：直接复制一份数组，将复制得到的数组进行排序，然后进行遍历比较，将得到的值添加到答案数组中，最后返回答案数组。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; nums_sorted &#x3D; nums; &#x2F;&#x2F; 复制nums数组        sort(nums_sorted.begin(), nums_sorted.end()); &#x2F;&#x2F; 将复制后的数组进行排序        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化答案数组        int len &#x3D; nums.size(); &#x2F;&#x2F; 得到数组的总长度        for (int i &#x3D; 0; i &lt; len; i++) &#123; &#x2F;&#x2F; 进行遍历            int result &#x3D; 0; &#x2F;&#x2F; 初始化大于nums[i]的元素的数量为0            for (int j &#x3D; 0; j &lt; len; j++) &#123; &#x2F;&#x2F; 在排序后的数组中进行遍历，以便得到精确的答案                if (nums_sorted[j] &lt; nums[i]) &#123;                    result++; &#x2F;&#x2F; 如果发现数组中有比nums[i]更小的数字，就把result进行++的操作                &#125;                else&#123;                    break; &#x2F;&#x2F; 否则就跳出循环（因为这是已经排序好的数组，这个元素不小于nums[i]那么之后的元素也都大于等于nums[i] 无需继续遍历                &#125;            &#125;            results.push_back(result); &#x2F;&#x2F; 将答案push进答案数组中        &#125;        return results; &#x2F;&#x2F; 返回答案结果    &#125;&#125;;</code></pre><ul><li>使用计数数组优化</li></ul><p>思路：因为nums数组中元素的大小范围为0到100，所以可以设置一个统计各个数字分别有多少个的计数数组，然后利用计数数组计算整个数组中小于nums[i]的元素的个数。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组，范围为0到100        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化结果数组        int len &#x3D; nums.size(); &#x2F;&#x2F; 获取数组长度                &#x2F;&#x2F; 统计每个数字的出现次数        for (int i &#x3D; 0; i &lt; len; i++) &#123;            count[nums[i]]++; &#x2F;&#x2F; 统计当前数字出现的次数        &#125;                &#x2F;&#x2F; 遍历每个数字，计算小于当前数字的元素个数        for (int i &#x3D; 0; i &lt; len; i++) &#123;            int temp_num &#x3D; nums[i]; &#x2F;&#x2F; 当前数字            int result &#x3D; 0; &#x2F;&#x2F; 小于当前数字的元素个数            for (int j &#x3D; 0; j &lt; temp_num; j++) &#123; &#x2F;&#x2F; 遍历计数数组                result +&#x3D; count[j]; &#x2F;&#x2F; 累加小于当前数字的元素个数            &#125;            results.push_back(result); &#x2F;&#x2F; 将结果添加到结果数组中        &#125;                return results; &#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre><ul><li>使用计数排序和前缀和</li></ul><ol><li>使用计数排序：题目中给出了限制条件，数组元素的范围是0到100，因此可以使用计数排序来替代排序函数，以提高效率。创建一个大小为101的计数数组，统计每个数字的出现次数，然后计算小于每个数字的元素个数。</li><li>使用前缀和：通过累加计算计数数组，可以得到每个数字的前缀和数组。前缀和数组的每个元素表示小于等于该数字的元素个数。然后，通过访问前缀和数组即可获取小于每个元素的元素个数。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组        int len &#x3D; nums.size();        &#x2F;&#x2F; 统计每个数字的出现次数        for (int i &#x3D; 0; i &lt; len; i++) &#123;            count[nums[i]]++;        &#125;        &#x2F;&#x2F; 计算前缀和数组        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;            count[i] +&#x3D; count[i - 1];        &#125;        vector&lt;int&gt; results;        for (int i &#x3D; 0; i &lt; len; i++) &#123;            if (nums[i] &#x3D;&#x3D; 0) &#123;                results.push_back(0); &#x2F;&#x2F; 对于数字0，直接加入结果数组中            &#125; else &#123;                results.push_back(count[nums[i] - 1]); &#x2F;&#x2F; 获取小于当前数字的元素个数            &#125;        &#125;        return results;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt;，对于其中每个元素 &lt;code&gt;nums[i]&lt;/code&gt;，请你统计数组中比它小的所有数字的数目。&lt;/p&gt;
&lt;p&gt;换而言之，对于每个 &lt;code&gt;nums[i]&lt;/code&gt; 你必须计算出有效的 &lt;code&gt;j&lt;/code&gt; 的数量，其中 &lt;code&gt;j&lt;/code&gt; 满足 &lt;code&gt;j != i&lt;/code&gt; &lt;strong&gt;且&lt;/strong&gt; &lt;code&gt;nums[j] &amp;lt; nums[i]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;以数组形式返回答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
