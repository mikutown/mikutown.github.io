<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-04-20T02:08:21.251Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode224.基本计算器</title>
    <link href="2023/04/19/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>2023/04/19/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2023-04-19T14:40:16.000Z</published>
    <updated>2023-04-20T02:08:21.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;1 + 1&quot;输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot; 2-1 + 2 &quot;输出：3</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li><li>‘+’ 不能用作一元运算(例如， “+1” 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</li><li>‘-‘ 可以用作一元运算(即 “-1” 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</li><li>输入中不存在两个连续的操作符</li><li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>题目要求实现一个计算器，计算一个字符串表达式的值。因为表达式中可能会存在括号，为了方便计算，可以使用递归的方法来实现。当遇到左括号时，递归调用自身来计算括号内的表达式值，当遇到右括号时，返回计算结果。当遇到加号或减号时，记录当前的操作符。当遇到数字时，记录当前的数值，并根据之前的操作符进行相应的计算。</p><p>具体步骤如下：</p><ol><li>定义一个辅助栈，用于存储之前的操作符和数字；</li><li>遍历表达式字符串，遇到数字时记录下来，遇到左括号时递归调用自身，遇到右括号时返回计算结果；</li><li>遇到加号或减号时，记录当前的操作符，遇到其他字符时忽略；</li><li>当遇到表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，并返回最终结果。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int calculate(string s) &#123;        stack&lt;int&gt; st;  &#x2F;&#x2F; 定义一个辅助栈，用于存储之前的操作符和数字        int num &#x3D; 0;  &#x2F;&#x2F; 用于记录当前的数值        int res &#x3D; 0;  &#x2F;&#x2F; 用于记录最终结果        int sign &#x3D; 1;  &#x2F;&#x2F; 用于记录当前的操作符，1表示加号，-1表示减号        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            if (isdigit(s[i])) &#123;  &#x2F;&#x2F; 如果当前字符是数字                num &#x3D; num * 10 + (s[i] - &#39;0&#39;);  &#x2F;&#x2F; 记录当前的数值            &#125; else if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;  &#x2F;&#x2F; 如果当前字符是左括号                int j &#x3D; i, cnt &#x3D; 0;                for (; i &lt; s.size(); i++) &#123;                    if (s[i] &#x3D;&#x3D; &#39;(&#39;) cnt++;                    if (s[i] &#x3D;&#x3D; &#39;)&#39;) cnt--;                    if (cnt &#x3D;&#x3D; 0) break;                &#125;                num &#x3D; calculate(s.substr(j + 1, i - j - 1));  &#x2F;&#x2F; 递归调用自身计算括号内的表达式值            &#125;            if (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;  &#x2F;&#x2F; 如果当前字符是加号或减号，或者已经遍历到表达式字符串的末尾                if (s[i] &#x3D;&#x3D; &#39;+&#39;) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中                    sign &#x3D; 1;  &#x2F;&#x2F; 更新操作符为加号                &#125; else if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中                    sign &#x3D; -1;  &#x2F;&#x2F; 更新操作符为减号                &#125; else if (s[i] &#x3D;&#x3D; &#39;)&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将最后一个数值乘上当前的操作符，并压入栈中                    int tmp &#x3D; 0;                    while (!st.empty()) &#123;  &#x2F;&#x2F; 从栈中取出数字和操作符进行计算，直到栈为空                        tmp +&#x3D; st.top();                        st.pop();                    &#125;                    res &#x3D; tmp;  &#x2F;&#x2F; 更新最终结果                &#125;                num &#x3D; 0;  &#x2F;&#x2F; 清空当前的数值            &#125;        &#125;        return res;  &#x2F;&#x2F; 返回最终结果    &#125;&#125;;</code></pre><blockquote><p>上述代码使用了一个栈来存储之前的数字和操作符，用于最后的计算。遇到左括号时，递归调用自身计算括号内的表达式值。遇到加号或减号时，记录当前的操作符和数字，当遇到右括号或表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，得到最终结果。</p></blockquote><p>需要注意的是，在遇到左括号时，需要找到对应的右括号位置，才能正确地计算括号内的表达式值。这里使用了一个变量cnt来记录遍历到的左括号数量和右括号数量的差值，当cnt为0时，说明找到了对应的右括号。</p><p>另外，需要注意的是，当遍历到表达式字符串的末尾时，也需要将之前记录的数字和操作符进行计算，得到最终结果。因此，在遍历完表达式字符串后，还需要进行一次栈中剩余数字和操作符的计算，以得到最终结果。</p><p>最后，需要注意对于操作数可能有多个位数的情况，需要在遍历字符串时将多位数字组合成一个完整的数值。这里使用了一个变量num来记录当前的数值，每次遍历到数字时，将其乘以10并加上当前位的数值即可。</p><p>综上所述，上述代码实现了一个简单的基本计算器，可以计算表达式中的加减法和括号，并返回最终结果。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串表达式 &lt;code&gt;s&lt;/code&gt; ，请你实现一个基本计算器来计算并返回它的值。&lt;/p&gt;
&lt;p&gt;注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 &lt;code&gt;eval()&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>WorkflowSim工作流仿真软件介绍+类的介绍+自创算法实现步骤</title>
    <link href="2023/04/19/WorkflowSim%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D-%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D-%E8%87%AA%E5%88%9B%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/"/>
    <id>2023/04/19/WorkflowSim%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D-%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D-%E8%87%AA%E5%88%9B%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/</id>
    <published>2023-04-19T08:00:38.000Z</published>
    <updated>2023-04-19T13:05:55.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intorduction"><a href="#Intorduction" class="headerlink" title="Intorduction"></a>Intorduction</h2><p>现在的大数据应用都非常复杂，并不仅仅能够通过一个或者几个MapReduce任务来描述。更加复杂的描述大数据应用的是工作流 (workflow)。</p><p>WorkflowSim (<a href="http://www.workflowsim.org/)%E6%98%AF%E7%94%B1%E5%8D%97%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%A6">http://www.workflowsim.org/)是由南加州大学</a>(University of Southern California)的Weiwei Chen开发的一套开源工作流仿真软件。WorkflowSim是拓展自CloudSim的工作流仿真开源软件，可以提供工作流基础上的仿真，增加了模拟不同层次延时和故障的支持，与真实分布式环境更加接近。支持了各种task scheduling, clustering, resource provisioning的算法。广泛应用在故障容错研究，成本导向调度研究，资源调度研究，能耗研究等领域。</p><span id="more"></span><p>其工作原理是在暨有的CloudSim仿真软件基础上，提供workflow层次的仿真。工作流可以用有向图来描述(Directed Acyclic Graph) DAG，图的任何一个节点都是一个由用户制定执行的任务(task)，节点之间有通过数据输入输出形成的依赖关系(dependency)。工作流引擎会依据其依赖关系按顺序执行，同时执行也会调用用户所选择的调度算法，比如HEFT，MINMIN等等算法已经在WorkflowSim里边实现并且测试通过了。</p><p>用户也可以添加自己的调度算法。</p><p>在实际运行过程中，因为很多工作流非常大，甚至到达几千上万个任务，而通常我们只有几十个计算节点。这个时候就需要使用task clustering这个技术来聚合相类似的任务从而形成任务群(clustered job)，有时候也通用称之为job。每个job包含了多个task，然后提交给运行环境的时候是整体提交的，这样可以节省很多延迟(submission delay)，等到了某一个计算节点的时候再打开任务群然后分别执行。</p><p>如何形成job就需要各种算法，有包括了balanced task clustering可以综合考虑依赖关系的，也有fault tolerant clustering可以综合考虑规避failure的。这些也都已经在WorkflowSim里边实现。</p><p>其行为最为接近Pegasus工作流管理系统。</p><p>WorkflowSim是一套开源软件，所有源代码和介绍都可以在<a href="http://www.github.com/WorkflowSim/%E6%89%BE%E5%88%B0%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9B%AE%E5%89%8D%E6%B5%81%E8%A1%8C%E7%9A%84Git%E5%81%9A%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E3%80%82">http://www.github.com/WorkflowSim/找到，使用目前流行的Git做软件版本控制。</a></p><p>使用非常简单，下载完源代码之后，只需要在任何一个WorkflowSim example里边选择所需要的dax 文档，并且修改里边的daxPath变量，即可运行。比如选择:“examples&#x2F;org&#x2F;workflowsim&#x2F;examples&#x2F;WorkflowSimBasicExample1.java”这个例子，将里边的daxPath改成在你当前环境下的文件路径即可。</p><p>WorkflowSim在config&#x2F;dax文件夹下面已经提供了很多DAX文件可供仿真。这些工作流的介绍可以参考：Documentation – Pegasus WMS</p><p>同时我们还提供WorkflowGenerator可以生成你所需要的任何工作流DAX文件<a href="https://confluence.pegasus.isi.edu/display/pegasus/WorkflowGenerator">https://confluence.pegasus.isi.edu/display/pegasus/WorkflowGenerator</a></p><p>如果对WorkflowSim感兴趣并且想进一步开发功能，可建议（但不限于）研究以下方面</p><ol><li><p>基于价格的调度算法，CloudSim本身已经实现了每个task的cost，但是WorkflowSim还没有合适的调度算法。</p></li><li><p>动态资源调度算法。WorkflowSim目前还是静态的把计算节点建立好然后运行工作流。</p></li><li><p>多数据中心支持。目前只测试了单数据中心支持。</p></li><li><p>数据日志支持。将已有的工作流管理系统的log转换成为trace从而可以在WorkflowSim里边仿真？目前只测试过Pegasus。</p></li><li><p>可靠的调度算法，在仿真Failure的情况下调度算法应该如何变得更鲁棒？目前failure的生成已经开发完成，但是相应的算法还没有。</p></li><li><p>自适应算法或者分布式算法。目前仅有一个中心调度算法，分布式算法也可以在WorkflowSim上面实现。</p></li><li><p>基于duplication的算法。在计算节点有余的时候，可以自动复制一部分任务到空闲的计算节点上。</p></li></ol><h3 id="WorkflowSim中调度算法与规划算法的区别"><a href="#WorkflowSim中调度算法与规划算法的区别" class="headerlink" title="WorkflowSim中调度算法与规划算法的区别"></a>WorkflowSim中调度算法与规划算法的区别</h3><p>WorkflowSim中有两种类型的算法：调度算法（Scheduling Algorithm）和计划算法（Planning Algorithm）。理论上它们是相同的，但是在实现方面它们是完全不同的。WorkflowSim 具有三层：Workflow Planner、Workflow Engine、Workflow Scheduler。</p><p>在 Workflow Planner 中，我们拥有整个工作流（所有任务及其依赖项）的全局视图，并且在每次迭代中，Workflow Engine 将free的任务（这意味着它们的父级已成功完成）发布到 Workflow Scheduler。Workflow Scheduler 将这些free的任务与资源（WorkflowSim 中的 Condor VM）进行匹配，并提交它们以供执行。分别来说，规划算法是一种全局调度算法，可以将任何任务绑定到任何资源（但实际执行顺序取决于资源可用性）。WorkflowSim 中的调度算法是一种本地调度算法，它只将空闲任务绑定到可用资源（并以某种方式保证它们的执行顺序）。</p><p>默认情况下，未设置规划算法。如果您已指定规划算法，则调度算法将被禁用，因为指定的规划算法强制工作流调度程序将任务映射到其分配的资源。</p><p>一些局部优化算法如MIN-MIN、MAX-MIN是调度算法，而一些全局优化算法如HEFT是WorkflowSim中的规划算法</p><h3 id="SHARED和LOCAL文件系统之间的区别"><a href="#SHARED和LOCAL文件系统之间的区别" class="headerlink" title="SHARED和LOCAL文件系统之间的区别"></a>SHARED和LOCAL文件系统之间的区别</h3><p>SHARED文件系统只有一个用于一个数据中心的存储空间，而LOCAL文件系统也有一个用于每个VM的本地文件系统。</p><p>对于 stage-in，在 SHARED 模式下，我们在stage-in作业开始时将所有的输入文件移动到共享存储中。在 LOCAL 模式下，我们将每个任务的输入文件从最近的 VM（因为 VM 也具有本地文件系统）或共享文件系统（如果该任务分配到的 VM 可用）移动。</p><p>对于数据传输成本，在 SHARED 模式下，数据传输成本已经计入任务执行时间，因此我们不计算每个作业的数据传输成本。但我们计算了初始阶段工作的成本。在 LOCAL 模式下，增加每个作业的数据传输成本。</p><p>为什么我们需要区分它们？在实践中，我们要么拥有一个共享文件系统，例如 NFS，要么拥有一个分布式系统，例如 HDFS。如果您有一些数据感知算法来提高数据局部性，则需要使用 LOCAL。否则，如果您的算法不考虑数据，您可以使用 SHARED fs 来简化建模。</p><h3 id="Task-和-Job-之间的区别（以及任务集群）"><a href="#Task-和-Job-之间的区别（以及任务集群）" class="headerlink" title="Task 和 Job 之间的区别（以及任务集群）"></a>Task 和 Job 之间的区别（以及任务集群）</h3><p>尽管在某些情况下我们可以互换使用Task和Job，但它们是完全不同的。任Task是用户指定运行的程序。它对应于 DAX 中的“job”，因为 DAX 是由用户创建的。WorkflowSim 中的Job是包含一个或多个Task的单个执行单元。但是，WorkflowSim 中的Job本身是从Task延伸扩展的，目的是简化一些代码。</p><p>任务聚类是一种将多个Task合并为一个Job的优化方法。根据不同的优化目的，我们最终可能会得到容错集群（最小化故障影响）、平衡任务集群（平衡数据传输成本和通信成本）等。</p><p>为什么任务集群即使它失去了一些并行性，也可以减少makespan？</p><p>任务集群只能在资源争用的情况下工作，这意味着我们没有足够的资源，必须将任务合并到任务中。例如，Montage工作流在每个级别最多可以有10,000个任务，而通常在一个小型数据集群中有20个节点。通过将这些任务合并为20或40个作业，我们仍然可以充分利用资源并提高整体运行时间。另一个重要问题是开销，作业提交、作业执行、作业准备都具有在现代分布式系统中非常重要的开销。单独执行10,000个任务最终可能会产生10,000倍的开销，而20个作业有20倍的开销。</p><p>有关任务聚类的好处的更多详细信息，请参阅任何任务聚类论文。</p><h3 id="如何在类中增加属性？"><a href="#如何在类中增加属性？" class="headerlink" title="如何在类中增加属性？"></a>如何在类中增加属性？</h3><p>如果你有一个新的属性要在WorkflowSim中使用，并且想要在配置文件中配置它，可以进行下面的几个步骤:</p><ol><li>假设我们想要添加一个工作流的截止日期，并且它是一个很长的变量。在org.workflowsim.utils.Parameters.java中，添加:</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> deadline<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">long</span> dl<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">//other parameters</span> deadline <span class="token operator">=</span> dl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> deadline<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><blockquote><p><em>因为<strong>Parameters</strong>是一个静态对象，通过这种方式，我们可以在任何地方访问<strong>deadline</strong>。</em></p></blockquote><ol start="2"><li><p><em>在<strong>org.workflowsim.utils.ArgumentParser.java</strong>中添加解析</em></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArgumentParser</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//other parameter parsing</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"deadline"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> deadline <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token class-name">Parameters</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> deadline<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre></li></ol><blockquote><p><em>这意味着我们在解析配置文件时设置了参数的截止日期。</em></p></blockquote><ol start="3"><li><em>在<strong>config.txt</strong>中添加截止日期</em></li></ol><p>在<em>config.txt**文件中添加：</em></p><pre class="language-java" data-language="java"><code class="language-java">deadline <span class="token operator">=</span> <span class="token number">10000</span></code></pre><ol start="4"><li><em>然后你可以在你的调度程序中得到截止日期，比如在<strong>RandomPlanner.java</strong>中：</em></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token class-name">Parameters</span><span class="token punctuation">.</span><span class="token function">getDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="类的介绍"><a href="#类的介绍" class="headerlink" title="类的介绍"></a>类的介绍</h2><h3 id="Cloudlet"><a href="#Cloudlet" class="headerlink" title="Cloudlet"></a>Cloudlet</h3><p>Cloudlet类对托管在云数据中心的容器中的应用程序进行建模。Cloudlet继承了CloudSim软件包中的功能。包括用户id，任务的大小，传入文件的大小。传出文件的大小，执行开始时间，完成时间和执行状态（CREATED，READY，QUEUED,CANCEL,PAUSED ,FAILED,SUCCESS和RESUMED等）等。详情见“sources\org\cloudbus\cloudsim\Cloudlet.java”。</p><p>Cloudlet类中包含一个静态内部类：Resource，它被用来跟踪Cloudlet在不同CloudResource中的移动。记录Cloudlet在一个CloudResource中的提交时间、等待时间、时间运行时间、成本等信息。</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Task类是CloudSim中Cloudlet类的一个扩展。它支持实现任务之间的依赖关系，其中包括一组父任务和一组其子任务。在WorkflowSim中，当所有的父任务都成功完成时，工作流引擎确保任务被释放到调度器(准备运行)。</p><p>相比Cloudlet类，Task新增了parentList，childList，taskFinishTime等属性。其中增加taskFinishTime是因为cloudlet不允许WorkflowSim更新任务的finish time。Task类中的getProcessingCost()方法用来获取处理或执行此任务的总成本。原始的Processing Cost &#x3D; input data transfer + processing cost + output transfer cost</p><p>【可根据需要进行修改】。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job是Task的扩展。它基本上是一组任务。在WorkflowSim中，ClusteringEngine将任务合并为任务(任务组)，并且job的总体运行时间是task运行时间的总和。</p><h3 id="Vm"><a href="#Vm" class="headerlink" title="Vm"></a>Vm</h3><p>Vm 类对VM进行建模。虚拟机由主机管理和托管，它运行在一个主机内，与其他虚拟机共享hostList。VM的属性有内存，处理器及其存储大小。它根据CloudletScheduler定义的策略处理cloudlet。每个虚拟机都有一个所有者，由所有者将cloudlet提交给要执行的虚拟机。</p><h3 id="CondorVM"><a href="#CondorVM" class="headerlink" title="CondorVM"></a>CondorVM</h3><p>Condor Vm扩展一个Vm，不同的是它有一个本地存储系统和一个状态来指示它是否忙碌：VM_STATUS_IDLE or VM_STATUS_READY (not used in workflowsim) or VM_STATUS_BUSY。</p><h3 id="FileItem"><a href="#FileItem" class="headerlink" title="FileItem"></a>FileItem</h3><p>这是WorkflowSim中的一个文件实现。由于CloudSim已经实现了File，我们在这里称之为FileItem。WorkflowSim有一个不同的文件视图。案例1:在org.cloudsim.File中，文件大小是integer类型，而在我们的例子中，它应该是double类型，因为我们有很多大的文件。此外，我们希望精确地估计传输延迟。案例2:我们指定与CloudSim中不同的文件的类型FileType (NONE，输入INPUT，输出OUTPUT)。</p><p>FileItem类中的isRealInputFile()方法，用于判断文件是否为输入文件。输入文件对应有一个输出文件，它不需要在工作流中阶段加入，我们有一个规则，一个文件只写一次，并多次读取，因此，如果一个文件是一个输出文件，这意味着它是在这个作业中生成的，然后由同一作业(或者其他作业)中的另一个任务使用。</p><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>Parameters类包含用户可以在配置文件中指定的大多数参数。</p><p>类中定义了调度算法、规划算法、文件类型、成本模型等枚举类型，以及虚拟机个数、调度算法、规划算法、成本模型、最大深度等属性。</p><h3 id="Datacenter"><a href="#Datacenter" class="headerlink" title="Datacenter"></a>Datacenter</h3><p>DataCenter类代表数据中心，提供虚拟化的网格资源，处理虚拟机信息的查询，包含虚拟机对资源的分配策略。数据中心类是一个CloudResource，它的主机列表是虚拟化的。它处理VM查询(即VM处理)，而不是处理与cloudlet相关的查询。即使一个分配策略将被实例化(在超类的init()方法中)，它也不会被使用，因为cloudlets的处理由CloudletScheduler处理，虚拟机的处理由VmAllocationPolicy处理。</p><p>类中包含DatacenterCharacteristics属性，DatacenterCharacteristics表示资源的静态属性，如资源架构、操作系统(OS)、管理策略(时间或空间共享)、成本和资源配置中所处的时区。</p><h3 id="WorkflowDatacenter"><a href="#WorkflowDatacenter" class="headerlink" title="WorkflowDatacenter"></a>WorkflowDatacenter</h3><p>WorkflowDatacenter扩展了Datacenter，这样我们就可以使用CondorVM和其他组件。</p><p>类中包含processCloudletSubmit()方法，它处理Cloudlet提交。cloudlet实际可以被cast到org.workflowsim.Job 。</p><p>updateTaskExecTime()方法更新job中的task的执行时间与完成时间。</p><p>stageInFile2FileSystem()方法，将处于stage-in 阶段的job所需文件加入存储。对于本地文件系统(如condor-io)，将文件添加到本地存储；对于共享文件系统(如NFS)，需要向共享存储添加文件。</p><p>processDataStageInForComputeJob()方法，返回job执行所需的文件传输时间个执行时间。</p><h3 id="WorkflowParser"><a href="#WorkflowParser" class="headerlink" title="WorkflowParser"></a>WorkflowParser</h3><p>WorkflowParser将DAX解析为任务，以便WorkflowSim可以管理它们。</p><p>DAX的文件格式如下：</p><p><img src="http://cdn.leafii.top/img/1f7d9ac573959e92928a9529130d523c.png" alt="img" loading="lazy"></p><p>类中的parseXmlFile(String path)方法，根据参数DAX文件的地址path，将其转换为工作流。它遍历整个dax文件，将所有的<code>&lt;job&gt;&lt;/job&gt;</code>标签，转换为工作流中的任务task，其中id是该任务的唯一标识；runtime为该任务的长度；其内部的<code>&lt;uses&gt;&lt;/uses&gt;</code>标签代表该任务的文件。link属性表示文件的种类（input输入文件或output输出文件）；size属性代表该文件的大小；其中file属性代表该文件的名字。【任务A的output输出文件名file和大小size需要与其对应的任务B的input输入文件名和大小相同！】</p><p><code>&lt;child&gt;&lt;parent&gt;&lt;/parent&gt;&lt;/child&gt;</code>标签表示任务之间的依赖关系，即某一个子任务child的父任务parent有哪些。其中ref属性的值对应<code>&lt;job&gt;</code>标签中的id属性。parseXmlFile()方法根据这些依赖关系，设置工作流中的某一个任务的子任务与父任务及其深度。如果一个任务没有父任务，则将其设置为root。【root可能有多个！】</p><h3 id="SimEntity"><a href="#SimEntity" class="headerlink" title="SimEntity"></a>SimEntity</h3><p>该类表示一个模拟实体。实体可以处理事件，也可以发送事件给其他实体。当这个类被扩展时，有几个方法需要被实现:</p><p>①startEntity()：在模拟启动时，由Simulation类调用。这个方法负责启动实体。</p><p>② processEvent(SimEvent)：每当延迟队列中有需要由实体处理的事件时，仿真类就会调用processEvent(SimEvent)。</p><p>③ shutdownEntity()：在模拟结束之前，仿真调用shutdownEntity()。如果你想将数据保存在日志文件中，这个方法将放置相应的代码。</p><h3 id="WorkflowScheduler"><a href="#WorkflowScheduler" class="headerlink" title="WorkflowScheduler"></a>WorkflowScheduler</h3><p>WorkflowScheduler它隐藏了虚拟机管理，例如创建虚拟机、将任务交给虚拟机以及销毁虚拟机，并根据配置选择调度算法。</p><p>一个workflowScheduler代理中绑定一个workflowEngine，即其含有一个workflowEngineId属性，并通过bindSchedulerDatacenter(int datacenterId)方法将其与一个数据中心绑定。与此同时，为了保证每个任务仅提交一次，设置一个布尔类型的变量processCloudletSubmitHasShown来标记任务是否提交。除此之外，workflowScheduler代理根据不同的指令执行对应的事件，如下图：</p><p><img src="http://cdn.leafii.top/img/78b5a2e208681634869183a8c4c14a88.png" alt="img" loading="lazy"></p><h3 id="WorkflowEngine"><a href="#WorkflowEngine" class="headerlink" title="WorkflowEngine"></a>WorkflowEngine</h3><p>WorkflowEngine为代表用户的引擎。它隐藏了虚拟机管理，例如创建虚拟机、向虚拟机提交cloudlet和销毁虚拟机。由于WorkflowEngine类继承了SimEntity类，所以他重写了startEntity()、processEvent(SimEvent)、shutdownEntity()方法。一个workflowEngine引擎控制多个workflowScheduler代理。</p><p>hasJobListContainsID(List jobList, int id)方法：用来判断一个任务列表中是否存在某个任务。</p><p>submitJobs()方法：在提交获得的任务列表时，借助hasJobListContainsID(List jobList, int id)方法来判断某个要提交的任务的所有父任务是否已经全部执行完毕。</p><h3 id="WorkflowPlanner"><a href="#WorkflowPlanner" class="headerlink" title="WorkflowPlanner"></a>WorkflowPlanner</h3><p>WorkflowPlanner根据配置选择规划算法。他有一个ClusteringEngine属性，即一个workflowPlanner代理与一个clusteringEngine引擎绑定，并通过clusteringEngine引擎绑定到一个workflowEngine引擎中。【ClusteringEngine类是WorkflowSim的一个可选组件，它可以将多个任务合并成一个大任务，由于目前本人还没有使用到，所以暂不介绍~】</p><p>WorkflowPlanner类中的getPlanningAlgorithm(PlanningAlgorithm name)方法可以根据需要选择规划算法，<strong>一般我们在使用WorkflowSim创建自己个人的算法时，写的算法是PlanningAlgorithm类型的规划算法。</strong></p><p>workflowPlanner代理可以为任务添加影响因子，这对任务平衡的聚类算法很有用，我们可以根据研究需要，选择使用。方法为：processImpactFactors(List<Task> taskList) 与addImpact(Task task, double impact)。</p><h3 id="BaseSchedulingAlgorithm"><a href="#BaseSchedulingAlgorithm" class="headerlink" title="BaseSchedulingAlgorithm"></a>BaseSchedulingAlgorithm</h3><p>BaseSchedulingAlgorithm类继承了SchedulingAlgorithmInterface接口，它是一个基本调度器实现了基本功能。如：虚拟机的get与set，cloudlet类型的任务列表的get与set，以及主要的run()方法。其他调度方法应扩展自BaseSchedulingAlgorithm，但不应直接使用。</p><h3 id="BasePlanningAlgorithm"><a href="#BasePlanningAlgorithm" class="headerlink" title="BasePlanningAlgorithm"></a>BasePlanningAlgorithm</h3><p>BasePlanningAlgorithm类继承了PlanningAlgorithmInterface接口，它是一个基本规划器实现了基本功能。如：虚拟机的get与set，任务列表的get与set，以及主要的run()方法。其他调度方法应扩展自BasePlanningAlgorithm，但不应直接使用。</p><p>与BaseSchedulingAlgorithm<strong>不同</strong>，BasePlanningAlgorithm可以直接设置并获取Task类型的任务列表，并增加了数据中心列表DatacenterList的get与set。</p><p><strong>【我们使用WorkflowSim创建个人的算法时，需要继承BasePlanningAlgorithm类】。</strong></p><h3 id="WorkflowSimBasicExample1"><a href="#WorkflowSimBasicExample1" class="headerlink" title="WorkflowSimBasicExample1"></a>WorkflowSimBasicExample1</h3><p>由其名可知，这是一个基本的WorkflowSimExample，它创建了一个工作流规划器、一个工作流引擎、一个调度器、一个数据中心和20个虚拟机。【根据实际情况在使用时更改daxPath与其他参数】。它包含4个方法：main()方法，创建虚拟机的方法createVM()，创建数据中心的方法createDatacenter()，以及输出结果的方法printJobList()。</p><p>main()方法实现了：①初始化WorkflowSim包；②初始化Parameters参数；③初始化cloudsim包；④创建数据中心；⑤创建调度算法代理；⑥创建WorkflowEngine引擎；⑦创建工作流；⑧创建虚拟机；⑨执行调度算法，完成任务到虚拟机的映射；⑩启动仿真程序、打印仿真结果以及关闭仿真程序。</p><p>我们在写好了自己的算法后，为了实现他，则需要<strong>创建一个继承了WorkflowSimExample的example来运行算法。</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="如何创建并使用调度算法"><a href="#如何创建并使用调度算法" class="headerlink" title="如何创建并使用调度算法"></a>如何创建并使用调度算法</h3><p>当我们下载好WorkflowSim源码后，便可以实现一个自己的调度算法。具体步骤如下：</p><ol><li>在source&#x2F;org&#x2F;planning中写一个继承BasePlanningAlgorithm的Class，类名如RKPNPlanningAlgorithm,重写run()方法。【可参考HEFTPlanningAlgorithm算法】，如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/71c79ef2c2ba683cd3c80a7aa23f0dde.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/dcdd7c3c49b40442515f15fc3178b30c.png" alt="img" loading="lazy"></p><ol start="2"><li>算法写完之后，需要在WorkflowPlanner的getPlanningAlgorithm()方法中增加该算法，具体操作如下：</li></ol><p><img src="http://cdn.leafii.top/img/75501f37de1f5ed5c7679f28e655203b.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/b05b6fe6250db499ccefd05b43ec576d.png" alt="img" loading="lazy"></p><p>其中的case：RKPN中的RKPN是自定义的算法名的缩写。</p><ol start="3"><li>在参数类Parameters的枚举PlanningAlgorithm里面添加步骤2的case:RKPN，具体操作如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/b9ab51fe998664ccd21b63f0157c7230.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/f957d7ca93dbc563cf4f51141b28cb51.png" alt="img" loading="lazy"></p><ol start="4"><li>这样我们的一个调度算法就编写完了，如何使用呢？需要在”examples&#x2F;org&#x2F;workflowsim.examples&#x2F;planning”中创建一个example来实现它。具体操作如下：</li></ol><p><img src="http://cdn.leafii.top/img/4f4798e0f63054ec8c031c4a21274878.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/d2f07a1477cb395186d059fa898a3f89.png" alt="img" loading="lazy"></p><p>如图所示，在main()方法中需要根据自己的dax工作流文件的存放地址修改daxPath的值。【在“config&#x2F;dax”中也有许多可供使用的工作流文件~】</p><p><img src="http://cdn.leafii.top/img/80bc660ab00519661684d2be785cd0c0.png" alt="img" loading="lazy"></p><p>上图修改Parameters的规划算法参数，值为在步骤(3)中设置的参数</p><p>除此之外，我们也可以根据需要自行设置虚拟机的个数vmNum等其他参数。具体操作见代码。</p><ol start="5"><li>运行main()函数，即可在控制台获得工作流的运行结果。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文直接复制粘贴自：<a href="https://blog.csdn.net/LaraJean/article/details/123689433">https://blog.csdn.net/LaraJean/article/details/123689433</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Intorduction&quot;&gt;&lt;a href=&quot;#Intorduction&quot; class=&quot;headerlink&quot; title=&quot;Intorduction&quot;&gt;&lt;/a&gt;Intorduction&lt;/h2&gt;&lt;p&gt;现在的大数据应用都非常复杂，并不仅仅能够通过一个或者几个MapReduce任务来描述。更加复杂的描述大数据应用的是工作流 (workflow)。&lt;/p&gt;
&lt;p&gt;WorkflowSim (&lt;a href=&quot;http://www.workflowsim.org/)%E6%98%AF%E7%94%B1%E5%8D%97%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%A6&quot;&gt;http://www.workflowsim.org/)是由南加州大学&lt;/a&gt;(University of Southern California)的Weiwei Chen开发的一套开源工作流仿真软件。WorkflowSim是拓展自CloudSim的工作流仿真开源软件，可以提供工作流基础上的仿真，增加了模拟不同层次延时和故障的支持，与真实分布式环境更加接近。支持了各种task scheduling, clustering, resource provisioning的算法。广泛应用在故障容错研究，成本导向调度研究，资源调度研究，能耗研究等领域。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode486.预测赢家</title>
    <link href="2023/04/19/leetcode486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"/>
    <id>2023/04/19/leetcode486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</id>
    <published>2023-04-19T06:44:54.000Z</published>
    <updated>2023-04-19T07:00:57.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p><p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 <code>0</code> 。每一回合，玩家从数组的任意一端取一个数字（即，<code>nums[0]</code> 或 <code>nums[nums.length - 1]</code>），取到的数字将会从数组中移除（数组长度减 <code>1</code> ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p><p>如果玩家 1 能成为赢家，返回 <code>true</code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 <code>true</code> 。你可以假设每个玩家的玩法都会使他的分数最大化。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,5,2]输出：false解释：一开始，玩家 1 可以从 1 和 2 中进行选择。如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。因此，玩家 1 永远不会成为赢家，返回 false 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,5,233,7]输出：true解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 107</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>首先，我们可以把这个问题看成是两个玩家在一堆石头上进行取石子游戏。每个玩家都可以在任何时候从石堆中取出一些石头，但是每次取石头的数量不能超过石堆中剩余石头的数量。游戏的规则是先手玩家必须先取，然后轮流取石头，直到石堆为空。每个石头的价值都不同，每个玩家在取石头时可以获得相应的价值。</p><p>我们可以用动态规划来解决这个问题。假设nums数组的长度为n，<code>dp[i][j]</code>表示在<code>nums[i...j]</code>范围内，先手玩家能获得的最大分数，那么先手玩家最终获胜的条件是<code>dp[0][n-1]</code>不小于nums中所有数之和的一半。</p><p>接下来考虑如何计算dp数组。首先，我们可以很容易地得出当区间长度为1时，<code>dp[i][i]</code>的值就是<code>nums[i]</code>。这是因为当只有一个数时，先手玩家必定获胜，得分为该数。</p><p>接下来，我们需要考虑更长的区间。假设当前处理的区间长度为len，则可以枚举区间左端点i，然后通过递推式来计算<code>dp[i][j]</code>。对于区间<code>[i,j]</code>，先手玩家可以选择<code>i</code>或<code>j</code>作为自己的选择，那么后手玩家就会在<code>[i+1, j]</code>或<code>[i, j-1]</code>区间内变成先手玩家。这样转化后的问题就可以通过<code>dp</code>数组的计算得到解决。</p><p>具体地，假设先手玩家选择了左端点i，那么后手玩家就会在<code>[i+1, j]</code>区间内变成先手玩家，此时先手玩家能获得的最大分数就是<code>nums[i]</code>加上区间<code>[i+2,j]</code>或区间<code>[i+1,j-1]</code>内先手玩家能获得的最大分数的最小值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">left &#x3D; nums[i] + min(dp[i+2][j], dp[i+1][j-1])</code></pre><p>同样地，假设先手玩家选择了右端点<code>j</code>，那么后手玩家就会在<code>[i, j-1]</code>区间内变成先手玩家，此时先手玩家能获得的最大分数就是<code>nums[j]</code>加上区间<code>[i,j-2]</code>或区间<code>[i+1,j-1]</code>内先手玩家能获得的最大分数的最小值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">right &#x3D; nums[j] + min(dp[i][j-2], dp[i+1][j-1])</code></pre><p>由于先手玩家和后手玩家的取石头顺序是交替进行的，因此先手玩家和后手玩家在不同的区间上作为先手玩家和后手玩家的情况应该分别考虑。最终，<code>dp[i][j]</code>的值就是left和right中的较大值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">dp[i][j] &#x3D; max(left, right)</code></pre><p>最终的答案就是<code>dp[0][n-1]</code>是否大于等于<code>nums</code>中所有数之和的一半。</p><p>代码实现时，我们可以使用二维数组<code>dp</code>来保存先手玩家能获得的最大分数，然后用双重循环来枚举区间长度和区间左端点，并使用上述递推式来计算<code>dp</code>数组中的每个元素。最后，比较<code>dp[0][n-1]</code>和<code>nums</code>中所有数之和的一半即可得到答案。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); &#x2F;&#x2F; 定义二维dp数组，dp[i][j]表示当剩下的数是nums[i..j]时，先手玩家比后手玩家多得的最大分数。        &#x2F;&#x2F; 处理区间长度为1的情况        for (int i &#x3D; 0; i &lt; n; i++) &#123;            dp[i][i] &#x3D; nums[i]; &#x2F;&#x2F; 当剩下的数只有一个时，先手玩家只能取这个数，并且得分就是这个数本身。        &#125;        &#x2F;&#x2F; 处理更长的区间        for (int len &#x3D; 2; len &lt;&#x3D; n; len++) &#123; &#x2F;&#x2F; 枚举区间长度            for (int i &#x3D; 0; i &lt;&#x3D; n - len; i++) &#123; &#x2F;&#x2F; 枚举区间左端点                int j &#x3D; i + len - 1; &#x2F;&#x2F; 区间右端点                int left &#x3D; nums[i] + min(i+2 &lt;&#x3D; j ? dp[i+2][j] : 0, i+1 &lt;&#x3D; j-1 ? dp[i+1][j-1] : 0); &#x2F;&#x2F; 先手玩家取nums[i]后，后手玩家就成为了先手玩家，接下来剩下的数就是nums[i+1..j]，此时先手玩家能得到的最大分数是dp[i+1][j]。如果先手玩家取nums[i]后，后手玩家也取了一个数，那么接下来剩下的数就是nums[i+2..j]，此时先手玩家能得到的最大分数是dp[i+2][j]。由于后手玩家也是聪明的，他肯定会选择让先手玩家得到更少的分数，因此先手玩家能得到的最大分数就是nums[i]加上min(dp[i+2][j], dp[i+1][j-1])。同理，我们也可以计算出先手玩家取nums[j]时能得到的最大分数right。                int right &#x3D; nums[j] + min(i &lt;&#x3D; j-2 ? dp[i][j-2] : 0, i+1 &lt;&#x3D; j-1 ? dp[i+1][j-1] : 0);                dp[i][j] &#x3D; max(left, right); &#x2F;&#x2F; 取left和right的较大值，表示先手玩家在nums[i..j]这个区间内能得到的最大分数。            &#125;        &#125;        &#x2F;&#x2F; 判断先手玩家是否能获胜        return dp[0][n-1] &gt;&#x3D; accumulate(nums.begin(), nums.end(), 0) &#x2F; 2.0; &#x2F;&#x2F; 如果先手玩家能得到的最大分数不小于nums中所有数之和的一半，那么先手玩家就能获胜。    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。&lt;/p&gt;
&lt;p&gt;玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 &lt;code&gt;0&lt;/code&gt; 。每一回合，玩家从数组的任意一端取一个数字（即，&lt;code&gt;nums[0]&lt;/code&gt; 或 &lt;code&gt;nums[nums.length - 1]&lt;/code&gt;），取到的数字将会从数组中移除（数组长度减 &lt;code&gt;1&lt;/code&gt; ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。&lt;/p&gt;
&lt;p&gt;如果玩家 1 能成为赢家，返回 &lt;code&gt;true&lt;/code&gt; 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 &lt;code&gt;true&lt;/code&gt; 。你可以假设每个玩家的玩法都会使他的分数最大化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1823.找出游戏的获胜者</title>
    <link href="2023/04/18/leetcode1823-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/"/>
    <id>2023/04/18/leetcode1823-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/</id>
    <published>2023-04-18T03:49:15.000Z</published>
    <updated>2023-04-18T04:12:22.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 <strong>顺时针顺序</strong> 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 <code>i</code> 名小伙伴顺时针移动一位会到达第 <code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code> ，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 <code>1</code> 名小伙伴的位置。</p><p>游戏遵循如下规则：</p><ol><li>从第 <code>1</code> 名小伙伴所在位置 <strong>开始</strong> 。</li><li>沿着顺时针方向数 <code>k</code> 名小伙伴，计数时需要 <strong>包含</strong> 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 <strong>顺时针下一位</strong> 小伙伴 <strong>开始</strong>，回到步骤 <code>2</code> 继续执行。</li><li>否则，圈子中最后一名小伙伴赢得游戏。</li></ol><p>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ic234-q2-ex11.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5, k &#x3D; 2输出：3解释：游戏运行步骤如下：1) 从小伙伴 1 开始。2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 6, k &#x3D; 5输出：1解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= n &lt;= 500</code></li></ul><p><strong>进阶：</strong>你能否使用线性时间复杂度和常数空间复杂度解决此问题？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>约瑟夫问题求解</li></ul><p>首先我们需要确定递推公式，假设上一轮淘汰的是第 m 个人，那么本轮淘汰的是第 $(m+k)% n$ 个人，所以我们可以得到递推公式：$f(n, k) &#x3D; (f(n-1, k)+k) % n$，其中$ f(n, k) $表示 n 个人中最后剩下的人的编号。</p><p>当只有一个人的时候，那么这个人一定是胜者，因此我们可以得到初始值：f(1, k) &#x3D; 0。</p><p>最后，我们可以通过递推得到 f(n, k) 的值，即为最后的胜者的编号。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findTheWinner(int n, int k) &#123;        int ans &#x3D; 0;  &#x2F;&#x2F; 最后胜者的编号        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;  &#x2F;&#x2F; 从第二个人开始进行游戏            ans &#x3D; (ans + k) % i;  &#x2F;&#x2F; 计算本轮淘汰的人的编号        &#125;        return ans + 1;  &#x2F;&#x2F; 将编号从 0-based 转换为 1-based 并返回    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;共有 &lt;code&gt;n&lt;/code&gt; 名小伙伴一起做游戏。小伙伴们围成一圈，按 &lt;strong&gt;顺时针顺序&lt;/strong&gt; 从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 编号。确切地说，从第 &lt;code&gt;i&lt;/code&gt; 名小伙伴顺时针移动一位会到达第 &lt;code&gt;(i+1)&lt;/code&gt; 名小伙伴的位置，其中 &lt;code&gt;1 &amp;lt;= i &amp;lt; n&lt;/code&gt; ，从第 &lt;code&gt;n&lt;/code&gt; 名小伙伴顺时针移动一位会回到第 &lt;code&gt;1&lt;/code&gt; 名小伙伴的位置。&lt;/p&gt;
&lt;p&gt;游戏遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第 &lt;code&gt;1&lt;/code&gt; 名小伙伴所在位置 &lt;strong&gt;开始&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;沿着顺时针方向数 &lt;code&gt;k&lt;/code&gt; 名小伙伴，计数时需要 &lt;strong&gt;包含&lt;/strong&gt; 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。&lt;/li&gt;
&lt;li&gt;你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。&lt;/li&gt;
&lt;li&gt;如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 &lt;strong&gt;顺时针下一位&lt;/strong&gt; 小伙伴 &lt;strong&gt;开始&lt;/strong&gt;，回到步骤 &lt;code&gt;2&lt;/code&gt; 继续执行。&lt;/li&gt;
&lt;li&gt;否则，圈子中最后一名小伙伴赢得游戏。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给你参与游戏的小伙伴总数 &lt;code&gt;n&lt;/code&gt; ，和一个整数 &lt;code&gt;k&lt;/code&gt; ，返回游戏的获胜者。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode231.2的幂</title>
    <link href="2023/04/17/leetcode231-2%E7%9A%84%E5%B9%82/"/>
    <id>2023/04/17/leetcode231-2%E7%9A%84%E5%B9%82/</id>
    <published>2023-04-17T01:09:01.000Z</published>
    <updated>2023-04-17T01:33:35.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>x</code> 使得 $n &#x3D;&#x3D; 2^x$ ，则认为 <code>n</code> 是 2 的幂次方。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：true解释：20 &#x3D; 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 16输出：true解释：24 &#x3D; 16</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：false</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：true</code></pre><p><strong>示例 5：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：false</code></pre><p><strong>提示：</strong></p><ul><li>$-2{31} &lt;&#x3D; n &lt;&#x3D; 2^{31} - 1$</li></ul><p><strong>进阶：</strong>你能够不使用循环&#x2F;递归解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归</li></ol><p>直接递归就好，注意n为0的情况</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        if (n &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; 如果n为1 直接返回true        if (n % 2 !&#x3D; 0 || n &#x3D;&#x3D; 0) return false; &#x2F;&#x2F; 如果n无法被2除尽，或者n为0，则直接返回false        return isPowerOfTwo(n &#x2F; 2); &#x2F;&#x2F; 否则返回递归的调用函数后的返回值    &#125;&#125;;</code></pre><ol start="2"><li>循环</li></ol><p>直接循环就行，简单易懂</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        while (n &gt;&#x3D; 2) &#123;            if (n % 2 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 2;            else return false; &#x2F;&#x2F; 如果n无法被2除尽，则直接返回false        &#125;        if (n &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; 如果n为1 直接返回true        return false;    &#125;&#125;;</code></pre><ol start="3"><li>使用位与运算符和掩码</li></ol><p>在这个题里面只需要检测n为正数且n的二进制里面只有一个1存在即可;</p><p>首先，我们检查n是否为正整数，这可以通过检查n是否大于0来实现。然后，我们需要检查n的二进制表示中只有一个1。如果我们将n减去1，那么所有在原来的二进制表示中为1的位都会变成0，而它后面的所有位都会变成1。例如，如果n的二进制表示为10000，那么n-1的二进制表示为01111。如果我们将n和n-1进行位与运算，结果将为0。因为n的二进制表示中只有一个1，所以n-1的二进制表示中所有的1都位于n的二进制表示中的0的位置上，因此它们不会在位与运算中重叠。如果n的二进制表示中有多个1，则n-1的二进制表示中将有一个以上的1与n的二进制表示中的1重叠，这样位与运算的结果将不为0。</p><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        return ((n &gt; 0) &amp;&amp; (n &amp; (n - 1)) &#x3D;&#x3D; 0); &#x2F;&#x2F; 检查n是否为正数，且n的二进制表示只有一个1    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;，请你判断该整数是否是 2 的幂次方。如果是，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果存在一个整数 &lt;code&gt;x&lt;/code&gt; 使得 $n &amp;#x3D;&amp;#x3D; 2^x$ ，则认为 &lt;code&gt;n&lt;/code&gt; 是 2 的幂次方。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode342.4的幂</title>
    <link href="2023/04/16/leetcode342-4%E7%9A%84%E5%B9%82/"/>
    <id>2023/04/16/leetcode342-4%E7%9A%84%E5%B9%82/</id>
    <published>2023-04-16T07:35:33.000Z</published>
    <updated>2023-04-17T01:29:58.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 4 的幂次方需满足：存在整数 <code>x</code> 使得 $n &#x3D;&#x3D; 4^x$</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 16输出：true</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：true</code></pre><p><strong>提示：</strong></p><ul><li>$-2^{31} &lt;&#x3D; n &lt;&#x3D; 2^{31} - 1$</li></ul><p><strong>进阶：</strong>你能不使用循环或者递归来完成本题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>循环</li></ol><p>直接使用循环进行<code>n/=4</code>的操作,到最后n小于3时根据n是否为1来判断原本的n是否为4的幂次</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfFour(int n) &#123;        while(n &gt; 3) &#123;            if (n % 4 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 判断n是否是4的整倍数 （在n大于3的情况下）                n &#x2F;&#x3D; 4;            &#125;            else return false; &#x2F;&#x2F; 如果不是直接返回false        &#125;        if (n &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; &#x2F;&#x3D;操作结束后判断n是否为1 or n本来就为1的时候应该直接返回true        return false;    &#125;&#125;;</code></pre><ol start="2"><li>递归</li></ol><p>如题，直接递归就完事了</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfFour(int n) &#123;        if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 4) return true; &#x2F;&#x2F; 返回true的条件        else if (n &gt; 4) &#123;            if (n % 4 !&#x3D; 0) return false; &#x2F;&#x2F; 余数不为0 直接返回false            else return isPowerOfFour(n &#x2F; 4); &#x2F;&#x2F; 通过递归完成对n的更新        &#125;        return false;     &#125;&#125;;</code></pre><ol start="3"><li>使用位与运算符和掩码</li></ol><p>首先，我们需要检查n是否为正数，并且它的二进制表示中只有一个1。这是因为4的幂次方的二进制表示中只有一个1。因此，如果n不是正数或者它的二进制表示中有多个1，则它不是4的幂。</p><p>其次，我们需要使用位运算来检查n是否为4的幂。我们可以使用位与运算符（&amp;）和一个掩码来完成此操作。掩码是一个32位整数，它的二进制表示中只有偶数位为1，奇数位为0。如果n是4的幂，则它的二进制表示中的1只能在偶数位上出现。因此，如果我们将n与掩码进行位与运算，结果应该等于n本身。</p><p>最终，如果n既是正数且只有一个1，又是4的幂，则函数返回true；否则，返回false。</p><p>详细的说，当你看到一个整数n时，你需要确定它是否是4的幂次方。一个正整数n是4的幂次方，当且仅当它满足以下两个条件：</p><ol><li>n是正整数，并且它的二进制表示中只有一个1，例如1、4、16等；</li><li>n可以表示为$4^k$的形式，其中k是一个非负整数。</li></ol><p>因此，我们需要找到一种方法来检查n是否满足这两个条件。在不使用循环或递归的前提下，我们可以使用位运算来实现这个目标。</p><p>首先，我们检查n是否为正整数，这可以通过检查n是否大于0来实现。然后，我们需要检查n的二进制表示中只有一个1。如果我们将n减去1，那么所有在原来的二进制表示中为1的位都会变成0，而它后面的所有位都会变成1。例如，如果n的二进制表示为10000，那么n-1的二进制表示为01111。如果我们将n和n-1进行位与运算，结果将为0。因为n的二进制表示中只有一个1，所以n-1的二进制表示中所有的1都位于n的二进制表示中的0的位置上，因此它们不会在位与运算中重叠。如果n的二进制表示中有多个1，则n-1的二进制表示中将有一个以上的1与n的二进制表示中的1重叠，这样位与运算的结果将不为0。</p><p>接下来，我们需要使用位运算来检查n是否可以表示为4的幂。我们知道，4的幂的二进制表示中的1只能出现在偶数位上，例如100、10000、1000000等。因此，我们可以使用一个掩码来将所有奇数位上的位设置为0，而偶数位上的位设置为1。这个掩码可以是0x55555555，它的二进制表示为01010101010101010101010101010101。如果我们将n与这个掩码进行位与运算，结果将为n本身，如果n不能表示为4的幂，则结果将不为n本身。</p><p>最后，如果n既是正整数且只有一个1，又是4的幂，则函数返回true，否则返回false。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfFour(int n) &#123;        &#x2F;&#x2F; 检查n是否为正数，且n的二进制表示只有一个1，且n是否为4的幂        return (n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) &#x3D;&#x3D; 0) &amp;&amp; ((n &amp; 0x55555555) &#x3D;&#x3D; n);     &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;整数 &lt;code&gt;n&lt;/code&gt; 是 4 的幂次方需满足：存在整数 &lt;code&gt;x&lt;/code&gt; 使得 $n &amp;#x3D;&amp;#x3D; 4^x$&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode72.编辑距离</title>
    <link href="2023/04/13/leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>2023/04/13/leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2023-04-13T12:06:19.000Z</published>
    <updated>2023-04-13T12:19:59.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这道题要求我们找到从 word1 转换到 word2 所需要的最小操作数，其中每个操作都是插入、删除或替换一个字符。这道题可以使用动态规划来解决。我们可以定义一个 dp 数组，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数。</p><p>当 i &#x3D; 0 时，表示 word1 为空，这时要将 word1 转换为 word2 的前 j 个字符，所以最小操作数就是 j。同样地，当 j &#x3D; 0 时，表示 word2 为空，这时要将 word1 转换为空字符串，所以最小操作数就是 i。</p><p>对于任意的 i 和 j，有以下两种情况：</p><ol><li>当 <code>word1[i-1] == word2[j-1] </code>时，不需要进行任何操作，所以 <code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>当 <code>word1[i-1] != word2[j-1] </code>时，有三种操作可以选择，分别为：<ol><li>在 word1 的第 i 个字符后面插入一个和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i][j-1] + 1</code>。</li><li>删除 word1 的第 i 个字符，这样就可以让 word1 的前 i-1 个字符和 word2 的前 j 个字符相等。操作数为<code> dp[i-1][j] + 1</code>。</li><li>将 word1 的第 i 个字符替换成和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i-1][j-1] + 1</code>。</li></ol></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minDistance(string word1, string word2) &#123;        int m &#x3D; word1.size();  &#x2F;&#x2F; 获取 word1 的长度        int n &#x3D; word2.size();  &#x2F;&#x2F; 获取 word2 的长度        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1));  &#x2F;&#x2F; 定义一个二维数组 dp，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 当 word2 为空字符串时，需要将 word1 转换为空字符串，所以最小操作数为 i            dp[i][0] &#x3D; i;        &#125;        for (int j &#x3D; 0; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 当 word1 为空字符串时，需要将 word1 转换为 word2 的前 j 个字符，所以最小操作数为 j            dp[0][j] &#x3D; j;        &#125;        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 从 word1 的第一个字符开始遍历            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 从 word2 的第一个字符开始遍历                if (word1[i-1] &#x3D;&#x3D; word2[j-1]) &#123;  &#x2F;&#x2F; 如果 word1 的第 i 个字符和 word2 的第 j 个字符相等，不需要进行任何操作                    dp[i][j] &#x3D; dp[i-1][j-1];                &#125; else &#123;  &#x2F;&#x2F; 否则，有三种操作可以选择                    dp[i][j] &#x3D; min(dp[i][j-1], min(dp[i-1][j], dp[i-1][j-1])) + 1;  &#x2F;&#x2F; 分别为插入、删除和替换一个字符，选择操作数最小的那个                &#125;            &#125;        &#125;        return dp[m][n];  &#x2F;&#x2F; 返回最小操作数    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个单词 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt;， &lt;em&gt;请返回将 &lt;code&gt;word1&lt;/code&gt; 转换成 &lt;code&gt;word2&lt;/code&gt; 所使用的最少操作数&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入一个字符&lt;/li&gt;
&lt;li&gt;删除一个字符&lt;/li&gt;
&lt;li&gt;替换一个字符&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode63.不同路径II</title>
    <link href="2023/04/12/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>2023/04/12/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</id>
    <published>2023-04-12T01:18:23.000Z</published>
    <updated>2023-04-12T01:21:48.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/robot1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/robot2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：obstacleGrid &#x3D; [[0,1],[0,0]]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道典型的动态规划问题。定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p><p>在定义dp数组时，需要特别注意：如果某个格子为障碍物，则不能通过该格子，路径数为0；如果第一列某个格子为障碍物，则其下方的所有格子均无法到达，路径数为0；如果第一行某个格子为障碍物，则其右方的所有格子均无法到达，路径数为0。</p><p>在状态转移方程中，如果某个格子为障碍物，则其路径数为0；否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p><p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int m &#x3D; obstacleGrid.size();        int n &#x3D; obstacleGrid[0].size();        &#x2F;&#x2F; 定义二维数组dp        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));        &#x2F;&#x2F; 初始化第一列        for (int i &#x3D; 0; i &lt; m; i++) &#123;            if (obstacleGrid[i][0] &#x3D;&#x3D; 1) &#123;                break;            &#125;            dp[i][0] &#x3D; 1;        &#125;        &#x2F;&#x2F; 初始化第一行        for (int j &#x3D; 0; j &lt; n; j++) &#123;            if (obstacleGrid[0][j] &#x3D;&#x3D; 1) &#123;                break;            &#125;            dp[0][j] &#x3D; 1;        &#125;        &#x2F;&#x2F; 对于其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和        for (int i &#x3D; 1; i &lt; m; i++) &#123;            for (int j &#x3D; 1; j &lt; n; j++) &#123;                if (obstacleGrid[i][j] &#x3D;&#x3D; 1) &#123;  &#x2F;&#x2F; 如果当前格子为障碍物，则不可到达，路径数为0                    dp[i][j] &#x3D; 0;                &#125; else &#123;  &#x2F;&#x2F; 否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达                    dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];                &#125;            &#125;        &#125;        &#x2F;&#x2F; 返回右下角格子的不同路径数目        return dp[m-1][n-1];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;网格中的障碍物和空位置分别用 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt; 来表示。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode62.不同路径</title>
    <link href="2023/04/12/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>2023/04/12/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2023-04-12T00:57:03.000Z</published>
    <updated>2023-04-12T01:21:20.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/robot_maze.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 7输出：28</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 7, n &#x3D; 3输出：28</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 3输出：6</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道比较典型的动态规划问题。我们定义一个二维数组<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p><p>根据题目要求，从第一行第一列出发只能向下或向右移动一步，因此<code>dp[0][j]</code>和<code>dp[i][0]</code>的值都为1。</p><p>对于其他的格子，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p><p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        &#x2F;&#x2F; 定义二维数组dp        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));        &#x2F;&#x2F; 对于除第一行第一列外的其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和        for (int i &#x3D; 1; i &lt; m; i++) &#123;            for (int j &#x3D; 1; j &lt; n; j++) &#123;                dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];            &#125;        &#125;        &#x2F;&#x2F; 返回右下角格子的不同路径数目        return dp[m-1][n-1];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode746.使用最小花费爬楼梯</title>
    <link href="2023/04/10/leetcode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>2023/04/10/leetcode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2023-04-10T07:44:23.000Z</published>
    <updated>2023-04-10T07:57:11.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：cost &#x3D; [10,15,20]输出：15解释：你将从下标为 1 的台阶开始。- 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：cost &#x3D; [1,100,1,1,1,100,1,1,100,1]输出：6解释：你将从下标为 0 的台阶开始。- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。- 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>因为上台阶可以一次1阶或者一次2阶，因此定义一个dp数组，长度为cost的大小+1，dp[i]表示到达第n个台阶需要的最小费用。因此<code>dp[i]</code>的更新公式为:</p><p>$dp[i] &#x3D; min(dp[i-1] + cost[i - 1], dp[i - 2] + cost[i - 2])$</p><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;        int len &#x3D; cost.size(); &#x2F;&#x2F; 获取cost的大小（总的台阶数）        vector&lt;int&gt; dp(len + 1); &#x2F;&#x2F; 定义一个dp数组，长度为cost的大小+1 dp[i]表示到达第n个台阶需要的最小费用。        dp[0] &#x3D; 0, dp[1] &#x3D; 0; &#x2F;&#x2F; 因为可以从下标为0或者1的台阶出发，因此dp[0]和dp[1]都初始化为0；        for (int i &#x3D; 2; i &lt; len + 1;i++) &#123;            dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); &#x2F;&#x2F; dp[i]的更新公式        &#125;        return dp[len]; &#x2F;&#x2F; 返回到达第n个台阶（也就是最后一个台阶）的最小费用。    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;cost&lt;/code&gt; ，其中 &lt;code&gt;cost[i]&lt;/code&gt; 是从楼梯第 &lt;code&gt;i&lt;/code&gt; 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。&lt;/p&gt;
&lt;p&gt;你可以选择从下标为 &lt;code&gt;0&lt;/code&gt; 或下标为 &lt;code&gt;1&lt;/code&gt; 的台阶开始爬楼梯。&lt;/p&gt;
&lt;p&gt;请你计算并返回达到楼梯顶部的最低花费。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode509.斐波那契数</title>
    <link href="2023/04/09/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>2023/04/09/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2023-04-09T06:41:47.000Z</published>
    <updated>2023-04-09T07:17:20.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre class="language-none"><code class="language-none">F(0) &#x3D; 0，F(1) &#x3D; 1F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</code></pre><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：1解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：2解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：3解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归求解</li></ol><p>在递归函数里初始化<code>f(0) = 0,f(1) = 1</code>,对于大于1的函数值，递归调用<code>f(n - 2) + f(n - 1)</code>;</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; f(0)的初始化        if (n &#x3D;&#x3D; 1) return 1; &#x2F;&#x2F; f(1)的初始化        return fib(n - 1) + fib(n - 2); &#x2F;&#x2F; 递归调用    &#125;&#125;;</code></pre><ol start="2"><li>迭代求解</li></ol><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        if (n &lt;&#x3D; 1) return n; &#x2F;&#x2F; 如果n为0或者1 直接返回它本身        int pre0 &#x3D; 0, pre1 &#x3D; 1; &#x2F;&#x2F; 初始化pre0和pre1        int answer &#x3D; 0; &#x2F;&#x2F; 初始化答案        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;            answer &#x3D; pre0 + pre1; &#x2F;&#x2F; 答案为f(n-2) + f(n-1)            pre0 &#x3D; pre1; &#x2F;&#x2F; pre0的值更新            pre1 &#x3D; answer; &#x2F;&#x2F; pre1的值更新        &#125;        return answer; &#x2F;&#x2F; 计算完毕返回答案    &#125;&#125;;</code></pre><ol start="3"><li>矩阵快速幂求解</li></ol><p>核心思路是将斐波那契数列的递推式转化为矩阵的乘法，然后使用矩阵快速幂的方法快速计算出矩阵的幂次，进而得到第 n 个斐波那契数。</p><p>首先，我们知道斐波那契数列的递推式为：</p><p>$F(n) &#x3D; F(n-1) + F(n-2)，其中 F(0) &#x3D; 0，F(1) &#x3D; 1。$</p><p>我们可以将这个递推式转化为矩阵的乘法形式：</p><p>$ \begin{bmatrix} F(n) \ F(n-1) \end{bmatrix} &#x3D; \begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} F(n-1) \ F(n-2) \end{bmatrix} $</p><p>根据这个式子，我们可以构造出初始矩阵 base 和单位矩阵 res，然后使用矩阵快速幂的方法快速计算出 base 的 n 次幂，最终得到 res。</p><p>最后，我们可以直接返回<code> res[0][1]</code>，这个值就是第 n 个斐波那契数。</p><p>总的来说，这种解法虽然比较高级，但可以在 O(log n) 的时间复杂度内计算出第 n 个斐波那契数，而且不需要使用数组或者递归来存储之前的结果，空间复杂度为 O(1)。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        &#x2F;&#x2F; 如果n小于等于1，直接返回n        if (n &lt;&#x3D; 1) &#123;            return n;        &#125;        &#x2F;&#x2F; 定义初始矩阵        vector&lt;vector&lt;int&gt;&gt; base&#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        &#x2F;&#x2F; 定义单位矩阵        vector&lt;vector&lt;int&gt;&gt; res&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;        &#x2F;&#x2F; 矩阵快速幂        while (n) &#123;            if (n &amp; 1) &#123;                res &#x3D; multiply(res, base);            &#125;            base &#x3D; multiply(base, base);            n &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 将变量 n 的二进制表示向右移动一位，并将移位后的结果赋值给 n。相当于n&#x2F;&#x3D;2        &#125;        &#x2F;&#x2F; 返回结果        return res[0][1];    &#125;    &#x2F;&#x2F; 定义矩阵乘法函数    vector&lt;vector&lt;int&gt;&gt; multiply(const vector&lt;vector&lt;int&gt;&gt;&amp; A, const vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123;        int m &#x3D; A.size(), n &#x3D; A[0].size(), l &#x3D; B[0].size();        vector&lt;vector&lt;int&gt;&gt; C(m, vector&lt;int&gt;(l));        for (int i &#x3D; 0; i &lt; m; ++i) &#123;            for (int j &#x3D; 0; j &lt; l; ++j) &#123;                for (int k &#x3D; 0; k &lt; n; ++k) &#123;                    C[i][j] +&#x3D; A[i][k] * B[k][j];                &#125;            &#125;        &#125;        return C;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt; （通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示）形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;pre class=&quot;language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;F(0) &amp;#x3D; 0，F(1) &amp;#x3D; 1
F(n) &amp;#x3D; F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-青蛙过河</title>
    <link href="2023/04/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
    <id>2023/04/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</id>
    <published>2023-04-06T12:23:29.000Z</published>
    <updated>2023-04-06T13:05:44.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里 的石头跳到对岸。</p><p>河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度, 每次小青蛙从一块石头起跳, 这块石头的高度就 会下降 1 , 当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的)。</p><p>小青蛙一共需要去学校上 $x$ 天课, 所以它需要往返 $2x$次。当小青蛙具有 一个跳跃能力 $y$ 时, 它能跳不超过 $y$的距离。</p><p>请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。</p><span id="more"></span><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含两个整数$n,x$, 分别表示河的宽度和小青蛙需要去学校 的天数。请注意$2x$ 才是实际过河的次数。</p><p>第二行包含 $n−1$ 个非负整数$H_1,H_2,⋯,H_{n−1}$, 其中 $H_i$&gt;0 表示在河中与小青蛙的家相距 $i$的地方有一块高度为 $H_i$ 的石头,$H_i&#x3D;0$ 表示这个位置没有石头。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行, 包含一个整数, 表示小青蛙需要的最低跳跃能力。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="language-txt" data-language="txt"><code class="language-txt">5 11 0 1 0</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="language-text" data-language="text"><code class="language-text">4</code></pre><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>由于只有两块高度为 1 的石头，所以往返只能各用一块。第 1 块石头和对岸的距离为 4，如果小青蛙的跳跃能力为 3 则无法满足要求。所以小青蛙最少需要 4 的跳跃能力。</p><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 30% 的评测用例, $n≤100$;</p><p>对于 60% 的评测用例, $n≤1000$;</p><p>对于所有评测用例, $1≤n≤10^5,1≤x≤10^9,1≤H_i≤10^4 $。</p><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 512M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>常规思路</li></ul><p>一只青蛙上x次课，来回走了2x次；相当于2x只青蛙上了一次课（只走一段）；每次踩石头它的高度都下降1，而且青蛙都能过河。所以可以先求前缀和之后二分法进行贪心的求解，代码的思路如下：</p><ol><li>定义数组的最大长度N，整型数字n,m，数组a用于接收输入，数组b用于计算前缀和;</li><li>得到n，m和数组a之后，定义数组<code>a[0] = a[n] = N</code>,然后进行计算前缀和的操作。例如前缀和<code>b[i]=x</code>的意思就是i之前的石头一共可以容纳x个青蛙跳过(我们一共需要2m)个;</li><li>进行二分+贪心操作，求出最小的跳跃能力值。</li><li>check函数用于计算在x的下标下，石头是否能让2m个青蛙通过。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int N &#x3D; 1e5 + 3;ll a[N],b[N];int n, m;bool check(int x) &#123;    for(int i &#x3D; 1; i + x - 1 &lt; n ;i++) &#123;        &#x2F;&#x2F; 只有一个的时候        if (b[i + x - 1] - b[i - 1] &lt; 2 * m) &#123;            &#x2F;&#x2F; 石块为0的情况            return false;        &#125;    &#125;    return true;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt; n; i++) &#123;        &#x2F;&#x2F; 循环到n-1        cin &gt;&gt; a[i];    &#125;    a[0] &#x3D; a[n] &#x3D; N;    for (int i &#x3D; 1; i &lt; n; i++) &#123;        &#x2F;&#x2F; 计算前缀和        b[i] &#x3D; b[i - 1] + a[i]; &#x2F;&#x2F; 我能让几只小青蛙在上面    &#125;    &#x2F;&#x2F; 贪心求y    int l &#x3D; 1, r &#x3D; N;    while (l &lt; r)&#123;        int mid &#x3D; (l + r) &#x2F; 2;        if (check(mid)) &#123; &#x2F;&#x2F; 石头足够青蛙分，继续贪心            r &#x3D; mid;        &#125;        else &#123; &#x2F;&#x2F; 石头不够青蛙分            l &#x3D; mid + 1;        &#125;    &#125;    cout &lt;&lt; l;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里 的石头跳到对岸。&lt;/p&gt;
&lt;p&gt;河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度, 每次小青蛙从一块石头起跳, 这块石头的高度就 会下降 1 , 当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的)。&lt;/p&gt;
&lt;p&gt;小青蛙一共需要去学校上 $x$ 天课, 所以它需要往返 $2x$次。当小青蛙具有 一个跳跃能力 $y$ 时, 它能跳不超过 $y$的距离。&lt;/p&gt;
&lt;p&gt;请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-回文日期</title>
    <link href="2023/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F/"/>
    <id>2023/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F/</id>
    <published>2023-04-05T08:01:19.000Z</published>
    <updated>2023-04-05T09:59:30.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。</p><p>有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。</p><p>也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。</p><p>给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。</p><span id="more"></span><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入包含一个八位整数 <em>N</em>，表示日期。</p><p>对于所有评测用例，10000101≤N≤89991231，保证 N 是一个合法日期的 8 位数表示。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出两行，每行 1 个八位数。第一行表示下一个回文日期，第二行表示下一个 ABABBABA 型的回文日期。</p><p><strong>输入输出样例</strong></p><p><strong>示例</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">20200202</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">2021120221211212</code></pre><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>（1）定义每个月的天数</li><li>（2）计算年份</li><li>（3）计算月份</li><li>（4）计算第几天</li><li>（5）判断是不是闰年</li><li>（6）闰年二月天数为29</li><li>（7）非闰年二月天数为28</li><li>（8）判断是不是符合日期标准</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;bool isleap(int year)&#123;    return ((year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)||year%400&#x3D;&#x3D;0); &#x2F;&#x2F; 判断是否是闰年&#125;bool legal(int n) &#x2F;&#x2F; 判断8位数是否是合规的日期&#123;    int year,month,day;    year&#x3D;n&#x2F;10000; &#x2F;&#x2F; 获取年月日的值    month&#x3D;(n%10000)&#x2F;100;    day&#x3D;n%100;    if(month&gt;12 || month&#x3D;&#x3D;0 || day&#x3D;&#x3D;0 || day&gt;31) &#x2F;&#x2F; 进行年月日的判断    return false;    if(month&#x3D;&#x3D;2) &#x2F;&#x2F; 2月针对闰年平年单独判断    &#123;        if(isleap(year)&#x3D;&#x3D;0&amp;&amp;day&gt;28)        return false;        if(isleap(year)&#x3D;&#x3D;1&amp;&amp;day&gt;29)        return false;    &#125;    if(month&#x3D;&#x3D;1||month&#x3D;&#x3D;3||month&#x3D;&#x3D;5||month&#x3D;&#x3D;7||month&#x3D;&#x3D;8||month&#x3D;&#x3D;10||month||12)    &#123;        if(day&gt;31)        return false;    &#125;    if(month&#x3D;&#x3D;4||month&#x3D;&#x3D;6||month&#x3D;&#x3D;9||month&#x3D;&#x3D;11)    &#123;        if(day&gt;30)        return false;    &#125;    return true;&#125;int main()&#123;    int n;    cin&gt;&gt;n; &#x2F;&#x2F; 获取输入    int flag&#x3D;0; &#x2F;&#x2F; 设置判断    for(int i&#x3D;n+1;i&lt;&#x3D;100000000;i++)    &#123;        int a1,a2,a3,a4,a5,a6,a7,a8; &#x2F;&#x2F; 用最笨的办法获取每一位的值        a8&#x3D;i&#x2F;10000000;        a7&#x3D;(i&#x2F;1000000)%10;        a6&#x3D;(i&#x2F;100000)%10;        a5&#x3D;(i&#x2F;10000)%10;        a4&#x3D;(i&#x2F;1000)%10;        a3&#x3D;(i&#x2F;100)%10;        a2&#x3D;(i&#x2F;10)%10;        a1&#x3D;i%10;        if(legal(i)&amp;&amp;flag&#x3D;&#x3D;0&amp;&amp;a1&#x3D;&#x3D;a8&amp;&amp;a2&#x3D;&#x3D;a7&amp;&amp;a3&#x3D;&#x3D;a6&amp;&amp;a4&#x3D;&#x3D;a5) &#x2F;&#x2F; 判断是否是普通回文日期        &#123;            cout&lt;&lt;i&lt;&lt;endl;            flag&#x3D;1;        &#125;        if(legal(i)&amp;&amp;a1&#x3D;&#x3D;a3&amp;&amp;a3&#x3D;&#x3D;a6&amp;&amp;a6&#x3D;&#x3D;a8&amp;&amp;a2&#x3D;&#x3D;a4&amp;&amp;a4&#x3D;&#x3D;a5&amp;&amp;a5&#x3D;&#x3D;a7) &#x2F;&#x2F; 判断是否是ABABBABA型回文日期        &#123;            cout&lt;&lt;i;            break;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。&lt;/p&gt;
&lt;p&gt;有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。&lt;/p&gt;
&lt;p&gt;也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。&lt;/p&gt;
&lt;p&gt;给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>一种用于网格计算中作业调度的新型多智能体强化学习方法</title>
    <link href="2023/04/04/%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97%E4%B8%AD%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B0%E5%9E%8B%E5%A4%9A%E4%BB%A3%E7%90%86%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <id>2023/04/04/%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97%E4%B8%AD%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B0%E5%9E%8B%E5%A4%9A%E4%BB%A3%E7%90%86%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</id>
    <published>2023-04-04T11:57:30.000Z</published>
    <updated>2023-04-05T11:26:26.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一种用于网格计算中作业调度的新型多智能体强化学习方法"><a href="#一种用于网格计算中作业调度的新型多智能体强化学习方法" class="headerlink" title="一种用于网格计算中作业调度的新型多智能体强化学习方法"></a>一种用于网格计算中作业调度的新型多智能体强化学习方法</h2><p>原标题：A novel multi-agent reinforcement learning approach for job scheduling in Grid computing</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>网格计算利用分布式异构资源来支持大规模或复杂的计算任务，合适的资源调度算法对于网格应用的成功至关重要。由于网格环境的复杂性和动态特性，传统的基于模型的方法在实践中可能会导致调度性能不佳。可扩展性和适应性是网格作业调度的主要目标之一。在本文中，针对作业调度问题，特别是在网格中实现负载平衡，提出了一种称为顺序共享学习 (OSL) 方法的新型多智能体强化学习方法。该方法通过使用有序的分布式学习策略规避了可扩展性问题，并基于有限通信的信息共享机制实现了多主体协调。仿真结果表明，OSL方法可以有效地达到负载均衡的目的，其性能在大多数情况下甚至可以与某些集中式调度算法相媲美。还说明了所提方法的收敛性和适应性。</p><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>主要介绍了网格计算的背景和作业调度问题，指出了传统的基于模型的方法在面对资源异构性、资源性能变化和应用程序多样性等方面存在的挑战。然后，介绍了强化学习在解决这些问题方面的优势，并提出了一种基于多智能体强化学习的作业调度方法。</p><p>在本文中，为了在大规模网格环境中实现基于学习的协调和泛化，提出了一种称为序数共享学习 (OSL) 方法的新型多智能体强化学习方法来解决网格计算的作业调度问题。在OSL方法中，基于序号信息共享机制设计了一种快速分布式学习算法。与以前用于作业调度的多智能体强化学习（MARL）方法相比，OSL 方法有两个方面的创新。一方面简化了作业调度中最优决策的建模，其中仅在线学习效用表来估计资源效率，而不是构建复杂的网格信息系统（GIS）。另一方面通过多智能体系统有限通信的有效信息共享机制规避了可扩展性和协调问题，其中有序共享策略使所有智能体共享它们的效用表并依次做出决策。在模拟的大规模网格计算环境中对所提出的方法进行了评估，结果表明了其有效性和可行性。</p><p>最后，简要介绍了本文的组织结构和贡献。</p><p><img src="http://cdn.leafii.top/img/image-20230404221510593.png" alt="image-20230404221510593" loading="lazy"></p><h3 id="Problem-statement"><a href="#Problem-statement" class="headerlink" title="Problem statement"></a>Problem statement</h3><h4 id="A-general-job-scheduling-model-in-Grids"><a href="#A-general-job-scheduling-model-in-Grids" class="headerlink" title="A general job scheduling model in Grids"></a>A general job scheduling model in Grids</h4><p>由于网格计算的NP-Complete特性和调度算法在网格场景中的最优性难以证明，现有的研究总是试图寻找次优解。为了描述网格计算的动态性，随机性以及异构性，研究了通用的 Gird 作业调度模型，如图2所示：</p><p><img src="http://cdn.leafii.top/img/image-20230404210909544.png" alt="image-20230404210909544" loading="lazy"></p><p>主要组件包括用户、调度程序和资源，其中不同的调度程序并行处理作业。他们负责从用户那里接收作业并将其分配给资源。与传统并行和分布式系统中的对应物不同，网格调度器通常不能直接控制资源，而是像代理体一样工作.每个调度器都可以向任何计算资源提交作业，并最终生成作业到资源的映射.在上述模型中，用户只是生产并向调度程序提交作业，他们的角色可以完全由作业创建者代替。工作到达或工作负荷的模型可以用泊松过程或其他基于概率的模型或自相关模型来描述.</p><p>在大型网格系统中，由于缺乏对资源的控制，资源更新周期长，调度器可用的资源信息存在时间延迟，可能不准确。因此，作业调度器的有限可观察性成为基于及时准确信息的作业调度算法的障碍，有必要开发更鲁棒和自适应的调度算法，这是本文的主要动机之一。</p><p>一般来说，Grids 中的分散作业调度问题可以建模为多智能体作业调度系统 [29]，表示为 6 元组$⟨G，R，P，D，C，SR⟩$，其中$G&#x3D;⟨g_1,…,g_N⟩$是一组智能体，$s &#x3D; {s_1,…,s_M}$是一组资源，$P:G\times N\rightarrow[0,1]$是作业提交函数,$D:G\times N \rightarrow \mathbb R$是概率作业大小函数,$C:G\times N \rightarrow \mathbb R$是概率容量函数，SR是作业调度规则。</p><p>为了专注于作业调度任务，上述模型进行了一些抽象，但保持了网格计算环境的主要特征，即动态的、大规模的用户和资源的异构性。尽管没有详细考虑实际实施的设计问题，例如网络拓扑，但图 2 中的模型<strong>足够通用</strong>，因为可以开发不同的代表性模型，包括随机作业提交函数、作业大小函数和容量函数，以描述网格工作负载的显着属性。利用网格工作负载的随机或自相关模型，可以研究处理网格作业调度问题的动态性、随机性和异构性的作业调度算法。</p><p>下面，为了便于讨论，假设所有的调度器都使用相同的调度算法，并且所有的作业只需要 CPU 资源，因此它们的持续时间 J 是唯一的。</p><h4 id="Performance-measures-for-job-scheduling-in-Grids"><a href="#Performance-measures-for-job-scheduling-in-Grids" class="headerlink" title="Performance measures for job scheduling in Grids"></a>Performance measures for job scheduling in Grids</h4><p>在上面的 Grid 调度模型中，资源执行分配的作业，并且它们的能力可能不同.每个资源都以其处理能力 C 为特征，它被定义为完成单位长度作业所需的 CPU 时间的倒数，即如果资源需要持续时间 t 来完成长度为 J &#x3D; 1 的单位作业，则其容量为$C &#x3D; 1&#x2F;t$。此外，假设队列中的所有作业都按到达时间排列优先级，因此在给定时间<strong>只有一个作业</strong>在资源上执行，而其他作业则在队列中等待。</p><p>网格作业调度中的常见性能度量是平均每个动作时间 (ATPT)。time-per-token (TPT) 是通过作业生成和完成之间经过的时间来衡量的，因此相应的平均标准，即 ATPT，可以制定如下：</p><p>$ATPT&#x3D;\frac{1}{L} \sum_{i&#x3D;1}^{L}TPT^i &#x3D; \frac{1}{L}\sum_{i&#x3D;1}^{L}(t_{wait}^i + t_{execute}^i)$</p><p>$TPT^i$是第i个作业的总耗时，它是队列等待时间$t_{wait}^i$（一个作业提交到开始执行的耗用时间）与实际执行时间$t_{execute}^i$之和，L表示所有资源完成的工作的总数。但是ATPT无法及时表征整个网格系统的调度性能，因为只有在作业完成后，才能更新此指标。如果资源中的作业队列很长，ATPT 的更新会严重延迟。最后，ATPT 的值仅仅反映了过去的作业调度效率，而不是当前的。</p><p>因此，使用了另一个有效的指标，即资源负载（LoR，或 makespan）。LoR定义为队列中作业的总长度$l_{total}$除以当前资源的容量$C_i$，系统的平均LoR（ALoR）可以<strong>完全代替</strong>平均每令牌时间。 ALoR 可以表示为：</p><p>$ALoR &#x3D; \frac{1}{M}\sum_{i&#x3D;1}^{M}LoR^i&#x3D;\frac{1}{M}\sum_{i&#x3D;1}^{M}(l_{total}^{i}&#x2F;C_i) \&#x3D;\frac{1}{M}\sum_{i&#x3D;1}^{M}(\sum_{j&#x3D;1}^{L^i}J_j^i&#x2F;C_i)$</p><p>其中 $LoR_i$ 是第 i 个资源的负载,$l^i_{total}$ 是队列中作业的总长度，它是所有排队作业长度$J_j^i$的总和,$L_i$ 是第 i 个资源队列中的作业数，$M$是资源数。新绩效指标的优点是显而易见的，因为它能够及时、全面地反映系统绩效。</p><p>作业调度算法的目标是最小化 ALoR 及其标准偏差。最小化上述两个量将确保整个系统的效率和公平性。除了上述两个指标外，资源中的最大 LoR 是反映瞬态性能的另一个指标。</p><h3 id="The-OSL-method-for-adaptive-job-scheduling"><a href="#The-OSL-method-for-adaptive-job-scheduling" class="headerlink" title="The OSL method for adaptive job scheduling"></a>The OSL method for adaptive job scheduling</h3><p>如上所述，在实际的大型网格应用中，即使有 GIS 系统的帮助，调度器中的资源信息也存在时间延迟并且可能不准确。因此，开发一种不依赖于精确模型的鲁棒调度算法是合理的。为了满足自适应作业调度的要求，协调的多智能体强化学习方法可能是一个合适的解决方案。在下文中，在对不同的 MARL 框架进行分析之后，提出了一种用于资源选择和作业调度的新型分散式 MARL 方法，其中多个智能体或调度程序之间的协作控制是通过顺序共享学习方法实现的。</p><h4 id="Basic-frameworks-for-multi-agent-reinforcement-learning"><a href="#Basic-frameworks-for-multi-agent-reinforcement-learning" class="headerlink" title="Basic frameworks for multi-agent reinforcement learning"></a>Basic frameworks for multi-agent reinforcement learning</h4><p>大多数单智能体 RL 算法都基于马尔可夫决策过程 (MDP) 的形式.然而，作为强化学习在分布式决策环境中的延伸，多智能体强化学习必须解决多个智能体共存打破环境平稳性的问题。到目前为止，许多 MARL 算法都是基于随机博弈 (SG) 模型 [33] 开发的，例如 JAL [34] 和 Team-Q 算法 [35]。然而，可扩展性差和信息利用效率低是MARL成功应用于大规模应用的两大障碍。对于图 2 中描述的作业调度问题，调度器和资源的数量非常多，因此，以前的MARL方法很难被采用。</p><p>除了SG模型，MARL的另一个框架是将单智能体强化学习技术直接扩展到多智能体系统，即让每个智能体根据局部状态和局部奖励独立学习，无需显式通信。这种技术在 MARL [34] 中称为独立学习器 (IL) 方法，并且在文献 [5,36,37] 中开发了一些 IL 算法。尽管 IL 的 MARL 方法不需要探索呈指数增长的联合状态-动作空间，但环境将不再是静止的，MARL 中将存在收敛问题和振荡行为。正如我们将在 4.1 节中说明的那样，如果在网格中的作业调度中使用没有协调和通信的 IL 方法，通常会出现羊群行为 [22]。</p><p>为了解决上述困难，多智能体强化学习的一种有前途的方法是通过信息共享和协调进行局部学习，以实现效率和最优性之间的平衡。基于这个想法，一种称为 OSL 算法的新 MARL 方法将在以下讨论中提出。</p><h4 id="The-OSL-algorithm-for-job-scheduling-in-Grids"><a href="#The-OSL-algorithm-for-job-scheduling-in-Grids" class="headerlink" title="The OSL algorithm for job scheduling in Grids"></a>The OSL algorithm for job scheduling in Grids</h4><p>为了克服 MARL 中的“维数灾难”问题，我们提出了具有降低的计算复杂性和改进的协调机制的 OSL 算法。新算法有两个主要特点。首先，它采用分布式 RL 框架并采用新颖的基于效用表的学习策略。由于 OSL 方法仅利用局部信息进行学习，因此它是一种基于独立学习者的 RL 方法。其次，它利用通信成本有限的信息共享机制来解决多主体协调问题。</p><p>OSL 的方案如图 3 所示。上面的循环表示共享实用程序表的调度程序。效用表仅随资源数量 M 线性增加，因此通信成本有限。下半部分详细表示调度程序智能体。每个调度器智能体主要包括两部分：Learner 和 Actor。 Learner 以有序的方式从前面的 agent 接收并共享效用表，并决定为 Job Buffer 中排队的作业选择资源。 Reward Converter 可以分析作业的完成信号并将其转换为奖励信号，这对于更新效用表至关重要。 Actor接收到新的job，并安排它们在Job Buffer中排队，然后根据Learner的决定将其提交到相应的资源中，并将提交记录在Submitted Job List中。最后，Actor 根据作业的完成情况更新 Submitted Job List，即如果一个作业完成了，那么它将从 Submitted Job List 中删除。</p><p><img src="http://cdn.leafii.top/img/image-20230404221455211.png" alt="image-20230404221455211" loading="lazy"></p><p>一般来说，OSL的实施需要考虑两个关键问题：</p><p>首先，虽然众所周知全局资源状态是调度器决策的基础，但由于调度器的观察和通信能力有限，很难在动态环境中获得所有调度器的准确信息。在本文中，提出了一种利用职位信息来估计状态的间接方法。调度器将提交作业的信息记录为向量$（n_r，t_s，t_e，J）$，即使用的资源名称$n_r$，作业开始时间$t_s$，作业完成时间$t_e$，作业大小$J$.然后，它抽象估计相应资源状态的信息。<strong>但是</strong>，如果调度程序从未向资源提交作业，则它对此一无所知。因此，这种来自个人经验的估计仅包含全局状态的部分信息。<strong>为提高估算精度，必须采取信息共享等有效手段。</strong></p><p>其次，很难直接获得学习的即时奖励。环境<strong>不能直接提供</strong>任何全局强化信号，而只能提供单个作业完成信号。因此调度器智能体必须将此类信息转换为奖励信息。事实上，由于其他调度器的存在，一个作业的time-per-token是由所有调度器的策略共同决定的。如何从上述信息中计算出合适的强化信号将是一个问题。更重要的是，当一个调度器等待其提交的作业的反馈时，网格环境可能会由于其他调度器的操作而发生变化，因此一个调度器只有在作业完成后才更新其效用表为时已晚。<strong>一种可能的解决方案</strong>是开发一种奖励机制，无论调度程序是否执行作业提交，都会在每个时间步创建奖励信息。</p><p>在下面的小节中，为了解决上述问题，将提出一种新颖的奖励生成机制和信息共享机制。</p><h5 id="The-decentralized-learning-strategy-using-utility-tables"><a href="#The-decentralized-learning-strategy-using-utility-tables" class="headerlink" title="The decentralized learning strategy using utility tables"></a>The decentralized learning strategy using utility tables</h5><p>在上述模型中，调度智能体被描述为 $G &#x3D; {g_1, g_2, . . . , g_N }$，其中每个调度智能体 gi 可以负责多个用户的作业调度。资源由$ S &#x3D; {s_1, s_2, . . . , S_M}$表示。类似于强盗问题 [24] 的学习方法，智能体 $g_i$ 保留一个效用表 $U_i$ 来对资源的效率进行评分，其中 $U^i{(j)}$ 表示第 j 个资源的效率，或者对从资源集 S，即 $j ∈ {1, 2, . . . , |S|} &#x3D; {1, 2, . . . , M}$中选择第 j 个资源的动作进行评分。调度程序 $g_i$的效用表如图 4 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230405092926308.png" alt="image-20230405092926308" loading="lazy"></p><p>对于去中心化学习过程中的每个时间步，agent $g_i$基于以下两个步骤执行资源选择操作和效用更新操作：</p><p>第1步：agent $g_i$检查判断是否有新的job到达。如果不是，转步骤2。如果是，重复执行步骤1，直到所有作业都被调度。 Agent $g_i$ 选择得分最高的资源 $s_j$，然后将作业提交给资源 $s_j$，并将其作为未完成的作业记录在已提交的作业列表中。如果执行第 j 个动作，则获得瞬时奖励 $r(j) &#x3D; −1$，同时更新该动作对应的效用 $U^i{(j)}$：</p><p>$U^i(j) &#x3D; (1 - \alpha) * U^i(j) + \alpha * r(j)$</p><p>其中的$\alpha$是学习率。</p><p>第 2 步：Agent $g_i$ 推进空闲调度进程并更新效用。如上所述，即使没有作业提交，也会为每个步骤设计一个瞬时奖励信号。Agent $g_i$ 根据提交的作业列表中的作业状态为每个动作创建强化信号，即：</p><p>$u(j) &#x3D;\left {<br>\begin{array}{c}<br>+1 \ \ \ only \ the \ job \ is \ finished \<br>0 \ \ \ no \ job \<br>-1 \ \ \ job\ is\ unfinished<br>\end{array}<br>\right. \ \ j \in {1,2,…,M}.$</p><p>如果多个作业被提交到同一个资源，每个作业都会有一个独立的强化信号。最后，可以通过将所有信号相加来计算<strong>相应动作的奖励</strong>：</p><p>$r(j)&#x3D;\sum_{k&#x3D;1}^{K^j}u(k)$</p><p>其中 $K^j$ 表示当前提交给第 j 个资源的作业数。例如，假设当前智能体向第一个资源提交了 3 个作业，并且在一个时间步之后，一个作业完成而另外两个作业未完成。所以选择第一个资源的瞬时奖励是：$r(1) &#x3D; 1 + 2 * (−1) &#x3D; −1$。当获得整个奖励向量$ (r(1), r(2), . . , r(N))$ 时，可以使用上面的等式更新每个资源的效用。</p><p>此时，agent $g_i$ 可以使用效用表 Ui 来估计所有资源的效率。例如，如果一个资源的队列很长或者资源的容量很差，调度器向它提交作业后，调度器必须等待很长时间才能收到资源的完成响应。因此，调度器获得奖励信号 −1 的次数要比获得奖励 +1 的次数多得多。最后，这种资源对应的效用价值会很小。显然，根据效用表，<strong>效用值越大，资源状态越好。</strong>连续更新操作及时反馈资源的工作状态，为分配连续作业做出可行的决策至关重要。</p><h5 id="Multi-agent-information-sharing-based-on-limited-communication"><a href="#Multi-agent-information-sharing-based-on-limited-communication" class="headerlink" title="Multi-agent information sharing based on limited communication"></a>Multi-agent information sharing based on limited communication</h5><p>在上面的小节中，建立了一个效用表来估计资源的效率。开发了一种改进的奖励和更新机制来指示资源的效率。然而，在网格应用程序中，有多个调度程序智能体。如果所有智能体都独立且同时学习和做出决策，则会出现协调问题。显然，调度器的任何决定都会改变资源的状态，但其他调度器在将作业提交到同一资源之前不会检测到更改（它们通过使用队列中的等待时间间接检测到这一点）。因此，特定智能体中的效用表不能准确指示资源的真实状态。此外，随着调度器数量的增加，可能的冲突将变得更加严重。因此，必须为网格作业调度问题中的分布式学习开发一种可行的协调机制。</p><p>由于每个智能体都拥有一个本地效用表来估计资源的效率，因此通过共享效用表来提高估计精度是一种自然的方式。但是，由于Grids中的scheduler agent数量非常多，不可能直接共享每个utility table。因此，本文提出了一种有限通信的序号共享机制来满足上述需求。智能体之间的协调是通过<strong>按顺序和迭代共享相邻智能体的效用表</strong>来实现的。如图4所示，效用表仅与资源规模成线性比例。因此智能体之间的总通信成本很低并且始终保持不变。</p><p>为了实现信息共享机制，通过将Agent排序 为$g_1，g_2，… . . , g_N$，为所有调度智能体定义了一个序数结构。 , 那么智能体共享它们的效用表并按顺序进行决策，即智能体 $g_i$ 共享前面智能体的效用信息如下：</p><p>$U^i(j) &#x3D; (1 - \beta) * U^i{j} + \beta * U^{i-1}(j)$</p><p>其中的$\beta$是共享因子。$U^{i-1}(j)$是相邻智能体$g_{i-1}$的效用表并且它包含了所有的之前的智能体对资源效用的估计。最终，最后一个agent的效用表返回给第一个agent再次共享。换句话说，效用共享过程是有序的和迭代的。</p><p>表 1 显示了网格作业调度中智能体 gi 的 OSL 算法的主要过程。</p><p><img src="http://cdn.leafii.top/img/image-20230405104508471.png" alt="image-20230405104508471" loading="lazy"></p><p>与其他MARL算法相比，OSL算法更适合在大规模作业调度应用中实现。作为一种基于效用表的学习方法，效用表函数中没有显式的状态变量，因此更适应资源和应用高度多样化和动态化的网格场景。此外，OSL 的另一个重要优势是协调的通信成本低。信息交换总量是简单效用表，其规模与资源数量成线性关系，远低于直接通信模式下的指数级。</p><h3 id="Performance-evaluation-and-discussions"><a href="#Performance-evaluation-and-discussions" class="headerlink" title="Performance evaluation and discussions"></a>Performance evaluation and discussions</h3><p>在本节中，将在模拟中评估和分析用于作业调度的基于 OSL 的选择 (OSLS) 规则的性能。此外，将所提出的 OSLS 方法与其他四种资源调度或选择规则进行了比较，它们是分散的最小-最小选择（DMMS）[38]、随机选择（RS）、最小负载选择（LLS）和简单学习选择（ SLS）[5]。 Min-Min算法是一种启发式调度方法，成为性能比较的基准调度算法[38]。基于分散的调度模型，每个调度器独立执行分散的Min-Min算法。即使有 GIS 系统的帮助，在动态环境中调度程序的决策也可能无法被其他人准确知晓。原因是GIS中的信息更新总是不可避免地存在时间延迟。在 RS 方法中，智能体根据均匀概率分布为作业随机选择资源。在 LLS 方法中，智能体选择负载最少的资源来提交作业。如果有多个资源具有相同的最小负载，则随机选择其中一个。该选择规则假定智能体可以获得准确的全球资源信息，例如，来自理想的 GIS 系统。在 SLS 方法中，智能体执行独立的强化学习过程。它与提议的 OSLS 方法的不同之处在于，智能体在收到来自资源的已提交作业的最终完成信号之前不会更新其效用表，并且每个智能体都在没有任何协调信息的情况下独立学习 [5]。</p><p>网格系统的规模可以定义为智能体数$(N)$和资源数$(M)$的组合$(N，M)$。在每个时间步中，每个调度智能体$g_i$ 可能会收到带有泊松过程生成的随机数的作业。工作的到达率表示为 $ξ$ 。作业的长度是从 $[J_{min}, J_{max}]$ 区间内的均匀分布中随机生成的。资源的容量也在区间 $[C_{min}, C_{max}]$ 中统一选择。所以系统可以用参数集$(N，M，ξ，[J_{min}，J_{max}]，[C_{min}，C_{max}])$来描述。因此，由Grids的总处理能力和到达的作业总数共同确定的期望系统负载$γ_{system}$可以计算为：</p><p>$γ_{system} &#x3D; \frac{J_{total}}{C_{total}} &#x3D; \frac{\sum_{j&#x3D;1}^N(J_j^{\alpha v}<em>\xi)}{\sum_{i&#x3D;1}^{N}C_i} &#x3D; \frac{\sum_{j&#x3D;1}^N((J_{min} + J_{max})&#x2F;2</em>\xi_{j})}{\sum_{i&#x3D;1}^{N}C_i} * 100%$</p><p>其中$J_j^{\alpha v}$ 是第 j 个调度程序的作业长度的中值。显然，系统负载不应超过 100%，否则调度系统会崩溃。事实上，超过 90% 的系统负载对于 Grids 来说是非常沉重的。一个有效的作业调度算法可以公平、充分地利用所有资源来平衡系统的负载。为了测试新方法的负载均衡能力，下面进行了几个实验。</p><h4 id="Performance-evaluations-under-different-system-scales"><a href="#Performance-evaluations-under-different-system-scales" class="headerlink" title="Performance evaluations under different system scales"></a>Performance evaluations under different system scales</h4><p>为了实验不同的系统规模，选择了三种系统规模，即(30, 100)、(100, 250)和(300, 1000)。这些配置足够大，可以代表典型网格计算环境的规模。作业长度的分散范围设置为 [5, 995]。资源容量的区间为[50, 350]。工作到达率分别为0.93、0.7和0.93。所以所有的系统负载大约在 70% 左右。它是网格应用程序的典型中等系统负载。仿真结果如图 5 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230405142053921.png" alt="image-20230405142053921" loading="lazy"></p><p>图5中不同作业调度方法的ALoR曲线表明，在中等系统负载下，只有OSL方法、DMMS方法和LLS方法在不同的系统规模下实现了高效的负载均衡。显然，LLS方法是一种集中式的方法，可以达到最优的调度策略。但昂贵的计算和通信成本阻碍了它在现实世界网格中的有效应用。 DMMS方法可以平衡负载，但效率低于LLS方法，因为非协调决策可能会发生冲突，导致某些资源的过度利用&#x2F;利用不足。 OSL算法是去中心化的，只需要有限的通信成本，但可以针对不同的系统规模获得更好的次优策略。结果表明，一开始，OSL 方法的性能可能比 DMMS 和 LLS 差。这是因为使用 OSL 方法的调度器没有网格的先验知识，但是使用其他两种启发式方法的调度器可以从 GIS 系统中获取环境信息。当基于 OSL 的调度器通过试验积累了足够的经验时，最终可以获得良好的调度性能。</p><p>如图所示，SLS规则的性能很差，无法完成作业调度任务。出现这种现象的主要原因是奖励机制不当和同步问题。对于 SLS 方法，无论其 bandit-like 模型如何，它都采用延迟奖励机制。此外，基于 SLS 的调度器无需协调即可独立学习和工作。显然，这种行为会导致某些资源过度利用，而导致其他资源利用不足，这会降低调度性能。这种病理被称为<strong>羊群行为</strong> [18,19]。</p><p>具有 RS 规则的智能体随机选择资源，根本不考虑它们的效率，因此低容量资源上的 LoR 将无限增长。最后，平均负载 ALoR 增加失控。此外，对于 RS 规则，确实规模越大，性能越差。</p><h4 id="Performance-evaluations-under-different-system-loads"><a href="#Performance-evaluations-under-different-system-loads" class="headerlink" title="Performance evaluations under different system loads"></a>Performance evaluations under different system loads</h4><p>为了测试新方法在不同系统负载下的自适应性能，选择了50%、70%和90%三种系统负载配置，系统规模设置为(100, 250)。其他参数与前一个实验相同。图 6 显示了不同系统负载下 ALoR 的变化曲线。很明显，OSL 方法允许智能体比 RS 和 SLS 方法更有效地在资源之间安排作业。此外，即使系统负载增加，OSL 方法也可以收敛到次优策略。因此，所提出的 OSL 方法可以适应不同的系统负载。从图 6 可以看出，对于低系统负载，OSL 甚至可以收敛到一个接近最优的策略，其性能与集中式 LLS 方法相似。当系统负载增加时，OSL 也可以找到与 LLS 相当的次优策略。</p><p><img src="http://cdn.leafii.top/img/image-20230405145121744.png" alt="image-20230405145121744" loading="lazy"></p><h4 id="Performance-evaluations-under-different-resource-capacities"><a href="#Performance-evaluations-under-different-resource-capacities" class="headerlink" title="Performance evaluations under different resource capacities"></a>Performance evaluations under different resource capacities</h4><p>在前面的模拟中，资源容量的区间很宽，即 [50, 350]。事实上，不同的时间间隔会显着影响系统性能。下面选择资源容量的一个窄区间[150, 250]，再次进行上述系统规模(200, 500)的模拟。结果如图 7 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230405150525357.png" alt="image-20230405150525357" loading="lazy"></p><p>在图 7 中，当系统负载较轻时（γsystem ≤ 70%），RS 方法可以很好地进行作业调度。 原因可能是所有资源的容量都大于 150，足以避免保持较长的作业队列。 此外，SLS 方法在系统负载较低时也可以获得良好的性能，如图 7（a）所示。 然而，RS 和 SLS 都无法在高系统负载下获得良好的性能，如图 7（b）和（c）所示。 当系统负载增加时，RS方法的性能下降，最终变得不可行。 然而，OSL 方法可以实现不同资源容量一致的负载平衡。</p><h4 id="Performance-evaluations-under-different-numbers-of-schedulers-and-resources"><a href="#Performance-evaluations-under-different-numbers-of-schedulers-and-resources" class="headerlink" title="Performance evaluations under different numbers of schedulers and resources"></a>Performance evaluations under different numbers of schedulers and resources</h4><p>在下面的模拟中，调度器数量和资源数量的不同比例被选择为（500, 200）和（1000, 500）。 作业长度的区间和资源容量的区间分别为 [5, 995] 和 [250, 750]。 作业到达率为 0.2 和 0.4（因此系统负载分别为 50% 和 80%）。 结果如图 8 所示。从图 8 可以看出，当调度器的数量远大于资源的数量时，SLS 方法具有良好的性能。 结果与文献[5]的结论一致。 如此好的成绩，可能是因为就业率低，资源能力强。 然而，对于现实世界的网格，调度器的数量多于资源的数量并不常见。 此外，请注意 SLS 规则的性能在不同条件下仍然不如 OSL 方法。</p><p><img src="http://cdn.leafii.top/img/image-20230405152315603.png" alt="image-20230405152315603" loading="lazy"></p><h4 id="Other-performance-measures"><a href="#Other-performance-measures" class="headerlink" title="Other performance measures"></a>Other performance measures</h4><p>除了平均资源负载 (ALoR) 之外，还可以使用其他指标来衡量系统性能。通常，ALoR 表示系统的宏观性能，但瞬态性能，例如资源中的最大 LoR（或完工跨度）也很重要。此外，LoR 的标准偏差是评估作业调度算法效率的另一个指标。无花果。图 9 和图 10 显示了 4.1 节中相应的实验结果。</p><p><img src="http://cdn.leafii.top/img/image-20230405153155477.png" alt="image-20230405153155477" loading="lazy"></p><p>从以上两个图中可以发现，OSLS 的最大 LoR 和偏差收敛，而 RS、SLS 和 DMMS 规则发散很快。 尽管 OSLS 曲线的幅度随着系统规模的增加而增加，但它们最终趋于平稳。 在不同的系统负载下获得了相同的结果。 换句话说，所有结果表明OSL算法的瞬态性能和效率是<strong>令人满意</strong>的。</p><h4 id="Performance-evaluation-with-different-learning-rates-and-sharing-factors"><a href="#Performance-evaluation-with-different-learning-rates-and-sharing-factors" class="headerlink" title="Performance evaluation with different learning rates and sharing factors"></a>Performance evaluation with different learning rates and sharing factors</h4><p>在上述所有模拟中，学习率和共享因子均设置为 0.5。事实上，学习因素和共享因素可以看作是新信息和过去经验之间的折衷，以及代理人自己的知识和他人的知识。可以为这两个参数选择一些不同的配置。下面进行与4.1(b)节相同条件的实验，分别评估不同的学习率和共享因子。</p><p><img src="http://cdn.leafii.top/img/image-20230405154828342.png" alt="image-20230405154828342" loading="lazy"></p><p>图 11(a) 显示了 OSL 在不同学习率下的性能变化，分别为 0.2、0.5 和 0.8，其中共享因子等于 0.5。 图 11(b) 显示了 OSL 在不同共享率下的性能变化，分别为 0.2、0.5 和 0.8，其中学习率等于 0.5。 结果表明，α 和 β 的值太大或太小都可能导致不理想的调度性能。 从实证研究中，可以选择学习率和共享因子的中间值以获得良好的性能。</p><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>根据以上实验，OSL算法的优势是显而易见的。通过使用序数共享学习机制，OSL 算法实现了与集中式和基于模型的方法（即 LLS 方法）相当的性能，但计算成本低得多且通信受限。此外，新方法对工作条件的敏感性低于其他算法，并实现了基于 MARL 的有效负载平衡。表 2 显示了本文研究的不同作业调度方法之间的比较总结。</p><p><img src="http://cdn.leafii.top/img/image-20230405155201637.png" alt="image-20230405155201637" loading="lazy"></p><h3 id="Related-works"><a href="#Related-works" class="headerlink" title="Related works"></a>Related works</h3><p>对于 Grids 中基于 RL 的作业调度问题，还有一些其他相关工作。 在[5]中，SLS 方法被用于网格作业调度。 然而，上述实验结果表明，SLS方法仅在用户数远大于资源数的某些特殊情况下具有良好的性能。 此外，其性能仍有待提高。</p><p>在 [6] 中，作者针对网格和其他分布式系统等领域的分布式任务分配问题引入了一种名为加权策略学习器 (WPL) 的新梯度上升学习算法。 WPL 可以在不观察其他智能体行为的情况下学习随机策略。然而，由于观测信息有限且难以获得平衡解，多智能体梯度上升法的收敛速度较慢，尤其是对于大规模问题。因此，作者只是针对一个小规模的问题测试了 WPL，其中服务器和用户的数量都不超过 5 个。</p><p>为了解决动态资源分配中的协调学习问题，在[39,27]中提出了一些基于价值函数的RL算法。为了将标准 Q 学习扩展到具有较大或连续状态-动作空间的资源分配问题，研究了具有函数逼近的 RL 方法。然而，大规模网格应用的问题仍然难以解决。在 [25,26] 中，一种名为 Fair Action Learner (FAL) 算法的多智能体 RL 方法被应用于以分散的方式跨集群共享资源。 FAL 采用直接策略搜索技术，即策略梯度上升 (PGA) 算法来学习决策策略。但是从他们的实验结果来看，学习过程的收敛速度还是很慢.</p><p>在 [40] 中，作者将资源分配问题视为复合 MDP，并提出了一种简化的本地化 RL 方法，其中动作、状态和奖励都是绝对本地化的。本地 RL 方法在数据中心原型的资源分配任务中进行了测试，并获得了一些有希望的结果。但是，智能体之间的适当协调对于获得更好的系统性能至关重要。</p><h3 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h3><p>网格计算的主要关注点之一是开发在动态环境中具有自配置和自优化能力的自主计算系统。 本文提出了基于多智能体强化学习的OSL方法来解决Grids中的作业调度问题。 该方法通过使用分布式学习策略规避了可扩展性问题，并实现了基于有序信息共享机制的多智能体协调。 最后，对OSL算法的性能进行了评价，并与其他算法进行了比较，研究并模拟了一种通用的网格作业调度模型，以描述网格的动态性、随机性、异构性。 仿真结果表明，适当的在线学习方法可以对异构网格系统中的负载平衡质量产生实质性的积极影响，并说明了OSL算法的有效性和效率。 未来的工作可能包括在实际网格环境中改进和应用所提出的方法。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一种用于网格计算中作业调度的新型多智能体强化学习方法&quot;&gt;&lt;a href=&quot;#一种用于网格计算中作业调度的新型多智能体强化学习方法&quot; class=&quot;headerlink&quot; title=&quot;一种用于网格计算中作业调度的新型多智能体强化学习方法&quot;&gt;&lt;/a&gt;一种用于网格计算中作业调度的新型多智能体强化学习方法&lt;/h2&gt;&lt;p&gt;原标题：A novel multi-agent reinforcement learning approach for job scheduling in Grid computing&lt;/p&gt;
&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;网格计算利用分布式异构资源来支持大规模或复杂的计算任务，合适的资源调度算法对于网格应用的成功至关重要。由于网格环境的复杂性和动态特性，传统的基于模型的方法在实践中可能会导致调度性能不佳。可扩展性和适应性是网格作业调度的主要目标之一。在本文中，针对作业调度问题，特别是在网格中实现负载平衡，提出了一种称为顺序共享学习 (OSL) 方法的新型多智能体强化学习方法。该方法通过使用有序的分布式学习策略规避了可扩展性问题，并基于有限通信的信息共享机制实现了多主体协调。仿真结果表明，OSL方法可以有效地达到负载均衡的目的，其性能在大多数情况下甚至可以与某些集中式调度算法相媲美。还说明了所提方法的收敛性和适应性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-单词分析</title>
    <link href="2023/04/04/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/"/>
    <id>2023/04/04/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/</id>
    <published>2023-04-04T07:48:17.000Z</published>
    <updated>2023-04-04T07:52:47.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组 成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。</p><p>现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这 个字母出现的次数。</p><span id="more"></span><p><strong>输入描述</strong></p><p>输入一行包含一个单词，单词只由小写英文字母组成。</p><p>对于所有的评测用例，输入的单词长度不超过 1000。</p><p><strong>输出描述</strong></p><p>输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪 个。如果有多个字母出现的次数相等，输出字典序最小的那个。</p><p>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。</p><p><strong>输入输出样例</strong></p><p><strong>示例 1</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">lanqiao</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">a2</code></pre><p><strong>示例 2</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">longlonglongistoolong</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">o6</code></pre><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    string word; &#x2F;&#x2F; 定义输入的单词变量    cin &gt;&gt; word; &#x2F;&#x2F; 用输入流为其赋值    int cnt[26] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 初始化计数器    int index &#x3D; -1; &#x2F;&#x2F; 初始化计数器所用的下标    for (char s: word) &#123;        index &#x3D; s - &#39;a&#39;; &#x2F;&#x2F; 获取当前字母在计数器中的下标        cnt[index]++; &#x2F;&#x2F; 对应的计数自增1    &#125;    int max &#x3D; -1; &#x2F;&#x2F; 计数器中的最大值    int max_index &#x3D; -1; &#x2F;&#x2F; 计数器中最大值对应的最小下标    for (int i &#x3D; 0; i &lt; 26; i++) &#123;        if (cnt[i] &gt; max) &#123;            max &#x3D; cnt[i]; &#x2F;&#x2F; 最大值迭代            max_index &#x3D; i; &#x2F;&#x2F; 最大值的最小下标迭代，若最大值未更新，下标也不会更新        &#125;    &#125;    char answer &#x3D; &#39;a&#39; + max_index; &#x2F;&#x2F; 得到字母个数最多的字母    cout &lt;&lt; answer &lt;&lt; endl; &#x2F;&#x2F; 输出题目要求的第一行答案    cout &lt;&lt; max &lt;&lt; endl; &#x2F;&#x2F; 输出题目要求的第二行答案    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组 成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。&lt;/p&gt;
&lt;p&gt;现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这 个字母出现的次数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-门牌制作</title>
    <link href="2023/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C/"/>
    <id>2023/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C/</id>
    <published>2023-04-03T08:29:27.000Z</published>
    <updated>2023-04-09T06:43:56.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小蓝要为一条街的住户制作门牌号。</p><p>这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。</p><p>小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。</p><p>请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><span id="more"></span><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int result &#x3D; 0; &#x2F;&#x2F; 初始化需要数字2的个数为0    for (int i &#x3D; 1; i &lt;&#x3D; 2020; i++) &#123; &#x2F;&#x2F; 循环，从1到2020        int temp &#x3D; i; &#x2F;&#x2F; 令temp&#x3D;i，方便后续判断字符2个数的操作        while (temp &gt; 0) &#123;            if (temp % 10 &#x3D;&#x3D; 2) &#123; &#x2F;&#x2F; 如果temp中最后一位是2                result++; &#x2F;&#x2F; result自增            &#125;            temp &#x2F;&#x3D; 10; &#x2F;&#x2F; temp&#x2F;&#x3D;10去掉最后一位数字        &#125;    &#125;    printf(&quot;%d&quot;, result);&#x2F;&#x2F; 输出结果    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小蓝要为一条街的住户制作门牌号。&lt;/p&gt;
&lt;p&gt;这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。&lt;/p&gt;
&lt;p&gt;小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。&lt;/p&gt;
&lt;p&gt;请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大运行时间：1s&lt;/li&gt;
&lt;li&gt;最大运行内存: 128M&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-质数</title>
    <link href="2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E8%B4%A8%E6%95%B0/"/>
    <id>2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E8%B4%A8%E6%95%B0/</id>
    <published>2023-04-02T06:29:27.000Z</published>
    <updated>2023-04-02T07:44:59.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们知道第一个质数是 22、第二个质数是 33、第三个质数是 55……</p><p>请你计算第 20192019 个质数是多少？</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><span id="more"></span><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int isPrime(int num) &#123;    &#x2F;&#x2F; 判断一个数字是不是质数，return 0代表不是质数， return 1 代表是质数    for (int i &#x3D; 2; i &lt; num; i++) &#123;        &#x2F;&#x2F; 循环中判断是否能被1或者它本身之外的数字整除，若能则不是质数，直接return 0        if (num % i &#x3D;&#x3D; 0) &#123;            return 0;        &#125;    &#125;    &#x2F;&#x2F; 循环结束都没发现能整除的其他数字，可以返回1    return 1;&#125;int main()&#123;    int count &#x3D; 0; &#x2F;&#x2F; 定义计数器，默认为0    int answer &#x3D; 0;    for (int i &#x3D; 2; count !&#x3D; 2019; i++) &#123; &#x2F;&#x2F; 从2开始循环是因为2是第一个质数，不要从1开始循环        if (isPrime(i) &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 若判断为是质数            count++; &#x2F;&#x2F; 计数器++；            answer &#x3D; i; &#x2F;&#x2F; 迭代更新answer        &#125;    &#125;    cout &lt;&lt; answer &lt;&lt; endl; &#x2F;&#x2F; 输出答案    return 0;&#125;</code></pre><ul><li>优化解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main() &#123;    int n &#x3D; 2019; &#x2F;&#x2F; 要计算的质数的位置    int num &#x3D; 3; &#x2F;&#x2F; 初始为3，因为第一个质数是2    int count &#x3D; 1; &#x2F;&#x2F; 已经找到了一个质数2，所以从1开始计数    while (count &lt; n) &#123;        num +&#x3D; 2; &#x2F;&#x2F; 只需要判断奇数是否为质数        bool isPrime &#x3D; true; &#x2F;&#x2F; 假设当前数是质数        for (int i &#x3D; 3; i &lt;&#x3D; sqrt(num); i +&#x3D; 2) &#123;            if (num % i &#x3D;&#x3D; 0) &#123;                isPrime &#x3D; false; &#x2F;&#x2F; 如果能被整除，则不是质数                break;            &#125;        &#125;        if (isPrime) &#123;            count++; &#x2F;&#x2F; 找到一个质数        &#125;    &#125;    cout &lt;&lt; num &lt;&lt; endl; &#x2F;&#x2F; 输出第2019个质数    return 0;&#125;</code></pre><ul><li>线性筛法（Linear Sieve）</li></ul><p>线性筛法是一种求解质数的算法，可以在$O(n)$的时间复杂度内预处理出小于等于$n$的所有质数。</p><p>线性筛法的基本思想是从小到大遍历每个正整数，如果它是质数，就将它加入质数数组中，并用它来筛掉它的倍数。在遍历过程中，对于每个数只会被它的最小质因子筛去，因此每个合数只会被筛一次，从而保证了线性时间复杂度。</p><p>下面是线性筛法的伪代码：</p><pre class="language-none"><code class="language-none">primes &#x3D; [] # 质数数组is_prime &#x3D; [True] * (n+1) # 标记是否为质数for i in range(2, n+1):    if is_prime[i]:        primes.append(i) # 将i加入质数数组    for j in range(len(primes)):        if i * primes[j] &gt; n:            break        is_prime[i * primes[j]] &#x3D; False # 将i*primes[j]标记为非质数        if i % primes[j] &#x3D;&#x3D; 0:            break # 如果i是primes[j]的倍数，就跳出循环</code></pre><blockquote><p>如果在内层循环中，$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</p><p>例如，当$i$为$2 \times 3&#x3D;6$时，在内层循环中，$i$会被$2$筛一次，被$3$筛一次，之后就不需要再被其他数筛了。因此，如果$i$是$primes[j]$的倍数，就可以跳出循环，不需要继续遍历$primes$数组中的其他质数。这样可以减少重复的筛选，提高算法的效率。</p></blockquote><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN &#x3D; 20000; &#x2F;&#x2F; 估计2019个质数的上限vector&lt;int&gt; primes; &#x2F;&#x2F; 存储质数bool isPrime[MAXN]; &#x2F;&#x2F; 标记是否为质数int main() &#123;    fill(isPrime, isPrime+MAXN, true); &#x2F;&#x2F; 初始化标记数组，全部设置为true    for (int i&#x3D;2; i&lt;MAXN; i++) &#123;        if (isPrime[i]) &#123; &#x2F;&#x2F; i是质数            primes.push_back(i); &#x2F;&#x2F; 将i加入质数数组            if (primes.size() &#x3D;&#x3D; 2019) &#123;                cout &lt;&lt; primes.back() &lt;&lt; endl;                break;            &#125;        &#125;        for (int j&#x3D;0; j&lt;primes.size() &amp;&amp; i*primes[j]&lt;MAXN; j++) &#123;            isPrime[i*primes[j]] &#x3D; false; &#x2F;&#x2F; 将i*primes[j]标记为非质数            if (i % primes[j] &#x3D;&#x3D; 0) break; &#x2F;&#x2F; 如果i是primes[j]的倍数，就跳出循环        &#125;    &#125;    return 0;&#125;</code></pre><blockquote><p>可以看到，线性筛法的实现相对简单，但需要注意以下几点：</p><ol><li>对于每个数只需要用它的最小质因子来筛去它的倍数，因此内层循环的终止条件为$i \times primes[j] &gt; n$。</li><li>在内层循环中，如果$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</li><li>在初始化标记数组时，除0和1外都初始化为True。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;我们知道第一个质数是 22、第二个质数是 33、第三个质数是 55……&lt;/p&gt;
&lt;p&gt;请你计算第 20192019 个质数是多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大运行时间：1s&lt;/li&gt;
&lt;li&gt;最大运行内存: 128M&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>leetcode968.监控二叉树</title>
    <link href="2023/03/29/leetcode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/29/leetcode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-29T06:23:53.000Z</published>
    <updated>2023-03-29T06:43:47.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/bst_cameras_01.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/bst_cameras_02.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>贪心算法</li></ul><p>本题是一道贪心算法的题目。通过对题目进行分析，我们可以发现有以下几种情况：</p><p>1.如果一个节点没有被监控，那么它必须要安装一个摄像头。</p><p>2.如果一个节点安装了摄像头，那么它的父节点就可以被监控了。</p><p>3.如果一个节点的子节点被监控了，那么这个节点也可以被监控。</p><p>因此，我们可以采用自下而上的方式进行处理，从叶子节点开始向根节点进行处理。对于每个节点，我们可以有三种状态：</p><p>0：该节点没有装摄像头，且它的子节点中也没有装摄像头的节点，此时应该给他装一个摄像头。</p><p>1：该节点没有装摄像头，但是它的子节点中至少有一个装摄像头的节点，此时应该给他的父节点装一个摄像头。</p><p>2：该节点装摄像头了，因此它无需再安装一个摄像头。</p><p>对于每个节点，我们可以采用递归的方式进行处理。当节点为叶子节点时，它的状态为0。对于其他节点，如果它的子节点中存在状态为0的节点，那么该节点的状态为1，表示需要安装摄像头。如果它的子节点中都存在状态为1或2的节点，那么该节点的状态为0，表示不需要安装摄像头，但是它的父节点需要安装摄像头。如果它的子节点中存在状态为2的节点，那么该节点的状态为1，表示不需要安装摄像头，因为它的子节点已经可以覆盖它了。</p><p>最后，根据根节点的状态来判断是否需要安装摄像头。如果根节点的状态为0或1，那么需要安装一个摄像头。如果根节点的状态为2，那么不需要安装摄像头。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minCameraCover(TreeNode* root) &#123;        int res &#x3D; 0;        if (dfs(root, res) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 根节点未被监控            res++;        &#125;        return res;    &#125;    int dfs(TreeNode* node, int&amp; res) &#123;        if (node &#x3D;&#x3D; nullptr) &#123;            return 2; &#x2F;&#x2F; 空节点不需要监控，返回2        &#125;        int left &#x3D; dfs(node-&gt;left, res);        int right &#x3D; dfs(node-&gt;right, res);        if (left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 左右子节点有未被监控的节点，该节点需要安装摄像头            res++; &#x2F;&#x2F; 安装了摄像头            return 1; &#x2F;&#x2F; return 1是指该节点没有被监控，但是它的子节点中至少有一个被监控的节点。        &#125; else if (left &#x3D;&#x3D; 1 || right &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 左右子节点中至少有一个节点被监控            return 2; &#x2F;&#x2F; return 2是指该节点被监控了。        &#125; else &#123; &#x2F;&#x2F; 左右子节点均被监控            return 0; &#x2F;&#x2F; return 0是指该节点没有装摄像头        &#125;    &#125;&#125;;</code></pre><blockquote><p>其中，dfs函数的返回值为当前节点的状态。如果返回值为0，表示当前节点需要安装摄像头；如果返回值为1，表示当前节点不需要安装摄像头，但是它的父节点需要安装摄像头；如果返回值为2，表示当前节点不需要安装摄像头。res为引用类型，表示安装摄像头的数量。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，我们在树的节点上安装摄像头。&lt;/p&gt;
&lt;p&gt;节点上的每个摄影头都可以监视&lt;strong&gt;其父对象、自身及其直接子对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算监控树的所有节点所需的最小摄像头数量。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode113.路径总和II</title>
    <link href="2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/"/>
    <id>2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</id>
    <published>2023-03-28T06:05:24.000Z</published>
    <updated>2023-03-28T06:24:39.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/pathsumii1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22输出：[[5,4,11,2],[5,8,4,5]]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/pathsum2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2], targetSum &#x3D; 0输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>本题可以使用深度优先搜索（DFS）求解。从根节点开始，依次搜索左子树和右子树，直到找到符合条件的路径。具体来说，我们可以使用递归的方式，每次遍历到一个节点时，将该节点加入路径中，并更新目标值。如果该节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径，将该路径加入结果数组中。否则，继续搜索左子树和右子树。在搜索之后，需要将当前节点从路径中删除，以便回溯到之前的状态。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        dfs(root, targetSum, res, path);        return res;    &#125;    void dfs(TreeNode* node, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;        if (!node) return;  &#x2F;&#x2F; 如果当前节点为空，则直接返回        path.push_back(node-&gt;val);  &#x2F;&#x2F; 将当前节点的值加入路径中        targetSum -&#x3D; node-&gt;val;     &#x2F;&#x2F; 更新目标值        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 如果当前节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径            res.push_back(path);    &#x2F;&#x2F; 将该路径加入结果数组        &#125; else &#123;            dfs(node-&gt;left, targetSum, res, path);   &#x2F;&#x2F; 搜索左子树            dfs(node-&gt;right, targetSum, res, path);  &#x2F;&#x2F; 搜索右子树        &#125;        path.pop_back();  &#x2F;&#x2F; 回溯：将当前节点从路径中删除，恢复到搜索之前的状态    &#125;&#125;;</code></pre><blockquote><p><code>path.pop_back()</code> 是 C++ 中 vector 容器的成员函数，用于删除 vector 容器中的最后一个元素。在本题中，由于我们在搜索过程中需要记录搜索路径，因此使用了一个 <code>path</code> 数组来保存路径。在每次搜索到一个新节点时，我们将该节点的值加入 <code>path</code> 数组中，如果搜索结束后未找到符合条件的路径，需要将该节点从 <code>path</code> 数组中删除，回溯到之前的状态，继续搜索其他节点。因此，在代码中，<code>path.pop_back()</code> 的作用是删除 <code>path</code> 数组中最后一个元素，以便回溯到之前的状态。</p></blockquote><p>时间复杂度分析：</p><p>本题的时间复杂度为$ O(N^2)$，其中 N 表示二叉树的节点数。在最坏情况下，二叉树的形态类似于一个单链表，此时需要遍历所有节点，时间复杂度为 $O(N)$。对于每个节点，由于需要将该节点加入路径中，时间复杂度为$ O(N)$，因此总时间复杂度为 $O(N^2)$。</p><p>空间复杂度分析：</p><p>本题的空间复杂度为 $O(N)$，其中 N 表示二叉树的节点数。递归调用的栈空间最多为 $O(N)$，路径数组的空间为 $O(N)$，因此总空间复杂度为 $O(N)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; 和一个整数目标和 &lt;code&gt;targetSum&lt;/code&gt; ，找出所有 &lt;strong&gt;从根节点到叶子节点&lt;/strong&gt; 路径总和等于给定目标和的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叶子节点&lt;/strong&gt; 是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode110.平衡二叉树</title>
    <link href="2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-27T07:36:41.000Z</published>
    <updated>2023-03-28T06:05:42.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/balance_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/balance_2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：true</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归但空间复杂度较高的解法</li></ul><p>本题可以使用递归的方法来解决。对于每一个节点，我们需要先递归遍历它的左右子树，计算它们的高度差。如果左右子树的高度差超过了1，那么这棵树就不是平衡二叉树。如果左右子树都是平衡二叉树，那么我们可以判断当前节点是不是平衡二叉树：如果左右子树的高度差不超过1，那么当前节点就是平衡二叉树。最后递归返回整棵树的平衡情况。</p><p>在递归函数中，我们需要同时返回当前节点的高度和平衡情况，因此可以使用pair&lt;int, bool&gt;来表示。其中，pair的第一个元素表示高度，第二个元素表示当前节点是否是平衡二叉树。同时，我们需要处理一些边界情况，例如空节点的高度为0，空节点也是平衡二叉树。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root).second;    &#125;        pair&lt;int, bool&gt; checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return make_pair(0, true);        &#125;        auto left &#x3D; checkBalance(node-&gt;left);        auto right &#x3D; checkBalance(node-&gt;right);        if (left.second &amp;&amp; right.second &amp;&amp; abs(left.first - right.first) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return make_pair(max(left.first, right.first) + 1, true);        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return make_pair(0, false);    &#125;&#125;;</code></pre><blockquote><p><code>pair</code>是C++ STL中的一个模板类，用于存储两个不同类型的变量。它将两个变量打包成一个整体，方便传递和使用。</p></blockquote><p>但是它的内存占用过高，因为对于每个节点，它都要单独存一个bool变量用于表示节点是否为二叉树的平衡结点。因此需要进行优化。</p><ul><li>递归，但优化内存占用</li></ul><p>在题目中，我们使用了<code>pair&lt;int, bool&gt;</code>来表示每个节点的高度和平衡情况，但是这种方法会浪费一定的空间，因为每个节点都需要存储一个<code>bool</code>类型的变量。实际上，我们只需要判断每个节点是否平衡，因此可以使用一个<code>int</code>类型的变量来表示平衡情况：-1表示不平衡，非0表示平衡并且代表节点的高度。这样就可以减少空间的使用。</p><p>同时，我们可以将返回值从<code>pair&lt;int, bool&gt;</code>改为<code>int</code>，表示当前节点的高度。如果当前节点不是平衡二叉树，那么直接返回-1，否则返回节点的高度。</p><p>C++代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root) !&#x3D; -1;    &#125;    int checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return 0;        &#125;        int left &#x3D; checkBalance(node-&gt;left);        int right &#x3D; checkBalance(node-&gt;right);        if (left !&#x3D; -1 &amp;&amp; right !&#x3D; -1 &amp;&amp; abs(left - right) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return max(left, right) + 1;        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
