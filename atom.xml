<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-03-14T02:16:31.959Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode102.二叉树的层序遍历</title>
    <link href="2023/03/14/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>2023/03/14/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-03-14T01:57:14.000Z</published>
    <updated>2023-03-14T02:16:31.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用队列辅助层序遍历</li></ol><p>注意看这个题的输入与输出，输出的动态数组的元素是元素为整型的数组，比如<code>[[3],[9,20],[15,7]]</code>.因此如果只定义一个队列辅助遍历，无法清晰的区分每层的元素应该插入到哪个数组中，比如如果只使用一个队列进行层次遍历，得到的结果只能是<code>[3,9,20,15,7]</code>，无法从这个结果中得知清晰的二叉树层次结构，所以在这里定义两个队列，首先向一个队列中塞入元素，接着对队首元素进行pop并且将队首元素的左右子树节点分别塞入另一队列中，再将结果数组并入result数组中，再将另一个队列进行同样的遍历操作，具体的C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        &#x2F;&#x2F; 定义两个队列 分别为q和another_q 用于层次遍历        queue&lt;TreeNode*&gt; q;        queue&lt;TreeNode*&gt; another_q;        &#x2F;&#x2F; 定义结果数组 其元素为元素为int类型的数组        vector&lt;vector&lt;int&gt;&gt; result;            &#x2F;&#x2F; 若根节点非空 则将根节点push进队列q中         if (root !&#x3D; nullptr) &#123;            q.push(root);        &#125;        &#x2F;&#x2F; 当q或者another_q队列非空时 进行遍历操作        while (!q.empty()|| !another_q.empty()) &#123;            &#x2F;&#x2F; 定义元素为int的临时数组 用于存储每一层的元素            vector&lt;int&gt; temp_vector;            &#x2F;&#x2F; 当队列q非空时 将队列q的元素逐个出队            while (!q.empty()) &#123;                TreeNode* temp_node &#x3D; q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;            &#x2F;&#x2F; 当另一个队列another_q非空时 将队列another_q的元素逐个出队            while (!another_q.empty()) &#123;                TreeNode* temp_node &#x3D; another_q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                another_q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;        &#125;        &#x2F;&#x2F; 返回结果数组        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;层序遍历&lt;/strong&gt; 。 （即逐层地，从左到</summary>
      
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode104.二叉树的最大深度</title>
    <link href="2023/03/13/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>2023/03/13/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2023-03-13T07:17:04.000Z</published>
    <updated>2023-03-13T07:50:43.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><pre class="language-none"><code class="language-none">  3 &#x2F; \9  20  &#x2F;  \ 15   7</code></pre><p>返回它的最大深度 3 。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>DFS（深度优先遍历）</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;      &#x2F;&#x2F; 如果当前节点为空，则返回0        if (root &#x3D;&#x3D; nullptr) return 0;      &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) return 1;        int left_depth &#x3D; -1, right_depth &#x3D; -1;      &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度        if (root-&gt;left !&#x3D; nullptr) &#123;            left_depth &#x3D; maxDepth(root-&gt;left);        &#125;      &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度        if (root-&gt;right !&#x3D; nullptr) &#123;            right_depth &#x3D; maxDepth(root-&gt;right);        &#125;      &#x2F;&#x2F; 返回左右子树深度的较大值加1        return max(left_depth, right_depth) + 1;    &#125;&#125;;</code></pre><ol start="2"><li>BFS（广度优先遍历）</li></ol><p>主要思路是使用一个队列来遍历整个二叉树。我们首先将根节点加入队列中，然后在每次循环中取出队列中的一层节点，将该层节点的左右子节点加入队列中。当遍历完所有节点时，队列中存储的即为最后一层节点，此时的深度即为树的深度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) &#123;            return 0;        &#125;        queue&lt;TreeNode*&gt; q;  &#x2F;&#x2F; 创建一个队列，用于BFS遍历        q.push(root);        &#x2F;&#x2F; 将根节点加入队列        int depth &#x3D; 0;       &#x2F;&#x2F; 初始化深度为0        while (!q.empty()) &#123; &#x2F;&#x2F; 当队列不为空时，继续遍历            int size &#x3D; q.size(); &#x2F;&#x2F; 记录队列中当前层的节点数量            for (int i &#x3D; 0; i &lt; size; i++) &#123; &#x2F;&#x2F; 遍历当前层的所有节点                TreeNode* node &#x3D; q.front();  &#x2F;&#x2F; 取出队列头部的节点                q.pop();                     &#x2F;&#x2F; 将该节点从队列中移除                if (node-&gt;left !&#x3D; NULL) &#123;    &#x2F;&#x2F; 如果该节点有左子节点，将其加入队列中                    q.push(node-&gt;left);                &#125;                if (node-&gt;right !&#x3D; NULL) &#123;   &#x2F;&#x2F; 如果该节点有右子节点，将其加入队列中                    q.push(node-&gt;right);                &#125;            &#125;            depth++;  &#x2F;&#x2F; 当前层遍历结束后，深度加1        &#125;        return depth; &#x2F;&#x2F; 返回树的深度    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;
&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明</summary>
      
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode111.二叉树的最小深度</title>
    <link href="2023/03/12/leetcode111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>2023/03/12/leetcode111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</id>
    <published>2023-03-12T11:56:24.000Z</published>
    <updated>2023-03-13T07:50:42.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ex_depth.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]输出：5</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>DFS（深度优先遍历）</li></ol><p>使用了递归的方式。首先判断根节点是否为空，如果为空，则返回深度为0；如果根节点没有左右子节点，返回深度为1；如果有左右子节点，则分别递归计算左子树和右子树的深度，取两者的较小值再加1，即为该树的最小深度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        &#x2F;&#x2F; 如果当前节点为空，则返回0        if (root &#x3D;&#x3D; nullptr) &#123;            return 0;        &#125;        &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;            return 1;        &#125;        int left_depth &#x3D; INT_MAX, right_depth &#x3D; INT_MAX;        &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度        if (root-&gt;left !&#x3D; nullptr) &#123;            left_depth &#x3D; minDepth(root-&gt;left);        &#125;        &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度        if (root-&gt;right !&#x3D; nullptr) &#123;            right_depth &#x3D; minDepth(root-&gt;right);        &#125;        &#x2F;&#x2F; 返回左右子树深度的较小值加1        return min(left_depth, right_depth) + 1;    &#125;&#125;;</code></pre><ol start="2"><li>BFS（广度优先遍历）</li></ol><p>该代码使用了队列来实现广度优先搜索，从根节点开始，逐层访问该节点的左右子节点，并将子节点及其所在的层数入队，直到找到叶子节点，即没有左右子节点的节点，此时返回该节点所在的层数即可。如果整个二叉树中没有叶子节点，则返回0。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return 0;        &#125;        &#x2F;&#x2F; 创建队列， 存储节点以及其所在的层数        queue&lt;pair&lt;TreeNode*, int&gt;&gt; q;        &#x2F;&#x2F; 将根节点和所在的层数入队        q.push(make_pair(root, 1));        while (!q.empty()) &#123;            &#x2F;&#x2F; 取出队首节点和所在的层数            TreeNode* node &#x3D; q.front().first;            int depth &#x3D; q.front().second;            q.pop();            &#x2F;&#x2F; 如果该节点为叶子节点， 直接返回其所在的层数            if (node-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; node-&gt;right &#x3D;&#x3D; nullptr) &#123;                return depth;            &#125;            &#x2F;&#x2F; 如果该节点有左子节点，则将其左子节点和所在的层数入队            if (node-&gt;left !&#x3D; nullptr) &#123;                q.push(make_pair(node-&gt;left, depth+1));                &#125;            &#x2F;&#x2F; 如果该节点有右子节点，则将其右子节点和所在的层数入队            if (node-&gt;right !&#x3D; nullptr) &#123;                q.push(make_pair(node-&gt;right, depth+1));                &#125;        &#125;        return 0;    &#125;&#125;;</code></pre><blockquote><p>一般来说，DFS和BFS的效率取决于二叉树的结构和分布。如果二叉树比较平衡，那么BFS可能更快，因为它可以更早地找到最小深度的叶子节点。如果二叉树比较不平衡，那么DFS可能更快，因为它可以避免访问很多不必要的节点。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;/p&gt;
&lt;p&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;叶子节点是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode25.K个一组翻转链表</title>
    <link href="2023/03/09/leetcode25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/09/leetcode25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-09T09:07:29.000Z</published>
    <updated>2023-03-09T09:22:48.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/reverse_ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2输出：[2,1,4,3,5]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/reverse_ex2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3输出：[3,2,1,4,5]</code></pre><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>编写一个函数，用于实现反转链表的核心逻辑，思路如下：</p><ul><li><p>初始化一个前驱节点prev和一个当前节点curr，分别指向空和头节点。</p></li><li><p>循环k次，每次做以下操作：</p><ul><li><p>保存当前节点的下一个节点next，以免丢失。</p></li><li><p>将当前节点的next指针指向前驱节点prev，实现反转。</p></li><li><p>将前驱节点prev更新为当前节点curr，为下一次反转做准备。</p></li><li><p>将当前节点curr更新为下一个节点next，继续遍历链表。</p></li></ul></li></ul><p>这样就可以将链表中的k个节点反转，并返回反转后的头尾指针。</p><blockquote><p>对以上函数进行一个图示说明：</p><p>假设链表为1-&gt;2-&gt;3-&gt;4-&gt;5，k为3，那么反转后的链表应该为3-&gt;2-&gt;1-&gt;4-&gt;5。</p><p>初始状态：</p><pre class="language-text" data-language="text"><code class="language-text">prev: nullcurr: 1next: 2null &lt;- prev   curr -> next -> 3 -> 4 -> 5</code></pre><p>第一次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 1curr: 2next: 3null &lt;- prev &lt;- curr   next -> 4 -> 5</code></pre><p>第二次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 2curr: 3next: 4null &lt;- prev &lt;- curr   next -> 5</code></pre><p>第三次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 3curr: 4next: 5null &lt;- prev &lt;- curr   next </code></pre><p>结束循环，返回{prev, head}即{3,1}。</p><pre class="language-text" data-language="text"><code class="language-text"> prev        head   |           |  v           v null&lt;-3&lt;-2&lt;-1    4->5 </code></pre></blockquote><p>代码的整体思路是：</p><ul><li>定义一个虚拟头节点dummy，指向原链表的头节点head，这样可以方便处理边界情况。</li><li>定义一个前驱节点prev，初始指向dummy，用来连接反转后的链表段。</li><li>用一个while循环遍历整个链表，每次循环做以下操作：<ul><li>定义一个尾部指针tail，初始指向头部指针head，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回dummy-&gt;next即可。</li><li>保存下一段链表的头部指针nextHead，并断开与当前段的连接。</li><li>调用反转函数reverseList，输入当前段的头部指针head和长度k，返回反转后的新头部和新尾部，并将其连接到前驱和下一段上。</li><li>更新前驱为新尾部，更新头部为下一段头部。</li></ul></li></ul><p>这样就可以将整个链表按照每k个节点进行反转，并返回dummy-&gt;next作为新链表的头节点。</p><p>代码的时间复杂度是O(n)，因为我们只需要遍历一次链表，每个节点最多被访问两次。 代码的空间复杂度是O(1)，因为我们只使用了常数个额外变量，没有使用递归或栈。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 定义反转链表的函数，输入一个链表头节点和一个长度k，返回反转后的头节点和尾节点    pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, int k) &#123;        &#x2F;&#x2F; 初始化前驱节点和当前节点        ListNode* prev &#x3D; nullptr;        ListNode* curr &#x3D; head;        &#x2F;&#x2F; 遍历k次，每次将当前节点指向前驱节点，并更新前驱和当前节点        for (int i &#x3D; 0; i &lt; k; i++) &#123;            ListNode* next &#x3D; curr-&gt;next; &#x2F;&#x2F; 保存下一个节点            curr-&gt;next &#x3D; prev; &#x2F;&#x2F; 反转指针            prev &#x3D; curr; &#x2F;&#x2F; 更新前驱            curr &#x3D; next; &#x2F;&#x2F; 更新当前        &#125;        &#x2F;&#x2F; 返回反转后的头节点和尾节点，即原来的尾节点和头节点        return &#123;prev, head&#125;;    &#125;    &#x2F;&#x2F; 定义leetcode 25的主函数，输入一个链表头节点和一个整数k，返回反转后的链表头节点    ListNode* reverseKGroup(ListNode* head, int k) &#123;        &#x2F;&#x2F; 初始化虚拟头节点和前驱节点        ListNode* dummy &#x3D; new ListNode(-1);        dummy-&gt;next &#x3D; head;        ListNode* prev &#x3D; dummy;                while (head !&#x3D; nullptr) &#123; &#x2F;&#x2F; 遍历链表直到为空            &#x2F;&#x2F; 初始化尾部指针为头部指针，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回虚拟头节点的下一个即可            ListNode* tail &#x3D; head;            for (int i &#x3D; 0; i &lt; k - 1; i++) &#123;                tail &#x3D; tail-&gt;next;                if (tail &#x3D;&#x3D; nullptr) return dummy-&gt;next;            &#125;                        &#x2F;&#x2F; 保存下一段链表的头部指针，并断开与当前段的连接            ListNode* nextHead &#x3D; tail-&gt;next;            tail-&gt;next &#x3D; nullptr;            &#x2F;&#x2F; 调用反转函数，得到反转后的新头部和新尾部，并将其连接到前驱和下一段上            auto reversedPair &#x3D; reverseList(head, k);            prev-&gt;next &#x3D; reversedPair.first;            reversedPair.second-&gt;next &#x3D; nextHead;            &#x2F;&#x2F; 更新前驱为新尾部，更新头部为下一段头部            prev &#x3D; reversedPair.second;            head &#x3D; nextHead;                    &#125;            return dummy-&gt;next;     &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你链表的头节点 &lt;code&gt;head&lt;/code&gt; ，每 &lt;code&gt;k&lt;/code&gt; 个节点一组进行翻转，请你返回修改后的链表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 &lt;code&gt;k&lt;/code&gt; 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode148.排序链表</title>
    <link href="2023/03/08/leetcode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/08/leetcode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-08T05:42:24.000Z</published>
    <updated>2023-03-10T08:26:30.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [4,2,1,3]输出：[1,2,3,4]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [-1,5,3,4,0]输出：[-1,0,3,4,5]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>为了解题而解题的解法</li></ol><p>建立一个动态数组nodes，将链表中的每个元素放入动态数组中，然后使用sort排序，接着将动态数组进行遍历，将每个数字新建一个节点放入结果链表中，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        vector&lt;int&gt; nodes;        while (head !&#x3D; nullptr) &#123;            nodes.push_back(head-&gt;val); &#x2F;&#x2F; 将链表的每个节点的值放入动态数组中            head &#x3D; head-&gt;next;        &#125;        sort(nodes.begin(), nodes.end()); &#x2F;&#x2F; 对动态数组中的元素进行排序        ListNode* sortedList &#x3D; nullptr;        ListNode** cur &#x3D; &amp;sortedList; &#x2F;&#x2F; 定义一个指向指针的指针 cur                for (auto node_num: nodes) &#123;            *cur &#x3D; new ListNode(node_num); &#x2F;&#x2F; 将排序好的数字加入新链表中            cur &#x3D; &amp;((*cur)-&gt;next);        &#125;        return sortedList; &#x2F;&#x2F; 返回链表头节点    &#125;&#125;;</code></pre><blockquote><p>这段代码涉及了指针和地址的操作，可以解读为：</p><p>​        ListNode** cur：定义一个指向指针的指针 cur</p><p>​        &amp;sortedList：获取 sortedList 的地址，也就是一个指向指针 sortedList 的指针</p><p>​        cur &#x3D; &amp;sortedList：将 sortedList 的地址赋值给 cur，此时 cur 指向 sortedList 的指针</p><p> 这样做的目的是为了可以更改 sortedList 的指针，从而修改链表结构。在 for 循环中，*cur 表示指针 cur 所指向的指针，即 sortedList 的指针，将新的节点插入到 sortedList 后，cur 需要指向插入节点的 next 指针，因此使用了 cur &#x3D; &amp;((*cur)-&gt;next) 的写法。</p></blockquote><ol start="2"><li>归并排序</li></ol><p>归并排序的思路如下：利用快慢指针将链表分为左链表和右链表，分而治之，将分得的两个链表进行再一次分割和归并，最终归并得到结果。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    &#x2F;&#x2F; 归并排序    ListNode* sortList(ListNode* head) &#123;        &#x2F;&#x2F; 如果链表为空或只有一个节点，直接返回        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) return head;        &#x2F;&#x2F; 找到链表的中点，用快慢指针法        ListNode* slow &#x3D; head; &#x2F;&#x2F; 慢指针，每次走一步        ListNode* fast &#x3D; head-&gt;next; &#x2F;&#x2F; 快指针，每次走两步        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;            slow &#x3D; slow-&gt;next; &#x2F;&#x2F; 慢指针走到中点            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走到末尾或者null        &#125;        &#x2F;&#x2F; 将链表从中点断开为两个子链表        ListNode* mid &#x3D; slow-&gt;next;         slow-&gt;next &#x3D; nullptr;        &#x2F;&#x2F; 对左右子链表分别进行排序        ListNode* left &#x3D; sortList(head);         ListNode* right &#x3D; sortList(mid);        &#x2F;&#x2F; 合并两个有序的子链表为一个有序的链表        return mergeTwoLists(left, right);    &#125;    &#x2F;&#x2F; 合并两个有序的链表为一个有序的链表    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        &#x2F;&#x2F; 创建一个哑节点作为合并后链表的头结点        ListNode dummy(0);        &#x2F;&#x2F; 创建一个指针cur指向当前合并后链表的最后一个节点，初始为哑节点        ListNode* cur &#x3D; &amp;dummy;        &#x2F;&#x2F; 当l1和l2都不为空时，比较它们的值，将较小的值接在cur后面，并更新对应的指针while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;if (l1-&gt;val &lt; l2-&gt;val) &#123; cur-&gt;next &#x3D; l1; l1 &#x3D; l1-&gt;next;&#125; else &#123; cur-&gt;next &#x3D; l2; l2 &#x3D; l2-&gt;next;&#125;cur &#x3D; cur-&gt;next; &#125;        &#x2F;&#x2F; 当l1或l2有一个为空时，直接将另一个非空的链表接在cur后面即可        if (l1 !&#x3D; nullptr) cur-&gt;next &#x3D; l1;        if (l2 !&#x3D; nullptr) cur-&gt;next &#x3D; l2;        return dummy.next;  &#x2F;&#x2F; 返回哑节点的下一个节点，即合并后链表的头结点    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你链表的头结点 &lt;code&gt;head&lt;/code&gt; ，请将其按 &lt;strong&gt;升序&lt;/strong&gt; 排列并返回 &lt;strong&gt;排序后的链表&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode142.环形链表II</title>
    <link href="2023/03/06/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <id>2023/03/06/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</id>
    <published>2023-03-06T12:44:53.000Z</published>
    <updated>2023-03-06T14:22:34.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist-20230306204553902.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test2-20230306204600878.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2], pos &#x3D; 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test3-20230306204608161.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1], pos &#x3D; -1输出：返回 null解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用hashset存储链表元素的地址，当使用快慢指针确定环形链表存在时，返回相应的环形节点。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#x2F;&#x2F; 如果链表为空或者只有一个元素，则返回null            return nullptr;         ListNode* slow &#x3D; head;        ListNode* fast &#x3D; head-&gt;next;        while (slow !&#x3D; fast) &#123;            if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) return nullptr;            fast &#x3D; fast-&gt;next-&gt;next;            slow &#x3D; slow-&gt;next;        &#125;        &#x2F;&#x2F;此时已经发现有环了，使用hashset存储链表元素地址，若有相同地址的元素就返回该元素        unordered_set&lt;ListNode*&gt; nodes;        ListNode* cur &#x3D; head;        while (cur !&#x3D; nullptr) &#123;            if (nodes.count(cur)) &#123;                return cur;            &#125;            else &#123;                nodes.insert(cur);                cur &#x3D; cur-&gt;next;            &#125;        &#125;        return nullptr;    &#125;&#125;;</code></pre><ol start="2"><li>快慢指针法</li></ol><p>利用快慢指针，找到链表中是否存在环。若存在环，则将快指针重新指向链表的头结点，并将快慢指针以相同的速度向前移动，直到两个指针相遇，即为环的入口节点。</p><p>假设链表的长度为L，环的长度为C，环的入口节点距离头节点的距离为A，快慢指针相遇的节点距离环的入口节点的距离为B。</p><p>当快慢指针相遇时，快指针走过的距离是慢指针的两倍，即：$2 \times (A + B) &#x3D; A + B + n \times C$其中n是快指针在环中走过的圈数。化简得：$A &#x3D; (n - 1) \times C + (C - B)$。这个式子的意义是，从头节点到环的入口节点的距离等于从相遇点到环的入口节点的距离加上(n - 1)圈的环的长度。</p><p>因此，如果让一个新的指针cur从头节点开始走，同时让slow从相遇点开始走，每次都走一步，那么它们会在环的入口节点相遇，因为它们走过的距离都是A。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        &#x2F;&#x2F; 判断链表是否为空或只有一个元素        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) &#123;            return NULL;        &#125;        &#x2F;&#x2F; 定义快慢指针，初始值指向头结点        ListNode* fast &#x3D; head;        ListNode* slow &#x3D; head;        &#x2F;&#x2F; 判断是否存在环        while (fast !&#x3D; NULL &amp;&amp; fast-&gt;next !&#x3D; NULL) &#123;            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走两步            slow &#x3D; slow-&gt;next;       &#x2F;&#x2F; 慢指针走一步            if (fast &#x3D;&#x3D; slow) &#123;      &#x2F;&#x2F; 快慢指针相遇                ListNode* start &#x3D; head; &#x2F;&#x2F; 从头结点开始，与慢指针同时前进，相遇点即为环的起点                while (start !&#x3D; slow) &#123;                    start &#x3D; start-&gt;next;                    slow &#x3D; slow-&gt;next;                &#125;                return start;            &#125;        &#125;        return NULL; &#x2F;&#x2F; 遍历完链表，仍未找到环，返回NULL    &#125;&#125;;</code></pre><blockquote><p>注：在 while 循环中，因为 fast 比 slow 快，所以应该先判断 fast 是否为 NULL 或 fast-&gt;next 是否为 NULL，以保证程序的正确性。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个链表的头节点  &lt;code&gt;head&lt;/code&gt; ，返回链表开始入环的第一个节点。 &lt;em&gt;如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 &lt;code&gt;next&lt;/code&gt; 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（&lt;strong&gt;索引从 0 开始&lt;/strong&gt;）。如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;strong&gt;注意：&lt;code&gt;pos&lt;/code&gt; 不作为参数进行传递&lt;/strong&gt;，仅仅是为了标识链表的实际情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不允许修改&lt;/strong&gt; 链表。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode160.相交链表</title>
    <link href="2023/03/06/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/06/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-06T07:18:58.000Z</published>
    <updated>2023-03-06T07:20:59.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><span id="more"></span><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><img src="http://cdn.leafii.top/img/160_statement.png" alt="img" loading="lazy"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/160_example_1_1.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3输出：Intersected at &#39;8&#39;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/160_example_2.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1输出：Intersected at &#39;2&#39;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/160_example_3.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。</code></pre><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>尾部对齐法</li></ol><p>因为当两链表相交时，它们从相交的节点开始到尾节点都是重叠的，因此首先依次遍历两个链表，获取两个链表的长度，然后将长度更长的链表进行对齐操作，之后分别比较对齐后的两链表的元素，若不相等，则分别迭代为next指针指向的元素，若两元素相等，则返回任意一个元素，若不相等，则遍历结束后返回<code>null</code>.</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        &#x2F;&#x2F; 分别计算两个链表的长度        int lenA &#x3D; 0, lenB &#x3D; 0;        ListNode* curA &#x3D; headA;        ListNode* curB &#x3D; headB;        while (curA) &#123;            lenA++;            curA &#x3D; curA-&gt;next;        &#125;        while (curB) &#123;            lenB++;            curB &#x3D; curB-&gt;next;        &#125;        &#x2F;&#x2F; 将较长的链表向后移动，使它们的尾部对齐        curA &#x3D; headA;        curB &#x3D; headB;        if (lenA &gt; lenB) &#123;            for (int i &#x3D; 0; i &lt; (lenA - lenB); i++) &#123;                curA &#x3D; curA-&gt;next;            &#125;        &#125;        else &#123;            for (int i &#x3D; 0; i &lt; (lenB - lenA); i++) &#123;                curB &#x3D; curB-&gt;next;            &#125;        &#125;        while (curA !&#x3D; curB) &#123;            curA &#x3D; curA-&gt;next;            curB &#x3D; curB-&gt;next;        &#125;        if (curA !&#x3D; nullptr) return curA;                return nullptr;    &#125;    &#125;;</code></pre><ol start="2"><li>使用哈希表</li></ol><p>使用一个哈希表存储一个链表的所有元素的地址，接着对另一个链表进行遍历，若另一个链表中有元素的地址和哈希表中的链表地址相等，则返回该元素，否则遍历结束后返回<code>null</code></p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        unordered_set&lt;ListNode*&gt; nodes; &#x2F;&#x2F;使用unordered_set存储链表A的各个元素的地址        while (headA) &#123;            nodes.insert(headA);            headA &#x3D; headA-&gt;next;        &#125;        while (headB) &#123;            if (nodes.count(headB)) &#123; &#x2F;&#x2F; 判断headB的元素地址是否在unordered_set中                return headB;            &#125;            headB &#x3D; headB-&gt;next;        &#125;        return nullptr;    &#125;&#125;;</code></pre><blockquote><p>需要注意的是在C++中因为<code>ListNode</code>没有定义比较方法，所以在这里使用的是 <code>unordered_set&lt;ListNode*&gt;</code></p></blockquote><ol start="3"><li>”快慢指针“法</li></ol><p>使用两个指针分别指向两个链表的头结点，分别进行遍历，若指针在遍历时遍历到了尾节点，则令指向尾节点的指针指向另一个链表的头结点，若两个链表有相交，即有重叠部分时，这两个指针终究会相遇，此时返回相遇的指针即可，若不能相遇，则返回<code>null</code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        &#x2F;&#x2F; &quot;快慢指针&quot;        ListNode* pointA &#x3D; headA;        ListNode* pointB &#x3D; headB;        while (pointA !&#x3D; pointB) &#123;            pointA &#x3D; pointA !&#x3D; nullptr? pointA-&gt;next: pointA &#x3D; headB;            pointB &#x3D; pointB !&#x3D; nullptr? pointB-&gt;next: pointB &#x3D; headA;        &#125;        if (pointA !&#x3D; nullptr) return pointA; &#x2F;&#x2F; 需要注意在遍历结束后判断pointA（或pointB)是否为null        return nullptr;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个单链表的头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode141.环形链表</title>
    <link href="2023/03/05/leetcode141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/05/leetcode141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-05T08:19:39.000Z</published>
    <updated>2023-03-06T07:24:16.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test2.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2], pos &#x3D; 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test3.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1], pos &#x3D; -1输出：false解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用快慢指针判断是否存在环，如果快指针走到了链表尾部，则直接返回false，若快指针追上了慢指针，则说明链表存在环。C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return false;        ListNode* slow &#x3D; head;        ListNode* fast &#x3D; head-&gt;next;        while (fast !&#x3D; slow) &#123;            &#x2F;&#x2F; 若fast指针走至链表尾部            if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) return false;            fast &#x3D; fast-&gt;next-&gt;next;            slow &#x3D; slow-&gt;next;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 &lt;code&gt;next&lt;/code&gt; 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。&lt;strong&gt;注意：&lt;code&gt;pos&lt;/code&gt; 不作为参数进行传递&lt;/strong&gt; 。仅仅是为了标识链表的实际情况。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果链表中存在环&lt;/em&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; 。 否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>一种基于知识图谱的离散制造车间资源分配优化方法</title>
    <link href="2023/03/02/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%A6%BB%E6%95%A3%E5%88%B6%E9%80%A0%E8%BD%A6%E9%97%B4%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>2023/03/02/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%A6%BB%E6%95%A3%E5%88%B6%E9%80%A0%E8%BD%A6%E9%97%B4%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</id>
    <published>2023-03-02T08:53:33.000Z</published>
    <updated>2023-03-13T14:10:16.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>这篇论文主要介绍了一种基于知识图谱的资源分配优化方法，用于离散制造车间。该方法利用知识图谱整合工程语义信息，包括大规模生产因素（过程、设备、人员、材料）的各种数据类型，以帮助优化资源分配。通过深度推理设备和过程之间的隐含关系，知识图谱可以生成热更新的知识图谱，从而驱动生产资源分配，并允许快速决策订单插入请求。此外，该方法还采用了社区设备方法进行资源分配，并结合模糊层次法进行候选设备集的构建和评估。实验结果表明，该方法可以有效地提高资源利用率和生产效率，并适应不同类型的生产任务。</p><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>随着动态个性化订单需求和不确定制造资源可用性的增加，如何实现智能资源优化分配成为了制造车间面临的重要挑战。传统的资源分配方法往往无法充分利用工程语义信息，也无法适应不同类型的生产任务。因此，本文提出了一种基于知识图谱和社区设备方法的资源分配优化方法，旨在整合工程语义信息、提高资源利用率和生产效率，并适应不同类型的生产任务。该方法的贡献包括：</p><p>1）提出了一种基于知识图谱的决策框架，用于支持资源分配的优化方法；</p><p>2）开发了一种分布式表示学习算法，用于挖掘复杂工程数据之间的隐式关系，增强车间资源之间的联系；</p><p>3）提出了一种基于候选设备集的三阶段方法，在混合模型生产过程中使用WRKG为候选设备的形成和评估提供相关数据支持；</p><p>4）通过在航空加工车间中使用生产任务对所提出的方法进行了评估，证明了该方法能够提高设备利用率和灵活性，同时保持稳定加工。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>讨论了制造业资源分配中与订单插入相关的基本问题，即如何匹配订单请求。文章重点回顾了现有的制造业资源分配研究工作，侧重于知识表示和建模方法。</p><h4 id="Knowledge-representation-and-modeling-of-manufacturing-resources"><a href="#Knowledge-representation-and-modeling-of-manufacturing-resources" class="headerlink" title="Knowledge representation and modeling of manufacturing resources"></a>Knowledge representation and modeling of manufacturing resources</h4><p>讨论了制造业中资源分配问题中的知识表示和建模方法。现有的知识表示和建模方法（如本体学）在处理大规模知识时存在灵活性和计算效率方面的限制。因此，研究者提出了基于知识图谱的决策框架和改进的知识表示学习算法，以挖掘复杂工程数据之间的隐含语义关系，提供更全面的知识支持资源分配决策。文章认为现有的方法不能直接应用于制造业，因为制造数据复杂多样，存在许多规则和约束，导致制造资源的语义表示和建模困难。</p><h4 id="Optimization-of-resource-configuration"><a href="#Optimization-of-resource-configuration" class="headerlink" title="Optimization of resource configuration"></a>Optimization of resource configuration</h4><p>介绍了混合模式车间动态生产环境下资源分配研究的优化方法、模型和算法。文章总结了鲁棒方法、智能优化方法和重新调度方法的优缺点，并列举了相关文献。鲁棒方法广泛研究用于优化车间资源分配，智能优化方法利用各种智能算法和优化方法进行动态资源分配，重新调度方法具有良好的时效性。这些方法都有其适用范围，但没有考虑车间中所包含的丰富语义信息。作者提出使用知识图谱来提供资源分配方法所需的信息，并提高生产决策的智能水平。因此，本文的主要贡献是使用知识图谱创新地提供资源分配方法所需的信息，并从知识层面提高生产决策的智能水平。</p><p><img src="http://cdn.leafii.top/img/image-20230306165544044.png" alt="image-20230306165544044" loading="lazy"></p><h3 id="The-WRKG-modeling-method-for-production-process"><a href="#The-WRKG-modeling-method-for-production-process" class="headerlink" title="The WRKG modeling method for production process"></a>The WRKG modeling method for production process</h3><p>为了整合车间资源知识，支持插单资源分配方式。 WRKG模型的建立是为了获取和融合与加工资源相关的数据，包括WRKG的定义、与设备和加工相关的信息规范。然后生成与加工相关的WRKG。此外，为了丰富和更新 WRKG，挖掘制造中的隐式关系，开发了一种改进的表示学习算法。</p><h4 id="Construction-of-the-WRKG"><a href="#Construction-of-the-WRKG" class="headerlink" title="Construction of the WRKG"></a>Construction of the WRKG</h4><p>为了将生产车间的大量半结构化和非结构化数据转化为结构化知识，设计了WRKG构建框架，整合车间设备资源，如图2所示。</p><p><img src="http://cdn.leafii.top/img/image-20230309204056952.png" alt="image-20230309204056952" loading="lazy"></p><p>它由三部分组成。</p><ol><li>首先，获取车间制造的历史数据、工艺文件数据和实时工艺数据。</li><li>其次，对制造相关信息进行知识融合处理，建立加工知识本体模型。车间资源的实体和关系存储在图数据库中。</li><li>然后利用本体规则支持的推理方法和分布式表示学习来识别与机加工车间使用的设备相关的隐式关系信息。</li><li>最后将隐含关系信息和知识应用信息反馈给数据采集端，动态更新车间资源之间的关系。</li></ol><p>为了构建 WRKG，车间资源信息由三元组构建，结合生产要素中的机器-材料-方法，如图 3 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230312214619994.png" alt="image-20230312214619994" loading="lazy"></p><p>三层结构包括类别层、概念层和实体层。<strong>资源类层</strong>由四个部分组成，代表车间的<strong>生产要素</strong>，包括设备、产品、过程和操作。<strong>中间层</strong>是资源类别层对应的<strong>各类生产资源</strong>，有利于本体的概念形成。<strong>底层</strong>是各类工坊资源的<strong>实体信息</strong>。这有助于开发大型车间资源的知识图谱，为设备资源之间的关系推断提供数据支持。</p><h5 id="Modeling-of-the-WRKG-of-machining-device"><a href="#Modeling-of-the-WRKG-of-machining-device" class="headerlink" title="Modeling of the WRKG of machining device"></a>Modeling of the WRKG of machining device</h5><p>本节基于WRKG框架来描述WRKG的定义。</p><p>**Definition 1.**机加工车间设备概念本体可以形式化定义为$o&#x3D;〈T,S,P,R,A〉$，其含义如下：</p><p><strong>T</strong>是术语抽象，主要是图3中的中间层设备类。<strong>S</strong>是同义词融合，由多个术语消歧后形成一个唯一的术语，如高速钢车刀、硬质合金车刀都归为车刀。<strong>P</strong>为属性抽象，$P &#x3D; { BasI(i), FunI(i), StaI(i)}$，其中$BasI(i)$表示设备$i$的基本信息，如设备位置、设备名称、设备编号等.$FunI(i)$ 表示关于设备$ i $的功能信息，例如可加工的腔体、复杂的表面零件。$StaI(i)$表示设备$i$的状态信息，取值0、1、2、3、4分别代表idle、full-load、overload、failure(怠速、满载、过载和故障)。设备附带的基本属性和功能属性是<strong>静态信息</strong>，状态属性是动态信息。此外，设备的状态基于传感器和MES（制造执行系统）实时更新。</p><p><strong>R</strong>是关系抽象，它基于P中的三个属性，关系包括“has_a”、“has_tool”、“has_status”等。在加工过程中，设备节点之间的关系有动态和静态的变化. &lt;概念实例、属性关系触发词、属性值&gt;三元组用于描述设备的基本信息，如&lt;Machine, has_a, Position&gt;。</p><p><strong>A</strong>$(A(i)∈A)$是一种规则，用于约束和规范设备的形成。其中，设备元描述为$M(i)&#x3D;{ BasI(i),FunI(i),StaI(i)}∈M⇒M(i)∈P$。设备模型可表示为$M &#x3D; ∑^n_{i &#x3D;1}M(i)$。机床设备数据模型M的约束规则如表2所示。</p><p><img src="http://cdn.leafii.top/img/image-20230312221444700.png" alt="image-20230312221444700" loading="lazy"></p><p>根据<strong>Definition 1</strong> 中给出的信息，开发了加工装置的概念模型（见图 4）。</p><p><img src="http://cdn.leafii.top/img/image-20230312221852950.png" alt="image-20230312221852950" loading="lazy"></p><h5 id="Formation-of-the-WRKG-of-device-relationship-network"><a href="#Formation-of-the-WRKG-of-device-relationship-network" class="headerlink" title="Formation of the WRKG of device relationship network"></a>Formation of the WRKG of device relationship network</h5><p>**Definition 2.**机加工车间设备集的知识图可以定义为$G&#x3D;〈MI,RI,PI,G〉$，其意义如下。</p><p><strong>MI</strong>是设备信息集，指的是图3中底层的设备资源<strong>（实体）</strong>，如车床、数控铣床、加工中心等。</p><p><strong>RI</strong>是设备之间的关系。Definition 1中已经用详细信息对器件实体进行了建模，但在加工过程中器件之间仍然存在复杂多变的关系，包括顺序关系、排他关系和并行关系。具体信息如下：</p><p>a) <strong>顺序关系</strong>是设备链接在加工过程中的全局关联形式。例如，设备M1和M2的顺序关系可以表示为Sequence(M1,M2)。</p><p>b) <strong>排他关系</strong>是设备链路在处理过程中的局部关联形式。 以设备M1和M2为例，如果在选择的分支结构中都在同一条分支路径上，则可以指定设备M1和M2之间存在排他关系，即Exclusive(M1, M2) .</p><p>c) <strong>并联关系</strong>是机械加工过程中常见的设备组织关系。 例如，如果设备M1和M2在并联分支结构中有不同的分支路径，则它们之间的关系可以定义为并联关系，即Parallel(M1,M2)。</p><p><strong>PI</strong>是基于制造过程信息流的<strong>过程需求信息</strong>（见图5），主要包括设备、工具、夹具、量具、量具、标识符、操作员和传感器。</p><p><img src="http://cdn.leafii.top/img/image-20230313170059637.png" alt="image-20230313170059637" loading="lazy"></p><p><strong>G</strong>是机加工车间的设备制造资源，可以描述为一个三元组$G&#x3D;{(h,l,t)}∈(MI×RI×PI)∩o$，其中$h$是WRKG的头实体，$t$是WRKG 的尾部实体，$l$是头尾实体之间的关系。结构件的制造涉及多道工序，需要多台设备才能完成规定的加工任务。</p><p>这样，可以利用集成的信息开发全面的设备关系网络。</p><h4 id="Knowledge-representation-learning-and-mining-of-the-WRKG"><a href="#Knowledge-representation-learning-and-mining-of-the-WRKG" class="headerlink" title="Knowledge representation learning and mining of the WRKG"></a>Knowledge representation learning and mining of the WRKG</h4><p>为进一步高效挖掘机加工车间资源间的隐含关系，为支持资源分配决策提供更全面的知识，提出了一种改进的分布式表示学习方法，该方法在头尾实体中加入<strong>语义权重向量</strong>$θ_i∈\mathbb R^k$对应关系 $l_i ∈ \mathbb R^k$。机加工车间资源信息知识表示模型描述如下：</p><p>$h_i &#x3D; h \circ \theta_i^h$</p><p>$t_i &#x3D; t \circ \theta_i^t$</p><p>其中$∘$为hadamma乘积算子（矩阵对应相乘相加），$h_i$和$t_i$分别由关系$l_i$语义下的头尾实体向量表示。为了提高机加工车间资源数据的语义关联准确性，基于马氏距离（表示点与一个分布之间的距离）<strong>计算设备资源的相似度</strong>。发现车间资源实体之间的隐式关系。得分函数如下所示：</p><p>$f_l(h,t) &#x3D; (h_i \circ \theta^h_i + l_i - t_i \circ \theta_i^t)W_l(h_i \circ \theta_i^h + l_i - t_i \circ \theta_i^t)$</p><p>其中$f_l(h,t)$是车间资源数据三元组的得分函数，$W_l$是自适应度量对应的特定关系对称非负权重矩阵。</p><p>优化目标函数如下：</p><p>$min \sum_{(h,l,t) \in \Delta(h’,l’,t’)\in \Delta’}[f_l(h,t) + \gamma - f_{l’}(h’,t’)]<em>+ + \lambda(\sum</em>{l \in L}||W_l||<em>F^2)+C(\sum</em>{e \in E ||e||<em>2^2} + \sum</em>{l\in L}||l||_2^2) $</p><p>$[W_l]_{ij} \geq 0$</p><p>其中，$[\cdot]_+$是取0和一个大的值的max值，$\gamma$是正负三元组的最大语义边界间隔， $|| \cdot||_F$是矩阵的F范数，C控制缩放度，λ控制自适应权重矩阵的正则化。可以通过将式（6）的导数设为0来求解Wl，以提高计算效率。</p><p><img src="http://cdn.leafii.top/img/image-20230313170345648.png" alt="image-20230313170345648" loading="lazy"></p><h3 id="A-three-staged-method-based-on-the-WRKG-for-resource-allocation-optimization"><a href="#A-three-staged-method-based-on-the-WRKG-for-resource-allocation-optimization" class="headerlink" title="A three-staged method based on the WRKG for resource allocation optimization"></a>A three-staged method based on the WRKG for resource allocation optimization</h3><p>本节提出了一个结合了WRKG以驱动设备资源调度优化的三阶段方法。该方法的每个阶段都利用相应的先前生成的制造知识，在认知层面提升资源分配决策的智能性。该方法可以将制造订单要求与机加工车间的WRKG联系起来。<strong>决策过程利用了WRKG信息，并且可以学习设备评估策略以形成指导后续生产的新知识。</strong>它包含的三个阶段如下：</p><ul><li>使用模糊层次方法所需的索引构造候选设备集。</li><li>利用基于社区的设备制造资源评价模型，从设备利用率方面对候选设备集进行评价和优化。</li><li>针对处理设备组的配置优化，建立了资源分配数学模型。</li></ul><h4 id="Mathematical-model-of-manufacturing-resource-reconfiguration"><a href="#Mathematical-model-of-manufacturing-resource-reconfiguration" class="headerlink" title="Mathematical model of manufacturing resource reconfiguration"></a>Mathematical model of manufacturing resource reconfiguration</h4><p>由2.2的分析，可以得到机械车间资源配置的数学模型。假定加工任务中的结构件是$J&#x3D;{J_1, J_2, …, J_i, …, j_n}$，其中加工过程的j节点被视为$O_j, j&#x3D;1,2,…,n_T$，其中$n_T$是操作的总数。可用设备域被设置为设备组$G&#x3D;{G_1, G_2,…,G_t,…,G_T}$，设备节点$M&#x3D;{M_1,M_2,…,M_k,…,M_m}$，因此$G_j$表示在过程$O_j$中正在处理的设备组，并且包含了一个设备节点集$M_j \in M$。过程$O_j$在设备节点$M_k$上的处理时间用$pt_{jk}$表示，使用$tt_{mn}$表示设备节点$M_m$和$M_n$之间的转移时间。$ST_{kj}$表示过程$O_j$在设备节点$M_k$的加工开始时间，并且$ET_{kj}$表示过程$O_j$在设备节点$M_k$上的加工结束时间。$C_i$是工件i节点的完成时间。$W_k$表示设备节点M_k的工作负载，以负载率作为衡量标准。基于以上描述，以下目标函数被定义。</p><p><img src="http://cdn.leafii.top/img/image-20230313202944346.png" alt="image-20230313202944346" loading="lazy"></p><p>上面的式子需要满足以下限制:<br>$ST_{kj} &#x3D; ET_{m(j-1)} + pt_{mk}$</p><p>这个目标是为了最小化处理时间和设备资源的负载。该限制表明在之前的处理完成之后设备之间的转移时间需要被考虑进去。</p><h5 id="Formation-of-the-candidate-device-sets"><a href="#Formation-of-the-candidate-device-sets" class="headerlink" title="Formation of the candidate device sets"></a>Formation of the candidate device sets</h5><p>结构件的生产涉及各种各样的设备。因此，基于WRKG的候选设备编队如图6所示，用于对特定进程进行资源匹配。</p><p><img src="http://cdn.leafii.top/img/image-20230313205031018.png" alt="image-20230313205031018" loading="lazy"></p><p>特定的评估指标用于选择设备以构建可选设备集。基于3.1.1节（Modeling of the WRKG of machining device）提出的制造设备信息模型，有五项设备资源评价指标，包括<strong>工件特征、加工特征、加工类型、加工精度和运行状态</strong>。这些指标具有层次结构。在这项研究中，模糊层次分析法被用来量化指标之间的关系。它的<strong>优点</strong>是可以为具有明显层次结构信息的各个评价指标分配权重。该方法可用于结构件制造过程中从<strong>指标集</strong>和<strong>对象集</strong>两个方面筛选设备资源。该方法的实现分为以下几个步骤。</p><ol><li>在指标集方面，利用WRKG提供的设备间丰富的相关性信息，建立了五类评价指标的模糊矩阵$R_{ij}$。</li><li>就对象集而言，为每个评价指标分配权重，通过计算指标间的标准差$σ_j$生成设备权重向量$W_j$。</li><li>在确定不同设备的权重向量后，引入相关系数 $ξ_i(k)$来提高设备资源的匹配精度。</li><li>通过将设备信息与过程知识相关联，得到每个候选设备资源对应指标的相关系数。</li><li>进一步计算处理任务中设备与进程信息之间的资源相似度匹配度$\gamma_s$。</li><li>最终选择符合生产要求的设备。</li></ol><h5 id="Evaluation-and-optimization-of-the-candidate-device-sets"><a href="#Evaluation-and-optimization-of-the-candidate-device-sets" class="headerlink" title="Evaluation and optimization of the candidate device sets"></a>Evaluation and optimization of the candidate device sets</h5><p>候选设备在设置后需要基于社区技术进行<strong>评估</strong>和<strong>优化</strong>。在这项研究中，社区包括几个具有共同功能和属性的共享通信节点的机床。换句话说，它可以基于通信节点对设备进行集群，以方便设备的统一组织。开发了基于社区的处理的评估模型（见图 7）。</p><p><img src="http://cdn.leafii.top/img/image-20230313220047285.png" alt="image-20230313220047285" loading="lazy"></p><ul><li>首先，WRKG<strong>提供</strong>评估方法所需的<strong>相关信息</strong>，包括设备组的组成信息和当前状态信息。</li><li>其次，如果评估需要优化，进行评估分析，及时合理分配社区设备。</li><li>最后，将各器件集的分析调整方案应用到WRKG中，形成新的器件集逻辑关系和组织形式，<strong>指导后续制造过程（更新）</strong>。</li></ul><p>社区的动态调整主要针对单台机床的负载率，旨在通过加工任务的重新分配优化机床资源的配置。评价优化算法如下：</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;这篇论文主要介绍了一种基于知识图谱的资源分配优化方法，用于离散制造车间。该方法利用知识图谱整合工程语义信息，包括大规模生产因素（过程、设备、人员、材料）的各种数据类型，以帮助优化资源分配。通过深度推理设备和过程之间的隐含关系，知识图谱可以生成热更新的知识图谱，从而驱动生产资源分配，并允许快速决策订单插入请求。此外，该方法还采用了社区设备方法进行资源分配，并结合模糊层次法进行候选设备集的构建和评估。实验结果表明，该方法可以有效地提高资源利用率和生产效率，并适应不同类型的生产任务。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
    <category term="知识图谱" scheme="tags/知识图谱/"/>
    
  </entry>
  
  <entry>
    <title>leetcode25.交换链表</title>
    <link href="2023/03/01/leetcode25-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/01/leetcode25-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-01T07:15:42.000Z</published>
    <updated>2023-03-06T07:16:29.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/swap_ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4]输出：[2,1,4,3]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>直接进行交换，思路如下：</li></ol><p>当链表为空或者只有一个节点时，无需任何操作，直接返回<code>head</code>，否则就定义指针<code>cur</code>和<code>before</code>，初始值分别为<code>head</code>和<code>NULL</code>。当链表中至少有两个节点时进行循环，在循环里定义一个指针<code>tmp</code>，用于指向<code>cur</code>的下一个节点，接下来进行两个节点的交换操作，此时判断before指针是否为空，若不为空则将before的next指向交换完毕的<code>tmp</code>指针，然后更新<code>cur</code>指针的值，继续循环直到链表中未得到交换的元素数小于2停止，最后返回头节点<code>head</code>。C++实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        &#x2F;&#x2F; 如果链表为空或只有一个节点，直接返回头指针        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return head;        &#x2F;&#x2F; 定义指针 cur 和 before，初始值分别为 head 和 NULL        ListNode* cur &#x3D; head;        ListNode* before &#x3D; NULL;        &#x2F;&#x2F; 当链表中至少有两个节点时进行循环        while(cur !&#x3D; NULL &amp;&amp; cur-&gt;next !&#x3D; NULL) &#123;            &#x2F;&#x2F; 定义指针 tmp，将其指向 cur 的下一个节点            ListNode* tmp &#x3D; cur-&gt;next;            &#x2F;&#x2F; 将 cur 的下一个节点指向 tmp 的下一个节点            cur-&gt;next &#x3D; tmp-&gt;next;            &#x2F;&#x2F; 将 tmp 的下一个节点指向 cur，完成交换            tmp-&gt;next &#x3D; cur;            &#x2F;&#x2F; 如果不是第一次交换，则将 before 的下一个节点指向 tmp            if (before !&#x3D; NULL) before-&gt;next &#x3D; tmp;            &#x2F;&#x2F; 如果 cur 是链表头节点，则将 head 指向 tmp            if (cur &#x3D;&#x3D; head) head &#x3D; tmp;            &#x2F;&#x2F; 将 before 指向 cur，cur 指向下一个节点，进行下一次循环            before &#x3D; cur;            cur &#x3D; cur-&gt;next;        &#125;        &#x2F;&#x2F; 返回交换后的链表头指针        return head;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode707.设计链表</title>
    <link href="2023/02/27/leetcode707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <id>2023/02/27/leetcode707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</id>
    <published>2023-02-27T12:47:38.000Z</published>
    <updated>2023-02-27T13:18:14.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和 <code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><span id="more"></span><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回<code>-1</code>。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 <code>index</code> 个节点之前添加值为 <code>val</code> 的节点。如果 <code>index</code> 等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果<code>index</code>小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code> 个节点。</li></ul><p><strong>示例：</strong></p><pre class="language-none"><code class="language-none">MyLinkedList linkedList &#x3D; new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2);   &#x2F;&#x2F;链表变为1-&gt; 2-&gt; 3linkedList.get(1);            &#x2F;&#x2F;返回2linkedList.deleteAtIndex(1);  &#x2F;&#x2F;现在链表是1-&gt; 3linkedList.get(1);            &#x2F;&#x2F;返回3</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= index, val &lt;= 1000</code></li><li>请不要使用内置的 LinkedList 库。</li><li><code>get</code>, <code>addAtHead</code>, <code>addAtTail</code>, <code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的操作次数不超过 <code>2000</code>。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>单链表实现，注意对象成员的定义和初始化。C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class MyLinkedList &#123;private:    struct ListNode &#123;        int val;        ListNode* next;        ListNode(int x) : val(x), next(NULL) &#123;&#125;        &#x2F;&#x2F; 构造函数，用于创建一个新的节点。其中，int x 是该节点的值，val(x) 表示将该值赋给节点的 val 成员变量，next(NULL) 表示将该节点的 next 成员变量初始化为 NULL。整个构造函数的作用是初始化节点的值和指针。    &#125;;    ListNode* head;    int len;public:    &#x2F;** Initialize your data structure here. *&#x2F;    MyLinkedList() &#123;        head &#x3D; NULL;        len &#x3D; 0;    &#125;        &#x2F;** Get the value of the index-th node in the linked list. If the index is invalid, return -1. *&#x2F;    int get(int index) &#123;        if (index &lt; 0 || index &gt;&#x3D; len) &#123;            return -1;        &#125;        ListNode* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        return cur-&gt;val;    &#125;        &#x2F;** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. *&#x2F;    void addAtHead(int val) &#123;        ListNode* newNode &#x3D; new ListNode(val);        newNode-&gt;next &#x3D; head;        head &#x3D; newNode;        len++;    &#125;        &#x2F;** Append a node of value val to the last element of the linked list. *&#x2F;    void addAtTail(int val) &#123;        if (len &#x3D;&#x3D; 0) &#123;            addAtHead(val);            return;        &#125;        ListNode* cur &#x3D; head;        while (cur-&gt;next !&#x3D; NULL) &#123;            cur &#x3D; cur-&gt;next;        &#125;        ListNode* newNode &#x3D; new ListNode(val);        cur-&gt;next &#x3D; newNode;        len++;    &#125;        &#x2F;** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. *&#x2F;    void addAtIndex(int index, int val) &#123;        if (index &lt; 0 || index &gt; len) &#123;            return;        &#125;        if (index &#x3D;&#x3D; 0) &#123;            addAtHead(val);            return;        &#125;        if (index &#x3D;&#x3D; len) &#123;            addAtTail(val);            return;        &#125;        ListNode* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        ListNode* newNode &#x3D; new ListNode(val);        newNode-&gt;next &#x3D; cur-&gt;next;        cur-&gt;next &#x3D; newNode;        len++;    &#125;        &#x2F;** Delete the index-th node in the linked list, if the index is valid. *&#x2F;    void deleteAtIndex(int index) &#123;        if (index &lt; 0 || index &gt;&#x3D; len) &#123;            return;        &#125;        if (index &#x3D;&#x3D; 0) &#123;            ListNode* temp &#x3D; head;            head &#x3D; head-&gt;next;            delete temp;            len--;            return;        &#125;        ListNode* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        ListNode* temp &#x3D; cur-&gt;next;        cur-&gt;next &#x3D; temp-&gt;next;        delete temp;        len--;    &#125;&#125;;</code></pre><ol start="2"><li>双链表实现</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;class MyLinkedList &#123;private:    struct Node &#123;        int val;        Node* prev;        Node* next;        Node(int val) : val(val), prev(nullptr), next(nullptr) &#123;&#125;    &#125;;    Node* head;    Node* tail;    int size;public:    &#x2F;** Initialize your data structure here. *&#x2F;    MyLinkedList() : head(nullptr), tail(nullptr), size(0) &#123;&#125;    &#x2F;** Get the value of the index-th node in the linked list. If the index is invalid, return -1. *&#x2F;    int get(int index) &#123;        if (index &lt; 0 || index &gt;&#x3D; size) &#123;            return -1;        &#125;        Node* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        return cur-&gt;val;    &#125;    &#x2F;** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. *&#x2F;    void addAtHead(int val) &#123;        Node* newNode &#x3D; new Node(val);        if (size &#x3D;&#x3D; 0) &#123;            head &#x3D; tail &#x3D; newNode;        &#125; else &#123;            newNode-&gt;next &#x3D; head;            head-&gt;prev &#x3D; newNode;            head &#x3D; newNode;        &#125;        size++;    &#125;    &#x2F;** Append a node of value val to the last element of the linked list. *&#x2F;    void addAtTail(int val) &#123;        Node* newNode &#x3D; new Node(val);        if (size &#x3D;&#x3D; 0) &#123;            head &#x3D; tail &#x3D; newNode;        &#125; else &#123;            newNode-&gt;prev &#x3D; tail;            tail-&gt;next &#x3D; newNode;            tail &#x3D; newNode;        &#125;        size++;    &#125;    &#x2F;** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list.      * If index is greater than the length, the node will not be inserted. *&#x2F;    void addAtIndex(int index, int val) &#123;        if (index &lt; 0 || index &gt; size) &#123;            return;        &#125;        if (index &#x3D;&#x3D; 0) &#123;            addAtHead(val);            return;        &#125;        if (index &#x3D;&#x3D; size) &#123;            addAtTail(val);            return;        &#125;        Node* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        Node* newNode &#x3D; new Node(val);        newNode-&gt;prev &#x3D; cur;        newNode-&gt;next &#x3D; cur-&gt;next;        cur-&gt;next-&gt;prev &#x3D; newNode;        cur-&gt;next &#x3D; newNode;        size++;    &#125;    &#x2F;** Delete the index-th node in the linked list, if the index is valid. *&#x2F;    void deleteAtIndex(int index) &#123;        if (index &lt; 0 || index &gt;&#x3D; size) &#123;            return;        &#125;        if (index &#x3D;&#x3D; 0) &#123;            Node* tmp &#x3D; head;            head &#x3D; head-&gt;next;            if (head !&#x3D; nullptr) &#123;                head-&gt;prev &#x3D; nullptr;            &#125; else &#123;                tail &#x3D; nullptr;            &#125;            delete tmp;        &#125; else if (index &#x3D;&#x3D; size - 1) &#123;            Node* tmp &#x3D; tail;        tail &#x3D; tail-&gt;prev;        tail-&gt;next &#x3D; nullptr;        delete tmp;        &#125; else &#123;            Node* cur &#x3D; head;            for (int i &#x3D; 0; i &lt; index; i++) &#123;                cur &#x3D; cur-&gt;next;            &#125;            cur-&gt;prev-&gt;next &#x3D; cur-&gt;next;            cur-&gt;next-&gt;prev &#x3D; cur-&gt;prev;            delete cur;        &#125;        size--;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：&lt;code&gt;val&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt;。&lt;code&gt;val&lt;/code&gt; 是当前节点的值，&lt;code&gt;next&lt;/code&gt; 是指向下一个节点的指针&amp;#x2F;引用。如果要使用双向链表，则还需要一个属性 &lt;code&gt;prev&lt;/code&gt; 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode206.反转链表</title>
    <link href="2023/02/27/leetcode206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>2023/02/27/leetcode206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-02-27T07:20:51.000Z</published>
    <updated>2023-02-27T08:32:07.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/rev1ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5]输出：[5,4,3,2,1]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/rev1ex2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2]输出：[2,1]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归方式</li></ol><p>在这个实现中，我们首先检查链表是否为空或只有一个节点。如果是这样，我们直接返回该节点，因为没有必要反转链表。</p><p>如果链表中有多个节点，我们将递归调用 <code>reverseList</code> 函数来反转链表的后半部分。然后，我们将当前节点连接到反转后的链表的末尾，将当前节点作为新的尾节点，连接到 NULL。最后，返回新的头节点。</p><p>这个递归方法的时间复杂度是 O(n)，其中 n 是链表的长度。虽然它可能需要使用堆栈来存储递归调用的上下文，但它通常比迭代方法更简洁易懂。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * 以链表1-&gt;2-&gt;3-&gt;4-&gt;5举例 * @param head * @return *&#x2F;ListNode* reverseList(ListNode* head) &#123;    if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#123;        &#x2F;*            直到当前节点的下一个节点为空时返回当前节点            由于5没有下一个节点了，所以此处返回节点5         *&#x2F;        return head;    &#125;    &#x2F;&#x2F;递归传入下一个节点，目的是为了到达最后一个节点    ListNode* newHead &#x3D; reverseList(head-&gt;next);    &#x2F;*        第一轮出栈，head为5，head-&gt;next为空，返回5        第二轮出栈，head为4，head-&gt;next为5，执行head-&gt;next-&gt;next&#x3D;head也就是5-&gt;next&#x3D;4，                  把当前节点的子节点的子节点指向当前节点                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4-&gt;next&#x3D;null                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5                  返回节点5        第三轮出栈，head为3，head-&gt;next为4，执行head-&gt;next-&gt;next&#x3D;head也就是4-&gt;next&#x3D;3，                  此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3-&gt;next&#x3D;null                  此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5                  返回节点5        第四轮出栈，head为2，head-&gt;next为3，执行head-&gt;next-&gt;next&#x3D;head也就是3-&gt;next&#x3D;2，                  此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2-&gt;next&#x3D;null                  此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5                  返回节点5        第五轮出栈，head为1，head-&gt;next为2，执行head-&gt;next-&gt;next&#x3D;head也就是2-&gt;next&#x3D;1，                  此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1-&gt;next&#x3D;null                  此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5                  返回节点5        出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1     *&#x2F;    head-&gt;next-&gt;next &#x3D; head;    head-&gt;next &#x3D; nullptr;    return newHead;&#125;</code></pre><ol start="2"><li>迭代方式（头插法）</li></ol><p>头插法的基本思路是，将链表的每个节点插入到新链表的头部。由于头插法是从头部开始插入，因此我们需要一个指针来跟踪新链表的头部。</p><p>在这个实现中，我们首先定义一个新链表的头部指针 <code>newHead</code>，并将其初始化为 NULL。</p><p>然后，我们遍历原链表中的每个节点。在每个迭代中，我们先记录当前节点的下一个节点，然后将当前节点插入到新链表的头部。为此，我们将当前节点的 <code>next</code> 指针指向新链表的头部，然后将新链表的头部指针指向当前节点。</p><p>最后，我们将当前节点更新为原链表中的下一个节点，并重复这个过程，直到我们遍历完整个链表。</p><p>这个方法的时间复杂度是 O(n)，其中 n 是链表的长度。它不需要额外的空间来存储递归调用的上下文，因此它通常比递归方法更快。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        &#x2F;&#x2F; 新链表的头节点指针，初始为 NULL        ListNode* newHead &#x3D; NULL;        &#x2F;&#x2F; 依次遍历原链表中的每个节点        while (head !&#x3D; NULL) &#123;            &#x2F;&#x2F; 记录当前节点的下一个节点            ListNode* next &#x3D; head-&gt;next;            &#x2F;&#x2F; 将当前节点插入到新链表的头部            head-&gt;next &#x3D; newHead;            newHead &#x3D; head;            &#x2F;&#x2F; 处理下一个节点            head &#x3D; next;        &#125;        &#x2F;&#x2F; 返回新链表的头节点指针        return newHead;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你单链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你反转链表，并返回反转后的链表。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode203.移除链表元素</title>
    <link href="2023/02/26/leetcode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>2023/02/26/leetcode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</id>
    <published>2023-02-26T05:43:26.000Z</published>
    <updated>2023-02-26T05:56:06.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/removelinked-list.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6输出：[1,2,3,4,5]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [], val &#x3D; 1输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [7,7,7,7], val &#x3D; 7输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>虚拟头节点法：</li></ol><p>若使用常规思路，在移除节点有两种情况：</p><ul><li><p>非头节点的移除：直接讲被删除节点的前一个节点同被删除节点的后一个节点连接，然后删除当前的被删除节点；</p></li><li><p>头节点的移除：新建一个节点指向头节点，令头节点等于头节点的后继节点，然后删除刚才指向头节点的新建节点。</p></li></ul><p>为了防止需要写两个逻辑判断到底怎么删除节点，在这里直接使用一个虚拟节点，他的后继节点指向头节点，此时本来需要被特殊处理的头节点也可以按照非头节点的移除方法进行移除了，在循环的最后删除虚拟头节点，返回虚拟头节点的后继节点（即真实头节点）。C++代码实现思路如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* visualHead &#x3D; new ListNode(0); &#x2F;&#x2F; 新建虚拟头节点        visualHead-&gt;next &#x3D; head;        ListNode* cur &#x3D; visualHead; &#x2F;&#x2F; cur指现在要处理的节点，默认指向虚拟头节点        while (cur-&gt;next!&#x3D;NULL) &#123; &#x2F;&#x2F; 开始循环            if (cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123; &#x2F;&#x2F; 如果值匹配，则进行删除                ListNode* tmp &#x3D; cur-&gt;next;                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123; &#x2F;&#x2F; 否则当前指针更新为它的next指针指向的元素                cur &#x3D; cur-&gt;next;            &#125;        &#125;        head &#x3D; visualHead-&gt;next; &#x2F;&#x2F; 得到删除对应元素之后的头节点        delete visualHead; &#x2F;&#x2F; 删除虚拟头节点，以降低空间复杂度        return head; &#x2F;&#x2F; 返回头节点，算法结束    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; 和一个整数 &lt;code&gt;val&lt;/code&gt; ，请你删除链表中所有满足 &lt;code&gt;Node.val == val&lt;/code&gt; 的节点，并返回 &lt;strong&gt;新的头节点&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode330.按要求补齐数组</title>
    <link href="2023/02/23/leetcode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/"/>
    <id>2023/02/23/leetcode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/</id>
    <published>2023-02-23T07:09:33.000Z</published>
    <updated>2023-02-23T07:26:01.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个已排序的正整数数组 <code>nums</code> <em>，</em>和一个正整数 <code>n</code> <em>。</em>从 <code>[1, n]</code> 区间内选取任意个数字补充到 nums 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 nums 中某几个数字的和来表示。</p><p>请返回 <em>满足上述要求的最少需要补充的数字个数</em> 。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3], n &#x3D; 6输出: 1 解释:根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。所以我们最少需要添加一个数字。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,5,10], n &#x3D; 20输出: 2解释: 我们需要添加 [2,4]。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,2,2], n &#x3D; 5输出: 0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>升序排列</strong></li><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>贪心算法</li></ol><p>题目使用的是贪心算法。贪心算法的基本思想是，在每一步选择中都选择当前状态下最优的选择，以求得最终的全局最优解。</p><p>对于这道题，我们的贪心策略是在已经被覆盖的区间内，选择尽可能靠右的数字来扩展区间，这样可以让被覆盖的区间尽可能的大，从而让需要添加的数字的数量尽可能的少。</p><p>当遍历到一个数时，如果这个数小于等于 <code>covered + 1</code>，那么它可以被当前的区间所覆盖，因此可以将它加入到被覆盖的区间内，更新 <code>covered</code> 的值(<code>covered += nums[i]</code>)。如果这个数大于 <code>covered + 1</code>，那么当前的区间无法覆盖它，因此需要添加一个新的数字，使得被覆盖的区间能够扩展到这个数，更新 <code>covered</code> 的值(<code>covered += covered + 1</code>)。</p><p>这个贪心策略的正确性可以通过反证法来证明：假设存在一个更优的解，使得需要添加的数字的数量比当前算法得到的解更少。那么这个更优的解必然包含一个数字 x，它是我们在当前算法中添加的数字。如果将 x 从更优的解中删除，那么这个解就会变成一个覆盖范围更小、需要添加的数字数量相同的解，与我们的假设矛盾。因此，当前算法得到的解就是最优解，贪心策略是正确的。</p><p>可以先求解所有需要被插入的数字，再返回拥有所有被插入数字的数组的长度，实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;        vector&lt;int&gt; patches; &#x2F;&#x2F; 用于保存需要插入的数字        long long int covered &#x3D; 0; &#x2F;&#x2F;用longlong类型存储当前已经被覆盖的数的范围        int i &#x3D; 0; &#x2F;&#x2F;nums数组的下标        while (covered &lt; n) &#123; &#x2F;&#x2F; 只要还没有覆盖到n，就需要添加数字            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;                &#x2F;&#x2F; 如果nums[i]小于等于当前已经被覆盖的数的下一个数(covered + 1)                &#x2F;&#x2F; 那么就可以将nums[i]加入到被覆盖的范围内                covered +&#x3D; nums[i];                i++;            &#125; else &#123;                &#x2F;&#x2F; 如果nums[i]大于covered + 1, 那么就需要添加一个新的数字                int patch &#x3D; covered + 1;                covered +&#x3D; patch;                patches.push_back(patch);            &#125;        &#125;        return patches.size();    &#125;&#125;;</code></pre><p>因为题目并没有要求存储被插入的数组，为了更低的空间占用，可以不存储要插入的数字，直接对计数器<code>count</code>自加一：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;        long long int covered &#x3D; 0;  &#x2F;&#x2F; 用 long long 类型存储当前已经被覆盖的数的范围        int count &#x3D; 0;  &#x2F;&#x2F; 记录需要添加的数字的数量        int i &#x3D; 0;  &#x2F;&#x2F; nums 数组的下标        while (covered &lt; n) &#123;  &#x2F;&#x2F; 只要还没有覆盖到 n，就需要添加数字            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;                &#x2F;&#x2F; 如果 nums[i] 小于等于当前已经被覆盖的数的下一个数（covered + 1）                &#x2F;&#x2F; 那么就可以将 nums[i] 加入到被覆盖的范围内                covered +&#x3D; nums[i];                i++;            &#125; else &#123;                &#x2F;&#x2F; 如果 nums[i] 大于 covered + 1，那么就需要添加一个新的数字                covered +&#x3D; covered + 1;                count++;            &#125;        &#125;        return count;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个已排序的正整数数组 &lt;code&gt;nums&lt;/code&gt; &lt;em&gt;，&lt;/em&gt;和一个正整数 &lt;code&gt;n&lt;/code&gt; &lt;em&gt;。&lt;/em&gt;从 &lt;code&gt;[1, n]&lt;/code&gt; 区间内选取任意个数字补充到 nums 中，使得 &lt;code&gt;[1, n]&lt;/code&gt; 区间内的任何数字都可以用 nums 中某几个数字的和来表示。&lt;/p&gt;
&lt;p&gt;请返回 &lt;em&gt;满足上述要求的最少需要补充的数字个数&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode435.无重叠区间</title>
    <link href="2023/02/22/leetcode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <id>2023/02/22/leetcode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</id>
    <published>2023-02-22T02:43:40.000Z</published>
    <updated>2023-02-22T02:52:22.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p><span id="more"></span> <p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: intervals &#x3D; [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 105</code></li><li><code>intervals[i].length == 2</code></li><li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><p>首先按照区间的结束位置从小到大排序，然后从前往后遍历所有区间，若当前区间和前面的区间不重叠，则保留当前区间，继续向后遍历；否则就舍弃当前区间，再继续向后遍历。最后返回被舍弃的区间数即可。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        int n &#x3D; intervals.size();        if (n &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        &#x2F;&#x2F; 按照区间的结束位置从小到大排序        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;            return a[1] &lt; b[1];        &#125;);        int cnt &#x3D; 1;  &#x2F;&#x2F; 不重叠区间的个数，初始值为1        int end &#x3D; intervals[0][1];  &#x2F;&#x2F; 当前不重叠区间的结束位置，初始值为第一个区间的结束位置        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (intervals[i][0] &gt;&#x3D; end) &#123;  &#x2F;&#x2F; 如果当前区间的起始位置大于等于当前不重叠区间的结束位置                cnt++;  &#x2F;&#x2F; 将不重叠区间的个数加1                end &#x3D; intervals[i][1];  &#x2F;&#x2F; 更新当前不重叠区间的结束位置            &#125;            &#x2F;&#x2F; 如果当前区间的起始位置小于当前不重叠区间的结束位置，说明当前区间与前面的区间重叠了，不能选            &#x2F;&#x2F; 不需要执行任何操作，直接跳过        &#125;        return n - cnt;  &#x2F;&#x2F; 总区间个数减去不重叠区间的个数，即为需要去除的重叠区间的最小个数    &#125;&#125;;</code></pre><p>注：在sort函数中第三个参数为匿名函数，其中的参数是数组，因此：</p><blockquote><p>在排序算法中，通常需要交换数组或容器中的元素位置来实现排序的目的。如果直接将数组或容器作为参数传递给比较函数，那么在函数内部交换元素位置时，就需要复制整个数组或容器，这样会造成不必要的开销。</p><p>因此，通常使用指向数组或容器中元素的指针或引用类型作为比较函数的参数，这样在交换元素位置时只需要交换指针或引用，而不需要复制整个数组或容器。这样可以减小开销，提高效率。</p><p>在本题中，使用 <code>vector&lt;int&gt;&amp;</code> 类型的引用作为比较函数的参数，可以避免复制整个二维向量，同时也可以保证比较函数的参数类型与 STL 中的排序算法所需的参数类型相同，方便函数间的传递和调用。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个区间的集合 &lt;code&gt;intervals&lt;/code&gt; ，其中 &lt;code&gt;intervals[i] = [starti, endi]&lt;/code&gt; 。返回 &lt;em&gt;需要移除区间的最小数量，使剩余区间互不重叠&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode45.跳跃游戏II</title>
    <link href="2023/02/21/leetcode45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
    <id>2023/02/21/leetcode45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</id>
    <published>2023-02-21T06:38:37.000Z</published>
    <updated>2023-02-21T06:43:08.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [2,3,0,1,4]输出: 2</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li>题目保证可以到达 <code>nums[n-1]</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>贪心算法</li></ol><p>算法思路是：遍历数组，用变量 <code>max_pos</code> 记录当前能够到达的最远位置，用变量 <code>end_pos</code> 记录当前步数下能够到达的最远位置，如果遍历到 <code>end_pos</code>，则更新 <code>end_pos</code> 为 <code>max_pos</code>，并将步数加 1。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n &#x3D;&#x3D; 1) return 0; &#x2F;&#x2F; 如果数组只有一个元素，返回 0        int steps &#x3D; 0, max_pos &#x3D; 0, end_pos &#x3D; 0;        &#x2F;&#x2F; steps：跳跃的步数，max_pos：当前能够到达的最远位置，end_pos：当前步数下能够到达的最远位置        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;            &#x2F;&#x2F; 遍历数组，到达 n - 1 时不需要再跳跃，因为已经到达了终点            max_pos &#x3D; max(max_pos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远位置            if (i &#x3D;&#x3D; end_pos) &#123; &#x2F;&#x2F; 如果到达了当前步数下能够到达的最远位置，需要增加步数                end_pos &#x3D; max_pos; &#x2F;&#x2F; 更新当前步数下能够到达的最远位置                steps++; &#x2F;&#x2F; 增加步数            &#125;        &#125;        return steps; &#x2F;&#x2F; 返回跳跃的步数    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;0 索引&lt;/strong&gt;整数数组 &lt;code&gt;nums&lt;/code&gt;。初始位置为 &lt;code&gt;nums[0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每个元素 &lt;code&gt;nums[i]&lt;/code&gt; 表示从索引 &lt;code&gt;i&lt;/code&gt; 向前跳转的最大长度。换句话说，如果你在 &lt;code&gt;nums[i]&lt;/code&gt; 处，你可以跳转到任意 &lt;code&gt;nums[i + j]&lt;/code&gt; 处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= j &amp;lt;= nums[i]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;i + j &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回到达 &lt;code&gt;nums[n - 1]&lt;/code&gt; 的最小跳跃次数。生成的测试用例可以到达 &lt;code&gt;nums[n - 1]&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode860.柠檬水找零</title>
    <link href="2023/02/20/leetcode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <id>2023/02/20/leetcode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</id>
    <published>2023-02-20T08:12:25.000Z</published>
    <updated>2023-02-20T08:53:43.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：bills &#x3D; [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：bills &#x3D; [5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bills.length &lt;= 105</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路</li></ol><p>使用一个大小为2的数组count存储5元纸币和10元纸币的数量，接着对数组bills进行遍历，当满足条件时将对应的纸币数量进行加减，若成功遍历整个数组，则说明可以找零(<code>return true</code>)，否则无法找零(<code>return false</code>)。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;        vector&lt;int&gt; count(2,0);        for (int i &#x3D; 0; i &lt; bills.size(); i++) &#123;            if (bills[i] &#x3D;&#x3D; 5) &#123;                count[0]++;            &#125;            else if (bills[i] &#x3D;&#x3D; 10) &#123;                if (count[0] !&#x3D; 0) &#123;                    count[0]--;                    count[1]++;                &#125;                else return false;            &#125;            else if (bills[i] &#x3D;&#x3D; 20)&#123;                &#x2F;&#x2F;20 usd&#39;s situation                if (count[1] &gt; 0 &amp;&amp; count[0] &gt; 0) &#123;                    count[0]--;                    count[1]--;                &#125;                else if (count[0] &gt;&#x3D; 3) &#123;                    count[0] -&#x3D; 3;                &#125;                else return false;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 &lt;code&gt;5&lt;/code&gt; 美元。顾客排队购买你的产品，（按账单 &lt;code&gt;bills&lt;/code&gt; 支付的顺序）一次购买一杯。&lt;/p&gt;
&lt;p&gt;每位顾客只买一杯柠檬水，然后向你付 &lt;code&gt;5&lt;/code&gt; 美元、&lt;code&gt;10&lt;/code&gt; 美元或 &lt;code&gt;20&lt;/code&gt; 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 &lt;code&gt;5&lt;/code&gt; 美元。&lt;/p&gt;
&lt;p&gt;注意，一开始你手头没有任何零钱。&lt;/p&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;bills&lt;/code&gt; ，其中 &lt;code&gt;bills[i]&lt;/code&gt; 是第 &lt;code&gt;i&lt;/code&gt; 位顾客付的账。如果你能给每位顾客正确找零，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode455.分发饼干</title>
    <link href="2023/02/19/leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <id>2023/02/19/leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</id>
    <published>2023-02-19T05:35:55.000Z</published>
    <updated>2023-02-19T05:58:44.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><span id="more"></span> <p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路</li></ol><p>对两个数组进行排序，然后使用双层for循环进行贪心的遍历查找；C++实现代码如下，但是显然还有优化空间。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(), g.end());        sort(s.begin(), s.end()); &#x2F;&#x2F;排列数组        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; g.size(); i++) &#123;            for (int j &#x3D; 0; j &lt; s.size(); j++) &#123;                if (s[j] &gt;&#x3D; g[i]) &#123;                    &#x2F;&#x2F; 如果满足条件，则result++,且修改s中的数值。                    &#x2F;&#x2F; g中的无需修改，因为循环会继续                    result++;                    s[j] &#x3D; -1;                    break;                &#125;            &#125;        &#125;        return result;         &#125;&#125;;</code></pre><ol start="2"><li>使用双指针优化刚才的双层for循环，C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(), g.end());        sort(s.begin(), s.end()); &#x2F;&#x2F;排列数组        int result &#x3D; 0;        int i &#x3D; 0, j &#x3D; 0;        while (i &lt; g.size() &amp;&amp; j &lt; s.size()) &#123;            if (s[j] &gt;&#x3D; g[i]) &#123;                result++;                i++;                j++;                        &#125;            else j++;        &#125;        return result;         &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。&lt;/p&gt;
&lt;p&gt;对每个孩子 &lt;code&gt;i&lt;/code&gt;，都有一个胃口值 &lt;code&gt;g[i]&lt;/code&gt;，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 &lt;code&gt;j&lt;/code&gt;，都有一个尺寸 &lt;code&gt;s[j]&lt;/code&gt; 。如果 &lt;code&gt;s[j] &amp;gt;= g[i]&lt;/code&gt;，我们可以将这个饼干 &lt;code&gt;j&lt;/code&gt; 分配给孩子 &lt;code&gt;i&lt;/code&gt; ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode135.分发糖果</title>
    <link href="2023/02/17/leetcode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <id>2023/02/17/leetcode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</id>
    <published>2023-02-17T06:45:58.000Z</published>
    <updated>2023-02-17T06:49:29.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：ratings &#x3D; [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：ratings &#x3D; [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>常规思路</li></ol><p>首先新建一个数组candies，它代表每个人能分得的糖果数，接下来进行两次遍历：第一次从左向右遍历，确保右边评分较高的小孩获得更多的糖果，第二次从右向左遍历，确保左边评分较高的小孩获得更多的糖果。代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        int n &#x3D; ratings.size();        vector&lt;int&gt; candies(n, 1);              &#x2F;&#x2F; 从左往右扫描，保证右边评分高的孩子分到更多的糖果        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (ratings[i] &gt; ratings[i - 1]) &#123;                candies[i] &#x3D; candies[i - 1] + 1;            &#125;        &#125;              &#x2F;&#x2F; 从右往左扫描，保证左边评分高的孩子分到更多的糖果        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;            if (ratings[i] &gt; ratings[i + 1]) &#123;                candies[i] &#x3D; max(candies[i], candies[i + 1] + 1);            &#125;                    &#125;        &#x2F;&#x2F; 计算糖果总数        int result &#x3D; 0;        for (int item: candies) &#123;            result +&#x3D; item;        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 个孩子站成一排。给你一个整数数组 &lt;code&gt;ratings&lt;/code&gt; 表示每个孩子的评分。&lt;/p&gt;
&lt;p&gt;你需要按照以下要求，给这些孩子分发糖果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个孩子至少分配到 &lt;code&gt;1&lt;/code&gt; 个糖果。&lt;/li&gt;
&lt;li&gt;相邻两个孩子评分更高的孩子会获得更多的糖果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请你给每个孩子分发糖果，计算并返回需要准备的 &lt;strong&gt;最少糖果数目&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode122.买卖股票的最佳时机II</title>
    <link href="2023/02/16/leetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>2023/02/16/leetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</id>
    <published>2023-02-16T08:36:11.000Z</published>
    <updated>2023-02-16T08:44:30.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。     总利润为 4 + 3 &#x3D; 7 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     总利润为 4 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li><p>使用贪心法</p><p>为什么要使用贪心法？因为题目明确暗示了：“你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。”</p><p>因此解题思路如下：首先定义一个整形变量result用于存储结果，接着从左向右遍历数组price,若<code>price[i] &lt; price[i+1]</code>，则说明第i天的价格低于第i+1天的价格，此时可以在第i天购买股票然后在第i+1天卖出，将卖出的价格减去前一天买入的价格的差值加到result中，然后继续向右遍历，直至遍历结束，返回result.</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n &#x3D; prices.size();        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;            int j &#x3D; i + 1;            if (prices[j] &gt; prices[i]) &#123;                result &#x3D; result - prices[i] + prices[j];            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><p>虽然走了一些弯路，但是还是做出来了，所以… 稍微得瑟一下：</p><p><img src="http://cdn.leafii.top/img/image-20230216164402662.png" alt="image-20230216164402662" loading="lazy"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;prices&lt;/code&gt; ，其中 &lt;code&gt;prices[i]&lt;/code&gt; 表示某支股票第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;在每一天，你可以决定是否购买和&amp;#x2F;或出售股票。你在任何时候 &lt;strong&gt;最多&lt;/strong&gt; 只能持有 &lt;strong&gt;一股&lt;/strong&gt; 股票。你也可以先购买，然后在 &lt;strong&gt;同一天&lt;/strong&gt; 出售。&lt;/p&gt;
&lt;p&gt;返回 &lt;em&gt;你能获得的 &lt;strong&gt;最大&lt;/strong&gt; 利润&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
