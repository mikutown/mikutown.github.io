<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-04-03T09:44:15.250Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蓝桥杯真题-门牌制作</title>
    <link href="2023/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C/"/>
    <id>2023/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C/</id>
    <published>2023-04-03T08:29:27.000Z</published>
    <updated>2023-04-03T09:44:15.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小蓝要为一条街的住户制作门牌号。</p><p>这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。</p><p>小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。</p><p>请问要制作所有的 11 到 20202020 号门牌，总共需要多少个字符 2？</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><span id="more"></span><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int result &#x3D; 0; &#x2F;&#x2F; 初始化需要数字2的个数为0    for (int i &#x3D; 1; i &lt;&#x3D; 2020; i++) &#123; &#x2F;&#x2F; 循环，从1到2020        int temp &#x3D; i; &#x2F;&#x2F; 令temp&#x3D;i，方便后续判断字符2个数的操作        while (temp &gt; 0) &#123;            if (temp % 10 &#x3D;&#x3D; 2) &#123; &#x2F;&#x2F; 如果temp中最后一位是2                result++; &#x2F;&#x2F; result自增            &#125;            temp &#x2F;&#x3D; 10; &#x2F;&#x2F; temp&#x2F;&#x3D;10去掉最后一位数字        &#125;    &#125;    printf(&quot;%d&quot;, result);&#x2F;&#x2F; 输出结果    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小蓝要为一条街的住户制作门牌号。&lt;/p&gt;
&lt;p&gt;这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。&lt;/p&gt;
&lt;p&gt;小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。&lt;/p&gt;
&lt;p&gt;请问要制作所有的 11 到 20202020 号门牌，总共需要多少个字符 2？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大运行时间：1s&lt;/li&gt;
&lt;li&gt;最大运行内存: 128M&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-质数</title>
    <link href="2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E8%B4%A8%E6%95%B0/"/>
    <id>2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E8%B4%A8%E6%95%B0/</id>
    <published>2023-04-02T06:29:27.000Z</published>
    <updated>2023-04-02T07:44:59.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们知道第一个质数是 22、第二个质数是 33、第三个质数是 55……</p><p>请你计算第 20192019 个质数是多少？</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><span id="more"></span><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int isPrime(int num) &#123;    &#x2F;&#x2F; 判断一个数字是不是质数，return 0代表不是质数， return 1 代表是质数    for (int i &#x3D; 2; i &lt; num; i++) &#123;        &#x2F;&#x2F; 循环中判断是否能被1或者它本身之外的数字整除，若能则不是质数，直接return 0        if (num % i &#x3D;&#x3D; 0) &#123;            return 0;        &#125;    &#125;    &#x2F;&#x2F; 循环结束都没发现能整除的其他数字，可以返回1    return 1;&#125;int main()&#123;    int count &#x3D; 0; &#x2F;&#x2F; 定义计数器，默认为0    int answer &#x3D; 0;    for (int i &#x3D; 2; count !&#x3D; 2019; i++) &#123; &#x2F;&#x2F; 从2开始循环是因为2是第一个质数，不要从1开始循环        if (isPrime(i) &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 若判断为是质数            count++; &#x2F;&#x2F; 计数器++；            answer &#x3D; i; &#x2F;&#x2F; 迭代更新answer        &#125;    &#125;    cout &lt;&lt; answer &lt;&lt; endl; &#x2F;&#x2F; 输出答案    return 0;&#125;</code></pre><ul><li>优化解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main() &#123;    int n &#x3D; 2019; &#x2F;&#x2F; 要计算的质数的位置    int num &#x3D; 3; &#x2F;&#x2F; 初始为3，因为第一个质数是2    int count &#x3D; 1; &#x2F;&#x2F; 已经找到了一个质数2，所以从1开始计数    while (count &lt; n) &#123;        num +&#x3D; 2; &#x2F;&#x2F; 只需要判断奇数是否为质数        bool isPrime &#x3D; true; &#x2F;&#x2F; 假设当前数是质数        for (int i &#x3D; 3; i &lt;&#x3D; sqrt(num); i +&#x3D; 2) &#123;            if (num % i &#x3D;&#x3D; 0) &#123;                isPrime &#x3D; false; &#x2F;&#x2F; 如果能被整除，则不是质数                break;            &#125;        &#125;        if (isPrime) &#123;            count++; &#x2F;&#x2F; 找到一个质数        &#125;    &#125;    cout &lt;&lt; num &lt;&lt; endl; &#x2F;&#x2F; 输出第2019个质数    return 0;&#125;</code></pre><ul><li>线性筛法（Linear Sieve）</li></ul><p>线性筛法是一种求解质数的算法，可以在$O(n)$的时间复杂度内预处理出小于等于$n$的所有质数。</p><p>线性筛法的基本思想是从小到大遍历每个正整数，如果它是质数，就将它加入质数数组中，并用它来筛掉它的倍数。在遍历过程中，对于每个数只会被它的最小质因子筛去，因此每个合数只会被筛一次，从而保证了线性时间复杂度。</p><p>下面是线性筛法的伪代码：</p><pre class="language-none"><code class="language-none">primes &#x3D; [] # 质数数组is_prime &#x3D; [True] * (n+1) # 标记是否为质数for i in range(2, n+1):    if is_prime[i]:        primes.append(i) # 将i加入质数数组    for j in range(len(primes)):        if i * primes[j] &gt; n:            break        is_prime[i * primes[j]] &#x3D; False # 将i*primes[j]标记为非质数        if i % primes[j] &#x3D;&#x3D; 0:            break # 如果i是primes[j]的倍数，就跳出循环</code></pre><blockquote><p>如果在内层循环中，$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</p><p>例如，当$i$为$2 \times 3&#x3D;6$时，在内层循环中，$i$会被$2$筛一次，被$3$筛一次，之后就不需要再被其他数筛了。因此，如果$i$是$primes[j]$的倍数，就可以跳出循环，不需要继续遍历$primes$数组中的其他质数。这样可以减少重复的筛选，提高算法的效率。</p></blockquote><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN &#x3D; 20000; &#x2F;&#x2F; 估计2019个质数的上限vector&lt;int&gt; primes; &#x2F;&#x2F; 存储质数bool isPrime[MAXN]; &#x2F;&#x2F; 标记是否为质数int main() &#123;    fill(isPrime, isPrime+MAXN, true); &#x2F;&#x2F; 初始化标记数组，全部设置为true    for (int i&#x3D;2; i&lt;MAXN; i++) &#123;        if (isPrime[i]) &#123; &#x2F;&#x2F; i是质数            primes.push_back(i); &#x2F;&#x2F; 将i加入质数数组            if (primes.size() &#x3D;&#x3D; 2019) &#123;                cout &lt;&lt; primes.back() &lt;&lt; endl;                break;            &#125;        &#125;        for (int j&#x3D;0; j&lt;primes.size() &amp;&amp; i*primes[j]&lt;MAXN; j++) &#123;            isPrime[i*primes[j]] &#x3D; false; &#x2F;&#x2F; 将i*primes[j]标记为非质数            if (i % primes[j] &#x3D;&#x3D; 0) break; &#x2F;&#x2F; 如果i是primes[j]的倍数，就跳出循环        &#125;    &#125;    return 0;&#125;</code></pre><blockquote><p>可以看到，线性筛法的实现相对简单，但需要注意以下几点：</p><ol><li>对于每个数只需要用它的最小质因子来筛去它的倍数，因此内层循环的终止条件为$i \times primes[j] &gt; n$。</li><li>在内层循环中，如果$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</li><li>在初始化标记数组时，除0和1外都初始化为True。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;我们知道第一个质数是 22、第二个质数是 33、第三个质数是 55……&lt;/p&gt;
&lt;p&gt;请你计算第 20192019 个质数是多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大运行时间：1s&lt;/li&gt;
&lt;li&gt;最大运行内存: 128M&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="蓝桥杯" scheme="tags/蓝桥杯/"/>
    
  </entry>
  
  <entry>
    <title>leetcode968.监控二叉树</title>
    <link href="2023/03/29/leetcode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/29/leetcode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-29T06:23:53.000Z</published>
    <updated>2023-03-29T06:43:47.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/bst_cameras_01.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/bst_cameras_02.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>贪心算法</li></ul><p>本题是一道贪心算法的题目。通过对题目进行分析，我们可以发现有以下几种情况：</p><p>1.如果一个节点没有被监控，那么它必须要安装一个摄像头。</p><p>2.如果一个节点安装了摄像头，那么它的父节点就可以被监控了。</p><p>3.如果一个节点的子节点被监控了，那么这个节点也可以被监控。</p><p>因此，我们可以采用自下而上的方式进行处理，从叶子节点开始向根节点进行处理。对于每个节点，我们可以有三种状态：</p><p>0：该节点没有装摄像头，且它的子节点中也没有装摄像头的节点，此时应该给他装一个摄像头。</p><p>1：该节点没有装摄像头，但是它的子节点中至少有一个装摄像头的节点，此时应该给他的父节点装一个摄像头。</p><p>2：该节点装摄像头了，因此它无需再安装一个摄像头。</p><p>对于每个节点，我们可以采用递归的方式进行处理。当节点为叶子节点时，它的状态为0。对于其他节点，如果它的子节点中存在状态为0的节点，那么该节点的状态为1，表示需要安装摄像头。如果它的子节点中都存在状态为1或2的节点，那么该节点的状态为0，表示不需要安装摄像头，但是它的父节点需要安装摄像头。如果它的子节点中存在状态为2的节点，那么该节点的状态为1，表示不需要安装摄像头，因为它的子节点已经可以覆盖它了。</p><p>最后，根据根节点的状态来判断是否需要安装摄像头。如果根节点的状态为0或1，那么需要安装一个摄像头。如果根节点的状态为2，那么不需要安装摄像头。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minCameraCover(TreeNode* root) &#123;        int res &#x3D; 0;        if (dfs(root, res) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 根节点未被监控            res++;        &#125;        return res;    &#125;    int dfs(TreeNode* node, int&amp; res) &#123;        if (node &#x3D;&#x3D; nullptr) &#123;            return 2; &#x2F;&#x2F; 空节点不需要监控，返回2        &#125;        int left &#x3D; dfs(node-&gt;left, res);        int right &#x3D; dfs(node-&gt;right, res);        if (left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 左右子节点有未被监控的节点，该节点需要安装摄像头            res++; &#x2F;&#x2F; 安装了摄像头            return 1; &#x2F;&#x2F; return 1是指该节点没有被监控，但是它的子节点中至少有一个被监控的节点。        &#125; else if (left &#x3D;&#x3D; 1 || right &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 左右子节点中至少有一个节点被监控            return 2; &#x2F;&#x2F; return 2是指该节点被监控了。        &#125; else &#123; &#x2F;&#x2F; 左右子节点均被监控            return 0; &#x2F;&#x2F; return 0是指该节点没有装摄像头        &#125;    &#125;&#125;;</code></pre><blockquote><p>其中，dfs函数的返回值为当前节点的状态。如果返回值为0，表示当前节点需要安装摄像头；如果返回值为1，表示当前节点不需要安装摄像头，但是它的父节点需要安装摄像头；如果返回值为2，表示当前节点不需要安装摄像头。res为引用类型，表示安装摄像头的数量。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，我们在树的节点上安装摄像头。&lt;/p&gt;
&lt;p&gt;节点上的每个摄影头都可以监视&lt;strong&gt;其父对象、自身及其直接子对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算监控树的所有节点所需的最小摄像头数量。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode113.路径总和II</title>
    <link href="2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/"/>
    <id>2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</id>
    <published>2023-03-28T06:05:24.000Z</published>
    <updated>2023-03-28T06:24:39.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/pathsumii1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22输出：[[5,4,11,2],[5,8,4,5]]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/pathsum2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2], targetSum &#x3D; 0输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>本题可以使用深度优先搜索（DFS）求解。从根节点开始，依次搜索左子树和右子树，直到找到符合条件的路径。具体来说，我们可以使用递归的方式，每次遍历到一个节点时，将该节点加入路径中，并更新目标值。如果该节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径，将该路径加入结果数组中。否则，继续搜索左子树和右子树。在搜索之后，需要将当前节点从路径中删除，以便回溯到之前的状态。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        dfs(root, targetSum, res, path);        return res;    &#125;    void dfs(TreeNode* node, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;        if (!node) return;  &#x2F;&#x2F; 如果当前节点为空，则直接返回        path.push_back(node-&gt;val);  &#x2F;&#x2F; 将当前节点的值加入路径中        targetSum -&#x3D; node-&gt;val;     &#x2F;&#x2F; 更新目标值        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 如果当前节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径            res.push_back(path);    &#x2F;&#x2F; 将该路径加入结果数组        &#125; else &#123;            dfs(node-&gt;left, targetSum, res, path);   &#x2F;&#x2F; 搜索左子树            dfs(node-&gt;right, targetSum, res, path);  &#x2F;&#x2F; 搜索右子树        &#125;        path.pop_back();  &#x2F;&#x2F; 回溯：将当前节点从路径中删除，恢复到搜索之前的状态    &#125;&#125;;</code></pre><blockquote><p><code>path.pop_back()</code> 是 C++ 中 vector 容器的成员函数，用于删除 vector 容器中的最后一个元素。在本题中，由于我们在搜索过程中需要记录搜索路径，因此使用了一个 <code>path</code> 数组来保存路径。在每次搜索到一个新节点时，我们将该节点的值加入 <code>path</code> 数组中，如果搜索结束后未找到符合条件的路径，需要将该节点从 <code>path</code> 数组中删除，回溯到之前的状态，继续搜索其他节点。因此，在代码中，<code>path.pop_back()</code> 的作用是删除 <code>path</code> 数组中最后一个元素，以便回溯到之前的状态。</p></blockquote><p>时间复杂度分析：</p><p>本题的时间复杂度为$ O(N^2)$，其中 N 表示二叉树的节点数。在最坏情况下，二叉树的形态类似于一个单链表，此时需要遍历所有节点，时间复杂度为 $O(N)$。对于每个节点，由于需要将该节点加入路径中，时间复杂度为$ O(N)$，因此总时间复杂度为 $O(N^2)$。</p><p>空间复杂度分析：</p><p>本题的空间复杂度为 $O(N)$，其中 N 表示二叉树的节点数。递归调用的栈空间最多为 $O(N)$，路径数组的空间为 $O(N)$，因此总空间复杂度为 $O(N)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; 和一个整数目标和 &lt;code&gt;targetSum&lt;/code&gt; ，找出所有 &lt;strong&gt;从根节点到叶子节点&lt;/strong&gt; 路径总和等于给定目标和的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叶子节点&lt;/strong&gt; 是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode110.平衡二叉树</title>
    <link href="2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-27T07:36:41.000Z</published>
    <updated>2023-03-28T06:05:42.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/balance_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/balance_2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：true</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归但空间复杂度较高的解法</li></ul><p>本题可以使用递归的方法来解决。对于每一个节点，我们需要先递归遍历它的左右子树，计算它们的高度差。如果左右子树的高度差超过了1，那么这棵树就不是平衡二叉树。如果左右子树都是平衡二叉树，那么我们可以判断当前节点是不是平衡二叉树：如果左右子树的高度差不超过1，那么当前节点就是平衡二叉树。最后递归返回整棵树的平衡情况。</p><p>在递归函数中，我们需要同时返回当前节点的高度和平衡情况，因此可以使用pair&lt;int, bool&gt;来表示。其中，pair的第一个元素表示高度，第二个元素表示当前节点是否是平衡二叉树。同时，我们需要处理一些边界情况，例如空节点的高度为0，空节点也是平衡二叉树。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root).second;    &#125;        pair&lt;int, bool&gt; checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return make_pair(0, true);        &#125;        auto left &#x3D; checkBalance(node-&gt;left);        auto right &#x3D; checkBalance(node-&gt;right);        if (left.second &amp;&amp; right.second &amp;&amp; abs(left.first - right.first) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return make_pair(max(left.first, right.first) + 1, true);        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return make_pair(0, false);    &#125;&#125;;</code></pre><blockquote><p><code>pair</code>是C++ STL中的一个模板类，用于存储两个不同类型的变量。它将两个变量打包成一个整体，方便传递和使用。</p></blockquote><p>但是它的内存占用过高，因为对于每个节点，它都要单独存一个bool变量用于表示节点是否为二叉树的平衡结点。因此需要进行优化。</p><ul><li>递归，但优化内存占用</li></ul><p>在题目中，我们使用了<code>pair&lt;int, bool&gt;</code>来表示每个节点的高度和平衡情况，但是这种方法会浪费一定的空间，因为每个节点都需要存储一个<code>bool</code>类型的变量。实际上，我们只需要判断每个节点是否平衡，因此可以使用一个<code>int</code>类型的变量来表示平衡情况：-1表示不平衡，非0表示平衡并且代表节点的高度。这样就可以减少空间的使用。</p><p>同时，我们可以将返回值从<code>pair&lt;int, bool&gt;</code>改为<code>int</code>，表示当前节点的高度。如果当前节点不是平衡二叉树，那么直接返回-1，否则返回节点的高度。</p><p>C++代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root) !&#x3D; -1;    &#125;    int checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return 0;        &#125;        int left &#x3D; checkBalance(node-&gt;left);        int right &#x3D; checkBalance(node-&gt;right);        if (left !&#x3D; -1 &amp;&amp; right !&#x3D; -1 &amp;&amp; abs(left - right) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return max(left, right) + 1;        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>迈向智能云：云系统容错方法回顾</title>
    <link href="2023/03/27/%E8%BF%88%E5%90%91%E6%99%BA%E8%83%BD%E4%BA%91%EF%BC%9A%E4%BA%91%E7%B3%BB%E7%BB%9F%E5%AE%B9%E9%94%99%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE/"/>
    <id>2023/03/27/%E8%BF%88%E5%90%91%E6%99%BA%E8%83%BD%E4%BA%91%EF%BC%9A%E4%BA%91%E7%B3%BB%E7%BB%9F%E5%AE%B9%E9%94%99%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE/</id>
    <published>2023-03-27T02:08:06.000Z</published>
    <updated>2023-03-29T14:10:51.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems"><a href="#Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems" class="headerlink" title="Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems"></a>Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文介绍了云计算中提出的容错方法的最新研究进展。本文将容错方法分为三类：1）反应式方法（RAMs）；2）预防性方法（PRMs）；和3）弹性方法（RSMs）。RAMs允许系统进入故障状态，然后尝试恢复系统。PRMs倾向于通过实施机制来避免错误影响系统，从而防止系统进入故障状态。另一方面，最近出现的RSMs旨在最小化系统从故障中恢复所需的时间。本文还探讨了机器学习和人工智能在RSM领域中如何发挥作用以最小化恢复时间。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>首先，介绍了云计算的概念和特点，指出云计算作为一种新型的计算模式，具有高度的可扩展性、灵活性和可靠性等优势。然而，由于云计算系统规模庞大、复杂度高，因此故障率也相应增加。因此，在云计算中实现容错是至关重要的。</p><p>接着，本文介绍了目前在云计算领域中已经提出的容错方法，并指出这些方法存在一些局限性和不足之处。</p><p>常见的容错方法被分类为三类：反应式方法（RAMs）、预防性方法（PRMs）和弹性方法（RSMs）。其中，反应式方法指的是系统在发生故障后才进行恢复；预防性方法则是通过实施机制来避免错误影响系统，从而防止系统进入故障状态；弹性方法旨在最小化系统从故障中恢复所需的时间。具体而言，反应式方法（RAMs）允许系统进入故障状态，然后尝试恢复系统；预防性方法（PRMs）倾向于通过实施机制来避免错误影响系统，从而防止系统进入故障状态；最近出现的弹性方法（RSMs）旨在最小化系统从故障中恢复所需的时间。它们常用的技术如下：</p><ol><li>反应式方法（RAMs）：基于传统的分布式系统容错技术，如复制、检查点&#x2F;重启、检测和恢复等。</li><li>预防性方法（PRMs）：主要采用监控、预测和抢占等技术。在正常操作下，PRMs不断监视系统状态，并在可能发生系统故障时立即调用避免故障的步骤。 </li><li>弹性方法（RSMs）：主要采用快速恢复和自愈能力等技术。RSMs旨在最小化系统从故障中恢复所需的时间，以便尽快将系统恢复到正常状态。</li></ol><p>而传统的反应式方法（RAMs）只能在系统发生故障后才能进行恢复，而预防性方法（PRMs）则需要消耗大量资源来避免错误发生。因此，需要进一步研究新型的容错方法来解决这些问题。 </p><p>在Introduction中，作者详细描述了PRMs和RSMs之间的区别。具体而言，作者指出PRMs主要实现故障预测和避免方法，但没有学习和适应方法；而RSMs则通过不断更新模型和学习结构来适应云系统的动态变化，并根据自身计算环境特征自适应地学习和减轻PRMs的影响。因此，虽然PRMs实现了故障预测，但没有学习和适应方法；而RSMs则通过自适应地学习计算环境特征来减轻PRMs的影响，并在系统发生故障时快速恢复。</p><p>最后，本文介绍了本文所采用的研究框架，并概述了本文各个章节所涉及到的内容。</p><p><img src="http://cdn.leafii.top/img/image-20230328151324660.png" alt="image-20230328151324660" loading="lazy"></p><h2 id="Cloud-Fault-Tolerance-Model"><a href="#Cloud-Fault-Tolerance-Model" class="headerlink" title="Cloud Fault Tolerance Model"></a>Cloud Fault Tolerance Model</h2><p>故障可以是系统中发生的影响系统正常运行的任何事件。通常，故障是系统正常运行的<strong>根本损害</strong>，它们会导致错误。错误反过来会导致系统故障。容错性是衡量系统在出现故障时继续为其客户请求提供服务的能力。本文定义了四种系统错误，分别是瞬态故障（Transient Faults），间歇性故障（Intermittent Faults），永久性故障（Permanent Faults），拜占庭式故障（Byzantine Faults）：</p><ol><li>瞬态故障（Transient Faults）：指系统中的某个组件或部件在短时间内发生故障，但之后又能够自行恢复正常工作。这种故障通常是由于电压波动、电磁干扰等原因引起的。 </li><li>间歇性故障（Intermittent Faults）：指系统中的某个组件或部件在不同时间点上出现故障，但每次故障持续时间很短，并且在下一次出现之前可能会有很长一段时间没有任何问题。这种故障通常是由于松动连接、温度变化等原因引起的。</li><li>永久性故障（Permanent Faults）：指系统中的某个组件或部件发生了无法自行恢复的故障，需要进行更换或修理才能恢复正常工作。这种故障通常是由于硬件损坏、软件错误等原因引起的。</li><li>拜占庭式故障（Byzantine Faults）：指系统中的某个组件或部件出现了任意形式的错误，包括发送错误信息、篡改数据等。这种错误通常是由于恶意攻击、软件漏洞等原因引起的。</li></ol><h2 id="Fault-Tolerance-Challenges-in-cloud-systems"><a href="#Fault-Tolerance-Challenges-in-cloud-systems" class="headerlink" title="Fault Tolerance Challenges in cloud systems"></a>Fault Tolerance Challenges in cloud systems</h2><p>云计算的特点使得云系统容错面临着以下挑战：</p><ul><li>Heterogeneity and the lack of standards（异质性和缺乏标准）：不同硬件和操作系统供应商基于自己的架构部署云，因此可能在同一个大型云系统中部署在异构平台上的组件。这给容错解决方案的设计带来了压力，因为它们必须考虑整个容错解决方案中每个操作系统供应商的方面。因此，在设计容错解决方案时需要考虑到这些异构性和缺乏标准的挑战。</li><li>Need for automation（需要自动化）：未来是智能的，并需要自动化。随着托管云系统的虚拟机数量呈指数级增长，人类管理这些系统将变得几乎不可能。因此，需要考虑自动化来管理这些系统的容错解决方案。然而，自动化面临着缺乏通用框架（API）的挑战，这些框架可以应用于任何云系统以实现容错解决方案，并且需要进行很少的努力（即需要插入式容错）。因此，在未来的容错解决方案中，自动化将成为主要趋势。</li><li>Downtime in the clouds（云中的停机时间）：云架构由多个地理位置分布和由不同供应商管理的数据中心组成。一个数据中心的完全停机可能会影响许多组织。每个组织对云的服务级别协议（SLA）不同，容错提供商必须确保满足所有组织的SLA。因此，在设计容错解决方案时需要考虑到这些挑战。</li><li>Consideration for RPO and RTO（对 RPO 和 RTO 的考虑）：容错解决方案的目标是将恢复点目标（RPO）和恢复时间目标（RTO）都降到最低。其中，<strong>RPO是服务器故障时可能丢失的数据量</strong>，而<strong>RTO是系统在故障后重新运行所需的时间</strong>。通过使用弹性方法来不断最小化RPO和RTO，可以设计出容错解决方案。弹性方法的学习功能可以被定义为最小化RPO和RTO。因此，在设计容错解决方案时需要考虑到这些目标。</li><li>Workloads in the cloud(云计算中的工作负载):云计算中有两种工作负载类型，即云原生和云启用工作负载。云原生应用是完全使用云模型构建的应用程序，由多个服务组成，每个服务都具有弹性、韧性，并可用于组合其他应用程序。而云原生工作负载是由纯云原生应用程序生成的计算工作负载。在某些情况下，不可能将应用程序的所有组件迁移到云上，这导致应用程序的某些组件在企业内部托管，而另一些组件在云上托管。这通常被称为“云启用”。因此，在设计容错解决方案时需要考虑到这些工作负载类型的差异。在这种情况下，主动和弹性方法都应该适用于处理云原生和云活动模型的容错要求。</li></ul><h2 id="Fault-tolerance-and-reliability-in-the-clouds"><a href="#Fault-tolerance-and-reliability-in-the-clouds" class="headerlink" title="Fault tolerance and reliability in the clouds"></a>Fault tolerance and reliability in the clouds</h2><p>虚拟化技术用于提供计算资源，然后这些资源属于许多云用户。 这种资源虚拟化导致了复杂的基础架构设计，这些设计将硬件暴露在它们最初并非设计用于并导致故障的条件下。 故障可能发生在硬件、系统（主机或 VM）、软件或操作员级别。 云系统中的故障可能导致系统发生灾难性中断，从而影响云系统的可靠性。</p><p>云系统的可靠性是衡量云系统在预定条件下向用户提供服务的好坏程度。 此类条件通常定义为 QoS，它构成云服务提供商与客户（或用户）之间合同的一部分。 云系统的可靠性最终取决于承载服务的虚拟机的容错能力。一般来说，云系统中用于容错的技术涉及<strong>检查点 [4]、冗余 [3]、[7] 和网络带宽</strong> [9]、[10] 的优化。 检查点可以发生在进程级别或 VM 级别。 进程或 VM 状态在执行期间不断被保存。 在进程失败的情况下，执行将从检查点开始恢复，而不是从头开始。 如果 VM 发生故障，VM 映像将恢复到另一台机器，并且进程从发生故障的 VM 的检查点继续。</p><p>大多数关于云系统可靠性的研究都集中在优化检查点算法和虚拟机冗余上。刘等人。 [3] 和周等人。 [4] 描述了一种<strong>冗余 VM 方法</strong>，该方法在选择一组 VM 托管服务器时考虑了网络拓扑结构，目的是最大限度地减少网络资源消耗。 周等。 [5] 提出了一种<strong>减少虚拟机检查点期间使用的存储</strong>的解决方案。 最后，周等人。 [5] 对<strong>增强云可靠性</strong>的研究进行了研究。 在大多数情况下，云服务的采用涉及将托管在组织数据中心的现有系统迁移到云环境。 由于低维护成本、高可扩展性和按使用付费模式等特性，组织被云托管的价值主张所吸引。 除了节省托管成本外，此类迁移还应提高系统的<strong>整体可靠性</strong>。 将一些成熟的企业系统迁移到云端并不是一个容易的决定。 尽管将系统迁移到云端有明显的好处，但组织仍然必须根据为此类决策提供信息所需的科学方法做出务实的决策。 此外，还需要考虑重要的考虑因素，例如系统安全性（由组织的安全策略管理）。 一些系统组件最好在本地私有环境中运行。 因此，需要一些<strong>指南</strong>来帮助实施最佳的云迁移结构。<br>邱等。 [11] 介绍了一个<strong>基于可靠性的框架</strong>（ROCloud），在考虑系统上的云迁移时，它可以用作决策制定的一部分。 ROCloud 由两种算法（ROCloud1 和 ROCloud2）组成，用于根据应用程序的结构和历史可靠性信息对其进行<strong>排名</strong>。 ROCloud1 和 ROCloud2 分别用于对普通应用程序和混合应用程序进行排名。 排名结果用于自动选择要使用的最佳容错策略。 该框架使用<strong>四种常见的容错策略</strong>，即 Recovery Block、N-Version Programming、Parallel 和 VM Restart。 每个策略根据<strong>三个参数</strong>对每个系统组件进行排名：响应时间、资源成本和故障率。 进行了实验，结果表明，仅通过过滤一些容易出错的组件并将它们移动到云中，就有了显着的改进。</p><h2 id="Taxonomy-of-fault-tolerance-methods"><a href="#Taxonomy-of-fault-tolerance-methods" class="headerlink" title="Taxonomy of fault tolerance methods"></a>Taxonomy of fault tolerance methods</h2><p>在这部分中，论文详细描述了对容错方法的三个分类，即ReActive Methods (RAMs)、PRoactive Methods (PRMs)和ReSilient Methods (RSMs)。其中，每个分类用到的关键技术如下：</p><ul><li>RAMs（反应性方法）：重点主要是系统恢复。系统的状态在恢复过程中不断保存和使用。使用的关键技术是复制、检查点和重新启动。</li><li>PRMs（主动方法）：主要关注防止系统完全中断。这些方法通过持续监控系统和进行故障预测来工作，以便在故障发生之前很好地预防故障的影响。使用的关键技术是云资源的监控、预测和重新分配。</li><li>RSMs（弹性方法）：这些方法与主动方法具有许多共同特征。 RSM 通过预测故障和实施方法来运行以避免或最小化此类故障对系统的影响。除了监控和预测之外，弹性方法还通过与托管环境交互并结合智能学习来调整（微调）系统容错能力。这是 RSM 与 PRM 显着不同的地方。</li></ul><p><img src="http://cdn.leafii.top/img/image-20230328161146682.png" alt="image-20230328161146682" loading="lazy"></p><h3 id="Reactive-Meghods"><a href="#Reactive-Meghods" class="headerlink" title="Reactive Meghods"></a>Reactive Meghods</h3><p>反应性方法用于减轻故障发生后的影响。根据当前文献，用于反应式容错的关键技术包括检查点&#x2F;重启、复制、SGuard、重试、自定义异常处理、任务重新提交和救援工作流。本节回顾了有关 RAM 的选定论文。</p><h4 id="Checkpointing-x2F-Restarting"><a href="#Checkpointing-x2F-Restarting" class="headerlink" title="Checkpointing&#x2F;Restarting"></a>Checkpointing&#x2F;Restarting</h4><p>检查点&#x2F;重新启动技术通过<strong>不断保存系统状态</strong>来工作，如果发生故障，作业将从最近的状态开始。 这些技术适用于长时间运行的作业。 以下段落将总结一些关于基于检查点的算法的论文，即[26]、[27]、[28]、[29]、[30]、[31]、[32]、[33]、[34] ]、[35]、[36]、[37]。 这些论文的选择基于他们如何将检查点纳入他们的解决方案的变化。</p><p>冈村等。 [27] 提出了一种基于强化学习的动态检查点方案。 这种技术在系统故障分布未知的情况下会变得很有用。 首先，检查点问题被建模为半马尔可夫决策过程。 其次，应用具有代表性的强化学习算法（称为 Q-learning 算法）。 Q-learning 允许构建自适应检查点方案。 该算法由通过学习和交互体验适应环境的智能 体组成。</p><p>穆迪等。 [29] 描述了一种新颖的多级检查点系统。 这种方法旨在降低不断增长的高性能计算 (HPC) 系统的检查点成本。 系统定义了一套 L checkpointing 机制。 每个级别代表一个具有不同成本和弹性级别的检查点机制，最终映射到所使用的存储类型，例如本地内存、USB、远程内存、使用软件 RAID、本地 SSD 或远程文件系统。 第一个级别 1 是成本最低的级别，最后一个级别 L 是成本最高的级别。 较低级别采用轻量级检查点，这些检查点具有较低的开销成本，因此非常适合处理最常见的故障模式。 类似地，较高级别具有昂贵的检查点成本，并且用于不太频繁的故障模式。 Scalable Checkpoint&#x2F;Restart (SCR) 库用于实现系统，它可以将检查点保存到计算节点上的 RAM、Flash 或磁盘。 该系统使用概率马尔可夫模型进一步建模，该模型可用于预测当前和未来系统的性能。 总体结果表明，当前和未来系统的并行文件系统负载<strong>减少了两次</strong>。 迪等人。 [30] 通过开发一种进一步优化级别选择的方法，进一步优化了多级检查点。 此外，Di 等人。 [33] 通过优化核数不确定的系统的检查点间隔来改进多级检查点。</p><p>奥林纳等。 [32] 引入了协作检查点技术，这是一种健壮的检查点算法，由一组规则和策略组成，使检查点决策能够由应用程序、编译器和操作系统（看门人）共同做出。 在这种方法中，开发人员在代码中的最佳位置插入检查点请求，编译器进一步优化这些检查点请求，看门人进行最终调用以授予或拒绝检查点。 网守考虑许多系统运行时因素来授予&#x2F;拒绝检查点请求，例如 CPU 负载、磁盘 I&#x2F;O、网络 I&#x2F;O、作业调度队列、故障事件预测和 QoS 保证。 奥林纳等。 [32] 还表明协作检查点简单实用，可以应用于现有应用程序检查点机制之上。 进行了许多实验，表明协作检查点<strong>优于</strong>周期性检查点。 Jangjaimon 和 Tzeng [35] 提出了一种增强的自适应增量检查点 (EAIC) 容错机制。 EAIC 旨在基于未来的云计算资源即服务 (RaaS) 模型，为托管在多核云基础设施上的多线程云应用程序提供 FT。 调整后的马尔可夫模型 (AMM) 的构建是为了满足现场实例 (SI)、保留实例 (RI) 和硬件故障的需要。 在 RI 中，客户购买预先配置资源（如 CPU、IO 或内存）的预留实例。 对于 SI，客户可以竞标未使用的资源，而且价格通常比 RI 低得多。 结果表明，应用程序运行时间和成本的<strong>显着减少都归功</strong>于多级检查点的使用。 这个观察是在使用 RI 和 SI 时进行的。 赵等。 [36] 提出了一种新方法，该方法确定如何使用对等检查点在云计算中提供弹性和联合可靠性优化。 总的来说，这项工作 [36] 利用云实用程序的检查点技术在数据中心的资源限制下共同最大化可靠性。 主要关注点对点检查点，用于提高网络资源限制下的可靠性。 在正常情况下，VM 映像被发送到中央存储服务器，这可能会由于高带宽使用率而导致网络拥塞。 为了缓解这个问题，点对点检查点是一种分布式方法，云运营商可以选择在具有足够带宽的对等点之间路由检查点的位置。 <strong>仿真结果</strong>表明，与随机点对点检查点和集中式检查点相比，这种方法显着提高了可靠性。 Amoon [37] 描述了一种基于检查点和复制的云计算自适应容错框架。 该框架在某种意义上是<strong>自适应的</strong>，它能够选择最佳的容错方法用于客户的任务。 此外，该框架还提出了一种复制算法，可以自适应地确定应用程序所需的副本数量。 通过这种方式，复制仅适用于发生故障时对云有较大性能影响的虚拟机。 检查点也是<strong>自适应的</strong>，检查点间隔的长度是根据虚拟机的故障概率自适应确定的。</p><h4 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h4><p>复制技术的工作原理是复制一些系统组件，然后将这些组件同时部署到不同的资源中。该技术旨在使系统健壮，提高可用性并保证作业的执行 [9]、[26]、[38]、[39]、[40]、[41]、[42]、[43] , [44], [45], [46], [47]</p><p>Bodı k 等人。 [9] 提出了一种可用于云迁移的新算法。 云迁移的一个挑战是找到一个既能满足容错又能降低带宽成本的最佳部署模型。 该算法还确定了将系统组件复制到云中并实现最佳带宽和容错的最佳方式。 将系统部署到云中的主要挑战之一是服务器可用性。 这与可用带宽直接相关。 数据中心采用本地冗余构建，可让本地服务器在维护或维修时脱机。 当整个数据中心因灾难或网络设备维护而离线时，挑战就来了。 这通常会导致大量服务器脱机。 可用带宽与云系统的部署架构相关联。 部署在一个数据中心的云系统容易出现服务器不可用、网络拥塞等各种网络故障。 如果网络连接完全中断，数据中心将成为单点故障。 增加部署系统的数据中心数量会直接增加带宽使用，但会显着提高容错能力。 因此，<strong>在提供高容错性和减少带宽使用之间找到良好的平衡存在挑战。</strong> 这可以通过 [9] 中描述的算法来解决。 Balasubramanian 和 Garg [38] 描述了分布式系统中基于融合数据结构的故障管理解决方案，旨在处理<strong>数据崩溃和拜占庭故障</strong>。 融合数据结构的设计方式使得主数据结构的恢复可以通过非常有限的复制次数来完成。 融合数据结构的主要<strong>优点</strong>是节省了存储数据结构副本所需的存储空间。 该技术主要适用于基于队列、栈、向量、二叉搜索树、哈希映射和哈希表等数据结构的解决方案的分布式存储。 融合数据结构还大大<strong>节省</strong>了从故障中恢复所需的计算资源。</p><p>库利等人。 [39] 目前 Remus 主要基于检查点和复制。 Remus 的目标是实现一种透明的容错技术，不需要对现有的云应用程序进行任何更改。 在 Remus 中，托管应用程序的虚拟机被配对成一个主虚拟机和一个辅助虚拟机。 Remus 中的复制是异步完成的。 然后采用各种技术来确保主要和次要之间的异步状态复制。 主 VM 的输出被缓冲并异步复制到辅助 VM。 主 VM 在其状态被检查点后立即恢复执行，并且不等待辅助 VM 的确认。 Remus 结合了一种简单的磁盘缓冲技术来保持主虚拟机和辅助虚拟机的磁盘同步。 在主 VM 上发出的磁盘写入立即提交到其本地磁盘，它们同时传输到辅助 VM 上的缓冲区。 辅助 VM 在检查点后提交到其本地磁盘。 </p><p>Castro 和 Liskov [42] 描述了拜占庭容错 (BFT) 协议。 BFT 协议主要<strong>旨在</strong>解决可靠性和保证系统的高可用性。 大多数 BFT 系统对于实际实施而言过于昂贵，因此，据我们所知，到目前为止，还没有关于实施 BFT 技术的商业数据中心的报道。 提供异步、分布式、客户端-服务器系统的 BFT 解决方案至少需要 $(3f+1)$ 个副本，其中一个为主，其余为备份，其中$ f $是在任何给定点可以容忍的最小故障数时间。 BFT 解决方案具有高资源消耗，这可以归因于它们处理故障的方式。 BFT 解决方案依赖于服务器状态机复制 (SMR)，其中每个副本都以相同的顺序执行相同的请求。 副本使用拜占庭协议来就一组给定请求的顺序达成一致。 订单达成一致后开始执行，然后使用多数表决方案选择正确的答案发送回客户端。 以这种方式，在该投票阶段也可以检测到有故障的服务器。</p><p>郑等。 [46] 提出了一种基于组件排名（称为 FTCloud）的可配置容错方法。 FTCloud由两种算法组成； 第一种算法使用组件执行结构并监视执行频率以构建显着组件排名。 第二种算法使用这些重要组件排名以及系统设计人员输入的容错要求来识别云应用程序的重要组件。 完成组件排名后，该算法会自动为重要的云组件确定最佳容错策略。 最重要的观察是，通过容忍一小部分最重要组件的故障，云应用程序的可靠性得到显着提高。 用于重要组件的最佳容错策略基于冗余和复制。 贾瓦尔等人。 [47] 介绍了一种创新的、系统级和模块化的解决方案，用于在云中创建容错。 该解决方案向应用程序开发人员隐藏了 FT 实施细节。 因此，它创建了一个服务层，开发人员可以在其中请求 FT 作为服务。 用户可以指定和应用所需的 FT 级别，而<strong>无需了解</strong>用于实现容错的底层技术。 该解决方案假定客户端应用程序部署在虚拟机上，因此将 FT 的粒度限制为 VM 实例。 具体来说，该方案利用冗余和复制来实现容错，创建多个虚拟机副本，并在出现故障时随时可用以接管。</p><h4 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h4><p>重试技术的工作原理是简单地多次重试<strong>同一资源</strong>上的失败请求 [48]、[49]。</p><p>Ramalingam 和 Vaswani [49] 提出了一种解决方案，该解决方案依赖于重试技术来解决由于云系统中的进程或通信故障引起的故障。在这样的环境中，失败的请求只是重试。重试机制依赖于系统的无能。 Indepotence 被描述为一个标准，使得在存在重复请求和失败的情况下从应用程序获得的结果与在没有重复请求和失败的情况下从这样的应用程序获得的结果<strong>完全相同</strong>。 Indepotence 由一种名为 FAIL 的语言形式化，该语言受云平台的影响。本质上，语言 FAIL 将流程失败、重复请求、数据和事务形式化。 FAIL 的最终目标是保证无能的云服务。这样的系统是去中心化的，不需要分布式协调。结果，这产生了一个完全分散的容错实现，它处理相同请求和进程失败的多次重试。</p><p>王等。[48]分析了重试容错技术对云服务的性能影响。这是通过构建云服务处理时间的数学模型来实现的。该模型后面是处理时间的概率分布，以分析在出现故障时重试作业的影响。还通过计算在定义的阈值下可以成功服务的请求的百分比来反映服务质量。将使用重试技术的云系统的性能与使用 FT 的检查点技术的云系统的性能进行了比较。结果表明，根据检查点方法的恢复率，重试技术的性能可能比检查点技术更好或更差。</p><h4 id="Task-Resubmission"><a href="#Task-Resubmission" class="headerlink" title="Task Resubmission"></a>Task Resubmission</h4><p>在任务重新提交中，当检测到失败的任务时，它会重新提交到相同或<strong>不同的资源</strong>以执行 [44]。</p><p>Plankensteiner 等人。 [44] 描述了重新提交影响启发式，并用它来改进基于重新提交和复制技术的容错方法。 这种方法通常用于在分布在云端的工作流系统中实现容错。 改进基于引入称为重新提交影响的新算法。 重新提交和复制是广泛用于分布式系统容错的基本技术。 重新提交通过对失败资源或新资源重新执行单个任务来操作，这会显着增加任务完成时间。 复制将同一任务的多个副本同时执行到多个资源，并且存在资源使用率高的缺点。 为了<strong>在重新提交和复制之间找到平衡</strong>，该算法计算 RI（Replication Index） 启发式算法，该算法用于描述重新提交任务对工作流整体执行的影响。 RI 是为每个工作流程定义的，它用于推断生成的重复次数。 实验结果表明，与保守方法相比，RI 显着减少了超过 42% 的资源消耗。 除此之外，RI 不会对任务完成率和整体工作流性能产生负面影响。</p><h4 id="Custom-Exception-Handling"><a href="#Custom-Exception-Handling" class="headerlink" title="Custom Exception Handling"></a>Custom Exception Handling</h4><p>自定义异常处理包括软件开发人员将代码插入应用程序的方法，以便它可以在运行时处理特定故障 [50]。</p><p>刘等人。 [50] 提出了一个框架，用于解决通过业务流程执行语言 (BPEL) 引擎实现编排的事务性 Web 服务 (FACTS) 的容错问题。 Web服务主要用于开发现代商业应用程序。 FACTS 是六个组件的集合，即 EXTRA、WS-BPEL 设计器、规范模块、验证模块、实施模块和计划模块。 EXTRA 组件提供了一组高级异常处理策略，这些策略在标准的 WS-BPEL 内置异常和事务处理工具上运行。复合 Web 服务的容错需求通常源自业务需求。服务设计人员使用事件-条件-操作 (ECA) 规则来定义处理故障的逻辑。 ECA 规则又基于 EXTRA 模块中定义的异常策略。验证模块用于验证故障处理逻辑。它通过评估 ECA 规则必须遵守的原则来做到这一点。</p><h4 id="Rescue-Workflow"><a href="#Rescue-Workflow" class="headerlink" title="Rescue Workflow"></a>Rescue Workflow</h4><p>救援工作流是一种旨在解决基于工作流的系统容错的技术。 即使任务失败，工作流也可以继续，<strong>直到</strong>如果不处理失败的任务就无法继续 [51]、[52]。 对基于工作流的系统的容错机制更感兴趣的读者可以参考 [51]。 Hernandez 和 Cole [52] 提出了<strong>救援有向无环图</strong>（Rescue DAG），这是一种基于倒带和迁移的可靠工作流 DAG 调度机制。 该机制依赖于两个关键组件，即 DAG Manager (DAGMan) 和 Rescue DAG。 DAGMan 是元调度器，它负责管理整个工作流，包括将工作流调度到计算资源上。 DAGMan 还包含容错机制。 该机制执行 DAG 工作流失败部分的重新提交。 当一个 DAG 的任务失败时，DAG 中的剩余任务将继续执行，直到由于 DAG 工作流中的任务依赖性而无法继续执行。 在这种情况下，DAGMan 会输出一个名为 Rescue DAG 的特殊文件，其中包含有关成功任务和不成功任务的足够详细信息。 然后使用 Rescue DAG 来恢复工作流。 重新提交失败的任务。 成功的任务不会重新执行，因此可以节省计算资源和时间。</p><h4 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h4><p>负载均衡是云系统容错和运行的关键。 许多服务器在被客户端请求淹没后可能会因计算资源（CPU 或 RAM）耗尽而崩溃。 为了减少此类故障，云系统必须实施负载平衡作为负载保护的第一道防线 [53]、[54]、[55]、[56]。 传统的集中式负载均衡机制不适用于云系统。 云系统具有高度可扩展性，它们建立在分布式服务器上，这些服务器可以托管在多个数据中心（取决于云系统的架构）。 由于此类系统的规模和复杂性，无法将计算请求集中分配给服务器。 蜜蜂觅食行为 [55]、有偏随机抽样 [56] 和主动聚类 [53] 是云系统最常用的负载平衡算法。 分布式负载平衡算法通常具有内置机制，使它们能够协调公平地处理负载。 [54] 中介绍了这些算法的比较研究。</p><h4 id="N-Version-and-Recovery-Block"><a href="#N-Version-and-Recovery-Block" class="headerlink" title="N-Version and Recovery Block"></a>N-Version and Recovery Block</h4><p>N-version 是一种多版本编程模型。多个功能相同的程序是由不同的团队根据同一组需求规范开发的。团队独立工作，根本不交流。 N版本的思想是基于这样一个事实，即独立开发的程序大大降低了两个或多个版本中出现类似故障的概率。恢复块 (RB) 利用输入数据的不同表示来提供设计错误的容忍度 [57]、[58]、[59]、[60]、[61]。</p><p>N-Version 最近已进入云安全 [58] 和恶意攻击（反病毒 [57]）应用程序。 [60] 中介绍了 N 版本和容错之间关系的一些一般背景。 在接下来的段落中，我们将讨论一些研究工作，其中 N 版本技术已被用作云场景中容错的一部分。 </p><p>彭等。 [59] 回顾了增强型 N 版本编程 (ENVP) 和扩展恢复块 (ERB) 技术。 ENVP 和 ERB 可以联合用于提高 Web 服务 (WS) 的可靠性，因此它们对提高云系统的容错能力有直接的贡献。 ENVP 和 ERB 分别是其原始对应的 N 版本 (NVP) 和恢复块容错机制的扩展。 这些技术已经适用于为基于 WS 的容错系统提供支持。 NVP 通过利用多个功能等效的软件组件（或版本）提供容错能力。 另一方面，RB 使用不同的输入数据表示来容忍软件设计错误。</p><p>ENVP 和 ERB 的逻辑在中间件中实现，中间件负责处理服务用户（客户端）和服务提供者（服务）之间的交互。 NVP 和 RB 都通过在中间件中引入验收测试 (AT) 组件进行了扩展。 AT 组件用于在将 WS 的输出传递给决策管理器 (DM) 之前评估其输出的正确性。 实验结果表明，增加更多的 AT 组件可以提高系统的整体可靠性。</p><h3 id="Proactive-Methods"><a href="#Proactive-Methods" class="headerlink" title="Proactive Methods"></a>Proactive Methods</h3><p>主动方法持续监控系统并进行故障预测，以便在故障发生之前很好地预防故障的影响。 在监控中，系统不断地执行故障预测算法来评估系统的状态，以便采取必要的措施来防止故障。 对于运行在虚拟化环境中的云系统，此类故障管理技术更多地依赖于虚拟平台提供的迁移、暂停&#x2F;取消暂停功能。 根据当前文献，用于主动容错的关键技术包括软件更新、自我修复、抢先迁移、监控和 SGuard。 本节回顾了有关 PRM 的选定论文。</p><h4 id="Software-Rejuvenation"><a href="#Software-Rejuvenation" class="headerlink" title="Software Rejuvenation"></a>Software Rejuvenation</h4><p>软件更新 (SR) 是为定期重启而设计的 [62]、[63]、[64]，它基本上涉及优雅地终止系统并重新启动它。 SR 由另外两种技术补充：1）错误计数；和 2) N 版本编程。错误计数也称为“数黑羊”。这是一种在错误发生时对错误进行计数的技术，这些错误计数的记录会被保存下来，以便它可以用于升级和加速恢复过程。</p><h4 id="Self-Healing"><a href="#Self-Healing" class="headerlink" title="Self-Healing"></a>Self-Healing</h4><p>自愈技术是系统的一项功能，可以自动检测、诊断和修复软件和硬件故障。此类系统由部署在多个 VM 上的多个组件组成 [65]、[66]、[67]、[68]。</p><h4 id="Preemptive-Migration"><a href="#Preemptive-Migration" class="headerlink" title="Preemptive Migration"></a>Preemptive Migration</h4><p>抢先迁移是虚拟化环境的一种重要方法。它提供了将程序执行从一台机器实时迁移到另一台机器的机制。此技术可防止即将发生故障的系统组件影响系统的性能。这是通过监视和将组件从即将无法在更稳定的节点上运行的节点移开来实现的 [3]、[13]、[69]、[70]、[71]、[72]、[73] , [74], [75], [76], [77], [78]。 Applying preemptive migration for proactive FT [69] 提出了一种依赖于抢先迁移的主动容错方法的体系结构。</p><p>恩格尔曼等人。 [69] 定义了一种架构，该架构将服务器作为主动 FT 的基础。 该体系结构基于虚拟机（VM）的预先迁移，因此适用于云计算。 此外，还提供了实施选项的分类。 分类由实施所采用的监控策略定义。 该架构的核心是一个反馈回路控制机制，它构成了系统健康监测的一部分。 系统及其应用程序受到监控，并采取预防措施将应用程序组件从预计会发生故障的节点迁移到更健康的节点。 确定了监控系统健康状况的一些挑战。 其中一个关键挑战是每个解决方案目前都在使用自己的一组指标来测量和评估系统组件之间的健康和接口。 需要标准指标和接口。 </p><p>Nagarajan 等人。 [70] 为消息传递接口 (MPI) 应用程序的主动 FT 提供了一种自动和透明的机制。 该机制将虚拟化技术与健康监控和抢先迁移相结合，以实施主动 FT 解决方案。 使用了 XEN 虚拟化环境。 该解决方案利用 XEN 的实时迁移功能，允许客户操作系统与其正在运行的任务一起重新定位到另一个节点。 当检测到节点的健康状况恶化时，将触发迁移。 抢占式迁移机制运行良好，消除了迁移开销。 MPI 任务在迁移过程中继续执行。</p><p>刘等人。 [3] 提出了一种主动协调 FT (PCFT) 解决方案，旨在为并行云系统提供容错能力。 VM 协调机制用于预测恶化的物理机 (PM)。 恶化 PM 上的 VMS 迁移到最佳目标 PM。 机器性能下降的预测<strong>基于对 CPU 温度的监控</strong>。 该算法的复杂性在于找到一个最佳目标 PM，它必须确保效率、有效性和可扩展性要求。</p><h4 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h4><p>预测构成了主动容错算法的核心。提前预测故障，以便云系统有机会采取纠正措施来避免或减少故障的影响 [13]、[17]、[79]、[80]、[81]、[82] , [83], [84]。萨尔夫纳等。 [83]提供了一种通过调查的预测方法。 Tikotekar 等人提出了一个可用于评估各种 FT 方法和政策的模拟框架。 [84]。该框架非常重视使用预测组件的主动 FT。</p><p>瓦莱等人。 [13] 描述了主动容错的通用框架。 该框架基于故障预测，主要目标是避免故障。 当检测到故障时，系统会使用底层虚拟化平台的故障管理功能，例如暂停&#x2F;取消暂停或迁移进程或整个虚拟机节点。 故障预测器利用计算节点上的<strong>本地信息</strong>来预测当前发生故障的概率，故障预测器定期分析本地系统日志，如果检测到异常行为则产生告警事件。 进行了<strong>两个实验</strong>，作为证明该框架在进行迁移时对计算开销的有效性的一部分。 第一个实验是使用 XEN 虚拟化平台完成的，并测量了虚拟机占用空间对迁移成本的影响。 影响是根据虚拟机内存与总迁移时间（以秒为单位）的函数来衡量的。 第二个实验中，使用专为评估容错策略而设计的模拟器进行 [84]。 发现模拟结果与使用 XEN 的物理实验结果一致，得出的结论是该框架减少了计算开销。 </p><p>平托等人。 [17] 通过结合预测来增强 Hadoop 集群中的容错能力。 预测是使用<strong>支持向量机</strong> (SVM) 模型实现的。 SVM 是具有相关学习算法的监督学习模型，这些算法分析用于分类和回归分析的数据。 SVM 分类器托管在监控 PC 上，以对系统故障进行智能预测。 标准的 Hadoop 架构包括一个级别的容错，其中作业从故障节点重新安排到网络中的其他节点。 这会导致效率低下，因为它可能需要重新处理已经完成的子任务。 SVM 预测模型用于更早地预测故障，以便更早地做出重新安排工作的决策。 此外，还结合了强化学习模块以消除误报，从而显着增强集群的容错能力。 </p><p>哥斯达等人。 [79]描述了一种基于预测的主动容错解决方案，可以有效地避免内存错误。 该解决方案源于一项观察，即检查点&#x2F;重启可能无法有效地处理以千万亿次级执行的高性能计算中的内存故障。 这种方法嵌入到操作系统中。 它的工作原理是向操作系统公开可纠正的错误信息，迁移页面并使故障内存脱机以避免应用程序崩溃。 对内存错误模式进行分析，并使用可纠正的错误模式来预测可能发生故障的内存。 在 IBM 的 Blue Gene&#x2F;Q (BG&#x2F;Q) 系统上运行的 Linux 上实现了一个原型，该系统是一个 HPC 系统。</p><h4 id="Monitoring-Feedback-Loop"><a href="#Monitoring-Feedback-Loop" class="headerlink" title="Monitoring (Feedback Loop)"></a>Monitoring (Feedback Loop)</h4><p>监控主要用于<strong>补充</strong>其他主动算法。它用于监视正在运行的应用程序上的一组状态变量。状态变量被过滤并通过反馈循环机制 [14]、[85] 提供给策略管理器。</p><p>Egwutuoha 等人。 [14] 描述了一种主动技术，它依赖于监控为云中的 HPC 提供 FT。 这种 FT 技术的框架最初是由 Egwutuoha 等人提出的。 [85]。 根据这项研究，超过 50% 的 HPC 系统故障是由处理器、硬盘驱动器、集成电路插槽和内存引起的。 强调了与被动方法相比，HPC 计算中<strong>主动容错</strong>的优势。 与主要基于检查点和重启的反应式容错方法不同，主动容错避免了从检查点重启，因此<strong>降低</strong>了运营成本和能源消耗。 Egwutuoha 等人。 [14] 主要关注 MPI 应用程序。 MPI 应用程序实际上是在不同 CPU 或 VM 上并行运行的应用程序，它们通过消息传递交换数据来进行通信，例如 GROMACS 系统 [89]。 Egwutuoha 等人。 [14] 采用回避方法来容忍错误。 这是通过结合使用系统日志和健康监控设施来实现的。 系统日志提供有关可靠性、可用性和可服务性的信息，而健康监控则以硬件和软件的状态为主。 [14] 中提出的主动 FT 解决方案的架构由四种类型的模块组成：1）带有 lm 传感器的节点监控模块；2）故障预测器；3）主动容错策略模块； 4) 控制器模块。 [14] 还提出了容错算法的框架和一些结果的定量分析。 结果表明，通过实施此 FT 模型可显着节省成本。 节省的主要原因是由于立即放弃故障节点而节省了运营成本。</p><p>Park等。 [90] 描述了一种监控技术，可以作为移动云计算中容错的一部分应用。 虽然Park等人。 [90] 没有描述完整的容错技术，它提供了一种<strong>监控技术</strong>，该技术对于在移动云计算中实现 FT 非常有用。 移动云计算被描述为移动计算和云计算的结合。 在移动云计算的背景下，云计算是通过移动设备提供的。 移动设备上的遗留问题似乎已被克服，这些问题包括电池寿命短和 CPU 性能低下。 该论文确定了在移动云计算中使用移动设备的两类，即作为接口的移动设备和作为资源的移动设备。 大多数工作以前都是使用移动设备作为界面进行的，最近的趋势是使用移动设备作为托管云服务的资源。 使用移动设备作为资源面临着大多数与移动性相关的问题。 其中包括由于无线连接不稳定导致的波动性、电源限制、低网络带宽以及由于频繁的位置变化导致的切换问题。 因此，资源监控是在移动云计算中实现可靠的资源调度和容错技术的关键。 一种资源监控技术，需要收集和分析有关每个参与资源状态的动态信息并确保稳定性。 Park等。 [90] 提出了一种基于马尔可夫链的监控技术，旨在监控和分析资源状态。 <strong>主要目的</strong>是解决移动设备的波动性对容错问题的影响。</p><h4 id="SGuard"><a href="#SGuard" class="headerlink" title="SGuard"></a>SGuard</h4><p>SGuard 是一种基于回滚和恢复的技术，用于实时视频流。它对视频流的影响要小得多 [18]。</p><p>权等人。 [18] 向 SGuard 展示了一个弹性容错方法的示例，该方法由反应性故障技术（即检查点、回滚、恢复和复制）的合并形成。 SGuard 是一种相对较新的技术，用于处理部署在多个集群中的分布式流处理引擎 (SPE) 中的故障。这种部署模型类似于基于云的服务。这种方法使用回滚&#x2F;恢复技术来实现容错。在系统运行时，SGuard 在流服务运行时异步执行检查点。故障服务器根据最近的检查点回滚和恢复。故障服务器的检查点、回滚和恢复是<strong>异步</strong>发生的，不会造成任何服务中断。检查点状态保存在分布式文件系统 (DFS) 上，例如 GFS、HDFS 或 Amazon EC2。 SGuard 能够处理软件故障和硬件崩溃。为了掩盖故障，SGuard 进一步采用了复制技术。 SPE 的状态在多个服务器上复制，这些服务器被分类为主要或次要。因此，SGuard 为实时视频流提供了一种破坏性较小的容错解决方案。</p><h3 id="Resilient"><a href="#Resilient" class="headerlink" title="Resilient"></a>Resilient</h3><p>弹性方法使系统能够在出现故障时<strong>继续</strong>为客户端请求提供服务，并在<strong>可接受的时间段</strong>内快速恢复。 故障可能是设备故障、停电或中断造成的。 通常，弹性系统由组件组成，这些组件负责实现在出现故障时继续响应客户端的能力、系统状态的监控、学习和适应系统的能力。 Colman-Meixner 等人。 [91] 对应用于云架构不同层的弹性技术进行了全面调查。 系统监控组件对于密切关注系统状态以及检测和预测即将发生的故障至关重要。 弹性系统的<strong>目标</strong>是通过最大化系统的可用性来最小化系统的整体停机时间。 学习组件负责优化故障恢复，它通过使用环境参数来实现这一点，并使用它们来改进下次发生故障时的处理。 这样，系统就能够从环境中学习并调整其容错机制。</p><p>容错机制的适应通常涉及<strong>部署最佳资源</strong>以使系统避免完全中断。 系统可以在出现故障之前或之后按时<strong>动态</strong>地添加或删除容量。 本质上，弹性方法是通过将用于 RAM 和 PRM 的技术与通过与环境交互学习的能力<strong>相结合</strong>并<strong>适应容错</strong> [19]、[20]、[21]、[22] 、 [23]、[24]、[25]形成的。本节回顾了有关 RSM 的选定论文。</p><h4 id="Machine-Learning-Approaches"><a href="#Machine-Learning-Approaches" class="headerlink" title="Machine Learning Approaches"></a>Machine Learning Approaches</h4><p>机器学习带来了容错的智能方式。云系统能够通过与其环境交互来学习，并相应地调整其故障处理策略。强化学习似乎是 FT 领域中最常用的技术 [19]、[20]、[21]、[22]、[23]、[24]、[25]、[39]、[86]。本节中审查的大多数论文可能不会直接链接到云计算。然而，我们寻求确定信息来源，其中机器学习，特别是强化学习已被用于实施或提高系统的容错能力。这些想法可以很容易地扩展到云环境中。</p><p>董等人。 [86] 为基于优先级队列和动态路由的云提出了一种高度弹性的容错解决方案。该解决方案得到云敏捷性的进一步支持，即动态地动态配置或取消配置额外的云资源的能力。使用分类方法，云服务请求被分成高优先级请求和低优先级请求，并分别映射到高优先级队列和低优先级队列。分布式动态队列用于卸载本地和远程云节点上的请求。队列技术（例如 Rabbit MQ）增加了将请求移交到远程托管的云服务器上进行处理的能力。动态路由监视优先级队列上的负载，当优先级队列上的负载增加时，它会发出在远程站点上提供额外服务的信号。较低优先级队列（可以容忍高延迟的队列）上的服务请求被移交给辅助服务器处理。该解决方案在后端包括一个数据复制层，用于同步主从服务之间的数据，以便它们可以独立运行。</p><p>许等。 [20] 提出了 FT 的统一强化学习（URL）解决方案。 URL 是一种机器学习技术，用于为云计算自动配置 VM 和设备。 VM 是托管云系统的各种组件的虚拟机。 这些设备可以是任何基于 VM 的软件包，例如 Apache 或 Tomcat Web 设备。 VM 和设备都有大量的配置值。 配置这些值以获得最佳性能和可用性的过程很容易出错。 在论文 [20] 中，描述了两个强化学习智能体，即 VMAgent 和 App-Agent。 VM-Agent 用于重新配置 VM，App-Agent 用于重新配置设备。 每个智能体的行为都使用马尔可夫决策过程 (MDP) 建模。 每个智能体的状态被描述为 VM 或设备的配置参数向量。 由于系统的工作负载需求会随着时间的推移而变化，因此 URL 的<strong>目标</strong>是找到能够为给定工作负载产生最佳性能的良好配置。</p><p>吴等。 [21] 建议使用顺序共享学习 (OSL) 来增强弹性和 FT。 OSL 是一种用于作业调度的鲁棒多智能体强化学习 (MARL) 方法。尽管最初是为网格计算设计的，但 OSL 中的<strong>思想也可以应用于云计算</strong>。 OSL 具有高度可扩展性。 OSL 由在智能体之间迭代交换的轻量级和线性效用表组成。实用程序表用于跟踪处理计划作业的系统资源的效率。 OSL 需要非常少的网络通信带宽，智能体只交换作为每个智能体学习算法输入的效用表。 Scheduler Agent 由两个主要组件组成，即 Actor 和 Learner。 Actor 接收要调度的作业，它在队列中缓冲作业（作业缓冲区）并跟踪当前正在运行的作业（提交的作业列表）。 Leaner 收到共享效用表，它使用提交的作业列表中的信息来学习处理当前作业的资源的新分数。分数被更新，效用表被传递到网格中的相邻节点。这种方式可确保最佳性能和最可靠的资源处理作业，从而增强系统的弹性和容错能力。</p><p>Farivar 和 Ahmadabadi [19] 提出了两种策略，可用于设计鲁棒且自适应的容错控制 (FTC) 系统。 尽管 FTC 与云系统没有直接关系，但可以为云系统数据中心借鉴和实施机器学习（尤其是强化学习）和神经网络（NN）的思想和方式。 [22] 中考虑了在基于执行器的系统中使用 NN 进行容错控制的类似方法。 故障是由一些执行器和传感器产生的，这些执行器和传感器可以安装在典型的云数据中心中以监控各个方面，例如入侵和温度。 传感器可以扩展到包括软件定义的传感器，这些传感器可以监控各种软件定义的指标，例如流量或系统负载。 定义了两种 FTC 策略。 第一个策略涉及一个智能观察器，用于监视未知数量的非线性系统。 第二种策略是基于强化学习，它结合了一些未知的非线性故障系统和非线性控制理论来保证系统的稳定性和鲁棒性。 这种非线性系统可以建模为负责托管云系统的服务器基础设施。 进行了模拟，结果证实上述 FTC 策略表现良好。 此外，对于执行器故障，强化学习被发现比神经网络表现更好。 同样，神经网络在基于传感器的故障上的表现优于强化学习。</p><p>Forster 和 Murphy [23] 提出了到多个接收器的反馈路由 (FROMS)，这是一种基于强化学习的无线传感器网络 (WSN) 的基于机器学习的多播路由范例。这是通过将 WSN 中的多播路由建模为强化学习问题来实现的。尽管 WSN 不被视为与云计算直接相关，但有一种观点认为，连接不良的网络中的最终用户设备可以形成一个动态的 WSN 并使用它来访问云服务。在这种情况下，WSN 的容错解决方案可以通过使 WSN 更加健壮来帮助解决云系统的容错问题。 FROMS 基本上是 WSN 的路由协议。 FROMS 的优势包括在不同服务器条件下灵活地优化路由，例如路由长度、电池电量、故障后恢复以及对接收器移动性的支持。这些声明作为 [23] 中获得的实验结果的一部分得到了支持。</p><p>Wang 和 Usher [24] 描述了 RL 在基于智能体的计算中的应用。 RL 通常用于授权自主智能体学习选择适当的行动，通过与环境交互来实现其目标。动作的选择取决于要解决的问题。尽管与容错没有直接联系，Wang 和 Usher [24] 将 RL 应用于制造系统中的计算智能体。著名的 RL 算法 Q-Learning 用于使机器智能体能够学习普遍接受的调度规则，这依赖于先前定义的最佳调度规则。 RL 的这种应用可用于云计算中的容错。由于云计算包括许多不同类型的计算智能体，它们通过 Internet 访问服务。需要解决连接问题，尤其是在移动网络上。可以应用 Q-Learning 算法，使智能体能够根据可用网络接入点列表始终选择最可靠的 Internet 连接。</p><p>Chen 和 Marculescu [25] 提出了一种在线分布式强化学习 (OD-RL) 算法，用于在功率限制下提高多核系统的性能。 OD-RL 算法基于动态电压频率缩放 (DVFS) 技术以节省功率。大多数托管云服务的数据中心都部署在基于多核 (CPU) 系统的服务器基础设施中，因此 OD-RL 适用于云端。强化学习用于学习在 CPU 级别控制电压&#x2F;频率 (VF) 的最佳策略。定义了用于在更粗粒度全局级别管理功率预算级别的最大化-最大方法。我们更感兴趣的是 RL 在更细粒度 CPU 级别的应用。实验结果表明，OD-RL 可显着节省电能、提高吞吐量和能效。</p><h4 id="Fault-Induction"><a href="#Fault-Induction" class="headerlink" title="Fault Induction"></a>Fault Induction</h4><p>Limoncelli [87] 描述了术语反脆弱性以及故障诱导方法在谷歌和亚马逊等大公司中对 FT 的应用。 早在 2000 年代初，亚马逊就开始使用故障感应方法。 这是通过一个名为 GameDay 的程序完成的。 GameDay 是一个程序，旨在通过在给定时间故意使系统出现重大故障来提高弹性，以发现系统之间的缺陷和依赖关系。 GameDay 测试类似于组织中的消防演习。 GameDay 行动不仅关注计算机系统，还包括对软件和人员（暗示业务流程）的测试，目的是让他们为应对实际灾难事件做好准备。 GameDay 演习模拟了一场真实的灾难，因此参与者可以包括组织各个级别的工作人员 [87]。 GameDay 现象已被谷歌和亚马逊等大型组织积极使用。 GameDay 测试可以重复。 只有在重复测试时一切正常时，GameDay 练习才被标记为成功。 这种技术的部分成果是使组织能够从失败中学习。 使用 GameDay 方法已经取得了<strong>显着的成果</strong>。</p><h3 id="Strengths-and-Weaknesses"><a href="#Strengths-and-Weaknesses" class="headerlink" title="Strengths and Weaknesses"></a>Strengths and Weaknesses</h3><p>在本节中，我们将回顾容错方法的优缺点。传统方法的优点和缺点在文献中得到了很好的研究，这些包括 [26]、[12] 和 [31]。因此，在这篇评论中，我们将介绍<strong>机器学习特定方法</strong>的优缺点，因为这是一个新兴领域。</p><p>越来越多地使用云计算导致系统复杂性和规模呈指数级增长。这最终将导致传统的容错方法不再有效和可行的状态。因此，需要替代方法来处理云中的资源管理、安全性和能源效率等容错问题。本研究中审查的论文评估了各种机器学习算法，这些算法对云容错有不同的贡献。</p><p>机器学习提供了能够处理大量数据并不断学习和调整系统的工具和算法。 ML 由三个主要类别组成，即监督学习、无监督学习和强化学习 (RL)。 RL更适合实现控制优化类型的解决方案。因此，RL 是实现容错的首选 [19]、[23]、[92]。</p><p>通常，RL 算法分为两大类，即基于模型和无模型的方法 [93]。 基于模型的方法使用智能体与环境（云）交互的经验构建世界模型。 该模型用于学习价值函数。 无模型方法直接从与环境的交互中估计价值函数。 每个班级都有不同的长处和短处。 基于模型的方法的关键优势在于，在大多数情况下，他们找到了与环境交互较少的良好价值函数，因此通常被视为产生更好的性能，这被称为数据效率 [93]。 然而，这是有代价的，基于模型的方法通常需要更多的计算资源。 无模型方法的主要优势在于它们需要更少的计算资源，因此它们可以支持比基于模型的方法大得多的表示，这被称为计算效率。 无模型算法的另一个优势在于它们是可扩展的，它们随着代表环境的特征数量线性增长 [93]。</p><p>RL 的<strong>最终目标</strong>是学习用于管理智能体行为的最优策略。 RL 系统由许多智能体组成，这些智能体通过一些涉及与环境交互的反复试验的经验来学习。 RL 智能体通过最大化从动作价值函数获得的奖励来不断适应环境。智能体学习从每个系统状态采取的最佳行动。 RL 适用于状态数量极大、结构复杂的系统，因此适用于云系统。然而，此类系统的一个弱点是需要大量的计算资源，尤其是存储和内存。</p><p>一些著名的机器学习工具已与 RL 算法一起使用，包括 Q-Learning、人工神经网络 (ANN)、朴素贝叶斯、随机森林和深度学习 [15]。接下来我们看看使用每种容错解决方案的方法的优点和缺点。 </p><p>Q-Learning 是一种无模型方法，主要用于通过学习每个状态-动作转换的最佳 Q 因子来找到最佳策略。它主要应用于任何具有有限状态的马尔可夫决策过程[20]。 Q-Learning 的关键优势在于它是无模型的，而且实施起来非常直接。 Q-Learning 的主要弱点是跟踪每个 Q-factor 所需的存储量，尤其是当状态-动作对的数量增长太大时。</p><p>人工神经网络可用于补充 Q-Learning。当状态值对的数量太大并且因此不能有效地存储在 Q 因子列表中时，将应用 ANN。因此，给定动作的所有 Q 因子都存储在一个网络中。然而，训练 ANN 来表示 Q 因子可能既复杂又耗时。</p><p>支持向量机是最近应用于强化学习的数据挖掘工具的一个例子，特别是在需要分类或回归时 [94]。 SVM 的优势包括高水平的预测准确性，即使在训练示例包含错误时它们也能发挥作用。在弱点方面，SVM 需要很长的训练时间，学习到的函数很难理解，因为它以权重表示。</p><p>朴素贝叶斯是一种基于贝叶斯定理的分类器，它是基于模型的，可以与强化学习一起使用。它在模型不完全已知且存在不确定性的情况下很有用。朴素贝叶斯的主要优势在于它被认为是快速、健壮的并且可以处理不完整的模型。朴素贝叶斯可以处理非常大的数据集，并且优于许多其他复杂的分类器。朴素贝叶斯的一个主要弱点是它依赖贝叶斯定理，该定理假定所有属性（特征）都是独立的。这样的假设可能导致简单地忽略预测中属性相关性的影响。</p><p>深度强化学习是深度神经网络与 RL 的应用。当状态-动作对的数量变得太大时，这特别有用。不是为每个状态-动作对存储 Q 因子，而是使用深度神经网络来存储每个动作的 Q 因子，这些网络也称为深度 Q 网络 (DQN) [95]。这种方法的关键优势在于能够处理大数据，从而使 RL 能够扩展到以前难以解决的问题领域 [96]。同时，他们的主要弱点与训练时间有关。</p><p>随机森林是基于树的分类结构，已与 RL 一起使用。基于树的算法的优势包括显着减少分类错误（高度准确）和降低计算资源负载 [97]。它们可以处理相当大的特征变量，并且在大型数据库上非常有效。在大多数报道中，随机森林为学习函数近似提供了更好的收敛性 [97]。在弱点方面，随机森林会遇到由过度生长的树木引起的过度拟合问题。交叉验证可用于解决过度拟合问题 [98]。</p><h2 id="Emerging-directions"><a href="#Emerging-directions" class="headerlink" title="Emerging directions"></a>Emerging directions</h2><p>根据作为本研究的一部分审查的论文（见表 2），很明显，目前有大量的容错解决方案<strong>仍然主要基于被动和主动方法</strong>。在云系统的背景下，这些方法的性能、灵活性和可扩展性仍有待证明。对于其中一些方法，不确定它们将如何在部署在分布式和异构云平台上的系统上工作。当前的方法不可扩展，需要某种形式的手动干预才能顺利运行和配置，因此，我们建议云中容错的<strong>未来将基于自动化</strong>。</p><p>在尝试解决其中一些挑战时，我们开始看到基于智能体的云计算的出现作为解决自主云问题的一种手段 [99]。因此，我们认为基于智能体的解决方案（包括强化学习）是云中自主容错的新兴方向。智能体是一个功能齐全的计算节点，能够独立做出决策并通过合作、协调和协商与其他智能体进行交互[99]。我们正在见证基于智能体的<strong>自动化</strong>在云的各个核心方面的出现，例如资源分配 [100]、[101]、作业&#x2F;任务调度 [102]、[103] 和容错 [104]。此外，我们将继续看到高级机器学习技术（例如深度学习）的开发和应用，以支持基于智能体的自动化方法、硬件和基础设施监控 [105]、[106]、[107]、[108]、[ 109] 和弹性缓存 [110] 对自主容错有直接影响。</p><p>以下段落回顾了最近的一些论文，其中研究了与云计算和容错相关的基于智能体的计算和强化学习范例.</p><p>Sim [99] 介绍了基于智能体的云计算的概念，并解释了如何将基于智能体的计算范式应用于云计算基础设施和资源的管理。 根据 Sim [99]，基于智能体的云计算涉及构建云的服务发现、服务协商和服务组合功能。 服务发现由 Cloudle 实现，Cloudle 是一个基于智能体的云服务搜索引擎。 进一步表明，基于智能体的协商机制可用于实现服务协商和云商务。 此外，基于智能体的协作问题解决技术被证明可以解决自动化云服务组合的问题。 实验结果表明，使用基于智能体的云计算自动化方法，智能体在协商云资源方面取得了很高的利用率和成功率。 智能体也可以通过自主选择 Cloudle 机制支持的服务来成功组合云服务。</p><p>阿拉伯内贾德等人。 [101] 描述了另一种自动化方法，其中 RL 可用于自动化云中的动态资源分配问题。目标是实施一个云管理解决方案，该解决方案根据系统工作负载的波动进行自适应和自动缩放。强化学习用于决定何时添加或删除资源，同时仍然保证商定的系统 SLA。使用模糊逻辑方法。比较了两种基于模糊逻辑的动态学习策略，即模糊 SARSA 学习 (FSL) 和模糊 Q 学习 (FQL)。这两种方法都能够处理不同的工作负载模式，例如突发性和周期性工作负载。此外，FSL 和 FQL 能够按需交付资源，同时降低运营成本并避免违反 SLA。</p><p>Dal ılia 和 Coutinho [104] 提出了一种基于自主和强化学习的解决方案，以解决机会主义网格系统中复制和检查点之间的平衡问题。这些机会网格系统被定义为通过使用非专用计算资源的空闲处理能力动态形成的低成本和大型计算网格。此类非专用资源可以在地理上分布在许多不同的管理域中，并且此类资源随机加入和离开网格。因此，需要不断地监测和检测网格形成事件并及时做出反应。 RL 用于自动调整用于在检查点和复制之间切换的阈值。使用 RL，切换决策基于网格中计算节点的数量和可靠性。实验结果表明，该方法能够学习在复制和检查点之间切换的最佳阈值。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文回顾了在分布式或云系统中实现容错的各种方法。我们将容错方法分为三大类：<strong>1）反应性方法； 2) 主动方法； 3）弹性方法</strong>。反应式和主动式方法主要基于传统的容错方法，如复制、检查点、重试、监控和抢占式迁移。</p><p>其中一些方法已在一定程度上用于实现云系统的容错。 例如，大多数使用虚拟化技术的数据中心都依赖于抢占式迁移来处理由服务器中断引起的故障。 这些传统方法有局限性。 首先，它们基于固定的逻辑并以其实现定义的特定方式处理故障。 因此，它们缺乏处理未来可能出现的新故障的能力。 其次，这些实现在做出处理故障的决策时只考虑固有的系统属性。 对可能影响系统性能（例如温度、功率和天气）的外部或环境属性的考虑非常有限。</p><p>由于计算的未来正在向云迁移，系统将面临传统容错方法无法处理的故障。因此，需要开发能够通过与运行环境的交互来学习和适应的系统。此类系统将需要使用<strong>机器学习方法</strong>作为其容错解决方案的一部分。正如我们在本文中所见，机器学习已被用于创建容错解决方案。然而，机器学习主要用作整体容错解决方案的一个子组件。一些解决方案主要使用机器学习来使用一组定义的变量进行预测。在其他应用中，机器学习已被用于管理硬件故障。这样的系统又是固定的并且不够动态以处理未来和未知的故障。</p><p>需要通过定义可在云环境中用于处理故障的可重用框架，将机器学习的应用进一步扩展到容错。这样的框架将被称为智能云。智能云的主要组成部分将是任何一组相互关联的智能体，并通过与它们将在其中执行的环境交互来学习如何处理故障。作为此的直接结果，这些智能体将有权做出连接决策，从而使他们也能够最佳地利用能源。</p><p>本文将未来的研究方向归于自动化。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] M. Armbrust, A. Fox, R. Griffith, A. D. Joseph, R. Katz, A. Konwinski, G. Lee, D. Patterson, A. Rabkin, I. Stoica, and M. Zaharia, “A view of cloud computing,” Commun. ACM, vol. 53, no. 4, pp. 50–58, Apr. 2010. </p><p>[2] A. Abid, M. T. Khemakhem, S. Marzouk, M. B. Jemaa, T. Monteil, and K. Drira, “Toward antifragile cloud computing infrastructures,” Procedia Comput. Sci., vol. 32, pp. 850–855, 2014. </p><p>[3] J. Liu, S. Wang, A. Zhou, S. Kumar, F. Yang, and R. Buyya, “Using proactive fault-tolerance approach to enhance cloud service reliability,” IEEE Trans. Cloud Comput., vol. PP, no. 99, p. 1, 2017, doi: 10.1109&#x2F;TCC.2016.2567392. </p><p>[4] A. Zhou, S. Wang, B. Cheng, Z. Zheng, F. Yang, R. N. Chang, M. R. Lyu, and R. Buyya, “Cloud service reliability enhancement via virtual machine placement optimization,” IEEE Trans. Serv. Comput., vol. 10, no. 6, pp. 902–913, Nov. 2017. </p><p>[5] A. Zhou, S. Wang, Z. Zheng, C. H. Hsu, M. R. Lyu, and F. Yang, “On cloud service reliability enhancement with optimal resource usage,” IEEE Trans. Cloud Comput., vol. 4, no. 4, pp. 452–466, Oct. 2016. </p><p>[6] S. Ananth and A. Saranya, “Reliability enhancement for cloud services—A survey,” in Proc. Int. Conf. Comput. Commun. Inform., Jan. 2016, pp. 1–7. </p><p>[7] J. W. Lin, C. H. Chen, and J. M. Chang, “QoS-aware data replication for data-intensive applications in cloud computing systems,” IEEE Trans. Cloud Comput., vol. 1, no. 1, pp. 101–115, Jan. 2013. </p><p>[8] Z. Qiu and J. F. Prez, “Enhancing reliability and response times via replication in computing clusters,” in Proc. IEEE Int. Conf. Comput. Commun., Apr. 2015, pp. 1355–1363. </p><p>[9] P. Bodık, I. Menache, M. Chowdhury, P. Mani, D. A. Maltz, and I. Stoica, “Surviving failures in bandwidth-constrained datacenters,” in Proc. ACM SIGCOMM Conf. Appl. Technol. Archit. Protocols Comput. Commun., 2012, pp. 431–442. </p><p>[10] J. Liu, S. Wang, A. Zhou, F. Yang, and R. Buy, “Availabilityaware virtual cluster allocation in bandwidth-constrained datacenters,” IEEE Trans. Serv. Comput., vol. PP, no. 99, p. 1, 2017, doi: 10.1109&#x2F;TSC.2017.2694838. </p><p>[11] W. Qiu, Z. Zheng, X. Wang, X. Yang, and M. R. Lyu, “Reliabilitybased design optimization for cloud migration,” IEEE Trans. Serv. Comput., vol. 7, no. 2, pp. 223–236, Apr. 2014. </p><p>[12] P. K. Patra, H. Singh, and G. Singh, “Fault tolerance techniques and comparative implementation in cloud computing,” Int. J. Comput. Appl., vol. 64, no. 14, pp. 37–41, Feb. 2013. </p><p>[13] G. Vallee, K. Charoenpornwattana, C. Engelmann, A. Tikotekar, C. Leangsuksun, T. Naughton, and S. L. Scott, “A framework for proactive fault tolerance,” in Proc. 3rd Int. Conf. Availability Rel. Secur., Mar. 2008, pp. 659–664. </p><p>[14] I. Egwutuoha, S. Chen, D. Levy, B. Selic, and R. Calvo, “A proactive fault tolerance approach to high performance computing (HPC) in the cloud,” in Proc. Int. Conf. Cloud Green Comput., Nov. 2012, pp. 268–273. </p><p>[15] Z. Amin, H. Singh, and N. Sethi, “Review on fault tolerance techniques in cloud computing,” Int. J. Comput. Appl., vol. 116, no. 18, pp. 11–17, Apr. 2015. </p><p>[16] G. P. Sarmila, N. Gnanambigai, and P. Dinadayalan, “Survey on fault tolerant—Load balancing algorithms in cloud computing,” in Proc. Int. Conf. Electron. Commun. Syst., Feb. 2015, pp. 1715–1720. </p><p>[17] J. Pinto, P. Jain, and T. Kumar, “Hadoop distributed computing clusters for fault prediction,” in Proc. Int. Comput. Sci. Eng. Conf., Dec. 2016, pp. 1–6. </p><p>[18] Y. Kwon, M. Balazinska, and A. Greenberg, “Fault-tolerant stream processing using a distributed, replicated file system,” Proc. VLDB Endowment, vol. 1, no. 1, pp. 574–585, Aug. 2008. </p><p>[19] F. Farivar and M. N. Ahmadabadi, “Continuous reinforcement learning to robust fault tolerant control for a class of unknown nonlinear systems,” Appl. Soft Comput., vol. 37, pp. 702–714, 2015. </p><p>[20] C.-Z. Xu, J. Rao, and X. Bu, “URL: A unified reinforcement learning approach for autonomic cloud management,” J. Parallel Distrib. Comput., vol. 72, no. 2, pp. 95–105, 2012. </p><p>[21] J. Wu, X. Xu, P. Zhang, and C. Liu, “A novel multi-agent reinforcement learning approach for job scheduling in grid computing,” Future Generation Comput. Syst., vol. 27, no. 5, pp. 430–439, 2011. </p><p>[22] L. Liu, Z. Wang, and H. Zhang, “Adaptive NN fault-tolerant control for discrete-time systems in triangular forms with actuator fault,” Neurocomput., vol. 152, pp. 209–221, 2015. </p><p>[23] A. Forster and A. L. Murphy, “FROMS: A failure tolerant and mobility enabled multicast routing paradigm with reinforcement learning for WSNs,” Ad Hoc Netw., vol. 9, no. 5, pp. 940–965, 2011. </p><p>[24] Y.-C. Wang and J. M. Usher, “Application of reinforcement learning for agent-based production scheduling,” Eng. Appl. Artif. Intell., vol. 18, no. 1, pp. 73–82, 2005. </p><p>[25] Z. Chen and D. Marculescu, “Distributed reinforcement learning for power limited many-core system performance optimization,” in Proc. Des. Autom. Test Eur. Conf. Exhib., 2015, pp. 1521–1526. </p><p>[26] R. Jhawar and V. Piuri, “Chapter 1—Fault tolerance and resilience in cloud computing environments,” in Cyber Security and IT Infrastructure Protection, J. R. Vacca, Ed. Boston, MA, USA: Syngress, 2014, pp. 1–28. </p><p>[27] H. Okamura, Y. Nishimura, and T. Dohi, “A dynamic checkpointing scheme based on reinforcement learning,” in Proc. IEEE Pacific Rim Int. Symp. Depend. Comput., Mar. 2004, pp. 151–158. </p><p>[28] L. Bautista-Gomez, S. Tsuboi, D. Komatitsch, F. Cappello, N. Maruyama, and S. Matsuoka, “FTI: High performance fault tolerance interface for hybrid systems,” in Proc. ACM&#x2F;IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2011, pp. 32:132:32. </p><p>[29] A. Moody, G. Bronevetsky, K. Mohror, and B. R. D. Supinski, “Design, modeling, and evaluation of a scalable multi-level checkpointing system,” in Proc. ACM&#x2F;IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2010, pp. 1–11. </p><p>[30] S. Di, L. Bautista-Gomez, and F. Cappello, “Optimization of a multilevel checkpoint model with uncertain execution scales,” in Proc. ACM&#x2F;IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2014, pp. 907–918. </p><p>[31] D. Singh, J. Singh, and A. Chhabra, “High availability of clouds: Failover strategies for cloud computing using integrated checkpointing algorithms,” in Proc. Int. Conf. Commun. Syst. Netw. Technol., May 2012, pp. 698–703. </p><p>[32] A. J. Oliner, L. Rudolph, and R. K. Sahoo, “Cooperative checkpointing: A robust approach to large-scale systems reliability,” in Proc. ACM Annu. Int. Conf. Supercomput., 2006, pp. 14–23.</p><p>[33] S. Di, M. S. Bouguerra, L. Bautista-Gomez, and F. Cappello, “Optimization of multi-level checkpoint model for large scale HPC applications,” in Proc. IEEE Int. Parallel Distrib. Process. Symp., May 2014, pp. 1181–1190. </p><p>[34] B. Mohammed, M. Kiran, K. M. Maiyama, M. M. Kamala, and I.-U. Awan, “Failover strategy for fault tolerance in cloud computing environment,” Softw.: Practice Experience, vol. 47, no. 9, pp. 1243–1274, 2017. </p><p>[35] I. Jangjaimon and N. F. Tzeng, “Effective cost reduction for elastic clouds under spot instance pricing through adaptive checkpointing,” IEEE Trans. Comput., vol. 64, no. 2, pp. 396–409, Feb. 2015. </p><p>[36] J. Zhao, Y. Xiang, T. Lan, H. H. Huang, and S. Subramaniam, “Elastic reliability optimization through peer-to-peer checkpointing in cloud computing,” IEEE Trans. Parallel Distrib. Syst., vol. 28, no. 2, pp. 491–502, Feb. 2017. </p><p>[37] M. Amoon, “Adaptive framework for reliable cloud computing environment,” IEEE Access, vol. 4, pp. 9469–9478, 2016. </p><p>[38] B. Balasubramanian and V. K. Garg, “Fault tolerance in distributed systems using fused data structures,” IEEE Trans. Parallel Distrib. Syst., vol. 24, no. 4, pp. 701–715, Apr. 2013. </p><p>[39] B. Cully, G. Lefebvre, D. Meyer, M. Feeley, N. Hutchinson, and A. Warfield, “Remus: High availability via asynchronous virtual machine replication,” in Proc. USENIX Symp. Netw. Syst. Des. Implementation, 2008, pp. 161–174. </p><p>[40] W. Zhao, P. Melliar-Smith, and L. Moser, “Fault tolerance middleware for cloud computing,” in Proc. IEEE Int. Conf. Cloud Comput., Jul. 2010, pp. 67–74. </p><p>[41] T. Wood, R. Singh, A. Venkataramani, P. Shenoy, and E. Cecchet, “ZZ and the art of practical BFT execution,” in Proc. ACM EuroSys Conf. Comput. Syst., 2011, pp. 123–138. </p><p>[42] M. Castro and B. Liskov, “Practical byzantine fault tolerance and proactive recovery,” ACM Trans. Comput. Syst., vol. 20, no. 4, pp. 398–461, Nov. 2002. </p><p>[43] P. Costa, M. Pasin, A. Bessani, and M. Correia, “Byzantine faulttolerant MapReduce: Faults are not just crashes,” in Proc. IEEE Int. Conf. Cloud Comput. Technol. Sci., Nov. 2011, pp. 32–39. </p><p>[44] K. Plankensteiner, R. Prodan, and T. Fahringer, “A new fault tolerance heuristic for scientific workflows in highly distributed environments based on resubmission impact,” in Proc. IEEE Int. Conf. e-Sci., Dec. 2009, pp. 313–320. </p><p>[45] A. Zhou, S. Wang, C.-H. Hsu, M. H. Kim, and K.-S. Wong, “Network failure-aware redundant virtual machine placement in a cloud data center,” Concurrency Comput.: Practice Experience, vol. 29, no. 24, 2017, Art. no. e4290. </p><p>[46] Z. Zheng, T. C. Zhou, M. R. Lyu, and I. King, “Component ranking for fault-tolerant cloud applications,” IEEE Trans. Serv. Comput., vol. 5, no. 4, pp. 540–550, Oct.–Dec. 2012. </p><p>[47] R. Jhawar, V. Piuri, and M. Santambrogio, “Fault tolerance management in cloud computing: A system-level perspective,” IEEE Syst. J., vol. 7, no. 2, pp. 288–297, Jun. 2013. </p><p>[48] C. Wang, L. Xing, H. Wang, Z. Zhang, and Y. Dai, “Processing time analysis of cloud services with retrying fault-tolerance technique,” in Proc. IEEE Int. Conf. Commun. China, Aug. 2012, pp. 63–67. </p><p>[49] G. Ramalingam and K. Vaswani, “Fault tolerance via idempotence,” SIGPLAN Notices, vol. 48, no. 1, pp. 249–262, Jan. 2013. </p><p>[50] A. Liu, Q. Li, L. Huang, and M. Xiao, “Facts: A framework for fault-tolerant composition of transactional web services,” IEEE Trans. Serv. Comput., vol. 3, no. 1, pp. 46–59, Jan. 2010. </p><p>[51] J. Yu and R. Buyya, “A taxonomy of scientific workflow systems for grid computing,” ACM SIGMOD Rec., vol. 34, no. 3, pp. 4449, Sep. 2005. </p><p>[52] I. Hernandez and M. Cole, “Reliable DAG scheduling on grids with rewinding and migration,” in Proc. ICST Int. Conf. Netw. Grid Appl., 2007, pp. 3:1–3:8. </p><p>[53] F. Saffre, R. Tateson, J. Halloy, M. Shackleton, and J. L. Deneubourg, “Aggregation dynamics in overlay networks and their implications for self-organized distributed applications,” Comput. J.,vol.52,no. 4, pp. 397–412, Jul. 2009. </p><p>[54] M. Randles, D. Lamb, and A. Taleb-Bendiab, “A comparative study into distributed load balancing algorithms for cloud computing,” in Proc. IEEE Int. Conf. Adv. Inf. Netw. Appl. Workshops, Apr. 2010, pp. 551–556. </p><p>[55] M. Randles, A. Taleb-Bendiab, and D. Lamb, “Scalable selfgovernance using service communities as ambients,” in Proc. World Conf. Services-I, Jul. 2009, pp. 813–820. </p><p>[56] O. Rahmeh, P. Johnson, and A. Taleb-Bendiab, “A dynamic biased random sampling scheme for scalable and reliable grid networks,” INFOCOMP J. Comput. Sci., vol. 7, no. 4, pp. 1–10, 2008. </p><p>[57] J. Oberheide, E. Cooke, and F. Jahanian, “CloudAV: N-version antivirus in the network cloud,” in Proc. USENIX Conf. Secur. Symp., 2008, pp. 91–106. </p><p>[58] J. Oberheide, K. Veeraraghavan, E. Cooke, J. Flinn, and F. Jahanian, “Virtualized in-cloud security services for mobile devices,” in Proc. ACM Workshop Virtualization Mobile Comput., 2008, pp. 31–35. </p><p>[59] K.-L. Peng, C.-Y. Huang, P.-H. Wang, and C.-J. Hsu, “Enhanced N-version programming and recovery block techniques for web service systems,” in Proc. ACM Int. Workshop Innovative Softw. Develop. Methodologies Practices, 2014, pp. 11–20. </p><p>[60] A. Avizienis, “The N-version approach to fault-tolerant software,” IEEE Trans. Softw. Eng., vol. 11, no. 12, pp. 1491–1501, Dec. 1985. </p><p>[61] P. Hosek and C. Cadar, “VARAN the unbelievable: An efficient N-version execution framework,” in Proc. ACM Int. Conf. Archit. Support Program. Languages Operating Syst., 2015, pp. 339–353. </p><p>[62] R. Hanmer, “Software rejuvenation,” in Proc. ACM Conf. Pattern Languages Programs, 2010, pp. 21:1–21:13. </p><p>[63] M. Melo, J. Araujo, R. Matos, J. Menezes, and P. Maciel, “Comparative analysis of migration-based rejuvenation schedules on cloud availability,” in Proc. IEEE Int. Conf. Syst. Man Cybern., Oct. 2013, pp. 4110–4115. </p><p>[64] F. Xin-Yuan, X. Guo-Zhi, Y. Ren-Dong, Z. Hao, and J. Le-Tian, “Performance analysis of software rejuvenation,” in Proc. Int. Conf. Parallel Distrib. Comput. Appl. Technol., Aug. 2003, pp. 562–566. </p><p>[65] R. Angarita, M. Rukoz, M. Manouvrier, and Y. Cardinale, “A knowledge-based approach for self-healing service-oriented applications,” in Proc. ACM Int. Conf. Manage. Digit. EcoSyst., 2016, pp. 1–8. </p><p>[66] J. O. Kephart and D. M. Chess, “The vision of autonomic computing,” Comput., vol. 36, no. 1, pp. 41–50, Jan. 2003. </p><p>[67] S. Dobson, R. Sterritt, P. Nixon, and M. Hinchey, “Fulfilling the vision of autonomic computing,” Comput., vol. 43, no. 1, pp. 3541, Jan. 2010. </p><p>[68] S. George, D. Evans, and L. Davidson, “A biologically inspired programming model for self-healing systems,” in Proc. ACM Workshop Self-Healing Syst., 2002, pp. 102–104. </p><p>[69] C. Engelmann, G. Vallee, T. Naughton, and S. Scott, “Proactive fault tolerance using preemptive migration,” in Proc. Euromicro Int. Conf. Parallel Distrib. Netw.-Based Process., Feb. 2009, pp. 252–257. </p><p>[70] A. B. Nagarajan, F. Mueller, C. Engelmann, and S. L. Scott, “Proactive fault tolerance for HPC with Xen virtualization,” in Proc. ACM Annu. Int. Conf. Supercomput., 2007, pp. 23–32. </p><p>[71] F. Hao, T. V. Lakshman, S. Mukherjee, and H. Song, “Enhancing dynamic cloud-based services using network virtualization,” in Proc. ACM Workshop Virtualized Infrastructure Syst. Archit., 2009, pp. 37–44. </p><p>[72] T. Wood, K. K. Ramakrishnan, P. Shenoy, and J. van der Merwe, “CloudNet: Dynamic pooling of cloud resources by live wan migration of virtual machines,” ACM SIGPLAN Notices, vol. 46, no. 7, pp. 121–132, Mar. 2011. </p><p>[73] P. Lu, A. Barbalace, and B. Ravindran, “HSG-LM: Hybrid-copy speculative guest OS live migration without hypervisor,” in Proc. ACM Int. Syst. Storage Conf., 2013, pp. 2:1–2:11. </p><p>[74] G. Dhiman, G. Marchetti, and T. Rosing, “vGreen: A system for energy-efficient management of virtual machines,” ACM Trans. Des. Autom. Electron. Syst., vol. 16, no. 1, pp. 6:1–6:27, Nov. 2010. </p><p>[75] T. Knauth and C. Fetzer, “VeCycle: Recycling VM checkpoints for faster migrations,” in Proc. ACM Annu. Middleware Conf., 2015, pp. 210–221. </p><p>[76] J. Li, C. Pu, Y. Chen, V. Talwar, and D. Milojicic, “Improving preemptive scheduling with application-transparent checkpointing in shared clusters,” in Proc. ACM Annu. Middleware Conf., 2015, pp. 222–234. </p><p>[77] A. Polze, P. Troger, and F. Salfner, “Timely virtual machine migration for pro-active fault tolerance,” in Proc. IEEE Int. Symp. Object&#x2F; Component&#x2F;Service-Oriented Real-Time Distrib. Comput. Workshops, Mar. 2011, pp. 234–243. </p><p>[78] Y. Zhong, J. Xu, Q. Li, H. Zhang, and F. Liu, “Memory state transfer optimization for pre-copy based live VM migration,” in Proc. IEEE Workshop Adv. Res. Technol. Ind. Appl., Sep. 2014, pp. 290–293. </p><p>[79] C. H. A. Costa, Y. Park, B. S. Rosenburg, C.-Y. Cher, and K. D. Ryu, “A system software approach to proactive memory-error avoidance,” in Proc. IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2014, pp. 707–718.</p><p>[80] A. Gainaru, F. Cappello, M. Snir, and W. Kramer, “Fault prediction under the microscope: A closer look into HPC systems,” in Proc. IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2012, pp. 77:1–77:11. </p><p>[81] O. Hannache and M. Batouche, “Probabilistic model for evaluating a proactive fault tolerance approach in the cloud,” in Proc. IEEE Int. Conf. Service Operations Logistics Informat., Nov. 2015, pp. 94–99. </p><p>[82] R. Rajachandrasekar, X. Besseron, and D. K. Panda, “Monitoring and predicting hardware failures in HPC clusters with FTBIPMI,” in Proc. IEEE Int. Parallel Distrib. Process. Symp. Workshops PhD Forum, May 2012, pp. 1136–1143. </p><p>[83] F. Salfner, M. Lenk, and M. Malek, “A survey of online failure prediction methods,” ACM Comput. Surveys, vol. 42, no. 3, pp. 10:1–10:42, Mar. 2010. </p><p>[84] A. Tikotekar, G. Vallee, T. Naughton, S. Scott, and C. Leangsuksun, “Evaluation of fault-tolerant policies using simulation,” in Proc. IEEE Int. Conf. Cluster Comput., Sep. 2007, pp. 303–311. </p><p>[85] I. Egwutuoha, S. Chen, D. Levy, and B. Selic, “A fault tolerance framework for high performance computing in cloud,” in Proc. IEEE&#x2F;ACM Int. Symp. Cluster Cloud Grid Comput., May 2012, pp. 709–710. </p><p>[86] T. Tung, S. Y. Chaw, Q. Xie, and Q. Zhu, “Highly resilient systems for cloud,” in Proc. IEEE Int. Conf. Web Serv., Jun. 2012, pp. 678–680. </p><p>[87] T. Limoncelli, “Resilience engineering: Learning to embrace failure,” Commun. ACM, vol. 55, no. 11, pp. 40–47, Nov. 2012. </p><p>[88] A. Benso and P. Prinetto, Eds., Fault Injection Techniques and Tools for Embedded Systems Reliability Evaluation. Berlin, Germany: Springer, 2003. </p><p>[89] H. J. C. Berendsen, D. V. D. Spoel, and R. V. Drunen, “GROMACS: A message-passing parallel molecular dynamics implementation,” Comput. Phys. Commun., vol. 91, pp. 43–56, 1995. </p><p>[90] J. Park, H. Yu, K. Chung, and E. Lee, “Markov chain based monitoring service for fault tolerance in mobile cloud computing,” in Proc. IEEE Workshops Int. Conf. Adv. Inf. Netw. Appl., Mar. 2011, pp. 520–525. </p><p>[91] C. Colman-Meixner, C. Develder, M. Tornatore, and B. Mukherjee, “A survey on resiliency techniques in cloud computing infrastructures and applications,” IEEE Commun. Surveys Tuts.,vol.18,no.3, pp. 2244–2281, Jul.–Sep. 2016. </p><p>[92] H. Li and S. Venugopal, “Using reinforcement learning for controlling an elastic web application hosting platform,” in Proc. ACM Int. Conf. Autonomic Comput., 2011, pp. 205–208. </p><p>[93] R. S. Sutton and A. G. Barto, Reinforcement Learning : An Introduction. Cambridge, MA, USA: MIT Press, 1998. </p><p>[94] T. G. Dietterich and X. Wang, Support Vectors for Reinforcement Learning. Berlin, Germany: Springer, 2001, pp. 600–600. </p><p>[95] Y. Li, “Deep reinforcement learning: An overview,” CoRR, vol. abs&#x2F;1701.07274, 2017, <a href="http://arxiv.org/abs/1701.07274">http://arxiv.org/abs/1701.07274</a> </p><p>[96] K. Arulkumaran, M. P. Deisenroth, M. Brundage, and A. A. Bharath, “Deep reinforcement learning: A brief survey,” IEEE Signal Process. Mag., vol. 34, no. 6, pp. 26–38, Nov. 2017, doi: 10.1109&#x2F;MSP.2017.2743240. </p><p>[97] A. Paul and D. P. Mukherjee, “Reinforced random forest,” in Proc. ACM Indian Conf. Comput. Vis. Graph. Image Process., 2016, pp. 1:1–1:8. </p><p>[98] P. Domingos, “A few useful things to know about machine learning,” Commun. ACM, vol. 55, no. 10, pp. 78–87, Oct. 2012. </p><p>[99] K. M. Sim, “Agent-based cloud computing,” IEEE Trans. Serv. Comput., vol. 5, no. 4, pp. 564–577, Oct.–Dec. 2012. </p><p>[100] K. M. SIM, “Agent-based approaches for intelligent intercloud resource allocation,” IEEE Trans. Cloud Comput., vol. PP, no. 99, p. 1, 2016, doi: 10.1109&#x2F;TCC.2016.2628375. </p><p>[101] H. Arabnejad, C. Pahl, P. Jamshidi, and G. Estrada, “A comparison of reinforcement learning techniques for fuzzy cloud autoscaling,” in Proc. IEEE&#x2F;ACM Int. Symp. Cluster Cloud Grid Comput., May 2017, pp. 64–73. </p><p>[102] D. Cui, Z. Peng, X. Jianbin, B. Xu, and W. Lin, “A reinforcement learning-based mixed job scheduler scheme for grid or IaaS cloud,” IEEE Trans. Cloud Comput., vol. PP, no. 99, p. 1, 2017, doi: 10.1109&#x2F;TCC.2017.2773078. </p><p>[103] L. Wang and E. Gelenbe, “Adaptive dispatching of tasks in the cloud,” IEEE Trans. Cloud Comput., vol. 6, no. 1, pp. 33–45, Jan. 2018, doi: 10.1109&#x2F;TCC.2015.2474406. </p><p>[104] A. Dalılia and L. R. Coutinho, “A fault tolerance approach based on reinforcement learning in the context of autonomic opportunistic grids,” in Proc. Int. Conf. Autonomic Auton. Syst., 2014, pp. 11–17. </p><p>[105] J. F. Murray, G. F. Hughes, and D. Schuurmans, “Machine learning methods for predicting failures in hard drives: A multipleinstance application,” J. Mach. Learn. Res., vol. 6, 2005, Art. no. 816. </p><p>[106] Y. Zhao, X. Liu, S. Gan, and W. Zheng, “Predicting disk failures with HMM- and HSMM-based approaches,” in Proc. Int. Conf. Adv. Data Mining. Appl. Theoretical Aspects, 2010, pp. 390–404. </p><p>[107] B. Zhu, G. Wang, X. Liu, D. Hu, S. Lin, and J. Ma, “Proactive drive failure prediction for large scale storage systems,” in Proc. IEEE Symp. Mass Storage Syst. Technol., 2013, pp. 1–5. </p><p>[108] Y. Wang, Q. Miao, E. Ma, K.-L. Tsui, and M. Pecht, “Online anomaly detection for hard disk drives based on Mahalanobis distance,” IEEE Trans. Rel., vol. 62, no. 1, pp. 136–145, Mar. 2013. </p><p>[109] J. Li, X. Ji, Y. Jia, B. Zhu, G. Wang, Z. Li, and X. Liu, “Hard drive failure prediction using classification and regression trees,” in Proc. IEEE&#x2F;IFIP Int. Conf. Depend. Syst. Netw., 2014, pp. 383–394.</p><p>[110] X. Qin, W. Zhang, W. Wang, J. Wei, H. Zhong, and T. Huang, “On-line cache strategy reconfiguration for elastic caching platform: A machine learning approach,” in Proc. IEEE Annu. Comput. Softw. Appl. Conf., Jul. 2011, pp. 523–534.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems&quot;&gt;&lt;a href=&quot;#Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems&quot; class=&quot;headerlink&quot; title=&quot;Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems&quot;&gt;&lt;/a&gt;Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;本文介绍了云计算中提出的容错方法的最新研究进展。本文将容错方法分为三类：1）反应式方法（RAMs）；2）预防性方法（PRMs）；和3）弹性方法（RSMs）。RAMs允许系统进入故障状态，然后尝试恢复系统。PRMs倾向于通过实施机制来避免错误影响系统，从而防止系统进入故障状态。另一方面，最近出现的RSMs旨在最小化系统从故障中恢复所需的时间。本文还探讨了机器学习和人工智能在RSM领域中如何发挥作用以最小化恢复时间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode108.将有序数组转换为二叉搜索树</title>
    <link href="2023/03/26/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>2023/03/26/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2023-03-26T11:19:20.000Z</published>
    <updated>2023-03-26T11:27:07.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/btree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/btree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归构造树</li></ul><p>在这个实现中，我们采用了递归的方法构建高度平衡的二叉搜索树。在每次递归中，我们找到当前子数组的中间元素作为根节点，然后递归构建左右子树，最后将根节点返回。在递归过程中，我们使用两个指针 <code>left</code> 和 <code>right</code> 分别表示当前子数组的左右边界。如果 <code>left &gt; right</code>，则说明当前子数组为空，递归结束，返回 <code>nullptr</code>。C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F; 调用buildBST函数        return buildBST(nums, 0, nums.size() - 1);    &#125;private:    TreeNode* buildBST(vector&lt;int&gt;&amp; nums, int left, int right) &#123;        if (left &gt; right) &#123;            &#x2F;&#x2F; 若left &gt; right 则直接返回空指针            return nullptr;         &#125;        int mid &#x3D; left + (right - left) &#x2F; 2; &#x2F;&#x2F; 寻找mid的大小，将nums[mid]作为树的根节点        TreeNode* root &#x3D; new TreeNode(nums[mid]); &#x2F;&#x2F; 新建根节点，节点的值为nums[mid]        &#x2F;&#x2F; 递归调用buildBST函数构造left和right树，并将其赋值给root-&gt;left和root-&gt;right        root-&gt;left &#x3D; buildBST(nums, left, mid - 1);         root-&gt;right &#x3D; buildBST(nums, mid + 1, right);        &#x2F;&#x2F; 返回根节点        return root;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，其中元素已经按 &lt;strong&gt;升序&lt;/strong&gt; 排列，请你将其转换为一棵 &lt;strong&gt;高度平衡&lt;/strong&gt; 二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高度平衡&lt;/strong&gt; 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode214.最短回文串</title>
    <link href="2023/03/23/leetcode214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>2023/03/23/leetcode214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2023-03-23T06:14:31.000Z</published>
    <updated>2023-03-23T06:27:13.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <em><strong>s</strong></em>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;aacecaaa&quot;输出：&quot;aaacecaaa&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;输出：&quot;dcbabcd&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>KMP算法求解</li></ul><p>本题可以通过将原字符串翻转后与原字符串拼接，然后在新的字符串中找到以原字符串开头的最长回文子串，最后将翻转字符串的前缀加到原字符串前面即可得到新的字符串。为了找到以原字符串开头的最长回文子串，可以使用KMP算法中的next数组，将新的字符串l的next数组求出来，那么l.size() - 1位置处的值就是以原字符串开头的最长回文子串的长度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string shortestPalindrome(string s) &#123;        &#x2F;&#x2F; 将字符串s翻转并存储在rev_s中        string rev_s &#x3D; s;        reverse(rev_s.begin(), rev_s.end());        &#x2F;&#x2F; 将s和rev_s拼接，并用“#”分割        string l &#x3D; s + &quot;#&quot; + rev_s;        &#x2F;&#x2F; 初始化一个大小为l.size()的数组p        vector&lt;int&gt; p(l.size(), 0);        &#x2F;&#x2F; 通过循环遍历l，求出p数组        for (int i &#x3D; 1; i &lt; l.size(); i++) &#123;            int j &#x3D; p[i - 1];            while (j &gt; 0 &amp;&amp; l[i] !&#x3D; l[j]) j &#x3D; p[j - 1];            p[i] &#x3D; (j +&#x3D; l[i] &#x3D;&#x3D; l[j]);        &#125;        &#x2F;&#x2F; 返回一个由rev_s的前缀和s组成的新字符串        return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;    &#125;&#125;;</code></pre><blockquote><p>以输入<code>s=&quot;aacecaaa&quot;</code>为例，说明代码的运行过程：</p><p>首先将字符串s翻转得到rev_s&#x3D;”aaacecaa”，然后将s和rev_s用”#”分割拼接起来得到l&#x3D;”aacecaaa#aaacecaa”。</p><p>然后初始化一个大小为l.size()的数组p，数组中每个元素表示对应位置之前的字符串的最长相同前缀后缀的长度。</p><p>接下来使用KMP算法的思想，通过遍历l来求得数组p的所有元素。从i&#x3D;1开始，依次比较l[i]和l[p[i-1]]，如果不相同，则令j&#x3D;p[i-1]，并循环将j更新为p[j-1]，直到j&#x3D;0或者找到一个位置k使得l[i]和l[k]相等。如果找到了k，则令p[i]&#x3D;k+1，否则令p[i]&#x3D;0。</p><p>经过上述循环遍历后，p数组的最后一个元素p[l.size()-1]表示以原字符串开头的最长回文子串的长度，即3。因此，可以将rev_s的前缀”aa”加到s的前面，得到新的字符串为”aaacecaaa”，这个字符串是由原字符串”aacecaaa”通过添加最少字符得到的回文串。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;em&gt;&lt;strong&gt;s&lt;/strong&gt;&lt;/em&gt;，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode151.反转字符串中的单词</title>
    <link href="2023/03/22/leetcode151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>2023/03/22/leetcode151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2023-03-22T02:01:36.000Z</published>
    <updated>2023-03-22T02:31:09.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;  hello world  &quot;输出：&quot;world hello&quot;解释：反转后的字符串中不能存在前导空格和尾随空格。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;a good   example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>大致思路：将字符串中的每个单词放入动态数组中，然后将动态数组倒序遍历得到结果字符串，最后返回结果字符串，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseWords(string s) &#123;        &#x2F;&#x2F; 特判：如果s的长度为1，则只包含一个单词，此时直接返回s即可        if (s.length() &#x3D;&#x3D; 1) return s;        &#x2F;&#x2F; 新建s_vec动态数组，元素类型为string        vector&lt;string&gt; s_vec;        &#x2F;&#x2F; 定义left，它是指向字符串里第一个单词的第一个字母的指针        int left &#x3D; 0; &#x2F;&#x2F; left的初始化        while (s[left] &#x3D;&#x3D; &#39; &#39;) &#123;            left++;  &#x2F;&#x2F; 防止字符串一开始就是空格        &#125;        &#x2F;&#x2F; 开始循环        for (int i &#x3D; left; i &lt; s.length(); i++) &#123;            &#x2F;&#x2F; 当i指向一个单词右边的第一个空格或者字符串的最后一个元素时            if (s[i] &#x3D;&#x3D; &#39; &#39; || i &#x3D;&#x3D; s.length() - 1) &#123;                if (i &#x3D;&#x3D; s.length()-1) i++; &#x2F;&#x2F; 当i指向字符串的最后一个字母时，需要自增1，否则无法通过substr获得子串                string temp &#x3D; s.substr(left, i - left); &#x2F;&#x2F; 使用substr获得子串                s_vec.push_back(temp); &#x2F;&#x2F; 将子串push进动态数组s_vec中                while (s[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; i &lt; s.length()) &#123;                    i++; &#x2F;&#x2F; 令i从其之后的第一个非空字母开始遍历                &#125;                left &#x3D; i; &#x2F;&#x2F; 更新left的值            &#125;        &#125;        if (s[s.length()-1] !&#x3D; &#39; &#39; &amp;&amp; s[s.length()-2] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 针对字符串最后的一个单词只有一个字母的特判            string temp &#x3D; s.substr(s.length()-1);            s_vec.push_back(temp);        &#125;        int n &#x3D; s_vec.size(); &#x2F;&#x2F; 获取动态数组的大小（也就是总的单词个数）        string result; &#x2F;&#x2F; 定义结果字符串        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123; &#x2F;&#x2F; 反向遍历，将结果同result相加            if (i &#x3D;&#x3D; n - 1) &#123; &#x2F;&#x2F; 第一个单词前无需加空格                result &#x3D; result + s_vec[i];            &#125;            else &#123; &#x2F;&#x2F; 其他单词在同result合并前需要先加一个空格                result &#x3D; result + &quot; &quot; + s_vec[i];             &#125;        &#125;        return result; &#x2F;&#x2F; 返回result字符串    &#125;&#125;;</code></pre><ul><li>空间复杂度为O(1)的解法</li></ul><ol><li>将整个字符串进行反转</li><li>将反转后的字符串的每个单词进行反转</li><li>去除字符串中多余的空格</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseWords(string s) &#123;        reverse(s.begin(), s.end()); &#x2F;&#x2F; 翻转整个字符串        int n &#x3D; s.size();        int idx &#x3D; 0;        for (int start &#x3D; 0; start &lt; n; ++start) &#123;            if (s[start] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 找到单词的起始位置                if (idx !&#x3D; 0) s[idx++] &#x3D; &#39; &#39;; &#x2F;&#x2F; 添加单词间空格                int end &#x3D; start;                while (end &lt; n &amp;&amp; s[end] !&#x3D; &#39; &#39;) s[idx++] &#x3D; s[end++]; &#x2F;&#x2F; 翻转单词                reverse(s.begin() + idx - (end - start), s.begin() + idx); &#x2F;&#x2F; 翻转单词                start &#x3D; end;            &#125;        &#125;        s.erase(s.begin() + idx, s.end()); &#x2F;&#x2F; 删除多余的空格        return s;    &#125;&#125;;</code></pre><blockquote><p>当我们调用reverse函数时，它会将字符串中的字符进行翻转。例如，如果我们有一个字符串”hello”，那么调用reverse函数后，它会变成”olleh”。在这个题目中，我们需要将整个字符串进行翻转，所以我们调用了reverse(s.begin(), s.end())函数来实现这个功能。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你反转字符串中 &lt;strong&gt;单词&lt;/strong&gt; 的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单词&lt;/strong&gt; 是由非空格字符组成的字符串。&lt;code&gt;s&lt;/code&gt; 中使用至少一个空格将字符串中的 &lt;strong&gt;单词&lt;/strong&gt; 分隔开。&lt;/p&gt;
&lt;p&gt;返回 &lt;strong&gt;单词&lt;/strong&gt; 顺序颠倒且 &lt;strong&gt;单词&lt;/strong&gt; 之间用单个空格连接的结果字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;输入字符串 &lt;code&gt;s&lt;/code&gt;中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>基于改进差分进化算法的云端科学工作流调度自适应故障检测策略</title>
    <link href="2023/03/21/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%91%E7%AB%AF%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%B0%83%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5/"/>
    <id>2023/03/21/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%91%E7%AB%AF%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%B0%83%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5/</id>
    <published>2023-03-21T12:03:37.000Z</published>
    <updated>2023-03-21T13:12:58.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于改进差分进化算法的云端科学工作流调度自适应故障检测策略"><a href="#基于改进差分进化算法的云端科学工作流调度自适应故障检测策略" class="headerlink" title="基于改进差分进化算法的云端科学工作流调度自适应故障检测策略"></a>基于改进差分进化算法的云端科学工作流调度自适应故障检测策略</h2><p>原题目：An adaptive fault detector strategy for scientific workflow scheduling based on improved differential evolution algorithm in cloud</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>讨论了在云计算环境中执行大规模科学工作流程的挑战，并提出了一种基于改进差分进化算法的<strong>自适应故障检测器策略</strong>，以最小化能源消耗、总成本和时间，并在调度科学工作流程时<strong>容忍故障</strong>。此外，该文章还介绍了一种自适应基于网络的模糊推理系统（ANFIS）预测模型，用于主动控制资源负载波动并提高故障预测准确性。</p><span id="more"></span><p><strong>通过对文章的阅读了解容错到底是什么</strong></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>介绍了在大规模的云计算环境中，错误会导致用于计算的虚拟机不可用，因此，通过提出一个有效且高效的容错策略来对错误发生时的问题进行处理是很有必要的。</p><p>传统方法进行容错的实现是需要了解云计算结构以及大量的知识和经验的，在实施时代价昂贵，且在缺少建模的条件下无法准确地进行容错评估。</p><p>在很多现实世界的工作流调度中，多目标优化方法可以用于优化虚拟机的任务调度以满足用户需求。然而大多数的现有方法并未考虑到容错技术的使用。</p><p>Differential evolution算法很高效，但也有陷入局部最优以及收敛过慢的问题，因此本文通过优化F和CR参数来解决这些问题</p><p>总的来说，本文的贡献是提出了一种自适应故障容错工作流调度方法，该方法基于改进差分进化算法和多目标IDE算法，结合主动和反应技术。该方法通过应用自适应基于网络的模糊推理系统（ANFIS）预测模型来预测未来资源负载，从而主动控制资源负载波动并提高故障预测准确性。此外，在故障&#x2F;失败发生后，该方法还通过反应性容错控制器来保证应用程序执行的可靠性。这种方法可以最小化能源消耗、总成本和时间，并在调度科学工作流程时容忍故障。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>本文的相关工作主要讨论了故障检测和容错技术在云计算环境中的应用。文章指出，故障发生在系统中表明任务执行能力的无法实现，可能发生在网络的任何节点或任何过程中的不同组件中。相关工作还探讨了云计算环境下的工作流调度问题，并介绍了一些传统方法，如遗传算法、蚁群算法和粒子群优化算法等。此外，相关工作还介绍了一些基于云计算环境的故障检测和容错技术，如虚拟机迁移、备份和恢复等。</p><p><img src="http://cdn.leafii.top/img/image-20230321202533280.png" alt="image-20230321202533280" loading="lazy"></p><h3 id="Workflow-model"><a href="#Workflow-model" class="headerlink" title="Workflow model"></a>Workflow model</h3><p>本文的工作流模型使用了直接无环图（DAG）来表示云计算环境中的工作流。该模型由一组任务和任务之间的依赖关系组成，其中每个任务都有一个权重，表示其参考值。具体地，该模型可以表示为： $W&#x3D;(T,D)$ 其中，$T&#x3D;{T_0,T_1,…,T_n}$是一组任务，$D&#x3D;{(T_i,T_j)|T_i,T_j \in T}$是任务之间的依赖关系集合。 每个任务都有一个权重$w_i$，表示其参考值。因此，我们可以将工作流模型表示为一个带权有向无环图（weighted directed acyclic graph），如下所示： $$G&#x3D;(V,E)$$ 其中，$V&#x3D;{v_0,v_1,…,v_n}$是节点集合，对应于任务集合$T$；$E&#x3D;{(v_i,v_j)|w_{ij}\neq 0}$是边集合，对应于依赖关系集合$D$。</p><p><img src="http://cdn.leafii.top/img/image-20230321202544971.png" alt="image-20230321202544971" loading="lazy"></p><blockquote><p>DAG是一种有向无环图，其中每个节点表示一个任务，每条边表示任务之间的依赖关系。在云计算环境中，DAG通常用于表示工作流模型，其中每个任务都有一个权重，表示其参考值。DAG可以帮助我们更好地理解和可视化工作流程，并且可以用于优化工作流程的调度和执行。在本文中，作者使用了一个样例DAG来说明其应用。</p></blockquote><h3 id="Proposed-framework"><a href="#Proposed-framework" class="headerlink" title="Proposed framework"></a>Proposed framework</h3><p>本文的proposed framework主要提出了一种基于自适应故障容错技术的多目标工作流调度框架。该框架使用了主动和反应技术来控制资源负载波动，并通过反应性容错控制器来保证应用程序执行的可靠性。具体来说，该框架包括以下组件： </p><ol><li>Workflow task queue：将用户提交的工作流程按照一定规则排列在队列中，等待分配到云数据中心的虚拟机上执行。</li><li>MAPE-k control loop：该控制循环由四个组件组成，包括monitor、analyzer、planner和executer。这些组件共享一个知识库，用于监测、分析、计划和执行工作流程。</li><li>ANFIS prediction model：该模型是一种自适应基于网络的模糊推理系统，用于预测未来资源负载，并通过主动控制资源负载波动来提高故障预测准确性。</li><li>Reactive fault-tolerant controller：该控制器是一种反应性容错技术，用于在故障&#x2F;失败发生后保证应用程序执行的可靠性。</li></ol><p> 本文提出的框架可以最小化能源消耗、总成本和时间，并在调度科学工作流程时容忍故障。</p><p><img src="http://cdn.leafii.top/img/image-20230321203418941.png" alt="image-20230321203418941" loading="lazy"></p><h4 id="Monitor-component"><a href="#Monitor-component" class="headerlink" title="Monitor component"></a>Monitor component</h4><p>Monitor component被描述为一个组件，其主要职责是收集云数据中心中的工作流任务信息和资源负载率。具体来说，用户传感器和资源传感器会在预定的时间间隔内从应用程序和云环境中收集足够的数据，并将其提供给Monitor component。其中，用户传感器的职责是收集用户工作流任务的信息（如请求速率、类型、大小等），而资源传感器的职责是收集资源负载率的信息（如CPU负载、应用内存和网络流量）。Monitor component会将监测到的数据进行整合，并存储在知识库中以供分析组件使用。</p><h4 id="Analyzer-component"><a href="#Analyzer-component" class="headerlink" title="Analyzer component"></a>Analyzer component</h4><p>在本文中，Analyzer component被描述为一个组件，其主要职责是分析Monitor component收集到的负载信息，并预测未来的资源负载。具体来说，Analyzer component使用ANFIS神经网络模型来预测未来的资源负载，并根据Monitor component的反馈进行调整。预测值会被传输到Planner component中，以便根据系统条件自适应地选择工作流调度算法。通过分析和预测资源负载，Analyzer component可以帮助实现负载均衡和最佳性能。</p><p>当Analyzer component接收到Monitor component传递的数据后，它会使用ANFIS神经网络模型来预测未来的资源负载。ANFIS模型是一种自适应基于网络的模糊推理系统，可以处理非线性和动态系统，并具有良好的泛化能力。在本文中，ANFIS模型被用于预测未来的资源负载，并根据Monitor component的反馈进行调整。具体来说，当预测值与实际值不匹配时，Analyzer component会根据误差信号对ANFIS模型进行调整，以提高预测准确性。 除了资源负载预测外，Analyzer component还可以执行其他分析任务，例如检查工作流任务之间的依赖关系、计算任务权重和优先级等。通过这些分析任务，Analyzer component可以帮助实现更好的工作流调度和执行效果。</p><h4 id="Fuzzy-Planner-component"><a href="#Fuzzy-Planner-component" class="headerlink" title="Fuzzy Planner component"></a>Fuzzy Planner component</h4><p>在本文中，Fuzzy Planner component被描述为一个组件，其主要职责是根据Analyzer component预测的资源负载来分配工作流任务到高效的云资源上。具体来说，Fuzzy Planner component使用三个模糊if-then规则来进行工作流任务分配： </p><ol><li>如果资源负载被预测为正常，则执行“无变化”命令，并调用IDE调度算法。 </li><li>如果资源负载被预测为高，则执行“未来可能发生错误”的命令，并调用主动容错控制器以减少负载。</li><li>如果资源负载被预测为非常高，则执行“故障发生”的命令。</li></ol><p> 这些规则是基于模糊逻辑和经验知识设计的，并可以根据实际情况进行修改和优化。通过使用Fuzzy Planner component，可以实现更好的工作流任务分配和资源利用率。</p><h5 id="IDE算法"><a href="#IDE算法" class="headerlink" title="IDE算法"></a>IDE算法</h5><p>在本文中，IDE算法的具体设计内容如下：</p><ol><li>初始化种群：首先，随机生成一组初始解作为种群，并计算每个解的适应度值。</li><li>变异操作：对于每个个体，随机选择另外两个不同的个体，并计算它们之间的差异向量。然后，将差异向量与当前个体进行加权和操作，得到一个新的变异向量。</li><li>交叉操作：将变异向量与当前个体进行交叉操作，得到一个新的解。</li><li>选择操作：根据适应度函数选择最优解，并将其作为下一代种群中的父代。</li><li>自适应参数设置：通过自适应参数设置技术来调整IDE算法中的参数。</li></ol><p>具体来说，通过监测种群中最优解和平均适应度值之间的差异来调整缩放因子和交叉概率等参数。 通过以上步骤，IDE算法可以在连续空间中寻找最优解，并且具有较好的收敛速度和搜索能力。</p><p>在本文中，IDE算法优化的目标是最小化工作流任务的makespan、总成本和能源消耗。具体来说，IDE算法的目标函数可以表示为： </p><p>$ f(x) &#x3D; w_1 \times makespan(x) + w_2 \times cost(x) + w_3 \times energy(x) $</p><p>其中，$x$表示工作流任务的调度方案，$makespan(x)$表示完成所有任务所需的时间，$cost(x)$表示执行任务所需的总成本，$energy(x)$表示执行任务所需的总能源消耗。$w_1, w_2, w_3$是权重系数，用于平衡不同目标之间的重要性。 通过优化上述目标函数，IDE算法可以得到一个最优的工作流调度方案，以实现更好的性能和效率。</p><h5 id="Proactive-fault-tolerance-controller"><a href="#Proactive-fault-tolerance-controller" class="headerlink" title="Proactive fault-tolerance controller"></a>Proactive fault-tolerance controller</h5><p>在本文中，Proactive fault-tolerance controller被描述为一种主动容错控制器，其主要目的是防止进入故障区域并将新负载分配给异常的虚拟机。具体来说，当Analyzer component检测到资源负载过高时，Fuzzy Planner component会调用Proactive fault-tolerance controller来减少负载并防止系统进入故障状态。 </p><p>Proactive fault-tolerance controller的实现方式是通过监测虚拟机的资源利用率和性能指标来判断是否存在异常情况。如果发现某个虚拟机出现了异常情况，则Proactive fault-tolerance controller会立即将其从负载均衡中移除，并将其上的任务重新分配给其他正常的虚拟机。这样可以避免故障扩散和系统崩溃。</p><p> 总之，Proactive fault-tolerance controller是一种有效的容错控制器，可以帮助云环境实现更好的容错性能和可靠性。</p><h5 id="Reactive-fault-tolerance-controller"><a href="#Reactive-fault-tolerance-controller" class="headerlink" title="Reactive fault-tolerance controller"></a>Reactive fault-tolerance controller</h5><p>在本文中，Reactive fault-tolerance controller被描述为一种响应式容错控制器，其主要目的是在故障发生后减少故障的影响。具体来说，当Analyzer component检测到某个虚拟机出现故障时，Fuzzy Planner component会调用Reactive fault-tolerance controller来处理故障并恢复系统正常运行。 </p><p>Reactive fault-tolerance controller的实现方式是通过使用复制技术来提供容错能力。具体来说，当某个虚拟机出现故障时，Reactive fault-tolerance controller会将该虚拟机上的任务复制到其他正常的虚拟机上，并重新分配这些任务以保证系统正常运行。这样可以避免任务丢失和系统崩溃。</p><p> 需要注意的是，Reactive fault-tolerance controller的主要缺点是成本较高。因为它需要额外的资源和计算能力来处理故障和执行复制操作。因此，在实际应用中需要权衡成本和性能之间的关系，并选择合适的容错策略。 </p><p>总之，Reactive fault-tolerance controller是一种有效的容错控制器，在云环境中可以帮助提高系统可靠性和容错性能。</p><h4 id="Executer-component-for-the-workflow-tasks-allocation"><a href="#Executer-component-for-the-workflow-tasks-allocation" class="headerlink" title="Executer component for the workflow tasks allocation"></a>Executer component for the workflow tasks allocation</h4><p>执行组件负责根据调度阶段执行的算法将用户发送的所有请求分配给现有的虚拟机。该组件负责实际执行规划组件决定的操作。</p><h3 id="Performance-evaluation"><a href="#Performance-evaluation" class="headerlink" title="Performance evaluation"></a>Performance evaluation</h3><p>实验部分不作具体分析</p><p>在本文中，“Performance evaluation”部分描述了作者如何评估所提出的工作流调度算法的性能。具体来说，作者使用了WorkflowSim-1.0工具包和CloudSim模拟器来模拟云环境中的工作流，并评估所提出的算法在不同负载下的性能表现。</p><p>在实验中，作者使用了一组实验设置，包括虚拟机数量、任务数量、任务大小等参数。通过对这些参数进行不同组合和调整，作者可以模拟不同负载下的云环境，并评估所提出算法的性能表现。 </p><p>最终，作者通过比较所提出算法和其他常用算法（如HEFT、Min-Min等）在不同负载下的性能指标（如makespan、总成本等）来评估其性能。实验结果表明，所提出算法可以显著提高系统性能和效率，并且在各项指标上均优于其他常用算法。 </p><p>总之，“Performance evaluation”部分描述了作者如何评估所提出算法的性能，并给出了实验结果和结论。这些结果可以帮助读者更好地理解该算法的优点和局限性，并为进一步研究和应用提供参考。</p><h4 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h4><p>“Conclusion and future work”部分是本文的结论和未来工作方向。具体来说，该部分总结了本文的主要贡献和发现，并提出了一些未来研究的方向。 </p><p>在结论部分，作者指出所提出的工作流调度算法可以显著提高云环境中的性能和效率，并且在各项指标上均优于其他常用算法。作者还强调了该算法的可扩展性和适应性，并指出它可以应用于不同类型的云环境和工作流场景。 </p><p>在未来工作方向中，作者提出了一些有待进一步研究的问题，如如何进一步优化算法性能、如何处理更复杂的工作流场景、如何实现更高效的容错机制等。这些问题都是当前云计算领域面临的挑战，也是未来研究需要解决的重要问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&quot;&gt;&lt;a href=&quot;#基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&quot; class=&quot;headerlink&quot; title=&quot;基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&quot;&gt;&lt;/a&gt;基于改进差分进化算法的云端科学工作流调度自适应故障检测策略&lt;/h2&gt;&lt;p&gt;原题目：An adaptive fault detector strategy for scientific workflow scheduling based on improved differential evolution algorithm in cloud&lt;/p&gt;
&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;讨论了在云计算环境中执行大规模科学工作流程的挑战，并提出了一种基于改进差分进化算法的&lt;strong&gt;自适应故障检测器策略&lt;/strong&gt;，以最小化能源消耗、总成本和时间，并在调度科学工作流程时&lt;strong&gt;容忍故障&lt;/strong&gt;。此外，该文章还介绍了一种自适应基于网络的模糊推理系统（ANFIS）预测模型，用于主动控制资源负载波动并提高故障预测准确性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="进化算法" scheme="tags/进化算法/"/>
    
    <category term="容错" scheme="tags/容错/"/>
    
    <category term="云计算" scheme="tags/云计算/"/>
    
    <category term="工作流调度" scheme="tags/工作流调度/"/>
    
  </entry>
  
  <entry>
    <title>leetcode28.找出字符串中第一个匹配项的下标</title>
    <link href="2023/03/21/leetcode28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/"/>
    <id>2023/03/21/leetcode28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</id>
    <published>2023-03-21T08:03:49.000Z</published>
    <updated>2023-03-21T08:55:29.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：haystack &#x3D; &quot;sadbutsad&quot;, needle &#x3D; &quot;sad&quot;输出：0解释：&quot;sad&quot; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：haystack &#x3D; &quot;leetcode&quot;, needle &#x3D; &quot;leeto&quot;输出：-1解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>暴力解法</li></ol><p>首先判断haystack的长度是否小于needle，若小于则直接返回-1.然后对haystack进行遍历，若haystack[i]&#x3D;&#x3D;needle[0]，则说明haystack同needle的第一个字符匹配了，此时直接求haystack在i上长度为needle长度的子串并比较他们是否相等，若相等则直接返回i即可，否则继续遍历haystack。C++解法如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        int m &#x3D; haystack.length();         int n &#x3D; needle.length(); &#x2F;&#x2F; 分别求两个字符串的长度        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; 此判断符合strStr函数的原始定义        if (m &lt; n) return -1; &#x2F;&#x2F; 若haystack长度小于needle长度，则直接返回-1        for (int i &#x3D; 0; i &lt; m; i++) &#123; &#x2F;&#x2F; 遍历匹配第一个字母            if (haystack[i] &#x3D;&#x3D; needle[0]) &#123; &#x2F;&#x2F; 若第一个字母成功匹配                string temp &#x3D; haystack.substr(i, n); &#x2F;&#x2F; 直接求下标为i，长度同needle相等的子串temp                if (temp &#x3D;&#x3D; needle) &#123; &#x2F;&#x2F; 判断temp与needle是否相等                    return i; &#x2F;&#x2F; 若相等，则直接返回i                &#125;            &#125;        &#125;        return -1; &#x2F;&#x2F; 否则返回-1    &#125;&#125;;</code></pre><ol start="2"><li>KMP算法</li></ol><p>KMP的详细介绍：<a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html</a></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void getNext(int* next, const string&amp; s) &#123;        int j &#x3D; -1;        next[0] &#x3D; j;        for(int i &#x3D; 1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 注意i从1开始            while (j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; s[j+1]) &#123; &#x2F;&#x2F;前后缀不相同了                j &#x3D; next[j];            &#125;            if (s[i] &#x3D;&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 找到相同的前后缀                j++;            &#125;            next[i] &#x3D; j; &#x2F;&#x2F; 将j（前缀的长度）赋给next[i]        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if (needle.size() &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);        int j &#x3D; -1;        for (int i &#x3D; 0; i &lt; haystack.size(); i++) &#123; &#x2F;&#x2F; 注意i从0开始            while(j &gt;&#x3D; 0 &amp;&amp; haystack[i] !&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 不匹配                j &#x3D; next[j]; &#x2F;&#x2F; j寻找之前匹配的位置            &#125;            if (haystack[i] &#x3D;&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 匹配，j和i同时向后移动                j++;            &#125;            if (j &#x3D;&#x3D;(needle.size() - 1))  &#123; &#x2F;&#x2F; 文本串s里出现了模式串t                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;haystack&lt;/code&gt; 和 &lt;code&gt;needle&lt;/code&gt; ，请你在 &lt;code&gt;haystack&lt;/code&gt; 字符串中找出 &lt;code&gt;needle&lt;/code&gt; 字符串的第一个匹配项的下标（下标从 0 开始）。如果 &lt;code&gt;needle&lt;/code&gt; 不是 &lt;code&gt;haystack&lt;/code&gt; 的一部分，则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer05.替换空格</title>
    <link href="2023/03/20/%E5%89%91%E6%8C%87Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>2023/03/20/%E5%89%91%E6%8C%87Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2023-03-20T08:11:28.000Z</published>
    <updated>2023-03-20T08:16:16.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><p><strong>限制：</strong></p><pre class="language-none"><code class="language-none">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>常规思路</li></ul><p>新建一个string类型的变量result，对输入的字符串s的每个字符进行判断，若字符为空格，则<code>result+=&quot;%20;&quot;</code>，否则<code>result+=s[i];</code>，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string replaceSpace(string s) &#123;        string result &#x3D; &quot;&quot;; &#x2F;&#x2F; 定义结果字符串result        int n &#x3D; s.length(); &#x2F;&#x2F; 获取输入字符串s的长度        for(int i &#x3D; 0; i &lt; n; i++) &#123; &#x2F;&#x2F; 进行遍历            if (s[i] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 若s[i]为空格，则result+&#x3D;&quot;%20&quot;;                result +&#x3D; &quot;%20&quot;;            &#125;            else &#123; &#x2F;&#x2F; 否则直接+&#x3D;s[i];                result +&#x3D; s[i];            &#125;        &#125;        return result; &#x2F;&#x2F; 最后返回结果值result    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;请实现一个函数，把字符串 &lt;code&gt;s&lt;/code&gt; 中的每个空格替换成”%20”。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode541.反转字符串II</title>
    <link href="2023/03/19/leetcode541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II/"/>
    <id>2023/03/19/leetcode541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II/</id>
    <published>2023-03-19T06:36:21.000Z</published>
    <updated>2023-03-19T06:37:34.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2输出：&quot;bacdfeg&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;, k &#x3D; 2输出：&quot;bacd&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文组成</li><li><code>1 &lt;= k &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接进行交换即可</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int n &#x3D; s.size(); &#x2F;&#x2F; 字符串的长度        for (int i &#x3D; 0; i &lt; n; i +&#x3D; 2 * k) &#123; &#x2F;&#x2F; 每 2k 个字符为一组进行反转            int left &#x3D; i; &#x2F;&#x2F; 左边界            int right &#x3D; min(i + k - 1, n - 1); &#x2F;&#x2F; 右边界，注意防止越界            while (left &lt; right) &#123; &#x2F;&#x2F; 双指针反转                swap(s[left], s[right]); &#x2F;&#x2F; 交换左右指针对应的字符。                left++;                right--; &#x2F;&#x2F; 左右指针向中间移动。            &#125;        &#125;        return s; &#x2F;&#x2F; 返回反转后的字符串    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt;，从字符串开头算起，每计数至 &lt;code&gt;2k&lt;/code&gt; 个字符，就反转这 &lt;code&gt;2k&lt;/code&gt; 字符中的前 &lt;code&gt;k&lt;/code&gt; 个字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果剩余字符少于 &lt;code&gt;k&lt;/code&gt; 个，则将剩余字符全部反转。&lt;/li&gt;
&lt;li&gt;如果剩余字符小于 &lt;code&gt;2k&lt;/code&gt; 但大于或等于 &lt;code&gt;k&lt;/code&gt; 个，则反转前 &lt;code&gt;k&lt;/code&gt; 个字符，其余字符保持原样。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode124.二叉树中的最大路径和</title>
    <link href="2023/03/16/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>2023/03/16/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2023-03-16T07:56:05.000Z</published>
    <updated>2023-03-16T08:00:27.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/exx1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/exx2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>树形DP<ol><li>首先判断当前节点是否为 null，若为 null 则返回 0。</li><li>递归计算当前节点的左子树和右子树的最大路径和，分别为 <code>left</code> 和 <code>right</code>。</li><li>计算当前子树中包含当前节点的最大路径和 <code>curMax</code>，公式为 <code>node-&gt;val + max(0, max(left, right))</code>，其中 <code>node-&gt;val</code> 表示当前节点的值，<code>max(left, right)</code> 表示当前子树中不包含当前节点的最大路径和，<code>max(0, ...)</code> 的作用是保证当前子树中的路径和一定是非负数。</li><li>更新全局最大路径和 <code>res</code>，公式为 <code>max(res, left+right+node-&gt;val)</code>，其中 <code>left+right+node-&gt;val</code> 表示当前子树中包含当前节点的路径和。</li><li>返回当前子树的最大路径和 <code>curMax</code>。</li></ol></li></ol><p>在递归计算时，每个节点都会计算自己为根节点的最大路径和，并更新全局最大路径和。最终返回的是整棵树中的最大路径和。</p><p>这种递归思路在处理树形结构的问题时非常常见，被称为树形 DP（动态规划）。通过递归计算子树的最大路径和，并将结果传递给父节点，最终得到整棵树的最大路径和。C++代码实现如下:</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxPathSum(TreeNode* root) &#123;        int res &#x3D; INT_MIN;        dfs(root, res);        return res;    &#125;    int dfs(TreeNode* root, int&amp; res) &#123;        if (!root) return 0;        int left &#x3D; max(0, dfs(root-&gt;left, res)); &#x2F;&#x2F; 左子树的最大贡献值        int right &#x3D; max(0, dfs(root-&gt;right, res)); &#x2F;&#x2F; 右子树的最大贡献值        res &#x3D; max(res, root-&gt;val + left + right); &#x2F;&#x2F; 更新最大路径和        return root-&gt;val + max(left, right); &#x2F;&#x2F; 返回当前子树的最大路径和    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt; 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 &lt;strong&gt;至多出现一次&lt;/strong&gt; 。该路径 &lt;strong&gt;至少包含一个&lt;/strong&gt; 节点，且不一定经过根节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路径和&lt;/strong&gt; 是路径中各节点值的总和。&lt;/p&gt;
&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其 &lt;strong&gt;最大路径和&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode105.从前序与中序遍历序列构造二叉树</title>
    <link href="2023/03/16/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/16/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-16T06:24:30.000Z</published>
    <updated>2023-03-16T06:27:34.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p> <span id="more"></span><p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/tree-20230316142527347.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]输出: [3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]输出: [-1]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>同<a href="https://leafii.top/2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">106的解法</a>相似,因此在这里只提供代码.</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        &#x2F;&#x2F; 创建根节点        TreeNode* root &#x3D; build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);        return root;    &#125;        TreeNode* build(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd, vector&lt;int&gt;&amp; inorder, int inStart, int inEnd) &#123;        &#x2F;&#x2F; 特判：preStart &gt; preEnd 时，已经没有节点需要处理，返回 NULL        if (preStart &gt; preEnd) &#123;            return nullptr;        &#125;                &#x2F;&#x2F; 创建当前子树的根节点        TreeNode* root &#x3D; new TreeNode(preorder[preStart]);                &#x2F;&#x2F; 在中序遍历序列中查找当前子树根节点的位置        int inRootIndex &#x3D; inStart;        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;            inRootIndex++;        &#125;                &#x2F;&#x2F; 计算当前子树左子树的大小        int leftTreeSize &#x3D; inRootIndex - inStart;                &#x2F;&#x2F; 递归构建当前子树的左子树和右子树        root-&gt;left &#x3D; build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inRootIndex - 1);        root-&gt;right &#x3D; build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inRootIndex + 1, inEnd);                &#x2F;&#x2F; 返回当前子树的根节点        return root;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 &lt;code&gt;preorder&lt;/code&gt; 和 &lt;code&gt;inorder&lt;/code&gt; ，其中 &lt;code&gt;preorder&lt;/code&gt; 是二叉树的&lt;strong&gt;先序遍历&lt;/strong&gt;， &lt;code&gt;inorder&lt;/code&gt; 是同一棵树的&lt;strong&gt;中序遍历&lt;/strong&gt;，请构造二叉树并返回其根节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode106.从中序与后序遍历序列构造二叉树</title>
    <link href="2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-15T09:27:14.000Z</published>
    <updated>2023-03-16T06:23:59.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p> <span id="more"></span><p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/tree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]输出：[3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入：inorder &#x3D; [-1], postorder &#x3D; [-1]输出：[-1]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归构造</li></ul><p>根据题意，可以得知后序遍历的最后一个元素一定是树的根节点。然后可以在中序遍历中找到该根节点，以此将树分为左子树和右子树。对于左子树和右子树，可以再分别在中序遍历和后序遍历中找到其根节点，以此类推。</p><p>所以该问题可以使用递归的方式解决，每次递归时，先找到后序遍历的最后一个元素作为根节点，在中序遍历中找到该根节点，以此将树分为左子树和右子树。再分别递归左子树和右子树构建二叉树。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        &#x2F;&#x2F; 创建根节点        TreeNode* root &#x3D; build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);        return root;    &#125;    TreeNode* build(vector&lt;int&gt;&amp; inorder, int inStart, int inEnd, vector&lt;int&gt;&amp; postorder, int postStart, int postEnd) &#123;      &#x2F;*            inorder：中序遍历序列；            postorder：后序遍历序列；            inStart：当前子树在中序遍历序列中的起始位置；            inEnd：当前子树在中序遍历序列中的结束位置；            postStart：当前子树在后序遍历序列中的起始位置；            postEnd：当前子树在后序遍历序列中的结束位置。        *&#x2F;        &#x2F;&#x2F; 特判： 若postStart &gt; postEnd时， 无节点需要处理，返回NULL        if (postStart &gt; postEnd) &#123;            return nullptr;        &#125;        &#x2F;&#x2F; 创建新的子树根节点        TreeNode* root &#x3D; new TreeNode(postorder[postEnd]); &#x2F;&#x2F; 后续遍历的最后一个元素一定是根节点        &#x2F;&#x2F; 在中序遍历中寻找当前子树根节点的位置        int inRootIndex &#x3D; inStart;        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;            inRootIndex++;        &#125;        &#x2F;&#x2F; 计算当前子树左子树的大小        int leftTreeSize &#x3D; inRootIndex - inStart;                &#x2F;&#x2F; 根据根节点的位置， 分别递归构建左子树和右子树         root-&gt;left &#x3D; build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);        root-&gt;right &#x3D; build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1);         return root;    &#125;&#125;;</code></pre><p>关于<code>root-&gt;left = build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);</code>和<code>root-&gt;right = build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1); </code>的解释：</p><blockquote><p>在中序遍历中找到了根节点的位置后，在中序遍历中根节点的左边就是左子树的中序遍历，根节点的右边就是右子树的中序遍历，在递归调用时，左子树的中序遍历的右边界指针指向根节点索引-1，同理右子树的中序遍历的左边界指针指向根节点索引+1；计算了左子树的大小之后，可以发现在后序遍历中，从最开始到左子树的大小-1的元素即为左子树对应的后序遍历，因此从最开始索引+左子树大小到最右边索引-1的后序遍历即为右子树的后序遍历，这样一直递归即可得到完整的左右子树，将子树同根节点连接，返回根节点即可得到完整的树。</p></blockquote><p>在整个递归的过程中，我们都不需要额外的空间来存储子数组，而是通过起始和结束下标来表示子数组。这种方式使得我们可以使用较少的空间来解决问题，并且在递归过程中也不需要频繁地拷贝数组，提高了算法的效率。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 &lt;code&gt;inorder&lt;/code&gt; 和 &lt;code&gt;postorder&lt;/code&gt; ，其中 &lt;code&gt;inorder&lt;/code&gt; 是二叉树的中序遍历， &lt;code&gt;postorder&lt;/code&gt; 是同一棵树的后序遍历，请你构造并返回这颗 &lt;em&gt;二叉树&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode102.二叉树的层序遍历</title>
    <link href="2023/03/14/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>2023/03/14/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-03-14T01:57:14.000Z</published>
    <updated>2023-03-14T02:20:22.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p> <span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用队列辅助层序遍历</li></ol><p>注意看这个题的输入与输出，输出的动态数组的元素是元素为整型的数组，比如<code>[[3],[9,20],[15,7]]</code>.因此如果只定义一个队列辅助遍历，无法清晰的区分每层的元素应该插入到哪个数组中，比如如果只使用一个队列进行层次遍历，得到的结果只能是<code>[3,9,20,15,7]</code>，无法从这个结果中得知清晰的二叉树层次结构，所以在这里定义两个队列，首先向一个队列中塞入元素，接着对队首元素进行pop并且将队首元素的左右子树节点分别塞入另一队列中，再将结果数组并入result数组中，再将另一个队列进行同样的遍历操作，具体的C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        &#x2F;&#x2F; 定义两个队列 分别为q和another_q 用于层次遍历        queue&lt;TreeNode*&gt; q;        queue&lt;TreeNode*&gt; another_q;        &#x2F;&#x2F; 定义结果数组 其元素为元素为int类型的数组        vector&lt;vector&lt;int&gt;&gt; result;            &#x2F;&#x2F; 若根节点非空 则将根节点push进队列q中         if (root !&#x3D; nullptr) &#123;            q.push(root);        &#125;        &#x2F;&#x2F; 当q或者another_q队列非空时 进行遍历操作        while (!q.empty()|| !another_q.empty()) &#123;            &#x2F;&#x2F; 定义元素为int的临时数组 用于存储每一层的元素            vector&lt;int&gt; temp_vector;            &#x2F;&#x2F; 当队列q非空时 将队列q的元素逐个出队            while (!q.empty()) &#123;                TreeNode* temp_node &#x3D; q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;            &#x2F;&#x2F; 当另一个队列another_q非空时 将队列another_q的元素逐个出队            while (!another_q.empty()) &#123;                TreeNode* temp_node &#x3D; another_q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                another_q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;        &#125;        &#x2F;&#x2F; 返回结果数组        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;层序遍历&lt;/strong&gt; 。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode104.二叉树的最大深度</title>
    <link href="2023/03/13/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>2023/03/13/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2023-03-13T07:17:04.000Z</published>
    <updated>2023-03-14T02:20:19.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><pre class="language-none"><code class="language-none">  3 &#x2F; \9  20  &#x2F;  \ 15   7</code></pre><p>返回它的最大深度 3 。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>DFS（深度优先遍历）</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;      &#x2F;&#x2F; 如果当前节点为空，则返回0        if (root &#x3D;&#x3D; nullptr) return 0;      &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) return 1;        int left_depth &#x3D; -1, right_depth &#x3D; -1;      &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度        if (root-&gt;left !&#x3D; nullptr) &#123;            left_depth &#x3D; maxDepth(root-&gt;left);        &#125;      &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度        if (root-&gt;right !&#x3D; nullptr) &#123;            right_depth &#x3D; maxDepth(root-&gt;right);        &#125;      &#x2F;&#x2F; 返回左右子树深度的较大值加1        return max(left_depth, right_depth) + 1;    &#125;&#125;;</code></pre><ol start="2"><li>BFS（广度优先遍历）</li></ol><p>主要思路是使用一个队列来遍历整个二叉树。我们首先将根节点加入队列中，然后在每次循环中取出队列中的一层节点，将该层节点的左右子节点加入队列中。当遍历完所有节点时，队列中存储的即为最后一层节点，此时的深度即为树的深度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) &#123;            return 0;        &#125;        queue&lt;TreeNode*&gt; q;  &#x2F;&#x2F; 创建一个队列，用于BFS遍历        q.push(root);        &#x2F;&#x2F; 将根节点加入队列        int depth &#x3D; 0;       &#x2F;&#x2F; 初始化深度为0        while (!q.empty()) &#123; &#x2F;&#x2F; 当队列不为空时，继续遍历            int size &#x3D; q.size(); &#x2F;&#x2F; 记录队列中当前层的节点数量            for (int i &#x3D; 0; i &lt; size; i++) &#123; &#x2F;&#x2F; 遍历当前层的所有节点                TreeNode* node &#x3D; q.front();  &#x2F;&#x2F; 取出队列头部的节点                q.pop();                     &#x2F;&#x2F; 将该节点从队列中移除                if (node-&gt;left !&#x3D; NULL) &#123;    &#x2F;&#x2F; 如果该节点有左子节点，将其加入队列中                    q.push(node-&gt;left);                &#125;                if (node-&gt;right !&#x3D; NULL) &#123;   &#x2F;&#x2F; 如果该节点有右子节点，将其加入队列中                    q.push(node-&gt;right);                &#125;            &#125;            depth++;  &#x2F;&#x2F; 当前层遍历结束后，深度加1        &#125;        return depth; &#x2F;&#x2F; 返回树的深度    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;
&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode111.二叉树的最小深度</title>
    <link href="2023/03/12/leetcode111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>2023/03/12/leetcode111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</id>
    <published>2023-03-12T11:56:24.000Z</published>
    <updated>2023-03-13T07:50:42.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ex_depth.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]输出：5</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>DFS（深度优先遍历）</li></ol><p>使用了递归的方式。首先判断根节点是否为空，如果为空，则返回深度为0；如果根节点没有左右子节点，返回深度为1；如果有左右子节点，则分别递归计算左子树和右子树的深度，取两者的较小值再加1，即为该树的最小深度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        &#x2F;&#x2F; 如果当前节点为空，则返回0        if (root &#x3D;&#x3D; nullptr) &#123;            return 0;        &#125;        &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;            return 1;        &#125;        int left_depth &#x3D; INT_MAX, right_depth &#x3D; INT_MAX;        &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度        if (root-&gt;left !&#x3D; nullptr) &#123;            left_depth &#x3D; minDepth(root-&gt;left);        &#125;        &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度        if (root-&gt;right !&#x3D; nullptr) &#123;            right_depth &#x3D; minDepth(root-&gt;right);        &#125;        &#x2F;&#x2F; 返回左右子树深度的较小值加1        return min(left_depth, right_depth) + 1;    &#125;&#125;;</code></pre><ol start="2"><li>BFS（广度优先遍历）</li></ol><p>该代码使用了队列来实现广度优先搜索，从根节点开始，逐层访问该节点的左右子节点，并将子节点及其所在的层数入队，直到找到叶子节点，即没有左右子节点的节点，此时返回该节点所在的层数即可。如果整个二叉树中没有叶子节点，则返回0。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return 0;        &#125;        &#x2F;&#x2F; 创建队列， 存储节点以及其所在的层数        queue&lt;pair&lt;TreeNode*, int&gt;&gt; q;        &#x2F;&#x2F; 将根节点和所在的层数入队        q.push(make_pair(root, 1));        while (!q.empty()) &#123;            &#x2F;&#x2F; 取出队首节点和所在的层数            TreeNode* node &#x3D; q.front().first;            int depth &#x3D; q.front().second;            q.pop();            &#x2F;&#x2F; 如果该节点为叶子节点， 直接返回其所在的层数            if (node-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; node-&gt;right &#x3D;&#x3D; nullptr) &#123;                return depth;            &#125;            &#x2F;&#x2F; 如果该节点有左子节点，则将其左子节点和所在的层数入队            if (node-&gt;left !&#x3D; nullptr) &#123;                q.push(make_pair(node-&gt;left, depth+1));                &#125;            &#x2F;&#x2F; 如果该节点有右子节点，则将其右子节点和所在的层数入队            if (node-&gt;right !&#x3D; nullptr) &#123;                q.push(make_pair(node-&gt;right, depth+1));                &#125;        &#125;        return 0;    &#125;&#125;;</code></pre><blockquote><p>一般来说，DFS和BFS的效率取决于二叉树的结构和分布。如果二叉树比较平衡，那么BFS可能更快，因为它可以更早地找到最小深度的叶子节点。如果二叉树比较不平衡，那么DFS可能更快，因为它可以避免访问很多不必要的节点。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;/p&gt;
&lt;p&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;叶子节点是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode25.K个一组翻转链表</title>
    <link href="2023/03/09/leetcode25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>2023/03/09/leetcode25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-09T09:07:29.000Z</published>
    <updated>2023-03-09T09:22:48.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/reverse_ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2输出：[2,1,4,3,5]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/reverse_ex2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3输出：[3,2,1,4,5]</code></pre><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>编写一个函数，用于实现反转链表的核心逻辑，思路如下：</p><ul><li><p>初始化一个前驱节点prev和一个当前节点curr，分别指向空和头节点。</p></li><li><p>循环k次，每次做以下操作：</p><ul><li><p>保存当前节点的下一个节点next，以免丢失。</p></li><li><p>将当前节点的next指针指向前驱节点prev，实现反转。</p></li><li><p>将前驱节点prev更新为当前节点curr，为下一次反转做准备。</p></li><li><p>将当前节点curr更新为下一个节点next，继续遍历链表。</p></li></ul></li></ul><p>这样就可以将链表中的k个节点反转，并返回反转后的头尾指针。</p><blockquote><p>对以上函数进行一个图示说明：</p><p>假设链表为1-&gt;2-&gt;3-&gt;4-&gt;5，k为3，那么反转后的链表应该为3-&gt;2-&gt;1-&gt;4-&gt;5。</p><p>初始状态：</p><pre class="language-text" data-language="text"><code class="language-text">prev: nullcurr: 1next: 2null &lt;- prev   curr -> next -> 3 -> 4 -> 5</code></pre><p>第一次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 1curr: 2next: 3null &lt;- prev &lt;- curr   next -> 4 -> 5</code></pre><p>第二次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 2curr: 3next: 4null &lt;- prev &lt;- curr   next -> 5</code></pre><p>第三次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 3curr: 4next: 5null &lt;- prev &lt;- curr   next </code></pre><p>结束循环，返回{prev, head}即{3,1}。</p><pre class="language-text" data-language="text"><code class="language-text"> prev        head   |           |  v           v null&lt;-3&lt;-2&lt;-1    4->5 </code></pre></blockquote><p>代码的整体思路是：</p><ul><li>定义一个虚拟头节点dummy，指向原链表的头节点head，这样可以方便处理边界情况。</li><li>定义一个前驱节点prev，初始指向dummy，用来连接反转后的链表段。</li><li>用一个while循环遍历整个链表，每次循环做以下操作：<ul><li>定义一个尾部指针tail，初始指向头部指针head，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回dummy-&gt;next即可。</li><li>保存下一段链表的头部指针nextHead，并断开与当前段的连接。</li><li>调用反转函数reverseList，输入当前段的头部指针head和长度k，返回反转后的新头部和新尾部，并将其连接到前驱和下一段上。</li><li>更新前驱为新尾部，更新头部为下一段头部。</li></ul></li></ul><p>这样就可以将整个链表按照每k个节点进行反转，并返回dummy-&gt;next作为新链表的头节点。</p><p>代码的时间复杂度是O(n)，因为我们只需要遍历一次链表，每个节点最多被访问两次。 代码的空间复杂度是O(1)，因为我们只使用了常数个额外变量，没有使用递归或栈。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 定义反转链表的函数，输入一个链表头节点和一个长度k，返回反转后的头节点和尾节点    pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, int k) &#123;        &#x2F;&#x2F; 初始化前驱节点和当前节点        ListNode* prev &#x3D; nullptr;        ListNode* curr &#x3D; head;        &#x2F;&#x2F; 遍历k次，每次将当前节点指向前驱节点，并更新前驱和当前节点        for (int i &#x3D; 0; i &lt; k; i++) &#123;            ListNode* next &#x3D; curr-&gt;next; &#x2F;&#x2F; 保存下一个节点            curr-&gt;next &#x3D; prev; &#x2F;&#x2F; 反转指针            prev &#x3D; curr; &#x2F;&#x2F; 更新前驱            curr &#x3D; next; &#x2F;&#x2F; 更新当前        &#125;        &#x2F;&#x2F; 返回反转后的头节点和尾节点，即原来的尾节点和头节点        return &#123;prev, head&#125;;    &#125;    &#x2F;&#x2F; 定义leetcode 25的主函数，输入一个链表头节点和一个整数k，返回反转后的链表头节点    ListNode* reverseKGroup(ListNode* head, int k) &#123;        &#x2F;&#x2F; 初始化虚拟头节点和前驱节点        ListNode* dummy &#x3D; new ListNode(-1);        dummy-&gt;next &#x3D; head;        ListNode* prev &#x3D; dummy;                while (head !&#x3D; nullptr) &#123; &#x2F;&#x2F; 遍历链表直到为空            &#x2F;&#x2F; 初始化尾部指针为头部指针，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回虚拟头节点的下一个即可            ListNode* tail &#x3D; head;            for (int i &#x3D; 0; i &lt; k - 1; i++) &#123;                tail &#x3D; tail-&gt;next;                if (tail &#x3D;&#x3D; nullptr) return dummy-&gt;next;            &#125;                        &#x2F;&#x2F; 保存下一段链表的头部指针，并断开与当前段的连接            ListNode* nextHead &#x3D; tail-&gt;next;            tail-&gt;next &#x3D; nullptr;            &#x2F;&#x2F; 调用反转函数，得到反转后的新头部和新尾部，并将其连接到前驱和下一段上            auto reversedPair &#x3D; reverseList(head, k);            prev-&gt;next &#x3D; reversedPair.first;            reversedPair.second-&gt;next &#x3D; nextHead;            &#x2F;&#x2F; 更新前驱为新尾部，更新头部为下一段头部            prev &#x3D; reversedPair.second;            head &#x3D; nextHead;                    &#125;            return dummy-&gt;next;     &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你链表的头节点 &lt;code&gt;head&lt;/code&gt; ，每 &lt;code&gt;k&lt;/code&gt; 个节点一组进行翻转，请你返回修改后的链表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 &lt;code&gt;k&lt;/code&gt; 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
