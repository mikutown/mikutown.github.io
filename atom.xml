<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2024-01-09T10:05:08.392Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode2.两数相加</title>
    <link href="2024/01/09/leetcode2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>2024/01/09/leetcode2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2024-01-09T10:03:25.000Z</published>
    <updated>2024-01-09T10:05:08.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 5输出: 2</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 2输出: 1</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 7输出: 4</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>折半查找</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int n &#x3D; nums.size(); &#x2F;&#x2F; 获取数组的大小        int left &#x3D; 0; &#x2F;&#x2F; 初始化左指针        int right &#x3D; n - 1; &#x2F;&#x2F; 初始化右指针                while (left &lt;&#x3D; right) &#123; &#x2F;&#x2F; 当左指针不大于右指针时循环            int mid &#x3D; left + (right - left) &#x2F; 2; &#x2F;&#x2F; 计算中间位置，防止溢出            if (nums[mid] &#x3D;&#x3D; target) &#123; &#x2F;&#x2F; 如果中间的元素等于目标值                return mid; &#x2F;&#x2F; 返回中间位置            &#125; else if (nums[mid] &lt; target) &#123; &#x2F;&#x2F; 如果中间元素小于目标值                left &#x3D; mid + 1; &#x2F;&#x2F; 将左指针移动到中间位置的右侧，加1以避免循环            &#125; else &#123; &#x2F;&#x2F; 如果中间元素大于目标值                right &#x3D; mid - 1; &#x2F;&#x2F; 将右指针移动到中间位置的左侧，减1以避免循环            &#125;        &#125;        return left; &#x2F;&#x2F; 如果没有找到目标值，返回应该插入的位置    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;请必须使用时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 的算法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode35.搜索插入位置</title>
    <link href="2024/01/09/leetcode35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>2024/01/09/leetcode35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</id>
    <published>2024-01-09T10:03:03.000Z</published>
    <updated>2024-01-09T10:06:22.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]输出：[7,0,8]解释：342 + 465 &#x3D; 807.</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [0], l2 &#x3D; [0]输出：[0]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>直接模拟</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode *newHead &#x3D; new ListNode(0);        ListNode *p &#x3D; l1;        ListNode *q &#x3D; l2;        ListNode *curr &#x3D; newHead;        int carry &#x3D; 0; &#x2F;&#x2F;进位        while(p !&#x3D; NULL || q !&#x3D; NULL) &#123;            int sum &#x3D; 0, x &#x3D; 0, y &#x3D; 0;            if(p) &#123;                x &#x3D; p -&gt; val;                p &#x3D; p -&gt; next;            &#125;            if(q) &#123;                y &#x3D; q -&gt; val;                q &#x3D; q -&gt; next;            &#125;            sum &#x3D; x + y + carry;            carry &#x3D; sum &#x2F; 10;            curr -&gt; next &#x3D; new ListNode(sum % 10);            curr &#x3D; curr -&gt; next;        &#125;        if(carry) &#123;            curr -&gt; next &#x3D; new ListNode(carry);        &#125;        return newHead -&gt; next;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;逆序&lt;/strong&gt; </summary>
      
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode400.第N位数字</title>
    <link href="2023/12/22/leetcode400-%E7%AC%ACN%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <id>2023/12/22/leetcode400-%E7%AC%ACN%E4%BD%8D%E6%95%B0%E5%AD%97/</id>
    <published>2023-12-22T09:49:08.000Z</published>
    <updated>2023-12-22T10:14:24.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，请你在无限的整数序列 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code> 中找出并返回第 <code>n</code> 位上的数字。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：3</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 11输出：0解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>暴力解决</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findNthDigit(int n) &#123;        int d &#x3D; 1, count &#x3D; 9;        while (n &gt; (long) d * count) &#123;            n -&#x3D; d * count;            d++;            count *&#x3D; 10;        &#125;        int index &#x3D; n - 1;        int start &#x3D; (int) pow(10, d - 1);        int num &#x3D; start + index &#x2F; d;        int digitIndex &#x3D; index % d;        int digit &#x3D; (num &#x2F; (int) (pow(10, d - digitIndex - 1))) % 10;        return digit;    &#125;&#125;;</code></pre><ol start="2"><li>直接计算</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findNthDigit(int n) &#123;        long base &#x3D; 9, digits &#x3D; 1;        &#x2F;&#x2F; 第一步：确定 n 所在的数字有几位        while (n - base * digits &gt; 0) &#123;            n -&#x3D; base * digits;            base *&#x3D; 10;            digits++;        &#125;        &#x2F;&#x2F; 第二步：确定 n 所在的具体数字        int index &#x3D; n % digits;        if (index &#x3D;&#x3D; 0) index &#x3D; digits;        long number &#x3D; 1;        for (int i &#x3D; 1; i &lt; digits; i++) &#123;            number *&#x3D; 10;        &#125;        number +&#x3D; (index &#x3D;&#x3D; digits) ? n&#x2F;digits - 1 : n&#x2F;digits;        &#x2F;&#x2F; 第三步：找到并返回目标数字中的具体一位        for (int i &#x3D; index; i &lt; digits; i++) number &#x2F;&#x3D; 10;        return number % 10;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你在无限的整数序列 &lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]&lt;/code&gt; 中找出并返回第 &lt;code&gt;n&lt;/code&gt; 位上的数字。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode398.随机数索引</title>
    <link href="2023/12/20/leetcode398-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/"/>
    <id>2023/12/20/leetcode398-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/</id>
    <published>2023-12-20T02:05:57.000Z</published>
    <updated>2023-12-20T02:15:53.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个可能含有 <strong>重复元素</strong> 的整数数组 <code>nums</code> ，请你随机输出给定的目标数字 <code>target</code> 的索引。你可以假设给定的数字一定存在于数组中。</p><p>实现 <code>Solution</code> 类：</p><ul><li><code>Solution(int[] nums)</code> 用数组 <code>nums</code> 初始化对象。</li><li><code>int pick(int target)</code> 从 <code>nums</code> 中选出一个满足 <code>nums[i] == target</code> 的随机索引 <code>i</code> 。如果存在多个有效的索引，则每个索引的返回概率应当相等。</li></ul> <span id="more"></span><p><strong>示例：</strong></p><pre class="language-none"><code class="language-none">输入[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;][[[1, 2, 3, 3, 3]], [3], [1], [3]]输出[null, 4, 0, 2]解释Solution solution &#x3D; new Solution([1, 2, 3, 3, 3]);solution.pick(3); &#x2F;&#x2F; 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。solution.pick(1); &#x2F;&#x2F; 返回 0 。因为只有 nums[0] 等于 1 。solution.pick(3); &#x2F;&#x2F; 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>target</code> 是 <code>nums</code> 中的一个整数</li><li>最多调用 <code>pick</code> 函数 <code>104</code> 次</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>直接实现</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    vector&lt;int&gt; sortNum;public:    Solution(vector&lt;int&gt;&amp; nums) &#123;        sortNum &#x3D; nums;    &#125;    int simpleRandom(int min, int max) &#123;        static bool first &#x3D; true;        if (first) &#123;            srand(time(nullptr)); &#x2F;&#x2F; 使用当前时间作为种子            first &#x3D; false;        &#125;        return min + rand() % (max - min + 1);    &#125;        int pick(int target) &#123;        vector&lt;int&gt; result;        for (int i &#x3D; 0; i &lt; sortNum.size(); i++) &#123;            if (sortNum[i] &#x3D;&#x3D; target) result.push_back(i);        &#125;        int randomIndex &#x3D; simpleRandom(0, result.size()-1);        return result[randomIndex];    &#125;&#125;;&#x2F;** * Your Solution object will be instantiated and called as such: * Solution* obj &#x3D; new Solution(nums); * int param_1 &#x3D; obj-&gt;pick(target); *&#x2F;</code></pre><ol start="2"><li>使用哈希表实现</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;    &#x2F;&#x2F; 使用哈希表存储每个数字及其在数组中的所有索引    unordered_map&lt;int, vector&lt;int&gt;&gt; pos;public:    &#x2F;&#x2F; 构造函数，接受一个整数数组作为参数    Solution(vector&lt;int&gt; &amp;nums) &#123;        &#x2F;&#x2F; 遍历数组        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;            &#x2F;&#x2F; 将每个数字及其索引存入哈希表中            &#x2F;&#x2F; 如果数字已存在，它的索引将被添加到对应的向量中            pos[nums[i]].push_back(i);        &#125;    &#125;    &#x2F;&#x2F; pick 函数，接受一个目标数字作为参数    int pick(int target) &#123;        &#x2F;&#x2F; 获取目标数字所有索引的向量的引用        auto &amp;indices &#x3D; pos[target];        &#x2F;&#x2F; 随机选择并返回一个索引        &#x2F;&#x2F; rand() % indices.size() 生成一个在 0 到 indices.size() - 1 范围内的随机数        return indices[rand() % indices.size()];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个可能含有 &lt;strong&gt;重复元素&lt;/strong&gt; 的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你随机输出给定的目标数字 &lt;code&gt;target&lt;/code&gt; 的索引。你可以假设给定的数字一定存在于数组中。&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;Solution&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Solution(int[] nums)&lt;/code&gt; 用数组 &lt;code&gt;nums&lt;/code&gt; 初始化对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int pick(int target)&lt;/code&gt; 从 &lt;code&gt;nums&lt;/code&gt; 中选出一个满足 &lt;code&gt;nums[i] == target&lt;/code&gt; 的随机索引 &lt;code&gt;i&lt;/code&gt; 。如果存在多个有效的索引，则每个索引的返回概率应当相等。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1025.除数博弈</title>
    <link href="2023/12/19/leetcode1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"/>
    <id>2023/12/19/leetcode1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</id>
    <published>2023-12-19T11:04:21.000Z</published>
    <updated>2023-12-19T11:06:40.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p><p>最初，黑板上有一个数字 <code>n</code> 。在每个玩家的回合，玩家需要执行以下操作：</p><ul><li>选出任一 <code>x</code>，满足 <code>0 &lt; x &lt; n</code> 且 <code>n % x == 0</code> 。</li><li>用 <code>n - x</code> 替换黑板上的数字 <code>n</code> 。</li></ul><p>如果玩家无法执行这些操作，就会输掉游戏。</p><p><em>只有在爱丽丝在游戏中取得胜利时才返回 <code>true</code> 。假设两个玩家都以最佳状态参与游戏。</em></p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>感觉像是一个脑经急转弯？每次都选1就是最佳选择</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool divisorGame(int n) &#123;        if (n &#x3D;&#x3D; 1) return false;        else return (!divisorGame(n-1));    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。&lt;/p&gt;
&lt;p&gt;最初，黑板上有一个数字 &lt;code&gt;n&lt;/code&gt; 。在每个玩家的回合，玩家需要执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选出任一 &lt;code&gt;x&lt;/code&gt;，满足 &lt;code&gt;0 &amp;lt; x &amp;lt; n&lt;/code&gt; 且 &lt;code&gt;n % x == 0&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;n - x&lt;/code&gt; 替换黑板上的数字 &lt;code&gt;n&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果玩家无法执行这些操作，就会输掉游戏。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;只有在爱丽丝在游戏中取得胜利时才返回 &lt;code&gt;true&lt;/code&gt; 。假设两个玩家都以最佳状态参与游戏。&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1154.一年中的第几天</title>
    <link href="2023/12/18/leetcode1154-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9/"/>
    <id>2023/12/18/leetcode1154-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9/</id>
    <published>2023-12-18T13:54:42.000Z</published>
    <updated>2023-12-18T13:55:35.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>date</code> ，按 <code>YYYY-MM-DD</code> 格式表示一个 <a href="https://baike.baidu.com/item/%E5%85%AC%E5%85%83/17855">现行公元纪年法</a> 日期。返回该日期是当年的第几天。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：date &#x3D; &quot;2019-01-09&quot;输出：9解释：给定日期是2019年的第九天。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：date &#x3D; &quot;2019-02-10&quot;输出：41</code></pre><p><strong>提示：</strong></p><ul><li><code>date.length == 10</code></li><li><code>date[4] == date[7] == &#39;-&#39;</code>，其他的 <code>date[i]</code> 都是数字</li><li><code>date</code> 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    bool judgeIsRun(int year) &#123;        return ((year % 4 &#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D; 0) || (year%400&#x3D;&#x3D;0 &amp;&amp; year % 3200 !&#x3D; 0) || year % 172800 &#x3D;&#x3D; 0);    &#125;public:    int dayOfYear(string date) &#123;        int year &#x3D; stoi(date.substr(0, 4));        int month &#x3D; stoi(date.substr(5, 2));        int day &#x3D; stoi(date.substr(8,2));        &#x2F;&#x2F; 以平年为默认初始化12个月的天数        vector&lt;int&gt; dayOfMonth&#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;        &#x2F;&#x2F; 判断是否为闰年，这决定了2月的天数        if (judgeIsRun(year)) dayOfMonth[1] &#x3D; 29;        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt;&#x3D; month - 1; i++) &#123;            if (i &lt; month - 1) result +&#x3D; dayOfMonth[i];            else result +&#x3D; day;        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;date&lt;/code&gt; ，按 &lt;code&gt;YYYY-MM-DD&lt;/code&gt; 格式表示一个 &lt;a href=&quot;https://baike.baidu.com/item/%E5%85%AC%E5%85%83/17855&quot;&gt;现行公元纪年法&lt;/a&gt; 日期。返回该日期是当年的第几天。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode347.前K个高频元素</title>
    <link href="2023/12/14/leetcode347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>2023/12/14/leetcode347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</id>
    <published>2023-12-14T12:01:34.000Z</published>
    <updated>2023-12-14T12:52:17.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><span id="more"></span> <p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2输出: [1,2]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1], k &#x3D; 1输出: [1]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用hashmap辅助</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        map&lt;int, int&gt; m; &#x2F;&#x2F; 创建一个用于存储数字频率的映射（键为数字，值为出现的次数）        for (int num : nums) &#123;            m[num] &#x3D; m[num] &#x3D;&#x3D; 0 ? 1 : m[num] + 1; &#x2F;&#x2F; 统计每个数字的出现次数        &#125;        vector&lt;std::pair&lt;int, int&gt;&gt; vec(m.begin(), m.end()); &#x2F;&#x2F; 将映射转换为包含键值对的向量        sort(vec.begin(), vec.end(), [](const std::pair&lt;int, int&gt;&amp; a, const std::pair&lt;int, int&gt;&amp; b) &#123;            return a.second &gt; b.second; &#x2F;&#x2F; 按值（出现次数）降序排序        &#125;);        vector&lt;int&gt; results;        for (int i &#x3D; 0; i &lt; k; i++) &#123;            results.push_back(vec[i].first); &#x2F;&#x2F; 获取前k个频率最高的数字        &#125;        return results;    &#125;&#125;;</code></pre><ol start="2"><li>代码优化</li></ol><blockquote><ol><li>**使用 <code>unordered_map</code> 而不是 <code>map</code>**：<code>unordered_map</code> 通常比 <code>map</code> 更快，因为 <code>unordered_map</code> 使用哈希表实现，而 <code>map</code> 使用平衡树。这在频繁插入和查找时尤其有用。</li><li><strong>简化元素计数</strong>：你可以直接使用 <code>++m[num]</code> 来增加计数，无需检查元素是否存在。</li><li><strong>使用优先队列（最小堆）</strong>：使用优先队列而不是对整个向量排序可以减少时间复杂度。只保留前 k 个最频繁的元素，这样不需要对所有元素进行排序。</li></ol></blockquote><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        &#x2F;&#x2F; 使用 unordered_map 来计数        unordered_map&lt;int, int&gt; count_map;        for (int num : nums) &#123;            ++count_map[num];        &#125;        &#x2F;&#x2F; 定义一个最小堆        auto comp &#x3D; [&amp;count_map](int n1, int n2) &#123;            return count_map[n1] &gt; count_map[n2];        &#125;;        priority_queue&lt;int, vector&lt;int&gt;, decltype(comp)&gt; heap(comp);        &#x2F;&#x2F; 保持堆的大小为 k        for (auto &amp;p : count_map) &#123;            heap.push(p.first);            if (heap.size() &gt; k) &#123;                heap.pop();            &#125;        &#125;        &#x2F;&#x2F; 从堆中提取元素        vector&lt;int&gt; results;        while (!heap.empty()) &#123;            results.push_back(heap.top());            heap.pop();        &#125;        reverse(results.begin(), results.end()); &#x2F;&#x2F; 将结果反转为正确的顺序        return results;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你返回其中出现频率前 &lt;code&gt;k&lt;/code&gt; 高的元素。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode150.逆波兰表达式求值</title>
    <link href="2023/12/14/leetcode150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <id>2023/12/14/leetcode150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</id>
    <published>2023-12-14T12:01:17.000Z</published>
    <updated>2023-12-14T12:25:27.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><span id="more"></span><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]输出：22解释：该算式转化为常见的中缀算术表达式为：  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5&#x3D; ((10 * 0) + 17) + 5&#x3D; (0 + 17) + 5&#x3D; 17 + 5&#x3D; 22</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用栈辅助遍历</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    &#x2F;&#x2F; 计算逆波兰表达式的值    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        &#x2F;&#x2F; 使用栈来辅助计算        stack&lt;int&gt; numStack;                &#x2F;&#x2F; 遍历表达式中的每个元素        for (string temp : tokens) &#123;            &#x2F;&#x2F; 如果是操作数，将其转换为整数并压入栈中            if (temp !&#x3D; &quot;+&quot; &amp;&amp; temp !&#x3D; &quot;-&quot; &amp;&amp; temp !&#x3D; &quot;*&quot; &amp;&amp; temp !&#x3D; &quot;&#x2F;&quot;) &#123;                numStack.push(stoi(temp));            &#125; else &#123;                &#x2F;&#x2F; 如果是操作符，从栈中弹出两个操作数进行计算                int num2 &#x3D; numStack.top();                numStack.pop();                int num1 &#x3D; numStack.top();                numStack.pop();                int num &#x3D; 0;                                &#x2F;&#x2F; 根据操作符进行相应的计算，并将结果压入栈中                if (temp &#x3D;&#x3D; &quot;+&quot;) &#123;                    num &#x3D; num1 + num2;                &#125; else if (temp &#x3D;&#x3D; &quot;-&quot;) &#123;                    num &#x3D; num1 - num2;                &#125; else if (temp &#x3D;&#x3D; &quot;*&quot;) &#123;                    num &#x3D; num1 * num2;                &#125; else if (temp &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;                    num &#x3D; num1 &#x2F; num2;                &#125;                numStack.push(num);            &#125;        &#125;                &#x2F;&#x2F; 最终栈中的唯一元素即为表达式的值        return numStack.top();    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;tokens&lt;/code&gt; ，表示一个根据 &lt;a href=&quot;https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437&quot;&gt;逆波兰表示法&lt;/a&gt; 表示的算术表达式。&lt;/p&gt;
&lt;p&gt;请你计算该表达式。返回一个表示表达式值的整数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode20.有效的括号</title>
    <link href="2023/12/13/leetcode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>2023/12/13/leetcode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2023-12-13T13:13:46.000Z</published>
    <updated>2023-12-13T13:15:22.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;()&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;输出：true</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;(]&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isValid(string s) &#123;        if (s.size() % 2 !&#x3D; 0) return false;        stack&lt;char&gt; charStack;        for (char c : s) &#123;            bool willPush &#x3D; true;            if (!charStack.empty()) &#123;                char temp &#x3D; charStack.top();                switch (temp) &#123;                    case &#39;(&#39;:                        if (c &#x3D;&#x3D; &#39;)&#39;) &#123;                            charStack.pop();                            willPush &#x3D; false;                        &#125;                        break;                    case &#39;&#123;&#39;:                        if (c &#x3D;&#x3D; &#39;&#125;&#39;) &#123;                            charStack.pop();                            willPush &#x3D; false;                        &#125;                        break;                    case &#39;[&#39;:                        if (c &#x3D;&#x3D; &#39;]&#39;) &#123;                            charStack.pop();                            willPush &#x3D; false;                        &#125;                        break;                &#125;            &#125;            if (willPush) &#123;                charStack.push(c);            &#125;        &#125;        return charStack.empty(); &#x2F;&#x2F; 可以直接返回栈是否为空，无需使用 if 判断    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;&amp;#123;&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;&amp;#125;&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;]&amp;#39;&lt;/code&gt; 的字符串 &lt;code&gt;s&lt;/code&gt; ，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;li&gt;每个右括号都有一个对应的相同类型的左括号。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1047.删除字符串中的所有相邻重复项</title>
    <link href="2023/12/11/leetcode1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>2023/12/11/leetcode1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2023-12-11T13:16:29.000Z</published>
    <updated>2023-12-11T13:28:00.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p> <span id="more"></span><p><strong>示例：</strong></p><pre class="language-none"><code class="language-none">输入：&quot;abbaca&quot;输出：&quot;ca&quot;解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 20000</code></li><li><code>S</code> 仅由小写英文字母组成。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用栈</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string removeDuplicates(string S) &#123;        stack&lt;char&gt; charStack;  &#x2F;&#x2F; 使用栈来存储字符        for (char c : S) &#123;            &#x2F;&#x2F; 如果栈不为空且栈顶字符与当前字符相同，则移除栈顶字符            if (!charStack.empty() &amp;&amp; charStack.top() &#x3D;&#x3D; c) &#123;                charStack.pop();            &#125; else &#123;                &#x2F;&#x2F; 否则，将当前字符压入栈                charStack.push(c);            &#125;        &#125;        &#x2F;&#x2F; 将栈中字符组合成最终的结果字符串        string result &#x3D; &quot;&quot;;        while (!charStack.empty()) &#123;            result &#x3D; charStack.top() + result;            charStack.pop();        &#125;        return result;    &#125;&#125;;</code></pre><ol start="2"><li>快慢指针</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string removeDuplicates(string S) &#123;        int slow &#x3D; 0; &#x2F;&#x2F; 慢指针，指向当前处理的位置        for (int fast &#x3D; 0; fast &lt; S.size(); ++fast) &#123;            &#x2F;&#x2F; 如果慢指针不为零，且当前字符与慢指针前一个字符相同，表示发现相邻重复            if (slow !&#x3D; 0 &amp;&amp; S[fast] &#x3D;&#x3D; S[slow - 1]) &#123;                slow--;            &#125; else &#123;                &#x2F;&#x2F; 否则，将当前字符加入到慢指针指向的位置                S[slow++] &#x3D; S[fast];            &#125;        &#125;        &#x2F;&#x2F; 截断字符串，保留有效部分        return S.substr(0, slow);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给出由小写字母组成的字符串 &lt;code&gt;S&lt;/code&gt;，&lt;strong&gt;重复项删除操作&lt;/strong&gt;会选择两个相邻且相同的字母，并删除它们。&lt;/p&gt;
&lt;p&gt;在 S 上反复执行重复项删除操作，直到无法继续删除。&lt;/p&gt;
&lt;p&gt;在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>在机器人网络云系统中使用复制的静态算法调度</title>
    <link href="2023/11/14/%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%BD%91%E7%BB%9C%E4%BA%91%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E7%9A%84%E9%9D%99%E6%80%81%E7%AE%97%E6%B3%95%E8%B0%83%E5%BA%A6/"/>
    <id>2023/11/14/%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%BD%91%E7%BB%9C%E4%BA%91%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E7%9A%84%E9%9D%99%E6%80%81%E7%AE%97%E6%B3%95%E8%B0%83%E5%BA%A6/</id>
    <published>2023-11-14T09:57:51.000Z</published>
    <updated>2023-11-20T08:04:58.268Z</updated>
    
    <content type="html"><![CDATA[<p>题目：Static Algorithm Allocation With Duplication in Robotic Network Cloud Systems</p><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>机器人网络可用于完成超出单个机器人能力的任务。在机器人网络中，机器人可以协同工作来完成共同的任务。云机器人技术使机器人能够受益于云的海量存储和计算能力。以往的研究主要集中在通过提前了解资源分配来最小化机器人检索资源的成本。在多个节点上复制算法可以减少执行任务所需的总时间。<strong>我们解决了应该复制哪些算法以及应该将副本放置在哪里以提高整体性能的问题。</strong>我们开发了一个程序来回答机器人网络云系统应该执行哪些算法以及是否应该重复这些算法以在所有机器人的总体任务执行时间方面实现最佳性能。我们提出的复制程序是最佳的，因为复制算法的数量最少，而结果为所有机器人提供了最短的总体完成时间。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>为了克服单一机器人能力的限制，通常使用多个机器人共同工作去完成任务。但如果只靠增加机器人数量的方式去增加机器人网络的能力会导致模型的复杂度提升以及系统的花费增加。云机器人是一种克服计算力以及机器人的性能限制的方式。</p><p>为了达到基于云的机器人系统的最优表现，我们需要去解决调度问题。这个问题涉及决定是否应将新到达的任务上传到云、在其中一个机器人上执行（边缘计算[14]）或在服务器上处理（雾计算[15]）。云机器人系统执行任务是通过执行、收集和组合几个称为算法的基本任务的结果来实现的。在机器人执行一项任务之前，该任务所需的所有算法都应该可用，并分配给系统的至少一个处理单元。当机器人被分配任务时，机器人请求与该任务相对应的算法的输出。我们的<strong>目标</strong>是确定应该将算法分配到哪里，以便无论哪个机器人正在执行任务，它都能在尽可能短的时间内检索算法所需的所有输出。</p><p>分配给多个处理器的算法称为重复算法。由于算法是相互依赖的，因此复制算法的输出更容易被分配到其后继算法的其他处理器使用。下面用一个例子来更好的说明算法重复的重要性。</p><p>云机器人的架构如图2所示。假设我们有一个只需要单个算法输出的任务。给定算法的输出，任务可以由任何边缘节点执行。假设该算法可以在每个边缘节点、雾节点和云节点上执行，平均执行时间分别为3秒、0.5秒和0.1秒。如果不考虑算法的重复，由于我们不知道哪个边缘节点发起执行任务的请求，因此可以通过静态算法分配来实现系统的最优性能[30]。结果是将算法分配给雾节点，其中边缘节点E1、E2和E3完成任务的平均时间分别为4.5、2.5和2.5秒。如果允许我们复制算法，则在边缘节点 E1 上复制算法会将边缘节点 E1 的平均任务完成时间减少到 3 秒。因此，以最小总时间完成任务的最优方案是将算法分配给雾节点F并在边缘节点E1上复制一次。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目：Static Algorithm Allocation With Duplication in Robotic Network Cloud Systems&lt;/p&gt;</summary>
    
    
    
    
    <category term="资源调度" scheme="tags/资源调度/"/>
    
    <category term="云机器人" scheme="tags/云机器人/"/>
    
  </entry>
  
  <entry>
    <title>多智能体云机器人的资源调度和服务提供的综述</title>
    <link href="2023/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%BC%E8%BF%B0/"/>
    <id>2023/11/12/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%BC%E8%BF%B0/</id>
    <published>2023-11-12T12:46:10.000Z</published>
    <updated>2023-11-14T09:54:00.504Z</updated>
    
    <content type="html"><![CDATA[<p>原题目：Resource Allocation and Service Provisioning in Multi-Agent Cloud Robotics: A Comprehensive Survey</p><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Abstract—Robotic applications nowadays are widely adopted to enhance operational automation and performance of real-world CyberPhysical Systems (CPSs) including Industry 4.0, agriculture, healthcare, and disaster management. These applications are composed of latency-sensitive, data-heavy, and compute-intensive tasks. The robots, however, are constrained in the computational power and storage capacity. The concept of multi-agent cloud robotics enables robotto-robot cooperation and creates a complementary environment for the robots in executing large-scale applications with the capability to utilize the edge and cloud resources. However, in such a collaborative environment, the optimal resource allocation for robotic tasks is challenging to achieve. Heterogeneous energy consumption rates and application of execution costs associated with the robots and computing instances make it even more complex. In addition, the data transmission delay between local robots, edge nodes, and cloud data centres adversely affects the real-time interactions and impedes service performance guarantee. Taking all these issues into account, this paper comprehensively surveys the state-of-the-art on resource allocation and service provisioning in multi-agent cloud robotics. The paper presents the application domains of multi-agent cloud robotics through explicit comparison with the contemporary computing paradigms and identifies the specific research challenges. A complete taxonomy on resource allocation is presented for the first time, together with the discussion of resource pooling, computation offloading, and task scheduling for efficient service provisioning. Furthermore, we highlight the research gaps from the learned lessons, and present future directions deemed beneficial to further advance this emerging field.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在多信息物理系统的条件下，多智能体云机器人可以带来以下优点：</p><ul><li>通过利用不同基础设施级别的计算资源，它为 CPS 提供执行各种机器人应用程序的选项。</li><li>它提供了一种抽象，可以根据计算基础设施的特征对机器人应用程序的任务进行分类。</li><li>它提供分布式资源来处理CPS中生成的大数据，并减少通信延迟。</li><li>它增强了机器人使用本地和边缘网络共享知识的能力，而不是依赖于远程云。</li><li>通过使资源更接近机器人，它显着降低了处理多个设备的 CPS 中的带宽要求（用于将数据发送到云）。</li><li>通过多智能体云机器人技术，CPS 对云数据中心的依赖性以及云数据中心（处理多个 CPS）的负载急剧降低。</li></ul><p><img src="http://cdn.leafii.top/img/image-20231112205735164.png" alt="image-20231112205735164" loading="lazy"></p><h3 id="多智能体云机器人系统和相关的计算范例"><a href="#多智能体云机器人系统和相关的计算范例" class="headerlink" title="多智能体云机器人系统和相关的计算范例"></a>多智能体云机器人系统和相关的计算范例</h3><p>接下来，将多智能体云机器人技术同移动云计算（MCC）和多接入边缘计算（MEC）进行了对比。相较于MCC和MEC，多智能体云机器人技术的网络连接方式更多样，而且支持AI智能决策，这使其更复杂。因此，有效的资源调度很重要，尤其是在这种需求多样的条件下。</p><h3 id="多智能体云机器人系统的资源调度和服务提供的挑战"><a href="#多智能体云机器人系统的资源调度和服务提供的挑战" class="headerlink" title="多智能体云机器人系统的资源调度和服务提供的挑战"></a>多智能体云机器人系统的资源调度和服务提供的挑战</h3><ul><li>实时学习和自动的动作</li><li>复杂的数据流处理</li><li>动态的机器人合作</li><li>跨基础设施的互操作性</li><li>异步的决策</li><li>按需计算和通信权衡</li><li>系统的特定策略</li><li>能源延迟优化</li><li>综合商业模式</li><li>异构导致的安全问题</li></ul><h3 id="文章的贡献"><a href="#文章的贡献" class="headerlink" title="文章的贡献"></a>文章的贡献</h3><ul><li>在考虑资源类型，表现评价计量，应用结构，服务模型和分发机制的情况下对资源调度进行了分类。</li><li>将用于有效提供服务的资源池化，计算迁移和任务调度的现有方法进行了很好的探索。</li><li>从研究综述中学到的知识进行聚合，并且填补了在多智能体云机器人系统中机器人系统的资源调度和服务提供的gap。</li><li>探索了未来的研究方向。</li></ul><h2 id="多智能体云机器人系统技术进展概述"><a href="#多智能体云机器人系统技术进展概述" class="headerlink" title="多智能体云机器人系统技术进展概述"></a>多智能体云机器人系统技术进展概述</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;原题目：Resource Allocation and Service Provisioning in Multi-Agent Cloud Robotics: A Comprehensive Survey&lt;/p&gt;</summary>
    
    
    
    
    <category term="多智能体" scheme="tags/多智能体/"/>
    
    <category term="资源调度" scheme="tags/资源调度/"/>
    
    <category term="云机器人" scheme="tags/云机器人/"/>
    
    <category term="综述" scheme="tags/综述/"/>
    
  </entry>
  
  <entry>
    <title>一种解决复杂物流网络资源平衡问题的合作多智能体强化学习框架</title>
    <link href="2023/11/12/%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E7%89%A9%E6%B5%81%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%88%E4%BD%9C%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    <id>2023/11/12/%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E7%89%A9%E6%B5%81%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%88%E4%BD%9C%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/</id>
    <published>2023-11-12T12:45:24.000Z</published>
    <updated>2023-11-12T12:48:43.823Z</updated>
    
    <content type="html"><![CDATA[<p>原题目：A Cooperative Multi-Agent Reinforcement Learning Framework for Resource Balancing in Complex Logistics Network</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;原题目：A Cooperative Multi-Agent Reinforcement Learning Framework for Resource Balancing in Complex Logistics Network&lt;/p&gt;</summary>
    
    
    
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
    <category term="多智能体" scheme="tags/多智能体/"/>
    
    <category term="资源调度" scheme="tags/资源调度/"/>
    
    <category term="物流网络" scheme="tags/物流网络/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1447.最简分数</title>
    <link href="2023/11/03/leetcode1447-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/"/>
    <id>2023/11/03/leetcode1447-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/</id>
    <published>2023-11-03T12:21:39.000Z</published>
    <updated>2023-11-03T12:22:35.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 <code>n</code> 的 <strong>最简</strong> 分数 。分数可以以 <strong>任意</strong> 顺序返回。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：[&quot;1&#x2F;2&quot;]解释：&quot;1&#x2F;2&quot; 是唯一一个分母小于等于 2 的最简分数。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：[&quot;1&#x2F;2&quot;,&quot;1&#x2F;3&quot;,&quot;2&#x2F;3&quot;]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：[&quot;1&#x2F;2&quot;,&quot;1&#x2F;3&quot;,&quot;1&#x2F;4&quot;,&quot;2&#x2F;3&quot;,&quot;3&#x2F;4&quot;]解释：&quot;2&#x2F;4&quot; 不是最简分数，因为它可以化简为 &quot;1&#x2F;2&quot; 。</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>利用自己写的最大公约数函数直接求解即可</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int getGCD(int x, int y) &#123;        int z &#x3D; y;        while (x % y !&#x3D; 0) &#123;            z &#x3D; x % y;            x &#x3D; y;            y &#x3D; z;        &#125;        return z;    &#125;    vector&lt;string&gt; simplifiedFractions(int n) &#123;        vector&lt;string&gt; results;        if (n &gt; 1) &#123;            int numerator &#x3D; 1;            int denominator &#x3D; 2;            for (int numerator &#x3D; 1; numerator &lt;&#x3D; n - 1; numerator++) &#123;                for (int denominator &#x3D; numerator + 1; denominator &lt;&#x3D; n; denominator++) &#123;                    if(getGCD(numerator, denominator)&#x3D;&#x3D;1) &#123;                        &#x2F;&#x2F; 如果是最简分数                        string temp &#x3D; to_string(numerator) + &quot;&#x2F;&quot; + to_string(denominator);                        results.push_back(temp);                    &#125;                &#125;            &#125;        &#125;        return results;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;最简&lt;/strong&gt; 分数 。分数可以以 &lt;strong&gt;任意&lt;/strong&gt; 顺序返回。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode258.各位相加</title>
    <link href="2023/11/03/leetcode258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/"/>
    <id>2023/11/03/leetcode258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-11-03T12:19:02.000Z</published>
    <updated>2023-11-03T12:21:18.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: num &#x3D; 38输出: 2 解释: 各位相加的过程为：38 --&gt; 3 + 8 --&gt; 1111 --&gt; 1 + 1 --&gt; 2由于 2 是一位数，所以返回 2。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: num &#x3D; 0输出: 0</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= num &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接做</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int addDigits(int num) &#123;        int sum &#x3D; 0; &#x2F;&#x2F; 初始化sum        while (num &gt; 0) &#123;            int temp &#x3D; num % 10; &#x2F;&#x2F; 获取个位数的值            num &#x2F;&#x3D; 10; &#x2F;&#x2F; num移去个位数的数字            sum +&#x3D; temp; &#x2F;&#x2F; 更新sum值        &#125;        if (sum &gt;&#x3D; 10) &#123;            return addDigits(sum); &#x2F;&#x2F; 递归调用函数，        &#125;        else &#123;            return sum; &#x2F;&#x2F; 符合条件时直接return sum        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负整数 &lt;code&gt;num&lt;/code&gt;，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode914.卡牌分组</title>
    <link href="2023/10/30/leetcode914-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/"/>
    <id>2023/10/30/leetcode914-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</id>
    <published>2023-10-30T08:57:10.000Z</published>
    <updated>2023-11-03T12:19:21.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有 <code>X</code> 张牌。</li><li>组内所有的牌上都写着相同的整数。</li></ul><p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：deck &#x3D; [1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：deck &#x3D; [1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= deck.length &lt;= 104</code></li><li><code>0 &lt;= deck[i] &lt; 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>使用哈希表+最小公约数解决</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) &#123;        unordered_map&lt;int, int&gt; deck_map; &#x2F;&#x2F; 用于统计牌的数量        int n &#x3D; deck.size();        for(int num:deck) &#123;            deck_map[num]++; &#x2F;&#x2F; 统计牌的数量        &#125;        int gcd &#x3D; 0; &#x2F;&#x2F; 初始化最大公约数        for (const auto&amp; entry : deck_map) &#123;            gcd &#x3D; __gcd(gcd, entry.second); &#x2F;&#x2F; 最大公约数更新        &#125;        return gcd &gt;&#x3D; 2; &#x2F;&#x2F; 符合题目条件时才返回true    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一副牌，每张牌上都写着一个整数。&lt;/p&gt;
&lt;p&gt;此时，你需要选定一个数字 &lt;code&gt;X&lt;/code&gt;，使我们可以将整副牌按下述规则分成 1 组或更多组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每组都有 &lt;code&gt;X&lt;/code&gt; 张牌。&lt;/li&gt;
&lt;li&gt;组内所有的牌上都写着相同的整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仅当你可选的 &lt;code&gt;X &amp;gt;= 2&lt;/code&gt; 时返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode30.串联所有单词的子串</title>
    <link href="2023/10/20/leetcode30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>2023/10/20/leetcode30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</id>
    <published>2023-10-20T01:56:52.000Z</published>
    <updated>2023-11-03T12:19:16.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p><p> <code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;barfoothefoobarman&quot;, words &#x3D; [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：因为 words.length &#x3D;&#x3D; 2 同时 words[i].length &#x3D;&#x3D; 3，连接的子字符串的长度必须为 6。子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。输出顺序无关紧要。返回 [9,0] 也是可以的。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;wordgoodgoodgoodbestword&quot;, words &#x3D; [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[]解释：因为 words.length &#x3D;&#x3D; 4 并且 words[i].length &#x3D;&#x3D; 4，所以串联子串的长度必须为 16。s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。所以我们返回一个空数组。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;barfoofoobarthefoobarman&quot;, words &#x3D; [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]输出：[6,9,12]解释：因为 words.length &#x3D;&#x3D; 3 并且 words[i].length &#x3D;&#x3D; 3，所以串联子串的长度必须为 9。子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>1 &lt;= words.length &lt;= 5000</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>滑动窗口</li></ul><p>此题是438.找到字符串中所有字母异位词的进阶版。不同的是第 438 题的元素是字母，而此题的元素是单词。可以用类似438.找到字符串中所有字母异位词的官方题解的方法二的滑动窗口来解这题。<br>记 words 的长度为 m，words 中每个单词的长度为n，s 的长度为 ls。首先需要将  s划分为单词组，每个单词的大小均为 n(首尾除外) 。这样的划分方法有 n 种，即先删去前  i(i&#x3D;0~n-1)个字后，将剩下字母进行划分，如果未尾有不到 n 个字母也删去。对这 n 种划分得到的单词数组分别使用滑动窗口对 words行类似于字母异位词的搜寻。<br>划分成单词组后，一个窗口包含 s 中前 m 个单词，用一个哈希表 dier 表示窗口中单词频次和 ords 中单词频次之差。初始化 differ 时，出现在窗口中的单词，每出现一次，相应的值增加 1，出现在 ords 中的单词,每出现一次，相应的值减少 1。然后将窗口右移，右侧会加入一个单词，左侧会移出一个单词，并对 differ 做应的更新。窗口移动时，若出现 differ 中值不为 0 的键的数量为 0，则表示这个窗口中的单词频次和 words 中单词频次相同，窗口的左端点是一个待求的起始位置。划分的方法有n种，做n次滑动窗口后，即可找到所有的起始位置。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; findSubstring(string &amp;s, vector&lt;string&gt; &amp;words) &#123;        vector&lt;int&gt; res;  &#x2F;&#x2F; 存储最终结果的向量        int m &#x3D; words.size();  &#x2F;&#x2F; words中单词的数量        int n &#x3D; words[0].size();  &#x2F;&#x2F; 单个单词的长度        int ls &#x3D; s.size();  &#x2F;&#x2F; 字符串s的总长度        &#x2F;&#x2F; 遍历s中的所有可能的起始位置，确保不越界        for (int i &#x3D; 0; i &lt; n &amp;&amp; i + m * n &lt;&#x3D; ls; ++i) &#123;            unordered_map&lt;string, int&gt; differ;  &#x2F;&#x2F; 存储与words中单词的不同之处            &#x2F;&#x2F; 遍历words中的单词，统计它们在当前窗口中的出现次数            for (int j &#x3D; 0; j &lt; m; ++j) &#123;                ++differ[s.substr(i + j * n, n)];             &#125;            &#x2F;&#x2F; 对于每个单词，减少其在differ中的计数，如果计数减为0则从differ中移除            for (string &amp;word: words) &#123;                if (--differ[word] &#x3D;&#x3D; 0) &#123;                    differ.erase(word);                &#125;            &#125;            &#x2F;&#x2F; 移动窗口，开始查找可能的匹配            for (int start &#x3D; i; start &lt; ls - m * n + 1; start +&#x3D; n) &#123;                if (start !&#x3D; i) &#123;                    &#x2F;&#x2F; 更新differ，添加新单词并移除旧单词                    string word &#x3D; s.substr(start + (m - 1) * n, n);                    if (++differ[word] &#x3D;&#x3D; 0) &#123;                        differ.erase(word);                    &#125;                    word &#x3D; s.substr(start - n, n);                    if (--differ[word] &#x3D;&#x3D; 0) &#123;                        differ.erase(word);                    &#125;                &#125;                &#x2F;&#x2F; 如果differ为空，说明当前窗口中的单词与words中的单词匹配                if (differ.empty()) &#123;                    res.emplace_back(start);  &#x2F;&#x2F; 将匹配的起始位置添加到结果中                &#125;            &#125;        &#125;        return res;  &#x2F;&#x2F; 返回最终结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个字符串数组 &lt;code&gt;words&lt;/code&gt;&lt;strong&gt;。&lt;/strong&gt; &lt;code&gt;words&lt;/code&gt; 中所有字符串 &lt;strong&gt;长度相同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;s&lt;/code&gt; 中的 &lt;strong&gt;串联子串&lt;/strong&gt; 是指一个包含 &lt;code&gt;words&lt;/code&gt; 中所有字符串以任意顺序排列连接起来的子串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，如果 &lt;code&gt;words = [&amp;quot;ab&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ef&amp;quot;]&lt;/code&gt;， 那么 &lt;code&gt;&amp;quot;abcdef&amp;quot;&lt;/code&gt;， &lt;code&gt;&amp;quot;abefcd&amp;quot;&lt;/code&gt;，&lt;code&gt;&amp;quot;cdabef&amp;quot;&lt;/code&gt;， &lt;code&gt;&amp;quot;cdefab&amp;quot;&lt;/code&gt;，&lt;code&gt;&amp;quot;efabcd&amp;quot;&lt;/code&gt;， 和 &lt;code&gt;&amp;quot;efcdab&amp;quot;&lt;/code&gt; 都是串联子串。 &lt;code&gt;&amp;quot;acdbef&amp;quot;&lt;/code&gt; 不是串联子串，因为他不是任何 &lt;code&gt;words&lt;/code&gt; 排列的连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回所有串联子串在 &lt;code&gt;s&lt;/code&gt; 中的开始索引。你可以以 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode18.四数之和</title>
    <link href="2023/10/20/leetcode18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>2023/10/20/leetcode18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2023-10-20T01:34:41.000Z</published>
    <updated>2023-10-20T01:36:18.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8输出：[[2,2,2,2]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针法</li></ul><p>双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是<code>O(n^2)</code>，四数之和的时间复杂度是<code>O(n^3) </code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        for (int k &#x3D; 0; k &lt; nums.size(); k++) &#123;            &#x2F;&#x2F; 剪枝处理            if (nums[k] &gt; target &amp;&amp; nums[k] &gt;&#x3D; 0) &#123;            break; &#x2F;&#x2F; 这里使用break，统一通过最后的return返回            &#125;            &#x2F;&#x2F; 对nums[k]去重            if (k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) &#123;                continue;            &#125;            for (int i &#x3D; k + 1; i &lt; nums.size(); i++) &#123;                &#x2F;&#x2F; 2级剪枝处理                if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;&#x3D; 0) &#123;                    break;                &#125;                &#x2F;&#x2F; 对nums[i]去重                if (i &gt; k + 1 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                    continue;                &#125;                int left &#x3D; i + 1;                int right &#x3D; nums.size() - 1;                while (right &gt; left) &#123;                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;                        right--;                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出                    &#125; else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;                        left++;                    &#125; else &#123;                        result.push_back(vector&lt;int&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);                        &#x2F;&#x2F; 对nums[left]和nums[right]去重                        while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;                        while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;                        &#x2F;&#x2F; 找到答案时，双指针同时收缩                        right--;                        left++;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个由 &lt;code&gt;n&lt;/code&gt; 个整数组成的数组 &lt;code&gt;nums&lt;/code&gt; ，和一个目标值 &lt;code&gt;target&lt;/code&gt; 。请你找出并返回满足下述全部条件且&lt;strong&gt;不重复&lt;/strong&gt;的四元组 &lt;code&gt;[nums[a], nums[b], nums[c], nums[d]]&lt;/code&gt; （若两个四元组元素一一对应，则认为两个四元组重复）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= a, b, c, d &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; &lt;strong&gt;互不相同&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[a] + nums[b] + nums[c] + nums[d] == target&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回答案 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode454.四数相加II</title>
    <link href="2023/10/18/leetcode454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>2023/10/18/leetcode454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/</id>
    <published>2023-10-18T01:18:10.000Z</published>
    <updated>2023-10-18T01:36:18.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]输出：1</code></pre><p> <strong>提示：</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>哈希表</li></ul><p>直接上4个for循环铁定要超时，因为时间复杂度高达<code>O(n^4)</code>，在这里利用哈希表查找操作接近O(1)的特性将整体的查找操作的时间复杂度降低到<code>O(n^2)</code>。整体的代码思路如下：</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;        int result &#x3D; 0; &#x2F;&#x2F; 定义结果，类型为int        unordered_map&lt;int, int&gt; cnt; &#x2F;&#x2F; 哈希表cnt 用于统计nums1和nums2数组元素和的次数        for (int i &#x3D; 0; i &lt; nums1.size(); i++) &#123;            for (int j &#x3D; 0; j &lt; nums2.size(); j++) &#123;                int temp &#x3D; nums1[i] + nums2[j];                cnt[temp] &#x3D; cnt[temp]&#x3D;&#x3D;0?1:cnt[temp]+1; &#x2F;&#x2F; 统计过程            &#125;        &#125;        for (int i &#x3D; 0; i &lt; nums3.size(); i++) &#123;            for (int j &#x3D; 0; j &lt; nums4.size(); j++) &#123;                int temp &#x3D; -1 * (nums3[i] + nums4[j]);                &#x2F;&#x2F; 判断如果nums3和nums4中单个元素的和乘以-1在名为cnt的哈希表中非0，就更新result的值                if (cnt[temp] !&#x3D; 0) result +&#x3D; cnt[temp];             &#125;        &#125;        return result; &#x2F;&#x2F; 返回结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你四个整数数组 &lt;code&gt;nums1&lt;/code&gt;、&lt;code&gt;nums2&lt;/code&gt;、&lt;code&gt;nums3&lt;/code&gt; 和 &lt;code&gt;nums4&lt;/code&gt; ，数组长度都是 &lt;code&gt;n&lt;/code&gt; ，请你计算有多少个元组 &lt;code&gt;(i, j, k, l)&lt;/code&gt; 能满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i, j, k, l &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode383.赎金信</title>
    <link href="2023/10/17/leetcode383-%E8%B5%8E%E9%87%91%E4%BF%A1/"/>
    <id>2023/10/17/leetcode383-%E8%B5%8E%E9%87%91%E4%BF%A1/</id>
    <published>2023-10-17T00:53:04.000Z</published>
    <updated>2023-10-17T01:10:07.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;输出：false</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力枚举</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;            for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;                &#x2F;&#x2F; 在ransomNote中找到和magazine相同的字符                if (magazine[i] &#x3D;&#x3D; ransomNote[j]) &#123;                    ransomNote.erase(ransomNote.begin() + j); &#x2F;&#x2F; ransomNote删除这个字符                    break;                &#125;            &#125;        &#125;        &#x2F;&#x2F; 如果ransomNote为空，则说明magazine的字符可以组成ransomNote        if (ransomNote.length() &#x3D;&#x3D; 0) &#123;            return true;        &#125;        return false;    &#125;&#125;;</code></pre><ul><li>哈希表</li></ul><p>使用哈希表分别统计两个字符串中字母的个数，然后对比两个哈希表的结果，如果前者的字母统计个数大于后者，直接返回false，否则最终返回true</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        &#x2F;&#x2F; 初始化哈希表用于统计字符数        unordered_map&lt;char, int&gt; ransomNoteCnt;        unordered_map&lt;char, int&gt; magezineCnt;        for (char c:ransomNote) &#123;            ransomNoteCnt[c] &#x3D; ransomNoteCnt[c]&#x3D;&#x3D;0?1:ransomNoteCnt[c]+1;        &#125;        for (char c:magazine) &#123;            magezineCnt[c] &#x3D; magezineCnt[c]&#x3D;&#x3D;0?1:magezineCnt[c]+1;        &#125;        for (char c &#x3D; &#39;a&#39;; c &lt;&#x3D; &#39;z&#39;; c++) &#123;            if (ransomNoteCnt[c] &lt;&#x3D; magezineCnt[c]) continue;            else return false;        &#125;        return true;    &#125;&#125;;</code></pre><ul><li>更省空间的哈希表解法</li></ul><p>因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个长度为26的数组来记录magazine里字母出现的次数。</p><p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p><p>依然是数组在哈希法中的应用。</p><p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        int record[26] &#x3D; &#123;0&#125;;        &#x2F;&#x2F;add        if (ransomNote.size() &gt; magazine.size()) &#123;            return false;        &#125;        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;            &#x2F;&#x2F; 通过record数据记录 magazine里各个字符出现次数            record[magazine[i]-&#39;a&#39;] ++;        &#125;        for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;            &#x2F;&#x2F; 遍历ransomNote，在record里对应的字符个数做--操作            record[ransomNote[j]-&#39;a&#39;]--;            &#x2F;&#x2F; 如果小于零说明ransomNote里出现的字符，magazine没有            if(record[ransomNote[j]-&#39;a&#39;] &lt; 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串：&lt;code&gt;ransomNote&lt;/code&gt; 和 &lt;code&gt;magazine&lt;/code&gt; ，判断 &lt;code&gt;ransomNote&lt;/code&gt; 能不能由 &lt;code&gt;magazine&lt;/code&gt; 里面的字符构成。&lt;/p&gt;
&lt;p&gt;如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;magazine&lt;/code&gt; 中的每个字符只能在 &lt;code&gt;ransomNote&lt;/code&gt; 中使用一次。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
