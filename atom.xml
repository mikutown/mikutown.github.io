<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-02-20T08:13:18.262Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode860.柠檬水找零</title>
    <link href="2023/02/20/leetcode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <id>2023/02/20/leetcode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</id>
    <published>2023-02-20T08:12:25.000Z</published>
    <updated>2023-02-20T08:13:18.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：bills &#x3D; [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：bills &#x3D; [5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bills.length &lt;= 105</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路</li></ol><p>使用一个大小为2的数组存储5元和10元的数量，对数组进行遍历，最后返回相应的值。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;        vector&lt;int&gt; count(2,0);        for (int i &#x3D; 0; i &lt; bills.size(); i++) &#123;            if (bills[i] &#x3D;&#x3D; 5) &#123;                count[0]++;            &#125;            else if (bills[i] &#x3D;&#x3D; 10) &#123;                if (count[0] !&#x3D; 0) &#123;                    count[0]--;                    count[1]++;                &#125;                else return false;            &#125;            else if (bills[i] &#x3D;&#x3D; 20)&#123;                &#x2F;&#x2F;20 usd&#39;s situation                if (count[1] &gt; 0 &amp;&amp; count[0] &gt; 0) &#123;                    count[0]--;                    count[1]--;                &#125;                else if (count[0] &gt;&#x3D; 3) &#123;                    count[0] -&#x3D; 3;                &#125;                else return false;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 &lt;code&gt;5&lt;/code&gt; 美元。顾客排队购买你的产品，（按账单 &lt;code&gt;bills&lt;/code&gt; 支付的顺序）一次购买一杯。&lt;/p&gt;
&lt;p&gt;每位顾客只买一杯柠檬水，然后向你付 &lt;code&gt;5&lt;/code&gt; 美元、&lt;code&gt;10&lt;/code&gt; 美元或 &lt;code&gt;20&lt;/code&gt; 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 &lt;code&gt;5&lt;/code&gt; 美元。&lt;/p&gt;
&lt;p&gt;注意，一开始你手头没有任何零钱。&lt;/p&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;bills&lt;/code&gt; ，其中 &lt;code&gt;bills[i]&lt;/code&gt; 是第 &lt;code&gt;i&lt;/code&gt; 位顾客付的账。如果你能给每位顾客正确找零，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode455.分发饼干</title>
    <link href="2023/02/19/leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <id>2023/02/19/leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</id>
    <published>2023-02-19T05:35:55.000Z</published>
    <updated>2023-02-19T05:58:44.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><span id="more"></span> <p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路</li></ol><p>对两个数组进行排序，然后使用双层for循环进行贪心的遍历查找；C++实现代码如下，但是显然还有优化空间。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(), g.end());        sort(s.begin(), s.end()); &#x2F;&#x2F;排列数组        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; g.size(); i++) &#123;            for (int j &#x3D; 0; j &lt; s.size(); j++) &#123;                if (s[j] &gt;&#x3D; g[i]) &#123;                    &#x2F;&#x2F; 如果满足条件，则result++,且修改s中的数值。                    &#x2F;&#x2F; g中的无需修改，因为循环会继续                    result++;                    s[j] &#x3D; -1;                    break;                &#125;            &#125;        &#125;        return result;         &#125;&#125;;</code></pre><ol start="2"><li>使用双指针优化刚才的双层for循环，C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(), g.end());        sort(s.begin(), s.end()); &#x2F;&#x2F;排列数组        int result &#x3D; 0;        int i &#x3D; 0, j &#x3D; 0;        while (i &lt; g.size() &amp;&amp; j &lt; s.size()) &#123;            if (s[j] &gt;&#x3D; g[i]) &#123;                result++;                i++;                j++;                        &#125;            else j++;        &#125;        return result;         &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。&lt;/p&gt;
&lt;p&gt;对每个孩子 &lt;code&gt;i&lt;/code&gt;，都有一个胃口值 &lt;code&gt;g[i]&lt;/code&gt;，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 &lt;code&gt;j&lt;/code&gt;，都有一个尺寸 &lt;code&gt;s[j]&lt;/code&gt; 。如果 &lt;code&gt;s[j] &amp;gt;= g[i]&lt;/code&gt;，我们可以将这个饼干 &lt;code&gt;j&lt;/code&gt; 分配给孩子 &lt;code&gt;i&lt;/code&gt; ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode135.分发糖果</title>
    <link href="2023/02/17/leetcode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <id>2023/02/17/leetcode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</id>
    <published>2023-02-17T06:45:58.000Z</published>
    <updated>2023-02-17T06:49:29.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：ratings &#x3D; [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：ratings &#x3D; [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>常规思路</li></ol><p>首先新建一个数组candies，它代表每个人能分得的糖果数，接下来进行两次遍历：第一次从左向右遍历，确保右边评分较高的小孩获得更多的糖果，第二次从右向左遍历，确保左边评分较高的小孩获得更多的糖果。代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        int n &#x3D; ratings.size();        vector&lt;int&gt; candies(n, 1);              &#x2F;&#x2F; 从左往右扫描，保证右边评分高的孩子分到更多的糖果        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (ratings[i] &gt; ratings[i - 1]) &#123;                candies[i] &#x3D; candies[i - 1] + 1;            &#125;        &#125;              &#x2F;&#x2F; 从右往左扫描，保证左边评分高的孩子分到更多的糖果        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;            if (ratings[i] &gt; ratings[i + 1]) &#123;                candies[i] &#x3D; max(candies[i], candies[i + 1] + 1);            &#125;                    &#125;        &#x2F;&#x2F; 计算糖果总数        int result &#x3D; 0;        for (int item: candies) &#123;            result +&#x3D; item;        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 个孩子站成一排。给你一个整数数组 &lt;code&gt;ratings&lt;/code&gt; 表示每个孩子的评分。&lt;/p&gt;
&lt;p&gt;你需要按照以下要求，给这些孩子分发糖果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个孩子至少分配到 &lt;code&gt;1&lt;/code&gt; 个糖果。&lt;/li&gt;
&lt;li&gt;相邻两个孩子评分更高的孩子会获得更多的糖果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请你给每个孩子分发糖果，计算并返回需要准备的 &lt;strong&gt;最少糖果数目&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode122.买卖股票的最佳时机II</title>
    <link href="2023/02/16/leetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>2023/02/16/leetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</id>
    <published>2023-02-16T08:36:11.000Z</published>
    <updated>2023-02-16T08:44:30.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。     总利润为 4 + 3 &#x3D; 7 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     总利润为 4 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li><p>使用贪心法</p><p>为什么要使用贪心法？因为题目明确暗示了：“你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。”</p><p>因此解题思路如下：首先定义一个整形变量result用于存储结果，接着从左向右遍历数组price,若<code>price[i] &lt; price[i+1]</code>，则说明第i天的价格低于第i+1天的价格，此时可以在第i天购买股票然后在第i+1天卖出，将卖出的价格减去前一天买入的价格的差值加到result中，然后继续向右遍历，直至遍历结束，返回result.</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n &#x3D; prices.size();        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;            int j &#x3D; i + 1;            if (prices[j] &gt; prices[i]) &#123;                result &#x3D; result - prices[i] + prices[j];            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><p>虽然走了一些弯路，但是还是做出来了，所以… 稍微得瑟一下：</p><p><img src="http://cdn.leafii.top/img/image-20230216164402662.png" alt="image-20230216164402662" loading="lazy"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;prices&lt;/code&gt; ，其中 &lt;code&gt;prices[i]&lt;/code&gt; 表示某支股票第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;在每一天，你可以决定是否购买和&amp;#x2F;或出售股票。你在任何时候 &lt;strong&gt;最多&lt;/strong&gt; 只能持有 &lt;strong&gt;一股&lt;/strong&gt; 股票。你也可以先购买，然后在 &lt;strong&gt;同一天&lt;/strong&gt; 出售。&lt;/p&gt;
&lt;p&gt;返回 &lt;em&gt;你能获得的 &lt;strong&gt;最大&lt;/strong&gt; 利润&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode55.跳跃游戏</title>
    <link href="2023/02/15/leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>2023/02/15/leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2023-02-15T10:21:20.000Z</published>
    <updated>2023-02-15T10:45:13.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>利用栈（<strong>超时</strong>）</li></ol><p>将能到达的数组元素推进栈，模拟树的操作，但是会超时。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int len &#x3D; nums.size();        if (len &gt; 1 &amp;&amp; nums[0] &#x3D;&#x3D; 0) return false;        if (len &#x3D;&#x3D; 1) return true;        stack&lt;int&gt; s; &#x2F;&#x2F; 定义一个栈        int index &#x3D; 0;        if (nums[index] &gt; len) return true;        s.push(index);        while(!s.empty()) &#123;            int temp_index &#x3D; s.top();            int temp_num &#x3D; nums[temp_index];            s.pop();            for (int i &#x3D; 1; i &lt;&#x3D; temp_num; i++) &#123;                if (temp_index + i &#x3D;&#x3D; len - 1) return true;                if (nums[temp_index + i] &gt;&#x3D; (len - (temp_index + i))) return true;                if (nums[temp_index + i] !&#x3D; 0) s.push(temp_index + i);            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><p>用chatGPT分析超时的原因：</p><blockquote><p>您的代码的时间复杂度为 O(2^n)，其中 n 是数组的长度，因为在每个位置都可以有两个选择：跳或不跳，总共有 2^n 种可能的路径。这样的时间复杂度是无法通过本题的。</p><p>此外，您使用了栈来存储待搜索的位置，但这样的做法并不高效。因为每个位置最多只需要被遍历一次，而使用栈会重复遍历一些位置，导致时间复杂度进一步增加。</p></blockquote><ol start="2"><li>使用贪心算法</li></ol><p>使用贪心算法，从左到右遍历数组，用一个变量来维护能够到达的最远距离，如果当前位置在这个最远距离之内，那么更新最远距离。如果遍历结束后最远距离大于等于数组的最后一个位置，那么就说明可以到达最后一个位置，否则就无法到达。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        int maxPos &#x3D; 0; &#x2F;&#x2F; 当前能到达的最远距离        for (int i &#x3D; 0; i &lt; n; i++) &#123;            if (i &gt; maxPos) return false; &#x2F;&#x2F; 如果当前位置无法到达，则返回false            maxPos &#x3D; max(maxPos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远距离            if (maxPos &gt;&#x3D; n - 1) return true; &#x2F;&#x2F; 如果能够到达最后一个位置，返回true        &#125;        return false;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个下标。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode101.对称二叉树</title>
    <link href="2023/02/14/leetcode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/02/14/leetcode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-02-14T07:18:47.000Z</published>
    <updated>2023-02-14T07:39:03.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/symtree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,4,4,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/symtree2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,null,3,null,3]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路（<strong>无法通过</strong>）：</li></ol><p>本来是想直接通过中序遍历获得一个数组，然后从数组的两端向中间进行判断，最后样例通过数为192&#x2F;199，原因是如果输入为<code>[1,2,2,2,null,2]</code>时，中序遍历得到的数组是对称的，但是实际上这个二叉树不是对称的。因此该思路被我放弃了。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F; &#x2F;&#x2F; 3241423 中序遍历 先左再中间最后右子树class Solution &#123;public:    void Middle_order_traversal(TreeNode* rootNode, vector&lt;int&gt;&amp; rst) &#123;        if (rootNode) &#123;            Middle_order_traversal(rootNode -&gt; left, rst);            rst.push_back(rootNode -&gt; val);            Middle_order_traversal(rootNode -&gt; right, rst);        &#125;        else &#123;            rst.push_back(-1);        &#125;    &#125;    bool isSymmetric(TreeNode* root) &#123;        vector&lt;int&gt; rst;        Middle_order_traversal(root, rst);        if (rst.size()%2&#x3D;&#x3D;0) &#123;            return false;        &#125;        int left &#x3D; 0, right &#x3D; rst.size() - 1;        while(left &lt; right) &#123;            if (rst[left] !&#x3D; rst[right]) &#123;                return false;            &#125;            left++;            right--;        &#125;        return true;    &#125;&#125;;</code></pre><ol start="2"><li>使用递归：</li></ol><p>在对root进行判断之后，就使用一个辅助函数对root的左子树和右子树进行判断，判断完成后分别对左子树的左子树和右子树的右子树；左子树的右子树以及右子树的左子树进行判断，两个判断结果进行与运算，递归得到最终结果。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若根节点为空，则返回true        return isSymmetricHelper(root-&gt;left, root-&gt;right);    &#125;    bool isSymmetricHelper(TreeNode* left, TreeNode* right) &#123;        if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若左右都为空，则返回true      &#x2F;&#x2F; if ((left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) || (left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL)) return false; &#x2F;&#x2F; 左右子树一个空一个不空，返回false (下面这行更简练)        if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;若左右节点有一个不为空，则返回false        if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F;若左右节点的值不相等，则返回false        &#x2F;&#x2F;递归检查左右子树是否对称        return isSymmetricHelper(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetricHelper(left-&gt;right, right-&gt;left);    &#125;&#125;;</code></pre><ol start="3"><li>使用迭代</li></ol><p>该解决方案使用队列来存储树的节点，首先将左子树和右子树的根节点加入队列中。然后在循环中，每次取出队列的头两个节点，并比较它们是否对称，如果不对称则返回false。如果对称，则将左节点的左子树节点和右节点的右子树节点加入队列，再将左节点的右子树节点和右节点的左子树节点加入队列。如果队列为空，则说明树是对称的，返回true。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;节点为空，返回true        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 定义一个队列存储节点        q.push(root-&gt;left);        q.push(root-&gt;right);        while (!q.empty()) &#123;            TreeNode* left &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为左节点            TreeNode* right &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为右节点            if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) continue; &#x2F;&#x2F;如果左右节点都为空，则继续迭代            if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;左右节点只有一个不为空，直接返回false            if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F; 左右节点值不等，直接返回false            q.push(left-&gt;left);            q.push(right-&gt;right);            q.push(left-&gt;right);            q.push(right-&gt;left); &#x2F;&#x2F; 注意push的顺序！！！        &#125;         return true; &#x2F;&#x2F;若队列为空，则说明该二叉树是对称的。    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ， 检查它是否轴对称。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode100.相同的树</title>
    <link href="2023/02/13/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>2023/02/13/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</id>
    <published>2023-02-13T07:14:04.000Z</published>
    <updated>2023-02-13T07:22:47.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：p &#x3D; [1,2,3], q &#x3D; [1,2,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/ex2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：p &#x3D; [1,2], q &#x3D; [1,null,2]输出：false</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/ex3.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：p &#x3D; [1,2,1], q &#x3D; [1,1,2]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><p>题目要求判断两棵树是否完全相同。</p><p>我们可以使用递归的方法，递归判断两棵树的根节点是否相同，以及它们的左子树和右子树是否相同。</p><p>如果两棵树都为空，则返回 true。如果有一棵树为空，另一棵树不为空，则返回 false。如果两棵树的根节点的值不相等，则返回 false。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 递归函数，判断两棵树是否相同    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        &#x2F;&#x2F; 如果两棵树都为空，则返回 true        if (!p &amp;&amp; !q) return true;        &#x2F;&#x2F; 如果有一棵树为空，另一棵树不为空，则返回 false        if (!p || !q) return false;        &#x2F;&#x2F; 如果两棵树的根节点的值不相等，则返回 false        if (p-&gt;val !&#x3D; q-&gt;val) return false;        &#x2F;&#x2F; 递归判断两棵树的左子树和右子树是否相同        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);    &#125;&#125;;</code></pre><p>可以将代码简化为：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        &#x2F;&#x2F; 如果两棵树都为空或者都不为空且值相等，则继续递归        if (!p &amp;&amp; !q) return true;        if (p &amp;&amp; q &amp;&amp; p-&gt;val &#x3D;&#x3D; q-&gt;val)            return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);        &#x2F;&#x2F; 否则，返回 false        return false;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两棵二叉树的根节点 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; ，编写一个函数来检验这两棵树是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:76.最小覆盖子串</title>
    <link href="2023/02/09/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <id>2023/02/09/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</id>
    <published>2023-02-08T18:10:05.000Z</published>
    <updated>2023-02-10T10:57:24.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;输出：&quot;BANC&quot;解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#39;A&#39;、&#39;B&#39; 和 &#39;C&#39;。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;输出：&quot;a&quot;解释：整个字符串 s 是最小覆盖子串。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;输出: &quot;&quot;解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</code></pre><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>滑动窗口</li></ol><p>一个常见的解决方案是使用双指针法和滑动窗口技巧，并利用一个哈希表来维护字符串 <code>t</code> 中字符的出现次数。</p><p>我们用两个指针分别指向当前枚举的子串的左端点和右端点，同时用一个计数器维护当前子串是否已经包含了字符串 <code>t</code> 中的所有字符。</p><p>每当右指针移动到一个字符时，如果该字符在字符串 <code>t</code> 中出现过，则将哈希表中该字符的计数器减一，同时如果该字符的计数器减一后不再为 0，则将计数器减一，表示该字符已经被包含在当前子串中了。</p><p>当计数器变成 0 时，说明当前子串已经包含了字符串 <code>t</code> 中的所有字符，此时开始移动左指针，直到该子串不再包含字符串 <code>t</code> 中的所有字符，此时计数器再次变成非 0 的值，表示当前子串不再完整包含字符串 <code>t</code>。</p><p>在整个过程中，每当移动左指针时，同时记录当前子串的长度是否比之前记录的子串长度更短，如果是，则将当前子串的长度和起始位置记录下来，作为结果的可能。</p><p>这样，我们就可以在 $O(m + n)$ 的时间复杂度内解决此问题。</p><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string minWindow(string s, string t) &#123;        unordered_map&lt;char, int&gt; t_map;        for (const char&amp; c : t) &#123;            ++t_map[c];        &#125;        int left &#x3D; 0, right &#x3D; 0, count &#x3D; t.length(), min_len &#x3D; INT_MAX, min_start &#x3D; 0;        while (right &lt; s.length()) &#123;            &#x2F;&#x2F; 右指针右移            if (t_map[s[right++]]-- &gt; 0) &#123;                --count;            &#125;            while (count &#x3D;&#x3D; 0) &#123;                if (right - left &lt; min_len) &#123;                    min_len &#x3D; right - left;                    min_start &#x3D; left;                &#125;                &#x2F;&#x2F; 左指针左移                if (t_map[s[left++]]++ &#x3D;&#x3D; 0) &#123;                    ++count;                &#125;            &#125;        &#125;        return min_len &#x3D;&#x3D; INT_MAX ? &quot;&quot; : s.substr(min_start, min_len);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 、一个字符串 &lt;code&gt;t&lt;/code&gt; 。返回 &lt;code&gt;s&lt;/code&gt; 中涵盖 &lt;code&gt;t&lt;/code&gt; 所有字符的最小子串。如果 &lt;code&gt;s&lt;/code&gt; 中不存在涵盖 &lt;code&gt;t&lt;/code&gt; 所有字符的子串，则返回空字符串 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;t&lt;/code&gt; 中重复字符，我们寻找的子字符串中该字符数量必须不少于 &lt;code&gt;t&lt;/code&gt; 中该字符数量。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;s&lt;/code&gt; 中存在这样的子串，我们保证它是唯一的答案。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:59.螺旋矩阵II</title>
    <link href="2023/02/09/leetcode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <id>2023/02/09/leetcode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</id>
    <published>2023-02-08T16:53:16.000Z</published>
    <updated>2023-02-10T10:58:03.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个正整数 $n$ ，生成一个包含 $1$ 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 $n \times n$ 正方形矩阵 <code>matrix</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：[[1,2,3],[8,9,4],[7,6,5]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>定义四个变量<code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>，分别代表矩阵的上下左右边界。</li><li>定义一个变量 <code>count</code> 表示当前元素的值，初始值为1。</li><li>只要 <code>top &lt;= bottom &amp;&amp; left &lt;= right</code> ，循环执行以下步骤：<ol><li>先向右填充 <code>top</code> 行的元素，元素的值递增，并将 <code>top</code> 向下移动1。</li><li>向下填充 <code>right</code> 列的元素，元素的值递增，并将 <code>right</code> 向左移动1。</li><li>如果 <code>top &lt;= bottom</code> ，向左填充 <code>bottom</code> 行的元素，元素的值递增，并将 <code>bottom</code> 向上移动1。</li><li>如果 <code>left &lt;= right</code> ，向上填充 <code>left</code> 列的元素，元素的值递增，并将 <code>left</code> 向右移动1。</li></ol></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 0));        int top &#x3D; 0, bottom &#x3D; n - 1, left &#x3D; 0, right &#x3D; n - 1;        int count &#x3D; 1;        while (top &lt;&#x3D; bottom &amp;&amp; left &lt;&#x3D; right) &#123;            for (int j &#x3D; left; j &lt;&#x3D; right; j++) &#123;                matrix[top][j] &#x3D; count++;            &#125;            top++;            for (int i &#x3D; top; i &lt;&#x3D; bottom; i++) &#123;                matrix[i][right] &#x3D; count++;            &#125;            right--;            if (top &lt;&#x3D; bottom) &#123;                for (int j &#x3D; right; j &gt;&#x3D; left; j--) &#123;                    matrix[bottom][j] &#x3D; count++;                &#125;                bottom--;            &#125;            if (left &lt;&#x3D; right) &#123;                for (int i &#x3D; bottom; i &gt;&#x3D; top; i--) &#123;                    matrix[i][left] &#x3D; count++;                &#125;                left++;            &#125;        &#125;        return matrix;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个正整数 $n$ ，生成一个包含 $1$ 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 $n \times n$ 正方形矩阵 &lt;code&gt;matrix&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:209.长度最小的子数组</title>
    <link href="2023/02/07/leetcode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>2023/02/07/leetcode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2023-02-07T11:43:53.000Z</published>
    <updated>2023-02-07T11:49:11.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：target &#x3D; 4, nums &#x3D; [1,4,4]输出：1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>滑动窗口法</li></ol><p>直接使用双重for循环会超时，因此在这里使用滑动窗口的思想，在一个for循环中解决问题，在for循环中索引值为窗口的右边界。当<code>sum &gt;= target</code>时，窗口左边的指针进行右移，同时<code>sum -= nums[i++]</code>，最终遍历结束就得到了左指针和右指针的最终位置。结果为右指针-左指针+1.</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int sum &#x3D; 0;        int n &#x3D; nums.size();        for (int num : nums) &#123;            if (num &#x3D;&#x3D; target) &#123;                return 1; &#x2F;&#x2F;若数组中有包含target的值，直接返回1            &#125;            sum +&#x3D; num;        &#125;        if (sum &lt; target) &#123;            return 0; &#x2F;&#x2F;若数组所有正数之和均小于target，则直接返回0        &#125;else if (sum &#x3D;&#x3D; target) &#123;            return nums.size();&#x2F;&#x2F;若数组所有正数之和刚好等于target，则直接返回数组的长度        &#125;else &#123;            int result &#x3D; INT32_MAX;&#x2F;&#x2F;初始化为int的最大值            int sum &#x3D; 0;            int i &#x3D; 0;            int subLength &#x3D; 0;            for(int j &#x3D; 0; j &lt; nums.size(); j++) &#123; &#x2F;&#x2F;窗口右边界                sum +&#x3D; nums[j];                while (sum &gt;&#x3D; target) &#123;                    subLength &#x3D; j - i + 1;                    result &#x3D; result &lt; subLength? result:subLength;                    sum -&#x3D; nums[i++]; &#x2F;&#x2F;滑动窗口                &#125;            &#125;            return result;        &#125;        return 0;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个含有 &lt;code&gt;n&lt;/code&gt; 个正整数的数组和一个正整数 &lt;code&gt;target&lt;/code&gt; &lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找出该数组中满足其和 &lt;code&gt;≥ target&lt;/code&gt; 的长度最小的 &lt;strong&gt;连续子数组&lt;/strong&gt; &lt;code&gt;[numsl, numsl+1, ..., numsr-1, numsr]&lt;/code&gt; ，并返回其长度&lt;strong&gt;。&lt;/strong&gt;如果不存在符合条件的子数组，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:977.有序数组的平方</title>
    <link href="2023/02/06/leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <id>2023/02/06/leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</id>
    <published>2023-02-06T11:32:22.000Z</published>
    <updated>2023-02-06T15:08:19.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-7,-3,2,3,11]输出：[4,9,9,49,121]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>常规思路</li></ol><p>先对每个数组的元素进行平方赋值，然后对数组进行排序。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            nums[i] &#x3D; nums[i] * nums[i];        &#125;        sort(nums.begin(), nums.end()); &#x2F;&#x2F;排序        return nums;    &#125;&#125;;</code></pre><ol start="2"><li>利用指向正负分界线的指针构造“归并排序”</li></ol><p>常规思路未使用题目的“非递减顺序数组”的条件，因此我们新建一个指针，它指向数组中的最后一个非正数元素，然后从中间向两边进行遍历，将平方和较小的结果插入rst数组中。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; rst;        int n &#x3D; nums.size();        &#x2F;&#x2F;1. 获取数组正负边界索引        int index &#x3D; -1;        for(int i &#x3D; 0; i &lt; n; i++) &#123;            if (nums[i] &lt; 0) &#123;                index &#x3D; i;            &#125;            else &#123;                break;            &#125;        &#125;        &#x2F;&#x2F;2. 双指针从中间向两边遍历        int i &#x3D; index;        int j &#x3D; index + 1;        while(i &gt;&#x3D; 0 || j &lt; n) &#123;            if (i &lt; 0) &#123;                rst.push_back(nums[j] * nums[j]);                j++;            &#125;            else if (j &#x3D;&#x3D; n) &#123;                rst.push_back(nums[i] * nums[i]);                i--;            &#125;            else if (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;                rst.push_back(nums[i] * nums[i]);                i--;            &#125;            else &#123;                rst.push_back(nums[j] * nums[j]);                j++;            &#125;        &#125;        return rst;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排序的整数数组 &lt;code&gt;nums&lt;/code&gt;，返回 &lt;strong&gt;每个数字的平方&lt;/strong&gt; 组成的新数组，要求也按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:704.二分查找</title>
    <link href="2023/02/05/leetcode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>2023/02/05/leetcode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2023-02-05T04:46:18.000Z</published>
    <updated>2023-02-05T04:49:24.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2输出: -1解释: 2 不存在 nums 中因此返回 -1</code></pre><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>如题目所示，直接使用二分查找即可。C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int size &#x3D; nums.size();        int left &#x3D; 0;        int right &#x3D; size - 1;        int mid &#x3D; (left + (right - left) &#x2F; 2);        while(nums[mid] !&#x3D; target &amp;&amp; left &lt; right) &#123;            if (nums[mid] &gt; target) &#123;                right &#x3D; mid - 1;            &#125;            else &#123;                left &#x3D; mid + 1;            &#125;            mid &#x3D; (left + (right - left) &#x2F; 2);        &#125;        if (nums[mid] &#x3D;&#x3D; target) &#123;            return mid;        &#125;        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个 &lt;code&gt;n&lt;/code&gt; 个元素有序的（升序）整型数组 &lt;code&gt;nums&lt;/code&gt; 和一个目标值 &lt;code&gt;target&lt;/code&gt; ，写一个函数搜索 &lt;code&gt;nums&lt;/code&gt; 中的 &lt;code&gt;target&lt;/code&gt;，如果目标值存在返回下标，否则返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:37.解数独</title>
    <link href="2023/02/03/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>2023/02/03/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/</id>
    <published>2023-02-03T06:58:10.000Z</published>
    <updated>2023-02-05T04:47:59.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/250px-sudoku-by-l2g-20050714svg.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</code></pre><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>我们可以考虑按照「行优先」的顺序依次枚举每一个空白格中填的数字，通过递归 + 回溯的方法枚举所有可能的填法。当递归到最后一个空白格后，如果仍然没有冲突，说明我们找到了答案；在递归的过程中，如果当前的空白格不能填下任何一个数字，那么就进行回溯。</p><p>由于每个数字在同一行、同一列、同一个九宫格中只会出现一次，因此我们可以使用<code>line[i]，column[j]，block[x][y]</code>分别表示第 i 行，第 j 列，第(x,y) 个九宫格中填写数字的情况。在下面给出的三种方法中，我们将会介绍两种不同的表示填写数字情况的方法。</p><blockquote><p>九宫格的范围为 $0 \leq x \leq 2$以及 $0 \leq y \leq 2$。 具体地，第 i 行第 j 列的格子位于第$(\lfloor i&#x2F;3 \rfloor, \lfloor j&#x2F;3 \rfloor)$个九宫格中，其中$\lfloor u \rfloor$表示对 u 向下取整。</p></blockquote><ol><li>回溯法</li></ol><p><strong>思路</strong>：最容易想到的方法是用一个数组记录每个数字是否出现。由于我们可以填写的数字范围为[1,9]，而数组的下标从 0 开始，因此在存储时，我们使用一个长度为 9 的布尔类型的数组，其中 i 个元素的值为 $\text{True}$，当且仅当数字i+1 出现过。例如我们用 $\textit{line}[2][3] &#x3D; \text{True}$ 表示数字 4 在第 2 行已经出现过，那么当我们在遍历到第 2 行的空白格时，就不能填入数字 4。</p><p><strong>算法</strong>：</p><p>首先对整个数独数组进行遍历，当我们遍历到第i行第j列时：</p><ul><li>若该位置是一个空白格，那么我们将其加入一个用来存储空白格位置的列表中，方便后续的递归操作；</li><li>若该位置是一个数字x，那么我们需要将<code>line[i][x-1],column[j][x-1]</code>以及<code>block[i/3][j/3][x-1]</code>都置为True。</li></ul><p>当我们结束了遍历过程之后，就可以开始递归枚举。当递归到第 $i$ 行第 $j$ 列的位置时，我们枚举填入的数字 $x$。根据题目的要求，数字 $x$ 不能和当前行、列、九宫格中已经填入的数字相同，因此 $line[i][x-1]$，$\textit{column}[j][x-1]$以及 $\textit{block}[\lfloor i&#x2F;3 \rfloor][\lfloor j&#x2F;3 \rfloor][x-1]$ 必须均为 $\text{False}$。</p><p>当我们填入了数字 $x$ 之后，我们要将上述的三个值都置为 $\text{True}$，并且继续对下一个空白格位置进行递归。在回溯到当前递归层时，我们还要将上述的三个值重新置为 $\text{False}$。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    bool line[9][9];    bool column[9][9];    bool block[3][3][9];    bool valid;    vector&lt;pair&lt;int, int&gt;&gt; spaces;public:    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;        if (pos &#x3D;&#x3D; spaces.size()) &#123;            valid &#x3D; true;            return;        &#125;        auto [i, j] &#x3D; spaces[pos]; &#x2F;&#x2F;获取空位位置        for (int digit &#x3D; 0; digit &lt; 9 &amp;&amp; !valid; ++digit) &#123;            if (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i &#x2F; 3][j &#x2F; 3][digit]) &#123;                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;填符合条件的数字                board[i][j] &#x3D; digit + &#39;0&#39; + 1;                dfs(board, pos + 1); &#x2F;&#x2F;递归                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; false; &#x2F;&#x2F;回溯            &#125;        &#125;    &#125;    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        memset(line, false, sizeof(line));        memset(column, false, sizeof(column));        memset(block, false, sizeof(block));        valid &#x3D; false;        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;                    spaces.emplace_back(i, j); &#x2F;&#x2F;initialize                &#125;                else &#123;                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;                    line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;initialize                &#125;            &#125;        &#125;        dfs(board, 0); &#x2F;&#x2F;从头开始求解，最后得到填满数字的board    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/">https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;数独的解法需 &lt;strong&gt;遵循如下规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一个以粗实线分隔的 &lt;code&gt;3x3&lt;/code&gt; 宫内只能出现一次。（请参考示例图）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数独部分空格内已填入了数字，空白格用 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 表示。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:198.打家劫舍</title>
    <link href="2023/02/03/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>2023/02/03/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2023-02-03T06:32:26.000Z</published>
    <updated>2023-02-05T04:48:09.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>动态规划分析如下：</p><ol><li>确定dp数组(dp table)以及它的下标的含义：</li></ol><p>dp[i]:考虑下标i以内的房屋，最多可以偷窃的金额为dp[i];</p><ol start="2"><li>确定递推公式</li></ol><p>决定是否偷第i个房间:</p><ul><li>如果偷第i个房间，dp[i] &#x3D; dp[i - 2] + nums[i];</li></ul><p>也就是不偷第i-1，而是找到i-2以内最多的房屋，然后再加上第i间房偷到的钱。</p><ul><li>如果不偷第i个房间，那么dp[i] &#x3D; dp[i - 1];也就是要考虑i-1房（<strong>注意这里是考虑而不是真的要偷i-1房</strong>）</li></ul><p>完成分析后取dp[i]的最大值，也就是dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>因为dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);所以基础就是dp[0]和dp[1];</p><p>因此dp[0] &#x3D; nums[0],dp[1] &#x3D; max(nums[0], nums[1]);</p><ol start="4"><li>确定遍历顺序</li></ol><p>dp[i]是根据dp[i-2]和dp[i-1]推导出来的，那么一定是从前到后遍历。</p><ol start="5"><li>举例推导dp数组</li></ol><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        if(nums.empty()) &#123;            return 0;        &#125;        int size &#x3D; nums.size();        if(size &#x3D;&#x3D; 1) &#123;            return nums[0];        &#125;        vector&lt;int&gt; dp &#x3D; vector&lt;int&gt;(size, 0); &#x2F;&#x2F;3. initialize        dp[0] &#x3D; nums[0];        dp[1] &#x3D; max(nums[0], nums[1]);        &#x2F;&#x2F;4. 遍历        for(int i &#x3D; 2; i &lt; size; i++) &#123;            dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);        &#125;        return dp[size - 1];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 &lt;strong&gt;不触动警报装置的情况下&lt;/strong&gt; ，一夜之内能够偷窃到的最高金额。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:53.最大子数组和</title>
    <link href="2023/02/02/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>2023/02/02/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</id>
    <published>2023-02-02T06:40:12.000Z</published>
    <updated>2023-02-03T13:02:55.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1]输出：1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [5,4,-1,7,8]输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>可以很容易想到$f(i) &#x3D; max{f(i-1) + nums[i], nums[i]}$.C++实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int pre &#x3D; 0, maxAns &#x3D; nums[0];        for (const auto &amp;x: nums) &#123;            pre &#x3D; max(pre + x, x);            maxAns &#x3D; max(maxAns, pre);        &#125;        return maxAns;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:70.爬楼梯</title>
    <link href="2023/02/01/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>2023/02/01/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2023-02-01T06:48:43.000Z</published>
    <updated>2023-02-02T16:52:25.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归</li></ol><p>很明显，该问题可以用$f(x) &#x3D; f(x - 1) + f(x - 2)$并且很容易得知$f(0) &#x3D; 1;f(1) &#x3D; 1;f(2) &#x3D; 2$,但是直接写递归(<code>return climbStairs(n - 1) + climbStairs(n - 2)</code>)会导致时间超限，在这里使用「滚动数组思想」把空间复杂度优化成 $O(1)$。</p><p><img src="http://cdn.leafii.top/img/70_fig1.gif" alt="fig1" loading="lazy"></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int climbStairs(int n) &#123;        int p &#x3D; 0, q &#x3D; 0, r &#x3D; 1;        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;            p &#x3D; q;             q &#x3D; r;             r &#x3D; p + q;        &#125;        return r;    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/">https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/</a> </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning</title>
    <link href="2023/02/01/Flexible%20Job-Shop%20Scheduling%20via%20Graph%20Neural%20Network%20and%20Deep%20Reinforcement%20Learning/"/>
    <id>2023/02/01/Flexible%20Job-Shop%20Scheduling%20via%20Graph%20Neural%20Network%20and%20Deep%20Reinforcement%20Learning/</id>
    <published>2023-02-01T06:46:17.000Z</published>
    <updated>2023-02-02T16:44:38.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度"><a href="#Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度" class="headerlink" title="Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度"></a>Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>本文考虑了众所周知的灵活作业车间调度问题，并通过提出一种新颖的 DRL 方法来端到端地学习高质量的 PDR 来解决这些问题。操作选择和机器分配被组合为一个复合决策。此外，基于一种新颖的调度状态异构图表示，提出了一种基于异构图神经网络的体系结构来捕获操作和机器之间的复杂关系。</p><span id="more"></span><ul><li><strong>背景</strong></li></ul><p>本文聚焦柔性车间调度问题(FJSP)，FJSP 允许在任何机器上处理一组可选机器的操作，因此更适合处理新制造范例（例如云制造）中任务-资源关系的灵活性和多样性。</p><p>JSP本来就是NP-hard问题，FJSP问题一般使用启发式方法，为效率牺牲最优性。优先调度规则 (PDR)是一种比较知名并且实践性强的启发式方法，它根据一些优先级规则 [例如，先进先出 (FIFO)] 将作业迭代地分配给机器。与元启发式相比，PDR 直观、易于实现且计算速度非常快，使其更适合处理云制造中的问题，这些问题通常是大规模的，甚至是动态的。</p><ul><li><strong>提出问题</strong></li></ul><p>PDR调度结果远非最优。原因如下：</p><ol><li>施工过程基于优先措施是贪婪的，这可能是短视的。</li><li>决策主要基于每个步骤中符合条件的工作和机器的信息，而全局信息在很大程度上被忽略了。</li><li>目前的PDR主要是根据人类经验设计的，通常不能保证最优性，缺乏适应特定问题和情况的能力</li></ol><p>因此，在这个方向上，最近的一些工作尝试以端到端的方式使用 DRL 自动生成用于调度问题的 PDR，但他们都只关注于非柔性的JSP问题，因为要通过该方式改良FJSP问题的调度有两个重大挑战：</p><ol><li>FJSP 中的决策更加复杂，不仅有操作选择，还有机器分配</li><li>由于操作和机器之间复杂的一对多关系，调度状态可能更难使用神经网络进行编码。</li></ol><p>因此，需要研究的问题就是：</p><ol><li>如何制定调度流程以纳入机器分配</li><li>如何设计表示方案和神经架构以从原始调度状态中提取有用信息。</li></ol><ul><li><strong>解决思路</strong></li></ul><ol><li>本文提出了一种基于 PDR 的 FJSP 调度的 MDP 公式，其中一个动作是选择一个符合条件的操作-机器（O-M）对，以便可以同时做出操作选择和机器分配决策。</li><li>通过用机器节点扩展 FJSP 的析取图，本文提出了一种新颖的异构图结构来表示 MDP 状态，从而可以捕获操作和机器之间的复杂关系。此外，提出了一种两阶段图神经网络（GNN）来获得异构图中节点的特征嵌入，在此基础上使用近端策略优化（PPO）设计和训练策略网络。</li><li>与现有的基于DRL的调度方法中使用的GNN不同，本文中提出的 GNN 适用于专用于 FJSP 的异构图，它不仅捕获操作的状态，还捕获机器和 O-M 关系的状态</li></ol><ul><li><strong>实验结果</strong></li></ul><p>在合成实例和公共基准上进行了广泛的实验。结果表明，在保持高计算效率的同时，所提出的方法可以优于传统的手工 PDR，并有效地泛化到训练中未见过的更大规模的问题和公共基准。</p><p>除了方法上的新颖性外，所提出的方法还具有良好的实用价值。它的神经结构与大小无关；因此，经过训练的策略可以应用于解决不同大小的实例，而不仅仅是训练大小。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>在每次迭代过程中，调度状态首先转化为异构图结构。然后，将具有两阶段嵌入过程的 HGNN 应用于异构图，以提取操作和机器的特征嵌入，决策网络使用这些嵌入来生成动作概率分布，从中采样调度操作。</p><h4 id="MDP-Formulation"><a href="#MDP-Formulation" class="headerlink" title="MDP Formulation"></a>MDP Formulation</h4><p>调度过程：在每个决策步骤t(时间为0或操作完成时)，agent观察当前系统状态$s_t$并做出决策$a_t$,该决策分配一个未调度的操作给空闲的机器，并从当前时间开始，记为$T(t)$.然后，环境过渡到下一个决策步骤$t+1$。该过程迭代直到所有操作都被调度。</p><ul><li><p>状态（State）：在第t步的所有操作和机器的状态构成了状态$s_t$</p></li><li><p>动作（Action）：本文中的动作将操作选择和机器分配结合为一个复合决策。具体来说，一个动作$a_t \in A_t$被定义为在第t步的一个可行的O-M对$(O_{ij}, M_K)$，其中的$O_{ij}$是可行的operation，$M_k$是空闲的机器。</p></li><li><p>状态转移(Transition)：基于$s_t$和$a_t$，环境确定性的过渡到新状态$s_{t+1}$，这是操作完成的时间。在本文中，两种不同的状态由异构图的拓扑和特征来区分。</p></li><li><p>奖励(Reward)：奖励定义为部分调度在 $s_t$ 和 $s_{t+1}$ 的完工时间之差，如$r(s_t, a_t, s_{t+1}) &#x3D; C_{max}(s_t) - C_{max}(s_{t+1}))$.若折扣因子$\gamma &#x3D; 1$时，一次求解过程中的累计奖励可以被记为$G &#x3D; \sum_{t&#x3D;0}^{|O|}r(s-t, a_t,s_{t+1}) &#x3D; C_{max}(s_0) - C_{max}$.对于一个特定的问题实例，$C_{max}(s0)$ 是一个常数，这意味着最小化 $C_{max}$ 和最大化 $G$是等价的。</p></li><li><p>策略(Policy):策略 $π(a_t|s_t)$ 为每个状态 $s_t$ 定义了动作集 $A_t$ 上的概率分布。接下来，本文将设计一个 DRL 算法，将 π 参数化为神经网络，并朝着最大化预期累积奖励的方向对其进行优化。</p></li></ul><h4 id="Heterogeneous-Graph"><a href="#Heterogeneous-Graph" class="headerlink" title="Heterogeneous Graph"></a>Heterogeneous Graph</h4><p>用析取图表示FJSP调度更复杂的原因：</p><ol><li>由于多台机器处理operation，析取弧集合D会明显变得更大。所以这种密集的图很难被有效处理。</li><li>一个操作在不同兼容机器上的处理时间是不同的，很难表示。</li></ol><p>为了解决上述问题，本文通过修改析取图结构，定义了一个新颖的异构图结构$H &#x3D; (O,M,C,E)$。如图所示，操作结点集合O和合取弧集C，增加了一组机器节点M，每个节点对应一台机器$M_k$。原本的析取弧集D由O-M弧集E替换。每个元素$E_{ijk} \in E$是一个将操作结点$O_{ij}$和兼容机器节点$M_k$连接起来的无向的弧。</p><p>该异构图结构拥有以下优点：</p><ol><li>图密度显着降低。</li><li>H 中的机器节点提供了一种方便的方式来注入机器信息并提取有用的特征以区分状态中的不同机器。</li><li>处理时间 $p_{ijk}$ 可以通过简单地附加为 $O-M$ 弧 $E_{ijk}$ 的特征来轻松表示。</li></ol><p>定义异构图之后，每一个状态$s_t$可以由异构图$H_t &#x3D; (O, M, C, E_t)$表示，其中$E_t$在求解过程中动态变化。具体来说：在第t步采取一个动作$(O_{ij},M_k)$后，只保留$E_{ijk}$，去掉$O_{ij}$的其他$O-M$弧，得到$H_{t+1}$。因此，节点之间的相邻关系也会动态变化。</p><p>在每个步骤t，定义$N_t(O_{ij})$ 是操作 $O_{ij}$ 的相邻机器，$N_t(M_k)$ 是机器 $M_k$ 的相邻操作。</p><h4 id="Heterogeneous-Graph-Neural-Network"><a href="#Heterogeneous-Graph-Neural-Network" class="headerlink" title="Heterogeneous Graph Neural Network"></a>Heterogeneous Graph Neural Network</h4><p>作为组合问题中的典型，FJSP 实例具有不同的大小。要使用 DRL 学习实用的调度策略，神经架构必须能够在不同大小的状态图上运行。之前的一些工作表明GNN可以用于实现大小不可知的特性，然而它们都是对齐次图（Homogenous graph）进行处理的，在这里不可用。目前提出的HGNN都没有考虑到FJSP的异构图$H_t$，原因如下：</p><ol><li>首先，$H_t$ 中的不同节点类型具有很强的连接模式。任何机器的邻居只能是通过无向弧连接的操作，而操作可以通过有向或无向弧连接到操作和机器。</li><li>O-M 弧上的特征（即处理时间）对于解决 FJSP 非常重要。</li></ol><p>然而，现有的 HGNN 通常只关注节点特征，不考虑弧特征。</p><p>为了利用异构图结构的特性和优势，本文提出了一种为 FJSP 定制的新型 HGNN 架构，以有效地编码 $H_t$.如图所示：</p><p><img src="http://cdn.leafii.top/img/image-20230202204228094.png" alt="image-20230202204228094" loading="lazy"></p><p>所提出的方法具有两阶段嵌入过程的特点，以便将图的拓扑和数值信息（原始特征）考虑在内，并将 $H_t$ 中的节点映射到$ d$ 维嵌入。</p><p>在第一阶段，机器嵌入$ ν′<em>k \in \R^d$ 通过聚合相关信息更新，而操作嵌入 $μ′</em>{ij} \in \R^d$ 在第二阶段更新。详情如下.</p><h5 id="Machine-Node-Embedding"><a href="#Machine-Node-Embedding" class="headerlink" title="Machine Node Embedding:"></a>Machine Node Embedding:</h5><p>在 $H_t$ 中，机器 $M_k$ 的邻居是一组操作 $N_t(M_k)$，它可能对 $M_k$ 有不同的含义。例如，预计较早开始的操作可能比较晚开始的操作更重要。这促使我们考虑图形注意力网络（GAT）,它通过应用注意力机制自动学习不同节点的重要性.对于齐次图，给定具有特征 $x_i$ 的节点 $i$，GAT 首先计算 $i$ 和其一阶邻域 $N(i)$（包括 $i$ 本身）中的每个$j$ 之间的注意系数 $e_{ij}$（标量）为$e_{ij}&#x3D;LeakyReLU(a^T[W_{x_i}||W_{x_j}])$.</p><p>换句话说，$x_i$ 和 $x_j$ 首先由共享线性变换 $W$ 处理，然后连接 $(||)$ 并馈入具有权重 a 和 LeakyReLU 激活的单层前馈神经网络。然后，使用 softmax 函数对邻域内的系数进行归一化:$\alpha_{ij}&#x3D;\frac{exp(e_{ij})}{\sum_{q\in N(i)exp(e_{iq})}} \forall j\in N(i)$</p><p>最终，GAT 在 $N (i)$ 上聚合（线性变换）特征并应用非线性 $\sigma$ 来获得 $i$ 的嵌入:$x’<em>i &#x3D; \sigma(\sum</em>{j \in N(i)}\alpha_{ij}W_{x_j})$.</p><p><strong>但是</strong>原来的GAT只是针对齐次图的，没有考虑弧特征。在这里，为了满足本文的需要（即计算相邻操作对机器的重要性）.</p><ol><li>可以观察到，对于每个机器 $M_k$，只有一个$O-M$ 弧将其与相邻操作连接起来。因此，每个 $O_{ij} \in N_t(M_k)$ 的原始特征向量通过将其原始原始特征与相应 O-M 弧的原始特征连接起来扩展为 $\mu_{ijk} &#x3D;[\mu_{ij}||\lambda_{ijk}] \in \R^7$.</li><li>在这里，两个线性变换 $W^M \in \R^{d×3}$ 和 $W^O \in \R^{d × 7}$ 分别用于机器和操作节点，而不是使用共享的。</li><li>对于机器 $M_k$，注意系数 $e_{ijk}$，即每个相邻操作的重要性 $O_{ij} \in N_t(M_k)$，可以计算为:$e_{ijk} &#x3D; LeakyReLU(a^T[W^Mv_k||W^O\mu_{ijk}])$,其中$a\in \R^{2d}$。</li></ol><p>通过这种方式，来自异构节点和 O-M 弧的信息可以有效地纳入注意力计算。</p><p>上面的式子中有一件事情未被考虑：原始GAT中涉及的机器$M_k$对自身的注意力系数。这里，$e_{kk}$ 是使用机器特定权重 $W^M$ 计算的，如下所示：$e_{kk} &#x3D; LeakyReLU(a^T[W^M_{V_k}||W^M_{v_k}])$.</p><p>所有 $e_{ijk} \forall O_{ij} \in N_t(M_k)$ 与 $e_kk$ 一起使用 softmax 函数进行归一化，以获得归一化的注意力系数 $α_{ijk}$ 和 $\alpha_{kk}$。</p><p>最终，机器嵌入$v’<em>k$由融合相邻操作和自身的特征计算得到。计算$v’<em>k$的聚合函数为：$v’<em>k &#x3D; \sigma(\alpha</em>{kk}W^M</em>{v_k} + \sum</em>{O_{ij}\in N_t(M_k)}\alpha_{ijk}W^O\mu_{ijk})$</p><h5 id="Operation-Node-Embedding"><a href="#Operation-Node-Embedding" class="headerlink" title="Operation Node Embedding:"></a>Operation Node Embedding:</h5><p>本文直接使用多个MLP对每个源的信息（包括$O_{ij}$本身的特征）进行处理，将结果拼接起来，投影回d维空间作为$O_{ij}$的embedding。</p><p>具体来说，有5个MLP被定义，每一个都有d维的输出，两个 $d_h$ 维隐藏层和 ELU 激活.$O_{ij}$的embedding计算如下:</p><p>$\mu’<em>{ij}&#x3D;MLP</em>{\theta_0}(ELU[MLP_{\theta_1}(\mu_{i,j-1})||MLP_{\theta_2}(\mu_{i, j+1})||MLP_{\theta_3}(\bar{v}’<em>{ij})||MLP</em>{\theta_4(\mu_{ij})}])$</p><p>请注意，无需计算两个虚拟操作 Start 和 End 的嵌入。</p><h5 id="Stacking-and-Pooling"><a href="#Stacking-and-Pooling" class="headerlink" title="Stacking and Pooling:"></a>Stacking and Pooling:</h5><p>上面的嵌入过程可以看作是一个HGNN层，它转换每个操作的原始特征$μ_{ij}$和$ν_k$，为了增强特征提取能力，这里将结构相同但可训练参数独立的 L个HGNN层堆叠起来，以获得最终的嵌入 $μ’^{(L)}_{ij}$ 和 $ν’^{(L)} _k$。</p><p>在HGNN的L层之后，分别对得到的操作嵌入集和机器嵌入集应用均值池化。然后，将生成的两个 d 维向量连接为异构图状态 $H_t$ 的嵌入 $ht \in \R^{2d}$，如下所示：$h_t&#x3D;[\frac{1}{O}\sum_{O_{i,j\in O}\mu_{ij}^{‘(L)}}||\frac{1}{|M|}\sum_{M_{k\in M}}v’^{(L)}_k]$.</p><p>通过上述过程，一个可变大小的异构图可以转化为一个固定维度的嵌入。令 θ 为所有 HGNN 参数的集合。</p><h4 id="Decision-Making"><a href="#Decision-Making" class="headerlink" title="Decision Making"></a>Decision Making</h4><p>由于上述异构图结构和 HGNN，策略 π(at|st) 使用提取的嵌入可以简单方便地表示.</p><p>对于在 $a_t &#x3D;(O_{ij},M_k) \in  A_t$ 处的每个可行动作，在步骤 t，相应的操作、机器和状态嵌入被连接起来并送入 MLP 以获得其在状态 $s_t$ 被选择的优先级索引，如下所示：$P(a_t, s_t)&#x3D;MLP_\omega[\mu’^{(L)}<em>{ij}||v’^{(L)}</em>{k}||h_t]$</p><p>选择每个 $a_t$ 的概率是通过对所有 $P (a_t,s_t)$ 应用 softmax 来计算的:</p><p>$\pi_\omega(a_t|s_t)&#x3D;\frac{exp(P(a_t,s_t))}{\sum_{a’_t\in A_t}exp(P(a’_t,s_t))} \forall a_t \in A_t$.</p><p>在训练过程中，根据策略 $\pi_\omega$ 对动作进行采样，以进行探索。</p><p>请注意，对于神经策略，采样的额外开销通常很小，因为图形处理单元 (GPU) 能够并行采样解决方案。</p><p><img src="http://cdn.leafii.top/img/image-20230203000256621.png" alt="image-20230203000256621" loading="lazy"></p><h4 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h4><p>本文使用 PPO进行训练，它采用了 actor-critic 结构。 Actor 是策略网络 $\pi_\omega$，critic $v_\phi$ 是另一个预测状态 $s_t$ 的值 $v(s_t)$ 的网络。</p><p><img src="http://cdn.leafii.top/img/image-20230203000557428.png" alt="image-20230203000557428" loading="lazy"></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>本节显示<strong>合成</strong>和<strong>公共 FJSP 实例</strong>的实验结果，以验证所提出的方法。</p><h4 id="Experimental-Settings"><a href="#Experimental-Settings" class="headerlink" title="Experimental Settings"></a>Experimental Settings</h4><h5 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h5><p>合成数据来自[1].</p><p>两个著名的 FJSP 基准测试数据:[1] 中的十个 mk 实例 (mk01–mk10) 和 [2] 中的三组 la 实例（rdata、edata 和 vdata，每组有 40 个实例）。</p><p>在四个较小的尺寸上进行训练，并使用最大的两个（30×10 和 40×10）来测试泛化能力</p><p>因此，对这些基准测试可以进一步验证所提出的方法在推广到分布外实例时的效果。有关这些实例的更多详细信息，请参见 [6]。</p><h5 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h5><p>与四个在实践中运行良好的著名 PDR 相比，包括 FIFO、剩余操作最多 (MOR)、最短处理时间 (SPT) 和剩余工作最多 (MWKR) 。</p><p>本文还与 Google OR-Tools 进行了比较。</p><p>对于公共基准，本文还与 DRL 方法 [3] 和 [4] 和 [5] 中的两种最新遗传算法 (GA) 的结果以及 [6] 中收集的最著名解决方案进行了比较。</p><p>对于具有最大完工时间 $C_{max}$ 的每个解决方案，其与最佳解决方案（不一定是最优）的最大完工时间 $C^{BS}_{max}$ 的相对差距计算如下：</p><p>$\epsilon &#x3D; (C_{max}&#x2F;C_^{BS} - 1) \times 100% $</p><h4 id="Performance-on-Synthetic-Instances"><a href="#Performance-on-Synthetic-Instances" class="headerlink" title="Performance on Synthetic Instances"></a>Performance on Synthetic Instances</h4><p>相当稳定并收敛于所有四种训练规模:</p><p><img src="http://cdn.leafii.top/img/image-20230203002931755.png" alt="image-20230203002931755" loading="lazy"></p><ol><li>训练大小实例的评估</li><li>大型实例的泛化性能</li><li>运行时间分析</li></ol><p><img src="http://cdn.leafii.top/img/image-20230203003842530.png" loading="lazy"></p><h4 id="Performance-on-Public-Benchmarks"><a href="#Performance-on-Public-Benchmarks" class="headerlink" title="Performance on Public Benchmarks"></a>Performance on Public Benchmarks</h4><p>进一步评估经过训练的政策在传统研究中经常使用的两个公共基准上的泛化性能:</p><p><img src="http://cdn.leafii.top/img/image-20230203003828665.png" alt="image-20230203003828665" loading="lazy"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>本文提出了一种新颖的端到端 DRL 方法来为 FJSP 学习高质量的 PDR，该方法在实践中得到广泛应用，但很少被现有的基于 DRL 的方法研究。</p><p>底层 MDP 是使用集成方法制定的，该方法将操作选择和机器分配结合为一个决策。然后，提出了一种异构图结构来表示调度状态，该结构由一种新颖的 HGNN 架构处理，以便将图中的数值和拓扑信息转换为特征嵌入。在 HGNN 的基础上，设计了一个 actor-critic 架构，并使用 PPO 进行训练。</p><p>结果表明，所提出的方法以合理的效率优于基线 PDR，并且可以很好地泛化到更大尺寸和公共基准的看不见的实例。</p><p>对于<strong>未来的工作</strong>，该方法将被扩展以处理实际生产中更具挑战性的因素，例如批次、到期日和不确定性。此外，将利用 FJSP 的多最优属性 [46]（即，一个实例可以有多个最优解）来提高训练性能。还将研究与 GA 等高级搜索机制相结合的可能性。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] P. Brandimarte, “Routing and scheduling in a flexible job shop by tabu search,” Ann. Oper. Res., vol. 41, no. 3, pp. 157–183, 1993.</p><p>[2]  J. Hurink, B. Jurisch, and M. Thole, “Tabu search for the job-shop scheduling problem with multi-purpose machines,” OR Spektrum, vol. 15, no. 4, pp. 205–215, 1994.</p><p>[3] B. Han and J. Yang, “A deep reinforcement learning based solution for flexible job shop scheduling problem,” Int. J. Simul. Model., vol. 20, no. 2, pp. 375–386, 2021.</p><p>[4] R. Chen, B. Yang, S. Li, and S. Wang, “A self-learning genetic algorithm based on reinforcement learning for flexible job-shop scheduling problem,” Comput. Ind. Eng., vol. 149, 2020, Art. no. 106778. </p><p>[5] D. Rooyani and F. M. Defersha, “An efficient two-stage genetic algorithm for flexible job-shop scheduling,” IFAC-PapersOnLine, vol. 52, no. 13, pp. 2519–2524, 2019.</p><p>[6] D. Behnke and M. J. Geiger, “Test instances for the flexible job shop scheduling problem with work centers,” Helmut Schmidt Univ., Hamburg, Germany, Tech. Rep. RR-12-01-01, 2012.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度&quot;&gt;&lt;a href=&quot;#Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度&quot; class=&quot;headerlink&quot; title=&quot;Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度&quot;&gt;&lt;/a&gt;Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度&lt;/h2&gt;&lt;h3 id=&quot;解决的问题&quot;&gt;&lt;a href=&quot;#解决的问题&quot; class=&quot;headerlink&quot; title=&quot;解决的问题&quot;&gt;&lt;/a&gt;解决的问题&lt;/h3&gt;&lt;p&gt;本文考虑了众所周知的灵活作业车间调度问题，并通过提出一种新颖的 DRL 方法来端到端地学习高质量的 PDR 来解决这些问题。操作选择和机器分配被组合为一个复合决策。此外，基于一种新颖的调度状态异构图表示，提出了一种基于异构图神经网络的体系结构来捕获操作和机器之间的复杂关系。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:344.反转字符串</title>
    <link href="2023/02/01/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>2023/02/01/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-01-31T16:46:29.000Z</published>
    <updated>2023-01-31T16:58:56.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>双指针从最左边到最右边遍历交换元素，直至左指针索引值大于右指针索引值。C++实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int n &#x3D; s.size();&#x2F;&#x2F;获取数组长度        int left &#x3D; 0, right &#x3D; n - 1;        char temp &#x3D; 0;        while(left &lt; right) &#123;            temp &#x3D; s[left];            s[left] &#x3D; s[right];            s[right] &#x3D; temp;&#x2F;&#x2F;交换操作            left++;            right--; &#x2F;&#x2F;指针移动        &#125;        &#x2F;&#x2F;最后的s即为结果，函数返回类型为void所以无需返回值    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 &lt;code&gt;s&lt;/code&gt; 的形式给出。&lt;/p&gt;
&lt;p&gt;不要给另外的数组分配额外的空间，你必须&lt;strong&gt;原地修改输入数组&lt;/strong&gt;、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:42.接雨水</title>
    <link href="2023/01/30/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>2023/01/30/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2023-01-29T19:14:51.000Z</published>
    <updated>2023-01-29T19:31:57.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/rainwatertrap.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [4,2,0,3,2,5]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>创建两个长度为n的数组leftMax和rightMax.leftMax[i]表示下标i以及其左边的位置中，height的最大高度，rightMax[i]表示下标i及其右边的位置中，height的最大高度。其中leftMax[0] &#x3D; height[0], rightMax[n - 1] &#x3D; height[n - 1].</p><ul><li>当1 &lt;&#x3D; i &lt;&#x3D; n - 1时， leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);</li><li>当0 &lt;&#x3D; i &lt;&#x3D; n - 2时，rightMax[i] &#x3D; max(rightMax[i + 1], height[i]).</li></ul><p>因此可以正向遍历数组height得到leftMax的每个元素值，反向遍历数组height得到rightMax的每个元素值。</p><p>在得到数组leftMax和rightMax的每个元素值后，对于0&lt;&#x3D;i&lt;n，下标i处能接的雨水量等于min(leftMax[i], rightMax[i]) - height[i].对每个下标i进行遍历，将结果进行累加。</p><p><img src="http://cdn.leafii.top/img/1.png" alt="fig1" loading="lazy"></p><p>C++代码实现如下： </p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int n &#x3D; height.size();        if (n &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        vector&lt;int&gt; leftMax(n);        leftMax[0] &#x3D; height[0];        for (int i &#x3D; 1; i &lt; n; ++i) &#123;            leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);        &#125;        vector&lt;int&gt; rightMax(n);        rightMax[n - 1] &#x3D; height[n - 1];        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; --i) &#123;            rightMax[i] &#x3D; max(rightMax[i + 1], height[i]);        &#125;        int ans &#x3D; 0;        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            ans +&#x3D; min(leftMax[i], rightMax[i]) - height[i];        &#125;        return ans;    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/">https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:46.全排列</title>
    <link href="2023/01/29/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>2023/01/29/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2023-01-29T06:23:57.000Z</published>
    <updated>2023-01-29T06:47:10.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1]输出：[[0,1],[1,0]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1]输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>回溯</li></ol><p>用回溯法模拟全排列的过程。</p><p>定义一个递归函数<code>backtrack(first, output)</code>表示从左往右填到第first个位置，当前排列为output，所以有以下两种情况：</p><ul><li>若<code>first = n</code>，则说明n个位置已经填完了，找到了一个可行的解，此时需要把output放入答案数组中，递归结束。</li><li>如果<code>first &lt; n</code>，我们需要考虑在第first个位置上我们需要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组vis来标记已经填过的数，如果有数未被标记，就尝试填入，并将其标记，然后继续调用<code>backtrack(first + 1, output)</code>，回溯时要撤销之前的标记以及已经填入的数字，但是标记数组增加了算法的空间复杂度。</li></ul><p>我们将题目给定的n个数的数组nums划分为左右两个部分，左边为已经填过的数，右边是待填的数，在回溯时只需要动态维护这个数组即可。</p><p>具体的来说，如果我们已经填到第first个位置，那么nums数组中<code>[0, first - 1]</code>是已经填过的数的集合，<code>[first, n - 1]</code>是待填数的集合。我们肯定是用<code>[first, n - 1]</code>的数去填第first个数，假设待填的数的下标为i，那么填完以后我们将第i个数和第first个数交换，即能使得在第first+1个数的时候nums数组的<code>[0, first]</code>部分为已填过的数，<code>[first + 1, n - 1]</code>为待填的数，回溯的时候交换回来就可以完成撤销操作。</p><p>举个简单的例子，假设我们有 <code>[2,5,8,9,10]</code>这 5 个数要填入，已经填到第 3 个位置，已经填了 <code>[8, 9]</code> 两个数，那么这个数组目前为 <code>[8, 9|2, 5, 10]</code> 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10 这个数，为了维护数组，我们将 2 和 10 交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填 <code>[8, 9, 10|2, 5]</code> 。C++实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len) &#123;        &#x2F;&#x2F;所有数都填完了        if (first &#x3D;&#x3D; len) &#123;            res.emplace_back(output);             &#x2F;&#x2F;和push_back()类似，emplace_back() 用来给容器中添加元素。            &#x2F;&#x2F;在容器尾部添加一个元素，调用构造函数原地构造，不需要触发拷贝构造和移动构造。因此比push_back()更加高效。            return;        &#125;        for (int i &#x3D; first; i &lt; len; ++i) &#123;            &#x2F;&#x2F;动态维护数组            swap(output[i], output[first]); &#x2F;&#x2F;swap用于交换两个int型变量的值            &#x2F;&#x2F;继续递归填下一个数            backtrack(res, output, first + 1, len);            &#x2F;&#x2F;撤销操作            swap(output[i], output[first]);        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt; &gt; res;        backtrack(res, nums, 0, (int)nums.size());        return res;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个不含重复数字的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其 &lt;em&gt;所有可能的全排列&lt;/em&gt; 。你可以 &lt;strong&gt;按任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
