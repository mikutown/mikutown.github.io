<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-02-26T05:56:06.765Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode203.移除链表元素</title>
    <link href="2023/02/26/leetcode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>2023/02/26/leetcode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</id>
    <published>2023-02-26T05:43:26.000Z</published>
    <updated>2023-02-26T05:56:06.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/removelinked-list.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6输出：[1,2,3,4,5]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [], val &#x3D; 1输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [7,7,7,7], val &#x3D; 7输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>虚拟头节点法：</li></ol><p>若使用常规思路，在移除节点有两种情况：</p><ul><li><p>非头节点的移除：直接讲被删除节点的前一个节点同被删除节点的后一个节点连接，然后删除当前的被删除节点；</p></li><li><p>头节点的移除：新建一个节点指向头节点，令头节点等于头节点的后继节点，然后删除刚才指向头节点的新建节点。</p></li></ul><p>为了防止需要写两个逻辑判断到底怎么删除节点，在这里直接使用一个虚拟节点，他的后继节点指向头节点，此时本来需要被特殊处理的头节点也可以按照非头节点的移除方法进行移除了，在循环的最后删除虚拟头节点，返回虚拟头节点的后继节点（即真实头节点）。C++代码实现思路如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* visualHead &#x3D; new ListNode(0); &#x2F;&#x2F; 新建虚拟头节点        visualHead-&gt;next &#x3D; head;        ListNode* cur &#x3D; visualHead; &#x2F;&#x2F; cur指现在要处理的节点，默认指向虚拟头节点        while (cur-&gt;next!&#x3D;NULL) &#123; &#x2F;&#x2F; 开始循环            if (cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123; &#x2F;&#x2F; 如果值匹配，则进行删除                ListNode* tmp &#x3D; cur-&gt;next;                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123; &#x2F;&#x2F; 否则当前指针更新为它的next指针指向的元素                cur &#x3D; cur-&gt;next;            &#125;        &#125;        head &#x3D; visualHead-&gt;next; &#x2F;&#x2F; 得到删除对应元素之后的头节点        delete visualHead; &#x2F;&#x2F; 删除虚拟头节点，以降低空间复杂度        return head; &#x2F;&#x2F; 返回头节点，算法结束    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; 和一个整数 &lt;code&gt;val&lt;/code&gt; ，请你删除链表中所有满足 &lt;code&gt;Node.val == val&lt;/code&gt; 的节点，并返回 &lt;strong&gt;新的头节点&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode330.按要求补齐数组</title>
    <link href="2023/02/23/leetcode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/"/>
    <id>2023/02/23/leetcode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/</id>
    <published>2023-02-23T07:09:33.000Z</published>
    <updated>2023-02-23T07:26:01.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个已排序的正整数数组 <code>nums</code> <em>，</em>和一个正整数 <code>n</code> <em>。</em>从 <code>[1, n]</code> 区间内选取任意个数字补充到 nums 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 nums 中某几个数字的和来表示。</p><p>请返回 <em>满足上述要求的最少需要补充的数字个数</em> 。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3], n &#x3D; 6输出: 1 解释:根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。所以我们最少需要添加一个数字。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,5,10], n &#x3D; 20输出: 2解释: 我们需要添加 [2,4]。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,2,2], n &#x3D; 5输出: 0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>升序排列</strong></li><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>贪心算法</li></ol><p>题目使用的是贪心算法。贪心算法的基本思想是，在每一步选择中都选择当前状态下最优的选择，以求得最终的全局最优解。</p><p>对于这道题，我们的贪心策略是在已经被覆盖的区间内，选择尽可能靠右的数字来扩展区间，这样可以让被覆盖的区间尽可能的大，从而让需要添加的数字的数量尽可能的少。</p><p>当遍历到一个数时，如果这个数小于等于 <code>covered + 1</code>，那么它可以被当前的区间所覆盖，因此可以将它加入到被覆盖的区间内，更新 <code>covered</code> 的值(<code>covered += nums[i]</code>)。如果这个数大于 <code>covered + 1</code>，那么当前的区间无法覆盖它，因此需要添加一个新的数字，使得被覆盖的区间能够扩展到这个数，更新 <code>covered</code> 的值(<code>covered += covered + 1</code>)。</p><p>这个贪心策略的正确性可以通过反证法来证明：假设存在一个更优的解，使得需要添加的数字的数量比当前算法得到的解更少。那么这个更优的解必然包含一个数字 x，它是我们在当前算法中添加的数字。如果将 x 从更优的解中删除，那么这个解就会变成一个覆盖范围更小、需要添加的数字数量相同的解，与我们的假设矛盾。因此，当前算法得到的解就是最优解，贪心策略是正确的。</p><p>可以先求解所有需要被插入的数字，再返回拥有所有被插入数字的数组的长度，实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;        vector&lt;int&gt; patches; &#x2F;&#x2F; 用于保存需要插入的数字        long long int covered &#x3D; 0; &#x2F;&#x2F;用longlong类型存储当前已经被覆盖的数的范围        int i &#x3D; 0; &#x2F;&#x2F;nums数组的下标        while (covered &lt; n) &#123; &#x2F;&#x2F; 只要还没有覆盖到n，就需要添加数字            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;                &#x2F;&#x2F; 如果nums[i]小于等于当前已经被覆盖的数的下一个数(covered + 1)                &#x2F;&#x2F; 那么就可以将nums[i]加入到被覆盖的范围内                covered +&#x3D; nums[i];                i++;            &#125; else &#123;                &#x2F;&#x2F; 如果nums[i]大于covered + 1, 那么就需要添加一个新的数字                int patch &#x3D; covered + 1;                covered +&#x3D; patch;                patches.push_back(patch);            &#125;        &#125;        return patches.size();    &#125;&#125;;</code></pre><p>因为题目并没有要求存储被插入的数组，为了更低的空间占用，可以不存储要插入的数字，直接对计数器<code>count</code>自加一：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;        long long int covered &#x3D; 0;  &#x2F;&#x2F; 用 long long 类型存储当前已经被覆盖的数的范围        int count &#x3D; 0;  &#x2F;&#x2F; 记录需要添加的数字的数量        int i &#x3D; 0;  &#x2F;&#x2F; nums 数组的下标        while (covered &lt; n) &#123;  &#x2F;&#x2F; 只要还没有覆盖到 n，就需要添加数字            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;                &#x2F;&#x2F; 如果 nums[i] 小于等于当前已经被覆盖的数的下一个数（covered + 1）                &#x2F;&#x2F; 那么就可以将 nums[i] 加入到被覆盖的范围内                covered +&#x3D; nums[i];                i++;            &#125; else &#123;                &#x2F;&#x2F; 如果 nums[i] 大于 covered + 1，那么就需要添加一个新的数字                covered +&#x3D; covered + 1;                count++;            &#125;        &#125;        return count;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个已排序的正整数数组 &lt;code&gt;nums&lt;/code&gt; &lt;em&gt;，&lt;/em&gt;和一个正整数 &lt;code&gt;n&lt;/code&gt; &lt;em&gt;。&lt;/em&gt;从 &lt;code&gt;[1, n]&lt;/code&gt; 区间内选取任意个数字补充到 nums 中，使得 &lt;code&gt;[1, n]&lt;/code&gt; 区间内的任何数字都可以用 nums 中某几个数字的和来表示。&lt;/p&gt;
&lt;p&gt;请返回 &lt;em&gt;满足上述要求的最少需要补充的数字个数&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode435.无重叠区间</title>
    <link href="2023/02/22/leetcode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <id>2023/02/22/leetcode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</id>
    <published>2023-02-22T02:43:40.000Z</published>
    <updated>2023-02-22T02:52:22.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p><span id="more"></span> <p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: intervals &#x3D; [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 105</code></li><li><code>intervals[i].length == 2</code></li><li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><p>首先按照区间的结束位置从小到大排序，然后从前往后遍历所有区间，若当前区间和前面的区间不重叠，则保留当前区间，继续向后遍历；否则就舍弃当前区间，再继续向后遍历。最后返回被舍弃的区间数即可。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        int n &#x3D; intervals.size();        if (n &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        &#x2F;&#x2F; 按照区间的结束位置从小到大排序        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;            return a[1] &lt; b[1];        &#125;);        int cnt &#x3D; 1;  &#x2F;&#x2F; 不重叠区间的个数，初始值为1        int end &#x3D; intervals[0][1];  &#x2F;&#x2F; 当前不重叠区间的结束位置，初始值为第一个区间的结束位置        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (intervals[i][0] &gt;&#x3D; end) &#123;  &#x2F;&#x2F; 如果当前区间的起始位置大于等于当前不重叠区间的结束位置                cnt++;  &#x2F;&#x2F; 将不重叠区间的个数加1                end &#x3D; intervals[i][1];  &#x2F;&#x2F; 更新当前不重叠区间的结束位置            &#125;            &#x2F;&#x2F; 如果当前区间的起始位置小于当前不重叠区间的结束位置，说明当前区间与前面的区间重叠了，不能选            &#x2F;&#x2F; 不需要执行任何操作，直接跳过        &#125;        return n - cnt;  &#x2F;&#x2F; 总区间个数减去不重叠区间的个数，即为需要去除的重叠区间的最小个数    &#125;&#125;;</code></pre><p>注：在sort函数中第三个参数为匿名函数，其中的参数是数组，因此：</p><blockquote><p>在排序算法中，通常需要交换数组或容器中的元素位置来实现排序的目的。如果直接将数组或容器作为参数传递给比较函数，那么在函数内部交换元素位置时，就需要复制整个数组或容器，这样会造成不必要的开销。</p><p>因此，通常使用指向数组或容器中元素的指针或引用类型作为比较函数的参数，这样在交换元素位置时只需要交换指针或引用，而不需要复制整个数组或容器。这样可以减小开销，提高效率。</p><p>在本题中，使用 <code>vector&lt;int&gt;&amp;</code> 类型的引用作为比较函数的参数，可以避免复制整个二维向量，同时也可以保证比较函数的参数类型与 STL 中的排序算法所需的参数类型相同，方便函数间的传递和调用。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个区间的集合 &lt;code&gt;intervals&lt;/code&gt; ，其中 &lt;code&gt;intervals[i] = [starti, endi]&lt;/code&gt; 。返回 &lt;em&gt;需要移除区间的最小数量，使剩余区间互不重叠&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode45.跳跃游戏II</title>
    <link href="2023/02/21/leetcode45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
    <id>2023/02/21/leetcode45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</id>
    <published>2023-02-21T06:38:37.000Z</published>
    <updated>2023-02-21T06:43:08.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [2,3,0,1,4]输出: 2</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li>题目保证可以到达 <code>nums[n-1]</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>贪心算法</li></ol><p>算法思路是：遍历数组，用变量 <code>max_pos</code> 记录当前能够到达的最远位置，用变量 <code>end_pos</code> 记录当前步数下能够到达的最远位置，如果遍历到 <code>end_pos</code>，则更新 <code>end_pos</code> 为 <code>max_pos</code>，并将步数加 1。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n &#x3D;&#x3D; 1) return 0; &#x2F;&#x2F; 如果数组只有一个元素，返回 0        int steps &#x3D; 0, max_pos &#x3D; 0, end_pos &#x3D; 0;        &#x2F;&#x2F; steps：跳跃的步数，max_pos：当前能够到达的最远位置，end_pos：当前步数下能够到达的最远位置        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;            &#x2F;&#x2F; 遍历数组，到达 n - 1 时不需要再跳跃，因为已经到达了终点            max_pos &#x3D; max(max_pos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远位置            if (i &#x3D;&#x3D; end_pos) &#123; &#x2F;&#x2F; 如果到达了当前步数下能够到达的最远位置，需要增加步数                end_pos &#x3D; max_pos; &#x2F;&#x2F; 更新当前步数下能够到达的最远位置                steps++; &#x2F;&#x2F; 增加步数            &#125;        &#125;        return steps; &#x2F;&#x2F; 返回跳跃的步数    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;0 索引&lt;/strong&gt;整数数组 &lt;code&gt;nums&lt;/code&gt;。初始位置为 &lt;code&gt;nums[0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每个元素 &lt;code&gt;nums[i]&lt;/code&gt; 表示从索引 &lt;code&gt;i&lt;/code&gt; 向前跳转的最大长度。换句话说，如果你在 &lt;code&gt;nums[i]&lt;/code&gt; 处，你可以跳转到任意 &lt;code&gt;nums[i + j]&lt;/code&gt; 处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= j &amp;lt;= nums[i]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;i + j &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回到达 &lt;code&gt;nums[n - 1]&lt;/code&gt; 的最小跳跃次数。生成的测试用例可以到达 &lt;code&gt;nums[n - 1]&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode860.柠檬水找零</title>
    <link href="2023/02/20/leetcode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <id>2023/02/20/leetcode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</id>
    <published>2023-02-20T08:12:25.000Z</published>
    <updated>2023-02-20T08:53:43.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：bills &#x3D; [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：bills &#x3D; [5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bills.length &lt;= 105</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路</li></ol><p>使用一个大小为2的数组count存储5元纸币和10元纸币的数量，接着对数组bills进行遍历，当满足条件时将对应的纸币数量进行加减，若成功遍历整个数组，则说明可以找零(<code>return true</code>)，否则无法找零(<code>return false</code>)。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;        vector&lt;int&gt; count(2,0);        for (int i &#x3D; 0; i &lt; bills.size(); i++) &#123;            if (bills[i] &#x3D;&#x3D; 5) &#123;                count[0]++;            &#125;            else if (bills[i] &#x3D;&#x3D; 10) &#123;                if (count[0] !&#x3D; 0) &#123;                    count[0]--;                    count[1]++;                &#125;                else return false;            &#125;            else if (bills[i] &#x3D;&#x3D; 20)&#123;                &#x2F;&#x2F;20 usd&#39;s situation                if (count[1] &gt; 0 &amp;&amp; count[0] &gt; 0) &#123;                    count[0]--;                    count[1]--;                &#125;                else if (count[0] &gt;&#x3D; 3) &#123;                    count[0] -&#x3D; 3;                &#125;                else return false;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 &lt;code&gt;5&lt;/code&gt; 美元。顾客排队购买你的产品，（按账单 &lt;code&gt;bills&lt;/code&gt; 支付的顺序）一次购买一杯。&lt;/p&gt;
&lt;p&gt;每位顾客只买一杯柠檬水，然后向你付 &lt;code&gt;5&lt;/code&gt; 美元、&lt;code&gt;10&lt;/code&gt; 美元或 &lt;code&gt;20&lt;/code&gt; 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 &lt;code&gt;5&lt;/code&gt; 美元。&lt;/p&gt;
&lt;p&gt;注意，一开始你手头没有任何零钱。&lt;/p&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;bills&lt;/code&gt; ，其中 &lt;code&gt;bills[i]&lt;/code&gt; 是第 &lt;code&gt;i&lt;/code&gt; 位顾客付的账。如果你能给每位顾客正确找零，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode455.分发饼干</title>
    <link href="2023/02/19/leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <id>2023/02/19/leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</id>
    <published>2023-02-19T05:35:55.000Z</published>
    <updated>2023-02-19T05:58:44.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><span id="more"></span> <p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路</li></ol><p>对两个数组进行排序，然后使用双层for循环进行贪心的遍历查找；C++实现代码如下，但是显然还有优化空间。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(), g.end());        sort(s.begin(), s.end()); &#x2F;&#x2F;排列数组        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; g.size(); i++) &#123;            for (int j &#x3D; 0; j &lt; s.size(); j++) &#123;                if (s[j] &gt;&#x3D; g[i]) &#123;                    &#x2F;&#x2F; 如果满足条件，则result++,且修改s中的数值。                    &#x2F;&#x2F; g中的无需修改，因为循环会继续                    result++;                    s[j] &#x3D; -1;                    break;                &#125;            &#125;        &#125;        return result;         &#125;&#125;;</code></pre><ol start="2"><li>使用双指针优化刚才的双层for循环，C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(), g.end());        sort(s.begin(), s.end()); &#x2F;&#x2F;排列数组        int result &#x3D; 0;        int i &#x3D; 0, j &#x3D; 0;        while (i &lt; g.size() &amp;&amp; j &lt; s.size()) &#123;            if (s[j] &gt;&#x3D; g[i]) &#123;                result++;                i++;                j++;                        &#125;            else j++;        &#125;        return result;         &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。&lt;/p&gt;
&lt;p&gt;对每个孩子 &lt;code&gt;i&lt;/code&gt;，都有一个胃口值 &lt;code&gt;g[i]&lt;/code&gt;，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 &lt;code&gt;j&lt;/code&gt;，都有一个尺寸 &lt;code&gt;s[j]&lt;/code&gt; 。如果 &lt;code&gt;s[j] &amp;gt;= g[i]&lt;/code&gt;，我们可以将这个饼干 &lt;code&gt;j&lt;/code&gt; 分配给孩子 &lt;code&gt;i&lt;/code&gt; ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode135.分发糖果</title>
    <link href="2023/02/17/leetcode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <id>2023/02/17/leetcode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</id>
    <published>2023-02-17T06:45:58.000Z</published>
    <updated>2023-02-17T06:49:29.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：ratings &#x3D; [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：ratings &#x3D; [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>常规思路</li></ol><p>首先新建一个数组candies，它代表每个人能分得的糖果数，接下来进行两次遍历：第一次从左向右遍历，确保右边评分较高的小孩获得更多的糖果，第二次从右向左遍历，确保左边评分较高的小孩获得更多的糖果。代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        int n &#x3D; ratings.size();        vector&lt;int&gt; candies(n, 1);              &#x2F;&#x2F; 从左往右扫描，保证右边评分高的孩子分到更多的糖果        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (ratings[i] &gt; ratings[i - 1]) &#123;                candies[i] &#x3D; candies[i - 1] + 1;            &#125;        &#125;              &#x2F;&#x2F; 从右往左扫描，保证左边评分高的孩子分到更多的糖果        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;            if (ratings[i] &gt; ratings[i + 1]) &#123;                candies[i] &#x3D; max(candies[i], candies[i + 1] + 1);            &#125;                    &#125;        &#x2F;&#x2F; 计算糖果总数        int result &#x3D; 0;        for (int item: candies) &#123;            result +&#x3D; item;        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 个孩子站成一排。给你一个整数数组 &lt;code&gt;ratings&lt;/code&gt; 表示每个孩子的评分。&lt;/p&gt;
&lt;p&gt;你需要按照以下要求，给这些孩子分发糖果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个孩子至少分配到 &lt;code&gt;1&lt;/code&gt; 个糖果。&lt;/li&gt;
&lt;li&gt;相邻两个孩子评分更高的孩子会获得更多的糖果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请你给每个孩子分发糖果，计算并返回需要准备的 &lt;strong&gt;最少糖果数目&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode122.买卖股票的最佳时机II</title>
    <link href="2023/02/16/leetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>2023/02/16/leetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</id>
    <published>2023-02-16T08:36:11.000Z</published>
    <updated>2023-02-16T08:44:30.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。     总利润为 4 + 3 &#x3D; 7 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     总利润为 4 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li><p>使用贪心法</p><p>为什么要使用贪心法？因为题目明确暗示了：“你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。”</p><p>因此解题思路如下：首先定义一个整形变量result用于存储结果，接着从左向右遍历数组price,若<code>price[i] &lt; price[i+1]</code>，则说明第i天的价格低于第i+1天的价格，此时可以在第i天购买股票然后在第i+1天卖出，将卖出的价格减去前一天买入的价格的差值加到result中，然后继续向右遍历，直至遍历结束，返回result.</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n &#x3D; prices.size();        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;            int j &#x3D; i + 1;            if (prices[j] &gt; prices[i]) &#123;                result &#x3D; result - prices[i] + prices[j];            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><p>虽然走了一些弯路，但是还是做出来了，所以… 稍微得瑟一下：</p><p><img src="http://cdn.leafii.top/img/image-20230216164402662.png" alt="image-20230216164402662" loading="lazy"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;prices&lt;/code&gt; ，其中 &lt;code&gt;prices[i]&lt;/code&gt; 表示某支股票第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;在每一天，你可以决定是否购买和&amp;#x2F;或出售股票。你在任何时候 &lt;strong&gt;最多&lt;/strong&gt; 只能持有 &lt;strong&gt;一股&lt;/strong&gt; 股票。你也可以先购买，然后在 &lt;strong&gt;同一天&lt;/strong&gt; 出售。&lt;/p&gt;
&lt;p&gt;返回 &lt;em&gt;你能获得的 &lt;strong&gt;最大&lt;/strong&gt; 利润&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode55.跳跃游戏</title>
    <link href="2023/02/15/leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>2023/02/15/leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2023-02-15T10:21:20.000Z</published>
    <updated>2023-02-15T10:45:13.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>利用栈（<strong>超时</strong>）</li></ol><p>将能到达的数组元素推进栈，模拟树的操作，但是会超时。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int len &#x3D; nums.size();        if (len &gt; 1 &amp;&amp; nums[0] &#x3D;&#x3D; 0) return false;        if (len &#x3D;&#x3D; 1) return true;        stack&lt;int&gt; s; &#x2F;&#x2F; 定义一个栈        int index &#x3D; 0;        if (nums[index] &gt; len) return true;        s.push(index);        while(!s.empty()) &#123;            int temp_index &#x3D; s.top();            int temp_num &#x3D; nums[temp_index];            s.pop();            for (int i &#x3D; 1; i &lt;&#x3D; temp_num; i++) &#123;                if (temp_index + i &#x3D;&#x3D; len - 1) return true;                if (nums[temp_index + i] &gt;&#x3D; (len - (temp_index + i))) return true;                if (nums[temp_index + i] !&#x3D; 0) s.push(temp_index + i);            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><p>用chatGPT分析超时的原因：</p><blockquote><p>您的代码的时间复杂度为 O(2^n)，其中 n 是数组的长度，因为在每个位置都可以有两个选择：跳或不跳，总共有 2^n 种可能的路径。这样的时间复杂度是无法通过本题的。</p><p>此外，您使用了栈来存储待搜索的位置，但这样的做法并不高效。因为每个位置最多只需要被遍历一次，而使用栈会重复遍历一些位置，导致时间复杂度进一步增加。</p></blockquote><ol start="2"><li>使用贪心算法</li></ol><p>使用贪心算法，从左到右遍历数组，用一个变量来维护能够到达的最远距离，如果当前位置在这个最远距离之内，那么更新最远距离。如果遍历结束后最远距离大于等于数组的最后一个位置，那么就说明可以到达最后一个位置，否则就无法到达。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        int maxPos &#x3D; 0; &#x2F;&#x2F; 当前能到达的最远距离        for (int i &#x3D; 0; i &lt; n; i++) &#123;            if (i &gt; maxPos) return false; &#x2F;&#x2F; 如果当前位置无法到达，则返回false            maxPos &#x3D; max(maxPos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远距离            if (maxPos &gt;&#x3D; n - 1) return true; &#x2F;&#x2F; 如果能够到达最后一个位置，返回true        &#125;        return false;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个下标。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode101.对称二叉树</title>
    <link href="2023/02/14/leetcode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>2023/02/14/leetcode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-02-14T07:18:47.000Z</published>
    <updated>2023-02-14T07:39:03.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/symtree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,4,4,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/symtree2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,null,3,null,3]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路（<strong>无法通过</strong>）：</li></ol><p>本来是想直接通过中序遍历获得一个数组，然后从数组的两端向中间进行判断，最后样例通过数为192&#x2F;199，原因是如果输入为<code>[1,2,2,2,null,2]</code>时，中序遍历得到的数组是对称的，但是实际上这个二叉树不是对称的。因此该思路被我放弃了。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F; &#x2F;&#x2F; 3241423 中序遍历 先左再中间最后右子树class Solution &#123;public:    void Middle_order_traversal(TreeNode* rootNode, vector&lt;int&gt;&amp; rst) &#123;        if (rootNode) &#123;            Middle_order_traversal(rootNode -&gt; left, rst);            rst.push_back(rootNode -&gt; val);            Middle_order_traversal(rootNode -&gt; right, rst);        &#125;        else &#123;            rst.push_back(-1);        &#125;    &#125;    bool isSymmetric(TreeNode* root) &#123;        vector&lt;int&gt; rst;        Middle_order_traversal(root, rst);        if (rst.size()%2&#x3D;&#x3D;0) &#123;            return false;        &#125;        int left &#x3D; 0, right &#x3D; rst.size() - 1;        while(left &lt; right) &#123;            if (rst[left] !&#x3D; rst[right]) &#123;                return false;            &#125;            left++;            right--;        &#125;        return true;    &#125;&#125;;</code></pre><ol start="2"><li>使用递归：</li></ol><p>在对root进行判断之后，就使用一个辅助函数对root的左子树和右子树进行判断，判断完成后分别对左子树的左子树和右子树的右子树；左子树的右子树以及右子树的左子树进行判断，两个判断结果进行与运算，递归得到最终结果。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若根节点为空，则返回true        return isSymmetricHelper(root-&gt;left, root-&gt;right);    &#125;    bool isSymmetricHelper(TreeNode* left, TreeNode* right) &#123;        if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若左右都为空，则返回true      &#x2F;&#x2F; if ((left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) || (left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL)) return false; &#x2F;&#x2F; 左右子树一个空一个不空，返回false (下面这行更简练)        if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;若左右节点有一个不为空，则返回false        if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F;若左右节点的值不相等，则返回false        &#x2F;&#x2F;递归检查左右子树是否对称        return isSymmetricHelper(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetricHelper(left-&gt;right, right-&gt;left);    &#125;&#125;;</code></pre><ol start="3"><li>使用迭代</li></ol><p>该解决方案使用队列来存储树的节点，首先将左子树和右子树的根节点加入队列中。然后在循环中，每次取出队列的头两个节点，并比较它们是否对称，如果不对称则返回false。如果对称，则将左节点的左子树节点和右节点的右子树节点加入队列，再将左节点的右子树节点和右节点的左子树节点加入队列。如果队列为空，则说明树是对称的，返回true。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;节点为空，返回true        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 定义一个队列存储节点        q.push(root-&gt;left);        q.push(root-&gt;right);        while (!q.empty()) &#123;            TreeNode* left &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为左节点            TreeNode* right &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为右节点            if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) continue; &#x2F;&#x2F;如果左右节点都为空，则继续迭代            if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;左右节点只有一个不为空，直接返回false            if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F; 左右节点值不等，直接返回false            q.push(left-&gt;left);            q.push(right-&gt;right);            q.push(left-&gt;right);            q.push(right-&gt;left); &#x2F;&#x2F; 注意push的顺序！！！        &#125;         return true; &#x2F;&#x2F;若队列为空，则说明该二叉树是对称的。    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ， 检查它是否轴对称。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode100.相同的树</title>
    <link href="2023/02/13/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>2023/02/13/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</id>
    <published>2023-02-13T07:14:04.000Z</published>
    <updated>2023-02-13T07:22:47.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：p &#x3D; [1,2,3], q &#x3D; [1,2,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/ex2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：p &#x3D; [1,2], q &#x3D; [1,null,2]输出：false</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/ex3.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：p &#x3D; [1,2,1], q &#x3D; [1,1,2]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><p>题目要求判断两棵树是否完全相同。</p><p>我们可以使用递归的方法，递归判断两棵树的根节点是否相同，以及它们的左子树和右子树是否相同。</p><p>如果两棵树都为空，则返回 true。如果有一棵树为空，另一棵树不为空，则返回 false。如果两棵树的根节点的值不相等，则返回 false。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 递归函数，判断两棵树是否相同    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        &#x2F;&#x2F; 如果两棵树都为空，则返回 true        if (!p &amp;&amp; !q) return true;        &#x2F;&#x2F; 如果有一棵树为空，另一棵树不为空，则返回 false        if (!p || !q) return false;        &#x2F;&#x2F; 如果两棵树的根节点的值不相等，则返回 false        if (p-&gt;val !&#x3D; q-&gt;val) return false;        &#x2F;&#x2F; 递归判断两棵树的左子树和右子树是否相同        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);    &#125;&#125;;</code></pre><p>可以将代码简化为：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        &#x2F;&#x2F; 如果两棵树都为空或者都不为空且值相等，则继续递归        if (!p &amp;&amp; !q) return true;        if (p &amp;&amp; q &amp;&amp; p-&gt;val &#x3D;&#x3D; q-&gt;val)            return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);        &#x2F;&#x2F; 否则，返回 false        return false;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两棵二叉树的根节点 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; ，编写一个函数来检验这两棵树是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:76.最小覆盖子串</title>
    <link href="2023/02/09/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <id>2023/02/09/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</id>
    <published>2023-02-08T18:10:05.000Z</published>
    <updated>2023-02-10T10:57:24.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;输出：&quot;BANC&quot;解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#39;A&#39;、&#39;B&#39; 和 &#39;C&#39;。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;输出：&quot;a&quot;解释：整个字符串 s 是最小覆盖子串。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;输出: &quot;&quot;解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</code></pre><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>滑动窗口</li></ol><p>一个常见的解决方案是使用双指针法和滑动窗口技巧，并利用一个哈希表来维护字符串 <code>t</code> 中字符的出现次数。</p><p>我们用两个指针分别指向当前枚举的子串的左端点和右端点，同时用一个计数器维护当前子串是否已经包含了字符串 <code>t</code> 中的所有字符。</p><p>每当右指针移动到一个字符时，如果该字符在字符串 <code>t</code> 中出现过，则将哈希表中该字符的计数器减一，同时如果该字符的计数器减一后不再为 0，则将计数器减一，表示该字符已经被包含在当前子串中了。</p><p>当计数器变成 0 时，说明当前子串已经包含了字符串 <code>t</code> 中的所有字符，此时开始移动左指针，直到该子串不再包含字符串 <code>t</code> 中的所有字符，此时计数器再次变成非 0 的值，表示当前子串不再完整包含字符串 <code>t</code>。</p><p>在整个过程中，每当移动左指针时，同时记录当前子串的长度是否比之前记录的子串长度更短，如果是，则将当前子串的长度和起始位置记录下来，作为结果的可能。</p><p>这样，我们就可以在 $O(m + n)$ 的时间复杂度内解决此问题。</p><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string minWindow(string s, string t) &#123;        unordered_map&lt;char, int&gt; t_map;        for (const char&amp; c : t) &#123;            ++t_map[c];        &#125;        int left &#x3D; 0, right &#x3D; 0, count &#x3D; t.length(), min_len &#x3D; INT_MAX, min_start &#x3D; 0;        while (right &lt; s.length()) &#123;            &#x2F;&#x2F; 右指针右移            if (t_map[s[right++]]-- &gt; 0) &#123;                --count;            &#125;            while (count &#x3D;&#x3D; 0) &#123;                if (right - left &lt; min_len) &#123;                    min_len &#x3D; right - left;                    min_start &#x3D; left;                &#125;                &#x2F;&#x2F; 左指针左移                if (t_map[s[left++]]++ &#x3D;&#x3D; 0) &#123;                    ++count;                &#125;            &#125;        &#125;        return min_len &#x3D;&#x3D; INT_MAX ? &quot;&quot; : s.substr(min_start, min_len);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 、一个字符串 &lt;code&gt;t&lt;/code&gt; 。返回 &lt;code&gt;s&lt;/code&gt; 中涵盖 &lt;code&gt;t&lt;/code&gt; 所有字符的最小子串。如果 &lt;code&gt;s&lt;/code&gt; 中不存在涵盖 &lt;code&gt;t&lt;/code&gt; 所有字符的子串，则返回空字符串 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;t&lt;/code&gt; 中重复字符，我们寻找的子字符串中该字符数量必须不少于 &lt;code&gt;t&lt;/code&gt; 中该字符数量。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;s&lt;/code&gt; 中存在这样的子串，我们保证它是唯一的答案。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:59.螺旋矩阵II</title>
    <link href="2023/02/09/leetcode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <id>2023/02/09/leetcode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</id>
    <published>2023-02-08T16:53:16.000Z</published>
    <updated>2023-02-10T10:58:03.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个正整数 $n$ ，生成一个包含 $1$ 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 $n \times n$ 正方形矩阵 <code>matrix</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：[[1,2,3],[8,9,4],[7,6,5]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>定义四个变量<code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>，分别代表矩阵的上下左右边界。</li><li>定义一个变量 <code>count</code> 表示当前元素的值，初始值为1。</li><li>只要 <code>top &lt;= bottom &amp;&amp; left &lt;= right</code> ，循环执行以下步骤：<ol><li>先向右填充 <code>top</code> 行的元素，元素的值递增，并将 <code>top</code> 向下移动1。</li><li>向下填充 <code>right</code> 列的元素，元素的值递增，并将 <code>right</code> 向左移动1。</li><li>如果 <code>top &lt;= bottom</code> ，向左填充 <code>bottom</code> 行的元素，元素的值递增，并将 <code>bottom</code> 向上移动1。</li><li>如果 <code>left &lt;= right</code> ，向上填充 <code>left</code> 列的元素，元素的值递增，并将 <code>left</code> 向右移动1。</li></ol></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 0));        int top &#x3D; 0, bottom &#x3D; n - 1, left &#x3D; 0, right &#x3D; n - 1;        int count &#x3D; 1;        while (top &lt;&#x3D; bottom &amp;&amp; left &lt;&#x3D; right) &#123;            for (int j &#x3D; left; j &lt;&#x3D; right; j++) &#123;                matrix[top][j] &#x3D; count++;            &#125;            top++;            for (int i &#x3D; top; i &lt;&#x3D; bottom; i++) &#123;                matrix[i][right] &#x3D; count++;            &#125;            right--;            if (top &lt;&#x3D; bottom) &#123;                for (int j &#x3D; right; j &gt;&#x3D; left; j--) &#123;                    matrix[bottom][j] &#x3D; count++;                &#125;                bottom--;            &#125;            if (left &lt;&#x3D; right) &#123;                for (int i &#x3D; bottom; i &gt;&#x3D; top; i--) &#123;                    matrix[i][left] &#x3D; count++;                &#125;                left++;            &#125;        &#125;        return matrix;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个正整数 $n$ ，生成一个包含 $1$ 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 $n \times n$ 正方形矩阵 &lt;code&gt;matrix&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:209.长度最小的子数组</title>
    <link href="2023/02/07/leetcode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>2023/02/07/leetcode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2023-02-07T11:43:53.000Z</published>
    <updated>2023-02-07T11:49:11.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：target &#x3D; 4, nums &#x3D; [1,4,4]输出：1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>滑动窗口法</li></ol><p>直接使用双重for循环会超时，因此在这里使用滑动窗口的思想，在一个for循环中解决问题，在for循环中索引值为窗口的右边界。当<code>sum &gt;= target</code>时，窗口左边的指针进行右移，同时<code>sum -= nums[i++]</code>，最终遍历结束就得到了左指针和右指针的最终位置。结果为右指针-左指针+1.</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int sum &#x3D; 0;        int n &#x3D; nums.size();        for (int num : nums) &#123;            if (num &#x3D;&#x3D; target) &#123;                return 1; &#x2F;&#x2F;若数组中有包含target的值，直接返回1            &#125;            sum +&#x3D; num;        &#125;        if (sum &lt; target) &#123;            return 0; &#x2F;&#x2F;若数组所有正数之和均小于target，则直接返回0        &#125;else if (sum &#x3D;&#x3D; target) &#123;            return nums.size();&#x2F;&#x2F;若数组所有正数之和刚好等于target，则直接返回数组的长度        &#125;else &#123;            int result &#x3D; INT32_MAX;&#x2F;&#x2F;初始化为int的最大值            int sum &#x3D; 0;            int i &#x3D; 0;            int subLength &#x3D; 0;            for(int j &#x3D; 0; j &lt; nums.size(); j++) &#123; &#x2F;&#x2F;窗口右边界                sum +&#x3D; nums[j];                while (sum &gt;&#x3D; target) &#123;                    subLength &#x3D; j - i + 1;                    result &#x3D; result &lt; subLength? result:subLength;                    sum -&#x3D; nums[i++]; &#x2F;&#x2F;滑动窗口                &#125;            &#125;            return result;        &#125;        return 0;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个含有 &lt;code&gt;n&lt;/code&gt; 个正整数的数组和一个正整数 &lt;code&gt;target&lt;/code&gt; &lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找出该数组中满足其和 &lt;code&gt;≥ target&lt;/code&gt; 的长度最小的 &lt;strong&gt;连续子数组&lt;/strong&gt; &lt;code&gt;[numsl, numsl+1, ..., numsr-1, numsr]&lt;/code&gt; ，并返回其长度&lt;strong&gt;。&lt;/strong&gt;如果不存在符合条件的子数组，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:977.有序数组的平方</title>
    <link href="2023/02/06/leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <id>2023/02/06/leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</id>
    <published>2023-02-06T11:32:22.000Z</published>
    <updated>2023-02-06T15:08:19.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-7,-3,2,3,11]输出：[4,9,9,49,121]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>常规思路</li></ol><p>先对每个数组的元素进行平方赋值，然后对数组进行排序。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            nums[i] &#x3D; nums[i] * nums[i];        &#125;        sort(nums.begin(), nums.end()); &#x2F;&#x2F;排序        return nums;    &#125;&#125;;</code></pre><ol start="2"><li>利用指向正负分界线的指针构造“归并排序”</li></ol><p>常规思路未使用题目的“非递减顺序数组”的条件，因此我们新建一个指针，它指向数组中的最后一个非正数元素，然后从中间向两边进行遍历，将平方和较小的结果插入rst数组中。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; rst;        int n &#x3D; nums.size();        &#x2F;&#x2F;1. 获取数组正负边界索引        int index &#x3D; -1;        for(int i &#x3D; 0; i &lt; n; i++) &#123;            if (nums[i] &lt; 0) &#123;                index &#x3D; i;            &#125;            else &#123;                break;            &#125;        &#125;        &#x2F;&#x2F;2. 双指针从中间向两边遍历        int i &#x3D; index;        int j &#x3D; index + 1;        while(i &gt;&#x3D; 0 || j &lt; n) &#123;            if (i &lt; 0) &#123;                rst.push_back(nums[j] * nums[j]);                j++;            &#125;            else if (j &#x3D;&#x3D; n) &#123;                rst.push_back(nums[i] * nums[i]);                i--;            &#125;            else if (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;                rst.push_back(nums[i] * nums[i]);                i--;            &#125;            else &#123;                rst.push_back(nums[j] * nums[j]);                j++;            &#125;        &#125;        return rst;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排序的整数数组 &lt;code&gt;nums&lt;/code&gt;，返回 &lt;strong&gt;每个数字的平方&lt;/strong&gt; 组成的新数组，要求也按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:704.二分查找</title>
    <link href="2023/02/05/leetcode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>2023/02/05/leetcode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2023-02-05T04:46:18.000Z</published>
    <updated>2023-02-05T04:49:24.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2输出: -1解释: 2 不存在 nums 中因此返回 -1</code></pre><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>如题目所示，直接使用二分查找即可。C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int size &#x3D; nums.size();        int left &#x3D; 0;        int right &#x3D; size - 1;        int mid &#x3D; (left + (right - left) &#x2F; 2);        while(nums[mid] !&#x3D; target &amp;&amp; left &lt; right) &#123;            if (nums[mid] &gt; target) &#123;                right &#x3D; mid - 1;            &#125;            else &#123;                left &#x3D; mid + 1;            &#125;            mid &#x3D; (left + (right - left) &#x2F; 2);        &#125;        if (nums[mid] &#x3D;&#x3D; target) &#123;            return mid;        &#125;        return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个 &lt;code&gt;n&lt;/code&gt; 个元素有序的（升序）整型数组 &lt;code&gt;nums&lt;/code&gt; 和一个目标值 &lt;code&gt;target&lt;/code&gt; ，写一个函数搜索 &lt;code&gt;nums&lt;/code&gt; 中的 &lt;code&gt;target&lt;/code&gt;，如果目标值存在返回下标，否则返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:37.解数独</title>
    <link href="2023/02/03/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>2023/02/03/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/</id>
    <published>2023-02-03T06:58:10.000Z</published>
    <updated>2023-02-05T04:47:59.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/250px-sudoku-by-l2g-20050714svg.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</code></pre><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>我们可以考虑按照「行优先」的顺序依次枚举每一个空白格中填的数字，通过递归 + 回溯的方法枚举所有可能的填法。当递归到最后一个空白格后，如果仍然没有冲突，说明我们找到了答案；在递归的过程中，如果当前的空白格不能填下任何一个数字，那么就进行回溯。</p><p>由于每个数字在同一行、同一列、同一个九宫格中只会出现一次，因此我们可以使用<code>line[i]，column[j]，block[x][y]</code>分别表示第 i 行，第 j 列，第(x,y) 个九宫格中填写数字的情况。在下面给出的三种方法中，我们将会介绍两种不同的表示填写数字情况的方法。</p><blockquote><p>九宫格的范围为 $0 \leq x \leq 2$以及 $0 \leq y \leq 2$。 具体地，第 i 行第 j 列的格子位于第$(\lfloor i&#x2F;3 \rfloor, \lfloor j&#x2F;3 \rfloor)$个九宫格中，其中$\lfloor u \rfloor$表示对 u 向下取整。</p></blockquote><ol><li>回溯法</li></ol><p><strong>思路</strong>：最容易想到的方法是用一个数组记录每个数字是否出现。由于我们可以填写的数字范围为[1,9]，而数组的下标从 0 开始，因此在存储时，我们使用一个长度为 9 的布尔类型的数组，其中 i 个元素的值为 $\text{True}$，当且仅当数字i+1 出现过。例如我们用 $\textit{line}[2][3] &#x3D; \text{True}$ 表示数字 4 在第 2 行已经出现过，那么当我们在遍历到第 2 行的空白格时，就不能填入数字 4。</p><p><strong>算法</strong>：</p><p>首先对整个数独数组进行遍历，当我们遍历到第i行第j列时：</p><ul><li>若该位置是一个空白格，那么我们将其加入一个用来存储空白格位置的列表中，方便后续的递归操作；</li><li>若该位置是一个数字x，那么我们需要将<code>line[i][x-1],column[j][x-1]</code>以及<code>block[i/3][j/3][x-1]</code>都置为True。</li></ul><p>当我们结束了遍历过程之后，就可以开始递归枚举。当递归到第 $i$ 行第 $j$ 列的位置时，我们枚举填入的数字 $x$。根据题目的要求，数字 $x$ 不能和当前行、列、九宫格中已经填入的数字相同，因此 $line[i][x-1]$，$\textit{column}[j][x-1]$以及 $\textit{block}[\lfloor i&#x2F;3 \rfloor][\lfloor j&#x2F;3 \rfloor][x-1]$ 必须均为 $\text{False}$。</p><p>当我们填入了数字 $x$ 之后，我们要将上述的三个值都置为 $\text{True}$，并且继续对下一个空白格位置进行递归。在回溯到当前递归层时，我们还要将上述的三个值重新置为 $\text{False}$。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    bool line[9][9];    bool column[9][9];    bool block[3][3][9];    bool valid;    vector&lt;pair&lt;int, int&gt;&gt; spaces;public:    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;        if (pos &#x3D;&#x3D; spaces.size()) &#123;            valid &#x3D; true;            return;        &#125;        auto [i, j] &#x3D; spaces[pos]; &#x2F;&#x2F;获取空位位置        for (int digit &#x3D; 0; digit &lt; 9 &amp;&amp; !valid; ++digit) &#123;            if (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i &#x2F; 3][j &#x2F; 3][digit]) &#123;                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;填符合条件的数字                board[i][j] &#x3D; digit + &#39;0&#39; + 1;                dfs(board, pos + 1); &#x2F;&#x2F;递归                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; false; &#x2F;&#x2F;回溯            &#125;        &#125;    &#125;    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        memset(line, false, sizeof(line));        memset(column, false, sizeof(column));        memset(block, false, sizeof(block));        valid &#x3D; false;        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;                    spaces.emplace_back(i, j); &#x2F;&#x2F;initialize                &#125;                else &#123;                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;                    line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;initialize                &#125;            &#125;        &#125;        dfs(board, 0); &#x2F;&#x2F;从头开始求解，最后得到填满数字的board    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/">https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;数独的解法需 &lt;strong&gt;遵循如下规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一个以粗实线分隔的 &lt;code&gt;3x3&lt;/code&gt; 宫内只能出现一次。（请参考示例图）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数独部分空格内已填入了数字，空白格用 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 表示。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:198.打家劫舍</title>
    <link href="2023/02/03/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>2023/02/03/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2023-02-03T06:32:26.000Z</published>
    <updated>2023-02-05T04:48:09.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>动态规划分析如下：</p><ol><li>确定dp数组(dp table)以及它的下标的含义：</li></ol><p>dp[i]:考虑下标i以内的房屋，最多可以偷窃的金额为dp[i];</p><ol start="2"><li>确定递推公式</li></ol><p>决定是否偷第i个房间:</p><ul><li>如果偷第i个房间，dp[i] &#x3D; dp[i - 2] + nums[i];</li></ul><p>也就是不偷第i-1，而是找到i-2以内最多的房屋，然后再加上第i间房偷到的钱。</p><ul><li>如果不偷第i个房间，那么dp[i] &#x3D; dp[i - 1];也就是要考虑i-1房（<strong>注意这里是考虑而不是真的要偷i-1房</strong>）</li></ul><p>完成分析后取dp[i]的最大值，也就是dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>因为dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);所以基础就是dp[0]和dp[1];</p><p>因此dp[0] &#x3D; nums[0],dp[1] &#x3D; max(nums[0], nums[1]);</p><ol start="4"><li>确定遍历顺序</li></ol><p>dp[i]是根据dp[i-2]和dp[i-1]推导出来的，那么一定是从前到后遍历。</p><ol start="5"><li>举例推导dp数组</li></ol><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        if(nums.empty()) &#123;            return 0;        &#125;        int size &#x3D; nums.size();        if(size &#x3D;&#x3D; 1) &#123;            return nums[0];        &#125;        vector&lt;int&gt; dp &#x3D; vector&lt;int&gt;(size, 0); &#x2F;&#x2F;3. initialize        dp[0] &#x3D; nums[0];        dp[1] &#x3D; max(nums[0], nums[1]);        &#x2F;&#x2F;4. 遍历        for(int i &#x3D; 2; i &lt; size; i++) &#123;            dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);        &#125;        return dp[size - 1];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 &lt;strong&gt;不触动警报装置的情况下&lt;/strong&gt; ，一夜之内能够偷窃到的最高金额。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:53.最大子数组和</title>
    <link href="2023/02/02/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>2023/02/02/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</id>
    <published>2023-02-02T06:40:12.000Z</published>
    <updated>2023-02-03T13:02:55.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1]输出：1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [5,4,-1,7,8]输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>可以很容易想到$f(i) &#x3D; max{f(i-1) + nums[i], nums[i]}$.C++实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int pre &#x3D; 0, maxAns &#x3D; nums[0];        for (const auto &amp;x: nums) &#123;            pre &#x3D; max(pre + x, x);            maxAns &#x3D; max(maxAns, pre);        &#125;        return maxAns;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:70.爬楼梯</title>
    <link href="2023/02/01/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>2023/02/01/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2023-02-01T06:48:43.000Z</published>
    <updated>2023-02-02T16:52:25.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归</li></ol><p>很明显，该问题可以用$f(x) &#x3D; f(x - 1) + f(x - 2)$并且很容易得知$f(0) &#x3D; 1;f(1) &#x3D; 1;f(2) &#x3D; 2$,但是直接写递归(<code>return climbStairs(n - 1) + climbStairs(n - 2)</code>)会导致时间超限，在这里使用「滚动数组思想」把空间复杂度优化成 $O(1)$。</p><p><img src="http://cdn.leafii.top/img/70_fig1.gif" alt="fig1" loading="lazy"></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int climbStairs(int n) &#123;        int p &#x3D; 0, q &#x3D; 0, r &#x3D; 1;        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;            p &#x3D; q;             q &#x3D; r;             r &#x3D; p + q;        &#125;        return r;    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/">https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/</a> </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
</feed>
