<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-10-17T01:10:07.495Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode383.赎金信</title>
    <link href="2023/10/17/leetcode383-%E8%B5%8E%E9%87%91%E4%BF%A1/"/>
    <id>2023/10/17/leetcode383-%E8%B5%8E%E9%87%91%E4%BF%A1/</id>
    <published>2023-10-17T00:53:04.000Z</published>
    <updated>2023-10-17T01:10:07.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;输出：false</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力枚举</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;            for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;                &#x2F;&#x2F; 在ransomNote中找到和magazine相同的字符                if (magazine[i] &#x3D;&#x3D; ransomNote[j]) &#123;                    ransomNote.erase(ransomNote.begin() + j); &#x2F;&#x2F; ransomNote删除这个字符                    break;                &#125;            &#125;        &#125;        &#x2F;&#x2F; 如果ransomNote为空，则说明magazine的字符可以组成ransomNote        if (ransomNote.length() &#x3D;&#x3D; 0) &#123;            return true;        &#125;        return false;    &#125;&#125;;</code></pre><ul><li>哈希表</li></ul><p>使用哈希表分别统计两个字符串中字母的个数，然后对比两个哈希表的结果，如果前者的字母统计个数大于后者，直接返回false，否则最终返回true</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        &#x2F;&#x2F; 初始化哈希表用于统计字符数        unordered_map&lt;char, int&gt; ransomNoteCnt;        unordered_map&lt;char, int&gt; magezineCnt;        for (char c:ransomNote) &#123;            ransomNoteCnt[c] &#x3D; ransomNoteCnt[c]&#x3D;&#x3D;0?1:ransomNoteCnt[c]+1;        &#125;        for (char c:magazine) &#123;            magezineCnt[c] &#x3D; magezineCnt[c]&#x3D;&#x3D;0?1:magezineCnt[c]+1;        &#125;        for (char c &#x3D; &#39;a&#39;; c &lt;&#x3D; &#39;z&#39;; c++) &#123;            if (ransomNoteCnt[c] &lt;&#x3D; magezineCnt[c]) continue;            else return false;        &#125;        return true;    &#125;&#125;;</code></pre><ul><li>更省空间的哈希表解法</li></ul><p>因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个长度为26的数组来记录magazine里字母出现的次数。</p><p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p><p>依然是数组在哈希法中的应用。</p><p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        int record[26] &#x3D; &#123;0&#125;;        &#x2F;&#x2F;add        if (ransomNote.size() &gt; magazine.size()) &#123;            return false;        &#125;        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;            &#x2F;&#x2F; 通过record数据记录 magazine里各个字符出现次数            record[magazine[i]-&#39;a&#39;] ++;        &#125;        for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;            &#x2F;&#x2F; 遍历ransomNote，在record里对应的字符个数做--操作            record[ransomNote[j]-&#39;a&#39;]--;            &#x2F;&#x2F; 如果小于零说明ransomNote里出现的字符，magazine没有            if(record[ransomNote[j]-&#39;a&#39;] &lt; 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串：&lt;code&gt;ransomNote&lt;/code&gt; 和 &lt;code&gt;magazine&lt;/code&gt; ，判断 &lt;code&gt;ransomNote&lt;/code&gt; 能不能由 &lt;code&gt;magazine&lt;/code&gt; 里面的字符构成。&lt;/p&gt;
&lt;p&gt;如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;magazine&lt;/code&gt; 中的每个字符只能在 &lt;code&gt;ransomNote&lt;/code&gt; 中使用一次。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode349.两个数组的交集</title>
    <link href="2023/10/17/leetcode349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>2023/10/17/leetcode349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2023-10-17T00:38:12.000Z</published>
    <updated>2023-10-17T00:52:36.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; deduplicate(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F; 手动去重        int n &#x3D; nums.size();        if (n &lt;&#x3D; 1) return nums;        int p &#x3D; 0,q &#x3D; 1;        while (q &lt; n) &#123;            &#x2F;&#x2F; 0 0 1 2 2 3 4            if (nums[p] &#x3D;&#x3D; nums[q])&#123;                ++q;            &#125;            else &#123;                nums[p+1] &#x3D; nums[q];                ++p;                ++q;            &#125;        &#125;        vector&lt;int&gt; newNums(nums.begin(), nums.begin() + p + 1);        return newNums;    &#125;    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        &#x2F;&#x2F; 排序        sort(nums1.begin(), nums1.end());        sort(nums2.begin(), nums2.end());        &#x2F;&#x2F; 对两个数组进行去重        vector&lt;int&gt; newNums1 &#x3D; deduplicate(nums1);        vector&lt;int&gt; newNums2 &#x3D; deduplicate(nums2);        &#x2F;&#x2F; 初始化结果数组        vector&lt;int&gt; results;        int n1 &#x3D; newNums1.size();        int n2 &#x3D; newNums2.size();        &#x2F;&#x2F; 暴力便利        for (int i &#x3D; 0; i &lt; n1; i++) &#123;            for (int j &#x3D; 0; j &lt; n2; j++) &#123;                if (newNums1[i] &#x3D;&#x3D; newNums2[j]) &#123;                    results.push_back(newNums1[i]);                &#125;            &#125;        &#125;        &#x2F;&#x2F; 返回结果数组        return results;    &#125;&#125;;</code></pre><ul><li>使用哈希表</li></ul><p>C++中，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_set&lt;int&gt; result_set;        unordered_set&lt;int&gt; nums1set(nums1.begin(), nums1.end());        for (int num:nums2) &#123;            &#x2F;&#x2F; 发现nums2的元素 在nums_set里又出现过            if (nums1set.find(num) !&#x3D; nums1set.end()) &#123;                result_set.insert(num);            &#125;        &#125;        return vector&lt;int&gt;(result_set.begin(), result_set.end());    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; ，返回 &lt;em&gt;它们的交集&lt;/em&gt; 。输出结果中的每个元素一定是 &lt;strong&gt;唯一&lt;/strong&gt; 的。我们可以 &lt;strong&gt;不考虑输出结果的顺序&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode40.组合总和II</title>
    <link href="2023/10/12/leetcode40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/"/>
    <id>2023/10/12/leetcode40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/</id>
    <published>2023-10-12T10:59:31.000Z</published>
    <updated>2023-10-12T11:10:39.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,输出:[[1,2,2],[5]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>这道题目和39.组合总和有如下区别：</p><ol><li>本题candidates 中的每个数字在每个组合中只能使用一次。</li><li>本题数组candidates的元素是有重复的，而39是无重复元素的数组candidates</li></ol><p>最后本题和39要求一样，解集不能包含重复的组合。</p><p><strong>本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p><p><img src="http://cdn.leafii.top/img/20230310000918.png" alt="40.组合总和II" loading="lazy"></p><p>同一树层上的两个重复元素不可以重新选取，使用used数组用来记录同一树枝上的元素是否使用过。</p><ul><li>递归函数参数</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span> <span class="token comment">// 存放组合集合</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span>           <span class="token comment">// 符合条件的组合</span><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> used<span class="token punctuation">)</span></code></pre><ul><li>递归终止条件</li></ul><p><code>sum &gt; target</code> 和 <code>sum == target</code></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 这个条件其实可以省略</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>单层搜索的逻辑</li></ul><p>要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。</p><p>**如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。</p><p>此时for循环里就应该做continue的操作。</p><p><img src="http://cdn.leafii.top/img/20230310000954.png" alt="40.组合总和II1" loading="lazy"></p><p>我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul><p><img src="http://cdn.leafii.top/img/20221021163812.png" alt="img" loading="lazy"></p><p>那么单层搜索的逻辑代码如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sum <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span>    <span class="token comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span>    <span class="token comment">// 要对同一树层使用过的元素进行跳过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> candidates<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    sum <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span>    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    sum <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>最终得到的整体代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) &#123;        if (sum &#x3D;&#x3D; target) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target; i++) &#123;            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过            &#x2F;&#x2F; 要对同一树层使用过的元素进行跳过            if (i &gt; 0 &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;                continue;            &#125;            sum +&#x3D; candidates[i];            path.push_back(candidates[i]);            used[i] &#x3D; true;            backtracking(candidates, target, sum, i + 1, used); &#x2F;&#x2F; 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次            used[i] &#x3D; false;            sum -&#x3D; candidates[i];            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        vector&lt;bool&gt; used(candidates.size(), false);        path.clear();        result.clear();        &#x2F;&#x2F; 首先把给candidates排序，让其相同的元素都挨在一起。        sort(candidates.begin(), candidates.end());        backtracking(candidates, target, 0, 0, used);        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个候选人编号的集合 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的每个数字在每个组合中只能使用 &lt;strong&gt;一次&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;解集不能包含重复的组合。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode39.组合总和</title>
    <link href="2023/10/11/leetcode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>2023/10/11/leetcode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</id>
    <published>2023-10-11T00:52:11.000Z</published>
    <updated>2023-10-12T11:10:36.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。7 也是一个候选， 7 &#x3D; 7 。仅有这两种组合。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入: candidates &#x3D; [2,3,5], target &#x3D; 8输出: [[2,2,2,2],[2,3,3],[3,5]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入: candidates &#x3D; [2], target &#x3D; 1输出: []</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>基础回溯法</li></ul><p>本题的搜索过程可以抽象成如下树形结构：</p><p><img src="http://cdn.leafii.top/img/20201223170730367.png" alt="39.组合总和" loading="lazy"></p><p>使用回溯三步曲：</p><ol><li>递归函数的参数</li></ol><p>定义一个二维数组results用于存储最终的组合，定义一个一维数组用于存储单次组合。这两个变量为全局变量，然后定义一个递归函数traceback,它的参数为题目自带的候选数组canditate，target，以及path元素的和sum，以及开始遍历的索引startIndex</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> startIndex<span class="token punctuation">)</span></code></pre><ol start="2"><li>递归终止条件</li></ol><p>当<code>sum&gt;target</code>时，没有继续遍历下去的必要，当<code>sum==target</code>时将当前的path放进results中，并退出当前递归函数。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>单层搜索逻辑</li></ol><p>从startIndex开始遍历candidates数组，搜索组合</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sum <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span>    sum <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 回溯</span>    path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 回溯</span><span class="token punctuation">&#125;</span></code></pre><p>整个代码：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; results;    vector&lt;int&gt; path;    void tracebacking(vector&lt;int&gt; candidates, int target, int sumValue,int startIndex) &#123;        &#x2F;&#x2F;参数分别为候选数组，目标值，path中元素的和sumValue，最终结果results，单个组合path，开始遍历的索引startIndex        if (sumValue &gt; target) return; &#x2F;&#x2F; 如果sumValue比target大，直接剪枝        &#x2F;&#x2F; 终止条件        if (sumValue &#x3D;&#x3D; target) &#123;            &#x2F;&#x2F; 符合一个组合的条件            results.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; candidates.size();i++) &#123;            path.push_back(candidates[i]);            sumValue +&#x3D; candidates[i];            tracebacking(candidates, target, sumValue, i);            &#x2F;&#x2F; 回溯            path.pop_back();            sumValue -&#x3D; candidates[i];        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        results.clear();        path.clear();        tracebacking(candidates, target, 0, 0);        return results;       &#125;&#125;;</code></pre><ul><li>剪枝优化</li></ul><p>对数组进行排序，在for循环中的判断中增加一个判断，可以进行有效的剪枝。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; results;    vector&lt;int&gt; path;    void tracebacking(vector&lt;int&gt; candidates, int target, int sumValue,int startIndex) &#123;        &#x2F;&#x2F;参数分别为候选数组，目标值，path中元素的和sumValue，最终结果results，单个组合path，开始遍历的索引startIndex        if (sumValue &gt; target) return; &#x2F;&#x2F; 如果sumValue比target大，直接剪枝        &#x2F;&#x2F; 终止条件        if (sumValue &#x3D;&#x3D; target) &#123;            &#x2F;&#x2F; 符合一个组合的条件            results.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sumValue + candidates[i] &lt;&#x3D; target;i++) &#123;            &#x2F;&#x2F; for循环中的判断条件做了剪枝优化            path.push_back(candidates[i]);            sumValue +&#x3D; candidates[i];            tracebacking(candidates, target, sumValue, i);            &#x2F;&#x2F; 回溯            path.pop_back();            sumValue -&#x3D; candidates[i];        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        results.clear();        path.clear();        sort(candidates.begin(), candidates.end()); &#x2F;&#x2F; 排序，减少不必要的计算        tracebacking(candidates, target, 0, 0);        return results;       &#125;&#125;;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>代码随想录：<a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 &lt;strong&gt;无重复元素&lt;/strong&gt; 的整数数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标整数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中可以使数字和为目标数 &lt;code&gt;target&lt;/code&gt; 的 所有 &lt;strong&gt;不同组合&lt;/strong&gt; ，并以列表形式返回。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回这些组合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;candidates&lt;/code&gt; 中的 &lt;strong&gt;同一个&lt;/strong&gt; 数字可以 &lt;strong&gt;无限制重复被选取&lt;/strong&gt; 。如果至少一个数字的被选数量不同，则两种组合是不同的。 &lt;/p&gt;
&lt;p&gt;对于给定的输入，保证和为 &lt;code&gt;target&lt;/code&gt; 的不同组合数少于 &lt;code&gt;150&lt;/code&gt; 个。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode83.删除排序链表中的重复元素</title>
    <link href="2023/10/10/leetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>2023/10/10/leetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2023-10-10T06:42:51.000Z</published>
    <updated>2023-10-10T06:46:43.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/list1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,1,2]输出：[1,2]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/list2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,1,2,3,3]输出：[1,2,3]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针</li></ul><p>思路与第一个题目类似，只是链表与数组的去重方式不同，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if (!head || !head-&gt;next) &#123;            &#x2F;&#x2F;如果仅有一个元素或者一个元素都没有，直接返回head本身            return head;        &#125;        &#x2F;&#x2F; 初始化指针p，q        ListNode* p &#x3D; head;         ListNode* q &#x3D; head-&gt;next;        while (q) &#123;            &#x2F;&#x2F; 当q未指到链表结尾时进行判断            if (p-&gt;val &#x3D;&#x3D; q-&gt;val) &#123;                &#x2F;&#x2F;相等元素执行断链操作                ListNode* temp &#x3D; q;                p-&gt;next &#x3D; q-&gt;next;                q &#x3D; q-&gt;next;                delete temp;            &#125;            else &#123;                &#x2F;&#x2F; 不相等两个指针全都后移                p &#x3D; p-&gt;next;                q &#x3D; q-&gt;next;            &#125;        &#125;        return head;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个已排序的链表的头 &lt;code&gt;head&lt;/code&gt; ， &lt;em&gt;删除所有重复的元素，使每个元素只出现一次&lt;/em&gt; 。返回 &lt;em&gt;已排序的链表&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode26.删除有序数组中的重复项</title>
    <link href="2023/10/10/leetcode26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>2023/10/10/leetcode26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2023-10-10T06:41:57.000Z</published>
    <updated>2023-10-10T06:45:35.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><span id="more"></span><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><pre class="language-none"><code class="language-none">int[] nums &#x3D; [...]; &#x2F;&#x2F; 输入数组int[] expectedNums &#x3D; [...]; &#x2F;&#x2F; 长度正确的期望答案int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用assert k &#x3D;&#x3D; expectedNums.length;for (int i &#x3D; 0; i &lt; k; i++) &#123;    assert nums[i] &#x3D;&#x3D; expectedNums[i];&#125;</code></pre><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]输出：5, nums &#x3D; [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n&#x3D;&#x3D;1) return n;        &#x2F;&#x2F; 初始化双指针        int p &#x3D; 0;        int q &#x3D; 1;        while (q &lt; n) &#123;            &#x2F;&#x2F; 1.比较 p 和 q 位置的元素是否相等。            &#x2F;&#x2F; 如果相等，q 后移 1 位             if (nums[p] &#x3D;&#x3D; nums[q]) &#123;                q &#x3D; q + 1;            &#125;            &#x2F;&#x2F; 如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位             else &#123;                nums[p+1] &#x3D; nums[q];                ++p;                ++q;            &#125;            &#x2F;&#x2F; 重复上述过程，直到 q 等于数组长度。        &#125;        return p + 1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 &lt;strong&gt;非严格递增排列&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，请你**&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt; 原地&lt;/a&gt;** 删除重复出现的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; ，返回删除后数组的新长度。元素的 &lt;strong&gt;相对顺序&lt;/strong&gt; 应该保持 &lt;strong&gt;一致&lt;/strong&gt; 。然后返回 &lt;code&gt;nums&lt;/code&gt; 中唯一元素的个数。&lt;/p&gt;
&lt;p&gt;考虑 &lt;code&gt;nums&lt;/code&gt; 的唯一元素的数量为 &lt;code&gt;k&lt;/code&gt; ，你需要做以下事情确保你的题解可以被通过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改数组 &lt;code&gt;nums&lt;/code&gt; ，使 &lt;code&gt;nums&lt;/code&gt; 的前 &lt;code&gt;k&lt;/code&gt; 个元素包含唯一元素，并按照它们最初在 &lt;code&gt;nums&lt;/code&gt; 中出现的顺序排列。&lt;code&gt;nums&lt;/code&gt; 的其余元素与 &lt;code&gt;nums&lt;/code&gt; 的大小不重要。&lt;/li&gt;
&lt;li&gt;返回 &lt;code&gt;k&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode611.有效三角形的个数</title>
    <link href="2023/09/15/leetcode611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>2023/09/15/leetcode611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2023-09-15T10:27:08.000Z</published>
    <updated>2023-09-15T10:30:07.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [4,2,3,4]输出: 4</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>遍历+双指针优化</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;        int result &#x3D; 0; &#x2F;&#x2F; 初始化结果        sort(nums.begin(), nums.end()); &#x2F;&#x2F; 对数组排序        int n &#x3D; nums.size();        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;            if (nums[i] &#x3D;&#x3D; 0) continue; &#x2F;&#x2F; 跳过为0的状态            int k &#x3D; i + 2; &#x2F;&#x2F; 第二个指针的初始化位置            for (int j &#x3D; i + 1; j &lt; n - 1; j++) &#123;                while (k &lt; n &amp;&amp; nums[i] + nums[j] &gt; nums[k]) &#123;                    k++;                &#125;                result +&#x3D; k - j - 1;&#x2F;&#x2F; k - j - 1 表示的是满足条件的第三个边的数量            &#125;        &#125;        return result; &#x2F;&#x2F; 返回结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个包含非负整数的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其中可以组成三角形三条边的三元组个数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode451.根据字符出现频率排序</title>
    <link href="2023/09/12/leetcode451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"/>
    <id>2023/09/12/leetcode451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-12T13:03:45.000Z</published>
    <updated>2023-09-12T13:10:08.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，根据字符出现的 <strong>频率</strong> 对其进行 <strong>降序排序</strong> 。一个字符出现的 <strong>频率</strong> 是它出现在字符串中的次数。</p><p>返回 <em>已排序的字符串</em> 。如果有多个答案，返回其中任何一个。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;tree&quot;输出: &quot;eert&quot;解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;cccaaa&quot;输出: &quot;cccaaa&quot;解释: &#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;Aabb&quot;输出: &quot;bbAa&quot;解释: 此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 * 105</code></li><li><code>s</code> 由大小写英文字母和数字组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>思路：首先使用hashmap对字符串中的字符进行计数，然后使用vector数组将hashmap的元素进行拷贝，将vector以计数的从大到小进行排序。最后对排序后的vector进行遍历，得到最终的字符串，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string frequencySort(string s) &#123;        unordered_map&lt;char, int&gt; s_count_map;        for (char c:s) &#123;            s_count_map[c]++;        &#125;        &#x2F;&#x2F; 复制        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector(s_count_map.begin(), s_count_map.end());        &#x2F;&#x2F;从大到小排序        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123;return a.second &gt; b.second;&#125;);        string result;        for(auto cnt:s_count_vector) &#123;            int cnt_second &#x3D; cnt.second;            while (cnt_second--) &#123;                result+&#x3D;cnt.first;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><ul><li>一些细节优化后的代码（成绩没变）</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string frequencySort(string s) &#123;        unordered_map&lt;char, int&gt; s_count_map;        &#x2F;&#x2F; 统计字符频率        for (char c : s) &#123;            s_count_map[c]++;        &#125;        &#x2F;&#x2F; 构建结果字符串        string result;        result.reserve(s.size()); &#x2F;&#x2F; 预分配足够的内存        &#x2F;&#x2F; 构建频率字符对，并按频率降序排序        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector;        for (const auto&amp; kv : s_count_map) &#123;            s_count_vector.emplace_back(kv);        &#125;        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123; return a.second &gt; b.second; &#125;);        &#x2F;&#x2F; 构建结果字符串        for (const auto&amp; cnt : s_count_vector) &#123;            result.append(cnt.second, cnt.first); &#x2F;&#x2F; 使用append方法        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，根据字符出现的 &lt;strong&gt;频率&lt;/strong&gt; 对其进行 &lt;strong&gt;降序排序&lt;/strong&gt; 。一个字符出现的 &lt;strong&gt;频率&lt;/strong&gt; 是它出现在字符串中的次数。&lt;/p&gt;
&lt;p&gt;返回 &lt;em&gt;已排序的字符串&lt;/em&gt; 。如果有多个答案，返回其中任何一个。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode976.三角形的最大周长</title>
    <link href="2023/09/12/leetcode976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/"/>
    <id>2023/09/12/leetcode976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/</id>
    <published>2023-09-12T12:29:18.000Z</published>
    <updated>2023-09-12T12:30:16.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定由一些正数（代表长度）组成的数组 <code>nums</code> ，返回 <em>由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长</em> 。如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,1,2]输出：5解释：你可以用三个边长组成一个三角形:1 2 2。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,1,10]输出：0解释：你不能用边长 1,1,2 来组成三角形。不能用边长 1,1,10 来构成三角形。不能用边长 1、2 和 10 来构成三角形。因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 104</code></li><li><code>1 &lt;= nums[i] &lt;= 106</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>排序解答</li></ul><ol><li>首先对输入数组 <code>nums</code> 进行排序，按照从大到小的顺序排列。</li><li>然后，遍历排序后的数组，从大到小依次选取三个数 <code>a</code>, <code>b</code>, <code>c</code>，判断是否满足组成三角形的条件，即 <code>a + b &gt; c</code> 和 <code>a - b &lt; c</code>。如果满足条件，就找到了最大周长的三角形，直接返回 <code>a + b + c</code>。</li><li>如果遍历完整个数组都没有找到满足条件的三角形，说明不存在符合条件的三角形，返回0。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:        int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F; 将数组从大到小排序        sort(nums.begin(), nums.end(), [](int a, int b) &#123;            return a &gt; b;        &#125;);        int n &#x3D; nums.size();        &#x2F;&#x2F; 开始遍历寻找最大的能组成三角形的三个数        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;            if (nums[i] &lt; nums[i + 1] + nums[i + 2]) return nums[i] + nums[i + 1] + nums[i + 2];        &#125;        return 0;    &#125;    &#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定由一些正数（代表长度）组成的数组 &lt;code&gt;nums&lt;/code&gt; ，返回 &lt;em&gt;由其中三个长度组成的、&lt;strong&gt;面积不为零&lt;/strong&gt;的三角形的最大周长&lt;/em&gt; 。如果不能形成任何面积不为零的三角形，返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode389.找不同</title>
    <link href="2023/09/12/leetcode389-%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
    <id>2023/09/12/leetcode389-%E6%89%BE%E4%B8%8D%E5%90%8C/</id>
    <published>2023-09-12T12:29:07.000Z</published>
    <updated>2023-09-12T12:30:20.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，它们只包含小写字母。</p><p>字符串 <code>t</code> 由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <code>t</code> 中被添加的字母。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;, t &#x3D; &quot;abcde&quot;输出：&quot;e&quot;解释：&#39;e&#39; 是那个被添加的字母。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;&quot;, t &#x3D; &quot;y&quot;输出：&quot;y&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 1000</code></li><li><code>t.length == s.length + 1</code></li><li><code>s</code> 和 <code>t</code> 只包含小写字母</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>用数组辅助计数的暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    char findTheDifference(string s, string t) &#123;        vector&lt;int&gt; s_cnt(26,0);        vector&lt;int&gt; t_cnt(26,0); &#x2F;&#x2F; 使用数组存储字符串中不同字母的个数        char result; &#x2F;&#x2F; 初始化答案字符        &#x2F;&#x2F; 分别统计不同字符串的字符个数        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            int index &#x3D; int(s[i] - &#39;a&#39;);            ++s_cnt[index];        &#125;        for (int j &#x3D; 0; j &lt; t.size(); j++) &#123;            int index &#x3D; int(t[j] - &#39;a&#39;);            ++t_cnt[index];        &#125;        &#x2F;&#x2F; 对比个数，不同的索引与&#39;a&#39;相加就是需要的答案。        for (int i &#x3D; 0; i &lt; 26; i++) &#123;            if (s_cnt[i] !&#x3D; t_cnt[i]) &#123;                result &#x3D; &#39;a&#39; + i;            &#125;        &#125;        return result; &#x2F;&#x2F; 返回答案    &#125;&#125;;</code></pre><ul><li>位运算</li></ul><p>如果将两个字符串拼接成一个字符串，则问题转换成求字符串中出现奇数次的字符。我们使用异或操作来找到两个字符串中不同的字符，因为相同的字符异或后会抵消，最终剩下的是不同的字符。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    char findTheDifference(string s, string t) &#123;        char result &#x3D; 0;                &#x2F;&#x2F; 异或操作会消除相同的字符，最终结果将是不同字符的ASCII码值        for (char c : s) &#123;            result ^&#x3D; c;        &#125;                for (char c : t) &#123;            result ^&#x3D; c;        &#125;                return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，它们只包含小写字母。&lt;/p&gt;
&lt;p&gt;字符串 &lt;code&gt;t&lt;/code&gt; 由字符串 &lt;code&gt;s&lt;/code&gt; 随机重排，然后在随机位置添加一个字母。&lt;/p&gt;
&lt;p&gt;请找出在 &lt;code&gt;t&lt;/code&gt; 中被添加的字母。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode60.排列序列</title>
    <link href="2023/09/08/leetcode60-%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/"/>
    <id>2023/09/08/leetcode60-%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</id>
    <published>2023-09-08T09:55:28.000Z</published>
    <updated>2023-09-08T13:50:45.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p><ol><li><code>&quot;123&quot;</code></li><li><code>&quot;132&quot;</code></li><li><code>&quot;213&quot;</code></li><li><code>&quot;231&quot;</code></li><li><code>&quot;312&quot;</code></li><li><code>&quot;321&quot;</code></li></ol><p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3, k &#x3D; 3输出：&quot;213&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4, k &#x3D; 9输出：&quot;2314&quot;</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3, k &#x3D; 1输出：&quot;123&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li><code>1 &lt;= k &lt;= n!</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>思路<br>首先可以根据全排列树发现，第 iii 层的每个结点有(n - i)!个分支，对于每一层我们只需要找到第 j 个结点使得$j\times(n - i)! \ge k$，然后再$k&#x3D;k−(j−1)×(n−i)!$ 再然后迭代下一层以此类推。 对于找第 j 个结点可以使用状态压缩，记录之前哪些点用过了。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:        vector&lt;int&gt; fact;  &#x2F;&#x2F; 存储阶乘的数组    Solution(): fact(10) &#123;  &#x2F;&#x2F; 构造函数，初始化fact数组为长度10的数组        fact[0] &#x3D; 1;  &#x2F;&#x2F; 阶乘0的值为1        iota(fact.begin() + 1, fact.end(), 1);  &#x2F;&#x2F; 填充fact数组，从1到9        partial_sum(fact.begin(), fact.end(), fact.begin(), multiplies&lt;int&gt;());  &#x2F;&#x2F; 计算部分和，得到1!到9!的值    &#125;    string getPermutation(int n, int k) &#123;  &#x2F;&#x2F; 返回第k个排列的字符串        string res;  &#x2F;&#x2F; 存储结果的字符串        int state &#x3D; 0;  &#x2F;&#x2F; 表示已经使用的数字的状态        for (int i &#x3D; n - 1; ~i; -- i) &#123;  &#x2F;&#x2F; 从最高位到最低位遍历            int pre &#x3D; 0;  &#x2F;&#x2F; 记录前一个状态下的排列数量            for (int j &#x3D; 1; j &lt;&#x3D; n; ++ j) &#123;  &#x2F;&#x2F; 遍历1到n                if (state &gt;&gt; j &amp; 1) continue;  &#x2F;&#x2F; 如果数字已被使用，跳过                if (pre + fact[i] &gt;&#x3D; k) &#123;  &#x2F;&#x2F; 如果前一个状态下的排列数量加上当前位的阶乘大于等于k                    res.push_back(j + &#39;0&#39;);  &#x2F;&#x2F; 将当前数字加入结果字符串                    k -&#x3D; pre;  &#x2F;&#x2F; 更新k值                    state |&#x3D; 1 &lt;&lt; j;  &#x2F;&#x2F; 更新已使用数字的状态                    break;  &#x2F;&#x2F; 跳出内层循环                &#125;                pre +&#x3D; fact[i];  &#x2F;&#x2F; 更新前一个状态下的排列数量            &#125;        &#125;        return res;  &#x2F;&#x2F; 返回结果字符串    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给出集合 &lt;code&gt;[1,2,3,...,n]&lt;/code&gt;，其所有元素共有 &lt;code&gt;n!&lt;/code&gt; 种排列。&lt;/p&gt;
&lt;p&gt;按大小顺序列出所有排列情况，并一一标记，当 &lt;code&gt;n = 3&lt;/code&gt; 时, 所有排列如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;123&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;132&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;213&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;231&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;312&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;321&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;，返回第 &lt;code&gt;k&lt;/code&gt; 个排列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode22.括号生成</title>
    <link href="2023/09/07/leetcode22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>2023/09/07/leetcode22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2023-09-07T07:55:19.000Z</published>
    <updated>2023-09-07T08:22:23.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[&quot;()&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储最终结果的向量        &#x2F;&#x2F; 调用递归函数开始生成括号        generate(result, &quot;&quot;, 0, 0, n);        return result;    &#125;private:    &#x2F;&#x2F; 递归生成括号的辅助函数    void generate(vector&lt;string&gt;&amp; result, string current, int open, int close, int max) &#123;        &#x2F;&#x2F; 当前生成的括号串长度等于2 * n时，将其加入结果向量        if (current.length() &#x3D;&#x3D; 2 * max) &#123;            result.push_back(current);            return;        &#125;        &#x2F;&#x2F; 如果左括号的数量小于n，可以添加左括号        if (open &lt; max) &#123;            generate(result, current + &quot;(&quot;, open + 1, close, max);        &#125;        &#x2F;&#x2F; 如果右括号的数量小于左括号，可以添加右括号        if (close &lt; open) &#123;            generate(result, current + &quot;)&quot;, open, close + 1, max);        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1828.统计一个圆中点的数目</title>
    <link href="2023/09/07/leetcode1828-%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%9C%86%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>2023/09/07/leetcode1828-%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%9C%86%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2023-09-07T07:54:16.000Z</published>
    <updated>2023-09-07T08:04:02.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> ，表示第 <code>i</code> 个点在二维平面上的坐标。多个点可能会有 <strong>相同</strong> 的坐标。</p><p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [xj, yj, rj]</code> ，表示一个圆心在 <code>(xj, yj)</code> 且半径为 <code>rj</code> 的圆。</p><p>对于每一个查询 <code>queries[j]</code> ，计算在第 <code>j</code> 个圆 <strong>内</strong> 点的数目。如果一个点在圆的 <strong>边界上</strong> ，我们同样认为它在圆 <strong>内</strong> 。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/chrome_2021-03-25_22-34-16.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：points &#x3D; [[1,3],[3,3],[5,3],[2,2]], queries &#x3D; [[2,3,1],[4,3,1],[1,1,2]]输出：[3,2,2]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/chrome_2021-03-25_22-42-07.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：points &#x3D; [[1,1],[2,2],[3,3],[4,4],[5,5]], queries &#x3D; [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]输出：[2,3,2,4]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= points.length &lt;= 500</code></li><li><code>points[i].length == 2</code></li><li><code>0 &lt;= xi, yi &lt;= 500</code></li><li><code>1 &lt;= queries.length &lt;= 500</code></li><li><code>queries[j].length == 3</code></li><li><code>0 &lt;= xj, yj &lt;= 500</code></li><li><code>1 &lt;= rj &lt;= 500</code></li><li>所有的坐标都是整数。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接模拟</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        int pointNum &#x3D; points.size(); &#x2F;&#x2F; 点的数目        int queriesNum &#x3D; queries.size(); &#x2F;&#x2F; 圆的数目        vector&lt;int&gt; ans(queriesNum, 0);        for (int i &#x3D; 0; i &lt; queriesNum; i++) &#123;            &#x2F;&#x2F; 获取当前遍历的圆的圆心和半径            int round_x &#x3D; queries[i][0];            int round_y &#x3D; queries[i][1];            int round_r &#x3D; queries[i][2];            for (int j &#x3D; 0; j &lt; pointNum; j++) &#123;                int point_x &#x3D; points[j][0]; &#x2F;&#x2F; 获取点的坐标                int point_y &#x3D; points[j][1];                &#x2F;&#x2F; 开始判断点是否在圆内                double dx &#x3D; round_x - point_x;                double dy &#x3D; round_y - point_y;                double dis &#x3D; sqrt(dx * dx + dy * dy);                if (dis &lt;&#x3D; round_r) ++ans[i]; &#x2F;&#x2F; 如果确实在圆内，ans数组对应元素增加！            &#125;        &#125;        return ans; &#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个数组 &lt;code&gt;points&lt;/code&gt; ，其中 &lt;code&gt;points[i] = [xi, yi]&lt;/code&gt; ，表示第 &lt;code&gt;i&lt;/code&gt; 个点在二维平面上的坐标。多个点可能会有 &lt;strong&gt;相同&lt;/strong&gt; 的坐标。&lt;/p&gt;
&lt;p&gt;同时给你一个数组 &lt;code&gt;queries&lt;/code&gt; ，其中 &lt;code&gt;queries[j] = [xj, yj, rj]&lt;/code&gt; ，表示一个圆心在 &lt;code&gt;(xj, yj)&lt;/code&gt; 且半径为 &lt;code&gt;rj&lt;/code&gt; 的圆。&lt;/p&gt;
&lt;p&gt;对于每一个查询 &lt;code&gt;queries[j]&lt;/code&gt; ，计算在第 &lt;code&gt;j&lt;/code&gt; 个圆 &lt;strong&gt;内&lt;/strong&gt; 点的数目。如果一个点在圆的 &lt;strong&gt;边界上&lt;/strong&gt; ，我们同样认为它在圆 &lt;strong&gt;内&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;请你返回一个数组 &lt;code&gt;answer&lt;/code&gt; ，其中 &lt;code&gt;answer[j]&lt;/code&gt;是第 &lt;code&gt;j&lt;/code&gt; 个查询的答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode463.岛屿的周长</title>
    <link href="2023/09/05/leetcode463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>2023/09/05/leetcode463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2023-09-05T08:26:04.000Z</published>
    <updated>2023-09-05T09:43:45.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p><p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/island.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：grid &#x3D; [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]输出：16解释：它的周长是上面图片中的 16 个黄色的边</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：grid &#x3D; [[1]]输出：4</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：grid &#x3D; [[1,0]]输出：4</code></pre><p><strong>提示：</strong></p><ul><li><code>row == grid.length</code></li><li><code>col == grid[i].length</code></li><li><code>1 &lt;= row, col &lt;= 100</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力遍历</li></ul><p>思路：对每一个方格进行遍历，在当前方格为1时，将result的值增加4，接下来判断当前的方格周围的方格是否为1，如果它的下方或右方有同样是1的方格时，将res减少2（分别在当前方格和相邻方格方面的边长减去）。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int res &#x3D; 0; &#x2F;&#x2F; 初始化结果        int rows &#x3D; grid.size(); &#x2F;&#x2F; 获取行数        int cols &#x3D; grid[0].size(); &#x2F;&#x2F; 获取列数        &#x2F;&#x2F; 开始遍历        for (int i &#x3D; 0; i &lt; rows; ++i) &#123;             for (int j &#x3D; 0; j &lt; cols; ++j) &#123;                if (grid[i][j] &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果当前被遍历的方格值为1                    res +&#x3D; 4; &#x2F;&#x2F; 结果增加4                    if (i &lt; rows - 1 &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) res -&#x3D; 2; &#x2F;&#x2F; 判断当前遍历的方格的下方的方格是否也是1                    if (j &lt; cols - 1 &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) res -&#x3D; 2;&#x2F;&#x2F; 判断当前遍历的方格的右方的方格是否也是1                &#125;            &#125;        &#125;        return res; &#x2F;&#x2F; 返回结果    &#125;&#125;;</code></pre><ul><li>数学方法</li></ul><p>思路：一块土地原则上会带来 4 个周长，但岛上的土地存在接壤，每一条接壤，会减掉 2 个边长。</p><p>所以，总周长 &#x3D; 4 * 土地个数 - 2 * 接壤边的条数。</p><p>遍历矩阵，遍历到土地，就 land++，如果它的右&#x2F;下边也是土地，则 border++，遍历结束后代入公式。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int land &#x3D; 0;&#x2F;&#x2F;土地数量        int border &#x3D; 0;&#x2F;&#x2F;接壤边的条数        for (int i &#x3D; 0; i &lt; grid.size(); ++i) &#123;            for (int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123;                if (grid[i][j] &#x3D;&#x3D; 1) &#123;                    ++land;                    if (i &lt; grid.size() - 1 &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;该土地的下方有土地就说明下面这条边就是接壤边                        ++border;                    &#125;                    if (j &lt; grid[0].size() - 1 &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;该土地的右方有土地就说明右面这条边就是接壤边                        ++border;                    &#125;                &#125;            &#125;        &#125;        return 4 * land - 2 * border;    &#125;&#125;;</code></pre><ul><li>DFS</li></ul><p>思路：岛就一个，我们从第一个遇到的土地开始深搜。</p><p>对于每个土地节点，做一些事情，基于它，递归上下左右四个点，做同样的事情。做什么事情呢？</p><p>从土地到土地，之间不会产生周长，但从土地迈入海洋，之间会产生 1 个周长，从土地迈出矩阵边界，也会产生 1 个周长。</p><p>dfs 的过程中，对当前点的上下左右递归，下一个递归的点又对上下左右递归，就会造成重复访问，造成周长的重复计算。</p><p>遍历过的土地节点，将值改为 2，区分于 1 和 0，代表访问过了。</p><p>总结：DFS 从一个点，向四周扩散，目标是遇到矩阵边界或海水，它们是答案已知的 base case，是位于递归树底部的 case，是递归的终止条件。</p><p>从上而下递归调用，随着递归的出栈，子问题的解自下而上地返回，最后得出大问题的解。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        for (int i &#x3D; 0; i &lt; grid.size(); ++i) &#123;            for (int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123;                if (grid[i][j] &#x3D;&#x3D; 1) &#123;                    return dfsHelper(grid, i, j);                &#125;            &#125;        &#125;        return 0;    &#125;    int dfsHelper(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j) &#123;        int rows &#x3D; grid.size();        int cols &#x3D; grid[0].size();        if (i &lt; 0 || i &gt;&#x3D; rows || j &lt; 0 || j &gt;&#x3D; cols) &#123;            &#x2F;&#x2F;越界的情况，直接返回1            return 1;        &#125;        if (grid[i][j] &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F; 从土地到达海水            return 1;        &#125;        if (grid[i][j] &#x3D;&#x3D; 2) &#123;            &#x2F;&#x2F; 之前已经访问过这块方格了，直接返回0            return 0;        &#125;        &#x2F;&#x2F; 修改方格的值为2，说明已经来过了        grid[i][j] &#x3D; 2;        return dfsHelper(grid, i - 1, j) + dfsHelper(grid, i + 1, j) + dfsHelper(grid, i, j - 1) + dfsHelper(grid, i, j + 1);    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个 &lt;code&gt;row x col&lt;/code&gt; 的二维网格地图 &lt;code&gt;grid&lt;/code&gt; ，其中：&lt;code&gt;grid[i][j] = 1&lt;/code&gt; 表示陆地， &lt;code&gt;grid[i][j] = 0&lt;/code&gt; 表示水域。&lt;/p&gt;
&lt;p&gt;网格中的格子 &lt;strong&gt;水平和垂直&lt;/strong&gt; 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。&lt;/p&gt;
&lt;p&gt;岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode2511.最多可以摧毁的敌人城堡数目</title>
    <link href="2023/09/04/leetcode2511-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E6%91%A7%E6%AF%81%E7%9A%84%E6%95%8C%E4%BA%BA%E5%9F%8E%E5%A0%A1%E6%95%B0%E7%9B%AE/"/>
    <id>2023/09/04/leetcode2511-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E6%91%A7%E6%AF%81%E7%9A%84%E6%95%8C%E4%BA%BA%E5%9F%8E%E5%A0%A1%E6%95%B0%E7%9B%AE/</id>
    <published>2023-09-04T12:31:04.000Z</published>
    <updated>2023-09-04T12:34:17.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个长度为 <code>n</code> ，下标从 <strong>0</strong> 开始的整数数组 <code>forts</code> ，表示一些城堡。<code>forts[i]</code> 可以是 <code>-1</code> ，<code>0</code> 或者 <code>1</code> ，其中：</p><ul><li><code>-1</code> 表示第 <code>i</code> 个位置 <strong>没有</strong> 城堡。</li><li><code>0</code> 表示第 <code>i</code> 个位置有一个 <strong>敌人</strong> 的城堡。</li><li><code>1</code> 表示第 <code>i</code> 个位置有一个你控制的城堡。</li></ul><p>现在，你需要决定，将你的军队从某个你控制的城堡位置 <code>i</code> 移动到一个空的位置 <code>j</code> ，满足：</p><ul><li><code>0 &lt;= i, j &lt;= n - 1</code></li><li>军队经过的位置 <strong>只有</strong> 敌人的城堡。正式的，对于所有 <code>min(i,j) &lt; k &lt; max(i,j)</code> 的 <code>k</code> ，都满足 <code>forts[k] == 0</code> 。</li></ul><p>当军队移动时，所有途中经过的敌人城堡都会被 <strong>摧毁</strong> 。</p><p>请你返回 <strong>最多</strong> 可以摧毁的敌人城堡数目。如果 <strong>无法</strong> 移动你的军队，或者没有你控制的城堡，请返回 <code>0</code> 。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：forts &#x3D; [1,0,0,-1,0,0,0,0,1]输出：4解释：- 将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2 。- 将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：forts &#x3D; [0,0,1,-1]输出：0解释：由于无法摧毁敌人的城堡，所以返回 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= forts.length &lt;= 1000</code></li><li><code>-1 &lt;= forts[i] &lt;= 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>双指针法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int captureForts(vector&lt;int&gt;&amp; forts) &#123;        int ans &#x3D; 0, pre &#x3D; -1; &#x2F;&#x2F; 双指针        for (int i &#x3D; 0; i &lt; forts.size(); i++) &#123;            if (forts[i] &#x3D;&#x3D; 1 || forts[i] &#x3D;&#x3D; -1) &#123;                if (pre &gt;&#x3D; 0 &amp;&amp; forts[i] !&#x3D; forts[pre]) &#123; &#x2F;&#x2F; 保证i与pre指着的元素不是同一个数字                    ans &#x3D; max(ans, i - pre - 1); &#x2F;&#x2F; 更新ans                &#125;                pre &#x3D; i; &#x2F;&#x2F; 更新pre，保证i和pre之间无其他1或者-1；            &#125;        &#125;        return ans; &#x2F;&#x2F; 返回最终结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; ，下标从 &lt;strong&gt;0&lt;/strong&gt; 开始的整数数组 &lt;code&gt;forts&lt;/code&gt; ，表示一些城堡。&lt;code&gt;forts[i]&lt;/code&gt; 可以是 &lt;code&gt;-1&lt;/code&gt; ，&lt;code&gt;0&lt;/code&gt; 或者 &lt;code&gt;1&lt;/code&gt; ，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-1&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个位置 &lt;strong&gt;没有&lt;/strong&gt; 城堡。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个位置有一个 &lt;strong&gt;敌人&lt;/strong&gt; 的城堡。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个位置有一个你控制的城堡。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，你需要决定，将你的军队从某个你控制的城堡位置 &lt;code&gt;i&lt;/code&gt; 移动到一个空的位置 &lt;code&gt;j&lt;/code&gt; ，满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i, j &amp;lt;= n - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;军队经过的位置 &lt;strong&gt;只有&lt;/strong&gt; 敌人的城堡。正式的，对于所有 &lt;code&gt;min(i,j) &amp;lt; k &amp;lt; max(i,j)&lt;/code&gt; 的 &lt;code&gt;k&lt;/code&gt; ，都满足 &lt;code&gt;forts[k] == 0&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当军队移动时，所有途中经过的敌人城堡都会被 &lt;strong&gt;摧毁&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;请你返回 &lt;strong&gt;最多&lt;/strong&gt; 可以摧毁的敌人城堡数目。如果 &lt;strong&gt;无法&lt;/strong&gt; 移动你的军队，或者没有你控制的城堡，请返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="双指针" scheme="tags/双指针/"/>
    
  </entry>
  
  <entry>
    <title>leetcode940.不同的子序列II</title>
    <link href="2023/09/01/leetcode940-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97II/"/>
    <id>2023/09/01/leetcode940-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97II/</id>
    <published>2023-09-01T08:36:44.000Z</published>
    <updated>2023-09-01T08:44:12.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code>，计算 <code>s</code> 的 <strong>不同非空子序列</strong> 的个数。因为结果可能很大，所以返回答案需要对 <strong><code>10^9 + 7</code> 取余</strong> 。</p><p>字符串的 <strong>子序列</strong> 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;***a***b***c***d***e***&quot;</code> 的一个子序列，但 <code>&quot;aec&quot;</code> 不是。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abc&quot;输出：7解释：7 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, 以及 &quot;abc&quot;。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;aba&quot;输出：6解释：6 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;aa&quot; 以及 &quot;aba&quot;。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;aaa&quot;输出：3解释：3 个不同的子序列分别是 &quot;a&quot;, &quot;aa&quot; 以及 &quot;aaa&quot;。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>思路：</p><p><img src="http://cdn.leafii.top/img/image-20230901164319947.png" alt="**image-20230901164319947**" loading="lazy"></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int distinctSubseqII(string s) &#123;        vector&lt;int&gt; last(26, -1);                int n &#x3D; s.size();        vector&lt;int&gt; f(n, 1);        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            for (int j &#x3D; 0; j &lt; 26; ++j) &#123;                if (last[j] !&#x3D; -1) &#123;                    f[i] &#x3D; (f[i] + f[last[j]]) % mod;                &#125;            &#125;            last[s[i] - &#39;a&#39;] &#x3D; i;        &#125;                int ans &#x3D; 0;        for (int i &#x3D; 0; i &lt; 26; ++i) &#123;            if (last[i] !&#x3D; -1) &#123;                ans &#x3D; (ans + f[last[i]]) % mod;            &#125;        &#125;        return ans;    &#125;private:    static constexpr int mod &#x3D; 1000000007;&#125;;</code></pre><hr><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/distinct-subsequences-ii/solutions/1888523/bu-tong-de-zi-xu-lie-ii-by-leetcode-solu-k2h5/">https://leetcode.cn/problems/distinct-subsequences-ii/solutions/1888523/bu-tong-de-zi-xu-lie-ii-by-leetcode-solu-k2h5/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt;，计算 &lt;code&gt;s&lt;/code&gt; 的 &lt;strong&gt;不同非空子序列&lt;/strong&gt; 的个数。因为结果可能很大，所以返回答案需要对 &lt;strong&gt;&lt;code&gt;10^9 + 7&lt;/code&gt; 取余&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;字符串的 &lt;strong&gt;子序列&lt;/strong&gt; 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;***a***b***c***d***e***&amp;quot;&lt;/code&gt; 的一个子序列，但 &lt;code&gt;&amp;quot;aec&amp;quot;&lt;/code&gt; 不是。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
  <entry>
    <title>leetcode522.最长特殊序列II</title>
    <link href="2023/08/31/leetcode522-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97II/"/>
    <id>2023/08/31/leetcode522-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97II/</id>
    <published>2023-08-31T01:22:21.000Z</published>
    <updated>2023-08-31T01:28:34.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定字符串列表 <code>strs</code> ，返回其中 <strong>最长的特殊序列</strong> 的长度。如果最长特殊序列不存在，返回 <code>-1</code> 。</p><p><strong>特殊序列</strong> 定义如下：该序列为某字符串 <strong>独有的子序列（即不能是其他字符串的子序列）</strong>。</p><p> <code>s</code> 的 <strong>子序列</strong>可以通过删去字符串 <code>s</code> 中的某些字符实现。</p><ul><li>例如，<code>&quot;abc&quot;</code> 是 <code>&quot;aebdc&quot;</code> 的子序列，因为您可以删除<code>&quot;aebdc&quot;</code>中的下划线字符来得到 <code>&quot;abc&quot;</code> 。<code>&quot;aebdc&quot;</code>的子序列还包括<code>&quot;aebdc&quot;</code>、 <code>&quot;aeb&quot;</code> 和 “” (空字符串)。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;aba&quot;,&quot;cdc&quot;,&quot;eae&quot;]输出: 3</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;aaa&quot;,&quot;aaa&quot;,&quot;aa&quot;]输出: -1</code></pre><p><strong>提示:</strong></p><ul><li><code>2 &lt;= strs.length &lt;= 50</code></li><li><code>1 &lt;= strs[i].length &lt;= 10</code></li><li><code>strs[i]</code> 只包含小写英文字母</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><ol><li>首先，我们需要对字符串数组进行排序，将较长的字符串排在前面。这是因为如果一个字符串是另一个字符串的子序列，那么较长的字符串必定不能成为特殊序列。</li><li>排序之后，我们遍历每个字符串，判断它是否是特殊序列。我们需要检查当前字符串是否在剩余的字符串中存在子序列。</li><li>对于每个字符串，我们逐个比较它与剩余字符串的关系。如果当前字符串不是任何其他字符串的子序列，那么它就是一个特殊序列。</li><li>我们只需要返回最长的特殊序列的长度即可。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    &#x2F;&#x2F; 判断字符串a是否是字符串b的子序列    bool isSubsequence(const string&amp; a, const string&amp; b) &#123;        int i &#x3D; 0, j &#x3D; 0;        while (i &lt; a.size() &amp;&amp; j &lt; b.size()) &#123;            if (a[i] &#x3D;&#x3D; b[j]) &#123;                i++;            &#125;            j++;        &#125;        return i &#x3D;&#x3D; a.size();    &#125;    &#x2F;&#x2F; 找到最长特殊序列的长度    int findLUSlength(vector&lt;string&gt;&amp; strs) &#123;        &#x2F;&#x2F; 根据字符串长度排序，较长的字符串排在前面        sort(strs.begin(), strs.end(), [](const string&amp; a, const string&amp; b) &#123;            return a.size() &gt; b.size();        &#125;);        for (int i &#x3D; 0; i &lt; strs.size(); ++i) &#123;            bool is_special &#x3D; true;            for (int j &#x3D; 0; j &lt; strs.size(); ++j) &#123;                if (i !&#x3D; j &amp;&amp; isSubsequence(strs[i], strs[j])) &#123;                    is_special &#x3D; false;                    break;                &#125;            &#125;            if (is_special) &#123;                return strs[i].size();            &#125;        &#125;                return -1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定字符串列表 &lt;code&gt;strs&lt;/code&gt; ，返回其中 &lt;strong&gt;最长的特殊序列&lt;/strong&gt; 的长度。如果最长特殊序列不存在，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特殊序列&lt;/strong&gt; 定义如下：该序列为某字符串 &lt;strong&gt;独有的子序列（即不能是其他字符串的子序列）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;s&lt;/code&gt; 的 &lt;strong&gt;子序列&lt;/strong&gt;可以通过删去字符串 &lt;code&gt;s&lt;/code&gt; 中的某些字符实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt; 的子序列，因为您可以删除&lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt;中的下划线字符来得到 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 。&lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt;的子序列还包括&lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt;、 &lt;code&gt;&amp;quot;aeb&amp;quot;&lt;/code&gt; 和 “” (空字符串)。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
  <entry>
    <title>leetcode300.最长递增子序列</title>
    <link href="2023/08/30/leetcode300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>2023/08/30/leetcode300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2023-08-30T08:26:25.000Z</published>
    <updated>2023-08-30T09:49:50.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,0,3,2,3]输出：4</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [7,7,7,7,7,7,7]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>n2复杂度动态规划</li></ul><p>解题思路：</p><ol><li>dp[i]:以nums[i]为结尾的最长递增子序列的长度</li><li>递推公式：max(dp[i],dp[j]+1),</li><li>dp[i]至少为1（初始化条件）</li><li>遍历顺序：i从小到大 j从大到小，从小到大都可以（0到i之间的每一个元素）</li><li>最终返回dp数组中的最大值</li></ol><p><img src="http://cdn.leafii.top/img/image-20230830164100634.png" alt="image-20230830164100634" loading="lazy"></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n &#x3D;&#x3D; 0) return 0;        vector&lt;int&gt; dp(n, 1); &#x2F;&#x2F; 初始化dp数组，每个元素默认长度为1        for (int i &#x3D; 0; i &lt; n; i++) &#123;            for (int j &#x3D; 0; j &lt; i; j++) &#123;                if (nums[i] &gt; nums[j]) &#123;                    dp[i] &#x3D; max(dp[i], dp[j] + 1); &#x2F;&#x2F; dp数组的更新                &#125;            &#125;        &#125;        return *max_element(dp.begin(), dp.end());    &#125;&#125;;</code></pre><ul><li>n log(n)复杂度贪心</li></ul><p>交换状态与状态值</p><p>令g[i]表示长度为i+1的IS的末尾元素的最小值 </p><p><img src="http://cdn.leafii.top/img/image-20230830172521363.png" alt="image-20230830172521363" loading="lazy"></p><p>g是严格递增的。</p><p>推论1:一次只能更新一个位置，单调递增序列不能有相同元素。</p><p>推论2:更新的位置是第一个大于等于nums[i]的数的下标。</p><p>算法：在g上用二分查找快速找到第一个大于等于nums[i]的下标j。如果j不存在，那么nums[i]直接加到g末尾;否则修改g[j]为nums[i].</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; tails; &#x2F;&#x2F; 用于存储递增子序列的末尾元素        for (int num : nums) &#123;            &#x2F;&#x2F; lower_bound 返回一个迭代器，指向容器中第一个大于等于给定值的元素。            auto it &#x3D; lower_bound(tails.begin(), tails.end(), num); &#x2F;&#x2F; 在 tails 中寻找第一个大于等于 num 的元素            if (it &#x3D;&#x3D; tails.end()) &#123;                tails.push_back(num); &#x2F;&#x2F; 如果找不到，则将 num 添加到末尾            &#125; else &#123;                *it &#x3D; num; &#x2F;&#x2F; 否则，更新找到的元素，因为它可以作为更长递增子序列的末尾元素            &#125;        &#125;        return tails.size(); &#x2F;&#x2F; 返回 tails 数组的长度，即为结果    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到其中最长严格递增子序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子序列&lt;/strong&gt; 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，&lt;code&gt;[3,6,2,7]&lt;/code&gt; 是数组 &lt;code&gt;[0,3,1,6,2,2,7]&lt;/code&gt; 的子序列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
  <entry>
    <title>leetcode521.最长特殊序列I</title>
    <link href="2023/08/30/leetcode521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97I/"/>
    <id>2023/08/30/leetcode521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97I/</id>
    <published>2023-08-30T08:20:02.000Z</published>
    <updated>2023-08-30T08:26:49.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串 <code>a</code> 和 <code>b</code>，请返回 <em>这两个字符串中 <strong>最长的特殊序列</strong></em> 的长度。如果不存在，则返回 <code>-1</code> 。</p><p><strong>「最长特殊序列」</strong> 定义如下：该序列为 <strong>某字符串独有的最长子序列（即不能是其他字符串的子序列）</strong> 。</p><p>字符串 <code>s</code> 的子序列是在从 <code>s</code> 中删除任意数量的字符后可以获得的字符串。</p><ul><li>例如，<code>&quot;abc&quot;</code> 是 <code>&quot;aebdc&quot;</code> 的子序列，因为删除 <code>&quot;a***e***b***d\***c&quot;</code> 中斜体加粗的字符可以得到 <code>&quot;abc&quot;</code> 。 <code>&quot;aebdc&quot;</code> 的子序列还包括 <code>&quot;aebdc&quot;</code> 、 <code>&quot;aeb&quot;</code> 和 <code>&quot;&quot;</code> (空字符串)。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入: a &#x3D; &quot;aba&quot;, b &#x3D; &quot;cdc&quot;输出: 3解释: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;)，两者均为自身的子序列且不是对方的子序列。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：a &#x3D; &quot;aaa&quot;, b &#x3D; &quot;bbb&quot;输出：3解释: 最长特殊序列是 &quot;aaa&quot; 和 &quot;bbb&quot; 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：a &#x3D; &quot;aaa&quot;, b &#x3D; &quot;aaa&quot;输出：-1解释: 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a.length, b.length &lt;= 100</code></li><li><code>a</code> 和 <code>b</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><p>首先，我们判断两个字符串是否相等。如果相等，那么它们之间不存在特殊序列，直接返回-1。</p><p>如果两个字符串不相等，那么其中一个字符串肯定不是另一个字符串的子序列。因此，我们只需返回较长字符串的长度作为最长特殊序列的长度。这是因为如果较长字符串的长度都不是另一个字符串的子序列，那么较短的字符串也不可能是另一个字符串的子序列。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findLUSlength(string a, string b) &#123;        &#x2F;&#x2F; 如果两个字符串相等，则没有特殊序列        if (a &#x3D;&#x3D; b) &#123;            return -1;        &#125;        &#x2F;&#x2F; 返回较长字符串的长度作为最长特殊序列的长度        return max(a.length(), b.length());    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，请返回 &lt;em&gt;这两个字符串中 &lt;strong&gt;最长的特殊序列&lt;/strong&gt;&lt;/em&gt; 的长度。如果不存在，则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「最长特殊序列」&lt;/strong&gt; 定义如下：该序列为 &lt;strong&gt;某字符串独有的最长子序列（即不能是其他字符串的子序列）&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;字符串 &lt;code&gt;s&lt;/code&gt; 的子序列是在从 &lt;code&gt;s&lt;/code&gt; 中删除任意数量的字符后可以获得的字符串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt; 的子序列，因为删除 &lt;code&gt;&amp;quot;a***e***b***d\***c&amp;quot;&lt;/code&gt; 中斜体加粗的字符可以得到 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 。 &lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt; 的子序列还包括 &lt;code&gt;&amp;quot;aebdc&amp;quot;&lt;/code&gt; 、 &lt;code&gt;&amp;quot;aeb&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; (空字符串)。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
  <entry>
    <title>leetcode674.最长连续递增序列</title>
    <link href="2023/08/30/leetcode674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <id>2023/08/30/leetcode674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</id>
    <published>2023-08-30T08:13:58.000Z</published>
    <updated>2023-08-30T08:26:57.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2], 长度为1。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>直接看代码</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n &#x3D;&#x3D; 0) &#123;            return 0;        &#125;                int maxLength &#x3D; 1; &#x2F;&#x2F; 初始化最大长度为1，因为至少有一个元素存在        int currentLength &#x3D; 1; &#x2F;&#x2F; 当前递增序列的长度，初始为1        for (int i &#x3D; 1; i &lt; n; ++i) &#123;            if (nums[i] &gt; nums[i - 1]) &#123;                currentLength++; &#x2F;&#x2F; 如果当前元素大于前一个元素，则当前递增序列长度加一                maxLength &#x3D; max(maxLength, currentLength); &#x2F;&#x2F; 更新最大长度            &#125; else &#123;                currentLength &#x3D; 1; &#x2F;&#x2F; 重置当前递增序列长度为1，因为递增中断            &#125;        &#125;                return maxLength;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个未经排序的整数数组，找到最长且 &lt;strong&gt;连续递增的子序列&lt;/strong&gt;，并返回该序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连续递增的子序列&lt;/strong&gt; 可以由两个下标 &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;r&lt;/code&gt;（&lt;code&gt;l &amp;lt; r&lt;/code&gt;）确定，如果对于每个 &lt;code&gt;l &amp;lt;= i &amp;lt; r&lt;/code&gt;，都有 &lt;code&gt;nums[i] &amp;lt; nums[i + 1]&lt;/code&gt; ，那么子序列 &lt;code&gt;[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]&lt;/code&gt; 就是连续递增子序列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
    <category term="序列" scheme="tags/序列/"/>
    
  </entry>
  
</feed>
