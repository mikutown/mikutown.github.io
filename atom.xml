<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeafiiのBlog</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="https://leafii.top/"/>
  <updated>2023-02-03T09:12:13.770Z</updated>
  <id>https://leafii.top/</id>
  
  <author>
    <name>Leafii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode:37.解数独</title>
    <link href="2023/02/03/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>2023/02/03/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/</id>
    <published>2023-02-03T06:58:10.000Z</published>
    <updated>2023-02-03T09:12:13.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</code></pre><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>我们可以考虑按照「行优先」的顺序依次枚举每一个空白格中填的数字，通过递归 + 回溯的方法枚举所有可能的填法。当递归到最后一个空白格后，如果仍然没有冲突，说明我们找到了答案；在递归的过程中，如果当前的空白格不能填下任何一个数字，那么就进行回溯。</p><p>由于每个数字在同一行、同一列、同一个九宫格中只会出现一次，因此我们可以使用<code>line[i]，column[j]，block[x][y]</code>分别表示第 i 行，第 j 列，第(x,y) 个九宫格中填写数字的情况。在下面给出的三种方法中，我们将会介绍两种不同的表示填写数字情况的方法。</p><blockquote><p>九宫格的范围为 $0 \leq x \leq 2$以及 $0 \leq y \leq 2$。 具体地，第 i 行第 j 列的格子位于第$(\lfloor i&#x2F;3 \rfloor, \lfloor j&#x2F;3 \rfloor)$个九宫格中，其中$\lfloor u \rfloor$表示对 u 向下取整。</p></blockquote><ol><li>回溯法</li></ol><p><strong>思路</strong>：最容易想到的方法是用一个数组记录每个数字是否出现。由于我们可以填写的数字范围为[1,9]，而数组的下标从 0 开始，因此在存储时，我们使用一个长度为 9 的布尔类型的数组，其中 i 个元素的值为 $\text{True}$，当且仅当数字i+1 出现过。例如我们用 $\textit{line}[2][3] &#x3D; \text{True}$ 表示数字 4 在第 2 行已经出现过，那么当我们在遍历到第 2 行的空白格时，就不能填入数字 4。</p><p><strong>算法</strong>：</p><p>首先对整个数独数组进行遍历，当我们遍历到第i行第j列时：</p><ul><li>若该位置是一个空白格，那么我们将其加入一个用来存储空白格位置的列表中，方便后续的递归操作；</li><li>若该位置是一个数字x，那么我们需要将<code>line[i][x-1],column[j][x-1]</code>以及<code>block[i/3][j/3][x-1]</code>都置为True。</li></ul><p>当我们结束了遍历过程之后，就可以开始递归枚举。当递归到第 $i$ 行第 $j$ 列的位置时，我们枚举填入的数字 $x$。根据题目的要求，数字 $x$ 不能和当前行、列、九宫格中已经填入的数字相同，因此 $line[i][x-1]$，$\textit{column}[j][x-1]$以及 $\textit{block}[\lfloor i&#x2F;3 \rfloor][\lfloor j&#x2F;3 \rfloor][x-1]$ 必须均为 $\text{False}$。</p><p>当我们填入了数字 $x$ 之后，我们要将上述的三个值都置为 $\text{True}$，并且继续对下一个空白格位置进行递归。在回溯到当前递归层时，我们还要将上述的三个值重新置为 $\text{False}$。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    bool line[9][9];    bool column[9][9];    bool block[3][3][9];    bool valid;    vector&lt;pair&lt;int, int&gt;&gt; spaces;public:    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;        if (pos &#x3D;&#x3D; spaces.size()) &#123;            valid &#x3D; true;            return;        &#125;        auto [i, j] &#x3D; spaces[pos]; &#x2F;&#x2F;获取空位位置        for (int digit &#x3D; 0; digit &lt; 9 &amp;&amp; !valid; ++digit) &#123;            if (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i &#x2F; 3][j &#x2F; 3][digit]) &#123;                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;填符合条件的数字                board[i][j] &#x3D; digit + &#39;0&#39; + 1;                dfs(board, pos + 1); &#x2F;&#x2F;递归                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; false; &#x2F;&#x2F;回溯            &#125;        &#125;    &#125;    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        memset(line, false, sizeof(line));        memset(column, false, sizeof(column));        memset(block, false, sizeof(block));        valid &#x3D; false;        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;                    spaces.emplace_back(i, j); &#x2F;&#x2F;initialize                &#125;                else &#123;                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;                    line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;initialize                &#125;            &#125;        &#125;        dfs(board, 0); &#x2F;&#x2F;从头开始求解，最后得到填满数字的board    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/">https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;数独的解法需 &lt;strong&gt;遵循如下规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 &lt;code&gt;1-9&lt;/code&gt; 在每一个以粗实线分隔的 &lt;code&gt;3x3&lt;/code&gt; 宫内只能出现一次。（请参考示例图）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数独部分空格内已填入了数字，空白格用 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 表示。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:198.打家劫舍</title>
    <link href="2023/02/03/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>2023/02/03/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2023-02-03T06:32:26.000Z</published>
    <updated>2023-02-03T06:57:41.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>动态规划分析如下：</p><ol><li>确定dp数组(dp table)以及它的下标的含义：</li></ol><p>dp[i]:考虑下标i以内的房屋，最多可以偷窃的金额为dp[i];</p><ol start="2"><li>确定递推公式</li></ol><p>决定是否偷第i个房间:</p><ul><li>如果偷第i个房间，dp[i] &#x3D; dp[i - 2] + nums[i];</li></ul><p>也就是不偷第i-1，而是找到i-2以内最多的房屋，然后再加上第i间房偷到的钱。</p><ul><li>如果不偷第i个房间，那么dp[i] &#x3D; dp[i - 1];也就是要考虑i-1房（<strong>注意这里是考虑而不是真的要偷i-1房</strong>）</li></ul><p>完成分析后取dp[i]的最大值，也就是dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>因为dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);所以基础就是dp[0]和dp[1];</p><p>因此dp[0] &#x3D; nums[0],dp[1] &#x3D; max(nums[0], nums[1]);</p><ol start="4"><li>确定遍历顺序</li></ol><p>dp[i]是根据dp[i-2]和dp[i-1]推导出来的，那么一定是从前到后遍历。</p><ol start="5"><li>举例推导dp数组</li></ol><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        if(nums.empty()) &#123;            return 0;        &#125;        int size &#x3D; nums.size();        if(size &#x3D;&#x3D; 1) &#123;            return nums[0];        &#125;        vector&lt;int&gt; dp &#x3D; vector&lt;int&gt;(size, 0); &#x2F;&#x2F;3. initialize        dp[0] &#x3D; nums[0];        dp[1] &#x3D; max(nums[0], nums[1]);        &#x2F;&#x2F;4. 遍历        for(int i &#x3D; 2; i &lt; size; i++) &#123;            dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);        &#125;        return dp[size - 1];    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 &lt;strong&gt;不触动警报装置的情况下&lt;/strong&gt; ，一夜之内能够偷窃到的最高金额。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:53.最大子数组和</title>
    <link href="2023/02/02/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>2023/02/02/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</id>
    <published>2023-02-02T06:40:12.000Z</published>
    <updated>2023-02-02T07:08:58.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1]输出：1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [5,4,-1,7,8]输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>可以很容易想到$f(i) &#x3D; max{f(i-1) + nums[i], nums[i]}$.C++实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int pre &#x3D; 0, maxAns &#x3D; nums[0];        for (const auto &amp;x: nums) &#123;            pre &#x3D; max(pre + x, x);            maxAns &#x3D; max(maxAns, pre);        &#125;        return maxAns;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:70.爬楼梯</title>
    <link href="2023/02/01/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>2023/02/01/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2023-02-01T06:48:43.000Z</published>
    <updated>2023-02-02T16:52:25.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归</li></ol><p>很明显，该问题可以用$f(x) &#x3D; f(x - 1) + f(x - 2)$并且很容易得知$f(0) &#x3D; 1;f(1) &#x3D; 1;f(2) &#x3D; 2$,但是直接写递归(<code>return climbStairs(n - 1) + climbStairs(n - 2)</code>)会导致时间超限，在这里使用「滚动数组思想」把空间复杂度优化成 $O(1)$。</p><p><img src="http://cdn.leafii.top/img/70_fig1.gif" alt="fig1" loading="lazy"></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int climbStairs(int n) &#123;        int p &#x3D; 0, q &#x3D; 0, r &#x3D; 1;        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;            p &#x3D; q;             q &#x3D; r;             r &#x3D; p + q;        &#125;        return r;    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/">https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/</a> </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning</title>
    <link href="2023/02/01/Flexible%20Job-Shop%20Scheduling%20via%20Graph%20Neural%20Network%20and%20Deep%20Reinforcement%20Learning/"/>
    <id>2023/02/01/Flexible%20Job-Shop%20Scheduling%20via%20Graph%20Neural%20Network%20and%20Deep%20Reinforcement%20Learning/</id>
    <published>2023-02-01T06:46:17.000Z</published>
    <updated>2023-02-02T16:44:38.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度"><a href="#Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度" class="headerlink" title="Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度"></a>Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>本文考虑了众所周知的灵活作业车间调度问题，并通过提出一种新颖的 DRL 方法来端到端地学习高质量的 PDR 来解决这些问题。操作选择和机器分配被组合为一个复合决策。此外，基于一种新颖的调度状态异构图表示，提出了一种基于异构图神经网络的体系结构来捕获操作和机器之间的复杂关系。</p><span id="more"></span><ul><li><strong>背景</strong></li></ul><p>本文聚焦柔性车间调度问题(FJSP)，FJSP 允许在任何机器上处理一组可选机器的操作，因此更适合处理新制造范例（例如云制造）中任务-资源关系的灵活性和多样性。</p><p>JSP本来就是NP-hard问题，FJSP问题一般使用启发式方法，为效率牺牲最优性。优先调度规则 (PDR)是一种比较知名并且实践性强的启发式方法，它根据一些优先级规则 [例如，先进先出 (FIFO)] 将作业迭代地分配给机器。与元启发式相比，PDR 直观、易于实现且计算速度非常快，使其更适合处理云制造中的问题，这些问题通常是大规模的，甚至是动态的。</p><ul><li><strong>提出问题</strong></li></ul><p>PDR调度结果远非最优。原因如下：</p><ol><li>施工过程基于优先措施是贪婪的，这可能是短视的。</li><li>决策主要基于每个步骤中符合条件的工作和机器的信息，而全局信息在很大程度上被忽略了。</li><li>目前的PDR主要是根据人类经验设计的，通常不能保证最优性，缺乏适应特定问题和情况的能力</li></ol><p>因此，在这个方向上，最近的一些工作尝试以端到端的方式使用 DRL 自动生成用于调度问题的 PDR，但他们都只关注于非柔性的JSP问题，因为要通过该方式改良FJSP问题的调度有两个重大挑战：</p><ol><li>FJSP 中的决策更加复杂，不仅有操作选择，还有机器分配</li><li>由于操作和机器之间复杂的一对多关系，调度状态可能更难使用神经网络进行编码。</li></ol><p>因此，需要研究的问题就是：</p><ol><li>如何制定调度流程以纳入机器分配</li><li>如何设计表示方案和神经架构以从原始调度状态中提取有用信息。</li></ol><ul><li><strong>解决思路</strong></li></ul><ol><li>本文提出了一种基于 PDR 的 FJSP 调度的 MDP 公式，其中一个动作是选择一个符合条件的操作-机器（O-M）对，以便可以同时做出操作选择和机器分配决策。</li><li>通过用机器节点扩展 FJSP 的析取图，本文提出了一种新颖的异构图结构来表示 MDP 状态，从而可以捕获操作和机器之间的复杂关系。此外，提出了一种两阶段图神经网络（GNN）来获得异构图中节点的特征嵌入，在此基础上使用近端策略优化（PPO）设计和训练策略网络。</li><li>与现有的基于DRL的调度方法中使用的GNN不同，本文中提出的 GNN 适用于专用于 FJSP 的异构图，它不仅捕获操作的状态，还捕获机器和 O-M 关系的状态</li></ol><ul><li><strong>实验结果</strong></li></ul><p>在合成实例和公共基准上进行了广泛的实验。结果表明，在保持高计算效率的同时，所提出的方法可以优于传统的手工 PDR，并有效地泛化到训练中未见过的更大规模的问题和公共基准。</p><p>除了方法上的新颖性外，所提出的方法还具有良好的实用价值。它的神经结构与大小无关；因此，经过训练的策略可以应用于解决不同大小的实例，而不仅仅是训练大小。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>在每次迭代过程中，调度状态首先转化为异构图结构。然后，将具有两阶段嵌入过程的 HGNN 应用于异构图，以提取操作和机器的特征嵌入，决策网络使用这些嵌入来生成动作概率分布，从中采样调度操作。</p><h4 id="MDP-Formulation"><a href="#MDP-Formulation" class="headerlink" title="MDP Formulation"></a>MDP Formulation</h4><p>调度过程：在每个决策步骤t(时间为0或操作完成时)，agent观察当前系统状态$s_t$并做出决策$a_t$,该决策分配一个未调度的操作给空闲的机器，并从当前时间开始，记为$T(t)$.然后，环境过渡到下一个决策步骤$t+1$。该过程迭代直到所有操作都被调度。</p><ul><li><p>状态（State）：在第t步的所有操作和机器的状态构成了状态$s_t$</p></li><li><p>动作（Action）：本文中的动作将操作选择和机器分配结合为一个复合决策。具体来说，一个动作$a_t \in A_t$被定义为在第t步的一个可行的O-M对$(O_{ij}, M_K)$，其中的$O_{ij}$是可行的operation，$M_k$是空闲的机器。</p></li><li><p>状态转移(Transition)：基于$s_t$和$a_t$，环境确定性的过渡到新状态$s_{t+1}$，这是操作完成的时间。在本文中，两种不同的状态由异构图的拓扑和特征来区分。</p></li><li><p>奖励(Reward)：奖励定义为部分调度在 $s_t$ 和 $s_{t+1}$ 的完工时间之差，如$r(s_t, a_t, s_{t+1}) &#x3D; C_{max}(s_t) - C_{max}(s_{t+1}))$.若折扣因子$\gamma &#x3D; 1$时，一次求解过程中的累计奖励可以被记为$G &#x3D; \sum_{t&#x3D;0}^{|O|}r(s-t, a_t,s_{t+1}) &#x3D; C_{max}(s_0) - C_{max}$.对于一个特定的问题实例，$C_{max}(s0)$ 是一个常数，这意味着最小化 $C_{max}$ 和最大化 $G$是等价的。</p></li><li><p>策略(Policy):策略 $π(a_t|s_t)$ 为每个状态 $s_t$ 定义了动作集 $A_t$ 上的概率分布。接下来，本文将设计一个 DRL 算法，将 π 参数化为神经网络，并朝着最大化预期累积奖励的方向对其进行优化。</p></li></ul><h4 id="Heterogeneous-Graph"><a href="#Heterogeneous-Graph" class="headerlink" title="Heterogeneous Graph"></a>Heterogeneous Graph</h4><p>用析取图表示FJSP调度更复杂的原因：</p><ol><li>由于多台机器处理operation，析取弧集合D会明显变得更大。所以这种密集的图很难被有效处理。</li><li>一个操作在不同兼容机器上的处理时间是不同的，很难表示。</li></ol><p>为了解决上述问题，本文通过修改析取图结构，定义了一个新颖的异构图结构$H &#x3D; (O,M,C,E)$。如图所示，操作结点集合O和合取弧集C，增加了一组机器节点M，每个节点对应一台机器$M_k$。原本的析取弧集D由O-M弧集E替换。每个元素$E_{ijk} \in E$是一个将操作结点$O_{ij}$和兼容机器节点$M_k$连接起来的无向的弧。</p><p>该异构图结构拥有以下优点：</p><ol><li>图密度显着降低。</li><li>H 中的机器节点提供了一种方便的方式来注入机器信息并提取有用的特征以区分状态中的不同机器。</li><li>处理时间 $p_{ijk}$ 可以通过简单地附加为 $O-M$ 弧 $E_{ijk}$ 的特征来轻松表示。</li></ol><p>定义异构图之后，每一个状态$s_t$可以由异构图$H_t &#x3D; (O, M, C, E_t)$表示，其中$E_t$在求解过程中动态变化。具体来说：在第t步采取一个动作$(O_{ij},M_k)$后，只保留$E_{ijk}$，去掉$O_{ij}$的其他$O-M$弧，得到$H_{t+1}$。因此，节点之间的相邻关系也会动态变化。</p><p>在每个步骤t，定义$N_t(O_{ij})$ 是操作 $O_{ij}$ 的相邻机器，$N_t(M_k)$ 是机器 $M_k$ 的相邻操作。</p><h4 id="Heterogeneous-Graph-Neural-Network"><a href="#Heterogeneous-Graph-Neural-Network" class="headerlink" title="Heterogeneous Graph Neural Network"></a>Heterogeneous Graph Neural Network</h4><p>作为组合问题中的典型，FJSP 实例具有不同的大小。要使用 DRL 学习实用的调度策略，神经架构必须能够在不同大小的状态图上运行。之前的一些工作表明GNN可以用于实现大小不可知的特性，然而它们都是对齐次图（Homogenous graph）进行处理的，在这里不可用。目前提出的HGNN都没有考虑到FJSP的异构图$H_t$，原因如下：</p><ol><li>首先，$H_t$ 中的不同节点类型具有很强的连接模式。任何机器的邻居只能是通过无向弧连接的操作，而操作可以通过有向或无向弧连接到操作和机器。</li><li>O-M 弧上的特征（即处理时间）对于解决 FJSP 非常重要。</li></ol><p>然而，现有的 HGNN 通常只关注节点特征，不考虑弧特征。</p><p>为了利用异构图结构的特性和优势，本文提出了一种为 FJSP 定制的新型 HGNN 架构，以有效地编码 $H_t$.如图所示：</p><p><img src="http://cdn.leafii.top/img/image-20230202204228094.png" alt="image-20230202204228094" loading="lazy"></p><p>所提出的方法具有两阶段嵌入过程的特点，以便将图的拓扑和数值信息（原始特征）考虑在内，并将 $H_t$ 中的节点映射到$ d$ 维嵌入。</p><p>在第一阶段，机器嵌入$ ν′<em>k \in \R^d$ 通过聚合相关信息更新，而操作嵌入 $μ′</em>{ij} \in \R^d$ 在第二阶段更新。详情如下.</p><h5 id="Machine-Node-Embedding"><a href="#Machine-Node-Embedding" class="headerlink" title="Machine Node Embedding:"></a>Machine Node Embedding:</h5><p>在 $H_t$ 中，机器 $M_k$ 的邻居是一组操作 $N_t(M_k)$，它可能对 $M_k$ 有不同的含义。例如，预计较早开始的操作可能比较晚开始的操作更重要。这促使我们考虑图形注意力网络（GAT）,它通过应用注意力机制自动学习不同节点的重要性.对于齐次图，给定具有特征 $x_i$ 的节点 $i$，GAT 首先计算 $i$ 和其一阶邻域 $N(i)$（包括 $i$ 本身）中的每个$j$ 之间的注意系数 $e_{ij}$（标量）为$e_{ij}&#x3D;LeakyReLU(a^T[W_{x_i}||W_{x_j}])$.</p><p>换句话说，$x_i$ 和 $x_j$ 首先由共享线性变换 $W$ 处理，然后连接 $(||)$ 并馈入具有权重 a 和 LeakyReLU 激活的单层前馈神经网络。然后，使用 softmax 函数对邻域内的系数进行归一化:$\alpha_{ij}&#x3D;\frac{exp(e_{ij})}{\sum_{q\in N(i)exp(e_{iq})}} \forall j\in N(i)$</p><p>最终，GAT 在 $N (i)$ 上聚合（线性变换）特征并应用非线性 $\sigma$ 来获得 $i$ 的嵌入:$x’<em>i &#x3D; \sigma(\sum</em>{j \in N(i)}\alpha_{ij}W_{x_j})$.</p><p><strong>但是</strong>原来的GAT只是针对齐次图的，没有考虑弧特征。在这里，为了满足本文的需要（即计算相邻操作对机器的重要性）.</p><ol><li>可以观察到，对于每个机器 $M_k$，只有一个$O-M$ 弧将其与相邻操作连接起来。因此，每个 $O_{ij} \in N_t(M_k)$ 的原始特征向量通过将其原始原始特征与相应 O-M 弧的原始特征连接起来扩展为 $\mu_{ijk} &#x3D;[\mu_{ij}||\lambda_{ijk}] \in \R^7$.</li><li>在这里，两个线性变换 $W^M \in \R^{d×3}$ 和 $W^O \in \R^{d × 7}$ 分别用于机器和操作节点，而不是使用共享的。</li><li>对于机器 $M_k$，注意系数 $e_{ijk}$，即每个相邻操作的重要性 $O_{ij} \in N_t(M_k)$，可以计算为:$e_{ijk} &#x3D; LeakyReLU(a^T[W^Mv_k||W^O\mu_{ijk}])$,其中$a\in \R^{2d}$。</li></ol><p>通过这种方式，来自异构节点和 O-M 弧的信息可以有效地纳入注意力计算。</p><p>上面的式子中有一件事情未被考虑：原始GAT中涉及的机器$M_k$对自身的注意力系数。这里，$e_{kk}$ 是使用机器特定权重 $W^M$ 计算的，如下所示：$e_{kk} &#x3D; LeakyReLU(a^T[W^M_{V_k}||W^M_{v_k}])$.</p><p>所有 $e_{ijk} \forall O_{ij} \in N_t(M_k)$ 与 $e_kk$ 一起使用 softmax 函数进行归一化，以获得归一化的注意力系数 $α_{ijk}$ 和 $\alpha_{kk}$。</p><p>最终，机器嵌入$v’<em>k$由融合相邻操作和自身的特征计算得到。计算$v’<em>k$的聚合函数为：$v’<em>k &#x3D; \sigma(\alpha</em>{kk}W^M</em>{v_k} + \sum</em>{O_{ij}\in N_t(M_k)}\alpha_{ijk}W^O\mu_{ijk})$</p><h5 id="Operation-Node-Embedding"><a href="#Operation-Node-Embedding" class="headerlink" title="Operation Node Embedding:"></a>Operation Node Embedding:</h5><p>本文直接使用多个MLP对每个源的信息（包括$O_{ij}$本身的特征）进行处理，将结果拼接起来，投影回d维空间作为$O_{ij}$的embedding。</p><p>具体来说，有5个MLP被定义，每一个都有d维的输出，两个 $d_h$ 维隐藏层和 ELU 激活.$O_{ij}$的embedding计算如下:</p><p>$\mu’<em>{ij}&#x3D;MLP</em>{\theta_0}(ELU[MLP_{\theta_1}(\mu_{i,j-1})||MLP_{\theta_2}(\mu_{i, j+1})||MLP_{\theta_3}(\bar{v}’<em>{ij})||MLP</em>{\theta_4(\mu_{ij})}])$</p><p>请注意，无需计算两个虚拟操作 Start 和 End 的嵌入。</p><h5 id="Stacking-and-Pooling"><a href="#Stacking-and-Pooling" class="headerlink" title="Stacking and Pooling:"></a>Stacking and Pooling:</h5><p>上面的嵌入过程可以看作是一个HGNN层，它转换每个操作的原始特征$μ_{ij}$和$ν_k$，为了增强特征提取能力，这里将结构相同但可训练参数独立的 L个HGNN层堆叠起来，以获得最终的嵌入 $μ’^{(L)}_{ij}$ 和 $ν’^{(L)} _k$。</p><p>在HGNN的L层之后，分别对得到的操作嵌入集和机器嵌入集应用均值池化。然后，将生成的两个 d 维向量连接为异构图状态 $H_t$ 的嵌入 $ht \in \R^{2d}$，如下所示：$h_t&#x3D;[\frac{1}{O}\sum_{O_{i,j\in O}\mu_{ij}^{‘(L)}}||\frac{1}{|M|}\sum_{M_{k\in M}}v’^{(L)}_k]$.</p><p>通过上述过程，一个可变大小的异构图可以转化为一个固定维度的嵌入。令 θ 为所有 HGNN 参数的集合。</p><h4 id="Decision-Making"><a href="#Decision-Making" class="headerlink" title="Decision Making"></a>Decision Making</h4><p>由于上述异构图结构和 HGNN，策略 π(at|st) 使用提取的嵌入可以简单方便地表示.</p><p>对于在 $a_t &#x3D;(O_{ij},M_k) \in  A_t$ 处的每个可行动作，在步骤 t，相应的操作、机器和状态嵌入被连接起来并送入 MLP 以获得其在状态 $s_t$ 被选择的优先级索引，如下所示：$P(a_t, s_t)&#x3D;MLP_\omega[\mu’^{(L)}<em>{ij}||v’^{(L)}</em>{k}||h_t]$</p><p>选择每个 $a_t$ 的概率是通过对所有 $P (a_t,s_t)$ 应用 softmax 来计算的:</p><p>$\pi_\omega(a_t|s_t)&#x3D;\frac{exp(P(a_t,s_t))}{\sum_{a’_t\in A_t}exp(P(a’_t,s_t))} \forall a_t \in A_t$.</p><p>在训练过程中，根据策略 $\pi_\omega$ 对动作进行采样，以进行探索。</p><p>请注意，对于神经策略，采样的额外开销通常很小，因为图形处理单元 (GPU) 能够并行采样解决方案。</p><p><img src="http://cdn.leafii.top/img/image-20230203000256621.png" alt="image-20230203000256621" loading="lazy"></p><h4 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h4><p>本文使用 PPO进行训练，它采用了 actor-critic 结构。 Actor 是策略网络 $\pi_\omega$，critic $v_\phi$ 是另一个预测状态 $s_t$ 的值 $v(s_t)$ 的网络。</p><p><img src="http://cdn.leafii.top/img/image-20230203000557428.png" alt="image-20230203000557428" loading="lazy"></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>本节显示<strong>合成</strong>和<strong>公共 FJSP 实例</strong>的实验结果，以验证所提出的方法。</p><h4 id="Experimental-Settings"><a href="#Experimental-Settings" class="headerlink" title="Experimental Settings"></a>Experimental Settings</h4><h5 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h5><p>合成数据来自[1].</p><p>两个著名的 FJSP 基准测试数据:[1] 中的十个 mk 实例 (mk01–mk10) 和 [2] 中的三组 la 实例（rdata、edata 和 vdata，每组有 40 个实例）。</p><p>在四个较小的尺寸上进行训练，并使用最大的两个（30×10 和 40×10）来测试泛化能力</p><p>因此，对这些基准测试可以进一步验证所提出的方法在推广到分布外实例时的效果。有关这些实例的更多详细信息，请参见 [6]。</p><h5 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h5><p>与四个在实践中运行良好的著名 PDR 相比，包括 FIFO、剩余操作最多 (MOR)、最短处理时间 (SPT) 和剩余工作最多 (MWKR) 。</p><p>本文还与 Google OR-Tools 进行了比较。</p><p>对于公共基准，本文还与 DRL 方法 [3] 和 [4] 和 [5] 中的两种最新遗传算法 (GA) 的结果以及 [6] 中收集的最著名解决方案进行了比较。</p><p>对于具有最大完工时间 $C_{max}$ 的每个解决方案，其与最佳解决方案（不一定是最优）的最大完工时间 $C^{BS}_{max}$ 的相对差距计算如下：</p><p>$\epsilon &#x3D; (C_{max}&#x2F;C_^{BS} - 1) \times 100% $</p><h4 id="Performance-on-Synthetic-Instances"><a href="#Performance-on-Synthetic-Instances" class="headerlink" title="Performance on Synthetic Instances"></a>Performance on Synthetic Instances</h4><p>相当稳定并收敛于所有四种训练规模:</p><p><img src="http://cdn.leafii.top/img/image-20230203002931755.png" alt="image-20230203002931755" loading="lazy"></p><ol><li>训练大小实例的评估</li><li>大型实例的泛化性能</li><li>运行时间分析</li></ol><p><img src="http://cdn.leafii.top/img/image-20230203003842530.png" loading="lazy"></p><h4 id="Performance-on-Public-Benchmarks"><a href="#Performance-on-Public-Benchmarks" class="headerlink" title="Performance on Public Benchmarks"></a>Performance on Public Benchmarks</h4><p>进一步评估经过训练的政策在传统研究中经常使用的两个公共基准上的泛化性能:</p><p><img src="http://cdn.leafii.top/img/image-20230203003828665.png" alt="image-20230203003828665" loading="lazy"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>本文提出了一种新颖的端到端 DRL 方法来为 FJSP 学习高质量的 PDR，该方法在实践中得到广泛应用，但很少被现有的基于 DRL 的方法研究。</p><p>底层 MDP 是使用集成方法制定的，该方法将操作选择和机器分配结合为一个决策。然后，提出了一种异构图结构来表示调度状态，该结构由一种新颖的 HGNN 架构处理，以便将图中的数值和拓扑信息转换为特征嵌入。在 HGNN 的基础上，设计了一个 actor-critic 架构，并使用 PPO 进行训练。</p><p>结果表明，所提出的方法以合理的效率优于基线 PDR，并且可以很好地泛化到更大尺寸和公共基准的看不见的实例。</p><p>对于<strong>未来的工作</strong>，该方法将被扩展以处理实际生产中更具挑战性的因素，例如批次、到期日和不确定性。此外，将利用 FJSP 的多最优属性 [46]（即，一个实例可以有多个最优解）来提高训练性能。还将研究与 GA 等高级搜索机制相结合的可能性。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] P. Brandimarte, “Routing and scheduling in a flexible job shop by tabu search,” Ann. Oper. Res., vol. 41, no. 3, pp. 157–183, 1993.</p><p>[2]  J. Hurink, B. Jurisch, and M. Thole, “Tabu search for the job-shop scheduling problem with multi-purpose machines,” OR Spektrum, vol. 15, no. 4, pp. 205–215, 1994.</p><p>[3] B. Han and J. Yang, “A deep reinforcement learning based solution for flexible job shop scheduling problem,” Int. J. Simul. Model., vol. 20, no. 2, pp. 375–386, 2021.</p><p>[4] R. Chen, B. Yang, S. Li, and S. Wang, “A self-learning genetic algorithm based on reinforcement learning for flexible job-shop scheduling problem,” Comput. Ind. Eng., vol. 149, 2020, Art. no. 106778. </p><p>[5] D. Rooyani and F. M. Defersha, “An efficient two-stage genetic algorithm for flexible job-shop scheduling,” IFAC-PapersOnLine, vol. 52, no. 13, pp. 2519–2524, 2019.</p><p>[6] D. Behnke and M. J. Geiger, “Test instances for the flexible job shop scheduling problem with work centers,” Helmut Schmidt Univ., Hamburg, Germany, Tech. Rep. RR-12-01-01, 2012.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度&quot;&gt;&lt;a href=&quot;#Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度&quot; class=&quot;headerlink&quot; title=&quot;Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度&quot;&gt;&lt;/a&gt;Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度&lt;/h2&gt;&lt;h3 id=&quot;解决的问题&quot;&gt;&lt;a href=&quot;#解决的问题&quot; class=&quot;headerlink&quot; title=&quot;解决的问题&quot;&gt;&lt;/a&gt;解决的问题&lt;/h3&gt;&lt;p&gt;本文考虑了众所周知的灵活作业车间调度问题，并通过提出一种新颖的 DRL 方法来端到端地学习高质量的 PDR 来解决这些问题。操作选择和机器分配被组合为一个复合决策。此外，基于一种新颖的调度状态异构图表示，提出了一种基于异构图神经网络的体系结构来捕获操作和机器之间的复杂关系。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:344.反转字符串</title>
    <link href="2023/02/01/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>2023/02/01/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-01-31T16:46:29.000Z</published>
    <updated>2023-01-31T16:58:56.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>双指针从最左边到最右边遍历交换元素，直至左指针索引值大于右指针索引值。C++实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int n &#x3D; s.size();&#x2F;&#x2F;获取数组长度        int left &#x3D; 0, right &#x3D; n - 1;        char temp &#x3D; 0;        while(left &lt; right) &#123;            temp &#x3D; s[left];            s[left] &#x3D; s[right];            s[right] &#x3D; temp;&#x2F;&#x2F;交换操作            left++;            right--; &#x2F;&#x2F;指针移动        &#125;        &#x2F;&#x2F;最后的s即为结果，函数返回类型为void所以无需返回值    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 &lt;code&gt;s&lt;/code&gt; 的形式给出。&lt;/p&gt;
&lt;p&gt;不要给另外的数组分配额外的空间，你必须&lt;strong&gt;原地修改输入数组&lt;/strong&gt;、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:42.接雨水</title>
    <link href="2023/01/30/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>2023/01/30/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2023-01-29T19:14:51.000Z</published>
    <updated>2023-01-29T19:31:57.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/rainwatertrap.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [4,2,0,3,2,5]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>创建两个长度为n的数组leftMax和rightMax.leftMax[i]表示下标i以及其左边的位置中，height的最大高度，rightMax[i]表示下标i及其右边的位置中，height的最大高度。其中leftMax[0] &#x3D; height[0], rightMax[n - 1] &#x3D; height[n - 1].</p><ul><li>当1 &lt;&#x3D; i &lt;&#x3D; n - 1时， leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);</li><li>当0 &lt;&#x3D; i &lt;&#x3D; n - 2时，rightMax[i] &#x3D; max(rightMax[i + 1], height[i]).</li></ul><p>因此可以正向遍历数组height得到leftMax的每个元素值，反向遍历数组height得到rightMax的每个元素值。</p><p>在得到数组leftMax和rightMax的每个元素值后，对于0&lt;&#x3D;i&lt;n，下标i处能接的雨水量等于min(leftMax[i], rightMax[i]) - height[i].对每个下标i进行遍历，将结果进行累加。</p><p><img src="http://cdn.leafii.top/img/1.png" alt="fig1" loading="lazy"></p><p>C++代码实现如下： </p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int n &#x3D; height.size();        if (n &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        vector&lt;int&gt; leftMax(n);        leftMax[0] &#x3D; height[0];        for (int i &#x3D; 1; i &lt; n; ++i) &#123;            leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);        &#125;        vector&lt;int&gt; rightMax(n);        rightMax[n - 1] &#x3D; height[n - 1];        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; --i) &#123;            rightMax[i] &#x3D; max(rightMax[i + 1], height[i]);        &#125;        int ans &#x3D; 0;        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            ans +&#x3D; min(leftMax[i], rightMax[i]) - height[i];        &#125;        return ans;    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/">https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:46.全排列</title>
    <link href="2023/01/29/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>2023/01/29/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2023-01-29T06:23:57.000Z</published>
    <updated>2023-01-29T06:47:10.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1]输出：[[0,1],[1,0]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1]输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>回溯</li></ol><p>用回溯法模拟全排列的过程。</p><p>定义一个递归函数<code>backtrack(first, output)</code>表示从左往右填到第first个位置，当前排列为output，所以有以下两种情况：</p><ul><li>若<code>first = n</code>，则说明n个位置已经填完了，找到了一个可行的解，此时需要把output放入答案数组中，递归结束。</li><li>如果<code>first &lt; n</code>，我们需要考虑在第first个位置上我们需要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组vis来标记已经填过的数，如果有数未被标记，就尝试填入，并将其标记，然后继续调用<code>backtrack(first + 1, output)</code>，回溯时要撤销之前的标记以及已经填入的数字，但是标记数组增加了算法的空间复杂度。</li></ul><p>我们将题目给定的n个数的数组nums划分为左右两个部分，左边为已经填过的数，右边是待填的数，在回溯时只需要动态维护这个数组即可。</p><p>具体的来说，如果我们已经填到第first个位置，那么nums数组中<code>[0, first - 1]</code>是已经填过的数的集合，<code>[first, n - 1]</code>是待填数的集合。我们肯定是用<code>[first, n - 1]</code>的数去填第first个数，假设待填的数的下标为i，那么填完以后我们将第i个数和第first个数交换，即能使得在第first+1个数的时候nums数组的<code>[0, first]</code>部分为已填过的数，<code>[first + 1, n - 1]</code>为待填的数，回溯的时候交换回来就可以完成撤销操作。</p><p>举个简单的例子，假设我们有 <code>[2,5,8,9,10]</code>这 5 个数要填入，已经填到第 3 个位置，已经填了 <code>[8, 9]</code> 两个数，那么这个数组目前为 <code>[8, 9|2, 5, 10]</code> 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10 这个数，为了维护数组，我们将 2 和 10 交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填 <code>[8, 9, 10|2, 5]</code> 。C++实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len) &#123;        &#x2F;&#x2F;所有数都填完了        if (first &#x3D;&#x3D; len) &#123;            res.emplace_back(output);             &#x2F;&#x2F;和push_back()类似，emplace_back() 用来给容器中添加元素。            &#x2F;&#x2F;在容器尾部添加一个元素，调用构造函数原地构造，不需要触发拷贝构造和移动构造。因此比push_back()更加高效。            return;        &#125;        for (int i &#x3D; first; i &lt; len; ++i) &#123;            &#x2F;&#x2F;动态维护数组            swap(output[i], output[first]); &#x2F;&#x2F;swap用于交换两个int型变量的值            &#x2F;&#x2F;继续递归填下一个数            backtrack(res, output, first + 1, len);            &#x2F;&#x2F;撤销操作            swap(output[i], output[first]);        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt; &gt; res;        backtrack(res, nums, 0, (int)nums.size());        return res;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个不含重复数字的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其 &lt;em&gt;所有可能的全排列&lt;/em&gt; 。你可以 &lt;strong&gt;按任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:15/16.三数之和/最接近的三数之和</title>
    <link href="2023/01/28/leetcode-15-16-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>2023/01/28/leetcode-15-16-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2023-01-28T07:53:18.000Z</published>
    <updated>2023-01-30T11:04:00.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,0], target &#x3D; 1输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 1000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><blockquote><p>这两道题目求解思路很相似，只是第一个题目需要返回所有满足求和条件的组合，第二个题目返回最接近target的sum值。</p></blockquote><p><strong>方法一：排序 + 双指针</strong></p><p>题目要求找到与目标值 $target$ 最接近的三元组，这里的「最接近」即为差值的绝对值最小。我们可以考虑直接使用三重循环枚举三元组，找出与目标值最接近的作为答案，时间复杂度为 $O(N^3)$。然而本题的 $N$ 最大为 $1000$，会超出时间限制。</p><p>那么如何进行优化呢？我们首先考虑枚举第一个元素 $a$，对于剩下的两个元素 $b$ 和 $c$，我们希望它们的和最接近 $target-a$。对于 $b$ 和 $c$，如果它们在原数组中枚举的范围（既包括下标的范围，也包括元素值的范围）没有任何规律可言，那么我们还是只能使用两重循环来枚举所有的可能情况。因此，我们可以考虑对整个数组进行升序排序，这样一来：</p><p>假设数组的长度为 $N$，我们先枚举 $a$，它在数组中的位置为 $i$；</p><p>为了防止重复枚举，我们在位置$[i+1,n)$的范围内枚举 $b$ 和 $c$。</p><p>当我们知道了 $b$ 和 $c$ 可以枚举的下标范围，并且知道这一范围对应的数组元素是有序（升序）的，那么我们是否可以对枚举的过程进行优化呢？</p><p>答案是可以的。借助双指针，我们就可以对枚举的过程进行优化。我们用 $p_b$和 $p_c$分别表示指向 $b$ 和 $c$ 的指针，初始时，$p_b$指向位置$i+1$，即左边界；$p_c$指向位置 $n-1$，即右边界。在每一步枚举的过程中，我们用 $a+b+c$ 来更新答案，并且：</p><p>如果 $a+b+c \ge target$，那么就将 $p_c$向左移动一个位置；</p><p>如果 $a+b+c \le target$，那么就将 $p_b$向右移动一个位置。</p><p>这是为什么呢？我们对 $a+b+c \ge target$ 的情况进行一个详细的分析：</p><p>如果 $a+b+c \ge target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_c$不变而 $p_b$向右移动，那么 $a+b+c$ 的值就会不断地增加，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_c$的情况下，此时的 $p_b$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_c$了，就可以将 $p_c$向左移动一个位置。</p><p>同样地，在 $a+b+c \le target$ 时：</p><p>如果 $a+b+c \le target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_b$不变而 $p_c$向左移动，那么 $a+b+c$ 的值就会不断地减小，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_b$的情况下，此时的 $p_c$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_b$了，就可以将 $p_b$向右移动一个位置。</p><p>实际上，$p_b$和 $p_c$就表示了我们当前可以选择的数的范围，而每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 $target$ 的值的关系，选择「抛弃」左边界的元素还是右边界的元素，从而减少了枚举的范围。这种思路与 11. 盛最多水的容器 中的双指针解法也是类似的。</p><p><strong>小优化</strong></p><p>本题也有一些可以减少运行时间（但不会减少时间复杂度）的小优化。当我们枚举到恰好等于 $target$ 的 $a+b+c$ 时，可以直接返回 $target$ 作为答案，因为不会有再比这个更接近的值了。</p><p>另一个优化与 15. 三数之和的官方题解 中提到的类似。当我们枚举 $a,b,c$中任意元素并移动指针时，可以直接将其移动到下一个与这次枚举到的不相同的元素，减少枚举的次数。</p><h3 id="15题C-实现："><a href="#15题C-实现：" class="headerlink" title="15题C++实现："></a>15题C++实现：</h3><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        &#x2F;&#x2F;对数组进行排序        sort(nums.begin(), nums.end());        int n &#x3D; nums.size();        &#x2F;&#x2F;枚举a        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            &#x2F;&#x2F;保证和上一次枚举的元素不相等            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                continue;            &#125;            int target &#x3D; -nums[i];            &#x2F;&#x2F;使用双指针枚举b和c            int j &#x3D; i + 1, k &#x3D; n - 1;            while (j &lt; k) &#123;                int sum &#x3D;  nums[j] + nums[k];                &#x2F;&#x2F; 如果和为target则直接返回答案                 if (sum &#x3D;&#x3D; target) &#123;                    result.push_back(&#123;nums[i], nums[j], nums[k]&#125;);                &#125;                if (sum &gt; target) &#123;                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针                    int k0 &#x3D; k - 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;                        --k0;                    &#125;                    k &#x3D; k0;                &#125; else &#123;                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针                    int j0 &#x3D; j + 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;                        ++j0;                    &#125;                    j &#x3D; j0;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h3 id="16题C-实现："><a href="#16题C-实现：" class="headerlink" title="16题C++实现："></a>16题C++实现：</h3><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;        &#x2F;&#x2F;对数组进行排序        sort(nums.begin(), nums.end());        int n &#x3D; nums.size();        int best &#x3D; 1e7;&#x2F;&#x2F; initial                &#x2F;&#x2F;根据差值的绝对值来更新答案        &#x2F;*            auto toNumber &#x3D; [&amp;](string const&amp; s) -&gt; unsigned &#123;                ...            &#125;            []：定义匿名函数            [&amp;]：以引用形式捕获所有外部变量，也就是外部变量均可用            (string const &amp;s) ：匿名函数的参数            -&gt;：定义匿名函数            unsigned：函数返回值类型            &#123;...&#125;：函数实现体        *&#x2F;                auto update &#x3D; [&amp;](int cur) &#123;            if (abs(cur - target) &lt; abs(best - target)) &#123;                best &#x3D; cur;            &#125;        &#125;;        &#x2F;&#x2F;枚举 a        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            &#x2F;&#x2F;保证和上一次枚举的元素不相等            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                continue;            &#125;            &#x2F;&#x2F;使用双指针枚举b和c            int j &#x3D; i + 1, k &#x3D; n - 1;            while (j &lt; k) &#123;                int sum &#x3D; nums[i] + nums[j] + nums[k];                &#x2F;&#x2F; 如果和为target则直接返回答案                 if (sum &#x3D;&#x3D; target) &#123;                    return target;                &#125;                update(sum);                if (sum &gt; target) &#123;                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针                    int k0 &#x3D; k - 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;                        --k0;                    &#125;                    k &#x3D; k0;                &#125; else &#123;                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针                    int j0 &#x3D; j + 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;                        ++j0;                    &#125;                    j &#x3D; j0;                &#125;            &#125;        &#125;        return best;    &#125;&#125;;</code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/">https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;15-三数之和&quot;&gt;&lt;a href=&quot;#15-三数之和&quot; class=&quot;headerlink&quot; title=&quot;15. 三数之和&quot;&gt;&lt;/a&gt;15. 三数之和&lt;/h2&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，判断是否存在三元组 &lt;code&gt;[nums[i], nums[j], nums[k]]&lt;/code&gt; 满足 &lt;code&gt;i != j&lt;/code&gt;、&lt;code&gt;i != k&lt;/code&gt; 且 &lt;code&gt;j != k&lt;/code&gt; ，同时还满足 &lt;code&gt;nums[i] + nums[j] + nums[k] == 0&lt;/code&gt; 。请&lt;/p&gt;
&lt;p&gt;你返回所有和为 &lt;code&gt;0&lt;/code&gt; 且不重复的三元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;答案中不可以包含重复的三元组。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:94.二叉树的中序遍历</title>
    <link href="2023/01/27/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>2023/01/27/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-01-27T06:59:43.000Z</published>
    <updated>2023-01-27T08:22:12.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/inorder_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,3,2]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归算法</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123;      &#x2F;&#x2F;原函数没办法对vector数组的内容进行添加        if(!root) &#123;            return;        &#125;      &#x2F;&#x2F;中 左 右        inorder(root-&gt;left, res);        res.push_back(root -&gt; val);        inorder(root-&gt;right, res);    &#125;    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        inorder(root, result);        return result;    &#125;&#125;;</code></pre><ol start="2"><li>迭代</li></ol><p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; stk;        while (root !&#x3D; nullptr || !stk.empty()) &#123;            &#x2F;&#x2F;结点非空时，将root结点push进去， root迭代至左结点            while(root !&#x3D; nullptr) &#123;                stk.push(root);                root &#x3D; root -&gt; left;            &#125;            &#x2F;&#x2F;符合条件的结点都push进去之后，出栈，然后将root结点的值push进res数组中，            root &#x3D; stk.top();            stk.pop();            res.push_back(root -&gt; val);            &#x2F;&#x2F; 将root结点迭代至右结点            root &#x3D; root -&gt; right;         &#125;        return res;    &#125;    &#125;;</code></pre><ol start="3"><li>Morris遍历算法</li></ol><p>思路与算法</p><p>Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 $O(1)$。</p><p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 $x$）：</p><p>如果 $x$ 无左孩子，先将 $x$ 的值加入答案数组，再访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>如果 $x$ 有左孩子，则找到 $x$ 左子树上最右的节点（即左子树中序遍历的最后一个节点，$x$ 在中序遍历中的前驱节点），我们记为 $predecessor $。根据 $predecessor $ 的右孩子是否为空，进行如下操作。<br>如果 $predecessor $ 的右孩子为空，则将其右孩子指向 $x$，然后访问 $x$ 的左孩子，即 $x &#x3D; x.left $。<br>如果 $predecessor $ 的右孩子不为空，则此时其右孩子指向 $x$，说明我们已经遍历完 $x$ 的左子树，我们将 $predecessor $ 的右孩子置空，将 $x$ 的值加入答案数组，然后访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>重复上述操作，直至访问完整棵树。</p><p>其实整个过程我们就多做一步：假设当前遍历到的节点为 xxx，将 xxx 的左子树中最右边的节点的右孩子指向 xxx，这样在左子树遍历完成后我们通过这个指向走回了 xxx，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        TreeNode *predecessor &#x3D; nullptr;        while (root !&#x3D; nullptr) &#123;            if(root -&gt; left !&#x3D; nullptr) &#123;                &#x2F;&#x2F;predecessor就是当前root节点向左走一步，再一直向右走到无法走为止                predecessor &#x3D; root -&gt; left;                while(predecessor -&gt; right !&#x3D; nullptr &amp;&amp; predecessor -&gt; right !&#x3D; root) &#123;                    predecessor &#x3D; predecessor -&gt; right;                &#125;            &#x2F;&#x2F;让predecessor的右指针指向root，继续遍历左子树            if (predecessor -&gt; right &#x3D;&#x3D; nullptr) &#123;                predecessor -&gt; right &#x3D; root;                root &#x3D; root -&gt; left;            &#125;            &#x2F;&#x2F;说明左子树已经访问完了， 需要断开连接            else &#123;                res.push_back(root -&gt; val);                predecessor -&gt; right &#x3D; nullptr;                root &#x3D; root -&gt; right;                &#125;            &#125;            &#x2F;&#x2F;如果没有左孩子，则直接访问右孩子            else &#123;                res.push_back(root -&gt; val);                root &#x3D; root -&gt; right;            &#125;                    &#125;        return res;            &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>力扣官方题解：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回 &lt;em&gt;它的 &lt;strong&gt;中序&lt;/strong&gt; 遍历&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:27.移除元素</title>
    <link href="2023/01/26/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>2023/01/26/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</id>
    <published>2023-01-26T06:02:42.000Z</published>
    <updated>2023-01-26T06:20:07.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><span id="more"></span><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre class="language-none"><code class="language-none">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len &#x3D; removeElement(nums, val);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;</code></pre><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li><p>双指针直接遍历</p><p>使用双指针，左指针为要被修改的元素，右指针为遍历主体，判断元素是否为<code>val</code>。最后返回left即可。C++代码实现如下：</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        &#x2F;&#x2F;双指针        int n &#x3D; nums.size();        int left &#x3D; 0;        for(int right &#x3D; 0; right &lt; n; right++) &#123;            if(nums[right] !&#x3D; val) &#123;                nums[left] &#x3D; nums[right];                left++;            &#125;        &#125;        return left;    &#125;&#125;;</code></pre><ol start="2"><li><p>双指针优化</p><p>初始化两个指针时，左指针为0，右指针为数组的最后一个元素，然后从两边向中间遍历.C++代码实现如下：</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int left &#x3D; 0, right &#x3D; nums.size();        while(left &lt; right) &#123;            if(nums[left] &#x3D;&#x3D; val) &#123;                nums[left] &#x3D; nums[right - 1];                right--;            &#125;            else &#123;                left++;            &#125;        &#125;        return left;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt; 移除所有数值等于 &lt;code&gt;val&lt;/code&gt; 的元素，并返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须仅使用 &lt;code&gt;O(1)&lt;/code&gt; 额外空间并 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot;&gt;原地 &lt;/a&gt;修改输入数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:51.N皇后</title>
    <link href="2023/01/17/leetcode-51-N%E7%9A%87%E5%90%8E/"/>
    <id>2023/01/17/leetcode-51-N%E7%9A%87%E5%90%8E/</id>
    <published>2023-01-17T08:52:01.000Z</published>
    <updated>2023-01-17T09:08:56.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[[&quot;Q&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>首先来看一下皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p><p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p><p><img src="http://cdn.leafii.top/img/20210130182532303.jpg" alt="51.N皇后" loading="lazy"></p><p>从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p><p>按照我总结的如下回溯模板，我们来依次分析：</p><pre class="language-C++" data-language="C++"><code class="language-C++">void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); &#x2F;&#x2F; 递归        回溯，撤销处理结果    &#125;&#125;</code></pre><ul><li>递归函数参数</li></ul><p>我依然是定义全局变量二维数组result来记录最终结果。</p><p>参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。</p><p>代码如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> result<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></code></pre><ul><li>递归终止条件</li></ul><p>在如下树形结构中： <img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后" loading="lazy"></p><p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。</p><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">if (row &#x3D;&#x3D; n) &#123;    result.push_back(chessboard);    return;&#125;</code></pre><ul><li>单层搜索的逻辑</li></ul><p>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</p><p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">for (int col &#x3D; 0; col &lt; n; col++) &#123;    if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放        chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后        backtracking(n, row + 1, chessboard);        chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后    &#125;&#125;</code></pre><ul><li>验证棋盘是否合法</li></ul><p>按照如下标准去重：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线 （45度和135度角）</li></ol><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;    &#x2F;&#x2F; 检查列    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 45度角是否有皇后    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 135度角是否有皇后    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p><p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p><p>那么按照这个模板不难写出如下C++代码：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:vector&lt;vector&lt;string&gt;&gt; result;&#x2F;&#x2F; n 为输入的棋盘大小&#x2F;&#x2F; row 是当前递归到棋盘的第几行了void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;    if (row &#x3D;&#x3D; n) &#123;        result.push_back(chessboard);        return;    &#125;    for (int col &#x3D; 0; col &lt; n; col++) &#123;        if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放            chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后            backtracking(n, row + 1, chessboard);            chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后        &#125;    &#125;&#125;bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;    &#x2F;&#x2F; 检查列    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 45度角是否有皇后    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 135度角是否有皇后    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    return true;&#125;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        result.clear();        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#39;.&#39;));        backtracking(n, 0, chessboard);        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n 皇后问题&lt;/strong&gt; 研究的是如何将 &lt;code&gt;n&lt;/code&gt; 个皇后放置在 &lt;code&gt;n×n&lt;/code&gt; 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，返回所有不同的 &lt;strong&gt;n 皇后问题&lt;/strong&gt; 的解决方案。&lt;/p&gt;
&lt;p&gt;每一种解法包含一个不同的 &lt;strong&gt;n 皇后问题&lt;/strong&gt; 的棋子放置方案，该方案中 &lt;code&gt;&amp;#39;Q&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 分别代表了皇后和空位。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer64.求1+2+…+n</title>
    <link href="2023/01/17/%E5%89%91%E6%8C%87Offer64-%E6%B1%821-2-%E2%80%A6-n/"/>
    <id>2023/01/17/%E5%89%91%E6%8C%87Offer64-%E6%B1%821-2-%E2%80%A6-n/</id>
    <published>2023-01-17T05:17:16.000Z</published>
    <updated>2023-01-17T06:10:05.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入: n &#x3D; 3输出: 6</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入: n &#x3D; 9输出: 45</code></pre><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 10000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>错误解法（使用了if）,虽然通过了但是不符合题意。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        if(n &#x3D;&#x3D; 1)        &#123;            return 1;        &#125;        else        &#123;            return n + sumNums(n - 1);        &#125;    &#125;&#125;;</code></pre><ol start="2"><li>由于不能使用乘除法，<code>for</code>，<code>while</code>等关键字以及条件判断语句，因此我们能用的挚友加减法，赋值，位运算符和逻辑运算符。</li></ol><p>但是如果使用递归方法，那么递归的结束条件很难不用条件判断语句，那么怎么解决？答案是使用逻辑运算符<code>&amp;&amp;</code>或者<code>||</code>，利用它的短路性质，对于<code> A &amp;&amp; B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>False</code> ，那么 <code>A &amp;&amp; B</code> 已经确定为 <code>False</code>，此时不会去执行表达式 <code>B</code>。同理，对于逻辑运算符 <code>||</code>， 对于 <code>A || B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>True</code> ，那么<code> A || B</code> 已经确定为<code> True</code> ，此时不会去执行表达式<code> B</code>。</p><p>因此我们可以将判断是否为递归的出口看作<code>A&amp;B</code>表达式中的<code>A</code>部分，递归的主体函数看作<code>B</code>部分。如果不是递归出口，就返回<code>True</code>，并继续执行表达式<code>B</code>的部分，否则递归结束。结合逻辑运算符<code>&amp;&amp;</code>的递归实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        n &amp;&amp; (n +&#x3D; sumNums(n-1));        return n;    &#125;&#125;;</code></pre><p>用逻辑运算符<code>||</code>的递归实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        n&#x3D;&#x3D;1 || (n +&#x3D; sumNums(n-1));        return n;    &#125;&#125;;</code></pre><ol start="3"><li>使用C++的sizeof函数进行$\frac{1}{2}(n \times (n+1))$的模拟：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        bool a[n][n+1]; &#x2F;&#x2F;bool一个元素占一bit        return sizeof(a) &gt;&gt; 1; &#x2F;&#x2F;sizeof(a) 计算了n*(n+1)    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;求 &lt;code&gt;1+2+...+n&lt;/code&gt; ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:2.两数相加</title>
    <link href="2023/01/17/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>2023/01/17/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-01-17T04:34:08.000Z</published>
    <updated>2023-01-17T05:03:43.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/addtwonumber1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]输出：[7,0,8]解释：342 + 465 &#x3D; 807.</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [0], l2 &#x3D; [0]输出：[0]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>将两个链表遍历相加，大致思路如下：</li></ol><blockquote><p>1.相加的过程中可能存在进位的操作，所以需要采用一个变量carry来记录进位的情况，初始化carry &#x3D; 0;</p><p>2.因为链表的数字是倒着放的，所以相加起来很方便，将两个链表从头到尾一起遍历，如果有值的话就将它们的值相加sum &#x3D; val1+val2+carry。</p><p>3.如果是两个长度不一样的链表，则需要注意将不再继续向后，且让相应位的和为val1+0.</p><p>4.carry的更新，carry &#x3D; sum&#x2F;10, 而当前节点和 curr-&gt;val &#x3D; sum%10.</p><p>5.循环直至l1,l2都为空。</p><p>6.遍历完之后如果carry &#x3D;&#x3D; 1, 新建一个节点存在进位。</p></blockquote><p>代码实现：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode *newHead &#x3D; new ListNode(0);        ListNode *p &#x3D; l1;        ListNode *q &#x3D; l2;        ListNode *curr &#x3D; newHead;        int carry &#x3D; 0; &#x2F;&#x2F;进位        while(p !&#x3D; NULL || q !&#x3D; NULL) &#123;            int sum &#x3D; 0, x &#x3D; 0, y &#x3D; 0;            if(p) &#123;                x &#x3D; p -&gt; val;                p &#x3D; p -&gt; next;            &#125;            if(q) &#123;                y &#x3D; q -&gt; val;                q &#x3D; q -&gt; next;            &#125;            sum &#x3D; x + y + carry;            carry &#x3D; sum &#x2F; 10;            curr -&gt; next &#x3D; new ListNode(sum % 10);            curr &#x3D; curr -&gt; next;        &#125;        if(carry) &#123;            curr -&gt; next &#x3D; new ListNode(carry);        &#125;        return newHead -&gt; next;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:35.搜索插入位置</title>
    <link href="2023/01/16/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>2023/01/16/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</id>
    <published>2023-01-16T07:04:57.000Z</published>
    <updated>2023-01-16T07:18:17.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 5输出: 2</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 2输出: 1</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 7输出: 4</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>目标元素有以下几种情况：</p><p>1.插入在数组头部</p><p>2.插入数组中某个位置</p><p>3.在数组中找到该元素</p><p>4.插入数组尾部</p><p>因此可用顺序遍历或者二分查找来解题</p><ol><li>顺序遍历整个数组的暴力解法</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        for(int i &#x3D; 0; i &lt; nums.size(); i++)        &#123;            if(nums[i] &#x3D;&#x3D; target)            &#123;                return i;            &#125;            else if(nums[i] &gt; target)&#123;                return i;            &#125;        &#125;        return nums.size();    &#125;&#125;;</code></pre><ol start="2"><li>使用二分查找法进行位置的查找</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int l&#x3D;0,r&#x3D;nums.size()-1;&#x2F;&#x2F; 我们定义target在左闭右闭的区间里，[left, right] ，当left&#x3D;&#x3D;right，区间[left, right]依然有效        while(l&lt;&#x3D;r)        &#123;            int mid&#x3D;l+(r-l)&#x2F;2;            if(nums[mid]&lt;target)            &#123;                l&#x3D;mid+1;&#x2F;&#x2F; target 在右区间，所以[middle + 1, right]            &#125;            else if(nums[mid]&#x3D;&#x3D;target)            &#123;                return mid;            &#125;            else            &#123;                r&#x3D;mid-1;&#x2F;&#x2F; target 在左区间，所以[left, middle - 1]            &#125;        &#125;        return r+1;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;请必须使用时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 的算法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:20.有效的括号</title>
    <link href="2023/01/15/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>2023/01/15/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2023-01-15T05:24:30.000Z</published>
    <updated>2023-01-15T08:01:36.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;()&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;输出：true</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;(]&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用栈进行左半边括号的存储，遍历字符串，当遇到右半边括号时进行匹配，若是相匹配的括号则继续遍历字符串直到最后一个字符，否则返回false。实现代码如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt; sc; &#x2F;&#x2F;创建栈        for(char a:s)&#123; &#x2F;&#x2F;遍历并判断，首先判断栈是否为空，                       &#x2F;&#x2F;接下来判断两个括号是否匹配。            if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;)&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;(&#39;)                sc.pop(); &#x2F;&#x2F;匹配成功后将栈内的左括号弹出            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;]&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;[&#39;)                sc.pop();            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;&#125;&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;&#123;&#39;)                sc.pop();            else                 sc.push(a); &#x2F;&#x2F;若是左括号，则压入栈内        &#125;        return sc.empty(); &#x2F;&#x2F;遍历结束后，若栈为空，则返回true    &#125;&#125;;</code></pre><ol start="2"><li>官方解答</li></ol><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>我们遍历给定的字符串 sss。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 sss 无效，返回 False\text{False}False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 sss 中的所有左括号闭合，返回<code>True</code>，否则返回 <code>False</code>。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 <code>False</code>，省去后续的遍历判断过程。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isValid(string s) &#123;        int n &#x3D; s.size();        if (n % 2 &#x3D;&#x3D; 1) &#123;            return false;        &#125;        unordered_map&lt;char, char&gt; pairs &#x3D; &#123;            &#123;&#39;)&#39;, &#39;(&#39;&#125;,            &#123;&#39;]&#39;, &#39;[&#39;&#125;,            &#123;&#39;&#125;&#39;, &#39;&#123;&#39;&#125;        &#125;;        stack&lt;char&gt; stk;        for (char ch: s) &#123;            if (pairs.count(ch)) &#123;                if (stk.empty() || stk.top() !&#x3D; pairs[ch]) &#123;                    return false;                &#125;                stk.pop();            &#125;            else &#123;                stk.push(ch);            &#125;        &#125;        return stk.empty();    &#125;&#125;;</code></pre><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/">https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;&amp;#123;&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;&amp;#125;&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;]&amp;#39;&lt;/code&gt; 的字符串 &lt;code&gt;s&lt;/code&gt; ，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;li&gt;每个右括号都有一个对应的相同类型的左括号。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:23.合并K个升序链表</title>
    <link href="2023/01/12/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>2023/01/12/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2023-01-12T09:23:49.000Z</published>
    <updated>2023-01-12T09:25:45.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：lists &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：lists &#x3D; [[]]输出：[]</code></pre><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>写一个可以合并两个有序链表的函数，然后对传入的list进行遍历，将list的两个元素两两合并，最后返回头结点。实现代码如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F;合并两个有序链表    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)    &#123;        ListNode* head &#x3D; nullptr;        ListNode* curNode &#x3D; nullptr;        ListNode** temp &#x3D; nullptr;        bool isFirst &#x3D; true;        while(list1 !&#x3D; nullptr &amp;&amp; list2 !&#x3D; nullptr)        &#123;            temp &#x3D; (list1 -&gt; val &lt; list2 -&gt; val)? &amp;list1:&amp;list2; &#x2F;&#x2F;使用二级指针，因为temp如果是一级指针，那么temp &#x3D; temp-&gt;next;是无法改变list1和list2的值的，而二级指针可以间接改变list1和list2的地址。            if(isFirst)            &#123;                head &#x3D; *temp;                curNode &#x3D; *temp;                isFirst &#x3D; false;            &#125;            else            &#123;                curNode -&gt; next &#x3D; *temp;                curNode &#x3D; curNode -&gt; next;            &#125;            *temp &#x3D; (*temp) -&gt; next;        &#125;        if(nullptr !&#x3D; list1)        &#123;            if(isFirst)  &#x2F;&#x2F;有一方链表为空            &#123;                head &#x3D; list1;            &#125;            else         &#x2F;&#x2F;剩下结点直接补齐            &#123;                curNode -&gt; next &#x3D; list1;            &#125;        &#125;        if(nullptr !&#x3D; list2)        &#123;            if(isFirst)            &#123;                head &#x3D; list2;            &#125;            else            &#123;                curNode-&gt;next &#x3D; list2;            &#125;        &#125;        return head;    &#125;    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        ListNode* head &#x3D; nullptr;        for(int i &#x3D; 0; i &lt; lists.size(); i++)        &#123;            head &#x3D; mergeTwoLists(head, lists[i]);        &#125;        return head;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。&lt;/p&gt;
&lt;p&gt;请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:19.删除链表的倒数第N个结点</title>
    <link href="2023/01/11/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>2023/01/11/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2023-01-11T07:20:46.000Z</published>
    <updated>2023-01-11T07:39:19.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/remove_ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2输出：[1,2,3,5]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1], n &#x3D; 1输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2], n &#x3D; 1输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>双指针遍历一次链表，思路如下：</li></ol><p>设置两个指针p，q，分别初始为头结点，然后p指针向后移动n次，接着p和q指针同时移动直到p指针指向链表的最后一个元素，此时q指针指向的是被删除元素的前一个元素，因此将需要被删除的元素进行删除，最终返回头结点即可，需要注意<strong>删除头结点的情况</strong>。实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode *q &#x3D; head, *p &#x3D; head, *t &#x3D; head -&gt; next;        if(head &#x3D;&#x3D; NULL)        &#123;            return head;        &#125;        while(n-- &amp;&amp; p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;p指针向后移动n位        &#123;            p &#x3D; p -&gt; next;        &#125;        if(n !&#x3D; -1) &#x2F;&#x2F;删除头结点        &#123;            t &#x3D; head;            head &#x3D; head -&gt; next;            delete t;            return head;        &#125;        while(p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;此时p和q指针一起向后移动，直到p指向最后一个结点        &#123;            q &#x3D; q -&gt; next;            p &#x3D; p -&gt; next;        &#125;        t &#x3D; q -&gt; next;        q -&gt; next &#x3D; t -&gt; next;        delete t;        return head;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表，删除链表的倒数第 &lt;code&gt;n&lt;/code&gt; 个结点，并且返回链表的头结点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:7.整数反转</title>
    <link href="2023/01/10/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>2023/01/10/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2023-01-10T06:59:15.000Z</published>
    <updated>2023-01-10T07:19:49.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; 123输出：321</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; -123输出：-321</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; 120输出：21</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; 0输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>将数字的每位分别提取并进行字符串拼接，最终将字符串转为int型数字，思路如下：</li></ol><p>因为负数对10取余数得到的结果依然为负数，所以如果x为负数，则将minus标记设置为true，并且将x转化为正数，如果x为正数，则minus标记为false，进行x的正负判断之后可以将string类型的ans_str变量进行初始化，接着进行x的特殊值的判断，因为int型的范围是$-2^{31} 到  2^{31}-1$，所以当<code>x=-2147483648</code>时，它无法被转化为正数进行计算，因此需要单独判断，需要单独判断的还有<code>x=0</code>的情况。接着在while循环中进行倒置的过程。倒置结束后对倒置结果进行判断，如果超过范围的话直接返回0（因为无法通过C++的stoi方法转化为int型结果。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int reverse(int x) &#123;        bool minus &#x3D; false;        string ans_str &#x3D; &quot;0&quot;;        &#x2F;&#x2F;特例判断        if(x &#x3D;&#x3D; -2147483648)&#123;            return 0;        &#125;        if(x &#x3D;&#x3D; 0)        &#123;            return 0;        &#125;        &#x2F;&#x2F;对负数的处理        if(x &lt; 0)        &#123;            ans_str &#x3D; &quot;-0&quot;;            x &#x3D; x * -1;            minus &#x3D; true;        &#125;        &#x2F;&#x2F;在while循环中进行倒置操作，倒置结果储存在ans_str变量中。        while(x !&#x3D; 0)&#123;            int temp_num &#x3D; x % 10;            x &#x3D; x &#x2F; 10;            string temp_str &#x3D; to_string(temp_num);            ans_str &#x3D; ans_str + temp_str;        &#125;        &#x2F;&#x2F;2^31-1 &#x3D; 2147483647        &#x2F;&#x2F;-2^31 &#x3D; -2147483648        &#x2F;&#x2F;通过int型范围设置两个对比的string类型，防止倒置结果超过范围。        string upper &#x3D; &quot;02147483647&quot;;        string lower &#x3D; &quot;-02147483648&quot;;        &#x2F;&#x2F;倒置结果是否超限的判断        if(minus &#x3D;&#x3D; true &amp;&amp; ans_str.length() &#x3D;&#x3D; 12)&#123;            for(int i &#x3D; 0; i &lt; 12; i++)&#123;                if(ans_str[i] &lt; lower[i])&#123;                    break;                &#125;                if(ans_str[i] &gt; lower[i])&#123;                    return 0;                 &#125;            &#125;        &#125;        if(minus &#x3D;&#x3D; false &amp;&amp; ans_str.length() &#x3D;&#x3D; 11)&#123;            for(int i &#x3D; 0; i &lt; 11; i++)&#123;                if(ans_str[i] &lt; upper[i])&#123;                    break;                &#125;                if(ans_str[i] &gt; upper[i])&#123;                    return 0;                &#125;            &#125;        &#125;        &#x2F;&#x2F;最终结果的转化        &#x2F;&#x2F;stoi函数：string -&gt; int        &#x2F;&#x2F;to_string函数：int -&gt; string        int ans &#x3D; stoi(ans_str);        return ans;    &#125;&#125;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 32 位的有符号整数 &lt;code&gt;x&lt;/code&gt; ，返回将 &lt;code&gt;x&lt;/code&gt; 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数超过 32 位的有符号整数的范围 &lt;code&gt;[−231, 231 − 1]&lt;/code&gt; ，就返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设环境不允许存储 64 位整数（有符号或无符号）。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="leetcode" scheme="tags/leetcode/"/>
    
    <category term="算法" scheme="tags/算法/"/>
    
  </entry>
  
  <entry>
    <title>Decima-Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers</title>
    <link href="2023/01/10/Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers/"/>
    <id>2023/01/10/Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers/</id>
    <published>2023-01-09T17:03:38.000Z</published>
    <updated>2023-01-17T14:49:26.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers"><a href="#Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers" class="headerlink" title="Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)"></a>Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>我们设计了黑盒扰动系统，其中训练了一个代理模型来模仿基于 DRL 的调度策略，并且表明，高可信代理模型可以帮助制作有效的扰动。扰动的意思是对作业的节点特性或依赖性进行轻微调整，同时不改变其功能。</p><p>最终，我们研究了提高基于 DRL 的调度程序对此类扰动的鲁棒性的解决方案：我们提出了一种对抗性训练框架，以强制神经模型在训练过程中适应扰动模式，从而消除应用过程中的潜在损害。</p><span id="more"></span><ul><li><strong>提出问题</strong></li></ul><p>各种研究发现深度神经模型（如DRL模型）容易受到对抗性数据实例的影响（如其观察空间或动作空间输入的扰动）产生错误决策，并且缺乏鲁棒性；而在云计算调度问题中，对鲁棒性也有很高的要求，即使系统中没有恶意用户也有可能会有一些特征模式触发调度程序的不当行为，因此这种鲁棒性问题并不总是与对抗性扰动相关联，但研究它的重要性是绝对的。</p><ul><li><strong>解决思路</strong></li></ul><ol><li>研究如何开发一种有效扰乱工作特征的方法。</li><li>在成功模拟有效扰乱工作特征之后，提出对抗训练方法以提升模型的鲁棒性</li></ol><ul><li><strong>实验结果</strong></li></ul><p>我们的实验表明，这种鲁棒性的提高显着降低了工作扰动的成功率。即使扰动成功，它也会降低扰动作业的性能增益。具有对抗性训练的 DRL 调度器能够实现与原始 DRL 调度器相当的调度性能。</p><h3 id="黑盒扰动系统"><a href="#黑盒扰动系统" class="headerlink" title="黑盒扰动系统"></a>黑盒扰动系统</h3><p>首先提出之前有人设计的白盒扰动系统，白盒方法假设用户可以访问 DRL 模型的详细信息，包括模型架构和参数。但白盒扰动系统存在这样一个问题：对于调度策略未知的许多云系统，该假设通常不成立。</p><p>因此工作扰动系统采用黑盒假设来解决这个问题，这意味着恶意用户无法访问 DRL 模型和其他用户的工作，如下图中的阴影方块所示。</p><p><img src="http://cdn.leafii.top/img/image-20230116152713038.png" alt="image-20230116152713038" loading="lazy"></p><p>其核心技术是模型窃取，即利用制造的数据集训练本地代理模型作为目标模型的替代品。代理模型不需要与其目标具有相同的结构，而只是模仿功能。</p><p>恶意用户通过模仿得到相同种类但细节不同的job，然后将job在空闲时间提交以获得调度程序的神经模型。通过执行完成后的调度轨迹，可以得知调度程序在每个时间步做出怎样的决策。因此，它只通过几个调度轨迹就得到了一个比较可信的代理神经网络。并且通过job状态和决策形成的元组，它将一个调度问题解耦成了一个分类问题。</p><p>在该代理模型的帮助下，恶意用户就可以在job提交之前计算并且应用扰动（增加一些任务的并行度或者在任务之间增加依赖关系）来获得额外的计算资源以达成早一些完成任务的目的。</p><h3 id="作业扰动"><a href="#作业扰动" class="headerlink" title="作业扰动"></a>作业扰动</h3><p>作业扰动的目的是在某些时间步将调度决策偏向错误的方向。</p><p><strong>成功施加扰动的难点</strong>：</p><p>首先，扰动可以应用于作业中多达数百个特征，并且很难获得最优计划。</p><p>其次，扰动作业试图抢占动态系统中的资源。它会在调度过程中的一个确定的时间步发生。具体成功时间由当时的系统状态快照决定，这是系统禁止的。</p><h4 id="基于梯度的扰动"><a href="#基于梯度的扰动" class="headerlink" title="基于梯度的扰动"></a>基于梯度的扰动</h4><h5 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h5><p>$job_k$ 的特征形成一个 $m \times n $矩阵 $X_k : (x_i,j)$，其中 $m_k$ 是任务数，$n$ 是特征数。此外，只有解决了任务的依赖关系才能执行任务，这些依赖关系由相邻矩阵 $E_k : (e_i,j)$ 表示，其中 $i, j \in [1, m_k]$。</p><p><strong>关于扰动</strong>：我们只会扰乱<strong>并行性</strong>和<strong>依赖性</strong>。</p><h5 id="特征扰动"><a href="#特征扰动" class="headerlink" title="特征扰动"></a>特征扰动</h5><p>在调度程序执行的过程中，一个任务是否被优先调度取决于它的得分。为了让被扰动的作业优先执行且占用更多资源，必须通过扰动让被扰动的作业获得更高的分数，只有获得更高的分数，它才能被执行。被扰动的作业优先被调度时必须满足下面公式：</p><p>$O_t[\bar{o_t}] &gt; O_t[o_t]$</p><p>但是本身被扰动的作业在被扰动前它的$O_t[\bar{o_t}]$就同$O_t[o_t]$相差很大，因此需要通过扰动使其获得更高的分数。为了决定扰动哪个特征可以使分数增加更多，提出了特征梯度的概念。</p><p>$\nabla \chi_tO_t[\bar{o_t}] &#x3D; \frac{\partial O_t[\bar{o_t}]}{\partial \chi_t}$</p><p>通过特征梯度可以得知作业中哪个特征的扰动对$O_t[o_t]$值的影响更显著。因此可以通过下面式子得知哪个task的哪个feature应该被选择去扰动。</p><p>$T^*, f^* &#x3D; argmax[\frac{\partial O_t[\bar{o_t}]}{\partial \chi_t}]$</p><p>确定了对哪个特征进行扰动，就该进行扰动的实际操作了，沿着值方向对特征进行增量应用扰动，如下式：</p><p>$x_{T^*, f^*} &#x3D; x_{T^*, f^*} + sign([\frac{\partial O_t[\bar{o_t}]}{\partial \chi_t}]_{T^*, f^*}) \times \delta$</p><h5 id="依赖扰动"><a href="#依赖扰动" class="headerlink" title="依赖扰动"></a>依赖扰动</h5><p>因此不能破坏原有任务的依赖性，因此所谓的依赖扰动就是通过加入以前独立的任务来应用依赖性扰动。它的评判标准被定义为下面的式子：</p><p>$\nabla \varepsilon_tO_t[\bar{o_t}] &#x3D; avg[\frac{\partial O_t[\bar{o_t}]}{\partial \varepsilon_t^i}] &#x3D; \frac{1}{K}\sum_{i&#x3D;1}^{K} \frac{\partial \bar{\pi_\theta}(\chi_t, \varepsilon_t^i)}{\partial \varepsilon_t^i}$</p><p>边缘梯度在相邻矩阵 $E_t$ 上形成显着图，其中较高的值表示在应用扰动时输出分量的改进更为显着。因此，在任务$T_f^*$和任务$T_t^*$之间的边被添加了：</p><p>$T_f^*, T_t^* &#x3D; argmax(avg[\frac{\partial O_t[\bar{o_t}]}{\partial \varepsilon_t^i}])$</p><p>识别出的边缘还应该满足这两个任务都属于恶意用户的工作并且之前是独立的。否则，上面的式子将继续寻找下一条除了不满足条件外显着性值最大的边。</p><h4 id="近似扰动"><a href="#近似扰动" class="headerlink" title="近似扰动"></a>近似扰动</h4><p>由于矩阵$\chi_t$和$\varepsilon_t$ 的一些部分不可访问，因此在训练过程中，通过自己的定义，将之前方程中梯度的专用分量可以通过每个独立输入作业的梯度来近似。</p><p>$T^*, f^* \approx argmax[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{X_t}}]$</p><p>$T_f^*, T_t^* \approx argmax(avg[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{E_t^i}}])$</p><p>当原始调度决策不那么明显时，在时间步长 t 应用扰动是至关重要的。我们通过近似来解决决定时间步长的问题。</p><p>通过用原始工作特征$\hat{X}$和$\hat{E^i}$替换即时的工作特征$\hat{X_t}$和$\hat{E_t^i}$。我们以工作的关键路径上的所有任务为目标进行综合考虑，将上面的两个近似式子重构成了以下式子：</p><p>$T^*, f^* \approx argmax[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{X}}]$</p><p>$T_f^*, T_t^* \approx argmax(avg[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{E^i}}])$</p><p>由于特征和依赖扰动计划都是时不变的，因此可以通过以 O(1) 时间成本提交的作业来计算。</p><h3 id="基于-DRL-的调度器的稳健性改进"><a href="#基于-DRL-的调度器的稳健性改进" class="headerlink" title="基于 DRL 的调度器的稳健性改进"></a>基于 DRL 的调度器的稳健性改进</h3><p>我们描述了一个对抗训练框架来提高 DRL 调度器的稳健性。它通过让调度程序在训练期间学习工作扰动的模式来提高鲁棒性。</p><p>在强化学习中，用来更新策略$\pi$的参数$\theta$的梯度可以通过以下式子获得：</p><p>$g &#x3D; E[\sum_{t&#x3D;0}^{\infin}R_t \nabla log_\theta (\pi_\theta(A_t|S_t))]$</p><p>在对抗训练期间，扰动状态 $S_t^*$ 和原始状态 $S_t$ 一起学习，以将梯度引向$\nabla log_\theta (\pi_\theta(A_t|S_t)) + \nabla log_\theta (\pi_\theta(A_t|S_t^*))$。</p><p>在训练阶段添加这种对抗性扰动可以使模型在寻找最高奖励时不那么极端，如果扰动发生在应用阶段 ，则模型会更加稳健。</p><p>对抗训练的整体工作流程为：</p><p><img src="http://cdn.leafii.top/img/image-20230116165033169.png" alt="image-20230116165033169" loading="lazy"></p><p>对抗训练框架的示意图：</p><p><img src="http://cdn.leafii.top/img/image-20230116165112449.png" alt="image-20230116165112449" loading="lazy"></p><p>原始状态和扰动状态被馈送到模型中进行梯度计算，并使用相同的奖励信号更新模型。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h4><p>我们使用 Decima的作业执行引擎作为我们的测试平台。</p><p>在我们的实验中，我们将集群的执行器数量设置为 10 和 20。我们使用 TPC-H 作业 [41] 作为工作负载。作业的统计信息，包括每个作业 DAG 中的级别、任务数以及每个任务的并行度和持续时间，如表 2 所示。作业运行时间遵循重尾分布，大约 20% 的作业占用所有作业运行时间的 80%。</p><p><img src="http://cdn.leafii.top/img/image-20230116171153629.png" alt="image-20230116171153629" loading="lazy"></p><p>我们实现了三种 DRL 算法作为 Decima 调度框架的插件，以证明这个问题对于不同的 DRL 算法是常见的。</p><p>第一种算法是REINFORCE，其每个时间步的奖励是通过使用情景样本的蒙特卡洛方法估计的，原始 Decima 调度程序也使用该方法。</p><p>第二种算法是off-policy policy gradient(OPPG),它使用行为策略来推导调度决策并计算另一个目标策略的重要性采样。</p><p>第三种算法是同步优势演员评论家 (A2C)，参与者(actor)使用策略模型生成动作，而评论家(critic)则使用另一个神经模型来预测每个动作的优势.每个模型中的核心策略都是用全连接神经网络实现的。实际上，A2C 使用 5 种不同的陈旧版本。 A2C 中的演员和评论家由不同的全连接层组成。actor 具有动态数量的输出，形成任务的概率分布，而 critic 仅输出一个单元。</p><p>图神经网络结合了非线性激活和聚合函数，这为调度程序提供了输入的全局视图，以获得更好的调度策略。</p><p>调度程序的脆弱性是通过它们受工作扰动影响的可能性来衡量的。成功的扰动会抢占资源以提前完成扰动的工作，同时延迟其他工作.</p><p>评估脆弱性的三个指标：扰动的成功率、扰动工作的好处（通过降低 JCT(任务完成时间) 来衡量）以及显着延迟的工作数量。而稳健性的提高是通过这些指标的减少来衡量的。</p><h4 id="模型窃取"><a href="#模型窃取" class="headerlink" title="模型窃取"></a>模型窃取</h4><p>忠实的代理神经模型对于<strong>黑盒扰动</strong>的成功至关重要。我们启动 50 个查询来窃取作业调度程序中的模型。每个查询包含 20 个根据时间步长安排的模拟作业。总的来说，我们从 11,000 个调度时间步长中获得了状态和动作对。其中 80% 用于训练，其余 20% 用于测试。代理模型学习如何在每个时间步将调度程序从数百个其他任务中选择的任务分类。最终实验结果表明：CNN 模型达到了 82.2% 的精度来近似 REINFORCE，而 GCN 达到了 85.0% 的精度来近似 OPPG。</p><p><img src="http://cdn.leafii.top/img/image-20230116181602908.png" alt="image-20230116181602908" loading="lazy"></p><h4 id="基于-DRL-的调度程序的脆弱性"><a href="#基于-DRL-的调度程序的脆弱性" class="headerlink" title="基于 DRL 的调度程序的脆弱性"></a>基于 DRL 的调度程序的脆弱性</h4><p>在本节中，进行了多次实验来评估漏洞。在每个实验中，提交了 50 个作业，其中一个作业被扰动了。独立评估不同的基于 DRL 的调度程序。将每个作业的作业完成时间与在相同设置但没有作业扰动的情况下获得的作业完成时间进行比较。</p><p><img src="http://cdn.leafii.top/img/image-20230116181800279.png" alt="image-20230116181800279" loading="lazy"></p><p>(a) 黑盒作业扰动干扰每个基于 DRL 的调度程序的成功率。 (b) 受扰动工作的好处（以减少的 JCT 衡量）和由于扰动工作的好处而严重延迟的正常工作（其 JCT 增加超过 5%）的数量。</p><p><strong>最终结果</strong>：REINFORCE 比其他两个调度程序更容易受到扰动，因为后者有超过 10 个正常作业被显着延迟。 OPPG和A2C的鲁棒性更强主要是因为独立行为策略或批评模型达到了一定的鲁棒性。</p><h4 id="对于扰动的详细说明"><a href="#对于扰动的详细说明" class="headerlink" title="对于扰动的详细说明"></a>对于扰动的详细说明</h4><p>为了理解基于 DRL 的调度器的脆弱性，我们首先给出扰动的统计数据，然后给出一个详细的例子来说明扰动是如何产生影响的。</p><p><strong>在改变并行度方面</strong>：并行度的降低是通过为数据分区插入“合并”运算符来实现的，而并行度的增加是通过在任务代码的开头添加运算符“repartition”来实现的。</p><p><strong>在增加依赖方面</strong>：两个任务的连接是通过“连接”的运算符实现的。</p><p>通过以上方式成功实现了扰动。</p><p><img src="http://cdn.leafii.top/img/image-20230116182309070.png" alt="image-20230116182309070" loading="lazy"></p><p>不同类型的扰动。从左到右，作业受到 (i) 仅增加任务并行度，(ii) 降低作业并行度并添加依赖项，以及 (iii) 仅添加依赖项的干扰。</p><h4 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h4><p>我们提供了一个案例研究来解释用不同方法扰乱的工作如何使他们的 JCT 受益，如图9所示：</p><p><img src="http://cdn.leafii.top/img/image-20230116183729916.png" alt="image-20230116183729916" loading="lazy"></p><p>扰动或调整后的并行度由每个任务节点周围的数字显示。示例作业没有依赖性变化，因为显着性值太低，即改变依赖性不会导致成功的扰动。</p><p>我们使用 REINFORCE 调度程序比较每个扰动作业的任务执行模式和同一环境中的原始作业，如图10所示：</p><p><img src="http://cdn.leafii.top/img/image-20230116183920593.png" alt="image-20230116183920593" loading="lazy"></p><p><strong>实验结果表明</strong>：经过扰动后，这些任务能够在某些调度步骤中具有更高的优先级。这些任务以更高的并行度执行，因此更早完成。它们的完成也可能导致依赖于它们的后续任务的提前执行。</p><h4 id="鲁棒性的提升"><a href="#鲁棒性的提升" class="headerlink" title="鲁棒性的提升"></a>鲁棒性的提升</h4><p>在本节中，我们评估了对抗训练在提高基于 DRL 的调度程序处理扰动工作的鲁棒性方面的有效性。</p><h5 id="对抗训练"><a href="#对抗训练" class="headerlink" title="对抗训练"></a>对抗训练</h5><p>一个健壮的基于 DRL 的调度器的实现方式与第 6.1 节中详述的方式类似。我们还在调度程序中包含了不同的强化学习实现，即 REINFORCE、OPPG 和 A2C。</p><p>每个调度器的正常训练和对抗训练的过程如图11的左栏所示：</p><p><img src="http://cdn.leafii.top/img/image-20230116184150766.png" alt="image-20230116184150766" loading="lazy"></p><blockquote><p>左列显示了基于 DRL 的调度程序的正常和对抗训练过程。每个模型的收敛由平均奖励的扁平化表示。右列显示了基本调度程序和鲁棒调度程序在 50 个作业集上的调度性能。剩余作业数量减少得越快，调度性能越好。具体来说，Reinforce的图如(a)和(b)所示，OPPG的图如(c)和(d)所示，A2C的图如(e)和(f)所示。</p></blockquote><p>该过程的特点是在每个情节中获得的归一化平均奖励。在训练过程中包括受扰动的工作会使收敛花费更长的时间，并且收到的奖励会波动（图 11a 和 11e）。</p><h5 id="调度表现"><a href="#调度表现" class="headerlink" title="调度表现"></a>调度表现</h5><p>我们将每个基于 DRL 的鲁棒调度程序的调度性能与基本对应调度程序进行比较。Jobs的执行流程如图11右栏所示。</p><p>总而言之，强大的 DRL 调度器保持了令人满意的调度性能。</p><h5 id="鲁棒性评估"><a href="#鲁棒性评估" class="headerlink" title="鲁棒性评估"></a>鲁棒性评估</h5><p>我们在“基于 DRL 的调度程序的脆弱性”的相同实验设置下评估了基于 DRL 的鲁棒调度程序的脆弱性，并将展示鲁棒性改进。</p><p>总的来说，我们的对抗训练方法可以提高基于 DRL 的调度程序的鲁棒性并减少工作扰动的影响。</p><h4 id="白盒扰动的脆弱性"><a href="#白盒扰动的脆弱性" class="headerlink" title="白盒扰动的脆弱性"></a>白盒扰动的脆弱性</h4><p>在“Whitebox”中，它拥有了一个更强的假设，即用户可以完全访问 DRL 模型。特征中的所有显着性值空间是在原始 DRL 模型而不是代理模型上计算的。在本节中，我们评估鲁棒调度程序是否也对白盒扰动具有鲁棒性。</p><p><img src="http://cdn.leafii.top/img/image-20230116185045106.png" alt="image-20230116185045106" loading="lazy"></p><p>总的来说，通过代理模型训练的鲁棒调度器可以有效地处理白盒模型产生的扰动作业。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本文中，我们探讨了基于 DRL 的调度程序的稳健性问题。 我们展示了用户可以在代理模型的帮助下扰乱作业以进行抢占，代理模型是为模仿基于 DRL 的调度程序的调度行为而开发的。 就工作自然具有某些特征模式而言，扰动可能是无意的。 这可能导致调度行为的不确定性。 我们提出了一种计算作业扰动的算法，并表明扰动作业具有很高的成功率以获得高调度优先级。 我们表明这种扰动对调度程序有害，因为它会导致系统中其他作业的意外延迟。 我们设计了一个对抗训练框架来提高 DRL 调度程序的稳健性。 广泛的实验表明，鲁棒调度器在保持高调度性能的同时不易受到扰动的影响。</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>TPC-H, 2020. [Online]. Available: <a href="http://www.tpc.org/tpch/">http://www.tpc.org/tpch/</a> default5.asp</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ieeexplore.ieee.org/abstract/document/9937194">Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers&quot;&gt;&lt;a href=&quot;#Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers&quot; class=&quot;headerlink&quot; title=&quot;Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)&quot;&gt;&lt;/a&gt;Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)&lt;/h2&gt;&lt;h3 id=&quot;解决的问题&quot;&gt;&lt;a href=&quot;#解决的问题&quot; class=&quot;headerlink&quot; title=&quot;解决的问题&quot;&gt;&lt;/a&gt;解决的问题&lt;/h3&gt;&lt;p&gt;我们设计了黑盒扰动系统，其中训练了一个代理模型来模仿基于 DRL 的调度策略，并且表明，高可信代理模型可以帮助制作有效的扰动。扰动的意思是对作业的节点特性或依赖性进行轻微调整，同时不改变其功能。&lt;/p&gt;
&lt;p&gt;最终，我们研究了提高基于 DRL 的调度程序对此类扰动的鲁棒性的解决方案：我们提出了一种对抗性训练框架，以强制神经模型在训练过程中适应扰动模式，从而消除应用过程中的潜在损害。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="tags/python/"/>
    
    <category term="强化学习" scheme="tags/强化学习/"/>
    
  </entry>
  
</feed>
