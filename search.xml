<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode107.二叉树的层序遍历II</title>
      <link href="/2023/06/05/leetcode107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II/"/>
      <url>/2023/06/05/leetcode107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用了层次遍历的思想，利用队列实现。具体解题思路如下：</p><ol><li>首先定义树的节点结构 <code>TreeNode</code>，包含节点值 <code>val</code>、左子节点指针 <code>left</code> 和右子节点指针 <code>right</code>。</li><li>定义一个函数 <code>levelOrderBottom</code>，该函数接受树的根节点 <code>root</code>，并返回层次遍历的结果。</li><li>在 <code>levelOrderBottom</code> 函数中，首先创建一个空的二维向量 <code>result</code>，用于保存最终的结果。</li><li>若根节点为空，直接返回空的结果向量 <code>result</code>。</li><li>创建一个队列 <code>q</code>，将根节点 <code>root</code> 入队。</li><li>进入循环，直到队列为空：<ul><li>获取当前层的节点数量 <code>levelSize</code>，这是为了在遍历当前层时，仅遍历当前层的节点。</li><li>创建一个空的向量 <code>level</code>，用于保存当前层的节点值。</li><li>进入内层循环，遍历当前层的节点：<ul><li>取出队首节点 <code>node</code>。</li><li>弹出队首节点。</li><li>将节点值 <code>node-&gt;val</code> 添加到当前层的结果向量 <code>level</code> 中。</li><li>若节点的左子节点不为空，将左子节点入队。</li><li>若节点的右子节点不为空，将右子节点入队。</li></ul></li><li>将当前层的结果向量 <code>level</code> 插入到结果向量 <code>result</code> 的开头，这是为了保持结果的逆序。</li></ul></li><li>循环结束后，返回结果向量 <code>result</code>。</li><li>在 <code>main</code> 函数中，创建一个测试用例 <code>[3,9,20,null,null,15,7]</code> 的树。</li><li>调用 <code>levelOrderBottom</code> 函数，获取层次遍历的结果，并输出结果。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result; &#x2F;&#x2F; 保存最终的结果        if (root &#x3D;&#x3D; NULL) &#123;            return result;        &#125;        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 创建一个队列，用于层次遍历        q.push(root); &#x2F;&#x2F; 将根节点入队        while (!q.empty()) &#123;            int levelSize &#x3D; q.size(); &#x2F;&#x2F; 当前层的节点数量            vector&lt;int&gt; level; &#x2F;&#x2F; 保存当前层的节点值            for (int i &#x3D; 0; i &lt; levelSize; i++) &#123;                TreeNode* node &#x3D; q.front(); &#x2F;&#x2F; 取出队首节点                q.pop(); &#x2F;&#x2F; 弹出队首节点                level.push_back(node-&gt;val); &#x2F;&#x2F; 将节点值保存到当前层的结果中                if (node-&gt;left !&#x3D; NULL) &#123;                    q.push(node-&gt;left); &#x2F;&#x2F; 将左子节点入队                &#125;                if (node-&gt;right !&#x3D; NULL) &#123;                    q.push(node-&gt;right); &#x2F;&#x2F; 将右子节点入队                &#125;            &#125;            result.insert(result.begin(), level); &#x2F;&#x2F; 将当前层的结果插入到结果向量的开头        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode297.二叉树的序列化与反序列化</title>
      <link href="/2023/06/02/leetcode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/06/02/leetcode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode.cn/hc/kb/article/1567641/">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/serdeser.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[1]</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 104]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>层序遍历序列化</li></ul><p>解题思路：</p><p>对于序列化操作，我们使用层序遍历将二叉树转化为字符串。使用队列辅助遍历，从根节点开始，依次处理每个节点，若节点为空则用字符串”null”表示，否则将节点值转化为字符串，并将其左右子节点加入队列。最后去掉最后一个多余的分隔符”,”并返回结果字符串。</p><p>对于反序列化操作，我们使用stringstream来分割字符串，并依次处理每个节点。首先根据第一个值创建根节点，并加入队列。然后依次处理队列中的节点，每次从字符串中读取两个值，分别表示当前节点的左右子节点的值。若值为”null”，则表示该节点为空，否则创建相应的节点，并加入队列。重复上述过程直到队列为空。最后返回根节点即可。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Codec &#123;public:    &#x2F;&#x2F; Encodes a tree to a single string.    string serialize(TreeNode* root) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return &quot;null&quot;;        &#125;                &#x2F;&#x2F; 使用层序遍历将二叉树转化为字符串        string result;        queue&lt;TreeNode*&gt; q;        q.push(root);                while (!q.empty()) &#123;            TreeNode* node &#x3D; q.front();            q.pop();                        if (node !&#x3D; nullptr) &#123;                &#x2F;&#x2F; 非空节点，将节点值转化为字符串                result +&#x3D; to_string(node-&gt;val);                                &#x2F;&#x2F; 将左右子节点加入队列                q.push(node-&gt;left);                q.push(node-&gt;right);            &#125; else &#123;                &#x2F;&#x2F; 空节点，用&quot;null&quot;表示                result +&#x3D; &quot;null&quot;;            &#125;                        &#x2F;&#x2F; 每个节点值后面加上分隔符&quot;,&quot;            result +&#x3D; &quot;,&quot;;        &#125;                &#x2F;&#x2F; 去掉最后一个多余的分隔符&quot;,&quot;        result.pop_back();                return result;    &#125;    &#x2F;&#x2F; Decodes your encoded data to tree.    TreeNode* deserialize(string data) &#123;        if (data &#x3D;&#x3D; &quot;null&quot;) &#123;            return nullptr;        &#125;                &#x2F;&#x2F; 使用stringstream分割字符串        stringstream ss(data);        string item;        queue&lt;TreeNode*&gt; q;                &#x2F;&#x2F; 获取根节点值        getline(ss, item, &#39;,&#39;);        int rootVal &#x3D; stoi(item);        TreeNode* root &#x3D; new TreeNode(rootVal);        q.push(root);                while (!q.empty()) &#123;            TreeNode* node &#x3D; q.front();            q.pop();                        &#x2F;&#x2F; 依次获取当前节点的左右子节点值            &#x2F;&#x2F; 并创建相应的节点            &#x2F;&#x2F; 左右子节点值为&quot;null&quot;时表示为空节点            getline(ss, item, &#39;,&#39;);            if (item !&#x3D; &quot;null&quot;) &#123;                int leftVal &#x3D; stoi(item);                TreeNode* leftNode &#x3D; new TreeNode(leftVal);                node-&gt;left &#x3D; leftNode;                q.push(leftNode);            &#125;                        getline(ss, item, &#39;,&#39;);            if (item !&#x3D; &quot;null&quot;) &#123;                int rightVal &#x3D; stoi(item);                TreeNode* rightNode &#x3D; new TreeNode(rightVal);                node-&gt;right &#x3D; rightNode;                q.push(rightNode);            &#125;        &#125;                return root;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode236.二叉树的最近公共祖先</title>
      <link href="/2023/06/01/leetcode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2023/06/01/leetcode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/binarytree.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/binarytree-20230601095804160.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2输出：1</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归遍历求解</li></ul><p>解题思路如下：</p><ol><li>首先，我们需要明确最近公共祖先的定义。在二叉树中，节点A是节点B和节点C的最近公共祖先，意味着节点A是同时包含节点B和节点C的子树中最深的节点。</li><li>从根节点开始遍历二叉树。如果当前节点是p或q中的一个，我们可以返回该节点，因为我们已经找到了一个目标节点。</li><li>递归地在左子树和右子树中寻找p和q。如果在左子树中找到了p或q的最近公共祖先，或者在右子树中找到了p或q的最近公共祖先，那么返回该节点。</li><li>如果左子树和右子树都没有找到p和q的最近公共祖先，那么返回根节点。</li></ol><p>这个思路的关键在于理解最近公共祖先的定义，并通过递归的方式遍历二叉树。通过在左右子树中的递归调用，我们可以找到p和q的最近公共祖先，或者在当前节点返回p或q其中的一个节点，从而实现最近公共祖先的查找。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        &#x2F;&#x2F; 如果当前节点是p或q或者为空，直接返回该节点        if (root &#x3D;&#x3D; nullptr || root &#x3D;&#x3D; p || root &#x3D;&#x3D; q) return root;                TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q); &#x2F;&#x2F; 得到root左子树拥有p或者q的最近祖先        TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q); &#x2F;&#x2F; 得到root右子树拥有p或者q的最近祖先                if (left &amp;&amp; right) return root; &#x2F;&#x2F; 如果左子树和右子树得到的结果都不为空，那么它们的最近公共祖先就是根节点        return left ? left : right; &#x2F;&#x2F; 返回left和right中不为空的那个，如果都为空，那么返回哪个都一样咯    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeepMAG-使用多智能体图进行深度强化学习以实现灵活的作业车间调度</title>
      <link href="/2023/05/31/DeepMAG-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%9B%BE%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BD%9C%E4%B8%9A%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6/"/>
      <url>/2023/05/31/DeepMAG-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%9B%BE%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BD%9C%E4%B8%9A%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling"><a href="#DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling" class="headerlink" title="DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling"></a>DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>一般的柔性车间调度执行基于两个决策步骤：任务次序（比如在一个机器上任务的执行顺序）以及任务路由（比如一个任务到一个机器的路径）。大多数现有的研究利用DRL或者MARL在大的搜索空间进行调度。<strong>但是</strong>这些研究有两个主要的限制：在DRL和MARL之间没有进行结合，独立的智能体之间没有合作。DeepMAG有两个关键贡献：1. DRL和MARL之间的结合。DeepMAG 通过将不同的智能体与每台机器和作业相关联，将 DRL 与 MARL 集成。每个智能体都利用 DRL 来找到有关作业排序和路由的最佳操作。在作业关联智能体选择最佳机器后，该作业成为机器进行下一个操作的作业候选者，而机器关联智能体从其作业候选集中选择下一个作业进行处理。2. 合作智能体。基于机器和作业之间的操作关系构建多智能体图。一个智能体与其相邻的智能体合作采取一个合作行动。最后，我们进行实验来评估 DeepMAG 的性能，实验结果表明它优于最先进的技术。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>作业车间调度 (JSS) 是最流行的调度问题之一，由于其在实际工厂中的广泛适用性，已被研究了几十年 [1]。 JSS 的决策步骤是通过在特定时间在特定机器上执行作业来对作业进行排序，其中 (1) 每个作业的操作需要按给定顺序（即<strong>优先约束</strong>）处理，(2) 每台机器只能处理一个任何时候作业的操作（即排除约束），以及（3）每个作业操作都有一台唯一的机器（即唯一约束）。而FJSS满足<strong>优先和排除约束</strong>但将<strong>唯一约束</strong>放宽为<strong>常量约束</strong>，其中作业的每个操作都可以在给定的常量机器集(Set)中的任何机器上处理，而不是在一台唯一的机器上处理。除了 JSS 中的作业排序（即作业在机器上执行的顺序）之外，FJSS 在作业路由上还有一个额外的决策步骤（即作业的每个操作到给定恒定机器集中的机器的路线） .</p><p><img src="http://cdn.leafii.top/img/image-20230525205309249.png" alt="image-20230525205309249" loading="lazy"></p><p>在现有的近似计算方法中，调度规则（Dispatching rules）很难得到满足真实生活应用的调度解；启发式搜索方法可以有效地到达可能的解，但是容易陷入局部最优；强化学习方法表现出了潜力，并且相较于其他方法更有到达精确最优解的潜能。但是这些方法有两个主要的缺陷：</p><ol><li><p>没有把DRL和MARL进行结合。</p><p>大多数研究工作将 DRL 用于大型状态空间 或将 MARL 用于大型动作空间。他们没有将 DRL 与 MARL 集成来解决 FJSS 中同时具有大状态和动作空间的难题。</p></li><li><p>独立的智能体。</p><p>当前的研究利用多个智能体来管理大的动作空间，但这些智能体彼此独立。结果，每个智能体都为一个子空间找到了自己的最优阶乘动作，而来自所有智能体的这些阶乘动作不一定构成一个最优联合动作。</p></li></ol><p>为了解决这两个限制，本文提出了一种基于深度强化学习和多智能体图的 FJSS 新模型，称为 DeepMAG，它具有两个重要特征。 </p><ol><li>DRL与MARL的融合。 DeepMAG 通过将每台机器或作业与一个独特的智能体相关联，将 DRL 集成到 MARL 中，该智能体利用 DQN 为机器关联的智能体找到作业排序的最佳操作，以选择下一个要处理的作业（如果可用）或作业路由作业相关的智能体在当前操作完成时选择一台机器进行下一个操作。此外，所有与机器相关的智能体共享一个 DQN，而所有与作业相关的智能体共享另一个。 </li><li>合作智能体。 DeepMAG 构建了一个多智能体图，由作为节点的智能体组成，节点基于机器处理作业操作的顺序和可以处理的作业的可能操作。每个智能体通过观察它们的操作关系并在每一步聚合相邻信息以采取一个合作行动来与其相邻智能体合作。</li></ol><p>本文的主要贡献可以概括为：</p><ul><li>我们通过将 DRL 与 MARL 集成，为 FJSS 开发了一个新模型 DeepMAG。 DRL 利用 DQN 来处理大状态空间，而 MARL 利用多个智能体来管理大动作空间。</li><li>我们设计了一个多智能体图，该图源自机器和作业之间的操作关系，包括机器的处理顺序和当前时间步正在机器上处理的作业的操作。所有智能体合作寻找最佳行动，以保证 DeepMAG 的良好回报。 </li><li>我们进行了广泛的实验，使用来自真实制造工厂的设置的模拟数据来评估 DeepMAG 的性能。实验结果表明，DeepMAG 明显优于其他竞争技术。</li></ul><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>将对JSS和FJSS的研究分为四类：计算优化方法(Operational optimization methods)，调度规则(Dispatching rules)，启发式搜索方法(Heuristic search methods)，强化学习(Reinforcement learning (RL) methods)；具体介绍略</p><h2 id="Problem-statement"><a href="#Problem-statement" class="headerlink" title="Problem statement"></a>Problem statement</h2><p>我们在第 3.1 节介绍了预备知识，并在第 3.2 节定义了 DeepMAG 的研究问题。在接下来的问题定义中，（1）大写字母表示一个随机变量，它相应的小写字母表示一个随机值，比如S是状态变量，s是S的状态值；（2）粗体字母表示向量，例如，<strong>S</strong>是状态变量向量，s是<strong>S</strong>的状态值向量。(3) 书法字母表示一组值，例如，S 表示一组状态值 s的集合。 (4) 黑板上的粗体字母表示函数，例如$\mathbb{P}$ 表示概率函数。 (5) 打字机字母表示一个常数，例如，p 表示生产率。</p><h3 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h3><p>Definition 3.1 (Markov Decision Process (MDP)).有限 MDP 是一个 4 元组 (S, A, R, P)，其中 S 是状态的有限集，A 是动作的有限集，R 是数字奖励的有限集，P 是四元组参数条件概率质量函数：</p><p>$\mathbb{P}(s’,r|s,a) &#x3D; Pr{S_{t+1} &#x3D; s’, R_{t+1} &#x3D; r|S_t &#x3D;s, A_t &#x3D; a}, (1)$</p><p>对于所有 s，s′ ∈ S，r ∈ R，a ∈ A。P(s′, r|s, a) 表示状态 s′ 和奖励 r 在时间步 t + 1 发生的概率，给定前面的状态 s 和动作 a 在时间步 t，它完全体现了有限 MDP 的动态。</p><p>在 MDP 中，智能体在每个连续的离散时间步与环境交互。在每个时间步 t，智能体接收环境的状态 St，从中选择一个动作 At。一个时间步之后，作为其选择 At 的结果，智能体收到数字奖励 Rt+1，并发现自己处于新状态 St+1。智能体选择动作 At 来最大化它在未来收到的折扣奖励的总和，这称为回报(return)。</p><p>Definition 3.2 (Return).回报 Gt 定义为在时间步 t 后收到的折扣奖励的总和：</p><p>$G_t &#x3D; R_{t+1} + \gamma R_{t+2} + \gamma^2R_{t+3} + … &#x3D; \sum_{n&#x3D;1}^{\infty}\gamma^{n-1}R_{t+n}(2)$，其中$\gamma$为折扣率。</p><p>智能体的目标是最大化其奖励的总量，这意味着最大化的不是即时奖励，而是长期的累积奖励。贴现率决定未来奖励的现值：在第 n 个未来时间步收到的奖励 Rt+n 乘以贴现率的 n-1 次方，即 γ n−1Rt+n。现实世界的问题，例如 JSS 和 FJSS，对于集中式智能体来说往往太大而无法解决。因此，研究人员研究了一个分布式多智能体系统，其中多个智能体在同一环境中行动以完成特定任务。因此，MDP 的定义可以扩展到这样的多智能体系统（定义 3.3）。</p><p>Definition 3.3 (Multi-agent MDP).多智能体 MDP 是一个 5 元组$ (\mathcal{I, S, A, R}, \mathbb{P})$，其中 I 是一组智能体，S 是可以分解为 $\mathcal{I}$的状态集。分量 $S &#x3D; S_1 × · · · × S_{|I|}$，$A &#x3D; A_1 × · · · × A_{|I|}$因此，共享相同奖励集 R 的智能体要执行的联合动作集，条件概率质量函数 P 由下式给出</p><p>$\mathbb{P}(s’,r|s,a) &#x3D; Pr{S_{t+1} &#x3D; s’, R_{t+1}&#x3D;r|S_t &#x3D; s, A_t &#x3D; a},(3)$，其中的s是所有智能体的状态$s_i$，A是所有智能体的动作$A_i$；</p><p>在多智能体 MDP 中，所有智能体在环境中观察自己的局部状态，采取各自的行动，并获得相同的奖励以相互合作完成相同的任务。 MARL 基于多智能体 MDP，通过将联合行动空间划分为多个具有阶乘行动的子空间来解决具有大联合行动空间的问题。每个智能体都可以直接应用各种 RL 方法将每个状态映射到最佳动作。具体来说，基于智能体 i ∈ I 的策略 π，使用 DQN 对具有大状态空间 Si 的状态-动作值函数 Q(si, ai) 进行参数化。</p><p>Definition 3.4 (Value Function).智能体 i ∈ I 在策略 π 下在状态 si 采取行动 ai 的值，表示为 Q(si, ai)，是在时间步 t 从 si 开始采取行动 ai，然后跟随 π 的预期回报，给定经过</p><p>$\mathbb{Q}(s_i, a_i) &#x3D; \mathbb{E}[G_t|S_t^i &#x3D; s_i, A_t^i &#x3D; a_i]$;在 DQN 中，π 是关于学习到的状态-动作值函数 Q(si, ai) 的贪心策略。</p><p>Definition 3.5 (Greedy Policy).对于任何状态-动作值函数 Q，相应的贪心策略 π 是确定性地选择具有最大值的动作 $a_i^*$ 的策略：</p><p>$a_i^* &#x3D; \pi(s_i) &#x3D; arg max \mathbb{Q}(s_i, a_i), for each s_i \in S_i$</p><h3 id="Problem-definition"><a href="#Problem-definition" class="headerlink" title="Problem definition"></a>Problem definition</h3><p>在本节中，我们定义了 MARL 框架中针对 FJSS 研究问题的重要概念。</p><p>环境(Environment)。 FJSS 的环境包括一组机器和一组作业，其中作业被路由到特定机器并在特定时间顺序处理。特别地，FJSS 环境包含第 1 节中提到的三个重要约束：（1）优先约束给出每个作业中操作的处理顺序，（2）排除约束要求在任何机器上处理的作业中最多有一个操作时间，以及（3）常量约束为作业的每个操作指定一个常量机器集。</p><p>智能体(Agents).每个智能体与环境交互，从中学习，然后做出决定。为了处理具有大动作空间的 FJSS，每台机器都与一个作业排序智能体相关联，方法是从机器的本地等待队列（即其作业候选集）中选择下一个作业，以便在可用时进行处理，而每个作业都是通过在当前操作完成时选择一台机器来处理其下一个操作，与作业路由的智能体相关联，然后该作业成为该机器的作业候选者。这些智能体一起工作，根据当前环境状态确定它们的最佳行动。</p><p>状态(States).状态是指环境的表示，包括机器和作业的各种特征，例如，机器的生产率及其关系、正在执行和可用于每个操作的机器数量，以及作业的工作量已完成或保留在不同的操作中。环境有一个全局状态，但每个智能体可能会观察到不同的局部状态。智能体在每个时间步采取行动后，全局状态会转换为新状态。</p><p>动作(Actions).有两种类型的智能体用于不同的操作。 与机器相关的智能体负责作业排序，并在相应机器可用时决定选择哪个作业进行处理。 与作业相关的智能体负责作业路由，并决定在当前操作完成时选择哪台机器来处理相应作业的下一个操作。 换句话说，机器相关智能体的动作是从工作候选集中选择一个工作，而工作相关智能体的动作是从一组固定的机器中选择一台机器。 重要的是要注意，智能体不会在每个时间步都采取行动； 该动作仅在机器可用或作业的当前操作在特定时间步完成时触发。</p><p>奖励(Rewards).在智能体人在时间步 t 采取行动后，他们从环境中收到相同的数字奖励 Rt+1。在每个时间步，奖励设置为 $R_{t+1} &#x3D; r &#x3D; −1$。在 FJSS 中，RL 的目标是最大化作为折扣奖励总和的回报，比如：最小化 makespan，即完成所有工作的总时间步数。</p><p>研究问题(Research problem).给定一组机器 M 和一组作业 J，每台机器 m ∈ M 在任何时候都只处理作业的一个操作（<strong>排除约束</strong>），并且具有指定每个时间步长完成的工作负载的生产率 pm；每个作业 j ∈ J 由 K 个有序操作组成 (oj,1, . . ., oj,K)（<strong>优先约束</strong>）；每个操作 oj,k 只能由一组常量机器 Mj,k ⊂ M（<strong>常量约束</strong>）处理，并且包含工作负载量 qj,k，表示 Mj,k 中给定机器上所需的时间步长。目标是在适当的时间段为特定机器的作业操作找到最佳计划，以最大限度地减少总处理时间，即完工时间。</p><h2 id="The-proposed-DeepMAG"><a href="#The-proposed-DeepMAG" class="headerlink" title="The proposed DeepMAG"></a>The proposed DeepMAG</h2><h3 id="Overview-of-DeepMAG"><a href="#Overview-of-DeepMAG" class="headerlink" title="Overview of DeepMAG"></a>Overview of DeepMAG</h3><p>简要的介绍了用于求解FJSS问题的DeepMAG，其通过两个DQN去进行job routing和job sequencing的决策。对于每一个时间步，DeepMAG按照以下的顺序进行执行。</p><ul><li><strong>Update agent graphs.</strong> DeepMAG 根据机器和作业之间的操作关系（第 4.2 节）<strong>更新</strong>多智能体图及其两种类型的变体（特定于机器的智能体图和特定于作业的智能体图）。</li><li>**Update features for each agent.**根据更新的智能体图，它提取基本特征、以机器为中心的特征和以作业为中心的特征（第 4.3 节）。</li><li>**Update the DQN for job routing.**对于每个准备好处理其对应作业的下一个操作的作业关联智能体，首先提取当前状态和所有候选动作（机器）的表示（第 4.4.2 节），然后深度 Q 学习算法用于从候选机器中选择一个动作来处理作业的下一个操作，更新重放内存，并通过随机梯度下降优化 DQN 的参数（第 4.5 和 4.6 节）。</li><li><strong>Update the other DQN for job sequencing.</strong> 对于每个可用的机器相关智能体，首先提取当前状态和所有候选动作（作业）的表示（第 4.4.1 节），然后应用深度 Q 学习从其候选作业中选择一个动作进行处理，更新回放内存，并通过随机梯度下降优化 DQN 的参数（第 4.5 和 4.6 节）。</li></ul><p>完成所有作业后，将为 FJSS 实例生成一个作业计划。通过在大量的 FJSS 实例上训练 DeepMAG，我们可以得到 DeepMAG 的近似最优参数。</p><h3 id="Multi-agent-graphs"><a href="#Multi-agent-graphs" class="headerlink" title="Multi-agent graphs"></a>Multi-agent graphs</h3><p>为了在job sequencing 和 job routing上大的连续动作空间去掌握FJSS，DeepMAG通过将每个机器或者任务用智能体联系起来来使用MARL。此外，这些智能体能够通过基于机器和作业之间的操作关系（即机器的处理顺序和当前时间步在机器上正在处理的作业的操作）来构建多智能体图的相互协作。需要注意DeepMAG并没有假定有固定数量的operation，并且自然而然地适应具有不同操作数量的场景。以下是多智能体图的定义。</p><p><strong>Definition 4.1</strong> (Multi-agent Graph).给定一组机器 M、一组作业 J 和一组机器 Mj,k ⊂ M 对于每个作业 j ∈ J 的每个操作 k，它们构成一个多智能体图 G &#x3D; (I, Es, Eu, Ev, Ew) 在一个时间步长，其中 I 是一组节点（即智能体）：</p><p>$I &#x3D; M \cup J \ \ \ \ \ \ \ \ (6)$</p><p>Es是机器之间在连续操作方面（例如，从 k 到 k + 1）静态关系的一组有向边：</p><p>$\varepsilon_s &#x3D; {m \rightarrow m’ |\exists j\in J, m \in M_{j,k}\and m’ \in M_{j, k+1}} \ \ \ \ \ \ \ (7)$</p><p>Eu是是机器在一个时间步处理的作业的动态关系上的一组无向边：</p><p>$\varepsilon_u &#x3D; {(j,m)|j\in J \ executing \ at \ m\in M} \ \ \ \ (8)$</p><p>Ev是作业的动态关系上的一组有向边，这些作业刚刚完成第 (k − 1) 次操作，并准备好在某个时间步路由到机器进行第 k 次操作：</p><p>$\varepsilon_v &#x3D; {m \rightarrow j|j \in J routing to m \in M_{j, k}} \ \ \ \ \ (9)$</p><p>Ew是在一个时间步等待在机器上的作业的动态关系的一组有向边：</p><p>$\varepsilon_w &#x3D; {j \rightarrow m|j \in J \ waiting\ at \ m \in M} \ \ \ \ (10)$</p><p>其中有向边 i → i’ 表示父子关系，i 是父节点，i’ 是子节点。</p><p>需要强调的是，在多智能体图中，所有与作业相连的边都是<strong>动态</strong>的，并且取决于在当前时间步可以处理的可能操作。此外，每个作业最多有一种类型的边，用于随时在机器上执行、等待或路由到机器。当一个作业完成时，其关联的智能体成为一个孤立的节点。此后，智能体和节点可互换地用于机器或作业。</p><p><img src="http://cdn.leafii.top/img/image-20230529180040531.png" alt="image-20230529180040531" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230529180231978.png" alt="image-20230529180231978" loading="lazy"></p><p>以图3为例：图3描述了一个多智能体图的例子，其中的M&#x3D;{1,2,3,4,5,6}, J &#x3D; {7,8,9,10,11,12},表1显示了每个任务的每个操作的机器集合。在图3中，黑色的结点表示同机器有关的智能体，白色结点表示和job有关的智能体。根据式7，结点1和结点3之间有一个有向边，因为job&#x3D;7（8，9 或10）在机器m&#x3D;1上有两个连续的操作。结点3和结点7由无向边进行连接，这表示job j&#x3D;7在现在的时间步在机器m&#x3D;3上正在执行。此外，job&#x3D;8和9都在第二个操作刚刚完成而且等待着路由第三个操作到机器m&#x3D;5或者6上，所以由式9可知结点5和6到结点8和9需要被连接起来。最后，基于式10，从结点10，11到结点4的有向边表明job j&#x3D;10和job j&#x3D;11正在机器m&#x3D;4上进行等待，此时的机器4正在执行job j &#x3D; 12。</p><p>在FJSS中，总会有一些在所有operation中拥有相同固定机器集合的job，比如在表1中的job8，9，10.考虑到现实世界中的job的不同operation会有不同的需要，所以不同的job的相同的operation可能会需要不同的机器来执行。比如说，表1中的job 7和11在前两个操作中需要的机器是完全不同的。这意味着这两个job在执行前两个操作时并没有竞争关系。这个特性在智能体执行动作时应该被考虑到。接下来我们定义一些重要且相关的定义。</p><p>Definition 4.2 (Equivalent Jobs).给定一个机器集合M，一个任务集合J，以及一系列固定的机器$M_{j,k}$，它表示每一个$job \ j \in J$的操作k需要的机器集合。当且仅当两个job的每一个操作都有相同的固定机器集合时，这两个job就是相等的。 </p><p>job相等的例子：表1中的$J &#x3D; {7,8,9,10,11,12}$有子集({7},{8,9,10},{11,12}).这几个子集都是每一个操作的固定机器集合都相同的相等任务。因此，我们可以将相等的任务形成一个特定任务的智能体图(Job-specific Agent Graph)。</p><p>Definition 4.3 (Job-specific Agent Graph).给定一系列的机器M，一系列的任务J，以及对每一个job j的operation k的一系列固定的机器集合$M_{j,k} \subset M$，特定于作业 j ∈ J 的智能体图 G(j) 和定义 4.1 中的多智能体图 G 的子图由作业 j 的节点、其等效作业及其每个操作的机器集，以及这些节点之间的边组成。</p><p>以表1为例，G(8)就是job j &#x3D; 8的特定任务智能体图，它由包括结点8，它的相等任务（9和10）以及固定的机器（1，3，4，5和6），以及这些结点之间的边组成。因此，我们可以通过移除结点2，7，11和12以及在图3中与他们相关的边构建G(8)。请注意，所有相等任务的特定任务的智能体图是一样的。举例来说，就是G(8) &#x3D; G(9) &#x3D; G(10).同样的，我们定义一个特定机器的智能体图。</p><p>Definition 4.4 (Machine-specific Agent Graph).给你一系列的机器集合M，一系列任务集合J，以及一系列固定机器集合$M_{j,k} \subset M$对于每一个任务j的每一个操作k，特定于机器 m ∈ M 的智能体图 $G(m)&#x3D;{I(m),\varepsilon_s(m),\varepsilon_u(m),\varepsilon_v(m),\varepsilon_w(m)}$和多智能体的子图定义 4.1 中的图 G 是所有作业 $G(j)&#x3D;{I(j),\varepsilon_s(j),\varepsilon_u(j),\varepsilon_v(j),\varepsilon_w(j)}$的作业特定智能体图的并集机器m可以处理的：$G(m) &#x3D; \bigcup_{j \in {j’|\exist k, m\in M_{j’,k}}}G(j)$</p><p>其中图并集在节点集 I(j) 和边集 Es(j)、Eu(j)、Ev(j) 和 Ew(j) 上执行。</p><p>举例说明：在结点4上的特定机器的智能体图G(4)就是在结点8，9，10，11和12上特定任务的智能体图的并集。因此，我们可以通过移除结点7以及跟他相关的边来得到智能体图G(4).</p><h3 id="Feature-extraction"><a href="#Feature-extraction" class="headerlink" title="Feature extraction"></a>Feature extraction</h3><p>有两种动作，供两类智能体使用。一个同机器相关的智能体的动作就是在它的本地等待执行队列里选取一个任务来执行。同任务相关的智能体的动作就是在一系列的机器中选择一个机器，将它的下一个等待执行的operation放进这个机器对应的本地等待执行队列中。换言之，机器和工作的可交换性构成了两类智能体的状态和动作。因此，机器和作业的特征对于这些智能体人做出决定很重要。</p><p>**Basic features.**我们强调一些已知的基本特征，包括机器 m 的生产率 $p_m$ 和作业 j 在操作 k 的工作量 $q_{j,k}$ 。为了表述方便，我们还用 $q_j$ 表示作业 j 在当前操作的工作量，用 $q_{j,m}$ 表示作业 j 在机器 m 上的工作量，因为当前操作或机器 m 表示一个确定的操作 k，它可以很容易推断出来。此外，设 $x_{j,m}$ 为作业 j 在机器 m 上在当前时间步完成的工作量。则剩余工作量为 $y_{j,m} &#x3D; q_{j,m} − x_{j,m}$。除了这些基本特征外，DeepMAG 还根据 4.2 节中定义的多智能体图提取机器和作业的特征。</p><h4 id="Machine-centric-features"><a href="#Machine-centric-features" class="headerlink" title="Machine-centric features"></a>Machine-centric features</h4><p>在不失一般性的情况下，我们关注机器 m 的特性，其关联智能体负责作业排序，当机器可用时，它会从等待队列中选择一个作业进行处理。</p><p><strong>Four types of machine-centric static relationships</strong></p><p>我们在机器m和其他机器之间定义了四种静态关系。</p><p>父集合由拥有从m’指向m的有向边的每个机器m’组成。它的含义就是m’可能会发送任务的下一个operation给m。</p><p>$M_e(m) &#x3D; {m’|m’ \in M \and (m’ \rightarrow m}\ \ \ \ \ \ \ (12)$</p><p>子集合由拥有从m指向m’的有向边的每个机器m‘组成。它的含义就是m’可能会接受来自机器m的job的operation。</p><p>$M_d(m) &#x3D; {m’|m’ \in  M \and (m \rightarrow m’)}\ \ \ \ \ \ \ \ \ (13)$</p><p>双亲集合是由至少与机器m‘拥有一个公共孩子的机器m的集合。它的含义就是机器m与机器 m’在普通孩子的资源上为竞争关系。</p><p>$M_c(m) &#x3D; {m’|m’ \in M \and (M_d(m’) \cap M_d(m) \neq \emptyset} \ \ \ \ \ (14)$</p><p>兄弟集由每台机器 m’ 组成，这些机器至少有一个与 m 有共同的父代。它的含义就是与机器 m 合作完成共同父结点上即将发送来的的工作。</p><p>$M_b(m) &#x3D; {m’|m’ \in M \and (M_e(m’) \cap M_e(m)\neq \emptyset}\ \ \ \ \ (15)$</p><p>以图3来说明刚才定义的四种静态关系。$M_e(4) &#x3D; {1, 2}, M_d(4) &#x3D; {5, 6}, M_c (4) &#x3D; {3} , M_b(4) &#x3D; {3}$ 在节点4上。</p><p><strong>Two types of machine-centric dynamic relationships</strong></p><p>接着，我们定义了在机器m和任务之间在一个时间步的两种动态关系。</p><p>正在执行的集合由拥有无向边(j,m)的job j组成。需要注意的是由于exclusion constraint的存在，在每一个时间步，$J_u(m)$至多拥有一个任务。</p><p>$J_u(m) &#x3D; {j|j \in J \and (j,m} \ \ \ \ \ \ (16)$</p><p>正在等待执行的任务集合由拥有从j到m的有向边的job j组成。这个集合中的job将通过在未来消耗一定的时间的方式为机器m带来负担。</p><p>$J_w(m) &#x3D; {j|j \in J \and (j \rightarrow m} \ \ \ \ \ \ (17)$</p><p>在图3中，这两种动态关系的举例如下：对于结点4，$J_u(4) &#x3D;{12}, J_w(4) &#x3D; {10,11}$。</p><p><strong>Seven types of machine-centric numeric features.</strong></p><p>基于机器的静态和动态提取一些数量特征。</p><p>具有不同关系的机器的数量（或度（入度出度））的特征 $f_{deg}$ 由下式给出：</p><p>$f_{deg}(m) &#x3D; [|M_{(.)}(m)|] \ \ \ \ \ \ (18)$</p><p>其中的[]表示一个向量聚合，(.)是从式12到式15得到的b,c,d和e的集合，后文的式子中的符号也是如此表示。</p><p>在生产力值的总和上的特征$f_{prod}$由下式给出：</p><p>$f_{prod}(m) &#x3D; [\sum_{m’\in M(.)(m)}p_{m’}] \ \ \ \ \ \ \ \ \ \ \ (19)$</p><p>在正在执行的任务的数量特征$f_{exe}(m)$由下式给出：</p><p>$f_{exe}(m) &#x3D; [|J_u(m)|, \sum_{m’ \in M(.)(m)}|J_u(m’)|] \ \ \ \ \ \ \ \ \ (20)$</p><p>它们相应的已完成和剩余工作量的总和由下式给出:</p><p>$f_{exe}^{finish}(m) &#x3D; [\sum_{m’ \in M(.)(m)} \sum_{j \in J_u(m’)}x_{j, m’}]\ \ \ \ \ \ \ \ (21)$</p><p>$f_{exe}^{remain}(m) &#x3D; [\sum_{m’ \in M(.)(m)} \sum_{j \in J_u(m’)}y_{j, m’}]\ \ \ \ \ \ \ \ (22)$</p><p>相对的，正在等待的任务的数量特征$f_{wait}(m)$由下式给出：</p><p>$f_{wait}(m) &#x3D; [|J_w(m)|, \sum_{m’ \in M_{(.)}(m)}|J_w(m’)|] \ \ \ \ \ \ (23)$</p><p>它的负载数量由下式给出：</p><p>$f_{wait}^{qty}(m) &#x3D; [\sum_{j \in J_w(m)}q_{j, m}, \sum_{m’ \in M_{(.)}(m)}\sum_{j\in J_w(m’)q_{j,m’}}] \ \ \ \ \ \ (24)$</p><p>这些特征表示在机器m周围复杂的环境，并且它们对与机器相关的智能体决策很重要。</p><h4 id="Job-centric-features"><a href="#Job-centric-features" class="headerlink" title="Job-centric features"></a>Job-centric features</h4><p>在不失一般性的情况下，我们通过选择一台机器来处理作业的下一个操作来关注作业 j 的特征，其关联智能体已准备好进行作业路由。</p><p><strong>Three types of job-centric dynamic relationships.</strong></p><p>我们定义了三种在任务j和机器m之间的动态关系。</p><p>路由机器集合$M_v(j)$由从机器m指向任务j的有向边的机器m组成，它能够为下一个操作处理作业 j。</p><p>$M_v(j) &#x3D; {m|m \in M \and(m \rightarrow j)} \ \ \ \ \ (25)$</p><p>拥有相同的路由机器的任务j’的路由任务集合$J_v(j)$由下式表示，它与相同路由机器上的作业j竞争。</p><p>$J_v(j) &#x3D; {j’|j’ \in J \and (M_v(j’)\cap M_v(j)\neq \emptyset} \ \ \ \ \ \ (26)$</p><p>任务j的祖先集合$J_g(j)$是拥有到job j的路径的所有job $j’ \in J$的集合，式子中的虚线箭头表示一条路径，它是具有无向边$(j′, m_1)$ 或有向边 $j′ → m_1$，有向边 $m_l → m_{l+1}$ 的不同节点序列$(j’, m_1, . . . , m_n, j)$ 以及$m_n → j (l &#x3D; 1, . . ., n−1)$。</p><p>$J_g(j) &#x3D; {j’|j’ \dashrightarrow j} \ \ \ \ \ \ \ \ (27)$</p><p>祖先结点将会在未来对任务j的路由机器$m_n$带来负载。例如，在图3中，结点8上的$M_v(8) &#x3D; {5,6}, J_v(8) &#x3D; {9},J_g(8) &#x3D; {7,10,11,12}$.</p><p><strong>Four types of job-centric numeric features.</strong></p><p>我们基于任务j的路由任务集合$J_v(j)$和祖先集合$J_g(j)$提取了四种数量特征。</p><p>和任务j有不同关系的任务数量$f_{num}$由下式表示，其中[]表示一个向量聚合，(.)由式26，27得到的v和g来设定，之后的符号也是这样的含义。</p><p>$f_{num}(j) &#x3D; [|J_{(.)}(j)|]\ \ \ \ \ \ \ (28)$</p><p>这些任务的负载上的三个统计量由下式表示：</p><p>$f_{sum}(j) &#x3D; [\sum_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ (29)$</p><p>$f_{max}(j) &#x3D; [max_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ \ \ (30)$</p><p>$f_{min}(j) &#x3D; [min_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ \ \ (31)$</p><p>任务j的复杂环境由这些特征表示，这些特征在同任务相关的智能体采取最优动作时有重要作用。</p><h3 id="Representations-of-states-and-actions"><a href="#Representations-of-states-and-actions" class="headerlink" title="Representations of states and actions"></a>Representations of states and actions</h3><p>在FJSS的大型状态空间中，将每个状态表示为标识符并学习每个状态的每个动作的状态-动作值是不可行的，就像在经典的 Q-learning 算法中一样。我们的DeepMAG通过代表状态和动作作为4.3节描述的一系列特征去估计状态动作值函数$\mathbb Q(s_i,a_i)$。机器相关和任务相关的智能体拥有不同的表示。</p><h4 id="Machine-associated-agents"><a href="#Machine-associated-agents" class="headerlink" title="Machine-associated agents"></a>Machine-associated agents</h4><p>让同机器有关的智能体$i&#x3D;m\in M$处于可用状态（用式16表示的话就是$J_u(m) &#x3D; \emptyset$），并且在一个时间步有一个正在等待的任务集合$J_w(m)$（由式17表示）。状态$s_i$应该反映智能体的特征和周围环境以及应该能够使每一个动作$a_i&#x3D;J\in J_w(m)$同其他动作区分开。</p><p>**State representations.**状态由向量$s_i$表示，它通过链接生产力$p_m$以及其中机器独有的数量特征（由式18～24表示）。此外，这些从式18～24提取出的向量是由定义4.1得到的多智能体图以及定义4.4的特定机器智能体图$g(m)$提取出来的.所有提取的特征对于智能体i或者机器m都是非常特别的，它们中的大多数都是依赖机器同相邻机器以及任务之间的关系。因此，智能体可以通过观察不同的状态来和其他的智能体合作去做出动作。</p><p>**Action representations.**一个可能的动作$a_i&#x3D;j\in J_w(m)$被表示为一个向量$a_i$，这个向量是由基于定义4.3得到的特定任务的智能体图得到的工作数量$q_{j,m}$和由式18到24得到的七种以机器为中心的数量特征。所有的这些特征对于正在等待的任务j来说是特别的，并且不同于其他的任务或者正在等待的任务。值得注意的是四种以任务为中心的数量特征不适用于提取任务j的特征，因为根据式25，在机器m上等待的任务j以及它的路由机器集合式空的。</p><h4 id="Job-associated-agents"><a href="#Job-associated-agents" class="headerlink" title="Job-associated agents"></a>Job-associated agents</h4><p>相反，假设一个与工作相关的智能体 i &#x3D; j ∈ J 准备就绪并且在一个时间步,由式25得知它中有一个路由机器集 $M_v(j)$。类似地，需要用任务 j 自身和周围的特征来表示状态 $s_j$，并表征每个可能的动作 $a_i &#x3D; m ∈ M_v(j)$。</p><p>**State representations.**由一个向量$s_i$组成状态$s_i$，这个向量是通过将工作数量$q_j$和通过式28到31的四种以任务为中心的数量特征表示。这些特征由任务j和其他任务在多智能体图以及特定任务图之间提取得出。所有的特征依赖智能体i或者任务j，但是他的任何动作都是独立的。</p><p>**Action representations.**一个候选动作$a_i&#x3D;m\in M_v(j)$由一个向量$a_i$表示，它通过将生产力$p_m$和七种类型的以机器为中心的数量特征，这些特征由多智能体图，特定任务的智能体图以及特定机器的智能体图得到。需要注意，等式18到24的定义是基于机器m，而不是这些种类的智能体图。</p><p>总的来说，无论什么样的智能体，表现出的状态或者动作都包含他们独特特征以及周围特征。接下来，这些智能体就能够一同工作以发现一个最优的连续动作(optimail joint action)。</p><h3 id="Learning-on-DQNs"><a href="#Learning-on-DQNs" class="headerlink" title="Learning on DQNs"></a>Learning on DQNs</h3><p>与单独的智能体分别学习各自的DQN的简单方法不同，DeepMAG为每一种做出不同动作的智能体学习一个DQN以降低成本，增加可扩展性并且能够去改变FJSS环境中的智能体个数。所有同机器相关的智能体共享一个DQN，它们在相应的机器到达可用状态时做出任务排序的动作。所有同任务相关的智能体共享另一个DQN，它们在机器现有的操作结束时，选择一个符合条件的机器去进行它的下一个操作。此外，两个DQN拥有同样的学习算法，比如deep Q-learning，只是在状态和动作上拥有不同的输入。deep Q-learning基于经验回放，他的目标是估计状态动作值函数$\mathbb Q(s_i, a_i)$.通常这种函数被建模为深度神经网络（如DQN）。智能体的经验就是根据马尔可夫过程将得到的$(s_i,a_i,s_i’,r)$进行存储。在学习过程中，Q-learning更新被应用在经验的mini-batches上。Q-learning的更新使用如下的损失函数:</p><p>$\mathbb L(\theta_n) &#x3D; \mathbb E[\left(r + \gamma \ max_{a’_i\in A_i}\hat{\mathbb Q}(s_i’,a_i’|\hat \theta_n) - \hat{\mathbb Q}(s_i, a_i|\theta_n)\right)^2 ] \ \ \ \ \ \ \ (32)$</p><p>其中$\gamma$是折扣率，$\theta_n$是DQN的参数。$\hat \theta_n$是用来计算目标的参数。目标网络的参数只有每N步才会进行更新。参数$\theta_n$由随机梯度下降算法进行学习。</p><h3 id="Training-optimization"><a href="#Training-optimization" class="headerlink" title="Training optimization"></a>Training optimization</h3><p>标准的深度 Q 学习算法是无模型的，它通过直接使用来自模拟器的样本训练 DQN 来估计方程式中的值函数 Q(si, ai)。 （4），而不是等式 (1)中的条件概率质量函数 P（s’，r | s，a）。通过学习等式中的贪心策略 a∗ i &#x3D; π (si) 也是一种off-policy。 (5) 同时遵循确保对状态空间进行充分探索的行为分布。在实践中，行为分布通常由 ε-greedy policy 确定，该 ε-greedy policy 遵循概率为 1−ε 的贪婪策略并选择概率为 ε 的随机动作。 DeepMAG 将此算法扩展到多智能体系统，如算法 1 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230531161425827.png" alt="image-20230531161425827" loading="lazy"></p><p>在FJSS环境中，智能体的动作次序是重要的，这对他们知道其他智能体的表现以及互相合作很重要。所以，同任务相关的智能体的动作应该先进行执行，以确保在机器的等待执行队列中有已经被路由去的待执行任务的操作存在。此外，应该根据任务和机器的工作量数量递减排序，因为有大的负载的任务或者机器都对makespan有着很大的影响， 需要更多的关注。最后，两种智能体使用算法2去学习他们自己的DQN。</p><p><img src="http://cdn.leafii.top/img/image-20230531162203905.png" alt="image-20230531162203905" loading="lazy"></p><p>**Computational complexity.**略</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>在5.1定义了实验设置，在5.2分析了实验结果。</p><h3 id="Experimental-setting"><a href="#Experimental-setting" class="headerlink" title="Experimental setting"></a>Experimental setting</h3><h4 id="Emulated-data"><a href="#Emulated-data" class="headerlink" title="Emulated data"></a>Emulated data</h4><p>模拟了在现实世界工厂里用63，50，35，34个机器实现四个有序操作的场景。他们的生产力范围从每小时2400到8400不等。有四种任务，每一种都有一个相等的关系，也就是这些拥有相同类型的任务是相等的，并且构成了相等的类。每种任务在每一个操作上有固定的机器集合，这些数据在表2中被展示。需要注意的是这些数据都是真实工厂中的数据。</p><p><img src="http://cdn.leafii.top/img/image-20230531163034639.png" alt="image-20230531163034639" loading="lazy"></p><p>为了训练DQN，在每一个episode的开始，我们通过均匀分布得到机器U(16,64),任务的数量$|J|\sim U(10, 100)$来生成FJSS实例。每个人物和负载的数量$q \sim U(1,4) \times 10,000$。这些均匀分布是根据现实世界工厂的离散的值，请注意，机器 M 是从给定的常量机器集中为 J 中的每对作业类型和操作挑选的。 DQN 在 10,000 个实例上进行训练并在三个场景中进行测试。每个场景包含 100 个具有相同作业数量（即 20、60 和 100）的不同实例，并取这 100 个实例的平均性能。</p><h4 id="Evaluated-methods"><a href="#Evaluated-methods" class="headerlink" title="Evaluated methods"></a>Evaluated methods</h4><p>我们将提出的DeepMAG同竞争的分发规则，因为其他的方法对于JSS或者FJSS来说没有可扩展性。大多数现有的方法只能解决少于20个机器或者任务。尽管RL方法可以处理大量的机器或者任务，但没有现有的工作用语FJSS。我们开发了四种复合调度方法。</p><ul><li>$J_W M_{max}$：作业关联智能体选择剩余工作量最小的机器，机器关联智能体选择工作负载最大的作业。</li><li>$J_T M_{max}$：与作业相关的智能体选择剩余处理时间最少的机器，与机器相关的智能体选择工作量最大的作业。</li><li>$J_W M_{min}$：作业关联智能体选择剩余工作量最小的机器，机器关联智能体选择工作负载最小的作业。</li><li>$J_T M_{min}$：与作业相关的智能体选择剩余处理时间最少的机器，与机器相关的智能体选择工作量最小的作业。</li></ul><p>四个复合调度规则始终将较高的优先级分配给负担较低的机器，即与作业相关的智能体的最小剩余工作量或处理时间。选择负担很重的机器显然是不合适的，这会成为制造时间的瓶颈。此外，这些规则总是根据作业的工作量为机器相关智能体选择作业，因为工作量与机器上的处理时间成正比，即工作量和处理时间都会导致相同的结果。</p><h4 id="Performance-metrics"><a href="#Performance-metrics" class="headerlink" title="Performance metrics"></a>Performance metrics</h4><p>为了比较 FJSS 上评估方法的性能，我们采用标准指标，即完成所有作业的时间步长总数。请注意，我们报告了每个场景中具有相同作业数量的 100 个测试实例的平均完工时间。</p><h4 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h4><p>我们的实验平台是一个计算服务器，配备 Interl(R) Xeon (R) CPU E5-2699 v4 2.20 GHz 和 Nvidia V100 GPU (16 GB)。 OpenAI 的 Gym 和谷歌的 TensorFlow 是分别用于强化学习和深度学习的开源软件库。我们基于Gym 0.17.3 实现了FJSS 环境，通过指定环境与agent 交互的标准接口。我们基于 TensorFlow 1.14 使用 DQN 实现智能体。每个 DQN 都是一个多层感知器，其中隐藏层数设置为三层，三层神经元数设置为 64、32 和 16。折扣率设置为 γ &#x3D; 0.9，ε-greedy探索从开始时的 ε &#x3D; 1 衰减到结束时的 ε &#x3D; 0.05。为了适应 FJSS 中具有不同机器和作业分布的各种环境，我们根据训练实例估计了预期的转换和步骤总数。然后，重放内存大小 |D|由与转换总数的比率（默认为 0.25）确定，而目标网络更新频率 N 是通过将总步数除以更新次数（默认为 10）来计算的。我们基于 Adam 优化器训练两个 DQN，批量大小为 64，学习率为 0.0001。</p><h3 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h3><h4 id="Method-comparison"><a href="#Method-comparison" class="headerlink" title="Method comparison"></a>Method comparison</h4><p>表 3 比较了三种不同场景下所有评估方法的完工时间。我们可以得出以下三个重要发现。 (1) 我们的 DeepMAG 始终在所有三种场景中实现最佳性能，包括小型、中型和大量作业。与第二好的相反，根据 JT Mmax 给出的性能，DeepMAG 平均将完工时间缩短了 3.6%。这些结果证明了 DeepMAG 对于具有大搜索空间的 FJSS 的有效性，因为它充分利用了 DRL 和 MARL 之间的集成以及智能体在根据机器和作业之间的操作关系构建的各种图中的合作。 (2) JT Mmax 优于其他评估的调度规则，因为在 JT Mmax 中，作业相关智能体根据其处理时间而不是工作量来选择机器，以考虑其生产力的影响。此外，在 JT Mmax 中，与机器相关的智能体通过选择具有最大工作负载而不是最小工作负载的作业来更加关注具有较大工作负载的作业以减少完工时间，其中具有大工作负载的作业主导完工时间。 (3) 相比之下，JW Mmin 在所有三种情况下始终记录最长的 makespan，因为它根据工作量选择机器而不考虑机器生产率，并通过更多地关注工作量小的工作来选择工作。</p><p><img src="http://cdn.leafii.top/img/image-20230531171254007.png" alt="image-20230531171254007" loading="lazy"></p><h4 id="Effect-of-replay-memory-ratios"><a href="#Effect-of-replay-memory-ratios" class="headerlink" title="Effect of replay memory ratios"></a>Effect of replay memory ratios</h4><p>图 4 描绘了不同重放内存比率对 DeepMAG 上预期转换总数的影响，其中该比率与重放内存大小 |D| 成正比。重放内存比率对完工时间的影响很小。由于这三种场景的预期转换总数很大，因此较小的比率会在回放内存中贡献足够的转换，以减轻观察序列中的相关性并平滑模拟数据中的变化，从而解决 DRL 中的不稳定性（甚至发散）和 MARL 在某种程度上。尽管较大的比率提供了更多的回放转换以进一步减少不稳定性，但更多的历史转换会降低学习效率并抵消对不稳定性的改进。在实践中，采用较小的比率来节省内存成本，例如，在我们的实验中默认为 0.25。</p><p><img src="http://cdn.leafii.top/img/image-20230531171419329.png" alt="image-20230531171419329" loading="lazy"></p><h4 id="Effect-of-target-network-update-times"><a href="#Effect-of-target-network-update-times" class="headerlink" title="Effect of target network update times"></a>Effect of target network update times</h4><p>图 5 显示了 DeepMAG 中目标网络更新次数的影响，即目标网络在整个训练过程中更新了多少次。最好的结果是更新目标网络 10 次。当更新时间从 10 次减少到 5 次时，性能变差；原因是目标网络更新太慢，Eq.中的估计目标值。 (32) 经常过时。相反，随着更新时间从 10 次增加到 80 次，性能也变得更差；这个结果是由于状态-动作值和目标值之间的相关性导致的不稳定性增加造成的。因此，应该使用适当数量的目标网络更新次数来平衡不稳定性和过时的目标值。</p><p><img src="http://cdn.leafii.top/img/image-20230531171452175.png" alt="image-20230531171452175" loading="lazy"></p><h4 id="Effect-of-neuron-numbers"><a href="#Effect-of-neuron-numbers" class="headerlink" title="Effect of neuron numbers"></a>Effect of neuron numbers</h4><p>图 6 描绘了关于改变 DQN 的第一个隐藏层中的神经元数量的影响，其中每个连续的隐藏层在前一个隐藏层中具有一半数量的神经元。具有 32 个神经元的设置产生最差的性能，因为神经元数量少导致 FJSS 学习模型的表达力非常有限。当神经元数量从 32 个增加到 64 个时，性能显着提高。原因是模型的表达能力增强了，有利于发现各种状态下更好的动作。随着神经元数量从 64 变为 128，makespan 变长了一点，因为学习的模型可能会出现过度拟合数据的问题。在实践中，应采用适度的神经元数来平衡模型的表达性、泛化性、专业化和计算成本，包括 CPU 时间和内存使用。</p><p><img src="http://cdn.leafii.top/img/image-20230531171525518.png" alt="image-20230531171525518" loading="lazy"></p><h4 id="Convergence-analysis"><a href="#Convergence-analysis" class="headerlink" title="Convergence analysis"></a>Convergence analysis</h4><p>图 7 分别说明了 DeepMAG 在具有 20、60 和 100 个作业的三个测试场景中的奖励曲线，其中 x 轴是训练集的数量，y 轴是 100 个测试实例的平均奖励，如前所述在第 5.1.1 节中。从图.图.从图7可以看出，一开始曲线波动较大，因为DeepMAG的模型参数更新很大。重要的是，在大约 7,000 次训练后，这些曲线收敛到与时间步数相反的接近最大的奖励。这种收敛特性使 DeepMAG 能够在真实的制造工厂中学习 FJSS 的可行解决方案。</p><p><img src="http://cdn.leafii.top/img/image-20230531171559090.png" alt="image-20230531171559090" loading="lazy"></p><h2 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h2><p>在本文中，我们形式化了灵活的作业车间调度（FJSS）问题，包括基于作业排序和路由的基于马尔可夫决策过程的框架，并据此定义了 FJSS 中的环境、智能体、状态、动作和奖励五个重要概念。然后，我们提出了一种基于 DRL 的 FJSS 新模型 DeepMAG，该模型具有多智能体图，该图是根据机器和作业之间的操作关系构建的，即机器的操作顺序和可以处理的作业的可能操作。 DeepMAG 将 DRL 与 MARL 相结合，解决了 FJSS 在状态和动作上空间过大的问题。一方面，DeepMAG 利用两个 DQN 分别为机器相关智能体的作业排序和作业相关智能体的作业路由找到最佳操作。另一方面，DeepMAG 利用各种多智能体图使每个智能体能够与其相邻智能体合作并采取一个合作行动。最后，仿真实验结果表明，与其他最先进的方法相比，DeepMAG 在 FJSS 的三种场景下实现了最佳性能。</p><p>将来，我们将考虑更先进的方法作为基线，例如，通过升级基于启发式的方法以适应大量机器和作业。本文重点研究静态 FJSS 问题，而一些动态事件，如机器故障、新工作插入和工作取消，在现实世界的制造环境中是不可避免的。因此，在 FJSS 中结合动态事件的特征来设计方法是我们未来的研究方向之一。</p><h2 id="Data-availability"><a href="#Data-availability" class="headerlink" title="Data availability"></a>Data availability</h2><p>作者无权共享数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 车间调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode98.验证二叉搜索树</title>
      <link href="/2023/05/31/leetcode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2023/05/31/leetcode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1-20230531141156695.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [2,1,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/tree2-20230531141159669.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>基于限定值的递归判断</li></ul><p>思路如下：对每一个需要被判断的节点，都为他设置一个最大值和最小值（防止子树的子树不符合搜索树条件），根节点的最大最小值是C++ longlong类型的最大最小值，之后判断左子树时，最大值变更为根节点的值，判断右子树时，最小值变为根节点的值，在判断节点时，若节点为空，则该子树是有效的二叉搜索树，否则就检查当前节点的值是否在minVal到maxVal的范围内。最后递归的验证左子树和右子树。C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 辅助函数，用于验证给定的子树是否为有效的二叉搜索树    bool isValidBSTHelper(TreeNode* node, long long minVal, long long maxVal) &#123;        &#x2F;&#x2F; 如果节点为空，则表示该子树是有效的二叉搜索树        if (node &#x3D;&#x3D; NULL)            return true;                &#x2F;&#x2F; 检查当前节点的值是否在[minVal, maxVal]的范围内        if (node-&gt;val &lt;&#x3D; minVal || node-&gt;val &gt;&#x3D; maxVal)            return false;                &#x2F;&#x2F; 递归验证左子树和右子树        return isValidBSTHelper(node-&gt;left, minVal, node-&gt;val) &amp;&amp;            isValidBSTHelper(node-&gt;right, node-&gt;val, maxVal);    &#125;    bool isValidBST(TreeNode* root) &#123;        &#x2F;&#x2F; 由于题目中未指定树节点的值的范围，所以我们使用长整型的最小值和最大值作为初始范围        long long minVal &#x3D; LLONG_MIN;        long long maxVal &#x3D; LLONG_MAX;                &#x2F;&#x2F; 调用辅助函数进行验证        return isValidBSTHelper(root, minVal, maxVal);    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode617.合并二叉树</title>
      <link href="/2023/05/30/leetcode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/05/30/leetcode617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/merge.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root1 &#x3D; [1], root2 &#x3D; [1,2]输出：[2,2]</code></pre><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>通过深度优先遍历进行合并</li></ol><p>如果有树为空，则直接返回另一个树；若两树都不为空，则新建一个节点，将对应的结点的值进行求和，递归调用函数，最终返回根结点。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        &#x2F;&#x2F; 如果其中一个树为空，我们可以直接返回另一个树作为合并后的结果        if (root1 &#x3D;&#x3D; nullptr) &#123;            return root2;        &#125;        if (root2 &#x3D;&#x3D; nullptr) &#123;            return root1;        &#125;                &#x2F;&#x2F; 创建一个新节点，值为两个树当前节点值的和        TreeNode *merged &#x3D; new TreeNode(root1-&gt;val + root2-&gt;val);                &#x2F;&#x2F; 递归地合并左子树和右子树        merged-&gt;left &#x3D; mergeTrees(root1-&gt;left, root2-&gt;left);        merged-&gt;right &#x3D; mergeTrees(root1-&gt;right, root2-&gt;right);                &#x2F;&#x2F; 返回合并后的树        return merged;    &#125;&#125;;</code></pre><ol start="2"><li>通过广度优先遍历实现合并</li></ol><p>我们使用三个队列，<code>q</code>用于存储合并后的树节点，<code>q1</code>和<code>q2</code>分别用于存储两棵输入树的节点。</p><p>在每一轮循环中，我们弹出<code>q</code>、<code>q1</code>和<code>q2</code>的队首元素，分别表示合并后的树的当前节点、第一棵树的当前节点和第二棵树的当前节点。</p><p>然后，我们获取当前节点的左子节点和右子节点，并根据情况进行处理。</p><ul><li>如果两棵树的左子节点都存在，我们创建一个合并后的左子节点，值为两个树的左子节点值之和，并将其连接到合并后的树的当前节点的左侧。同时，我们将合并后的左子节点、第一棵树的左子节点和第二棵树的左子节点分别入队列<code>q</code>、<code>q1</code>和<code>q2</code>中。</li><li>如果只有第一棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li><li>如果只有第二棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li></ul><p>对于右子节点，我们执行类似的逻辑。</p><p>最终，当队列<code>q1</code>和<code>q2</code>都为空时，表示已经遍历完两棵树的所有节点，此时合并过程完成，我们返回合并后的树的根节点。</p><p>这样，使用广度优先遍历的方式，我们可以合并两棵二叉树并返回合并后的结果。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> t1<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 如果其中一个树为空，直接返回另一个树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> t1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 创建一个新的节点，值为两个树当前节点值的和</span>        TreeNode<span class="token operator">*</span> merged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>t1<span class="token operator">-></span>val <span class="token operator">+</span> t2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 使用队列存储节点，初始时将根节点入队列</span>        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>merged<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q1<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q2<span class="token punctuation">;</span>        q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>        q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>q2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 弹出当前节点以及对应的两个输入树的节点</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> node1 <span class="token operator">=</span> q1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> node2 <span class="token operator">=</span> q2<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 获取当前节点的左子节点和右子节点</span>            TreeNode<span class="token operator">*</span> left1 <span class="token operator">=</span> node1<span class="token operator">-></span>left<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> left2 <span class="token operator">=</span> node2<span class="token operator">-></span>left<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> right1 <span class="token operator">=</span> node1<span class="token operator">-></span>right<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> right2 <span class="token operator">=</span> node2<span class="token operator">-></span>right<span class="token punctuation">;</span>                      <span class="token comment">// 处理左子节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> left2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>left1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> left2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果两棵树的左子节点都存在，创建合并后的左子节点，并入队列</span>                    TreeNode<span class="token operator">*</span> leftMerged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>left1<span class="token operator">-></span>val <span class="token operator">+</span> left2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node<span class="token operator">-></span>left <span class="token operator">=</span> leftMerged<span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftMerged<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第一棵树的左子节点存在，直接使用该节点</span>                    node<span class="token operator">-></span>left <span class="token operator">=</span> left1<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第二棵树的左子节点存在，直接使用该节点</span>                    node<span class="token operator">-></span>left <span class="token operator">=</span> left2<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>                      <span class="token comment">// 处理右子节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> right2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> right2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果两棵树的右子节点都存在，创建合并后的右子节点，并入队列</span>                    TreeNode<span class="token operator">*</span> rightMerged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>right1<span class="token operator">-></span>val <span class="token operator">+</span> right2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node<span class="token operator">-></span>right <span class="token operator">=</span> rightMerged<span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightMerged<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第一棵树的右子节点存在，直接使用该节点</span>                    node<span class="token operator">-></span>right <span class="token operator">=</span> right1<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right2 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 如果只有第二棵树的右子节点存在</span>                    node<span class="token operator">-></span>right <span class="token operator">=</span> right2<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>              <span class="token comment">// 返回合并后的树</span>        <span class="token keyword">return</span> merged<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode700.二叉搜索树中的搜索</title>
      <link href="/2023/05/29/leetcode700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>/2023/05/29/leetcode700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><span id="more"></span> <p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2输出：[2,1,3]</code></pre><p><strong>示例 2:</strong></p><p><img src="http://cdn.leafii.top/img/tree2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>数中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接搜索</li></ul><p>在二叉搜索树中，每个节点的值大于其左子树中的所有节点的值，小于其右子树中的所有节点的值，因此可以利用这个性质进行查找操作。你的方法通过迭代方式在二叉搜索树中查找给定值，并返回匹配的节点指针。这种查找方式通常称为”二叉搜索树的查找”或”BST查找”。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* searchBST(TreeNode* root, int val) &#123;        while (root !&#x3D; nullptr) &#123; &#x2F;&#x2F; 在root非空的情况下进行循环            if (val &#x3D;&#x3D; root-&gt;val) &#123;                return root; &#x2F;&#x2F; 如果值匹配就直接返回root            &#125;            else if (val &gt; root-&gt;val) &#123;                root &#x3D; root-&gt;right; &#x2F;&#x2F; 如果值大于root现有的值，它的目标节点只有可能在他的右子树            &#125;            else &#123;                root &#x3D; root-&gt;left; &#x2F;&#x2F; 如果值小于root现有的值，它的目标节点只有可能在他的左子树            &#125;        &#125;        return nullptr; &#x2F;&#x2F; 如果root为空（不管是现有的root还是迭代后的root） 就直接返回nullptr    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode188.买卖股票的最佳时机IV</title>
      <link href="/2023/05/24/leetcode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/"/>
      <url>/2023/05/24/leetcode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：k &#x3D; 2, prices &#x3D; [2,4,1]输出：2解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 100</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用buy和sale数组进行动态规划，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数），sale[i] 表示进行第 i 次卖出操作后的最大利润，代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;        int n &#x3D; prices.size();        vector&lt;int&gt; buy(k, -prices[0]); &#x2F;&#x2F; 定义买入的数组，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数）        vector&lt;int&gt; sale(k); &#x2F;&#x2F; 定义卖出的数组，sale[i] 表示进行第 i 次卖出操作后的最大利润        for(int i &#x3D; 1; i &lt; n; ++i) &#123;            buy[0] &#x3D; max(buy[0], -prices[i]); &#x2F;&#x2F; 更新第一次买入的最大利润，取当前买入的最大利润和前一天的最大利润中较大的值            sale[0] &#x3D; max(sale[0], prices[i] + buy[0]); &#x2F;&#x2F; 更新第一次卖出的最大利润，取当前卖出的最大利润和前一天的最大利润加上当前股票价格的较大值            for(int j &#x3D; 1; j &lt; k; ++j) &#123;                buy[j] &#x3D; max(buy[j], sale[j - 1] - prices[i]); &#x2F;&#x2F; 更新第 j 次买入的最大利润，取当前买入的最大利润和前一次卖出的最大利润减去当前股票价格的较大值                sale[j] &#x3D; max(sale[j], buy[j] + prices[i]); &#x2F;&#x2F; 更新第 j 次卖出的最大利润，取当前卖出的最大利润和当前买入的最大利润加上当前股票价格的较大值            &#125;        &#125;        return sale[k - 1]; &#x2F;&#x2F; 返回最后一次卖出的最大利润    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode518.零钱兑换II</title>
      <link href="/2023/05/23/leetcode518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II/"/>
      <url>/2023/05/23/leetcode518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：amount &#x3D; 5, coins &#x3D; [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5&#x3D;55&#x3D;2+2+15&#x3D;2+1+1+15&#x3D;1+1+1+1+1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：amount &#x3D; 3, coins &#x3D; [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：amount &#x3D; 10, coins &#x3D; [10] 输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>在这个解答中，我们使用动态规划来解决问题。我们定义一个长度为amount+1的dp数组，其中dp[i]表示凑成金额i所需的硬币组合数。</p><p>我们初始化dp[0]为1，表示凑成金额0的组合数为1（不选择任何硬币）。然后，我们遍历硬币数组coins，对于每个硬币coin，我们从coin遍历到amount，更新dp数组的值。对于每个金额i，我们考虑是否选择硬币coin，如果选择，则组合数增加dp[i-coin]，因为我们只需要找出剩余金额i-coin的组合数即可。</p><p>最终，dp[amount]即为所需的结果，即凑成金额amount的组合数。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;        vector&lt;int&gt; dp(amount + 1, 0); &#x2F;&#x2F; 创建长度为amount+1的dp数组，初始值为0        dp[0] &#x3D; 1; &#x2F;&#x2F; 凑成金额0的组合数为1（不选择任何硬币）                for (int coin : coins) &#123; &#x2F;&#x2F; 遍历硬币数组            for (int i &#x3D; coin; i &lt;&#x3D; amount; i++) &#123; &#x2F;&#x2F; 从硬币coin遍历到amount                dp[i] +&#x3D; dp[i - coin]; &#x2F;&#x2F; 更新组合数            &#125;        &#125;                return dp[amount]; &#x2F;&#x2F; 返回凑成金额amount的组合数    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode322.零钱兑换</title>
      <link href="/2023/05/22/leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
      <url>/2023/05/22/leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11输出：3 解释：11 &#x3D; 5 + 5 + 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：coins &#x3D; [2], amount &#x3D; 3输出：-1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：coins &#x3D; [1], amount &#x3D; 0输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>解题思路：</p><ul><li>创建一个长度为 amount + 1 的数组 <code>dp</code>，用于保存每个金额对应的最小硬币数量。初始时，将数组中所有元素的值设置为一个较大的值，表示无穷大。</li><li>将金额为 0 的最小硬币数量设为 0。</li><li>通过动态规划的方式，遍历每个金额，计算最小硬币数量。</li><li>对于当前金额 i，遍历每个硬币的面值，如果当前硬币面值小于等于当前金额 i，则计算使用当前硬币后的剩余金额 remainder。</li><li>检查剩余金额的最小硬币数量是否为有效值，如果是，则更新当前金额 i 的最小硬币数量为 <code>dp[remainder] + 1</code>（加 1 表示使用了当前硬币）。</li><li>最终，如果最终金额的最小硬币数量仍为无效值（即未被更新），则返回 -1，否则返回最小硬币数量。</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;climits&gt;class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量        vector&lt;int&gt; dp(amount + 1, INT_MAX);                &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0        dp[0] &#x3D; 0;                &#x2F;&#x2F; 遍历每个金额，计算最小硬币数量        for (int i &#x3D; 1; i &lt;&#x3D; amount; ++i) &#123;            &#x2F;&#x2F; 遍历每个硬币的面值            for (int j &#x3D; 0; j &lt; coins.size(); ++j) &#123;                &#x2F;&#x2F; 如果当前硬币面值小于等于当前金额 i                if (coins[j] &lt;&#x3D; i) &#123;                    &#x2F;&#x2F; 计算使用当前硬币后的剩余金额                    int remainder &#x3D; i - coins[j];                                        &#x2F;&#x2F; 检查剩余金额的最小硬币数量是否为有效值                    if (dp[remainder] !&#x3D; INT_MAX) &#123;                        &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量                        dp[i] &#x3D; min(dp[i], dp[remainder] + 1);                    &#125;                &#125;            &#125;        &#125;                &#x2F;&#x2F; 如果最终金额的最小硬币数量为无效值，则返回 -1，否则返回最小硬币数量        return dp[amount] &#x3D;&#x3D; INT_MAX ? -1 : dp[amount];    &#125;&#125;;</code></pre><ol start="2"><li>动态规划（优化）</li></ol><ul><li>通过使用范围-based for 循环遍历硬币面值，可以简化代码并提高可读性。</li><li>内层循环从硬币面值开始，而不是从 1 开始，这样可以避免重复计算和无效的更新。</li><li>这种优化利用了动态规划的特性，逐步计算每个金额的最小硬币数量。</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量        vector&lt;int&gt; dp(amount + 1, amount + 1);        &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0        dp[0] &#x3D; 0;        &#x2F;&#x2F; 动态规划，遍历每个金额，计算最小硬币数量        for (int coin : coins) &#123;            for (int i &#x3D; coin; i &lt;&#x3D; amount; ++i) &#123;                &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量                dp[i] &#x3D; min(dp[i], dp[i - coin] + 1);            &#125;        &#125;        &#x2F;&#x2F; 如果最终金额的最小硬币数量仍然大于 amount，则表示无法凑出该金额，返回 -1        if (dp[amount] &gt; amount) &#123;            return -1;        &#125; else &#123;            &#x2F;&#x2F; 返回最小硬币数量            return dp[amount];        &#125;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1207.独一无二的出现次数</title>
      <link href="/2023/05/21/leetcode1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
      <url>/2023/05/21/leetcode1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1,2]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路： 该问题要求判断给定数组中各个元素出现的频率是否唯一。</p><p>我们可以使用两个数据结构来解决这个问题：</p><ol><li><code>unordered_map&lt;int, int&gt;</code>：用于记录每个元素出现的频率。</li><li><code>unordered_set&lt;int&gt;</code>：用于记录已经出现过的频率。</li></ol><p>我们首先遍历数组，统计每个元素出现的频率并存储在<code>frequencyMap</code>中。然后，我们遍历<code>frequencyMap</code>，对于每个出现的频率，如果该频率已经在<code>occurrenceSet</code>中存在，则说明出现的频率不是唯一的，我们返回false。否则，将该频率添加到<code>occurrenceSet</code>中。最后，如果所有频率都是唯一的，则返回true。</p><p>在示例代码中，我们使用了一个测试用例<code>arr = &#123;1, 2, 2, 1, 1, 3&#125;</code>进行验证，输出结果为<code>true</code>，说明给定数组中各个元素的频率是唯一的。</p><p>请注意，示例代码中使用了C++标准库中的<code>unordered_map</code>和<code>unordered_set</code>来实现哈希表和哈希集合的功能。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123;        unordered_map&lt;int, int&gt; frequencyMap; &#x2F;&#x2F; 存储每个元素出现的频率        unordered_set&lt;int&gt; occurrenceSet; &#x2F;&#x2F; 存储出现的频率值        &#x2F;&#x2F; 计算每个元素出现的频率        for (int num : arr) &#123;            frequencyMap[num]++;        &#125;        &#x2F;&#x2F; 检查频率是否是唯一的        for (auto it &#x3D; frequencyMap.begin(); it !&#x3D; frequencyMap.end(); ++it) &#123;            int occurrence &#x3D; it-&gt;second;            &#x2F;&#x2F; 如果出现的频率已经存在，返回false            if (occurrenceSet.count(occurrence) &gt; 0) &#123;                return false;            &#125;            &#x2F;&#x2F; 将出现的频率添加到集合中            occurrenceSet.insert(occurrence);        &#125;        &#x2F;&#x2F; 所有频率都是唯一的，返回true        return true;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1365.有多少小于当前数字的数字</title>
      <link href="/2023/05/20/leetcode1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2023/05/20/leetcode1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p><p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。</p><p>以数组形式返回答案。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [8,1,2,2,3]输出：[4,0,1,1,3]解释： 对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]&#x3D;1 不存在比它小的数字。对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [6,5,4,8]输出：[2,1,0,3]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [7,7,7,7]输出：[0,0,0,0]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>思路：直接复制一份数组，将复制得到的数组进行排序，然后进行遍历比较，将得到的值添加到答案数组中，最后返回答案数组。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; nums_sorted &#x3D; nums; &#x2F;&#x2F; 复制nums数组        sort(nums_sorted.begin(), nums_sorted.end()); &#x2F;&#x2F; 将复制后的数组进行排序        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化答案数组        int len &#x3D; nums.size(); &#x2F;&#x2F; 得到数组的总长度        for (int i &#x3D; 0; i &lt; len; i++) &#123; &#x2F;&#x2F; 进行遍历            int result &#x3D; 0; &#x2F;&#x2F; 初始化大于nums[i]的元素的数量为0            for (int j &#x3D; 0; j &lt; len; j++) &#123; &#x2F;&#x2F; 在排序后的数组中进行遍历，以便得到精确的答案                if (nums_sorted[j] &lt; nums[i]) &#123;                    result++; &#x2F;&#x2F; 如果发现数组中有比nums[i]更小的数字，就把result进行++的操作                &#125;                else&#123;                    break; &#x2F;&#x2F; 否则就跳出循环（因为这是已经排序好的数组，这个元素不小于nums[i]那么之后的元素也都大于等于nums[i] 无需继续遍历                &#125;            &#125;            results.push_back(result); &#x2F;&#x2F; 将答案push进答案数组中        &#125;        return results; &#x2F;&#x2F; 返回答案结果    &#125;&#125;;</code></pre><ul><li>使用计数数组优化</li></ul><p>思路：因为nums数组中元素的大小范围为0到100，所以可以设置一个统计各个数字分别有多少个的计数数组，然后利用计数数组计算整个数组中小于nums[i]的元素的个数。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组，范围为0到100        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化结果数组        int len &#x3D; nums.size(); &#x2F;&#x2F; 获取数组长度                &#x2F;&#x2F; 统计每个数字的出现次数        for (int i &#x3D; 0; i &lt; len; i++) &#123;            count[nums[i]]++; &#x2F;&#x2F; 统计当前数字出现的次数        &#125;                &#x2F;&#x2F; 遍历每个数字，计算小于当前数字的元素个数        for (int i &#x3D; 0; i &lt; len; i++) &#123;            int temp_num &#x3D; nums[i]; &#x2F;&#x2F; 当前数字            int result &#x3D; 0; &#x2F;&#x2F; 小于当前数字的元素个数            for (int j &#x3D; 0; j &lt; temp_num; j++) &#123; &#x2F;&#x2F; 遍历计数数组                result +&#x3D; count[j]; &#x2F;&#x2F; 累加小于当前数字的元素个数            &#125;            results.push_back(result); &#x2F;&#x2F; 将结果添加到结果数组中        &#125;                return results; &#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre><ul><li>使用计数排序和前缀和</li></ul><ol><li>使用计数排序：题目中给出了限制条件，数组元素的范围是0到100，因此可以使用计数排序来替代排序函数，以提高效率。创建一个大小为101的计数数组，统计每个数字的出现次数，然后计算小于每个数字的元素个数。</li><li>使用前缀和：通过累加计算计数数组，可以得到每个数字的前缀和数组。前缀和数组的每个元素表示小于等于该数字的元素个数。然后，通过访问前缀和数组即可获取小于每个元素的元素个数。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组        int len &#x3D; nums.size();        &#x2F;&#x2F; 统计每个数字的出现次数        for (int i &#x3D; 0; i &lt; len; i++) &#123;            count[nums[i]]++;        &#125;        &#x2F;&#x2F; 计算前缀和数组        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;            count[i] +&#x3D; count[i - 1];        &#125;        vector&lt;int&gt; results;        for (int i &#x3D; 0; i &lt; len; i++) &#123;            if (nums[i] &#x3D;&#x3D; 0) &#123;                results.push_back(0); &#x2F;&#x2F; 对于数字0，直接加入结果数组中            &#125; else &#123;                results.push_back(count[nums[i] - 1]); &#x2F;&#x2F; 获取小于当前数字的元素个数            &#125;        &#125;        return results;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode906.超级回文数</title>
      <link href="/2023/05/19/leetcode906-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2023/05/19/leetcode906-%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</p><p>现在，给定两个正整数 <code>L</code> 和 <code>R</code> （以字符串形式表示），返回包含在范围 <code>[L, R]</code> 中的超级回文数的数目。</p> <span id="more"></span><p><strong>示例：</strong></p><pre class="language-none"><code class="language-none">输入：L &#x3D; &quot;4&quot;, R &#x3D; &quot;1000&quot;输出：4解释：4，9，121，以及 484 是超级回文数。注意 676 不是一个超级回文数： 26 * 26 &#x3D; 676，但是 26 不是回文数。</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= len(L) &lt;= 18</code></li><li><code>1 &lt;= len(R) &lt;= 18</code></li><li><code>L</code> 和 <code>R</code> 是表示 <code>[1, 10^18)</code> 范围的整数的字符串。</li><li><code>int(L) &lt;= int(R)</code></li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接求解</li></ul><ol><li>首先，将输入的左右边界转换为长整型。</li><li>然后，利用两个循环来生成所有可能的回文数：<ul><li>第一个循环从1到9，将每个数字作为回文数的中心，生成回文数。</li><li>第二个循环从1到9999，将每个数字作为回文数的前半部分，并生成回文数的后半部分。</li></ul></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int superpalindromesInRange(string left, string right) &#123;        long long leftVal &#x3D; stoll(left); &#x2F;&#x2F; 将左边界转换为长整型        long long rightVal &#x3D; stoll(right); &#x2F;&#x2F; 将右边界转换为长整型        int count &#x3D; 0;        &#x2F;&#x2F; 第一部分：生成所有可能的回文数的前半部分        for (int i &#x3D; 1; i &lt;&#x3D; 9; ++i) &#123;            generatePalindromes(to_string(i), leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数        &#125;                &#x2F;&#x2F; 第二部分：生成所有可能的回文数的中间部分        for (int i &#x3D; 1; i &lt;&#x3D; 9999; ++i) &#123;            string leftPart &#x3D; to_string(i);            string rightPart &#x3D; to_string(i);            reverse(rightPart.begin(), rightPart.end()); &#x2F;&#x2F; 反转右半部分                        generatePalindromes(leftPart + rightPart, leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数            for (int j &#x3D; 0; j &lt;&#x3D; 9; ++j) &#123;                generatePalindromes(leftPart + to_string(j) + rightPart, leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数            &#125;        &#125;                return count;    &#125;    private:    &#x2F;&#x2F; 生成回文数并判断是否为超级回文数    void generatePalindromes(string str, long long leftVal, long long rightVal, int&amp; count) &#123;        long long num &#x3D; stoll(str);        num *&#x3D; num; &#x2F;&#x2F; 平方得到回文数                if (num &gt; rightVal) &#123;            return;        &#125;                if (num &gt;&#x3D; leftVal &amp;&amp; isPalindrome(to_string(num))) &#123;            ++count;        &#125;    &#125;        &#x2F;&#x2F; 判断是否为回文数    bool isPalindrome(string str) &#123;        int left &#x3D; 0;        int right &#x3D; str.length() - 1;                while (left &lt; right) &#123;            if (str[left] !&#x3D; str[right]) &#123;                return false;            &#125;                        ++left;            --right;        &#125;                return true;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1291.顺次数</title>
      <link href="/2023/05/17/leetcode1291-%E9%A1%BA%E6%AC%A1%E6%95%B0/"/>
      <url>/2023/05/17/leetcode1291-%E9%A1%BA%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 <code>1</code> 的整数。</p><p>请你返回由 <code>[low, high]</code> 范围内所有顺次数组成的 <strong>有序</strong> 列表（从小到大排序）。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输出：low &#x3D; 100, high &#x3D; 300输出：[123,234]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输出：low &#x3D; 1000, high &#x3D; 13000输出：[1234,2345,3456,4567,5678,6789,12345]</code></pre><p><strong>提示：</strong></p><ul><li><code>10 &lt;= low &lt;= high &lt;= 10^9</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接生成符合条件的数字</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; sequentialDigits(int low, int high) &#123;        vector&lt;int&gt; result; &#x2F;&#x2F; 存储符合条件的顺次数结果的向量        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;            int num &#x3D; i; &#x2F;&#x2F; 初始化当前数字为起始位            for (int j &#x3D; i + 1; j &lt;&#x3D; 9; j++) &#123;                num &#x3D; num * 10 + j; &#x2F;&#x2F; 逐位增加数字                if (num &gt;&#x3D; low &amp;&amp; num &lt;&#x3D; high) &#123;                    result.push_back(num); &#x2F;&#x2F; 如果生成的数字在给定范围内，则添加到结果向量中                &#125;            &#125;        &#125;        sort(result.begin(), result.end()); &#x2F;&#x2F; 对结果向量进行排序        return result; &#x2F;&#x2F; 返回最终的结果向量    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode845.数组中的最长山脉</title>
      <link href="/2023/05/16/leetcode845-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/"/>
      <url>/2023/05/16/leetcode845-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>把符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：</p><ul><li><code>arr.length &gt;= 3</code></li><li>存在下标<code>i（0 &lt; i &lt; arr.length - 1），</code>满足<ul><li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li><li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul></li></ul><p>给出一个整数数组 <code>arr</code>，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 <code>0</code> 。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,1,4,7,3,2,5]输出：5解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,2,2]输出：0解释：不存在山脉子数组。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 104</code></li><li><code>0 &lt;= arr[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>三指针法</li></ul><ol><li>首先，我们可以初始化三个指针：left、right和peak。<ul><li>left指针指向山脉数组的起点，即数组的第一个元素。</li><li>right指针指向山脉数组的终点，即数组的最后一个元素。</li><li>peak指针指向山脉数组的顶峰。</li></ul></li><li>我们可以通过移动right指针来找到山脉数组的终点。当数组的下一个元素比当前元素大的时候，我们可以继续移动right指针。如果下一个元素比当前元素小，我们将找到了山脉数组的终点。</li><li>一旦我们找到了山脉数组的终点，我们需要移动left指针。我们需要找到山脉数组的起点，即数组的第一个元素。我们可以通过移动left指针来找到山脉数组的起点。当数组的下一个元素比当前元素大的时候，我们可以继续移动left指针。</li><li>当我们找到山脉数组的起点和终点后，我们需要更新peak指针的位置。我们可以通过遍历山脉数组的起点到终点之间的元素，找到最大的元素，并更新peak指针的位置。</li><li>最后，我们可以计算山脉数组的长度，即右边界(right)减去左边界(left)再加1。如果山脉数组的长度大于等于3，就返回该长度；否则，返回0。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int longestMountain(vector&lt;int&gt;&amp; A) &#123;        int n &#x3D; A.size();        int left &#x3D; 0, right &#x3D; 0, peak &#x3D; 0;        int longestMountainLength &#x3D; 0;        while (left &lt; n) &#123;            right &#x3D; left;            &#x2F;&#x2F; 找到山脉数组的终点            if (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;                while (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;                    right++;                &#125;                &#x2F;&#x2F; 找到山脉数组的起点                if (right + 1 &lt; n &amp;&amp; A[right] &gt; A[right + 1]) &#123;                    peak &#x3D; right;                    while (peak + 1 &lt; n &amp;&amp; A[peak] &gt; A[peak + 1]) &#123;                        peak++;                    &#125;                    &#x2F;&#x2F; 更新最长山脉的长度                    longestMountainLength &#x3D; max(longestMountainLength, peak - left + 1);                &#125;            &#125;            left &#x3D; max(right, left + 1);        &#125;        return longestMountainLength &gt;&#x3D; 3 ? longestMountainLength : 0;    &#125;&#125;;</code></pre><ul><li>仅用一趟扫描,并仅用O(1)空间复杂度解决问题</li></ul><p>解题思路：</p><ol><li><p>初始化变量：</p><ul><li><code>up</code>：表示上升的长度（山脉的左半边）</li><li><code>down</code>：表示下降的长度（山脉的右半边）</li><li><code>maxLen</code>：表示最长山脉数组的长度</li></ul></li><li><p>从数组的第二个元素开始遍历：</p><ul><li><p>如果当前元素 <code>A[i]</code> 大于前一个元素 <code>A[i-1]</code>，则表示处于上升阶段，递增 <code>up</code> 的值，同时重置 <code>down</code> 的值为0。</p></li><li><p>如果当前元素 </p><pre class="language-none"><code class="language-none">A[i]</code></pre><p> 小于前一个元素 </p><pre class="language-none"><code class="language-none">A[i-1]</code></pre><p>：</p><ul><li>如果 <code>up</code> 大于0，表示已经处于山脉的下降阶段，递增 <code>down</code> 的值。</li><li>如果 <code>up</code> 等于0，表示还没有开始上升阶段，不进行任何操作。</li></ul></li></ul></li><li><p>当 <code>down</code> 大于0时，表示找到了山脉数组的终点，更新 <code>maxLen</code> 的值。然后将指针移动到山脉数组的下一个元素，即 <code>i</code> 加1，并重置 <code>up</code> 和 <code>down</code> 的值为0。</p></li><li><p>最后返回 <code>maxLen</code>，即为最长山脉数组的长度。</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int longestMountain(vector&lt;int&gt;&amp; A) &#123;        int n &#x3D; A.size();        int up &#x3D; 0, down &#x3D; 0;  &#x2F;&#x2F; 上升和下降的长度        int maxLen &#x3D; 0;  &#x2F;&#x2F; 最长山脉数组的长度        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (A[i] &gt; A[i-1]) &#123;  &#x2F;&#x2F; 上升阶段                if (down &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于下降阶段，则重置上升和下降长度                    up &#x3D; 0;                    down &#x3D; 0;                &#125;                up++;  &#x2F;&#x2F; 递增上升长度            &#125; else if (A[i] &lt; A[i-1]) &#123;  &#x2F;&#x2F; 下降阶段                if (up &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于上升阶段                    down++;  &#x2F;&#x2F; 递增下降长度                    maxLen &#x3D; max(maxLen, up + down + 1);  &#x2F;&#x2F; 更新最长山脉数组的长度                &#125;            &#125; else &#123;  &#x2F;&#x2F; 平稳阶段，重置上升和下降长度                up &#x3D; 0;                down &#x3D; 0;            &#125;        &#125;        return maxLen;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1925.统计平方和三元组的数目</title>
      <link href="/2023/05/15/leetcode1925-%E7%BB%9F%E8%AE%A1%E5%B9%B3%E6%96%B9%E5%92%8C%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
      <url>/2023/05/15/leetcode1925-%E7%BB%9F%E8%AE%A1%E5%B9%B3%E6%96%B9%E5%92%8C%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个 <strong>平方和三元组</strong> <code>(a,b,c)</code> 指的是满足 <code>a2 + b2 = c2</code> 的 <strong>整数</strong> 三元组 <code>a</code>，<code>b</code> 和 <code>c</code> 。</p><p>给你一个整数 <code>n</code> ，请你返回满足 <code>1 &lt;= a, b, c &lt;= n</code> 的 <strong>平方和三元组</strong> 的数目。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：2解释：平方和三元组为 (3,4,5) 和 (4,3,5) 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 10输出：4解释：平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 250</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力枚举</li></ul><p>直接进行枚举即可。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int countTriples(int n) &#123;        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n                for (int c &#x3D; b + 1; c &lt;&#x3D; n; c++) &#123;  &#x2F;&#x2F; 遍历c的范围从b+1到n                    if (a * a + b * b &#x3D;&#x3D; c * c) &#123;  &#x2F;&#x2F; 检查是否满足勾股定理                        cnt +&#x3D; 2;  &#x2F;&#x2F; 满足条件的三元组数量加2                    &#125;                &#125;            &#125;        &#125;        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量    &#125;&#125;;</code></pre><ul><li>通过固定C降低时间复杂度</li></ul><p>暴力枚举法的复杂度为O(n^3)，我们可以对其进行一些优化，比如固定c，只保留a和b的循环。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int countTriples(int n) &#123;        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n                int c_square &#x3D; a * a + b * b; &#x2F;&#x2F;  定义c_square&#x3D;a*a+b*b                int c &#x3D; sqrt(c_square); &#x2F;&#x2F; 得到整型的变量c，其值为c_square的平方根                 if (c &lt;&#x3D; n &amp;&amp; c * c &#x3D;&#x3D; c_square) &#123; &#x2F;&#x2F; 因为c是被强制转换成int类型进行存储的，所以不仅要判断c是否小于n还要确定c的平方确实等于c_square                    cnt +&#x3D; 2; &#x2F;&#x2F; 若符合要求，则cnt+&#x3D;2 比如（3，4，5）和（4，3，5）只判断一次，但cnt+&#x3D;2；                &#125;            &#125;        &#125;        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1534.统计好三元组</title>
      <link href="/2023/05/14/leetcode1534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/"/>
      <url>/2023/05/14/leetcode1534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p><p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li><li><code>|arr[i] - arr[j]| &lt;= a</code></li><li><code>|arr[j] - arr[k]| &lt;= b</code></li><li><code>|arr[i] - arr[k]| &lt;= c</code></li></ul><p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p><p>返回 <strong>好三元组的数量</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [3,0,1,1,9,7], a &#x3D; 7, b &#x3D; 2, c &#x3D; 3输出：4解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1,1,2,2,3], a &#x3D; 0, b &#x3D; 0, c &#x3D; 1输出：0解释：不存在满足所有条件的三元组。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= arr.length &lt;= 100</code></li><li><code>0 &lt;= arr[i] &lt;= 1000</code></li><li><code>0 &lt;= a, b, c &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力枚举</li></ul><p>直接模拟暴力枚举即可，代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123;        int len &#x3D; arr.size();  &#x2F;&#x2F; 获取数组的长度        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，记录符合条件的三元组数量        for (int i &#x3D; 0; i &lt; len - 2; i++) &#123;  &#x2F;&#x2F; 第一个数的索引范围是 [0, len - 3]            for (int j &#x3D; i + 1; j &lt; len - 1; j++) &#123;  &#x2F;&#x2F; 第二个数的索引范围是 [i+1, len - 2]                for (int k &#x3D; j + 1; k &lt; len; k++) &#123;  &#x2F;&#x2F; 第三个数的索引范围是 [j+1, len - 1]                    if (abs(arr[i] - arr[j]) &lt;&#x3D; a &amp;&amp; abs(arr[j] - arr[k]) &lt;&#x3D; b &amp;&amp; abs(arr[i] - arr[k]) &lt;&#x3D; c) &#123;                        &#x2F;&#x2F; 检查三元组的条件：两个数之间的差值都不超过给定的限制                        cnt++;  &#x2F;&#x2F; 符合条件的三元组数量加一                    &#125;                &#125;            &#125;        &#125;        return cnt;  &#x2F;&#x2F; 返回符合条件的三元组数量    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode84.柱状图中最大的矩形</title>
      <link href="/2023/05/12/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
      <url>/2023/05/12/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><span id="more"></span> <p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/histogram.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：heights &#x3D; [2,1,5,6,2,3]输出：10解释：最大的矩形为图中红色区域，面积为 10</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/histogram-1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入： heights &#x3D; [2,4]输出： 4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><ol><li>遍历给定的柱状图高度数组 <code>heights</code>，依次处理每个柱子。</li><li>使用一个栈来保存递增序列的索引。栈中的索引对应的柱子高度是递增的。</li><li>对于每个柱子，如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界。</li><li>弹出栈顶元素，并计算以栈顶元素为高度的矩形的面积。面积的宽度可以通过当前索引和新的栈顶元素索引之间的距离计算得到。</li><li>更新最大面积值。</li><li>将当前索引入栈，继续下一个柱子的处理。</li><li>遍历完所有柱子后，栈中剩余的索引对应的柱子高度没有右边界，因此以这些柱子高度计算的矩形面积可以直接得到。</li><li>返回最大面积值。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;    int n &#x3D; heights.size();    stack&lt;int&gt; st; &#x2F;&#x2F; 使用栈来保存递增序列的索引    int maxArea &#x3D; 0;    for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;        &#x2F;&#x2F; 如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界        &#x2F;&#x2F; 计算以栈顶元素为高度的矩形的面积，并更新最大面积        while (!st.empty() &amp;&amp; (i &#x3D;&#x3D; n || heights[i] &lt; heights[st.top()])) &#123;            int h &#x3D; heights[st.top()];            st.pop();            int w &#x3D; st.empty() ? i : (i - st.top() - 1);            maxArea &#x3D; max(maxArea, h * w);        &#125;        &#x2F;&#x2F; 将当前索引入栈        st.push(i);    &#125;    return maxArea;&#125;int main() &#123;    vector&lt;int&gt; heights &#x3D; &#123;2, 1, 5, 6, 2, 3&#125;;    int maxArea &#x3D; largestRectangleArea(heights);    cout &lt;&lt; &quot;最大矩形的面积为：&quot; &lt;&lt; maxArea &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种基于知识图谱的离散制造车间资源分配优化方法</title>
      <link href="/2023/05/12/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%A6%BB%E6%95%A3%E5%88%B6%E9%80%A0%E8%BD%A6%E9%97%B4%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2023/05/12/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%A6%BB%E6%95%A3%E5%88%B6%E9%80%A0%E8%BD%A6%E9%97%B4%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops"><a href="#A-novel-knowledge-graph-based-optimization-approach-for-resource-allocation-in-discrete-manufacturing-workshops" class="headerlink" title="A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops"></a>A novel knowledge graph-based optimization approach for resource allocation in discrete manufacturing workshops</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>动态订单需求和不确定的制造资源可用性是目前智能资源优化配置的研究热点。目前从制造业产生的数据量正在快速的增长。这些数据有多源头，异构和多尺度的特点。将数据转化为知识，优化个性化订单与制造资源的配置，是提高企业认知智能生产水平的有效策略。<strong>但是</strong>，制造过程在资源配置上是多样化的。数据之间有很多规则和约束。数据之间的关系是更加复杂的，从海量制造数据中挖掘语义信息，缺乏统一的信息建模和工业知识生成方法。<strong>研究挑战</strong>是如何充分整合车间资源的复杂数据，挖掘隐含的语义信息，形成可行的<strong>知识驱动的资源分配优化方法</strong>。这种方法可以有效地提供资源分配所需的相关工程信息。本研究提出了一种统一的知识图驱动的生产资源分配方法，允许根据资源加工信息和设备评估策略，为给定的订单插入任务快速做出资源分配决策。提出了车间资源知识图谱（WRKG）模型来整合机加工车间的工程语义信息。开发了一种<strong>分布式知识表示学习算法</strong>来挖掘隐式资源信息以实时更新WRKG。此外，提出了一种由 WRKG 支持的三阶段资源分配优化方法，以输出特定任务所需的设备集。以航空航天企业制造资源分配过程任务为例，论证了所提方法的可行性。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>制造资源的合理配置对提高生产效率具有重要意义，尤其是在离散制造行业。结构件的生产是离散制造的典型例子，具有多品种、小批量生产、工艺变化频繁等特点。在实际的结构件生产过程中，批量生产任务和研发任务并存，是典型的混合模式生产（见图1）。<strong>批量生产</strong>有固定的处理时间并且每个处理块都根据生产计划进行执行。<strong>研发任务</strong>的制造模式主要是在试制阶段对待加工产品进行一些加急订单，具有较大的不确定性，尤其是在加工时间和设备使用方面。混合模式生产中紧急订单的存在会<strong>引发制造车间资源配置的冲突</strong>。此外，紧急订单会影响生产效率和交货时间。此外，切换紧急订单需要大量的准备时间和等待时间，这降低了车间的整体生产效率。<strong>因此需要</strong>快速高效地配置车间制造资源，减少资源冲突，提高资源利用率，增强制造过程的灵活性。</p><p><img src="http://cdn.leafii.top/img/image-20230510203735964.png" alt="image-20230510203735964" loading="lazy"></p><p>大多数次序资源分配的现有方法主要关注于优化资源模型和算法。随着IOT和大数据行业的巨大发展，在工业生产过程有很多的数据被生成了。这些数据具有结构化和非结构化、多尺度、多源和语义关系复杂性的特点。然而，现有的资源分配模型或算法中，<strong>缺乏</strong>对企业海量制造数据的语义信息挖掘。现有的资源分配模型或算法中，<strong>缺乏</strong>对企业海量制造数据的语义信息挖掘。这些方法<strong>忽略</strong>了车间中丰富的语义信息，不利于为资源配置提供准确的关联知识，像人类一样从知识层面进行认知和决策。根据在离散制造车间进行的实地调研发现，车间资源产生的数据<strong>利用不充分</strong>，主要有以下原因：</p><ol><li>数据类型多样：过程的历史数据在生产车间以多种类型记录。此外，大多数数据是半结构化或非结构化的，这导致数据处理效率低下。如此一来，数据便无法轻易复用，以提升后续生产设备的配置效率。</li><li>复杂的数据关系：制造数据中的车间生产设备、加工零件、工艺需求之间存在多种潜在的逻辑关联。目前，由于这些数据之间关系的复杂性，利用数据关系指导生产还不够充分。</li><li>数据处理效率低：制造数据的处理延迟无法在有急单时提供及时、动态的资源调整决策。这主要是因为各个制造步骤之间的数据关系复杂，并且缺乏对制造数据的语义理解。</li></ol><p>目前，这些数据还没有很好地用于生产计划和控制的决策。有必要探索一种有效的方法来整合积累的生产资源数据，以供工业知识重用和资源配置应用。语义技术（即本体论）广泛用于知识建模。<strong>然而</strong>，本体表示模式层上的知识，而没有描述深层语义关系。产业本体是资源概念的集合，主要描述资源概念及其属性信息。这种方法灵活性有限，知识的计算效率相对较低。知识图谱是一种结构化的语义知识库，由实体-关系-实体和实体-属性-值三元组组成，能够更好地描述数据层中的数据。此外，知识图谱能够处理具有复杂结构的大规模数据，计算不同术语之间的语义相似度，以及在没有显式边的情况下推理实体之间的隐式关系。知识图谱已经出现在制造领域。<strong>然而</strong>，从海量制造数据中挖掘特定的语义信息，构建工业资源配置决策所需的语义知识，目前还<strong>缺乏统一的信息建模和知识生成方法</strong>。此外，目前知识库构建的研究多是通过关联企业已有的知识来进行的。并且对挖掘制造业中海量的隐式语义关系缺乏深入研究，不利于丰富知识库，提高知识利用率。<strong>研究的挑战</strong>在于如何充分整合车间资源的复杂数据，挖掘隐含的语义信息，形成可行的知识驱动的资源分配优化方法，高效提供资源分配所需的相关工程信息。</p><p>本论文首先研究了一种基于统一知识图谱的制造资源优化配置方法。该方法旨在<strong>挖掘制造中的隐性关系，生成驱动生产资源分配的热更新知识图谱，从知识层面实现订单插入请求的快速资源分配决策</strong>。具体来说，提出了<strong>WRKG模型</strong>来集成工程语义信息，包括制造企业中大规模生产要素（过程、设备、人员、材料）的各种数据类型。然后，开发了一种<strong>知识表示学习算法</strong>来推理设备和进程之间的深层隐式关系。通过这种方式，WRKG 可以规范机加工车间的知识，提高生产过程的效率。此外，为了使用构建的 WRKG 为订单任务提供准确的信息，提出了基于WRKG的<strong>资源分配优化三阶段方法</strong>，包括1）制造资源重构的数学模型，2）候选设备集的形成和3）候选设备集的评估和优化。最后，在航空航天加工车间对所提出的方法进行了应用和评估。</p><p>本文的主要贡献包括：</p><p>1）提出了一个<strong>统一的基于知识图谱的决策框架</strong>，集成了机加工车间环境中的隐性工程知识。该框架用于支持资源分配的优化方法</p><p>2）开发<strong>分布式表示学习算法</strong>，挖掘复杂工程数据之间的隐含关系，丰富车间资源之间的关系，高效指导生产。</p><p>3）提出了<strong>混合模型生产过程中候选设备形成和基于社区的设备评估的三阶段方法</strong>，该方法利用机加工车间WRKG为候选设备的形成和评估提供关联数据支持。</p><p>4）通过在航空航天加工车间采用结构件的生产任务来<strong>评估</strong>所提出的方法。结果表明，该方法能够在处理稳定的前提下，生成更符合逻辑、更直观的资源重构过程知识，提高设备利用率、处理任务的响应能力和设备的灵活性。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>讨论了制造业资源分配中与订单插入相关的基本问题，即如何匹配订单请求。文章重点回顾了现有的制造业资源分配研究工作，侧重于知识表示和建模方法。</p><h4 id="Knowledge-representation-and-modeling-of-manufacturing-resources"><a href="#Knowledge-representation-and-modeling-of-manufacturing-resources" class="headerlink" title="Knowledge representation and modeling of manufacturing resources"></a>Knowledge representation and modeling of manufacturing resources</h4><p>讨论了制造业中资源分配问题中的知识表示和建模方法。现有的知识表示和建模方法（如本体学）在处理大规模知识时存在灵活性和计算效率方面的限制。因此，研究者提出了基于知识图谱的决策框架和改进的知识表示学习算法，以挖掘复杂工程数据之间的隐含语义关系，提供更全面的知识支持资源分配决策。文章认为现有的方法不能直接应用于制造业，因为制造数据复杂多样，存在许多规则和约束，导致制造资源的语义表示和建模困难。因此本文提出了一个<strong>统一的基于知识图的决策制定框架</strong>用于支持资源调度的最优方法。此外，一种<strong>改进的用于挖掘复杂的工程数据之间关系的知识表示学习算法</strong>也被提出以提供更多可理解的知识。</p><h4 id="Optimization-of-resource-configuration"><a href="#Optimization-of-resource-configuration" class="headerlink" title="Optimization of resource configuration"></a>Optimization of resource configuration</h4><p>介绍了混合模式车间动态生产环境下资源分配研究的优化方法、模型和算法。文章总结了鲁棒方法、智能优化方法和重新调度方法的优缺点，并列举了相关文献。鲁棒方法广泛研究用于优化车间资源分配，智能优化方法利用各种智能算法和优化方法进行动态资源分配，重新调度方法具有良好的时效性。这些方法都有其适用范围，但没有考虑车间中所包含的丰富语义信息。作者提出使用知识图谱来提供资源分配方法所需的信息，并提高生产决策的智能水平。因此，本文的主要贡献是使用知识图谱创新地提供资源分配方法所需的信息，并从知识层面提高生产决策的智能水平。</p><p><img src="http://cdn.leafii.top/img/image-20230306165544044.png" alt="image-20230306165544044" loading="lazy"></p><p>根据表1可以得出结论，这些方法都有一定的适用范围，但都没有考虑到workshop中包含的丰富的语义信息。智能优化方法适用于解决本文所讨论的问题。本文的主要贡献是创新性地利用知识图谱为资源配置方法提供所需信息，从知识层面提高生产决策的智能化水平。</p><h3 id="The-WRKG-modeling-method-for-production-process"><a href="#The-WRKG-modeling-method-for-production-process" class="headerlink" title="The WRKG modeling method for production process"></a>The WRKG modeling method for production process</h3><p>总的来说是，WRKG的提出是为了整合车间资源知识，并且支持插入订单的资源分配方式。 WRKG模型的建立是为了<strong>获取和融合</strong>与加工资源相关的数据，<strong>包括</strong>WRKG的<strong>定义</strong>、与设备和加工相关的<strong>信息规范</strong>。然后生成与加工相关的WRKG。此外，为了丰富和更新 WRKG，挖掘制造生产中的<strong>隐式关系</strong>，开发了一种<strong>改进的表示学习算法</strong>（improved represented learning algorithm)。</p><h4 id="Construction-of-the-WRKG"><a href="#Construction-of-the-WRKG" class="headerlink" title="Construction of the WRKG"></a>Construction of the WRKG</h4><p>为了将生产车间的大量半结构化和非结构化数据转化为结构化知识，设计了WRKG构建框架，整合车间设备资源，如图2所示。</p><p><img src="http://cdn.leafii.top/img/image-20230309204056952.png" alt="image-20230309204056952" loading="lazy"></p><p>它由三部分组成。</p><ol><li>首先，获取车间制造的历史数据、生产文件数据和实时生产数据。</li><li>其次，对制造相关信息进行知识融合处理，建立加工知识本体模型。车间资源的实体和关系存储在图数据库中。</li><li>然后使用本体规则和分布式表示学习支持的推理方法来识别与加工车间使用的设备相关的隐式关系。</li><li>最后，隐式关系之间的信息和知识应用的形成都反馈到数据采集端，以动态更新研讨会资源之间的关系。</li></ol><p>为了构建 WRKG，车间资源信息由三元组构建，结合生产要素中的机器-材料-方法（Machine-Material-Method），如图 3 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230312214619994.png" alt="image-20230312214619994" loading="lazy"></p><p>三层结构包括<strong>类别层、概念层和实体层</strong>。<strong>资源类别层</strong>由四个部分组成，代表车间的<strong>生产要素</strong>，包括设备、产品、过程和操作。<strong>中间层（概念层）</strong>是资源类别层对应的<strong>各类生产资源</strong>，有利于本体的概念形成。<strong>底层（实体层）</strong>是各类工坊资源的<strong>实体信息</strong>。这有助于开发大型车间资源的知识图谱，为设备资源之间的关系推断提供数据支持。</p><h5 id="Modeling-of-the-WRKG-of-machining-device"><a href="#Modeling-of-the-WRKG-of-machining-device" class="headerlink" title="Modeling of the WRKG of machining device"></a>Modeling of the WRKG of machining device</h5><p>本节基于WRKG框架来描述WRKG的定义。</p><p>**Definition 1.**机加工车间设备概念本体可以形式化定义为$o&#x3D;〈T,S,P,R,A〉$，其含义如下：</p><p><strong>T</strong>是术语抽象，主要是图3中的中间层（概念层）设备类。</p><p><strong>S</strong>是同义词融合，由多个术语消除歧议后形成一个唯一的术语，如高速钢车刀、硬质合金车刀都归为车刀。</p><p><strong>P</strong>为属性抽象，$P &#x3D; { BasI(i), FunI(i), StaI(i)}$，其中$BasI(i)$表示设备$i$的<strong>基本信息</strong>，如设备位置、设备名称、设备编号等.$FunI(i)$ 表示关于设备$ i $的<strong>功能信息</strong>，例如可加工的腔体、复杂的表面零件。$StaI(i)$表示设备$i$的<strong>状态信息</strong>，取值0、1、2、3、4分别代表idle、full-load、overload、failure(怠速、满载、过载和故障)。设备附带的基本属性和功能属性是<strong>静态信息</strong>，状态属性是<strong>动态信息</strong>。此外，设备的状态基于传感器和MES（制造执行系统）实时更新。</p><p><strong>R</strong>是关系抽象，它基于P中的三个属性，关系包括“has_a”、“has_tool”、“has_status”等。在加工过程中，设备节点之间的关系有<strong>动态和静态</strong>的变化. &lt;概念实例、属性关系触发词、属性值&gt;三元组用于描述设备的基本信息，如&lt;Machine, has_a, Position&gt;。</p><p><strong>A</strong>$(A(i)∈A)$是一种规则，用于<strong>约束和规范</strong>设备的形成。其中，设备元素（element）描述为$M(i)&#x3D;{ BasI(i),FunI(i),StaI(i)}∈M⇒M(i)∈P$。设备模型可表示为$M &#x3D; ∑^n_{i &#x3D;1}M(i)$。机床设备数据模型M的<strong>约束规则</strong>如表2所示。</p><p><img src="http://cdn.leafii.top/img/image-20230312221444700.png" alt="image-20230312221444700" loading="lazy"></p><p>根据<strong>Definition 1</strong> 中给出的信息，开发了加工装置的概念模型（见图 4）。</p><p><img src="http://cdn.leafii.top/img/image-20230312221852950.png" alt="image-20230312221852950" loading="lazy"></p><h5 id="Formation-of-the-WRKG-of-device-relationship-network"><a href="#Formation-of-the-WRKG-of-device-relationship-network" class="headerlink" title="Formation of the WRKG of device relationship network"></a>Formation of the WRKG of device relationship network</h5><p>**Definition 2.**机加工车间设备集的知识图可以定义为$G&#x3D;〈MI,RI,PI,G〉$，其意义如下。</p><p><strong>MI</strong>是设备信息集，指的是图3中底层的设备资源<strong>（实体）</strong>，如车床、数控铣床、加工中心等。</p><p><strong>RI</strong>是设备之间的关系。Definition 1中已经用详细信息对器件实体进行了建模，但在加工过程中器件之间仍然存在复杂多变的关系，包括顺序关系、排他关系和并行关系。具体信息如下：</p><p>a) <strong>顺序关系</strong>是设备链接在加工过程中的全局关联形式。例如，设备M1和M2的顺序关系可以表示为Sequence(M1,M2)。</p><p>b) <strong>排他关系</strong>是设备链路在处理过程中的局部关联形式。 以设备M1和M2为例，如果在选择的分支结构中都在同一条分支路径上，则可以指定设备M1和M2之间存在排他关系，即Exclusive(M1, M2) .</p><p>c) <strong>并联关系</strong>是机械加工过程中常见的设备组织关系。 例如，如果设备M1和M2在并联分支结构中有不同的分支路径，则它们之间的关系可以定义为并联关系，即Parallel(M1,M2)。</p><p><strong>PI</strong>是基于制造过程信息流的<strong>过程需求信息</strong>（见图5），主要包括设备、工具、夹具、量具、量具、标识符、操作员和传感器。</p><p><img src="http://cdn.leafii.top/img/image-20230313170059637.png" alt="image-20230313170059637" loading="lazy"></p><p><strong>G</strong>是机加工车间的设备制造资源，可以描述为一个三元组$G&#x3D;{(h,l,t)}∈(MI×RI×PI)∩o$，其中$h$是WRKG的头实体，$t$是WRKG 的尾部实体，$l$是头尾实体之间的关系。结构件的制造涉及多道工序，需要多台设备才能完成规定的加工任务。</p><p>这样，可以利用集成的信息开发全面的设备关系网络。</p><h4 id="Knowledge-representation-learning-and-mining-of-the-WRKG"><a href="#Knowledge-representation-learning-and-mining-of-the-WRKG" class="headerlink" title="Knowledge representation learning and mining of the WRKG"></a>Knowledge representation learning and mining of the WRKG</h4><p>为进一步高效<strong>挖掘机加工车间资源间的隐含关系</strong>，为支持资源分配决策提供更全面的知识，提出了一种改进的分布式表示学习方法，该方法在头尾实体中加入<strong>语义权重向量</strong>$θ_i∈\mathbb R^k$对应关系 $l_i ∈ \mathbb R^k$。机加工车间资源信息知识表示模型描述如下：</p><p>$h_i &#x3D; h \circ \theta_i^h$</p><p>$t_i &#x3D; t \circ \theta_i^t$</p><p>其中$∘$为hadamma乘积算子（矩阵对应相乘相加），$h_i$和$t_i$分别由关系$l_i$语义下的头尾实体向量表示。为了提高机加工车间资源数据的语义关联准确性，基于马氏距离（表示点与一个分布之间的距离）<strong>计算设备资源的相似度</strong>。<strong>发现车间资源实体之间的隐式关系</strong>。得分函数如下所示：</p><p>$f_l(h,t) &#x3D; (h_i \circ \theta^h_i + l_i - t_i \circ \theta_i^t)W_l(h_i \circ \theta_i^h + l_i - t_i \circ \theta_i^t)$</p><p>其中$f_l(h,t)$是<strong>车间资源数据三元组的得分函数</strong>，$W_l$是自适应度量对应的特定关系对称非负权重矩阵。</p><p>优化目标函数如下：</p><p>$min \sum_{(h,l,t) \in \Delta(h’,l’,t’)\in \Delta’}[f_l(h,t) + \gamma - f_{l’}(h’,t’)]<em>+ + \lambda(\sum</em>{l \in L}||W_l||<em>F^2)+C(\sum</em>{e \in E} ||e||<em>2^2 + \sum</em>{l\in L}||l||_2^2) $</p><p>$[W_l]_{ij} \geq 0$</p><p>其中，$[\cdot]_+$是取0和一个大的值的<strong>max值</strong>，$\gamma$是正负三元组的<strong>最大语义边界间隔</strong>， $|| \cdot||_F$是矩阵的<strong>F范数</strong>，C控制<strong>缩放度</strong>，λ控制自适应权重矩阵的<strong>正则化</strong>。可以通过将式（6）(见下文)的导数设为0来求解Wl，以提高计算效率。</p><p>为了更彻底的理解算法1中WRKG的真正实现，在5.2节中举了一个例子进行说明。</p><p><img src="http://cdn.leafii.top/img/image-20230313170345648.png" alt="image-20230313170345648" loading="lazy"></p><h3 id="A-three-staged-method-based-on-the-WRKG-for-resource-allocation-optimization"><a href="#A-three-staged-method-based-on-the-WRKG-for-resource-allocation-optimization" class="headerlink" title="A three-staged method based on the WRKG for resource allocation optimization"></a>A three-staged method based on the WRKG for resource allocation optimization</h3><p>本节提出了一个结合了WRKG以驱动设备资源调度优化的三阶段方法。该方法的每个阶段都利用相应的先前生成的制造知识，在认知层面提升资源分配决策的智能性。该方法可以将制造订单要求与机加工车间的WRKG联系起来。<strong>决策过程利用了WRKG信息，并且可以学习设备评估策略以形成指导后续生产的新知识。</strong>它包含的三个阶段如下：</p><ul><li>使用模糊层次方法所需的索引构造候选设备集。</li><li>利用基于社区的设备制造资源<strong>评价模型</strong>，从设备利用率方面对候选设备集进行评价和优化。</li><li>针对处理设备组的配置优化，建立了资源分配<strong>数学模型</strong>。</li></ul><h4 id="Mathematical-model-of-manufacturing-resource-reconfiguration"><a href="#Mathematical-model-of-manufacturing-resource-reconfiguration" class="headerlink" title="Mathematical model of manufacturing resource reconfiguration"></a>Mathematical model of manufacturing resource reconfiguration</h4><p>由2.2节的分析，可以得到机械车间资源配置的数学模型。假定加工任务中的结构件是$J&#x3D;{J_1, J_2, …, J_i, …, j_n}$，其中加工过程的j节点被视为$O_j, j&#x3D;1,2,…,n_T$，其中$n_T$是操作的总数。可用设备域被设置为设备组$G&#x3D;{G_1, G_2,…,G_t,…,G_T}$，设备节点$M&#x3D;{M_1,M_2,…,M_k,…,M_m}$，因此$G_j$表示在过程$O_j$中正在处理的设备组，并且包含了一个设备节点集$M_j \in M$。过程$O_j$在设备节点$M_k$上的处理时间用$pt_{jk}$表示，使用$tt_{mn}$（transform time)表示设备节点$M_m$和$M_n$之间的转移时间。$ST_{kj}$表示过程$O_j$在设备节点$M_k$的加工开始时间，并且$ET_{kj}$表示过程$O_j$在设备节点$M_k$上的加工结束时间。$C_i$是工件$i$节点的完成时间。$W_k$表示设备节点$M_k$的工作负载，以负载率作为衡量标准。基于以上描述，以下目标函数被定义。</p><p><img src="http://cdn.leafii.top/img/image-20230313202944346.png" alt="image-20230313202944346" loading="lazy"></p><p>上面的式子需要满足以下限制:<br>$ST_{kj} &#x3D; ET_{m(j-1)} + pt_{mk}$</p><p>这个目标是为了<strong>最小化处理时间和设备资源的负载</strong>。该限制表明在之前的处理完成之后<strong>设备之间的转移时间</strong>需要被考虑进去。</p><h5 id="Formation-of-the-candidate-device-sets"><a href="#Formation-of-the-candidate-device-sets" class="headerlink" title="Formation of the candidate device sets"></a>Formation of the candidate device sets</h5><p>结构件的生产涉及各种各样的设备。因此，基于WRKG的候选设备编队如图6所示，用于对特定进程进行资源匹配。</p><p><img src="http://cdn.leafii.top/img/image-20230313205031018.png" alt="image-20230313205031018" loading="lazy"></p><p>特定的评估指标用于选择设备以构建可选设备集。基于3.1.1节（Modeling of the WRKG of machining device）提出的制造设备信息模型，有五项设备资源评价指标，包括<strong>工件特征、加工特征、加工类型、加工精度和运行状态</strong>。这些指标具有层次结构。在这项研究中，模糊层次分析法被用来量化指标之间的关系。它的<strong>优点</strong>是可以为具有明显层次结构信息的各个评价指标分配权重。该方法可用于结构件制造过程中从<strong>指标集</strong>和<strong>对象集</strong>两个方面筛选设备资源。该方法的实现分为以下几个步骤。</p><ol><li>在指标集方面，利用WRKG提供的设备间丰富的相关性信息，建立了五类评价指标的模糊矩阵$R_{ij}$。</li><li>就对象集而言，为每个评价指标分配权重，通过计算指标间的标准差$σ_j$生成设备权重向量$W_j$。</li><li>在确定不同设备的权重向量后，引入相关系数 $ξ_i(k)$来提高设备资源的匹配精度。</li><li>通过将设备信息与过程知识相关联，得到每个候选设备资源对应指标的相关系数。</li><li>进一步计算<strong>处理任务中设备与进程信息之间的资源相似度匹配度</strong>$\gamma_s$。</li><li>最终选择符合生产要求的设备。</li></ol><h5 id="Evaluation-and-optimization-of-the-candidate-device-sets"><a href="#Evaluation-and-optimization-of-the-candidate-device-sets" class="headerlink" title="Evaluation and optimization of the candidate device sets"></a>Evaluation and optimization of the candidate device sets</h5><p>候选设备在设置后需要基于社区技术进行<strong>评估</strong>和<strong>优化</strong>。在这项研究中，社区包括几个具有共同功能和属性的共享通信节点的机床。换句话说，它可以基于通信节点对设备进行集群，以方便设备的统一组织。开发了基于社区的处理的评估模型（见图 7）。</p><p><img src="http://cdn.leafii.top/img/image-20230313220047285.png" alt="image-20230313220047285" loading="lazy"></p><ul><li>首先，WRKG<strong>提供</strong>评估方法所需的<strong>相关信息</strong>，包括设备组的组成信息和当前状态信息。</li><li>其次，如果评估需要优化，进行评估分析，及时合理分配社区设备。</li><li>最后，将各器件集的分析调整方案应用到WRKG中，形成新的器件集逻辑关系和组织形式，<strong>指导后续制造过程（更新）</strong>。</li></ul><p>社区的动态调整主要针对<strong>单台机床的负载率</strong>，旨在<strong>通过加工任务的重新分配</strong>优化机床资源的配置。评价优化算法如下：</p><p><img src="http://cdn.leafii.top/img/image-20230314102517102.png" alt="image-20230314102517102" loading="lazy"></p><h3 id="Case-study"><a href="#Case-study" class="headerlink" title="Case study"></a>Case study</h3><p>案例研究是基于航空航天企业中加工结构件的具体加工任务。</p><h4 id="Processing-information-of-aerospace-machining-workshop"><a href="#Processing-information-of-aerospace-machining-workshop" class="headerlink" title="Processing information of aerospace machining workshop"></a>Processing information of aerospace machining workshop</h4><p>选择该车间为代表进行配置优化问题的分析的理由：该车间是企业内部的核心制造车间之一。车间由16台机器组成，包括加工中心、线切割机和数控车床。其中包括三台专用功能线切割机和两台 DMG 车床 (DMG CTV160)。多功能数控机床，尤其是加工中心，是影响结构件生产效率的重要因素。设备信息在表3中提供。</p><p><img src="http://cdn.leafii.top/img/image-20230314104027858.png" alt="image-20230314104027858" loading="lazy"></p><p>本研究以车间某一时期的结构件加工任务为研究对象，主要包括特定型号的电动转向架（PTVA10212）、旋转体头罩（PTVN10312）、车架背支撑板（PTVL10111），盒体（PTVM10121）。对4个航天结构件处理后的原始数据进行整理后，批处理任务详情如表4所示。</p><p><img src="http://cdn.leafii.top/img/image-20230314104538441.png" alt="image-20230314104538441" loading="lazy"></p><p>批量生产任务处理20h时发出加工新试制盒的加急单PTVC10221（见表4），加工信息见表5。</p><p><img src="http://cdn.leafii.top/img/image-20230314105347359.png" alt="image-20230314105347359" loading="lazy"></p><h4 id="Generation-of-the-WRKG-of-the-aerospace-machining-workshop"><a href="#Generation-of-the-WRKG-of-the-aerospace-machining-workshop" class="headerlink" title="Generation of the WRKG of the aerospace machining workshop"></a>Generation of the WRKG of the aerospace machining workshop</h4><p>基于图4加工装置的概念模型，将装置的基本静态属性、状态属性、功能属性信息进行整合，生成加工中心的WRKG（见图8）。</p><p><img src="http://cdn.leafii.top/img/image-20230314105535517.png" alt="image-20230314105535517" loading="lazy"></p><p>然后将各种设备的实体信息与加工产品的工艺实体信息相关联。计算过程用于演示如何挖掘车间资源实体之间的隐含关系，阐明WRKG的更新过程（见图9）。</p><p><img src="http://cdn.leafii.top/img/image-20230314105644941.png" alt="image-20230314105644941" loading="lazy"></p><p>输入是 WRKG 中的一组三元组，结合算法 1。可以训练每个三元组以生成相应的嵌入向量。如果“加工中心”与语义相似度高的实体相匹配，则可以根据马氏距离输出对应的实体。如果预测“加工中心”和“孔”之间的隐含关系，即一个三元组（machining center, ?, hole），则可以根据评分函数输出实体之间可能存在的隐含关系。此外，隐式关系在工程师评估后更新到 WRKG。给出输出从小到大排名前3的结果，作为工程师评估的参考。为此，将隐式关系更新到 WRKG。最后，在图 10 中开发了航空结构件加工过程中的 WRKG。</p><p><img src="http://cdn.leafii.top/img/image-20230314110439473.png" alt="image-20230314110439473" loading="lazy"></p><h4 id="Resource-configuration-optimization-for-processing-tasks"><a href="#Resource-configuration-optimization-for-processing-tasks" class="headerlink" title="Resource configuration optimization for processing tasks"></a>Resource configuration optimization for processing tasks</h4><p>构建了一个基于知识的航天结构件制造资源优化配置平台如图11所示，专门针对机加工车间。由于车间排除了热处理工艺，后续分析忽略热处理的加工信息。</p><p><img src="http://cdn.leafii.top/img/image-20230314143230294.png" alt="image-20230314143230294" loading="lazy"></p><p>平台集成了前面章节描述的方法，包括当前器件加工能力信息、基于算法1的WRKG嵌入式表示、制造资源重构的数学模型、候选器件集的形成和评估。</p><p>当有新的加急订单下达时，可根据当前订单状态信息，计算可行设备群并在平台上可视化，包括具体设备的状态信息（当前加工状态、加工工件、剩余加工时间等）和任务的实时细节。</p><p>将表4的处理任务导入到平台中。此外，还计算了四个加工社区，包括 PTVM10212、PTVN10312、PTVA10111 和 PTVL10121。该平台用于在表5中的加急订单下达时，针对表4中的订单任务优化加工设备配置的计算。开发了完成PTVC10221加工任务的六台设备的加工共同体。</p><p>重新配置后，与重新配置前的设备利用率和之前的平均设备利用率相比，重新配置后的<strong>整体设备利用率得到提高</strong>（见图 12（a））。此外，前半部分的利用率显着提高，而后半部分则较少。因为新机加工社区的组成主要由现有机加工社区中的原机加工设备组成。此外，紧急订单 PTVC10221 包括现有机加工社区中的第一台机加工设备。</p><p><img src="http://cdn.leafii.top/img/image-20230314143722314.png" alt="image-20230314143722314" loading="lazy"></p><p>分析了加急订单前后各机加工社区的平均负载率和负载均衡状态。重构前后各加工团体的目标状态对比曲线如图12(b)所示。可以看出，所有机加工社区的整体负载率θ从48.82%上升到56.68%。另外，**单台机床的负载率$θ_k$不过80%**。此外，整体负载均衡状态$σ(θ)$略有变化，从6.30%变为7.51%，仍然是一个可控的理想范围（$θ_k≤80%，σ(θ)&lt;15%$）如图7和算法2所示。结果表明，车间内所有设备的负载率是均衡的。因此，得出的结论是，所提出的方法促进了车间设备社区的可持续加工。</p><p>单个设备的配置演变如图13所示，其中车削设备群体、铣削设备群体和钻削设备群体发生了变化。此外，设备社区的变化是由表5中任务订单的流程要求引起的。表 5 订单发布后，设备社区发生变化，表明设备转移发生在机加工社区内。来自不同社区的设备转移表明该方法<strong>提高了设备处理的灵活性</strong>。</p><p><img src="http://cdn.leafii.top/img/image-20230314144713007.png" alt="image-20230314144713007" loading="lazy"></p><h4 id="Discussions"><a href="#Discussions" class="headerlink" title="Discussions"></a>Discussions</h4><p>正如所呈现的工业案例研究所验证的那样，基于知识图谱的方法可以链接航空航天加工车间的制造资源，以支持加工设备的优化。它能够实时查询设备状态，为平台支持调度提供准确的信息。同时，航空结构件的生产过程涉及到很多与设备相关的信息，并不局限于机加工车间。本文仅关注机加工车间设备相关信息。<strong>不能保证</strong>在设计航空航天 WRKG 时完全涵盖设备相关关系。因此，其他车间信息和更多的关系将在以后的工作中带来。</p><p>在案例验证中，本研究分析了抢单影响下的车间流程资源重构。但是，在工业实践中还有一些情况需要进行资源重构分析，例如修改订单、设备故障等。因此，进一步的研究将集中在其他情况下如何改善制造资源配置。</p><h3 id="Conclusions-and-future-work"><a href="#Conclusions-and-future-work" class="headerlink" title="Conclusions and future work"></a>Conclusions and future work</h3><p>在车间层面开发低成本、系统的工程知识生成和分配服务机制是一项关键的研究挑战。本研究提出了一种新的基于知识图谱的设备资源分配优化方法，用于快速实时响应设备资源的配置需求。提出了生产过程的WRKG建模方法，包括WRKG的构建和基于WRKG知识表示学习和挖掘的方法。预计这两个方面将整合来自不同层次的处理知识，以支持资源分配方法。</p><p>在资源分配服务方面，提出了一种集成WRKG驱动设备资源分配优化的三阶段方法。<strong>第一步</strong>是生成标准化的加工知识，如工件特征、加工特征、加工类型、加工状态等。为了支持候选设备集的决策，<strong>第二步</strong>是使用制造资源社区评估模型评估可用设备。<strong>第三步</strong>旨在利用资源分配数学模型对处理设备集进行配置优化，保证设备的利用率最大化。最后，通过案例研究产品对所提出的方法进行评估，以证明工程知识在改进车间资源配置优化方面的价值。</p><p>未来，本研究将引入航天企业其他加工车间（热处理车间、焊接车间等）的资源，丰富航天加工车间资源之间的关系。此外，考虑包含更多的不可控因素，以提高整个资源重构过程的鲁棒性，并与其他方法进行比较。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 车间调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode739.每日温度</title>
      <link href="/2023/05/11/leetcode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
      <url>/2023/05/11/leetcode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]输出: [1,1,4,2,1,1,0,0]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: temperatures &#x3D; [30,40,50,60]输出: [1,1,1,0]</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: temperatures &#x3D; [30,60,90]输出: [1,1,0]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>单调栈</li></ul><p>解本题的第一种解题思路是直接进行暴力模拟。但是本文的样例中，若数组的长度很长而且元素都是同一个值，会导致超出时间限制，因此我们必须考虑使用其他的数据结构帮助我们进行解题。本体可以使用栈的数据结构帮助我们解题，思路如下：首先初始化答案数组为全0，数组的长度为temperatures数组的长度，栈中的元素是尚未找到下一个更高温度的索引。遍历温度列表时，如果当前温度大于栈顶索引对应的温度，说明栈顶索引对应的温度已经找到了下一个更高温度，可以计算出答案并更新结果数组。通过这种方法，可以在一次遍历中完成计算，时间复杂度为 O(n)，满足时间限制。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        int len &#x3D; temperatures.size();        vector&lt;int&gt; answers(len, 0); &#x2F;&#x2F; 储存答案数组        stack&lt;int&gt; stk; &#x2F;&#x2F; 单调栈        for (int i &#x3D; 0; i &lt; len; i++) &#123;            while (!stk.empty() &amp;&amp; temperatures[stk.top()] &lt; temperatures[i]) &#123; &#x2F;&#x2F; 当当前温度高于栈顶索引的温度时                answers[stk.top()] &#x3D; i - stk.top(); &#x2F;&#x2F; 更新对应索引的answer                stk.pop(); &#x2F;&#x2F; 较低的温度的索引出栈            &#125;            stk.push(i); &#x2F;&#x2F; 较高的温度索引入栈        &#125;        return answers; &#x2F;&#x2F; 返回答案数组    &#125;&#125;;</code></pre><p>当给定输入 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，我们可以逐步执行优化后的代码来帮助您理解它的工作原理：</p><ol><li>初始化空栈和答案数组：stk &#x3D; []，answers &#x3D; [0, 0, 0, 0, 0, 0, 0, 0]。</li><li>遍历温度列表：<ul><li>对于第一个温度 73：<ul><li>栈为空，将索引 0 压入栈。</li></ul></li><li>对于第二个温度 74：<ul><li>栈顶索引对应的温度是 73，74 &gt; 73，可以计算答案 answers[0] &#x3D; 1。</li><li>弹出栈顶索引 0，将索引 1 压入栈。</li></ul></li><li>对于第三个温度 75：<ul><li>栈顶索引对应的温度是 74，75 &gt; 74，可以计算答案 answers[1] &#x3D; 1。</li><li>弹出栈顶索引 1，将索引 2 压入栈。</li></ul></li><li>对于第四个温度 71：<ul><li>栈顶索引对应的温度是 75，71 &lt; 75，将索引 3 压入栈。</li></ul></li><li>对于第五个温度 69：<ul><li>栈顶索引对应的温度是 71，69 &lt; 71，将索引 4 压入栈。</li></ul></li><li>对于第六个温度 72：<ul><li>栈顶索引对应的温度是 69，72 &gt; 69，可以计算答案 answers[4] &#x3D; 2。</li><li>弹出栈顶索引 4，将索引 5 压入栈。</li></ul></li><li>对于第七个温度 76：<ul><li>栈顶索引对应的温度是 72，76 &gt; 72，可以计算答案 answers[5] &#x3D; 1。</li><li>弹出栈顶索引 5，将索引 6 压入栈。</li></ul></li><li>对于最后一个温度 73：<ul><li>栈顶索引对应的温度是 76，73 &lt; 76，将索引 7 压入栈。</li></ul></li></ul></li><li>完成遍历后，栈中剩余的索引对应的答案无法计算，因为它们没有找到下一个更高温度。因此，答案数组中仍然为0。</li></ol><p>最终的答案数组为 [1, 1, 4, 2, 1, 1, 0, 0]，它表示每个温度需要等待的天数，直到出现更高的温度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode503.下一个更大元素II</title>
      <link href="/2023/05/10/leetcode503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/"/>
      <url>/2023/05/10/leetcode503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,2,3,4,3]输出: [2,3,4,-1,4]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>直接进行循环遍历判断即可。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;        int len &#x3D; nums.size();        vector&lt;int&gt; answers;        for (int i &#x3D; 0; i &lt; len; i++) &#123;            int temp &#x3D; nums[i]; &#x2F;&#x2F; 保存当前需要判断的值            int temp_index &#x3D; i; &#x2F;&#x2F; 保存当前需要判断的值的索引            int answer &#x3D; -1; &#x2F;&#x2F; 初始化answer元素            for (int j &#x3D; (i + 1) % len; j !&#x3D; temp_index; j &#x3D; (j + 1) % len) &#123;                if (nums[j] &gt; temp) &#123;                    answer &#x3D; nums[j]; &#x2F;&#x2F;找到第一个比temp大的元素，将其赋值给answer 并跳出当前for循环                    break;                &#125;            &#125;            answers.push_back(answer); &#x2F;&#x2F; 将answer放进答案数组中        &#125;        return answers; &#x2F;&#x2F; 返回答案数组    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode496.下一个更大元素I</title>
      <link href="/2023/05/09/leetcode496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/"/>
      <url>/2023/05/09/leetcode496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].输出：[3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 2 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。下一个更大元素是 3 。- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li><li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力实现</li></ul><p>直接模拟实现</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt; answers;        map&lt;int,int&gt; m;&#x2F;&#x2F; m用于存储nums2数组中每个元素的下标值        for (int i &#x3D; 0; i &lt; nums2.size(); i++) &#123;            m[nums2[i]] &#x3D; i;        &#125;        for (int i &#x3D; 0; i &lt; nums1.size(); i++)&#123;            int index &#x3D; m[nums1[i]]; &#x2F;&#x2F; 获取nums1的元素在nums2的下标值            int answer &#x3D; -1;            int temp &#x3D; nums1[i];            if (index &#x3D;&#x3D; nums2.size() - 1) answer &#x3D; -1;            else &#123;                while (index &lt; nums2.size()) &#123;                    if(index+1 &lt; nums2.size() &amp;&amp; nums2[index+1] &gt; temp) &#123;                        answer &#x3D; nums2[index+1];                        break;                    &#125;                    else &#123;                        index++;                    &#125;                &#125;            &#125;            answers.push_back(answer);        &#125;        return answers;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1356.根据数字二进制下1的数目排序</title>
      <link href="/2023/05/09/leetcode1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/05/09/leetcode1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p><p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p><p>请你返回排序后的数组。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]解释：[0] 是唯一一个有 0 个 1 的数。[1,2,4,8] 都有 1 个 1 。[3,5,6] 有 2 个 1 。[7] 有 3 个 1 。按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [10000,10000]输出：[10000,10000]</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [2,3,5,7,11,13,17,19]输出：[2,3,5,17,7,11,13,19]</code></pre><p><strong>示例 5：</strong></p><pre class="language-none"><code class="language-none">输入：arr &#x3D; [10,100,1000,10000]输出：[10,100,10000,1000]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 500</code></li><li><code>0 &lt;= arr[i] &lt;= 10^4</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路如下：</p><ol><li>首先定义一个辅助函数<code>countBits</code>，用于计算一个数的二进制表示中1的个数。该函数使用位运算技巧，通过不断将数字与其自身减1的结果进行按位与运算，可以统计出二进制中1的个数。</li><li>接下来定义一个自定义的比较函数<code>compare</code>，用于在排序时比较两个数的大小。该函数首先分别计算两个数的二进制中1的个数，然后比较它们的个数。如果个数相等，则按照原始数值的大小进行比较。</li><li>然后定义<code>sortByBits</code>函数，该函数接受一个整数数组作为参数，并使用STL的<code>sort</code>函数对数组进行排序。在排序过程中，使用自定义的比较函数<code>compare</code>进行比较。</li><li>在主函数<code>main</code>中，创建一个测试数组<code>arr</code>，并调用<code>sortByBits</code>函数对数组进行排序。排序后的结果保存在<code>sortedArr</code>中。</li><li>最后，通过循环遍历<code>sortedArr</code>，将排序后的数组打印输出。</li></ol><p>整体思路是先计算每个数字的二进制中1的个数，然后根据这个个数进行排序，当个数相同时按照原始数值的大小进行排序。通过自定义比较函数和使用STL的<code>sort</code>函数，可以方便地完成这个排序任务。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int get(int x)&#123;        int res &#x3D; 0;        while (x) &#123;            res +&#x3D; (x % 2);            x &#x2F;&#x3D; 2;        &#125;        return res;    &#125;    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123;        vector&lt;int&gt; bit(10001, 0);        for (auto x: arr) &#123;            bit[x] &#x3D; get(x);        &#125;        sort(arr.begin(), arr.end(), [&amp;](int x, int y)&#123; &#x2F;&#x2F; Lambda表达式语法            if (bit[x] &lt; bit[y]) &#123;                return true;            &#125;            if (bit[x] &gt; bit[y]) &#123;                return false;            &#125;            return x &lt; y;        &#125;);        return arr;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种基于任务网络图聚合的多卫星多任务调度新方法</title>
      <link href="/2023/05/07/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%BD%91%E7%BB%9C%E5%9B%BE%E8%81%9A%E5%90%88%E7%9A%84%E5%A4%9A%E5%8D%AB%E6%98%9F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%96%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2023/05/07/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%BD%91%E7%BB%9C%E5%9B%BE%E8%81%9A%E5%90%88%E7%9A%84%E5%A4%9A%E5%8D%AB%E6%98%9F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%96%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>卫星网络任务调度时效性问题是实现空地一体化网络（STIN）的关键。传统方法将卫星任务调度问题解释为线性或非线性规划问题，忽略了任务之间的复杂关系。为了提高多卫星和多任务场景中任务调度的及时性，我们<strong>研究了解释任务相关性的网络图结构</strong>。然后，我们<strong>针对具有相似性和相关性特征的任务</strong>提出了多层网络图聚合模型。进一步，我们<strong>将任务调度问题转化为零一规划问题</strong>，设计任务调度算法来解决任务调度时效性问题。最后，我们模拟和模拟真实世界的数据作为实验数据集，用于与三种基线算法进行比较。实验结果表明本文方法具有明显的优势和进步。</p><span id="more"></span><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文的Introduction部分首先介绍了卫星任务调度的背景和意义，指出卫星任务调度是卫星运行中最重要的环节之一，其质量直接影响到卫星系统的性能和效益。然后，介绍了传统方法在多卫星和多任务场景下存在的问题，包括复杂的任务关系、低效的任务调度及时性等。接着，本文提出了一种基于任务网络图聚合的新方法来<strong>改善任务调度及时性</strong>。该方法将不同卫星上的原子任务聚合成一个整体图，并通过优化算法实现对整体图进行调度。最后，Introduction简要介绍了本文研究内容和结构安排，包括模型构建、算法设计、仿真实验等方面。</p><p>我们的贡献可以简要总结如下：</p><ul><li>我们<strong>建立了任务的网络图表示方法</strong>，解决了多卫星多任务关系复杂难表示的问题，实现了多任务复杂关系的统一表示。首先，我们根据任务的初始执行时间、资源需求、资源类型、任务操作等任务属性设计了任务的五元组。然后，我们将任务表示为边，任务属性表示为边属性，开始和结束执行事件表示为节点。根据任务执行时间的顺序，将任务之间的关系映射到边之间的关系，构建任务网络图。另外，我们根据资源类型、资源数量、可见时间窗的起止时间属性，设计了卫星的五元组。</li><li>我们<strong>构建了任务网络图的相似性聚合和相关性聚合模型</strong>，可以解决相似任务重复执行和相关任务独立分配带来的相互约束问题，实现多任务执行时间的最大压缩.首先，我们构建了多层任务网络图的聚合模型。根据任务之间的相似性和相关性，我们将所有任务网络图重构并聚合成一个大的任务网络图。然后，我们根据网络图和任务网络图中的关键路径计算出每个任务的最早开始执行时间和最晚结束执行时间，即完成所有任务的理论最短时间。</li><li>我们<strong>设计了多星多任务调度优化算法</strong>，保证大规模任务网络图能够在最短的理论时间内执行，实现多星多任务调度的高时效性。如果任务网络图中关键路径上的任务按时执行，任务网络图中的其他任务也会在资源充足时执行。因此，我们将多卫星和多任务调度问题解释为一个零一规划问题。然后，我们优先考虑关键路径上任务的资源分配策略，然后基于零一规划模型为剩余任务分配空闲卫星资源。</li></ul><h2 id="3-问题描述-amp-模型构建"><a href="#3-问题描述-amp-模型构建" class="headerlink" title="3. 问题描述&amp;模型构建"></a>3. 问题描述&amp;模型构建</h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h3><p>原子问题五元组：$\alpha &#x3D; &lt; t_{start}, r_t, r_n, oper, t_{end}&gt;$,tstart表示原子任务的计划初始执行时间，rt表示原子任务的资源需求类型，rn表示原子任务的资源需求，oper表示原子任务在卫星上的运行，tend表示最新的计划的执行时间。</p><p>可用卫星问题五元组：$s &#x3D; &lt;st_{start}, sr_t,sr_n, s_{oper}, st_{end}&gt;$,ststart表示卫星可见时间窗的开始时间，srt表示卫星当前提供的资源类型，srn表示卫星当前时刻可以提供的资源总量，soper表示卫星运行，stend表示可见时间窗的结束时间。</p><p>定义1 原子任务α由卫星直接执行，执行过程中不允许被打断。原子任务是从任务σ中分解出来的。</p><p>任务σ的原子任务α具有顺序执行关系，原子任务之间相互包容、相互制约。也就是说，有些原子任务只有在其他原子任务执行完之后才能执行。一般来说，原子任务有不同的资源类型、数量要求和初始执行时间，多个卫星可以满足同一个原子任务的资源需求。根据医院信息网络动态时变环境下原子任务的这些特点，计算多任务原子任务的执行顺序和执行时间，保证任务执行时间最短是关键问题。</p><h3 id="3-2-最短时间内完成机载多任务执行顺序动态计算模型"><a href="#3-2-最短时间内完成机载多任务执行顺序动态计算模型" class="headerlink" title="3.2 最短时间内完成机载多任务执行顺序动态计算模型"></a>3.2 最短时间内完成机载多任务执行顺序动态计算模型</h3><p>主要解决最小化任务执行时间的问题，假设特定时间段的开始时间为 Tstart ，结束时间为 Tend 。然后，</p><p><img src="http://cdn.leafii.top/img/image-20230507152603783.png" alt="image-20230507152603783" loading="lazy"></p><p>如式(3)所示，pi表示一个离散的时间段。 C1 表示 Γ 中的任何离散周期时间未被覆盖或重叠。 C2 表示从离散时间 i 到 j 的时间段为 pς 。我们需要计算任务执行在离散时间段Γ内的最短耗时，建立优化模型如下：</p><p><img src="http://cdn.leafii.top/img/image-20230507152625126.png" alt="image-20230507152625126" loading="lazy"></p><p>如式(4)所示，表示<strong>任意时间段Γ内所有原子任务并行执行消耗的最小时间的计算方法。</strong> p(i, j) ∈ Γ 表示在 Γ 中的一个小时间段，p(i, j) 不为零，即 i ≠ j。式(4)中，C1表示任意时间段p(i,j)的有效时间为p(θ,θ‘)。如图1所示，p(i,j)是随机考虑的某个时间段。该时间段包含的任务执行队列中最新任务的执行结束时间不一定严格等于j，即θ为p(i,j)中执行的第一个任务1的开始执行时间。同理，θ为最后一个任务8的执行结束时间。因此，我们取时间段p(i,j)内执行的第一个任务开始执行时间为θ，最后一个任务执行结束时间是θ’，p(θ, θ‘) ∈ τ 表示为 p(i, j) 中的多个任务全部执行完毕的最大起止时间。p(θ, θ’) 包含可以在 K(θ − θ’) 的时间段内完成的完整任务集。在离散时间段(θ,θ‘)中，我们取当前时间段内所有任务执行时间的最大值，max∀k∈K(t) Ct(k)表示所有任务的最大耗时值在时间 t 正在执行的任务。例如，式（4）中的C2表示单位时间的耗时约束。我们假设t是单位时间，那么任务Ct(k)的耗时为1。此时我们可以观察到在任务未执行时Ct(k)的值为0。另外，如果有正在执行的任务，则当前时刻消耗的时间记录为1，因此图1中所有任务消耗的最大时间为θ’-θ-(b-a)。</p><p><img src="http://cdn.leafii.top/img/image-20230507152752798.png" alt="image-20230507152752798" loading="lazy"></p><p>值得一提的是，式（4）中所有任务最早开始执行和最晚结束执行的时间和执行顺序<strong>并不准确</strong>，从而导致出现多种组合。不幸的是，当我们遍历所有可能的组合时，这对卫星的计算能力来说将是灾难性的。此外，它消耗了大量的计算时间，导致卫星网络执行任务的时效性差。那么，关键问题是如何快速计算出原子任务的执行顺序，并保证消耗的时间最少。</p><h2 id="4-问题转化和解决方式"><a href="#4-问题转化和解决方式" class="headerlink" title="4. 问题转化和解决方式"></a>4. 问题转化和解决方式</h2><p>将最小化执行时间的问题转化为两个子问题：<strong>计算原子任务开始和结束时间的问题</strong>以及<strong>聚合相似原子任务问题</strong></p><p>计算原子任务开始和结束时间的问题：确定原子任务的最早开始和最晚结束执行时间，以减少原子任务执行时间内的组合数量，将多种组合方案减少为少数几种可组合方案。然后，我们计算原子任务的最晚开始执行时间和最早结束执行时间，并结合结果数据确定某些任务的开始和结束执行时间。这个时候，原子任务的执行顺序也已经确定了。</p><p>聚合相似原子任务问题：我们根据原子任务之间的相似特征和相关关系特征聚合相似的任务执行，节省重复执行原子任务所消耗的时间。</p><h3 id="4-1-基于网络图表示的关键原子任务计算模型与算法"><a href="#4-1-基于网络图表示的关键原子任务计算模型与算法" class="headerlink" title="4.1 基于网络图表示的关键原子任务计算模型与算法"></a>4.1 基于网络图表示的关键原子任务计算模型与算法</h3><p>我们给定原子任务的统一表示元组。原子任务作为网络图的边，元组元素作为边的属性。节点表示原子任务开始或者结束执行的事件。原子任务之间复杂的关系由网络图结构进行表示。网络图的计算由两个元素组成：<strong>首先</strong>，每一个边的最早开始时间和最晚结束时间被用于计算原子任务的执行的时间范围。<strong>然后</strong>网络图的关键路径被计算，在关键路径上的任务为必要的原子任务。如果原子任务的优先计算得到了保障，那么我们可以得到所有原子任务的最小执行时间。</p><p>我们使用网络图数据结构去表示原子任务，然后重新定义了原子任务。原子任务由以下式子表示：</p><p>$\alpha’ &#x3D; &lt;t’_{start}, t_{start}, r_t, r_n, oper, t_{end}, t’_{end}&gt;$</p><p>我们添加了原子任务的最早可能开始时间 t′ start 和允许完成执行的最晚时间 t′ end 。一个任务 σ 可以分解为多个原子任务 σ &#x3D; {α′ 1, α′ 2, α′ 3, … , α′ n}。</p><h4 id="4-1-1-任务网络图表示"><a href="#4-1-1-任务网络图表示" class="headerlink" title="4.1.1 任务网络图表示"></a>4.1.1 任务网络图表示</h4><p>根据原子任务集合中原子任务的优先级重新分配原子任务的执行顺序，并且获得新的原子任务队列。我们将网络中的<strong>边表示为网络图的原子任务</strong>。图中的<strong>节点表示为原子任务执行的事件</strong>。</p><p><img src="http://cdn.leafii.top/img/image-20230505174740721.png" alt="image-20230505174740721" loading="lazy"></p><blockquote><p>示意图显示了原子任务之间的依赖关系。子图(a)表示边代表原子任务，子图(b)节点表示原子任务执行的事件。</p></blockquote><p>在构建任务网络图之前，我们需要计算原子任务的<strong>计划完成时间</strong>。</p><p>$P(\alpha’<em>i) &#x3D; t</em>{end, i} - t_{start, i}$</p><p>这个式子里的$P(\alpha’_i)$就是原子任务$\alpha’_i$的计划完成时间。</p><p>然后边的属性可以表示为$w_i &#x3D; (t’<em>{start}, A_i, t’</em>{end})$,而且边的属性的集合为$W &#x3D; {w_1, w_2, …, w_m}$</p><h4 id="4-1-2-任务网络图计算模型"><a href="#4-1-2-任务网络图计算模型" class="headerlink" title="4.1.2 任务网络图计算模型"></a>4.1.2 任务网络图计算模型</h4><p>如图所示。$v_1$是任务执行开始的事件，$v_7$是任务执行结束时的事件。图G表示一个特定任务的所有原子任务的<strong>依赖关系</strong>。节点上的出度边所代表的原子任务可以在节点上的入度边所代表的原子任务完成后执行。边的属性信息W表示原子任务的执行时间、最早执行时间和最晚执行时间。</p><p><img src="http://cdn.leafii.top/img/image-20230505191049565.png" alt="image-20230505191049565" loading="lazy"></p><p>引理1. <strong>关键路径</strong>的引理和证明 略</p><p>定理1. T 是关键路径上的关键任务集。除关键路径P的任务集外，其余任务集为Q。C(T) + C(Q) &#x3D; min(C(G))，其中执行 T 的<strong>时间成本</strong>是 C(T)，执行 Q 的时间成本是 C(Q)， 时间成本的证明略</p><p>从引理 1 可以看出，我们关心的是任务的<strong>开始和结束事件最早和最晚发生的时间</strong>，网络中最后一个事件的完成时间就是整个图像完成的时间。然而，定理 1 关注的是<strong>网络图中所有边所代表的任务执行时间和成本的总和</strong>。同时，时间成本是网络图上边的权重。</p><p>为了保证提升任务执行效率并缩短任务的执行时间，我们需要<strong>计算完成任务所需的最短时间以及对任务执行时间有影响的关键任务</strong>。如果我们保证关键任务的正常执行，那么理论上我们可以获得网络图执行的最短时间。对于任务网络图G，是完成最后一个事件Vm和每个原子任务的关键性的最短时间。同时，我们可以参考AOE（Activity on edge network）网络的关键路径计算方法。</p><p><img src="http://cdn.leafii.top/img/image-20230505192540505.png" alt="image-20230505192540505" loading="lazy"></p><p>te(vj )表示<strong>任务事件最早发生的时间</strong>，P(ez)表示执行原子任务所需的时间。在约束条件C1中，T是所有以顶点vk结尾的边的头顶点集合，ez代表所有以顶点vk结尾的边。ez 表示所有以顶点 vk 结尾的边。以节点vj的所有原子任务中执行时间最长的原子任务为出度，事件vi最早发生时间之和就是事件vi最早发生时间。</p><p>从已完成的顶点vn开始，令l(vn) &#x3D; e(vn)求拓扑序中<strong>剩余顶点的最晚允许出现时间</strong>。如式(8)所示，S是所有以vj为头的弧的尾顶点的集合。如约束条件 C2 所示，j 必须满足约束条件 1 ⩽ j ⩽ n − 1。</p><p><img src="http://cdn.leafii.top/img/image-20230505193310443.png" alt="image-20230505193310443" loading="lazy"></p><p>找出每个原子任务ei的最早开始时间<strong>e(i) &#x3D; e(vj )</strong>, 1 ⩽ i ⩽ m，最晚开始时间**l(i) &#x3D; l(vk) − P (vj , vk)<strong>。如果一个弧</strong>满足e(i) &#x3D; l(i)**，那么它就是一个关键任务。</p><h4 id="4-1-3-关键原子任务的计算算法"><a href="#4-1-3-关键原子任务的计算算法" class="headerlink" title="4.1.3 关键原子任务的计算算法"></a>4.1.3 关键原子任务的计算算法</h4><p>由上述的（8）和（7），我们设计了一个<strong>网络图计算算法</strong>，算法如下：</p><p><img src="http://cdn.leafii.top/img/image-20230505193623442.png" alt="image-20230505193623442" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230505193635610.png" alt="image-20230505193635610" loading="lazy"></p><p>算法2的设计参考了AOE网络的关键路径求解方法。首先，算法1被用于创建一个任务网络图并且进行拓扑排序的操作，并且初始化所有时间的发生时间为0.算法 2 以网络图作为输入数据（第 1-3 行），然后根据拓扑排序顺序从前到后更新事件的最早执行时间。用每个顶点的每个相邻点更新e(v)，其值是连接到当前节点和相邻节点的所有边的最大值与当前最早时间之和（第4-9行）。同理，按照拓扑排序顺序，从后向前更新节点最晚出现时间l(v)（第10行），求出每个原子最早出现时间e(edge)和最晚出现时间l(edge)根据 e(v) 和 l(v) 的任务。根据e(edge)和l(edge)是否相等判断原子任务是否为关键原子任务。网络图中最后一个节点的最早出现时间是整个任务的最早完成时间（第 11-22 行）。</p><h3 id="4-2-基于原子任务相似特征的多网络图聚合模型及算法"><a href="#4-2-基于原子任务相似特征的多网络图聚合模型及算法" class="headerlink" title="4.2 基于原子任务相似特征的多网络图聚合模型及算法"></a>4.2 基于原子任务相似特征的多网络图聚合模型及算法</h3><p>通过考虑原子任务的相似性和相关特征，我们将不同的网络图聚合成一整个图。拥有相似特征的原子任务可以被组合为一个简单的原子任务。同样的，有关联的多原子任务可以被聚合成一个可以在单个卫星完成的不可分解的任务集合。由于多层网络图在聚合过程有环路，会导致<strong>计算关键路径</strong>失败。因此，我们基于剪枝的思想设计了一种破环算法来实现多层网络图聚合的目的。</p><p>基于刚才提出的网络图表示方法，我们可以把多任务表示为多网络图。在网络图之间偶尔会有很多边会被合并从而形成一个大范围的网络图。定义3解释了任务聚合，也就根据特定的规则将多个网络图合并为一个网络图。任务聚合的规则有两方面：依赖聚合关系以及相似聚合关系。定义4解释了依赖聚合关系的定义，定义5解释了相似聚合关系的定义。</p><p>定义3 <strong>任务聚合</strong>是指分析多个任务的原子任务集φ并将满足特定约束的多个原子任务聚合到一颗卫星上执行，或者将多个具有相似特征的原子任务合并为一个原子任务。最终形成一组新的原子任务。聚类后的任务集仍然是原子任务集。</p><p>定义4 <strong>依赖聚合关系</strong>是指原子任务执行顺序之间的相互依赖关系。如果一个原子任务αi的执行结果是另一个或多个原子任务的执行前提，则这些原子任务满足依赖聚合关系。</p><p>依赖包括多对一的依赖以及一对一的依赖，如图所示.</p><p><img src="http://cdn.leafii.top/img/image-20230506204533547.png" alt="image-20230506204533547" loading="lazy"></p><p>定义5 <strong>相似聚合关系</strong>定义为原子任务之间存在相似的资源需求、任务需求或执行结果。如果同一卫星在同一周期内可以执行多个原子任务，则这些原子任务之间满足相似聚合关系。</p><p>如图6所示，子图(a)描述了分散在多颗卫星上的具有相似特征的多个原子任务，子图(b)描述了可以包含其他原子任务特征的原子任务，子图(c)描述了多颗卫星- 原子任务聚合成一个原子任务。</p><p><img src="http://cdn.leafii.top/img/image-20230506204630468.png" alt="image-20230506204630468" loading="lazy"></p><p>目标原子任务的执行结果数据包含所有源原子任务的执行结果数据。所以目标原子任务可以代替所有源原子任务的执行过程。</p><h4 id="4-2-1-相似原子任务聚合模型"><a href="#4-2-1-相似原子任务聚合模型" class="headerlink" title="4.2.1 相似原子任务聚合模型"></a>4.2.1 相似原子任务聚合模型</h4><p>为了降低非必要任务执行的影响，我们研究了所有相似和相关任务聚合的方法。所有的原子任务都在集合X上执行，单颗卫星可以独立完成一个原子任务，不需要多颗卫星联合执行。集合Z&#x3D;{R,B,L}中所有具有依赖关系的原子任务记为R。具有相似关系的所有原子任务的集合为B&#x3D;{S,H}，S表示具有相似关系的所有目标原子任务的集合相似关系，H表示具有所有相似关系的原子源任务集合，所有不符合聚合关系的原子任务集合为L，则原子任务集合Z由卫星集合X执行完成所需的总消耗的时间如方程式所示。 (12),</p><p><img src="http://cdn.leafii.top/img/image-20230506213501362.png" alt="image-20230506213501362" loading="lazy"></p><p>我们将执行具有依赖关系的所有目标原子任务集合R的卫星集合记为A，将执行具有依赖关系的目标原子任务αr的卫星记为xr，则所有具有依赖关系的原子任务聚合后<strong>消耗的时间模型</strong>如下所示在 (13)</p><p><img src="http://cdn.leafii.top/img/image-20230506214147818.png" alt="image-20230506214147818" loading="lazy"></p><p>T(R)表示所有具有依赖关系的原子任务集合执行所消耗时间的总和。</p><p>把10和9式子放进13中，可得到式14:</p><p><img src="http://cdn.leafii.top/img/image-20230506214341116.png" alt="image-20230506214341116" loading="lazy"></p><p>我们将执行具有相似关系S的所有目标原子任务的卫星集合表示为B，将执行目标原子任务s的卫星表示为xs。则<strong>聚合后所有具有相似关系的原子任务消耗的时间模型</strong>如式(15)所示。</p><p><img src="http://cdn.leafii.top/img/image-20230506214437470.png" alt="image-20230506214437470" loading="lazy"></p><p>C(γ(s), xs)表示目标原子任务s在卫星xs上消耗的执行时间。C1是对目标原子任务集合的距离约束，表示卫星执行原子任务时天线角度或遥感设备角度等操作的转换时间。 C2是具有相似特征的源和目标原子任务之间的约束关系。</p><p>所有原子任务集合Z中<strong>除相似特征原子任务和原子依赖任务外其余任务的执行耗时</strong>可构造为式(16)，</p><p><img src="http://cdn.leafii.top/img/image-20230506214559626.png" alt="image-20230506214559626" loading="lazy"></p><p>D是执行原子任务集合L的卫星集合，C(γ(l),xl)是执行不可聚合的原子任务所消耗的时间，xl是执行原子任务l的卫星。</p><p>综上所述，我们构建了<strong>可聚合的原子任务执行时间消耗模型和其他原子任务执行时间消耗模型</strong>。 代入方程式。 （14），（15）和（16）进入等式。 (12) 产生执行和完成所有任务 N 所消耗的时间总和。 时间消耗如方程式 (17)所示。</p><p><img src="http://cdn.leafii.top/img/image-20230506214727347.png" alt="image-20230506214727347" loading="lazy"></p><p>其中C1-C2表示所有可聚合原子任务与其他原子任务的关系和范围，所有任务执行时间T都不为0。C3-C5说明具有可聚合关系的源原子任务和目标原子任务之间的关系和约束。 C6表示原子任务执行过程中卫星完成天线或载荷设备角度调整所消耗的时间，我们默认为一个固定值。</p><p>总之，我们对多颗卫星上多任务执行的时间消耗进行建模，如式（17）所示，并求解该式。 𝑇 预先假定需要确定哪些原子任务有资格进行聚合以及选择卫星来执行它们。 一旦确定了这些要求，就可以<strong>更新聚合原子任务的网络图表示</strong>，然后可以根据算法2<strong>求解多任务执行的最小时间消耗</strong>。</p><h4 id="4-2-2-相似原子任务聚合算法"><a href="#4-2-2-相似原子任务聚合算法" class="headerlink" title="4.2.2 相似原子任务聚合算法"></a>4.2.2 相似原子任务聚合算法</h4><p>本节我们基于上述多层网络聚合模型设计相应的求解算法。在多图聚合的过程中，我们发现了多图聚合后产生循环的情况。我们设计了一种聚合后不产生循环的算法，并建立了一种消除任务网络图中循环的方法。</p><h5 id="A-层任务网络图的相似度聚合算法"><a href="#A-层任务网络图的相似度聚合算法" class="headerlink" title="A. 层任务网络图的相似度聚合算法"></a>A. 层任务网络图的相似度聚合算法</h5><p><img src="http://cdn.leafii.top/img/image-20230506215146281.png" alt="image-20230506215146281" loading="lazy"></p><p>在图7的a中有两个网络图的初始状态。我们基于原子任务的属性特征不同来计算任务之间的相似度。比如，如果多个观测任务的观测区域重叠，在观测任务的一些原子任务之间就有一个相似度。观察区域覆盖率较大的原子任务就是需要聚合的目标原子任务，我们称之为目标原子任务。观察目标区域较小的原子任务是等待聚合的原子源任务，我们称之为源原子任务。根据这些规则，我们确定要在多图中聚合的目标任务和源原子任务。</p><p>值得一提的是，目标原子任务可以有多个源原子任务与之对应，而源原子任务只有一个目标原子任务。如图b，蓝色的边表示目标原子任务，红边表示源原子任务。再决定目标和源原子任务后，我们需要跨越多个图并建立源原子任务和原子目标任务之间的关系。如图c所示，我们通过创建9-&gt;3和5-&gt;12虚拟边来聚合两个图。尽管多个图可以通过虚拟边聚合为一个图，额外的虚拟边以及属性值的设定影响着多图聚合的效果。因此，我们将虚拟边的属性值设置为0并且用最少的虚拟边将原子目标任务进行连接。子图 (c) 描绘了具有多个源节点 1,8 和多个汇点 7,14 的完整网络图。此时的网络图并没有计算使用算法2的所有任务的最小消耗时间和关键原子任务。因此我们需要把多源多沉没的网络图表示为单源单沉没的网络图。如图d所示，我们增加两个虚拟事件0，-1，虚拟事件0是网络图的源，虚拟事件1时网络图的下沉。同时，我们增加虚拟边0-&gt;1, 0-&gt;8, 7-&gt;-1, 14-&gt;-1到网络图中。此外，红色边被蓝色边合并，并且虚拟边被创建去消除原子源任务，消除了完成两个原子任务的需求以实现仅一个目标原子任务的目标。新的逻辑虚拟结点表示一个空的原子任务，它并未被执行。在消除原子源任务9-&gt;12后，与其关联的事件9,12也可消除。如图e所示，事件9和3被合并，事件12和5被合并，最终导致一个完整的网络图被聚合。</p><p><img src="http://cdn.leafii.top/img/image-20230506223615258.png" alt="image-20230506223615258" loading="lazy"></p><p>如图8所示，图a到f描述了拥有一个目标原子任务的多源原子任务的聚合过程。图a描述了两个任务的网络图的初始状态。图b表示聚合关系的计算结果，蓝色边表示原子目标任务，红色边表示要被合并的原子源任务。如图c所示，虚拟边9-&gt;3，5-&gt;12以及11-&gt;3,5-&gt;10被添加用目标原子任务去合并两个源原子任务。如图d所示，为了将多源，多下沉网络图转化为单源，单下沉网络图，我们增加两个虚拟事件0，-1，我们添加两个虚拟事件 0、-1，以及虚拟边 0 → 1、0 → 8 和 7 → −1、14 → −1。剔除源原子任务 9 → 12 和 11 → 10 后，事件 9、11、12、10 就没有有意义的存在了。因此，事件9，11需要与事件3合并。同样，事件12，10需要与事件5合并，合并结果如子图（e）所示。我们发现事件 8 和事件 3 之间有两条边，即要执行的两个原子任务。类似地，在事件 5 和事件 14 之间有两个原子任务要执行。如子图 (f) 所示，我们的任务网络图表示中不允许两个相邻事件之间存在两条或更多条边。因此，我们添加两个虚拟事件-2、-3和两个虚拟边缘8→-2和-3→14。目标原子任务的虚拟事件、虚拟边缘和事件3,5之间的关系为8→ −2 → 3 和 5 → −3 → 14 其中 8 → −2 → 3 上的原子任务是随机选择子图 (e) 中事件 5 和事件 14 之间的两个原子任务。同样，5 → -3 → 14 是在事件 5 和事件 14 之间的两个原子任务中的随机选择。最后，根据原子任务相似性，将两个网络图表示为一个完整的网络图。</p><p><img src="http://cdn.leafii.top/img/image-20230507132332862.png" alt="image-20230507132332862" loading="lazy"></p><p>如图9所示，它描述了具有数据依赖性的原子任务之间的聚合过程。子图 (a) 显示了两个图的初始状态。子图 (b) 描述了两个图中的目标和源原子任务，其中蓝色边表示原子目标任务，两条红色边表示原子源任务。原子任务 4 → 6 的执行需要原子任务 10 → 14 和 13 → 14 的执行。关联原子任务聚合不是消除原子任务，而是将具有关联的原子任务从分散状态转换为集中状态。那么我们需要尽可能将具有相关性的原子任务分配给一颗卫星执行，这样可以减少大量卫星协同处理数据所花费的时间。如图(c)所示，虚拟边14→4连接两个图，虚拟节点0和虚拟边0→1、0→8将图从多源节点转变为单源节点。子图（d）描绘了事件14,4的合并，其中原始事件10→14、13→14被转换为10→4、13→4。原子目标任务和原子源任务没有改变，但它们的关系被改变，使它们更紧凑。根据卫星资源状况，我们可以考虑将新的目标原子任务4→6和原子源任务10→4、13→4在同一颗卫星上执行，减少数据请求和数据传输的耗时。</p><p>定理 2. 给定一个单源单汇网络图 G。如果 G 中存在任务 ei，则其属性五元组为 α(ei) &#x3D; ⟨tei start, rei t, rei n, operei, tei end⟩,以及任务执行时间范围 L(ei) &#x3D; (tei start, tei end)。存在一个任务 ej，其属性为 α(ej) &#x3D; ⟨tej start, rej t, rej n, operej , tej end⟩，任务执行时间范围为 L(ej ) &#x3D; (tej start, tej end)。如果rei t &#x3D; rej t, L(ei) ∩ L(ej ) ≠ ⊘，则存在一个任务ek 可以替代任务ei 和ej 并且任务ek 的耗时小于任务ei 和ej 的总和。</p><p>证明略</p><p>根据定理 2，我们构建任务 ek 来替换网络图 G 中的任务 ei 和 ej，并且任务 ek 被执行的时间成本小于任务 ei 和 ej 的总和。</p><p><strong>算法3描述了原子任务相似性特征的多任务聚合过程</strong>。首先获取原子任务属性数据，然后计算不同原子任务的相似性特征（第 1-7 行）。基于每个原子任务的特征数据，采用K-均值聚类算法计算原子任务在多个网络图中的相似度，选择原子目标任务作为聚类算法的质心。与每个质心相邻的原子任务可视为原子源任务（第 9 行）。我们根据计算结果得到源和目标原子任务的启动和终止事件。然后我们构建一个虚拟链接，它建立在原子源任务的起始节点和目标原子任务的起始节点之间。目标原子任务的终止节点实际上链接到源原子任务的终止节点。最后，删除所有原子源任务（第 10-11 行）。如果两个事件之间存在两个或多个原子任务，则必须重建多个原子任务连接。我们通过构建虚拟节点和虚拟边（第 12-15 行）将额外的原子任务连接到新路径。最后，源原子任务的开始和结束节点与目标原子任务的开始和结束节点合并（第 16-17 行）。</p><p><img src="http://cdn.leafii.top/img/image-20230507134025076.png" alt="image-20230507134025076" loading="lazy"></p><h5 id="B-原子任务数据依赖的识别与聚合算法"><a href="#B-原子任务数据依赖的识别与聚合算法" class="headerlink" title="B. 原子任务数据依赖的识别与聚合算法"></a>B. 原子任务数据依赖的识别与聚合算法</h5><p>定理3. 给定一个单源单汇网络图 G。如果 G 中存在任务 ei，则其属性五元组为 α(ei) &#x3D; ⟨tei start, rei t, rei n, operei, tei end⟩,以及任务执行时间范围 L(ei) &#x3D; (tei start, tei end)。存在一个任务 ej，其属性为 α(ej) &#x3D; ⟨tej start, rej t, rej n, operej , tej end⟩，任务执行时间范围为 L(ej ) &#x3D; (tej start, tej end)。将任务𝑒𝑖和𝑒𝑗的执行过程产生的成本表示为𝜇，当𝑒𝑖是任务𝑒𝑗的入口度边时，任务𝑒𝑖和𝑒𝑗的执行过程产生的成本表示为𝜈，<strong>则𝜇⩾𝜈</strong>。</p><p>证明略。</p><p><img src="http://cdn.leafii.top/img/image-20230507134813348.png" alt="image-20230507134813348" loading="lazy"></p><p>由定理3可知，<strong>将具有相关关系的任务聚合在一起执行所消耗的成本要小于聚合前所消耗的成本。</strong>因此，我们根据定理3设计了<strong>基于多任务依赖关系的聚合算法4</strong>。该算法描述了原子任务相关关系特征的识别和多任务聚合过程。首先，我们获取原子任务属性数据，然后计算不同原子任务的相似性特征（第 1-7 行）。然后，根据每个原子任务的特征数据，我们计算原子任务在多个网络图中的相关性，输入数据是其他原子任务的输出数据，可以将其视为目标原子任务。相反，其输出数据可用作其他原子任务的输入数据的原子任务可被视为源原子任务（第 9 行）。基于计算出的源任务的端点事件和目标任务的起点事件，我们在源任务的端点事件和目标任务的起点之间创建了一个虚拟链接。为了构建单源单汇网络图，创建虚拟节点和虚拟边并将其链接到网络图的多个源和汇，并删除与源原子任务关联的虚拟边，最后将端点源原子任务的起点与目标原子任务的起点合并（代码 10-12）。</p><h5 id="C-消除网络图中多环路的形成"><a href="#C-消除网络图中多环路的形成" class="headerlink" title="C. 消除网络图中多环路的形成"></a>C. 消除网络图中多环路的形成</h5><p>A小节描述的多层网络图的聚合过程属于没有出现环路的情况。然而，现有空间信息网络中任务图的合并过程会产生多个循环。因此，本节C提出了一种<strong>消散多层网络图聚合过程中的环路形成的方法</strong>，并设计了打破四种环路的算法，以解决多层网络图聚合过程中的环路形成问题。</p><p>由<strong>待聚合边的源节点的入度边引起的环路解析过程</strong>描述如示意图10所示。</p><p><img src="http://cdn.leafii.top/img/image-20230507135753688.png" alt="image-20230507135753688" loading="lazy"></p><p>子图(a)为循环生成前的状态。边 (a, b) 是目标任务，边 (53, 54) 是要聚合的任务。事件50为已经合并的事件，边(51, 53)为节点53的入度边。子图(b)描述了任务(a, b)和(53, 54)完成合并后的状态已被合并。由于边 (53, 54) 被 (a, b) 替换，因此边 (51, 53) 被移除并添加了新边 (51, a)。同时，图中存在环路。事件50、51、a形成子图(c)所示的循环。如子图（d）所示，为了打破循环，我们添加了一个新的虚拟事件 0 和一条权重为 -w 的边 (0, 51)，从而在不丢失原始边上的权重 w 的情况下打破了原始循环（ 51，a）。此外，我们需要将图的起始节点’start’连接到新的虚拟事件0。类似地，图11描述了由边的源节点的入度边引起的环路解析过程是聚合。子图(a)和(b)描述了边(53, 54)聚合的过程，任务(53, 51)是源53的出度边。子图(c)是之后形成的循环聚合，子图（d）添加虚拟时间0，添加边0,51以打破循环，最后将网络源节点start连接到虚拟节点0。</p><p><img src="http://cdn.leafii.top/img/image-20230507140348700.png" alt="image-20230507140348700" loading="lazy"></p><p>如示意图12所示，描述了由<strong>待聚合边的汇聚节点的入度边引起的环路解析过程</strong>。子图(a)为环路生成前的状态，其中边(a, b)为目标任务，边(49, 50)为待聚合任务。子图(b)描述了任务(a, b)和(49, 50)合并后的状态，由于(49, 50)被(a, b)替换，该图形成了一个循环。事件b、52、51形成一个循环，如图(c)所示。如子图 (d) 所示，我们添加了一个新的虚拟事件 0 和一条权重为 -w 的边 (0, 51) 来打破循环，从而在不丢失边 (51, b) 上的权重 w 的情况下打破了原始循环。此外，我们需要将网络源节点“start”连接到添加的虚拟事件0。类似地，图13描绘了由要聚合的边缘的汇节点的出度边缘引起的环路解决过程。子图 (a) 和子图 (b) 描述了边 (49, 50) 聚合的过程。子图(c)表示聚合后形成的环路，子图(d)加入虚拟时间0，加入新的边(0, 51)打破环路，最后将网络源节点start连接到虚拟节点0。</p><p><img src="http://cdn.leafii.top/img/image-20230507140413748.png" alt="image-20230507140413748" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230507140618038.png" alt="image-20230507140618038" loading="lazy"></p><p>定理 4. 给定一个没有循环的网络图 G 和 G’，要合并的边 e(a, b) ∈ G 和合并后的边 e(c, d) ∈ G’，其中 e( c, d) 是 I(c)，输出边的集合是 O(d)。加入一条新的边e(m, n)连接边e(a, b)和边e(c, d)，合并后的新边为e(a’, b’)。如果合并边e(a, b)和e(c, d)，则得到一个新的网络图G’’，其中生成了环路P。添加事件 v 最早发生时间 ve(v) &#x3D; ve(m) 和最晚发生时间 vl(v) &#x3D; vl(m) 的新虚拟节点 v。权重为 w 的虚拟边 ev 和反向虚拟边创建具有权重 −w 的边 e′ v 并用于打破循环。同时，得到无环合并网络图G*。如果在不考虑虚拟边权重的情况下计算网络图的总时间成本，则 **min(C(G∗)) &#x3D; min(C(G) + C(G′))**。</p><p>证明略。</p><p>由定理4可知，<strong>聚合后多网络图的时间成本消耗小于聚合前原始网络图的时间消耗</strong>。然而，聚合网络图不允许环路的存在。为了解决这个问题，我们设计了<strong>算法 5 来打破聚合网络图中的循环</strong>。该算法描述了消除网络图中循环歧义的过程。首先，我们获得所有聚合边的入度和出度边（第 2-3 行）。如果网络图中存在环路，则判断合并边(source, sink)的源节点source的入边suInEg或出边suOutEg是否在环路路径中。如果它在循环中，它会删除任一条边，中断循环，并添加具有权重的新边，从而保持网络权重不变（第 714 行）。类似地，伪代码（第 16-22 行）中显示了合并边的源节点源（源、汇）的循环中断。</p><p><img src="http://cdn.leafii.top/img/image-20230507140951660.png" alt="image-20230507140951660" loading="lazy"></p><h4 id="4-3-基于聚合网络图的多星资源分配方法"><a href="#4-3-基于聚合网络图的多星资源分配方法" class="headerlink" title="4.3 基于聚合网络图的多星资源分配方法"></a>4.3 基于聚合网络图的多星资源分配方法</h4><p>基于聚合后的网络图，我们需要将网络图上的任务分配给场景中的所有有效卫星。我们将任务调度问题转化为 0-1 规划问题。然后开发了基于聚合网络图的任务调度模型，并设计了求解算法以实现高时间效率的任务调度。</p><p>本节基于聚合网络图解决多星资源分配问题，实现多星多任务的高时效调度。为了更方便地描述我们的多卫星和多任务调度模型，我们根据 3.1 节中描述的原子任务和卫星元组表示简化任务集为 σ &#x3D; σ1, σ2, … , σm，其中 m 是任务。任务的属性集表示为 σi &#x3D; ai, bi, ci, di, 0 ⩽ i &lt; m，其中 A 表示卫星接触窗口的开始时间，B 表示任务资源需求数，C表示卫星接触窗口的结束时间，D表示卫星资源类型。卫星集合简化为 S &#x3D; s1, s2, … , sn，其中 n 是卫星的数量。每个卫星属性表示为 sj &#x3D; ej , fj , gj , hj , 0 ⩽ j &lt; n，其中 E 表示任务开始执行的时间，F 表示任务需要的资源数量，G 表示时间任务完成的时间点，H 表示任务要求的资源类型。</p><p>根据上述定义，我们将多星-原子任务的任务执行最小时间记为T&#x3D;min f(X)，T为任务等待执行时间与任务执行时间之和。我们可以<strong>转化多卫星多任务调度问题为 0–1 规划问题。</strong>该模型的构造如下：</p><p><img src="http://cdn.leafii.top/img/image-20230507141611179.png" alt="image-20230507141611179" loading="lazy"></p><p>如方程式 (18)所示。C1为待解矩阵X的描述。 X 是由要求解的值形成的矩阵。矩阵中的元素标识卫星是否被允许参与执行某项任务。 xi,j在矩阵X中的第j列表示任务σj在卫星si上的执行状态。如果 xi,j &#x3D; 0，则意味着卫星 si 没有资源分配给任务 σj 。</p><p>反之，则意味着卫星需要为指定的任务分配资源。 C2是根据任务数量和卫星数量生成的所有已知元素为1的矩阵。 C3表示f(X)的解需要满足任务开始执行时间大于卫星可见时间窗开始时间。 C4表示卫星可见时间窗的结束时间需要大于任务执行的结束时间。 C5是指卫星拥有的资源类型应与任务所需的资源类型相同。 C6表示卫星拥有的资源数量需要大于任务所需的资源数量。</p><p><strong>算法6描述了多星多任务的调度过程，我们重点计算任务本身的执行顺序和执行时间的优化。</strong>首先，我们根据任务网络图表示算法 1（第 3 行）构建具有多个任务的多个网络图。然后使用算法 3 聚合多图中具有相似特征的原子任务。通过使用算法 4 聚合多图中具有数据依赖性的原子任务，获得由多个任务组成的单源单汇网络图（第 5-6 行） .根据算法 5 消除网络图中的循环。根据算法 2（第 7-8 行）计算无循环网络图中的关键原子任务和整个图要消耗的最短时间。我们使用第三方计算库P uLP 2 根据每个原子任务的最早和最晚执行时间、关键原子任务、聚合的原子任务来计算原子任务。根据每个原子任务的最早和最晚执行时间、关键原子任务、被聚合的原子任务等，为原子任务分配卫星资源。分配卫星资源，使其不超过原子任务的最早或最晚执行时间，并且通常执行关键原子任务（第 9-15 行）。 至此，多任务将在最短时间内完成，无需考虑复杂的资源约束和优化策略，即可计算出多星多任务耗时最短的调度方案。</p><p><img src="http://cdn.leafii.top/img/image-20230507142136552.png" alt="image-20230507142136552" loading="lazy"></p><h2 id="5-实验"><a href="#5-实验" class="headerlink" title="5. 实验"></a>5. 实验</h2><h3 id="5-1-算法复杂度分析"><a href="#5-1-算法复杂度分析" class="headerlink" title="5.1 算法复杂度分析"></a>5.1 算法复杂度分析</h3><p>我们着重研究了任务执行顺序和执行时间的计算，以克服多个任务混合执行耗时控制的困难，保证任务执行耗时最少。我们研究了原子任务聚合算法，可以节省不必要的原子任务执行时间消耗，进一步提高多任务执行效率。基于多任务网络图聚合的调度方法主要包括五种算法：网络图构造算法、相似原子任务聚合算法、相关关系原子任务聚合算法、网络图关键路径和最小耗时计算算法、多星多-任务调度算法。</p><p>算法1将所有原子任务视为网络图的边，将原子任务的开始执行事件和结束执行事件分别视为边的节点。算法输入是一个任务，所以算法的时间复杂度主要体现在该任务的所有原子任务的遍历过程中。如果原子任务的个数是E，那么它的时间复杂度就是O(E)。算法2主要计算特定网络图上的关键任务路径和整个网络图完成执行所需的最短时间。其计算时间消耗主要体现在网络图节点和边的遍历上，时间复杂度为O(E+V)。算法3主要计算多个网络图之间具有相似关系的原子任务的聚合。计算中使用经典的k-均值算法。</p><p>对于简单情况，𝑘 − 𝑚𝑒𝑎𝑛𝑠 算法的运行时间界限是 𝑂(𝑑𝐸4𝑀2)。 算法3的时间复杂度主要体现在多个网络图和网络图上边的遍历操作上。 若两个事件的冗余边数为𝑟，网络图数记为𝐺，则算法3的时间复杂度可表示为𝑂(𝐺𝑑𝐸4𝑀2𝑟)。 算法4主要计算多个网络图上具有相关关系的原子任务之间的聚合操作，其时间复杂度主要体现在网络图和边的遍历上。 因此，它的时间复杂度是𝑂(𝐺𝐸)。 算法6主要是在上述算法的基础上完成多图的最小时间和卫星资源分配计算，其时间复杂度为𝑂(𝐺𝐸+𝐸+𝑉+𝐺𝑑𝐸4𝑀2𝑟+𝐺𝐸)。 我们将本文提出的基于网络图聚合的多卫星多任务调度算法的时间复杂度简化为𝑂(𝐺(𝑑𝐸{4}𝑀{2}𝑟 + 𝑉 + 𝐸))。</p><h3 id="5-2-实验数据"><a href="#5-2-实验数据" class="headerlink" title="5.2 实验数据"></a>5.2 实验数据</h3><p>为研究天基信息网络的任务调度、链路优化、协同计算、网络拓扑发现等关键问题，自主研发了基于天然卫星的空间信息网络通用计算环境仿真工具包（CSTK）3和天基信息网络的共同任务数据。在本系统中，我们模拟了大量的卫星数据，包括卫星载荷数据、卫星轨道数据、星间可见时间窗、星间可见时间窗数据、卫星资源容量、卫星资源数量等。我们模拟了对地观测常见应用场景数据，包括对地观测区域数据、任务执行时间需求、任务资源类型、任务资源需求等。此外，我们开发了CSTK系统所需的多种计算库。在本文中，我们获得了基于CSTK系统的实验数据，并在该系统上实现了本文提出的模型和算法进行计算。本文提出的算法MSRA-TAG的实验数据描述如下，</p><p>如表1所示，本文共有六组实验数据。标题“Datasets”表示数据集的名称，标题“Atomic tasks”表示数据集中原子任务的数量，标题“Satellites”表示数据集中卫星的数量。</p><p><img src="http://cdn.leafii.top/img/image-20230507144250302.png" alt="image-20230507144250302" loading="lazy"></p><p>如表 2 所示，我们总共使用了四个数据集。每个数据集中包含的卫星和任务数量呈梯度增长，其中Scale表示每个数据集中的任务和卫星数量，’Minimum Strat Time’是所有任务的最短开始时间和所有卫星的最短开始时间在可见时间窗内。同样，“最大战略时间”表示所有任务或卫星的可见时间窗口的最大开始时间。 “最短结束时间”表示所有任务和卫星可见时间窗口的最短结束时间。 “最大结束时间”表示所有任务和卫星的可见时间窗口的最大结束时间。 ‘Minimum Resources Num’表示所有任务所需的最少资源数和所有卫星可用的最少资源数。‘Maximum Resources Num’表示所有任务中需要最多资源的任务和所有卫星中能提供最多资源的卫星请求的资源数量。 “资源类型”表示任务所需资源类型和卫星有效载荷的资源类型。 1表示观测资源，2表示存储资源，3表示传输资源。</p><p><img src="http://cdn.leafii.top/img/image-20230507144239318.png" alt="image-20230507144239318" loading="lazy"></p><p>为了验证 MSRA-TAG 在真实卫星观测场景中的有效性，我们添加了对真实世界数据的模拟，其中包含较少的合成数据。在真实的地球观测场景中，我们研究了两个用于观测地球区域目标的用户任务。用户任务是对用户需求的描述，是粗粒度的任务。观测场景包含两个观测需求，八颗观测卫星和两个用于发送任务指令的地面站。场景时间范围从“2022 年 3 月 5 日 04:00:00.000 UTCG”到“2022 年 3 月 6 日 04:00:00.000 UTCG”，步长为 10 秒。模拟场景如图 14 所示，子图 (a) 和 (b) 显示了两个观测任务的地球观测区域的 3D 和 2D 视图。我们可以观察到两个观测任务的目标观测区域重叠。这意味着两个用户任务被分解为原子任务后，还存在一部分相似或相关的原子任务。子图(c)和(d)显示了卫星轨道、地面站和观测区域的完整场景视图。我们可以从 3D 或 2D 场景观察卫星凌日的时间。</p><p><img src="http://cdn.leafii.top/img/image-20230507143958198.png" alt="image-20230507143958198" loading="lazy"></p><p>真实观测场景的任务数据详情如表3所示。我们可以观察到’’Real World Dataset’’表示真实世界数据集名称，’’TaskID’’指定用户任务ID，’’Areas’’表示观察区域的经纬度坐标和“离散时间范围”表示观察场景周期离散化的持续时间，以秒为单位。 “Resources Type”字段表示用户任务所需的卫星资源类型，与表1中的类型相同。</p><p>观测场景中的卫星详情如表4所示，表中卫星涉及整个观测任务，’’Common Name’’表示卫星名称，’’Launch Date’’表示发射日期卫星的“周期”表示卫星的运行周期（以分钟为单位）。 “倾角”表示卫星相对于地球的倾角，“原子序数”表示卫星上安装的天线数，双线元全称“TLE”表示卫星轨道范围。</p><h3 id="5-3-Experimental-parameter"><a href="#5-3-Experimental-parameter" class="headerlink" title="5.3 Experimental parameter"></a>5.3 Experimental parameter</h3><p>本文使用python第三方库sklearn中的Spectral Clustering(Huang et al., 2020)方法完成相似边的查找。在完成多任务聚类后，我们使用线性求解器 P uLP 4 来实现多任务资源分配的解决方案。我们在 P uLP 求解器中使用默认参数设置。 Spectral Clustering方法中的参数设置如下表5所示。</p><p>如表5所示，其中参数gamma值在0.01、0.1、1、10范围内选取，参数n_clusters在2、3、4、5、6范围内选取。我们选取最优的聚合结果从上面训练出来的集合，以及聚类完成后默认选择的三个类别的集合。所有任务的默认最短开始时间应大于 0。</p><p>我们将本文方法与用于天基信息网络电路任务调度的基线算法进行比较，5 这些算法包括粒子群优化 (PSO)（Chen 等人，2012 年；Kennedy 和 Eberhart，1995 年；Luo 等人，2020 年） ; Xia et al., 2009), Genetic Algorithm (GA) (Gerges et al., 2018; Sun et al., 2010; Xhafa et al., 2012), and Differential Evolution (DE) (Li &amp; Li, 2019; Storn &amp; Price，1997 年；Wu、Wang 等人，2015 年）算法。 在空间信息网络任务调度场景下，这些算法的参数设置如表6所示，其中参数𝑙𝑏表示各自变量的最小值，𝑢𝑏表示各自变量的最大值，参数𝑙𝑏表示各自变量的最大值， 每个变量作为卫星当前拥有的资源数量上线。 𝑝𝑟𝑜𝑏_𝑚𝑢𝑡表示方差概率，𝑝𝑟𝑒𝑐𝑖𝑠𝑖𝑜𝑛表示算法𝐺𝐴的精度，𝑤表示算法𝑃的惯性权重𝑆𝑂， 𝑐1表示算法𝑃𝑆𝑂的个体记忆，𝑐2表示算法𝑃𝑆𝑂的集体记忆，𝐹表示方差系数 算法𝐷𝐸。</p><h3 id="5-4-Experimental-results"><a href="#5-4-Experimental-results" class="headerlink" title="5.4 Experimental results"></a>5.4 Experimental results</h3><p>本节分为三个主要部分来分析和验证我们提出的方法的性能。首先，我们比较和分析了我们的聚合方法的性能。然后对多卫星多任务资源分配性能进行了精确分析。最后，将本文提出的方法 MSRA-TAG 与三个基线模型进行比较，以彻底验证方法 MSRA-TAG 的有效性和优越性。</p><h5 id="A-多任务聚合前后任务执行时间对比"><a href="#A-多任务聚合前后任务执行时间对比" class="headerlink" title="A. 多任务聚合前后任务执行时间对比"></a>A. 多任务聚合前后任务执行时间对比</h5><p>一个任务在整个调度过程中的时间成本消耗包括两个主要部分：任务执行消耗的时间和分配卫星资源时等待执行的时间。在本文中，我们提出的聚合过程发生在卫星资源分配过程之前。因此，我们比较了聚合前后计划执行任务所需的时间，以验证我们提出的相似性聚合和相关性聚合方法的有效性。</p><p>如表7所示，我们分别计算了聚合前原始任务和聚合后任务在六个数据集上的计划执行消耗时间。 我们可以观察到原始任务和聚合任务的计划耗时在数据集𝐷1 上是相同的，这表明没有执行聚合过程。 造成这种情况的原因是数据集中的任务数量太少，导致不存在相似的任务或有相关关系的任务。 因此任务无法聚合，导致聚合前后任务计划执行的成本消耗相同。 在数据集𝐷2、𝐷3、𝐷4、𝐷5、𝐷6和𝐷𝑟𝑒𝑎𝑙上，我们可以观察到聚合后任务的耗时小于原始任务的耗时，说明任务集中的某些任务具有相似或相关关系 ，它们聚合在一起并减少了任务大小。</p><p>经过上面的分析，我们可以注意到，任务的聚合操作可以减少任务执行时间的消耗，减少任务的数量。此外，如图15所示，聚合后任务总成本的降低率随着数据量的增长而增长。此外，我们可以意识到，当任务数量增加时，具有相似性和相关性的任务数量也会增加，聚合后任务执行时间消耗也会减少。因此，当空间信息网络满足许多任务请求时，我们提出的聚合方法降低的任务执行消耗成本随着任务数量的增加而增加。在真实世界数据的模拟结果中，我们可以观察到任务聚合后任务消耗的估计时间成本减少了 861。聚合后减少的时间消耗比大批量任务场景要小，因为真实数据集中只有两个用户观察任务。因此，更少的任务满足聚合条件。本文提出的任务聚合方法对真实世界数据有效。总之，我们提出的聚合方法可以适应大容量任务请求场景。</p><h5 id="B-关键路径任务优先资源分配与全图分配结果对比"><a href="#B-关键路径任务优先资源分配与全图分配结果对比" class="headerlink" title="B. 关键路径任务优先资源分配与全图分配结果对比"></a>B. 关键路径任务优先资源分配与全图分配结果对比</h5><p>任务聚合后，需要将当前时刻活跃卫星拥有的空闲资源分配给任务。本节给出了本文提出的关键路径任务优先级分配资源方法与全图分配资源结果的对比分析。如4.3节所述，关键路径任务优先分配资源法是指先将资源分配给网络图中关键路径上的原子任务，再分配给关键路径以外的剩余任务，即保证整个网络图可以在理想的时间内执行和完成。全图资源分配是指根据实际卫星资源的数量一次性为网络图中的所有任务分配资源。之后，我们分析了这两种方法的实验结果数据。</p><p>如表8所示，关键路径优先分配和整个网络图的一次性分配的成本消耗在D1数据集上是一致的。这表明卫星资源的数量足以执行网络上的所有任务，不存在资源竞争。因此，这两种方法都不会延长关键路径上任务的执行时间。然而，随着D2-Dreal数据集上的任务数量逐渐增加，卫星资源不足导致资源争用。它导致网络地图上关键原子任务的执行按时完成。结果，“一次性分配”方法导致整个网络的时间成本消耗增加。</p><p><img src="http://cdn.leafii.top/img/image-20230507145258428.png" alt="image-20230507145258428" loading="lazy"></p><p>如图16所示，随着任务的增加，对资源的竞争也越来越激烈。子图描述了与一次性分配方法一致的优先关键路径方法对数据集 D1 的成本消耗。这是因为任务数量少，不会造成资源争用。此外，网络图中关键任务的执行越来越延迟，导致整个网络图中的任务执行成本增加。在真实数据集 Dreal 上，我们可以观察到整图一次性分配方法的成本消耗大于关键路径优先方法的成本消耗。因此，关键路径任务优先执行法实现了显着的成本节约和更理想的结果。随着任务数量的增加，成本节约消耗更加出色。</p><p><img src="http://cdn.leafii.top/img/image-20230507145509413.png" alt="image-20230507145509413" loading="lazy"></p><h5 id="C-MSRA-TAG-与基线方法的调度结果对比"><a href="#C-MSRA-TAG-与基线方法的调度结果对比" class="headerlink" title="C. MSRA-TAG 与基线方法的调度结果对比"></a>C. MSRA-TAG 与基线方法的调度结果对比</h5><p>本节将本文的方法 MSRA-TAG 与基线算法 PSO、GA 和 DE 进行比较。 算法计算成本消耗越小，意味着算法对动态变化的空间信息网络的适应性越强，算法的性能就会提高。如表9所示，PSO、GA、DE算法的成本消耗在数据集D1上是一样的，都是7797。MSRA-TAG相比baseline方法是3657，消耗的时间不到所消耗时间的一半通过基线模型，显着降低了任务执行的成本消耗。但是，我们发现MSRA-TAG大于原任务的计划成本消耗时间2761，这是由于卫星可见窗口、资源数量或分配时卫星功率等任务约束的等待时间造成的任务的卫星资源。此外，我们提出的方法 MSRA-TAG 在数据集 D1 上产生的任务等待时间延迟仅为 896。基线方法GA和DE在数据集D2上的结果相同，PSO算法的结果略高于GA和DE。我们提出的方法 MSRA-TAG 计算所有方法中的次要成本消耗。</p><p><img src="http://cdn.leafii.top/img/image-20230507145904784.png" alt="image-20230507145904784" loading="lazy"></p><p>在数据集 D3 上，我们提出的方法 MSRA-TAG 计算结果为 51 604.99，远小于原始任务的计划成本消耗 62,665.09，这是由任务集中许多相似任务和具有相关性的任务引起的数据集的数量增加。因此，众多任务的聚合极大地减少了时间成本消耗。在数据集 D3 上，随着数据集数量的增加，任务集中存在许多相似的任务和具有相关性的任务。然而，尽管如此，任务的等待时间仍然存在。在数据集 D5 上，MSRA-TAG 的时间成本为 179,240.64，原始任务的时间成本为 251,749.25，其他基线方法的时间成本分别为 623,999、623 760 和 623 760。原始任务的时间成本为 72,508.61，MSRATAG 节省的其他算法的时间成本为 444,548.61。 MSRA-TAG 相对于其他算法节省了 444,758.36、444,519.36 和 444,519.36。所有数据集上的卫星资源分配过程都存在任务等待时间消耗。 baseline算法的结果大致相同，但都远大于MSRA-TAG方案消耗的时间成本。类似地，数据集 D4、D5 和 D6 上的 MSRA-TAG 显示出随着任务数量的增加任务执行时间消耗减少的增加趋势。总之，我们的方法比基线方法具有绝对优势。</p><p>在真实数据集 Dreal 上，我们可以观察到 MSRA-TAG 的成本为 370 064，大约是源任务耗时的 23 倍。种群智能算法 PSO、GA 和 DE 消耗相同的成本 518 400，大约是源任务消耗时间的 33 倍。因此，与所有基线方法相比，MSRA-TAG 的成本消耗较小，可以提高任务调度的时效性。总之，我们的方法 MSRA-TAG 与基线方法相比具有绝对优势。</p><p>如图 17 所示，“原始任务成本”表示原始任务的时间消耗。随着任务数量的增加，所提出的方法 MSRA-TAG 的上升幅度远小于基线方法，并且其时间成本在数据集 D3、D4、D5、D6 和 Dreal 上低于原始任务。</p><p><img src="http://cdn.leafii.top/img/image-20230507150103220.png" alt="image-20230507150103220" loading="lazy"></p><p>为了更清楚地比较多种方法的时间消耗趋势，我们计算了每个算法在不同数据集上固定基数的增长率，计算如下，</p><p><img src="http://cdn.leafii.top/img/image-20230507150146637.png" alt="image-20230507150146637" loading="lazy"></p><p>如方程式所示。 (19)，我们将算法集 A &#x3D; {Original Tasks Cost, MSRA-TAG, PSO, GA, DE} 定义为 y &#x3D; {a1, a2, a3, a4, a5}。定义数据集 D &#x3D; {D1, D2, D3, D4, D5, D6, Dreal} 为 x &#x3D; {d1, d2, d3, d4, d5, d6, d7}。 φx(y)表示方法ai计算的任务执行耗时，1≤i≤5在数据集dj上，1≤j≤5。γ(x)表示原始任务在数据集x中的耗时。 f (x, y) 表示算法 x 在数据集 y 上的固定基数的增长率。</p><p>如表 10 所示，我们分别使用表 9 中“原始任务成本”列的值作为数据集 D1 −Dreal 的基线。其中，MSRA-TAG方法在数据集D1和D2上的增长率为正，小于baseline方法。这意味着 MSRA-TAG 方法的计算结果对于原始任务的成本消耗具有最低的增长率，即我们提出的任务调度方法需要最少的时间成本消耗。 MSRA-TAG 在数据集 D3、D4、D5 和 D6 上的增长率均为负值，其绝对值小于其他基线算法。这意味着该方法消耗的时间成本低于原任务的计划成本，增长率均低于其他算法。在真实数据集Dreal上，随着任务和卫星数量的增加，MSRATAG成本消耗以2298.65%的速度增长，而基线模型PSO、GA和DE的成本消耗增长率为3260.12%。</p><p><img src="http://cdn.leafii.top/img/image-20230507150218903.png" alt="image-20230507150218903" loading="lazy"></p><p>通过比较，我们可以观察到 MSRA-TAG 方法具有最慢的成本增长率和较高的任务执行时间。 虽然在真实数据集中只考虑了八颗卫星，但两个用户任务分解后产生的原子任务比数据集𝐷1中包含的原子任务数量要多。 原子任务的数量越多，可聚合的任务就越多，耗时也就越少。 因此，方法 MSRA-TAG 在𝐷𝑟𝑒𝑎𝑙 上的成本增长率小于 D1。</p><p>我们提出的方法 MSRA-TAG 随着任务数量的增加使更多的任务聚合在一起执行，从而减少重复执行的大量时间成本。如图 18 所示，算法 PSO、GA 和 DE 的增长率具有相同的值，导致三种算法的增长率倍数重叠。 MSRA-TAG、PSO、GA 和 DE 的增长率在数据集 D1 和 D2 上是有利的。然而，随着任务数量的增加，MSRA-TAG 在数据集 D3、D4、D5 和 D6 上出现了负增长，增长率曲线停滞在-30.37%。 PSO、GA 和 DE 的增长率仍然为正，增长率稳定在 147.87%。 PSO、GA 和 DE 的增长率保持正增长并稳定在 147.87%。我们的方法 MSRA-TAG 显示出正增长率，低于数据集 Dreal 上 PSO、GA 和 DE 的增长率。我们可以观察到MSRA-TAG在所有数据集上相比基线算法的时间成本消耗最少，并且随着数据量的增长增长率逐渐降低，具有优异的性能。</p><p><img src="http://cdn.leafii.top/img/image-20230507150344294.png" alt="image-20230507150344294" loading="lazy"></p><p>为了验证所有算法在任务数量变化时的性能，我们根据所有算法在数据集 D1 上的基准测试结果，计算了每个算法在数据集 D2、D3、D4、D5、D6 和 Dreal 上的增长率。随着任务和卫星数量的增加，时间成本的增加是不可避免的。因此，我们提出的方法 MSRA-TAG 旨在尽我们所能减少任务的时间成本消耗。如表11所示，原任务的时间成本增长率为1102%。本文提出的算法MSRA-TAG虽然在数据集𝐷2上997%的增长率比基准算法高出900%，但并没有显着差异。 这种情况是因为数据集𝐷2中的任务和卫星数虽然相对于数据集𝐷1增长了1102%，但具有相似关系或相关关系的任务并不多，聚合效果不明显。 但随着数据量的增长，MSRA-TAG的增长率明显低于其他基准算法，这是由于任务和卫星数量的增长，出现了更多具有相似和相关关系的任务，使得MSRA- TAG充分发挥其性能。 如图19所示，随着数据量的增长，MSRA-TAG的增长率明显低于其他基线方法，其增长率曲线的斜率也远小于 其他基线算法。 然而，与其他方法相比，MSRA-TAG 在真实数据集 Dreal 上相对于 𝐷1 的增长率最高。 这是因为𝐷1数据集中的卫星比数据𝐷𝑟𝑒𝑎𝑙中的卫星多。 然而，𝐷1 中的原子任务数量少于𝐷𝑟𝑒𝑎𝑙。 因此，与 𝐷𝑟𝑒𝑎𝑙 相比，它导致 𝐷1 的成本最低，后者更广泛并导致更显着的增长率。</p><p><img src="http://cdn.leafii.top/img/image-20230507150417069.png" alt="image-20230507150417069" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230507150524224.png" alt="image-20230507150524224" loading="lazy"></p><p>综上所述，我们的方法在处理大批量任务请求时具有出色的性能，并且与其他方法相比，任务越多，我们的时间消耗就会少得多。然而，对于任务数量较少的场景，我们的方法的优异性能并不能得到充分体现。</p><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6. Conclusion"></a>6. Conclusion</h2><p>针对空间信息网络中多卫星多任务场景下任务关系复杂、任务调度时效性差的问题，研究多任务聚合方法和多卫星资源分配方法，提出了一种<strong>独创的复杂多任务聚合方法</strong>，基于合成数据集和真实世界数据，仿真验证了该方法在多卫星、多任务调度场景下的有效性和优越性。我们提出了<strong>多任务的网络图表示</strong>，建立了<strong>相似性和相关关系任务聚合模型</strong>，设计了<strong>解决多层任务网络图聚合的算法</strong>，解决了重复执行多个任务需要大量时间的问题.为了解决多卫星资源分配问题，我们提出了一种基于聚合任务网络图来优先分配关键任务资源请求的方法。我们还建立了<strong>多卫星多任务资源分配模型</strong>，并设计了算法对关键任务进行优先分配，解决了空间信息网络资源大量被占用和资源利用率低的问题。资源配置不合理。该论文突破了多任务聚合的关键技术难题，实现了空间信息网络中多卫星、多任务的高时效调度。本文通过从多个角度验证本文提出的MSRA-TAG方法的有效性，并将实验的性能与各种基线算法进行比较，验证了我们的想法的有效性和效率。 MSRA-TAG 在最大数据集 D6 上将 95 745.82 个亲属保存到原始任务中。此外，MSRA-TAG相对于其他算法分别节省了560 436.08、560 137.08和560 137.08。 MSRA-TAG方法在所有数据集上其任务和卫星数量较多的时间成本消耗负增长率最高为-30.37%，其他基线算法时间成本消耗数量增长率最高为147.38% . MSRA-TAG 对数据集 D1 的最高增长率为 10 019%，其他基线模型对 D1 的最高增长率为 9904%。因此，本文提出的方法MSRA-TAG具有更强的适应性，在空间信息网络中的多星、多任务场景下具有优异的性能。</p><p>未来，卫星信息网络必然向天地一体化网络发展。脱离地基基站的卫星自主任务规划或聚类方法研究必将成为普遍的研究趋势。纵观相关文献，目前的任务规划或聚类方法大多基于图论、强化学习或种群智能方法。然而，在未来几十年，任务规划方法将倾向于基于卫星之间自主协商的星上自主在线规划。因此，下一步将研究卫星间自主协作机制和星上任务在线规划策略，以实现卫星信息网络的智能化和自主化。同时，我们将更倾向于根据卫星网络的时变特性，研究具有高时间效率的多任务在线聚类方法。</p><p>论文关键：<strong>拥有相似属性</strong>的任务可以进行聚合，<strong>拥有数据依赖</strong>的任务可以进行聚合，原子任务来自于大任务的分解</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作流调度 </tag>
            
            <tag> 任务网络图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode123.买卖股票的最佳时机III</title>
      <link href="/2023/04/27/leetcode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/"/>
      <url>/2023/04/27/leetcode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>这道题是需要我们计算在最多进行两次买卖的情况下，所能获得的最大利润。我们可以定义四个状态分别为：</p><ul><li><code>buy1</code>表示第一次买入时的最大收益；</li></ul><ul><li><code>sell1</code>表示第一次卖出时的最大收益；</li><li><code>buy2</code>表示第二次买入时的最大收益；</li><li><code>sell2</code>表示第二次卖出时的最大收益。</li></ul><p>对于这四个状态，我们可以使用动态规划算法进行求解。具体地，对于第i天的情况，我们有以下状态转移方程：</p><pre class="language-C++" data-language="C++"><code class="language-C++">buy1 &#x3D; max(buy1, -prices[i]);    &#x2F;&#x2F;第一次买入的最大收益，可以选择不进行或进行sell1 &#x3D; max(sell1, buy1 + prices[i]);  &#x2F;&#x2F;第一次卖出的最大收益，可以选择不进行或进行buy2 &#x3D; max(buy2, sell1 - prices[i]);  &#x2F;&#x2F;第二次买入的最大收益，可以选择不进行或进行sell2 &#x3D; max(sell2, buy2 + prices[i]); &#x2F;&#x2F;第二次卖出的最大收益，可以选择不进行或进行</code></pre><p>其中，<code>buy1</code>和<code>buy2</code>的更新都使用上一次买入的最大收益减去当前股票价格来更新，因为如果当前的股票价格越低，那么买入的收益也就越大。而对于<code>sell1</code>和<code>sell2</code>的更新则使用上一次的买入收益加上当前股票价格来更新，因为如果当前的股票价格越高，那么卖出的收益也就越大。</p><p>最后，我们的最大收益就是第二次卖出时的最大收益<code>sell2</code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int buy1 &#x3D; -prices[0], sell1 &#x3D; 0, buy2 &#x3D; -prices[0], sell2 &#x3D; 0;        for(int i &#x3D; 1; i &lt; prices.size(); i++)&#123;            &#x2F;&#x2F; 第一次买入的最大收益，可以选择不进行或进行            buy1 &#x3D; max(buy1, -prices[i]);            &#x2F;&#x2F; 第一次卖出的最大收益，可以选择不进行或进行            sell1 &#x3D; max(sell1, buy1 + prices[i]);            &#x2F;&#x2F; 第二次买入的最大收益，可以选择不进行或进行            buy2 &#x3D; max(buy2, sell1 - prices[i]);            &#x2F;&#x2F; 第二次卖出的最大收益，可以选择不进行或进行            sell2 &#x3D; max(sell2, buy2 + prices[i]);        &#125;        &#x2F;&#x2F; 返回第二次卖出时的最大收益        return sell2;    &#125;&#125;;</code></pre><p>时间复杂度：O(n)，其中n是股票的天数，只需要遍历一遍数组即可求解。</p><p>空间复杂度：O(1)，使用了常数个变量来存储状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1049.最后一块石头的重量II</title>
      <link href="/2023/04/26/leetcode1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/"/>
      <url>/2023/04/26/leetcode1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：stones &#x3D; [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：stones &#x3D; [31,26,33,21,40]输出：5</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道动态规划问题。我们可以定义一个 dp 数组，其中 dp[i] 表示背包容量为 i 时能够得到的最大价值。这里价值就是石头的重量。</p><p>具体来说，对于每一块石头，我们可以选择将其放入背包中，也可以不放入背包中。如果我们选择将其放入背包中，则可以得到的最大价值为 dp[j-stones[i]]+stones[i]，其中 j-stones[i] 表示剩余背包容量，dp[j-stones[i]] 表示剩余背包容量为 j-stones[i] 时能够得到的最大价值，stones[i] 表示当前石头的重量。</p><p>遍历完所有的石头后，dp[target] 就是能够得到的最大价值，其中 target 是所有石头重量之和的一半（因为我们要得到最终得到的石头的最小可能重量，因此需要将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值）。</p><p>最终得到的石头的重量就是 sum - 2*dp[target]，其中 sum 是所有石头的重量之和。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;        int sum &#x3D; accumulate(stones.begin(), stones.end(), 0); &#x2F;&#x2F; 计算所有石头重量之和        int target &#x3D; sum &#x2F; 2; &#x2F;&#x2F; 将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值        vector&lt;int&gt; dp(target+1, 0); &#x2F;&#x2F; 定义动态规划数组        for(int i&#x3D;0; i&lt;stones.size(); i++) &#123; &#x2F;&#x2F; 遍历每一块石头            for(int j&#x3D;target; j&gt;&#x3D;stones[i]; j--) &#123; &#x2F;&#x2F; 从后往前更新 dp 数组                dp[j] &#x3D; max(dp[j], dp[j-stones[i]]+stones[i]); &#x2F;&#x2F; 更新 dp 数组            &#125;        &#125;        return sum - 2*dp[target]; &#x2F;&#x2F; 返回最终得到的石头的重量    &#125;&#125;;</code></pre><p>在上面的代码中，我们首先使用<code>std::accumulate</code>库函数对石头的重量进行求和，得到所有石头的总重量<code>sum</code>。接着，我们将原问题转化为求解容量为<code>sum/2</code>的背包能够得到的最大价值，因此定义了一个<code>target</code>变量来保存这个值。</p><p>然后，我们定义了一个长度为<code>target+1</code>的<code>dp</code>数组，其中<code>dp[i]</code>表示背包容量为<code>i</code>时能够得到的最大价值。这个数组的初始化值都是0。</p><p>接下来，我们遍历每一块石头，并对每一块石头进行背包问题的动态规划更新。具体来说，对于第<code>i</code>块石头，我们从<code>target</code>向<code>stones[i]</code>遍历，更新所有<code>dp[j]</code>（<code>j&gt;=stones[i]</code>）。更新公式为<code>dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</code></p><p>这里<code>dp[j-stones[i]]</code>表示在放入第<code>i</code>块石头前剩余的背包容量，因此需要从<code>dp[j-stones[i]]</code>中加上当前石头的重量<code>stones[i]</code>才能得到在放入第<code>i</code>块石头后的最大价值。最后，我们返回最终得到的石头的重量，即<code>sum-2*dp[target]</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode416.分割等和子集</title>
      <link href="/2023/04/25/leetcode416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
      <url>/2023/04/25/leetcode416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p> <span id="more"></span><p>示例 1：</p><p>输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这个解法使用了动态规划。具体来说，我们首先计算数组中所有数字的总和。如果总和是奇数，那么无法分成等和子集，直接返回 false。否则，我们就要找到一个子集，使得它的和等于总和的一半，也就是说，我们要在数组中选择一些数字，使得它们的和等于 target。</p><p>我们使用 dp 数组来记录 target 是否可以被分成等和子集。dp[i] 表示 target 为 i 时的情况，dp[i] &#x3D; true 表示 target 可以被分成等和子集，否则为 false。</p><p>对于每一个数字 num，我们遍历 dp 数组的范围是 [target, num]，并且更新状态。具体来说，如果 dp[i - num] 为 true，那么 dp[i] 也为 true，因为我们可以在 dp[i - num] 的基础上加上 num 得到 dp[i]。最后，我们返回 dp[target]，判断是否可以分成等和子集。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int sum &#x3D; 0;        for (int num : nums) &#123;            sum +&#x3D; num;        &#125;        if (sum % 2 !&#x3D; 0) &#123;  &#x2F;&#x2F; 如果总和是奇数，无法分成等和子集            return false;        &#125;        int target &#x3D; sum &#x2F; 2;        vector&lt;bool&gt; dp(target + 1, false);  &#x2F;&#x2F; 创建一个长度为target+1的vector        dp[0] &#x3D; true;  &#x2F;&#x2F; target为0的情况是可以满足的        for (int num : nums) &#123;            for (int i &#x3D; target; i &gt;&#x3D; num; i--) &#123;  &#x2F;&#x2F; 遍历可选数字的范围是[target, num]                dp[i] &#x3D; dp[i] || dp[i - num];  &#x2F;&#x2F; 状态转移方程            &#125;        &#125;        return dp[target];  &#x2F;&#x2F; 返回target是否可以被分成等和子集    &#125;&#125;;</code></pre><blockquote><p><code> dp[i] = dp[i] || dp[i - num];</code>是一个状态转移方程，表示当前状态 dp[i] 是否可以被满足。dp[i] 初始值为 false，如果 dp[i - num] 为 true，也就是说前面已经找到了一组数字使得它们的和等于 i - num，那么我们只需要在这个基础上再加上 num，就可以得到一组数字使得它们的和等于 i，于是我们可以将 dp[i] 设置为 true。</p><p>这里使用了逻辑或运算符（<code>||</code>），如果 dp[i] 本来就是 true，那么 dp[i] 的值不会改变，因为或运算符的两个操作数有一个为 true，结果就是 true。如果 dp[i - num] 为 false，那么 dp[i] 仍然是 false。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WorkflowSim：用于在分布式环境中模拟科学工作流程的工具包</title>
      <link href="/2023/04/24/WorkflowSim%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%A8%A1%E6%8B%9F%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
      <url>/2023/04/24/WorkflowSim%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%A8%A1%E6%8B%9F%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments"><a href="#WorkflowSim-A-Toolkit-for-Simulating-Scientific-Workflows-in-Distributed-Environments" class="headerlink" title="WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments"></a>WorkflowSim: A Toolkit for Simulating Scientific Workflows in Distributed Environments</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>现有的工作流模拟器无法提供一个考虑异构系统开销和失败的框架，也缺少对广泛使用的工作流优化技术（如任务聚合）的支持。因此我们引入了WorkflowSim。在扩展CloudSim的基础上提供了更高层的工作流管理。我们还通过实验证明了忽视系统开销和故障会导致预测工作流时间的极大不准确。在两个研究领域中我们进一步验证了WorkflowSim在促进科学研究方面的价值。</p><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>首先介绍了科学工作流，然后说对于科学工作流工作的验证如果放在真实环境中验证有很多缺点，而基于模拟的验证有很多好处，比如降低实验步骤的复杂度并且通过在可重复和受控的环境中测试他们的应用程序，在工作流执行中节省了大量精力。</p><p>因此一个能够准确模拟的工作流调度模拟框架是非常需要的。易购分布式系统使开销也五花八门，考虑到全面的系统开销在工作流的运行时间中起到的重要作用，需要对这些工作流开销进行分类，这有助于提高模拟器的精确度（相较于不考虑开小的模拟器）。</p><p>此外，很多研究者已经强调了容错设计的重要性并认为现代分布式系统中的错误率不应该被忽视，我们需要一个支持随机以及分层故障的模拟器来促进相关方面的研究。</p><p>最后，工作流研究的进展还需要一个能够支持广泛接受的工作流特征和优化技术的通用框架。现有的模拟器，如 CloudSim&#x2F;GridSim[12] 无法提供细粒度的工作流模拟。</p><p>据我们所知，当前的分布式系统模拟器都不支持这些丰富的特性和技术。在本文中，我们介绍了我们在模拟满足这些要求的科学工作流程方面的早期工作。我们以任务聚类为例评估 WorkflowSim 的性能。我们进一步表明，WorkflowSim 有望为容错集群和开销鲁棒性研究等研究领域提供评估平台。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>在我们的设计中，我们在 CloudSim 现有的工作流调度层之上添加了多个层，包括 Workflow Mapper、Workflow Engine、Clustering Engine、Failure Generator、Failure Monitor 等。我们将解释这些层的细节在第三节。</p><p>CloudSim只支持单工作流，并没有考虑工作流的任务依赖关系，也没有对故障和开销进行分析。WorkflowSim 扩展了 CloudSim 以满足这些新要求。</p><p>其他模拟器是专门为工作流管理的一些理想方面（例如工作流调度）而设计的，但这种简化与不断变化的分布式计算世界和新工作流管理技术的发展不匹配。</p><p>因此，与其针对特定领域的工作流进行模拟，WorkflowSim 试图提取各种工作流系统公开的共同特征，并支持广泛使用的工作流管理技术。WorkflowSim 不仅支持调度技术的评估，还考虑了各种任务调度&#x2F;执行开销和故障。</p><p>在任务聚合方面，论文的聚合策略是静态的并且没有考虑动态的资源特征，他也没考虑到一些开销，这些开销包含在我们的模型中，其值是根据实际执行轨迹估算的。</p><p>故障分析和建模呈现系统特征，例如错误和故障分布以及危险率。在所有故障中，我们重点关注暂时性故障，因为预计它们比永久性故障更普遍。基于这些工作，我们模拟了两层（任务&#x2F;工作）的故障，并为用户提供了一个接口开发容错算法</p><h3 id="Models-and-Features"><a href="#Models-and-Features" class="headerlink" title="Models and Features"></a>Models and Features</h3><p>如图 1 所示，准备和执行工作流涉及多个组件层。工作流管理系统 (WMS) 的模型类似于 Pegasus WMS [17]，它包含： 一个工作流映射器，用于将抽象工作流映射到依赖于执行站点的具体工作流；一个工作流引擎来处理数据依赖；和一个工作流调度程序，用于将作业与资源相匹配。其他组件包括将小任务合并到大作业中的集群引擎、跟踪任务&#x2F;作业执行历史的 Provenance 收集器以及将用户工作流划分为多个子工作流的工作流分区器。</p><p><img src="http://cdn.leafii.top/img/image-20230424175929354.png" alt="image-20230424175929354" loading="lazy"></p><h4 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h4><h5 id="Workflow-Mapper"><a href="#Workflow-Mapper" class="headerlink" title="Workflow Mapper"></a>Workflow Mapper</h5><p>我们将工作流建模为有向无环图 (DAG)，其中作业代表用户要执行的计算，有向边代表作业之间的数据或控制流依赖关系.Workflow Mapper 用于导入 XML 格式的 DAG 文件和文件大小等其他元数据信息。Workflow Mapper 创建任务列表并将这些任务分配给执行站点。任务是用户想要执行的程序&#x2F;活动。</p><h5 id="Clustering-Engine"><a href="#Clustering-Engine" class="headerlink" title="Clustering Engine"></a>Clustering Engine</h5><p>我们将任务定义为用户想要执行的程序。 作业是执行系统看到的一个原子单元，它包含多个顺序或并行执行的任务。Clustering Engine将任务合并到作业中，以减少调度开销。</p><p><img src="http://cdn.leafii.top/img/image-20230424180131785.png" alt="image-20230424180131785" loading="lazy"></p><h5 id="Workflow-Engine"><a href="#Workflow-Engine" class="headerlink" title="Workflow Engine"></a>Workflow Engine</h5><p>Workflow Engine根据作业的依赖关系管理作业，以确保只有在其所有父作业都成功完成后才能发布作业。Workflow Engine 只会向 Scheduler 释放空闲作业。我们使用 DAGMan作为工作流引擎。</p><h5 id="Workflow-Scheduler-and-Job-Execution"><a href="#Workflow-Scheduler-and-Job-Execution" class="headerlink" title="Workflow Scheduler and Job Execution"></a>Workflow Scheduler and Job Execution</h5><p>Workflow Scheduler 用于根据用户选择的标准（MaxMin [2]、MinMin [1] 和许多其他试探法）将作业与工作节点匹配。 CloudSim 已经支持静态调度算法，我们添加了对动态工作流算法的支持。WorkflowSim 依靠 CloudSim 提供准确可靠的作业级执行模型，例如分时模型和空间共享模型。但是WorkflowSim引入了不同层次的开销和故障，提高了仿真的准确性.</p><p>为了关联和协调这些层，我们采用了基于事件的方法，其中每个组件维护一个消息队列。图 3 显示了具有两个执行站点的简单配置，每个执行站点都有两个节点。</p><p><img src="http://cdn.leafii.top/img/image-20230424180421142.png" alt="image-20230424180421142" loading="lazy"></p><h4 id="Layered-Overhead"><a href="#Layered-Overhead" class="headerlink" title="Layered Overhead"></a>Layered Overhead</h4><p>基于我们之前对工作流开销的研究，我们将分层开销添加到工作流模拟中。我们将工作流开销分为以下五类。</p><ul><li>Workflow Engine Delay测量作业的最后一个父作业完成与作业提交到本地队列的时间之间的时间。Workflow Engine Delay反映了工作流引擎（在我们的例子中是 DAGMan）的效率。</li><li>Queue Delay定义为工作流引擎向本地队列提交作业与本地调度程序看到作业运行（可能在远程资源上）之间的时间。它反映了工作流调度程序（例如，Condor [19]）执行作业的效率以及执行作业的资源可用性。</li><li>Postscript Delay and Prescript Delay是在某些执行系统下执行作业前后执行轻量级脚本所花费的时间。Prescripts 通常用于创建作业执行目录。Postscript在作业的计算部分完成后检查作业的退出代码。</li><li>Data Transfer Delay当数据在节点之间传输时发生。它包括三种不同类型的过程：staging data in, cleaning up, and staging data out.</li><li>Clustering Delay衡量的是实际任务运行时间的总和与工作流调度程序看到的作业运行时间之间的差异</li></ul><p>我们指出有必要考虑开销的分配，而不是简单地在作业执行后添加一个恒定的延迟。我们以工作流引擎延迟为例来说明对开销进行适当建模的必要性。</p><p><img src="http://cdn.leafii.top/img/image-20230424180933926.png" alt="image-20230424180933926" loading="lazy"></p><p>图 4 显示了 Montage 8 度工作流中开销和运行时间的真实轨迹（对于缩放问题，我们仅显示 mProjectPP 级别中的前 15 个作业）。我们可以看到，工作流引擎延迟在每五个作业后稳定增加。我们将这种工作流开销的特殊性称为循环递增。因此，在每次作业执行后简单地添加一个恒定的延迟忽略了它对性能的潜在影响。出于这个原因，我们采用基于消息队列的方法并迭代检查 WorkflowSim 中的消息队列。</p><p>图 6 显示了 mProjectPP、mDiffFit 和 mBackground 的 Clustering Delay 的平均值。很明显，随着k（每个水平级别的最大作业数）的增加，集群中的任务越来越少，因此每个作业的集群延迟减少。</p><p><img src="http://cdn.leafii.top/img/image-20230424201616337.png" alt="image-20230424201616337" loading="lazy"></p><p>根据等式1，<img src="http://cdn.leafii.top/img/image-20230424181348922.png" alt="image-20230424181348922" loading="lazy"></p><p>如果已知k&#x3D;j时的延迟，反比例模型可以直接估计k&#x3D;i时的延迟。因此，只要我们收集到一个聚类案例，我们就可以预测所有的聚类案例。</p><h4 id="Layered-Failures-and-Job-Retry"><a href="#Layered-Failures-and-Job-Retry" class="headerlink" title="Layered Failures and Job Retry"></a>Layered Failures and Job Retry</h4><p>在工作流执行期间的不同时间可能会发生故障。与任务和作业的定义一致，我们将瞬态故障分为两类：任务故障和作业故障。如果暂时性故障影响任务的计算（任务失败），作业中的其他任务不一定失败。如果暂时性故障影响集群作业（作业失败），则其所有任务都会失败。我们添加了两个组件来响应故障模拟：</p><ul><li>Failure Generator被引入以在每个执行站点注入任务&#x2F;作业失败。每个作业执行后，Failure Generator 根据用户指定的分布和平均失败率随机生成任务&#x2F;作业失败。</li><li>Failure Monitor收集故障记录并将它们返回给工作流管理系统，以便它可以动态调整调度策略。</li></ul><p>我们还修改了其他组件以支持容错优化。在容易出现故障的环境中，有多种方法可以提高工作流性能。</p><ol><li>当计算不成功时，可以简单地重试整个作业或仅重试该作业的失败部分。此功能被添加到 Workflow Scheduler，它检查作业的状态并根据用户选择的策略采取行动。</li><li>Reclustering是我们提出的一种技术，它试图根据检测到的故障率来调整任务聚类策略。</li></ol><h3 id="VALIDATION"><a href="#VALIDATION" class="headerlink" title="VALIDATION"></a>VALIDATION</h3><p>我们以任务聚类为例说明在工作流模拟中引入开销overheads的必要性。目标是比较工作流的模拟整体运行时间，以防作业运行时间和系统开销的信息已知并从先前的跟踪中提取。</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>在Application部分，作者介绍了如何使用WorkflowSim进行科学工作流研究。他们提到，WorkflowSim提供了一种灵活的框架，可以轻松地模拟各种科学工作流应用程序，并支持各种优化技术，例如任务聚类和容错性。 作者还列举了一些使用WorkflowSim进行研究的实际应用案例，包括生物信息学、气象预测、天文学和地震模拟等领域。他们指出，WorkflowSim可以帮助研究人员更好地理解和优化这些复杂的科学工作流应用程序，并提高其性能和效率。 </p><h3 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h3><p>在Conclusion and Future Work部分，作者总结了他们的研究成果，并提出了未来的研究方向。作者指出，WorkflowSim是一个可靠且有效的工作流仿真器，可以用于各种科学工作流应用程序中，并支持各种优化技术。 作者还提到，未来的研究方向包括进一步改进WorkflowSim的性能和功能，例如增加对容错性和动态资源管理的支持。此外，作者还计划将WorkflowSim扩展到更广泛的应用领域，并与其他工作流引擎进行比较。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 容错 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 工作流调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode119.杨辉三角II</title>
      <link href="/2023/04/24/leetcode119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/"/>
      <url>/2023/04/24/leetcode119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><span id="more"></span><p><img src="http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2-20230424132835008.gif" alt="img" loading="lazy"></p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: rowIndex &#x3D; 3输出: [1,3,3,1]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: rowIndex &#x3D; 0输出: [1]</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: rowIndex &#x3D; 1输出: [1,1]</code></pre><p><strong>提示:</strong></p><ul><li><code>0 &lt;= rowIndex &lt;= 33</code></li></ul><p><strong>进阶：</strong></p><p>你可以优化你的算法到 <code>*O*(*rowIndex*)</code> 空间复杂度吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>得到33行的所有结果，再按照要求返回对应的行的数组</li></ul><p>得到33行的结果的代码可以直接从leetcode118里复制粘贴，最后只需要修改一下return的值就行，需要返回的是result数组里需要的那一行的结果数组。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; getRow(int rowIndex) &#123;        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组        for (int i &#x3D; 0; i &lt; 34; i++) &#123; &#x2F;&#x2F; 按行进行遍历            &#x2F;&#x2F; i是当前行号            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行                     continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值                &#125;                else &#123;                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和                &#125;            &#125;            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组        &#125;        return results[rowIndex];&#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre><ul><li>空间复杂度优化</li></ul><p>本题要求生成杨辉三角的第 <code>rowIndex</code> 行，其中第 <code>i</code> 行有 <code>i+1</code> 个数，即第一行有 1 个数，第二行有 2 个数，第三行有 3 个数，以此类推。</p><p>因为杨辉三角的每一行只依赖于上一行的值，所以我们可以只存储上一行的值，不断地更新，直到得到第 <code>rowIndex</code> 行为止。</p><p>我们可以用一个一维数组来存储上一行的值，并不断地更新数组中的值，最终得到第 <code>rowIndex</code> 行的值。在更新的过程中，我们需要注意到数组的下标从 0 开始，而杨辉三角每一行的第一个数和最后一个数都是 1，所以我们需要在数组的第一个位置和最后一个位置都赋值为 1。</p><p>由于本题要求空间复杂度为 <code>O(rowIndex)</code>，因此我们不能开辟二维数组。在更新数组中的值时，我们需要用到上一行中前面的数和当前行中前面的数，因此我们需要用一个变量 <code>pre</code> 来存储上一行中前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。</p><p>时间复杂度为 <code>O(rowIndex^2)</code>，空间复杂度为 <code>O(rowIndex)</code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; getRow(int rowIndex) &#123;        vector&lt;int&gt; res(rowIndex + 1, 1);  &#x2F;&#x2F; 初始化结果数组为全 1        for (int i &#x3D; 2; i &lt;&#x3D; rowIndex; ++i) &#123;  &#x2F;&#x2F; 从第 2 行开始更新            int pre &#x3D; res[0];  &#x2F;&#x2F; 存储上一行前面的数            for (int j &#x3D; 1; j &lt; i; ++j) &#123;                int temp &#x3D; res[j];  &#x2F;&#x2F; 保存当前位置的值                res[j] +&#x3D; pre;  &#x2F;&#x2F; 更新当前位置的值                pre &#x3D; temp;  &#x2F;&#x2F; 更新 pre            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><p>在上述代码中，我们用 <code>res</code> 数组存储上一行的值，并初始化为全 1。然后从第 2 行开始更新，用变量 <code>pre</code> 存储上一行前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。最终返回更新后的结果数组即可。</p><p>由于题目要求返回的是第 <code>rowIndex</code> 行，因此数组的大小应该为 <code>rowIndex + 1</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode118.杨辉三角</title>
      <link href="/2023/04/23/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
      <url>/2023/04/23/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><span id="more"></span><p><img src="http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img" loading="lazy"></p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: numRows &#x3D; 5输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: numRows &#x3D; 1输出: [[1]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接模拟</li></ul><p>直接看代码吧 就是直接模拟：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组        for (int i &#x3D; 0; i &lt; numRows; i++) &#123; &#x2F;&#x2F; 按行进行遍历            &#x2F;&#x2F; i是当前行号            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行                     continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值                &#125;                else &#123;                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和                &#125;            &#125;            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组        &#125;        return results;&#x2F;&#x2F; 返回结果数组    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode224.基本计算器</title>
      <link href="/2023/04/19/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2023/04/19/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;1 + 1&quot;输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot; 2-1 + 2 &quot;输出：3</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li><li>‘+’ 不能用作一元运算(例如， “+1” 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</li><li>‘-‘ 可以用作一元运算(即 “-1” 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</li><li>输入中不存在两个连续的操作符</li><li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>题目要求实现一个计算器，计算一个字符串表达式的值。因为表达式中可能会存在括号，为了方便计算，可以使用递归的方法来实现。当遇到左括号时，递归调用自身来计算括号内的表达式值，当遇到右括号时，返回计算结果。当遇到加号或减号时，记录当前的操作符。当遇到数字时，记录当前的数值，并根据之前的操作符进行相应的计算。</p><p>具体步骤如下：</p><ol><li>定义一个辅助栈，用于存储之前的操作符和数字；</li><li>遍历表达式字符串，遇到数字时记录下来，遇到左括号时递归调用自身，遇到右括号时返回计算结果；</li><li>遇到加号或减号时，记录当前的操作符，遇到其他字符时忽略；</li><li>当遇到表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，并返回最终结果。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int calculate(string s) &#123;        stack&lt;int&gt; st;  &#x2F;&#x2F; 定义一个辅助栈，用于存储之前的操作符和数字        int num &#x3D; 0;  &#x2F;&#x2F; 用于记录当前的数值        int res &#x3D; 0;  &#x2F;&#x2F; 用于记录最终结果        int sign &#x3D; 1;  &#x2F;&#x2F; 用于记录当前的操作符，1表示加号，-1表示减号        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            if (isdigit(s[i])) &#123;  &#x2F;&#x2F; 如果当前字符是数字                num &#x3D; num * 10 + (s[i] - &#39;0&#39;);  &#x2F;&#x2F; 记录当前的数值            &#125; else if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;  &#x2F;&#x2F; 如果当前字符是左括号                int j &#x3D; i, cnt &#x3D; 0;                for (; i &lt; s.size(); i++) &#123;                    if (s[i] &#x3D;&#x3D; &#39;(&#39;) cnt++;                    if (s[i] &#x3D;&#x3D; &#39;)&#39;) cnt--;                    if (cnt &#x3D;&#x3D; 0) break;                &#125;                num &#x3D; calculate(s.substr(j + 1, i - j - 1));  &#x2F;&#x2F; 递归调用自身计算括号内的表达式值            &#125;            if (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;  &#x2F;&#x2F; 如果当前字符是加号或减号，或者已经遍历到表达式字符串的末尾                if (s[i] &#x3D;&#x3D; &#39;+&#39;) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中                    sign &#x3D; 1;  &#x2F;&#x2F; 更新操作符为加号                &#125; else if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中                    sign &#x3D; -1;  &#x2F;&#x2F; 更新操作符为减号                &#125; else if (s[i] &#x3D;&#x3D; &#39;)&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;                    st.push(sign * num);  &#x2F;&#x2F; 将最后一个数值乘上当前的操作符，并压入栈中                    int tmp &#x3D; 0;                    while (!st.empty()) &#123;  &#x2F;&#x2F; 从栈中取出数字和操作符进行计算，直到栈为空                        tmp +&#x3D; st.top();                        st.pop();                    &#125;                    res &#x3D; tmp;  &#x2F;&#x2F; 更新最终结果                &#125;                num &#x3D; 0;  &#x2F;&#x2F; 清空当前的数值            &#125;        &#125;        return res;  &#x2F;&#x2F; 返回最终结果    &#125;&#125;;</code></pre><blockquote><p>上述代码使用了一个栈来存储之前的数字和操作符，用于最后的计算。遇到左括号时，递归调用自身计算括号内的表达式值。遇到加号或减号时，记录当前的操作符和数字，当遇到右括号或表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，得到最终结果。</p></blockquote><p>需要注意的是，在遇到左括号时，需要找到对应的右括号位置，才能正确地计算括号内的表达式值。这里使用了一个变量cnt来记录遍历到的左括号数量和右括号数量的差值，当cnt为0时，说明找到了对应的右括号。</p><p>另外，需要注意的是，当遍历到表达式字符串的末尾时，也需要将之前记录的数字和操作符进行计算，得到最终结果。因此，在遍历完表达式字符串后，还需要进行一次栈中剩余数字和操作符的计算，以得到最终结果。</p><p>最后，需要注意对于操作数可能有多个位数的情况，需要在遍历字符串时将多位数字组合成一个完整的数值。这里使用了一个变量num来记录当前的数值，每次遍历到数字时，将其乘以10并加上当前位的数值即可。</p><p>综上所述，上述代码实现了一个简单的基本计算器，可以计算表达式中的加减法和括号，并返回最终结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WorkflowSim工作流仿真软件介绍+类的介绍+自创算法实现步骤</title>
      <link href="/2023/04/19/WorkflowSim%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D-%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D-%E8%87%AA%E5%88%9B%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/04/19/WorkflowSim%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D-%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D-%E8%87%AA%E5%88%9B%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Intorduction"><a href="#Intorduction" class="headerlink" title="Intorduction"></a>Intorduction</h2><p>现在的大数据应用都非常复杂，并不仅仅能够通过一个或者几个MapReduce任务来描述。更加复杂的描述大数据应用的是工作流 (workflow)。</p><p>WorkflowSim (<a href="http://www.workflowsim.org/)%E6%98%AF%E7%94%B1%E5%8D%97%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%A6">http://www.workflowsim.org/)是由南加州大学</a>(University of Southern California)的Weiwei Chen开发的一套开源工作流仿真软件。WorkflowSim是拓展自CloudSim的工作流仿真开源软件，可以提供工作流基础上的仿真，增加了模拟不同层次延时和故障的支持，与真实分布式环境更加接近。支持了各种task scheduling, clustering, resource provisioning的算法。广泛应用在故障容错研究，成本导向调度研究，资源调度研究，能耗研究等领域。</p><span id="more"></span><p>其工作原理是在暨有的CloudSim仿真软件基础上，提供workflow层次的仿真。工作流可以用有向图来描述(Directed Acyclic Graph) DAG，图的任何一个节点都是一个由用户制定执行的任务(task)，节点之间有通过数据输入输出形成的依赖关系(dependency)。工作流引擎会依据其依赖关系按顺序执行，同时执行也会调用用户所选择的调度算法，比如HEFT，MINMIN等等算法已经在WorkflowSim里边实现并且测试通过了。</p><p>用户也可以添加自己的调度算法。</p><p>在实际运行过程中，因为很多工作流非常大，甚至到达几千上万个任务，而通常我们只有几十个计算节点。这个时候就需要使用task clustering这个技术来聚合相类似的任务从而形成任务群(clustered job)，有时候也通用称之为job。每个job包含了多个task，然后提交给运行环境的时候是整体提交的，这样可以节省很多延迟(submission delay)，等到了某一个计算节点的时候再打开任务群然后分别执行。</p><p>如何形成job就需要各种算法，有包括了balanced task clustering可以综合考虑依赖关系的，也有fault tolerant clustering可以综合考虑规避failure的。这些也都已经在WorkflowSim里边实现。</p><p>其行为最为接近Pegasus工作流管理系统。</p><p>WorkflowSim是一套开源软件，所有源代码和介绍都可以在<a href="http://www.github.com/WorkflowSim/%E6%89%BE%E5%88%B0%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9B%AE%E5%89%8D%E6%B5%81%E8%A1%8C%E7%9A%84Git%E5%81%9A%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E3%80%82">http://www.github.com/WorkflowSim/找到，使用目前流行的Git做软件版本控制。</a></p><p>使用非常简单，下载完源代码之后，只需要在任何一个WorkflowSim example里边选择所需要的dax 文档，并且修改里边的daxPath变量，即可运行。比如选择:“examples&#x2F;org&#x2F;workflowsim&#x2F;examples&#x2F;WorkflowSimBasicExample1.java”这个例子，将里边的daxPath改成在你当前环境下的文件路径即可。</p><p>WorkflowSim在config&#x2F;dax文件夹下面已经提供了很多DAX文件可供仿真。这些工作流的介绍可以参考：Documentation – Pegasus WMS</p><p>同时我们还提供WorkflowGenerator可以生成你所需要的任何工作流DAX文件<a href="https://confluence.pegasus.isi.edu/display/pegasus/WorkflowGenerator">https://confluence.pegasus.isi.edu/display/pegasus/WorkflowGenerator</a></p><p>如果对WorkflowSim感兴趣并且想进一步开发功能，可建议（但不限于）研究以下方面</p><ol><li><p>基于价格的调度算法，CloudSim本身已经实现了每个task的cost，但是WorkflowSim还没有合适的调度算法。</p></li><li><p>动态资源调度算法。WorkflowSim目前还是静态的把计算节点建立好然后运行工作流。</p></li><li><p>多数据中心支持。目前只测试了单数据中心支持。</p></li><li><p>数据日志支持。将已有的工作流管理系统的log转换成为trace从而可以在WorkflowSim里边仿真？目前只测试过Pegasus。</p></li><li><p>可靠的调度算法，在仿真Failure的情况下调度算法应该如何变得更鲁棒？目前failure的生成已经开发完成，但是相应的算法还没有。</p></li><li><p>自适应算法或者分布式算法。目前仅有一个中心调度算法，分布式算法也可以在WorkflowSim上面实现。</p></li><li><p>基于duplication的算法。在计算节点有余的时候，可以自动复制一部分任务到空闲的计算节点上。</p></li></ol><h3 id="WorkflowSim中调度算法与规划算法的区别"><a href="#WorkflowSim中调度算法与规划算法的区别" class="headerlink" title="WorkflowSim中调度算法与规划算法的区别"></a>WorkflowSim中调度算法与规划算法的区别</h3><p>WorkflowSim中有两种类型的算法：调度算法（Scheduling Algorithm）和计划算法（Planning Algorithm）。理论上它们是相同的，但是在实现方面它们是完全不同的。WorkflowSim 具有三层：Workflow Planner、Workflow Engine、Workflow Scheduler。</p><p>在 Workflow Planner 中，我们拥有整个工作流（所有任务及其依赖项）的全局视图，并且在每次迭代中，Workflow Engine 将free的任务（这意味着它们的父级已成功完成）发布到 Workflow Scheduler。Workflow Scheduler 将这些free的任务与资源（WorkflowSim 中的 Condor VM）进行匹配，并提交它们以供执行。分别来说，规划算法是一种全局调度算法，可以将任何任务绑定到任何资源（但实际执行顺序取决于资源可用性）。WorkflowSim 中的调度算法是一种本地调度算法，它只将空闲任务绑定到可用资源（并以某种方式保证它们的执行顺序）。</p><p>默认情况下，未设置规划算法。如果您已指定规划算法，则调度算法将被禁用，因为指定的规划算法强制工作流调度程序将任务映射到其分配的资源。</p><p>一些局部优化算法如MIN-MIN、MAX-MIN是调度算法，而一些全局优化算法如HEFT是WorkflowSim中的规划算法</p><h3 id="SHARED和LOCAL文件系统之间的区别"><a href="#SHARED和LOCAL文件系统之间的区别" class="headerlink" title="SHARED和LOCAL文件系统之间的区别"></a>SHARED和LOCAL文件系统之间的区别</h3><p>SHARED文件系统只有一个用于一个数据中心的存储空间，而LOCAL文件系统也有一个用于每个VM的本地文件系统。</p><p>对于 stage-in，在 SHARED 模式下，我们在stage-in作业开始时将所有的输入文件移动到共享存储中。在 LOCAL 模式下，我们将每个任务的输入文件从最近的 VM（因为 VM 也具有本地文件系统）或共享文件系统（如果该任务分配到的 VM 可用）移动。</p><p>对于数据传输成本，在 SHARED 模式下，数据传输成本已经计入任务执行时间，因此我们不计算每个作业的数据传输成本。但我们计算了初始阶段工作的成本。在 LOCAL 模式下，增加每个作业的数据传输成本。</p><p>为什么我们需要区分它们？在实践中，我们要么拥有一个共享文件系统，例如 NFS，要么拥有一个分布式系统，例如 HDFS。如果您有一些数据感知算法来提高数据局部性，则需要使用 LOCAL。否则，如果您的算法不考虑数据，您可以使用 SHARED fs 来简化建模。</p><h3 id="Task-和-Job-之间的区别（以及任务集群）"><a href="#Task-和-Job-之间的区别（以及任务集群）" class="headerlink" title="Task 和 Job 之间的区别（以及任务集群）"></a>Task 和 Job 之间的区别（以及任务集群）</h3><p>尽管在某些情况下我们可以互换使用Task和Job，但它们是完全不同的。任Task是用户指定运行的程序。它对应于 DAX 中的“job”，因为 DAX 是由用户创建的。WorkflowSim 中的Job是包含一个或多个Task的单个执行单元。但是，WorkflowSim 中的Job本身是从Task延伸扩展的，目的是简化一些代码。</p><p>任务聚类是一种将多个Task合并为一个Job的优化方法。根据不同的优化目的，我们最终可能会得到容错集群（最小化故障影响）、平衡任务集群（平衡数据传输成本和通信成本）等。</p><p>为什么任务集群即使它失去了一些并行性，也可以减少makespan？</p><p>任务集群只能在资源争用的情况下工作，这意味着我们没有足够的资源，必须将任务合并到任务中。例如，Montage工作流在每个级别最多可以有10,000个任务，而通常在一个小型数据集群中有20个节点。通过将这些任务合并为20或40个作业，我们仍然可以充分利用资源并提高整体运行时间。另一个重要问题是开销，作业提交、作业执行、作业准备都具有在现代分布式系统中非常重要的开销。单独执行10,000个任务最终可能会产生10,000倍的开销，而20个作业有20倍的开销。</p><p>有关任务聚类的好处的更多详细信息，请参阅任何任务聚类论文。</p><h3 id="如何在类中增加属性？"><a href="#如何在类中增加属性？" class="headerlink" title="如何在类中增加属性？"></a>如何在类中增加属性？</h3><p>如果你有一个新的属性要在WorkflowSim中使用，并且想要在配置文件中配置它，可以进行下面的几个步骤:</p><ol><li>假设我们想要添加一个工作流的截止日期，并且它是一个很长的变量。在org.workflowsim.utils.Parameters.java中，添加:</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> deadline<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">long</span> dl<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">//other parameters</span> deadline <span class="token operator">=</span> dl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> deadline<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><blockquote><p><em>因为<strong>Parameters</strong>是一个静态对象，通过这种方式，我们可以在任何地方访问<strong>deadline</strong>。</em></p></blockquote><ol start="2"><li><p><em>在<strong>org.workflowsim.utils.ArgumentParser.java</strong>中添加解析</em></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArgumentParser</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//other parameter parsing</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"deadline"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> deadline <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token class-name">Parameters</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> deadline<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre></li></ol><blockquote><p><em>这意味着我们在解析配置文件时设置了参数的截止日期。</em></p></blockquote><ol start="3"><li><em>在<strong>config.txt</strong>中添加截止日期</em></li></ol><p>在<em>config.txt**文件中添加：</em></p><pre class="language-java" data-language="java"><code class="language-java">deadline <span class="token operator">=</span> <span class="token number">10000</span></code></pre><ol start="4"><li><em>然后你可以在你的调度程序中得到截止日期，比如在<strong>RandomPlanner.java</strong>中：</em></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> deadline <span class="token operator">=</span> <span class="token class-name">Parameters</span><span class="token punctuation">.</span><span class="token function">getDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="类的介绍"><a href="#类的介绍" class="headerlink" title="类的介绍"></a>类的介绍</h2><h3 id="Cloudlet"><a href="#Cloudlet" class="headerlink" title="Cloudlet"></a>Cloudlet</h3><p>Cloudlet类对托管在云数据中心的容器中的应用程序进行建模。Cloudlet继承了CloudSim软件包中的功能。包括用户id，任务的大小，传入文件的大小。传出文件的大小，执行开始时间，完成时间和执行状态（CREATED，READY，QUEUED,CANCEL,PAUSED ,FAILED,SUCCESS和RESUMED等）等。详情见“sources\org\cloudbus\cloudsim\Cloudlet.java”。</p><p>Cloudlet类中包含一个静态内部类：Resource，它被用来跟踪Cloudlet在不同CloudResource中的移动。记录Cloudlet在一个CloudResource中的提交时间、等待时间、时间运行时间、成本等信息。</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Task类是CloudSim中Cloudlet类的一个扩展。它支持实现任务之间的依赖关系，其中包括一组父任务和一组其子任务。在WorkflowSim中，当所有的父任务都成功完成时，工作流引擎确保任务被释放到调度器(准备运行)。</p><p>相比Cloudlet类，Task新增了parentList，childList，taskFinishTime等属性。其中增加taskFinishTime是因为cloudlet不允许WorkflowSim更新任务的finish time。Task类中的getProcessingCost()方法用来获取处理或执行此任务的总成本。原始的Processing Cost &#x3D; input data transfer + processing cost + output transfer cost</p><p>【可根据需要进行修改】。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job是Task的扩展。它基本上是一组任务。在WorkflowSim中，ClusteringEngine将任务合并为任务(任务组)，并且job的总体运行时间是task运行时间的总和。</p><h3 id="Vm"><a href="#Vm" class="headerlink" title="Vm"></a>Vm</h3><p>Vm 类对VM进行建模。虚拟机由主机管理和托管，它运行在一个主机内，与其他虚拟机共享hostList。VM的属性有内存，处理器及其存储大小。它根据CloudletScheduler定义的策略处理cloudlet。每个虚拟机都有一个所有者，由所有者将cloudlet提交给要执行的虚拟机。</p><h3 id="CondorVM"><a href="#CondorVM" class="headerlink" title="CondorVM"></a>CondorVM</h3><p>Condor Vm扩展一个Vm，不同的是它有一个本地存储系统和一个状态来指示它是否忙碌：VM_STATUS_IDLE or VM_STATUS_READY (not used in workflowsim) or VM_STATUS_BUSY。</p><h3 id="FileItem"><a href="#FileItem" class="headerlink" title="FileItem"></a>FileItem</h3><p>这是WorkflowSim中的一个文件实现。由于CloudSim已经实现了File，我们在这里称之为FileItem。WorkflowSim有一个不同的文件视图。案例1:在org.cloudsim.File中，文件大小是integer类型，而在我们的例子中，它应该是double类型，因为我们有很多大的文件。此外，我们希望精确地估计传输延迟。案例2:我们指定与CloudSim中不同的文件的类型FileType (NONE，输入INPUT，输出OUTPUT)。</p><p>FileItem类中的isRealInputFile()方法，用于判断文件是否为输入文件。输入文件对应有一个输出文件，它不需要在工作流中阶段加入，我们有一个规则，一个文件只写一次，并多次读取，因此，如果一个文件是一个输出文件，这意味着它是在这个作业中生成的，然后由同一作业(或者其他作业)中的另一个任务使用。</p><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>Parameters类包含用户可以在配置文件中指定的大多数参数。</p><p>类中定义了调度算法、规划算法、文件类型、成本模型等枚举类型，以及虚拟机个数、调度算法、规划算法、成本模型、最大深度等属性。</p><h3 id="Datacenter"><a href="#Datacenter" class="headerlink" title="Datacenter"></a>Datacenter</h3><p>DataCenter类代表数据中心，提供虚拟化的网格资源，处理虚拟机信息的查询，包含虚拟机对资源的分配策略。数据中心类是一个CloudResource，它的主机列表是虚拟化的。它处理VM查询(即VM处理)，而不是处理与cloudlet相关的查询。即使一个分配策略将被实例化(在超类的init()方法中)，它也不会被使用，因为cloudlets的处理由CloudletScheduler处理，虚拟机的处理由VmAllocationPolicy处理。</p><p>类中包含DatacenterCharacteristics属性，DatacenterCharacteristics表示资源的静态属性，如资源架构、操作系统(OS)、管理策略(时间或空间共享)、成本和资源配置中所处的时区。</p><h3 id="WorkflowDatacenter"><a href="#WorkflowDatacenter" class="headerlink" title="WorkflowDatacenter"></a>WorkflowDatacenter</h3><p>WorkflowDatacenter扩展了Datacenter，这样我们就可以使用CondorVM和其他组件。</p><p>类中包含processCloudletSubmit()方法，它处理Cloudlet提交。cloudlet实际可以被cast到org.workflowsim.Job 。</p><p>updateTaskExecTime()方法更新job中的task的执行时间与完成时间。</p><p>stageInFile2FileSystem()方法，将处于stage-in 阶段的job所需文件加入存储。对于本地文件系统(如condor-io)，将文件添加到本地存储；对于共享文件系统(如NFS)，需要向共享存储添加文件。</p><p>processDataStageInForComputeJob()方法，返回job执行所需的文件传输时间个执行时间。</p><h3 id="WorkflowParser"><a href="#WorkflowParser" class="headerlink" title="WorkflowParser"></a>WorkflowParser</h3><p>WorkflowParser将DAX解析为任务，以便WorkflowSim可以管理它们。</p><p>DAX的文件格式如下：</p><p><img src="http://cdn.leafii.top/img/1f7d9ac573959e92928a9529130d523c.png" alt="img" loading="lazy"></p><p>类中的parseXmlFile(String path)方法，根据参数DAX文件的地址path，将其转换为工作流。它遍历整个dax文件，将所有的<code>&lt;job&gt;&lt;/job&gt;</code>标签，转换为工作流中的任务task，其中id是该任务的唯一标识；runtime为该任务的长度；其内部的<code>&lt;uses&gt;&lt;/uses&gt;</code>标签代表该任务的文件。link属性表示文件的种类（input输入文件或output输出文件）；size属性代表该文件的大小；其中file属性代表该文件的名字。【任务A的output输出文件名file和大小size需要与其对应的任务B的input输入文件名和大小相同！】</p><p><code>&lt;child&gt;&lt;parent&gt;&lt;/parent&gt;&lt;/child&gt;</code>标签表示任务之间的依赖关系，即某一个子任务child的父任务parent有哪些。其中ref属性的值对应<code>&lt;job&gt;</code>标签中的id属性。parseXmlFile()方法根据这些依赖关系，设置工作流中的某一个任务的子任务与父任务及其深度。如果一个任务没有父任务，则将其设置为root。【root可能有多个！】</p><h3 id="SimEntity"><a href="#SimEntity" class="headerlink" title="SimEntity"></a>SimEntity</h3><p>该类表示一个模拟实体。实体可以处理事件，也可以发送事件给其他实体。当这个类被扩展时，有几个方法需要被实现:</p><p>①startEntity()：在模拟启动时，由Simulation类调用。这个方法负责启动实体。</p><p>② processEvent(SimEvent)：每当延迟队列中有需要由实体处理的事件时，仿真类就会调用processEvent(SimEvent)。</p><p>③ shutdownEntity()：在模拟结束之前，仿真调用shutdownEntity()。如果你想将数据保存在日志文件中，这个方法将放置相应的代码。</p><h3 id="WorkflowScheduler"><a href="#WorkflowScheduler" class="headerlink" title="WorkflowScheduler"></a>WorkflowScheduler</h3><p>WorkflowScheduler它隐藏了虚拟机管理，例如创建虚拟机、将任务交给虚拟机以及销毁虚拟机，并根据配置选择调度算法。</p><p>一个workflowScheduler代理中绑定一个workflowEngine，即其含有一个workflowEngineId属性，并通过bindSchedulerDatacenter(int datacenterId)方法将其与一个数据中心绑定。与此同时，为了保证每个任务仅提交一次，设置一个布尔类型的变量processCloudletSubmitHasShown来标记任务是否提交。除此之外，workflowScheduler代理根据不同的指令执行对应的事件，如下图：</p><p><img src="http://cdn.leafii.top/img/78b5a2e208681634869183a8c4c14a88.png" alt="img" loading="lazy"></p><h3 id="WorkflowEngine"><a href="#WorkflowEngine" class="headerlink" title="WorkflowEngine"></a>WorkflowEngine</h3><p>WorkflowEngine为代表用户的引擎。它隐藏了虚拟机管理，例如创建虚拟机、向虚拟机提交cloudlet和销毁虚拟机。由于WorkflowEngine类继承了SimEntity类，所以他重写了startEntity()、processEvent(SimEvent)、shutdownEntity()方法。一个workflowEngine引擎控制多个workflowScheduler代理。</p><p>hasJobListContainsID(List jobList, int id)方法：用来判断一个任务列表中是否存在某个任务。</p><p>submitJobs()方法：在提交获得的任务列表时，借助hasJobListContainsID(List jobList, int id)方法来判断某个要提交的任务的所有父任务是否已经全部执行完毕。</p><h3 id="WorkflowPlanner"><a href="#WorkflowPlanner" class="headerlink" title="WorkflowPlanner"></a>WorkflowPlanner</h3><p>WorkflowPlanner根据配置选择规划算法。他有一个ClusteringEngine属性，即一个workflowPlanner代理与一个clusteringEngine引擎绑定，并通过clusteringEngine引擎绑定到一个workflowEngine引擎中。【ClusteringEngine类是WorkflowSim的一个可选组件，它可以将多个任务合并成一个大任务，由于目前本人还没有使用到，所以暂不介绍~】</p><p>WorkflowPlanner类中的getPlanningAlgorithm(PlanningAlgorithm name)方法可以根据需要选择规划算法，<strong>一般我们在使用WorkflowSim创建自己个人的算法时，写的算法是PlanningAlgorithm类型的规划算法。</strong></p><p>workflowPlanner代理可以为任务添加影响因子，这对任务平衡的聚类算法很有用，我们可以根据研究需要，选择使用。方法为：processImpactFactors(List<Task> taskList) 与addImpact(Task task, double impact)。</p><h3 id="BaseSchedulingAlgorithm"><a href="#BaseSchedulingAlgorithm" class="headerlink" title="BaseSchedulingAlgorithm"></a>BaseSchedulingAlgorithm</h3><p>BaseSchedulingAlgorithm类继承了SchedulingAlgorithmInterface接口，它是一个基本调度器实现了基本功能。如：虚拟机的get与set，cloudlet类型的任务列表的get与set，以及主要的run()方法。其他调度方法应扩展自BaseSchedulingAlgorithm，但不应直接使用。</p><h3 id="BasePlanningAlgorithm"><a href="#BasePlanningAlgorithm" class="headerlink" title="BasePlanningAlgorithm"></a>BasePlanningAlgorithm</h3><p>BasePlanningAlgorithm类继承了PlanningAlgorithmInterface接口，它是一个基本规划器实现了基本功能。如：虚拟机的get与set，任务列表的get与set，以及主要的run()方法。其他调度方法应扩展自BasePlanningAlgorithm，但不应直接使用。</p><p>与BaseSchedulingAlgorithm<strong>不同</strong>，BasePlanningAlgorithm可以直接设置并获取Task类型的任务列表，并增加了数据中心列表DatacenterList的get与set。</p><p><strong>【我们使用WorkflowSim创建个人的算法时，需要继承BasePlanningAlgorithm类】。</strong></p><h3 id="WorkflowSimBasicExample1"><a href="#WorkflowSimBasicExample1" class="headerlink" title="WorkflowSimBasicExample1"></a>WorkflowSimBasicExample1</h3><p>由其名可知，这是一个基本的WorkflowSimExample，它创建了一个工作流规划器、一个工作流引擎、一个调度器、一个数据中心和20个虚拟机。【根据实际情况在使用时更改daxPath与其他参数】。它包含4个方法：main()方法，创建虚拟机的方法createVM()，创建数据中心的方法createDatacenter()，以及输出结果的方法printJobList()。</p><p>main()方法实现了：①初始化WorkflowSim包；②初始化Parameters参数；③初始化cloudsim包；④创建数据中心；⑤创建调度算法代理；⑥创建WorkflowEngine引擎；⑦创建工作流；⑧创建虚拟机；⑨执行调度算法，完成任务到虚拟机的映射；⑩启动仿真程序、打印仿真结果以及关闭仿真程序。</p><p>我们在写好了自己的算法后，为了实现他，则需要<strong>创建一个继承了WorkflowSimExample的example来运行算法。</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="如何创建并使用调度算法"><a href="#如何创建并使用调度算法" class="headerlink" title="如何创建并使用调度算法"></a>如何创建并使用调度算法</h3><p>当我们下载好WorkflowSim源码后，便可以实现一个自己的调度算法。具体步骤如下：</p><ol><li>在source&#x2F;org&#x2F;planning中写一个继承BasePlanningAlgorithm的Class，类名如RKPNPlanningAlgorithm,重写run()方法。【可参考HEFTPlanningAlgorithm算法】，如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/71c79ef2c2ba683cd3c80a7aa23f0dde.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/dcdd7c3c49b40442515f15fc3178b30c.png" alt="img" loading="lazy"></p><ol start="2"><li>算法写完之后，需要在WorkflowPlanner的getPlanningAlgorithm()方法中增加该算法，具体操作如下：</li></ol><p><img src="http://cdn.leafii.top/img/75501f37de1f5ed5c7679f28e655203b.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/b05b6fe6250db499ccefd05b43ec576d.png" alt="img" loading="lazy"></p><p>其中的case：RKPN中的RKPN是自定义的算法名的缩写。</p><ol start="3"><li>在参数类Parameters的枚举PlanningAlgorithm里面添加步骤2的case:RKPN，具体操作如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/b9ab51fe998664ccd21b63f0157c7230.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/f957d7ca93dbc563cf4f51141b28cb51.png" alt="img" loading="lazy"></p><ol start="4"><li>这样我们的一个调度算法就编写完了，如何使用呢？需要在”examples&#x2F;org&#x2F;workflowsim.examples&#x2F;planning”中创建一个example来实现它。具体操作如下：</li></ol><p><img src="http://cdn.leafii.top/img/4f4798e0f63054ec8c031c4a21274878.png" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/d2f07a1477cb395186d059fa898a3f89.png" alt="img" loading="lazy"></p><p>如图所示，在main()方法中需要根据自己的dax工作流文件的存放地址修改daxPath的值。【在“config&#x2F;dax”中也有许多可供使用的工作流文件~】</p><p><img src="http://cdn.leafii.top/img/80bc660ab00519661684d2be785cd0c0.png" alt="img" loading="lazy"></p><p>上图修改Parameters的规划算法参数，值为在步骤(3)中设置的参数</p><p>除此之外，我们也可以根据需要自行设置虚拟机的个数vmNum等其他参数。具体操作见代码。</p><ol start="5"><li>运行main()函数，即可在控制台获得工作流的运行结果。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文直接复制粘贴自：<a href="https://blog.csdn.net/LaraJean/article/details/123689433">https://blog.csdn.net/LaraJean/article/details/123689433</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 容错 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 工作流调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode486.预测赢家</title>
      <link href="/2023/04/19/leetcode486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"/>
      <url>/2023/04/19/leetcode486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p><p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 <code>0</code> 。每一回合，玩家从数组的任意一端取一个数字（即，<code>nums[0]</code> 或 <code>nums[nums.length - 1]</code>），取到的数字将会从数组中移除（数组长度减 <code>1</code> ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p><p>如果玩家 1 能成为赢家，返回 <code>true</code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 <code>true</code> 。你可以假设每个玩家的玩法都会使他的分数最大化。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,5,2]输出：false解释：一开始，玩家 1 可以从 1 和 2 中进行选择。如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。因此，玩家 1 永远不会成为赢家，返回 false 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,5,233,7]输出：true解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 107</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>首先，我们可以把这个问题看成是两个玩家在一堆石头上进行取石子游戏。每个玩家都可以在任何时候从石堆中取出一些石头，但是每次取石头的数量不能超过石堆中剩余石头的数量。游戏的规则是先手玩家必须先取，然后轮流取石头，直到石堆为空。每个石头的价值都不同，每个玩家在取石头时可以获得相应的价值。</p><p>我们可以用动态规划来解决这个问题。假设nums数组的长度为n，<code>dp[i][j]</code>表示在<code>nums[i...j]</code>范围内，先手玩家能获得的最大分数，那么先手玩家最终获胜的条件是<code>dp[0][n-1]</code>不小于nums中所有数之和的一半。</p><p>接下来考虑如何计算dp数组。首先，我们可以很容易地得出当区间长度为1时，<code>dp[i][i]</code>的值就是<code>nums[i]</code>。这是因为当只有一个数时，先手玩家必定获胜，得分为该数。</p><p>接下来，我们需要考虑更长的区间。假设当前处理的区间长度为len，则可以枚举区间左端点i，然后通过递推式来计算<code>dp[i][j]</code>。对于区间<code>[i,j]</code>，先手玩家可以选择<code>i</code>或<code>j</code>作为自己的选择，那么后手玩家就会在<code>[i+1, j]</code>或<code>[i, j-1]</code>区间内变成先手玩家。这样转化后的问题就可以通过<code>dp</code>数组的计算得到解决。</p><p>具体地，假设先手玩家选择了左端点i，那么后手玩家就会在<code>[i+1, j]</code>区间内变成先手玩家，此时先手玩家能获得的最大分数就是<code>nums[i]</code>加上区间<code>[i+2,j]</code>或区间<code>[i+1,j-1]</code>内先手玩家能获得的最大分数的最小值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">left &#x3D; nums[i] + min(dp[i+2][j], dp[i+1][j-1])</code></pre><p>同样地，假设先手玩家选择了右端点<code>j</code>，那么后手玩家就会在<code>[i, j-1]</code>区间内变成先手玩家，此时先手玩家能获得的最大分数就是<code>nums[j]</code>加上区间<code>[i,j-2]</code>或区间<code>[i+1,j-1]</code>内先手玩家能获得的最大分数的最小值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">right &#x3D; nums[j] + min(dp[i][j-2], dp[i+1][j-1])</code></pre><p>由于先手玩家和后手玩家的取石头顺序是交替进行的，因此先手玩家和后手玩家在不同的区间上作为先手玩家和后手玩家的情况应该分别考虑。最终，<code>dp[i][j]</code>的值就是left和right中的较大值，即：</p><pre class="language-C++" data-language="C++"><code class="language-C++">dp[i][j] &#x3D; max(left, right)</code></pre><p>最终的答案就是<code>dp[0][n-1]</code>是否大于等于<code>nums</code>中所有数之和的一半。</p><p>代码实现时，我们可以使用二维数组<code>dp</code>来保存先手玩家能获得的最大分数，然后用双重循环来枚举区间长度和区间左端点，并使用上述递推式来计算<code>dp</code>数组中的每个元素。最后，比较<code>dp[0][n-1]</code>和<code>nums</code>中所有数之和的一半即可得到答案。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); &#x2F;&#x2F; 定义二维dp数组，dp[i][j]表示当剩下的数是nums[i..j]时，先手玩家比后手玩家多得的最大分数。        &#x2F;&#x2F; 处理区间长度为1的情况        for (int i &#x3D; 0; i &lt; n; i++) &#123;            dp[i][i] &#x3D; nums[i]; &#x2F;&#x2F; 当剩下的数只有一个时，先手玩家只能取这个数，并且得分就是这个数本身。        &#125;        &#x2F;&#x2F; 处理更长的区间        for (int len &#x3D; 2; len &lt;&#x3D; n; len++) &#123; &#x2F;&#x2F; 枚举区间长度            for (int i &#x3D; 0; i &lt;&#x3D; n - len; i++) &#123; &#x2F;&#x2F; 枚举区间左端点                int j &#x3D; i + len - 1; &#x2F;&#x2F; 区间右端点                int left &#x3D; nums[i] + min(i+2 &lt;&#x3D; j ? dp[i+2][j] : 0, i+1 &lt;&#x3D; j-1 ? dp[i+1][j-1] : 0); &#x2F;&#x2F; 先手玩家取nums[i]后，后手玩家就成为了先手玩家，接下来剩下的数就是nums[i+1..j]，此时先手玩家能得到的最大分数是dp[i+1][j]。如果先手玩家取nums[i]后，后手玩家也取了一个数，那么接下来剩下的数就是nums[i+2..j]，此时先手玩家能得到的最大分数是dp[i+2][j]。由于后手玩家也是聪明的，他肯定会选择让先手玩家得到更少的分数，因此先手玩家能得到的最大分数就是nums[i]加上min(dp[i+2][j], dp[i+1][j-1])。同理，我们也可以计算出先手玩家取nums[j]时能得到的最大分数right。                int right &#x3D; nums[j] + min(i &lt;&#x3D; j-2 ? dp[i][j-2] : 0, i+1 &lt;&#x3D; j-1 ? dp[i+1][j-1] : 0);                dp[i][j] &#x3D; max(left, right); &#x2F;&#x2F; 取left和right的较大值，表示先手玩家在nums[i..j]这个区间内能得到的最大分数。            &#125;        &#125;        &#x2F;&#x2F; 判断先手玩家是否能获胜        return dp[0][n-1] &gt;&#x3D; accumulate(nums.begin(), nums.end(), 0) &#x2F; 2.0; &#x2F;&#x2F; 如果先手玩家能得到的最大分数不小于nums中所有数之和的一半，那么先手玩家就能获胜。    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1823.找出游戏的获胜者</title>
      <link href="/2023/04/18/leetcode1823-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/"/>
      <url>/2023/04/18/leetcode1823-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 <strong>顺时针顺序</strong> 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 <code>i</code> 名小伙伴顺时针移动一位会到达第 <code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code> ，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 <code>1</code> 名小伙伴的位置。</p><p>游戏遵循如下规则：</p><ol><li>从第 <code>1</code> 名小伙伴所在位置 <strong>开始</strong> 。</li><li>沿着顺时针方向数 <code>k</code> 名小伙伴，计数时需要 <strong>包含</strong> 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 <strong>顺时针下一位</strong> 小伙伴 <strong>开始</strong>，回到步骤 <code>2</code> 继续执行。</li><li>否则，圈子中最后一名小伙伴赢得游戏。</li></ol><p>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ic234-q2-ex11.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5, k &#x3D; 2输出：3解释：游戏运行步骤如下：1) 从小伙伴 1 开始。2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 6, k &#x3D; 5输出：1解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= n &lt;= 500</code></li></ul><p><strong>进阶：</strong>你能否使用线性时间复杂度和常数空间复杂度解决此问题？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>约瑟夫问题求解</li></ul><p>首先我们需要确定递推公式，假设上一轮淘汰的是第 m 个人，那么本轮淘汰的是第 $(m+k)% n$ 个人，所以我们可以得到递推公式：$f(n, k) &#x3D; (f(n-1, k)+k) % n$，其中$ f(n, k) $表示 n 个人中最后剩下的人的编号。</p><p>当只有一个人的时候，那么这个人一定是胜者，因此我们可以得到初始值：f(1, k) &#x3D; 0。</p><p>最后，我们可以通过递推得到 f(n, k) 的值，即为最后的胜者的编号。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findTheWinner(int n, int k) &#123;        int ans &#x3D; 0;  &#x2F;&#x2F; 最后胜者的编号        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;  &#x2F;&#x2F; 从第二个人开始进行游戏            ans &#x3D; (ans + k) % i;  &#x2F;&#x2F; 计算本轮淘汰的人的编号        &#125;        return ans + 1;  &#x2F;&#x2F; 将编号从 0-based 转换为 1-based 并返回    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode231.2的幂</title>
      <link href="/2023/04/17/leetcode231-2%E7%9A%84%E5%B9%82/"/>
      <url>/2023/04/17/leetcode231-2%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>x</code> 使得 $n &#x3D;&#x3D; 2^x$ ，则认为 <code>n</code> 是 2 的幂次方。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：true解释：20 &#x3D; 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 16输出：true解释：24 &#x3D; 16</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：false</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：true</code></pre><p><strong>示例 5：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：false</code></pre><p><strong>提示：</strong></p><ul><li>$-2{31} &lt;&#x3D; n &lt;&#x3D; 2^{31} - 1$</li></ul><p><strong>进阶：</strong>你能够不使用循环&#x2F;递归解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归</li></ol><p>直接递归就好，注意n为0的情况</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        if (n &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; 如果n为1 直接返回true        if (n % 2 !&#x3D; 0 || n &#x3D;&#x3D; 0) return false; &#x2F;&#x2F; 如果n无法被2除尽，或者n为0，则直接返回false        return isPowerOfTwo(n &#x2F; 2); &#x2F;&#x2F; 否则返回递归的调用函数后的返回值    &#125;&#125;;</code></pre><ol start="2"><li>循环</li></ol><p>直接循环就行，简单易懂</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        while (n &gt;&#x3D; 2) &#123;            if (n % 2 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 2;            else return false; &#x2F;&#x2F; 如果n无法被2除尽，则直接返回false        &#125;        if (n &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; 如果n为1 直接返回true        return false;    &#125;&#125;;</code></pre><ol start="3"><li>使用位与运算符和掩码</li></ol><p>在这个题里面只需要检测n为正数且n的二进制里面只有一个1存在即可;</p><p>首先，我们检查n是否为正整数，这可以通过检查n是否大于0来实现。然后，我们需要检查n的二进制表示中只有一个1。如果我们将n减去1，那么所有在原来的二进制表示中为1的位都会变成0，而它后面的所有位都会变成1。例如，如果n的二进制表示为10000，那么n-1的二进制表示为01111。如果我们将n和n-1进行位与运算，结果将为0。因为n的二进制表示中只有一个1，所以n-1的二进制表示中所有的1都位于n的二进制表示中的0的位置上，因此它们不会在位与运算中重叠。如果n的二进制表示中有多个1，则n-1的二进制表示中将有一个以上的1与n的二进制表示中的1重叠，这样位与运算的结果将不为0。</p><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        return ((n &gt; 0) &amp;&amp; (n &amp; (n - 1)) &#x3D;&#x3D; 0); &#x2F;&#x2F; 检查n是否为正数，且n的二进制表示只有一个1    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode342.4的幂</title>
      <link href="/2023/04/16/leetcode342-4%E7%9A%84%E5%B9%82/"/>
      <url>/2023/04/16/leetcode342-4%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 4 的幂次方需满足：存在整数 <code>x</code> 使得 $n &#x3D;&#x3D; 4^x$</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 16输出：true</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 5输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：true</code></pre><p><strong>提示：</strong></p><ul><li>$-2^{31} &lt;&#x3D; n &lt;&#x3D; 2^{31} - 1$</li></ul><p><strong>进阶：</strong>你能不使用循环或者递归来完成本题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>循环</li></ol><p>直接使用循环进行<code>n/=4</code>的操作,到最后n小于3时根据n是否为1来判断原本的n是否为4的幂次</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfFour(int n) &#123;        while(n &gt; 3) &#123;            if (n % 4 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 判断n是否是4的整倍数 （在n大于3的情况下）                n &#x2F;&#x3D; 4;            &#125;            else return false; &#x2F;&#x2F; 如果不是直接返回false        &#125;        if (n &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; &#x2F;&#x3D;操作结束后判断n是否为1 or n本来就为1的时候应该直接返回true        return false;    &#125;&#125;;</code></pre><ol start="2"><li>递归</li></ol><p>如题，直接递归就完事了</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfFour(int n) &#123;        if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 4) return true; &#x2F;&#x2F; 返回true的条件        else if (n &gt; 4) &#123;            if (n % 4 !&#x3D; 0) return false; &#x2F;&#x2F; 余数不为0 直接返回false            else return isPowerOfFour(n &#x2F; 4); &#x2F;&#x2F; 通过递归完成对n的更新        &#125;        return false;     &#125;&#125;;</code></pre><ol start="3"><li>使用位与运算符和掩码</li></ol><p>首先，我们需要检查n是否为正数，并且它的二进制表示中只有一个1。这是因为4的幂次方的二进制表示中只有一个1。因此，如果n不是正数或者它的二进制表示中有多个1，则它不是4的幂。</p><p>其次，我们需要使用位运算来检查n是否为4的幂。我们可以使用位与运算符（&amp;）和一个掩码来完成此操作。掩码是一个32位整数，它的二进制表示中只有偶数位为1，奇数位为0。如果n是4的幂，则它的二进制表示中的1只能在偶数位上出现。因此，如果我们将n与掩码进行位与运算，结果应该等于n本身。</p><p>最终，如果n既是正数且只有一个1，又是4的幂，则函数返回true；否则，返回false。</p><p>详细的说，当你看到一个整数n时，你需要确定它是否是4的幂次方。一个正整数n是4的幂次方，当且仅当它满足以下两个条件：</p><ol><li>n是正整数，并且它的二进制表示中只有一个1，例如1、4、16等；</li><li>n可以表示为$4^k$的形式，其中k是一个非负整数。</li></ol><p>因此，我们需要找到一种方法来检查n是否满足这两个条件。在不使用循环或递归的前提下，我们可以使用位运算来实现这个目标。</p><p>首先，我们检查n是否为正整数，这可以通过检查n是否大于0来实现。然后，我们需要检查n的二进制表示中只有一个1。如果我们将n减去1，那么所有在原来的二进制表示中为1的位都会变成0，而它后面的所有位都会变成1。例如，如果n的二进制表示为10000，那么n-1的二进制表示为01111。如果我们将n和n-1进行位与运算，结果将为0。因为n的二进制表示中只有一个1，所以n-1的二进制表示中所有的1都位于n的二进制表示中的0的位置上，因此它们不会在位与运算中重叠。如果n的二进制表示中有多个1，则n-1的二进制表示中将有一个以上的1与n的二进制表示中的1重叠，这样位与运算的结果将不为0。</p><p>接下来，我们需要使用位运算来检查n是否可以表示为4的幂。我们知道，4的幂的二进制表示中的1只能出现在偶数位上，例如100、10000、1000000等。因此，我们可以使用一个掩码来将所有奇数位上的位设置为0，而偶数位上的位设置为1。这个掩码可以是0x55555555，它的二进制表示为01010101010101010101010101010101。如果我们将n与这个掩码进行位与运算，结果将为n本身，如果n不能表示为4的幂，则结果将不为n本身。</p><p>最后，如果n既是正整数且只有一个1，又是4的幂，则函数返回true，否则返回false。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isPowerOfFour(int n) &#123;        &#x2F;&#x2F; 检查n是否为正数，且n的二进制表示只有一个1，且n是否为4的幂        return (n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) &#x3D;&#x3D; 0) &amp;&amp; ((n &amp; 0x55555555) &#x3D;&#x3D; n);     &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode72.编辑距离</title>
      <link href="/2023/04/13/leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
      <url>/2023/04/13/leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这道题要求我们找到从 word1 转换到 word2 所需要的最小操作数，其中每个操作都是插入、删除或替换一个字符。这道题可以使用动态规划来解决。我们可以定义一个 dp 数组，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数。</p><p>当 i &#x3D; 0 时，表示 word1 为空，这时要将 word1 转换为 word2 的前 j 个字符，所以最小操作数就是 j。同样地，当 j &#x3D; 0 时，表示 word2 为空，这时要将 word1 转换为空字符串，所以最小操作数就是 i。</p><p>对于任意的 i 和 j，有以下两种情况：</p><ol><li>当 <code>word1[i-1] == word2[j-1] </code>时，不需要进行任何操作，所以 <code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>当 <code>word1[i-1] != word2[j-1] </code>时，有三种操作可以选择，分别为：<ol><li>在 word1 的第 i 个字符后面插入一个和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i][j-1] + 1</code>。</li><li>删除 word1 的第 i 个字符，这样就可以让 word1 的前 i-1 个字符和 word2 的前 j 个字符相等。操作数为<code> dp[i-1][j] + 1</code>。</li><li>将 word1 的第 i 个字符替换成和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i-1][j-1] + 1</code>。</li></ol></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minDistance(string word1, string word2) &#123;        int m &#x3D; word1.size();  &#x2F;&#x2F; 获取 word1 的长度        int n &#x3D; word2.size();  &#x2F;&#x2F; 获取 word2 的长度        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1));  &#x2F;&#x2F; 定义一个二维数组 dp，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 当 word2 为空字符串时，需要将 word1 转换为空字符串，所以最小操作数为 i            dp[i][0] &#x3D; i;        &#125;        for (int j &#x3D; 0; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 当 word1 为空字符串时，需要将 word1 转换为 word2 的前 j 个字符，所以最小操作数为 j            dp[0][j] &#x3D; j;        &#125;        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 从 word1 的第一个字符开始遍历            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 从 word2 的第一个字符开始遍历                if (word1[i-1] &#x3D;&#x3D; word2[j-1]) &#123;  &#x2F;&#x2F; 如果 word1 的第 i 个字符和 word2 的第 j 个字符相等，不需要进行任何操作                    dp[i][j] &#x3D; dp[i-1][j-1];                &#125; else &#123;  &#x2F;&#x2F; 否则，有三种操作可以选择                    dp[i][j] &#x3D; min(dp[i][j-1], min(dp[i-1][j], dp[i-1][j-1])) + 1;  &#x2F;&#x2F; 分别为插入、删除和替换一个字符，选择操作数最小的那个                &#125;            &#125;        &#125;        return dp[m][n];  &#x2F;&#x2F; 返回最小操作数    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode63.不同路径II</title>
      <link href="/2023/04/12/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
      <url>/2023/04/12/leetcode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/robot1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/robot2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：obstacleGrid &#x3D; [[0,1],[0,0]]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道典型的动态规划问题。定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p><p>在定义dp数组时，需要特别注意：如果某个格子为障碍物，则不能通过该格子，路径数为0；如果第一列某个格子为障碍物，则其下方的所有格子均无法到达，路径数为0；如果第一行某个格子为障碍物，则其右方的所有格子均无法到达，路径数为0。</p><p>在状态转移方程中，如果某个格子为障碍物，则其路径数为0；否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p><p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int m &#x3D; obstacleGrid.size();        int n &#x3D; obstacleGrid[0].size();        &#x2F;&#x2F; 定义二维数组dp        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));        &#x2F;&#x2F; 初始化第一列        for (int i &#x3D; 0; i &lt; m; i++) &#123;            if (obstacleGrid[i][0] &#x3D;&#x3D; 1) &#123;                break;            &#125;            dp[i][0] &#x3D; 1;        &#125;        &#x2F;&#x2F; 初始化第一行        for (int j &#x3D; 0; j &lt; n; j++) &#123;            if (obstacleGrid[0][j] &#x3D;&#x3D; 1) &#123;                break;            &#125;            dp[0][j] &#x3D; 1;        &#125;        &#x2F;&#x2F; 对于其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和        for (int i &#x3D; 1; i &lt; m; i++) &#123;            for (int j &#x3D; 1; j &lt; n; j++) &#123;                if (obstacleGrid[i][j] &#x3D;&#x3D; 1) &#123;  &#x2F;&#x2F; 如果当前格子为障碍物，则不可到达，路径数为0                    dp[i][j] &#x3D; 0;                &#125; else &#123;  &#x2F;&#x2F; 否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达                    dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];                &#125;            &#125;        &#125;        &#x2F;&#x2F; 返回右下角格子的不同路径数目        return dp[m-1][n-1];    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode62.不同路径</title>
      <link href="/2023/04/12/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>/2023/04/12/leetcode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/robot_maze.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 7输出：28</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 7, n &#x3D; 3输出：28</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：m &#x3D; 3, n &#x3D; 3输出：6</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>这是一道比较典型的动态规划问题。我们定义一个二维数组<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p><p>根据题目要求，从第一行第一列出发只能向下或向右移动一步，因此<code>dp[0][j]</code>和<code>dp[i][0]</code>的值都为1。</p><p>对于其他的格子，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p><p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        &#x2F;&#x2F; 定义二维数组dp        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));        &#x2F;&#x2F; 对于除第一行第一列外的其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和        for (int i &#x3D; 1; i &lt; m; i++) &#123;            for (int j &#x3D; 1; j &lt; n; j++) &#123;                dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];            &#125;        &#125;        &#x2F;&#x2F; 返回右下角格子的不同路径数目        return dp[m-1][n-1];    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode746.使用最小花费爬楼梯</title>
      <link href="/2023/04/10/leetcode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2023/04/10/leetcode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：cost &#x3D; [10,15,20]输出：15解释：你将从下标为 1 的台阶开始。- 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：cost &#x3D; [1,100,1,1,1,100,1,1,100,1]输出：6解释：你将从下标为 0 的台阶开始。- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。- 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>动态规划</li></ul><p>因为上台阶可以一次1阶或者一次2阶，因此定义一个dp数组，长度为cost的大小+1，dp[i]表示到达第n个台阶需要的最小费用。因此<code>dp[i]</code>的更新公式为:</p><p>$dp[i] &#x3D; min(dp[i-1] + cost[i - 1], dp[i - 2] + cost[i - 2])$</p><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;        int len &#x3D; cost.size(); &#x2F;&#x2F; 获取cost的大小（总的台阶数）        vector&lt;int&gt; dp(len + 1); &#x2F;&#x2F; 定义一个dp数组，长度为cost的大小+1 dp[i]表示到达第n个台阶需要的最小费用。        dp[0] &#x3D; 0, dp[1] &#x3D; 0; &#x2F;&#x2F; 因为可以从下标为0或者1的台阶出发，因此dp[0]和dp[1]都初始化为0；        for (int i &#x3D; 2; i &lt; len + 1;i++) &#123;            dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); &#x2F;&#x2F; dp[i]的更新公式        &#125;        return dp[len]; &#x2F;&#x2F; 返回到达第n个台阶（也就是最后一个台阶）的最小费用。    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode509.斐波那契数</title>
      <link href="/2023/04/09/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
      <url>/2023/04/09/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre class="language-none"><code class="language-none">F(0) &#x3D; 0，F(1) &#x3D; 1F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</code></pre><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：1解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：2解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：3解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归求解</li></ol><p>在递归函数里初始化<code>f(0) = 0,f(1) = 1</code>,对于大于1的函数值，递归调用<code>f(n - 2) + f(n - 1)</code>;</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; f(0)的初始化        if (n &#x3D;&#x3D; 1) return 1; &#x2F;&#x2F; f(1)的初始化        return fib(n - 1) + fib(n - 2); &#x2F;&#x2F; 递归调用    &#125;&#125;;</code></pre><ol start="2"><li>迭代求解</li></ol><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        if (n &lt;&#x3D; 1) return n; &#x2F;&#x2F; 如果n为0或者1 直接返回它本身        int pre0 &#x3D; 0, pre1 &#x3D; 1; &#x2F;&#x2F; 初始化pre0和pre1        int answer &#x3D; 0; &#x2F;&#x2F; 初始化答案        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;            answer &#x3D; pre0 + pre1; &#x2F;&#x2F; 答案为f(n-2) + f(n-1)            pre0 &#x3D; pre1; &#x2F;&#x2F; pre0的值更新            pre1 &#x3D; answer; &#x2F;&#x2F; pre1的值更新        &#125;        return answer; &#x2F;&#x2F; 计算完毕返回答案    &#125;&#125;;</code></pre><ol start="3"><li>矩阵快速幂求解</li></ol><p>核心思路是将斐波那契数列的递推式转化为矩阵的乘法，然后使用矩阵快速幂的方法快速计算出矩阵的幂次，进而得到第 n 个斐波那契数。</p><p>首先，我们知道斐波那契数列的递推式为：</p><p>$F(n) &#x3D; F(n-1) + F(n-2)，其中 F(0) &#x3D; 0，F(1) &#x3D; 1。$</p><p>我们可以将这个递推式转化为矩阵的乘法形式：</p><p>$ \begin{bmatrix} F(n) \ F(n-1) \end{bmatrix} &#x3D; \begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} F(n-1) \ F(n-2) \end{bmatrix} $</p><p>根据这个式子，我们可以构造出初始矩阵 base 和单位矩阵 res，然后使用矩阵快速幂的方法快速计算出 base 的 n 次幂，最终得到 res。</p><p>最后，我们可以直接返回<code> res[0][1]</code>，这个值就是第 n 个斐波那契数。</p><p>总的来说，这种解法虽然比较高级，但可以在 O(log n) 的时间复杂度内计算出第 n 个斐波那契数，而且不需要使用数组或者递归来存储之前的结果，空间复杂度为 O(1)。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int fib(int n) &#123;        &#x2F;&#x2F; 如果n小于等于1，直接返回n        if (n &lt;&#x3D; 1) &#123;            return n;        &#125;        &#x2F;&#x2F; 定义初始矩阵        vector&lt;vector&lt;int&gt;&gt; base&#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;        &#x2F;&#x2F; 定义单位矩阵        vector&lt;vector&lt;int&gt;&gt; res&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;        &#x2F;&#x2F; 矩阵快速幂        while (n) &#123;            if (n &amp; 1) &#123;                res &#x3D; multiply(res, base);            &#125;            base &#x3D; multiply(base, base);            n &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 将变量 n 的二进制表示向右移动一位，并将移位后的结果赋值给 n。相当于n&#x2F;&#x3D;2        &#125;        &#x2F;&#x2F; 返回结果        return res[0][1];    &#125;    &#x2F;&#x2F; 定义矩阵乘法函数    vector&lt;vector&lt;int&gt;&gt; multiply(const vector&lt;vector&lt;int&gt;&gt;&amp; A, const vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123;        int m &#x3D; A.size(), n &#x3D; A[0].size(), l &#x3D; B[0].size();        vector&lt;vector&lt;int&gt;&gt; C(m, vector&lt;int&gt;(l));        for (int i &#x3D; 0; i &lt; m; ++i) &#123;            for (int j &#x3D; 0; j &lt; l; ++j) &#123;                for (int k &#x3D; 0; k &lt; n; ++k) &#123;                    C[i][j] +&#x3D; A[i][k] * B[k][j];                &#125;            &#125;        &#125;        return C;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯真题-青蛙过河</title>
      <link href="/2023/04/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
      <url>/2023/04/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里 的石头跳到对岸。</p><p>河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度, 每次小青蛙从一块石头起跳, 这块石头的高度就 会下降 1 , 当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的)。</p><p>小青蛙一共需要去学校上 $x$ 天课, 所以它需要往返 $2x$次。当小青蛙具有 一个跳跃能力 $y$ 时, 它能跳不超过 $y$的距离。</p><p>请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。</p><span id="more"></span><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含两个整数$n,x$, 分别表示河的宽度和小青蛙需要去学校 的天数。请注意$2x$ 才是实际过河的次数。</p><p>第二行包含 $n−1$ 个非负整数$H_1,H_2,⋯,H_{n−1}$, 其中 $H_i$&gt;0 表示在河中与小青蛙的家相距 $i$的地方有一块高度为 $H_i$ 的石头,$H_i&#x3D;0$ 表示这个位置没有石头。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行, 包含一个整数, 表示小青蛙需要的最低跳跃能力。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="language-txt" data-language="txt"><code class="language-txt">5 11 0 1 0</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="language-text" data-language="text"><code class="language-text">4</code></pre><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>由于只有两块高度为 1 的石头，所以往返只能各用一块。第 1 块石头和对岸的距离为 4，如果小青蛙的跳跃能力为 3 则无法满足要求。所以小青蛙最少需要 4 的跳跃能力。</p><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 30% 的评测用例, $n≤100$;</p><p>对于 60% 的评测用例, $n≤1000$;</p><p>对于所有评测用例, $1≤n≤10^5,1≤x≤10^9,1≤H_i≤10^4 $。</p><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 512M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>常规思路</li></ul><p>一只青蛙上x次课，来回走了2x次；相当于2x只青蛙上了一次课（只走一段）；每次踩石头它的高度都下降1，而且青蛙都能过河。所以可以先求前缀和之后二分法进行贪心的求解，代码的思路如下：</p><ol><li>定义数组的最大长度N，整型数字n,m，数组a用于接收输入，数组b用于计算前缀和;</li><li>得到n，m和数组a之后，定义数组<code>a[0] = a[n] = N</code>,然后进行计算前缀和的操作。例如前缀和<code>b[i]=x</code>的意思就是i之前的石头一共可以容纳x个青蛙跳过(我们一共需要2m)个;</li><li>进行二分+贪心操作，求出最小的跳跃能力值。</li><li>check函数用于计算在x的下标下，石头是否能让2m个青蛙通过。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int N &#x3D; 1e5 + 3;ll a[N],b[N];int n, m;bool check(int x) &#123;    for(int i &#x3D; 1; i + x - 1 &lt; n ;i++) &#123;        &#x2F;&#x2F; 只有一个的时候        if (b[i + x - 1] - b[i - 1] &lt; 2 * m) &#123;            &#x2F;&#x2F; 石块为0的情况            return false;        &#125;    &#125;    return true;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt; n; i++) &#123;        &#x2F;&#x2F; 循环到n-1        cin &gt;&gt; a[i];    &#125;    a[0] &#x3D; a[n] &#x3D; N;    for (int i &#x3D; 1; i &lt; n; i++) &#123;        &#x2F;&#x2F; 计算前缀和        b[i] &#x3D; b[i - 1] + a[i]; &#x2F;&#x2F; 我能让几只小青蛙在上面    &#125;    &#x2F;&#x2F; 贪心求y    int l &#x3D; 1, r &#x3D; N;    while (l &lt; r)&#123;        int mid &#x3D; (l + r) &#x2F; 2;        if (check(mid)) &#123; &#x2F;&#x2F; 石头足够青蛙分，继续贪心            r &#x3D; mid;        &#125;        else &#123; &#x2F;&#x2F; 石头不够青蛙分            l &#x3D; mid + 1;        &#125;    &#125;    cout &lt;&lt; l;    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯真题-回文日期</title>
      <link href="/2023/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F/"/>
      <url>/2023/04/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。</p><p>有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。</p><p>也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。</p><p>给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。</p><span id="more"></span><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入包含一个八位整数 <em>N</em>，表示日期。</p><p>对于所有评测用例，10000101≤N≤89991231，保证 N 是一个合法日期的 8 位数表示。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出两行，每行 1 个八位数。第一行表示下一个回文日期，第二行表示下一个 ABABBABA 型的回文日期。</p><p><strong>输入输出样例</strong></p><p><strong>示例</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">20200202</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">2021120221211212</code></pre><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>（1）定义每个月的天数</li><li>（2）计算年份</li><li>（3）计算月份</li><li>（4）计算第几天</li><li>（5）判断是不是闰年</li><li>（6）闰年二月天数为29</li><li>（7）非闰年二月天数为28</li><li>（8）判断是不是符合日期标准</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;bool isleap(int year)&#123;    return ((year%4&#x3D;&#x3D;0&amp;&amp;year%100!&#x3D;0)||year%400&#x3D;&#x3D;0); &#x2F;&#x2F; 判断是否是闰年&#125;bool legal(int n) &#x2F;&#x2F; 判断8位数是否是合规的日期&#123;    int year,month,day;    year&#x3D;n&#x2F;10000; &#x2F;&#x2F; 获取年月日的值    month&#x3D;(n%10000)&#x2F;100;    day&#x3D;n%100;    if(month&gt;12 || month&#x3D;&#x3D;0 || day&#x3D;&#x3D;0 || day&gt;31) &#x2F;&#x2F; 进行年月日的判断    return false;    if(month&#x3D;&#x3D;2) &#x2F;&#x2F; 2月针对闰年平年单独判断    &#123;        if(isleap(year)&#x3D;&#x3D;0&amp;&amp;day&gt;28)        return false;        if(isleap(year)&#x3D;&#x3D;1&amp;&amp;day&gt;29)        return false;    &#125;    if(month&#x3D;&#x3D;1||month&#x3D;&#x3D;3||month&#x3D;&#x3D;5||month&#x3D;&#x3D;7||month&#x3D;&#x3D;8||month&#x3D;&#x3D;10||month||12)    &#123;        if(day&gt;31)        return false;    &#125;    if(month&#x3D;&#x3D;4||month&#x3D;&#x3D;6||month&#x3D;&#x3D;9||month&#x3D;&#x3D;11)    &#123;        if(day&gt;30)        return false;    &#125;    return true;&#125;int main()&#123;    int n;    cin&gt;&gt;n; &#x2F;&#x2F; 获取输入    int flag&#x3D;0; &#x2F;&#x2F; 设置判断    for(int i&#x3D;n+1;i&lt;&#x3D;100000000;i++)    &#123;        int a1,a2,a3,a4,a5,a6,a7,a8; &#x2F;&#x2F; 用最笨的办法获取每一位的值        a8&#x3D;i&#x2F;10000000;        a7&#x3D;(i&#x2F;1000000)%10;        a6&#x3D;(i&#x2F;100000)%10;        a5&#x3D;(i&#x2F;10000)%10;        a4&#x3D;(i&#x2F;1000)%10;        a3&#x3D;(i&#x2F;100)%10;        a2&#x3D;(i&#x2F;10)%10;        a1&#x3D;i%10;        if(legal(i)&amp;&amp;flag&#x3D;&#x3D;0&amp;&amp;a1&#x3D;&#x3D;a8&amp;&amp;a2&#x3D;&#x3D;a7&amp;&amp;a3&#x3D;&#x3D;a6&amp;&amp;a4&#x3D;&#x3D;a5) &#x2F;&#x2F; 判断是否是普通回文日期        &#123;            cout&lt;&lt;i&lt;&lt;endl;            flag&#x3D;1;        &#125;        if(legal(i)&amp;&amp;a1&#x3D;&#x3D;a3&amp;&amp;a3&#x3D;&#x3D;a6&amp;&amp;a6&#x3D;&#x3D;a8&amp;&amp;a2&#x3D;&#x3D;a4&amp;&amp;a4&#x3D;&#x3D;a5&amp;&amp;a5&#x3D;&#x3D;a7) &#x2F;&#x2F; 判断是否是ABABBABA型回文日期        &#123;            cout&lt;&lt;i;            break;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种用于网格计算中作业调度的新型多智能体强化学习方法</title>
      <link href="/2023/04/04/%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97%E4%B8%AD%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B0%E5%9E%8B%E5%A4%9A%E4%BB%A3%E7%90%86%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2023/04/04/%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97%E4%B8%AD%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B0%E5%9E%8B%E5%A4%9A%E4%BB%A3%E7%90%86%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一种用于网格计算中作业调度的新型多智能体强化学习方法"><a href="#一种用于网格计算中作业调度的新型多智能体强化学习方法" class="headerlink" title="一种用于网格计算中作业调度的新型多智能体强化学习方法"></a>一种用于网格计算中作业调度的新型多智能体强化学习方法</h2><p>原标题：A novel multi-agent reinforcement learning approach for job scheduling in Grid computing</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>网格计算利用分布式异构资源来支持大规模或复杂的计算任务，合适的资源调度算法对于网格应用的成功至关重要。由于网格环境的复杂性和动态特性，传统的基于模型的方法在实践中可能会导致调度性能不佳。可扩展性和适应性是网格作业调度的主要目标之一。在本文中，针对作业调度问题，特别是在网格中实现负载平衡，提出了一种称为顺序共享学习 (OSL) 方法的新型多智能体强化学习方法。该方法通过使用有序的分布式学习策略规避了可扩展性问题，并基于有限通信的信息共享机制实现了多主体协调。仿真结果表明，OSL方法可以有效地达到负载均衡的目的，其性能在大多数情况下甚至可以与某些集中式调度算法相媲美。还说明了所提方法的收敛性和适应性。</p><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>主要介绍了网格计算的背景和作业调度问题，指出了传统的基于模型的方法在面对资源异构性、资源性能变化和应用程序多样性等方面存在的挑战。然后，介绍了强化学习在解决这些问题方面的优势，并提出了一种基于多智能体强化学习的作业调度方法。</p><p>在本文中，为了在大规模网格环境中实现基于学习的协调和泛化，提出了一种称为序数共享学习 (OSL) 方法的新型多智能体强化学习方法来解决网格计算的作业调度问题。在OSL方法中，基于序号信息共享机制设计了一种快速分布式学习算法。与以前用于作业调度的多智能体强化学习（MARL）方法相比，OSL 方法有两个方面的创新。一方面简化了作业调度中最优决策的建模，其中仅在线学习效用表来估计资源效率，而不是构建复杂的网格信息系统（GIS）。另一方面通过多智能体系统有限通信的有效信息共享机制规避了可扩展性和协调问题，其中有序共享策略使所有智能体共享它们的效用表并依次做出决策。在模拟的大规模网格计算环境中对所提出的方法进行了评估，结果表明了其有效性和可行性。</p><p>最后，简要介绍了本文的组织结构和贡献。</p><p><img src="http://cdn.leafii.top/img/image-20230404221510593.png" alt="image-20230404221510593" loading="lazy"></p><h3 id="Problem-statement"><a href="#Problem-statement" class="headerlink" title="Problem statement"></a>Problem statement</h3><h4 id="A-general-job-scheduling-model-in-Grids"><a href="#A-general-job-scheduling-model-in-Grids" class="headerlink" title="A general job scheduling model in Grids"></a>A general job scheduling model in Grids</h4><p>由于网格计算的NP-Complete特性和调度算法在网格场景中的最优性难以证明，现有的研究总是试图寻找次优解。为了描述网格计算的动态性，随机性以及异构性，研究了通用的 Gird 作业调度模型，如图2所示：</p><p><img src="http://cdn.leafii.top/img/image-20230404210909544.png" alt="image-20230404210909544" loading="lazy"></p><p>主要组件包括用户、调度程序和资源，其中不同的调度程序并行处理作业。他们负责从用户那里接收作业并将其分配给资源。与传统并行和分布式系统中的对应物不同，网格调度器通常不能直接控制资源，而是像代理体一样工作.每个调度器都可以向任何计算资源提交作业，并最终生成作业到资源的映射.在上述模型中，用户只是生产并向调度程序提交作业，他们的角色可以完全由作业创建者代替。工作到达或工作负荷的模型可以用泊松过程或其他基于概率的模型或自相关模型来描述.</p><p>在大型网格系统中，由于缺乏对资源的控制，资源更新周期长，调度器可用的资源信息存在时间延迟，可能不准确。因此，作业调度器的有限可观察性成为基于及时准确信息的作业调度算法的障碍，有必要开发更鲁棒和自适应的调度算法，这是本文的主要动机之一。</p><p>一般来说，Grids 中的分散作业调度问题可以建模为多智能体作业调度系统 [29]，表示为 6 元组$⟨G，R，P，D，C，SR⟩$，其中$G&#x3D;⟨g_1,…,g_N⟩$是一组智能体，$s &#x3D; {s_1,…,s_M}$是一组资源，$P:G\times N\rightarrow[0,1]$是作业提交函数,$D:G\times N \rightarrow \mathbb R$是概率作业大小函数,$C:G\times N \rightarrow \mathbb R$是概率容量函数，SR是作业调度规则。</p><p>为了专注于作业调度任务，上述模型进行了一些抽象，但保持了网格计算环境的主要特征，即动态的、大规模的用户和资源的异构性。尽管没有详细考虑实际实施的设计问题，例如网络拓扑，但图 2 中的模型<strong>足够通用</strong>，因为可以开发不同的代表性模型，包括随机作业提交函数、作业大小函数和容量函数，以描述网格工作负载的显着属性。利用网格工作负载的随机或自相关模型，可以研究处理网格作业调度问题的动态性、随机性和异构性的作业调度算法。</p><p>下面，为了便于讨论，假设所有的调度器都使用相同的调度算法，并且所有的作业只需要 CPU 资源，因此它们的持续时间 J 是唯一的。</p><h4 id="Performance-measures-for-job-scheduling-in-Grids"><a href="#Performance-measures-for-job-scheduling-in-Grids" class="headerlink" title="Performance measures for job scheduling in Grids"></a>Performance measures for job scheduling in Grids</h4><p>在上面的 Grid 调度模型中，资源执行分配的作业，并且它们的能力可能不同.每个资源都以其处理能力 C 为特征，它被定义为完成单位长度作业所需的 CPU 时间的倒数，即如果资源需要持续时间 t 来完成长度为 J &#x3D; 1 的单位作业，则其容量为$C &#x3D; 1&#x2F;t$。此外，假设队列中的所有作业都按到达时间排列优先级，因此在给定时间<strong>只有一个作业</strong>在资源上执行，而其他作业则在队列中等待。</p><p>网格作业调度中的常见性能度量是平均每个动作时间 (ATPT)。time-per-token (TPT) 是通过作业生成和完成之间经过的时间来衡量的，因此相应的平均标准，即 ATPT，可以制定如下：</p><p>$ATPT&#x3D;\frac{1}{L} \sum_{i&#x3D;1}^{L}TPT^i &#x3D; \frac{1}{L}\sum_{i&#x3D;1}^{L}(t_{wait}^i + t_{execute}^i)$</p><p>$TPT^i$是第i个作业的总耗时，它是队列等待时间$t_{wait}^i$（一个作业提交到开始执行的耗用时间）与实际执行时间$t_{execute}^i$之和，L表示所有资源完成的工作的总数。但是ATPT无法及时表征整个网格系统的调度性能，因为只有在作业完成后，才能更新此指标。如果资源中的作业队列很长，ATPT 的更新会严重延迟。最后，ATPT 的值仅仅反映了过去的作业调度效率，而不是当前的。</p><p>因此，使用了另一个有效的指标，即资源负载（LoR，或 makespan）。LoR定义为队列中作业的总长度$l_{total}$除以当前资源的容量$C_i$，系统的平均LoR（ALoR）可以<strong>完全代替</strong>平均每令牌时间。 ALoR 可以表示为：</p><p>$ALoR &#x3D; \frac{1}{M}\sum_{i&#x3D;1}^{M}LoR^i&#x3D;\frac{1}{M}\sum_{i&#x3D;1}^{M}(l_{total}^{i}&#x2F;C_i) \&#x3D;\frac{1}{M}\sum_{i&#x3D;1}^{M}(\sum_{j&#x3D;1}^{L^i}J_j^i&#x2F;C_i)$</p><p>其中 $LoR_i$ 是第 i 个资源的负载,$l^i_{total}$ 是队列中作业的总长度，它是所有排队作业长度$J_j^i$的总和,$L_i$ 是第 i 个资源队列中的作业数，$M$是资源数。新绩效指标的优点是显而易见的，因为它能够及时、全面地反映系统绩效。</p><p>作业调度算法的目标是最小化 ALoR 及其标准偏差。最小化上述两个量将确保整个系统的效率和公平性。除了上述两个指标外，资源中的最大 LoR 是反映瞬态性能的另一个指标。</p><h3 id="The-OSL-method-for-adaptive-job-scheduling"><a href="#The-OSL-method-for-adaptive-job-scheduling" class="headerlink" title="The OSL method for adaptive job scheduling"></a>The OSL method for adaptive job scheduling</h3><p>如上所述，在实际的大型网格应用中，即使有 GIS 系统的帮助，调度器中的资源信息也存在时间延迟并且可能不准确。因此，开发一种不依赖于精确模型的鲁棒调度算法是合理的。为了满足自适应作业调度的要求，协调的多智能体强化学习方法可能是一个合适的解决方案。在下文中，在对不同的 MARL 框架进行分析之后，提出了一种用于资源选择和作业调度的新型分散式 MARL 方法，其中多个智能体或调度程序之间的协作控制是通过顺序共享学习方法实现的。</p><h4 id="Basic-frameworks-for-multi-agent-reinforcement-learning"><a href="#Basic-frameworks-for-multi-agent-reinforcement-learning" class="headerlink" title="Basic frameworks for multi-agent reinforcement learning"></a>Basic frameworks for multi-agent reinforcement learning</h4><p>大多数单智能体 RL 算法都基于马尔可夫决策过程 (MDP) 的形式.然而，作为强化学习在分布式决策环境中的延伸，多智能体强化学习必须解决多个智能体共存打破环境平稳性的问题。到目前为止，许多 MARL 算法都是基于随机博弈 (SG) 模型 [33] 开发的，例如 JAL [34] 和 Team-Q 算法 [35]。然而，可扩展性差和信息利用效率低是MARL成功应用于大规模应用的两大障碍。对于图 2 中描述的作业调度问题，调度器和资源的数量非常多，因此，以前的MARL方法很难被采用。</p><p>除了SG模型，MARL的另一个框架是将单智能体强化学习技术直接扩展到多智能体系统，即让每个智能体根据局部状态和局部奖励独立学习，无需显式通信。这种技术在 MARL [34] 中称为独立学习器 (IL) 方法，并且在文献 [5,36,37] 中开发了一些 IL 算法。尽管 IL 的 MARL 方法不需要探索呈指数增长的联合状态-动作空间，但环境将不再是静止的，MARL 中将存在收敛问题和振荡行为。正如我们将在 4.1 节中说明的那样，如果在网格中的作业调度中使用没有协调和通信的 IL 方法，通常会出现羊群行为 [22]。</p><p>为了解决上述困难，多智能体强化学习的一种有前途的方法是通过信息共享和协调进行局部学习，以实现效率和最优性之间的平衡。基于这个想法，一种称为 OSL 算法的新 MARL 方法将在以下讨论中提出。</p><h4 id="The-OSL-algorithm-for-job-scheduling-in-Grids"><a href="#The-OSL-algorithm-for-job-scheduling-in-Grids" class="headerlink" title="The OSL algorithm for job scheduling in Grids"></a>The OSL algorithm for job scheduling in Grids</h4><p>为了克服 MARL 中的“维数灾难”问题，我们提出了具有降低的计算复杂性和改进的协调机制的 OSL 算法。新算法有两个主要特点。首先，它采用分布式 RL 框架并采用新颖的基于效用表的学习策略。由于 OSL 方法仅利用局部信息进行学习，因此它是一种基于独立学习者的 RL 方法。其次，它利用通信成本有限的信息共享机制来解决多主体协调问题。</p><p>OSL 的方案如图 3 所示。上面的循环表示共享实用程序表的调度程序。效用表仅随资源数量 M 线性增加，因此通信成本有限。下半部分详细表示调度程序智能体。每个调度器智能体主要包括两部分：Learner 和 Actor。 Learner 以有序的方式从前面的 agent 接收并共享效用表，并决定为 Job Buffer 中排队的作业选择资源。 Reward Converter 可以分析作业的完成信号并将其转换为奖励信号，这对于更新效用表至关重要。 Actor接收到新的job，并安排它们在Job Buffer中排队，然后根据Learner的决定将其提交到相应的资源中，并将提交记录在Submitted Job List中。最后，Actor 根据作业的完成情况更新 Submitted Job List，即如果一个作业完成了，那么它将从 Submitted Job List 中删除。</p><p><img src="http://cdn.leafii.top/img/image-20230404221455211.png" alt="image-20230404221455211" loading="lazy"></p><p>一般来说，OSL的实施需要考虑两个关键问题：</p><p>首先，虽然众所周知全局资源状态是调度器决策的基础，但由于调度器的观察和通信能力有限，很难在动态环境中获得所有调度器的准确信息。在本文中，提出了一种利用职位信息来估计状态的间接方法。调度器将提交作业的信息记录为向量$（n_r，t_s，t_e，J）$，即使用的资源名称$n_r$，作业开始时间$t_s$，作业完成时间$t_e$，作业大小$J$.然后，它抽象估计相应资源状态的信息。<strong>但是</strong>，如果调度程序从未向资源提交作业，则它对此一无所知。因此，这种来自个人经验的估计仅包含全局状态的部分信息。<strong>为提高估算精度，必须采取信息共享等有效手段。</strong></p><p>其次，很难直接获得学习的即时奖励。环境<strong>不能直接提供</strong>任何全局强化信号，而只能提供单个作业完成信号。因此调度器智能体必须将此类信息转换为奖励信息。事实上，由于其他调度器的存在，一个作业的time-per-token是由所有调度器的策略共同决定的。如何从上述信息中计算出合适的强化信号将是一个问题。更重要的是，当一个调度器等待其提交的作业的反馈时，网格环境可能会由于其他调度器的操作而发生变化，因此一个调度器只有在作业完成后才更新其效用表为时已晚。<strong>一种可能的解决方案</strong>是开发一种奖励机制，无论调度程序是否执行作业提交，都会在每个时间步创建奖励信息。</p><p>在下面的小节中，为了解决上述问题，将提出一种新颖的奖励生成机制和信息共享机制。</p><h5 id="The-decentralized-learning-strategy-using-utility-tables"><a href="#The-decentralized-learning-strategy-using-utility-tables" class="headerlink" title="The decentralized learning strategy using utility tables"></a>The decentralized learning strategy using utility tables</h5><p>在上述模型中，调度智能体被描述为 $G &#x3D; {g_1, g_2, . . . , g_N }$，其中每个调度智能体 gi 可以负责多个用户的作业调度。资源由$ S &#x3D; {s_1, s_2, . . . , S_M}$表示。类似于强盗问题 [24] 的学习方法，智能体 $g_i$ 保留一个效用表 $U_i$ 来对资源的效率进行评分，其中 $U^i{(j)}$ 表示第 j 个资源的效率，或者对从资源集 S，即 $j ∈ {1, 2, . . . , |S|} &#x3D; {1, 2, . . . , M}$中选择第 j 个资源的动作进行评分。调度程序 $g_i$的效用表如图 4 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230405092926308.png" alt="image-20230405092926308" loading="lazy"></p><p>对于去中心化学习过程中的每个时间步，agent $g_i$基于以下两个步骤执行资源选择操作和效用更新操作：</p><p>第1步：agent $g_i$检查判断是否有新的job到达。如果不是，转步骤2。如果是，重复执行步骤1，直到所有作业都被调度。 Agent $g_i$ 选择得分最高的资源 $s_j$，然后将作业提交给资源 $s_j$，并将其作为未完成的作业记录在已提交的作业列表中。如果执行第 j 个动作，则获得瞬时奖励 $r(j) &#x3D; −1$，同时更新该动作对应的效用 $U^i{(j)}$：</p><p>$U^i(j) &#x3D; (1 - \alpha) * U^i(j) + \alpha * r(j)$</p><p>其中的$\alpha$是学习率。</p><p>第 2 步：Agent $g_i$ 推进空闲调度进程并更新效用。如上所述，即使没有作业提交，也会为每个步骤设计一个瞬时奖励信号。Agent $g_i$ 根据提交的作业列表中的作业状态为每个动作创建强化信号，即：</p><p>$u(j) &#x3D;\left {<br>\begin{array}{c}<br>+1 \ \ \ only \ the \ job \ is \ finished \<br>0 \ \ \ no \ job \<br>-1 \ \ \ job\ is\ unfinished<br>\end{array}<br>\right. \ \ j \in {1,2,…,M}.$</p><p>如果多个作业被提交到同一个资源，每个作业都会有一个独立的强化信号。最后，可以通过将所有信号相加来计算<strong>相应动作的奖励</strong>：</p><p>$r(j)&#x3D;\sum_{k&#x3D;1}^{K^j}u(k)$</p><p>其中 $K^j$ 表示当前提交给第 j 个资源的作业数。例如，假设当前智能体向第一个资源提交了 3 个作业，并且在一个时间步之后，一个作业完成而另外两个作业未完成。所以选择第一个资源的瞬时奖励是：$r(1) &#x3D; 1 + 2 * (−1) &#x3D; −1$。当获得整个奖励向量$ (r(1), r(2), . . , r(N))$ 时，可以使用上面的等式更新每个资源的效用。</p><p>此时，agent $g_i$ 可以使用效用表 Ui 来估计所有资源的效率。例如，如果一个资源的队列很长或者资源的容量很差，调度器向它提交作业后，调度器必须等待很长时间才能收到资源的完成响应。因此，调度器获得奖励信号 −1 的次数要比获得奖励 +1 的次数多得多。最后，这种资源对应的效用价值会很小。显然，根据效用表，<strong>效用值越大，资源状态越好。</strong>连续更新操作及时反馈资源的工作状态，为分配连续作业做出可行的决策至关重要。</p><h5 id="Multi-agent-information-sharing-based-on-limited-communication"><a href="#Multi-agent-information-sharing-based-on-limited-communication" class="headerlink" title="Multi-agent information sharing based on limited communication"></a>Multi-agent information sharing based on limited communication</h5><p>在上面的小节中，建立了一个效用表来估计资源的效率。开发了一种改进的奖励和更新机制来指示资源的效率。然而，在网格应用程序中，有多个调度程序智能体。如果所有智能体都独立且同时学习和做出决策，则会出现协调问题。显然，调度器的任何决定都会改变资源的状态，但其他调度器在将作业提交到同一资源之前不会检测到更改（它们通过使用队列中的等待时间间接检测到这一点）。因此，特定智能体中的效用表不能准确指示资源的真实状态。此外，随着调度器数量的增加，可能的冲突将变得更加严重。因此，必须为网格作业调度问题中的分布式学习开发一种可行的协调机制。</p><p>由于每个智能体都拥有一个本地效用表来估计资源的效率，因此通过共享效用表来提高估计精度是一种自然的方式。但是，由于Grids中的scheduler agent数量非常多，不可能直接共享每个utility table。因此，本文提出了一种有限通信的序号共享机制来满足上述需求。智能体之间的协调是通过<strong>按顺序和迭代共享相邻智能体的效用表</strong>来实现的。如图4所示，效用表仅与资源规模成线性比例。因此智能体之间的总通信成本很低并且始终保持不变。</p><p>为了实现信息共享机制，通过将Agent排序 为$g_1，g_2，… . . , g_N$，为所有调度智能体定义了一个序数结构。 , 那么智能体共享它们的效用表并按顺序进行决策，即智能体 $g_i$ 共享前面智能体的效用信息如下：</p><p>$U^i(j) &#x3D; (1 - \beta) * U^i{j} + \beta * U^{i-1}(j)$</p><p>其中的$\beta$是共享因子。$U^{i-1}(j)$是相邻智能体$g_{i-1}$的效用表并且它包含了所有的之前的智能体对资源效用的估计。最终，最后一个agent的效用表返回给第一个agent再次共享。换句话说，效用共享过程是有序的和迭代的。</p><p>表 1 显示了网格作业调度中智能体 gi 的 OSL 算法的主要过程。</p><p><img src="http://cdn.leafii.top/img/image-20230405104508471.png" alt="image-20230405104508471" loading="lazy"></p><p>与其他MARL算法相比，OSL算法更适合在大规模作业调度应用中实现。作为一种基于效用表的学习方法，效用表函数中没有显式的状态变量，因此更适应资源和应用高度多样化和动态化的网格场景。此外，OSL 的另一个重要优势是协调的通信成本低。信息交换总量是简单效用表，其规模与资源数量成线性关系，远低于直接通信模式下的指数级。</p><h3 id="Performance-evaluation-and-discussions"><a href="#Performance-evaluation-and-discussions" class="headerlink" title="Performance evaluation and discussions"></a>Performance evaluation and discussions</h3><p>在本节中，将在模拟中评估和分析用于作业调度的基于 OSL 的选择 (OSLS) 规则的性能。此外，将所提出的 OSLS 方法与其他四种资源调度或选择规则进行了比较，它们是分散的最小-最小选择（DMMS）[38]、随机选择（RS）、最小负载选择（LLS）和简单学习选择（ SLS）[5]。 Min-Min算法是一种启发式调度方法，成为性能比较的基准调度算法[38]。基于分散的调度模型，每个调度器独立执行分散的Min-Min算法。即使有 GIS 系统的帮助，在动态环境中调度程序的决策也可能无法被其他人准确知晓。原因是GIS中的信息更新总是不可避免地存在时间延迟。在 RS 方法中，智能体根据均匀概率分布为作业随机选择资源。在 LLS 方法中，智能体选择负载最少的资源来提交作业。如果有多个资源具有相同的最小负载，则随机选择其中一个。该选择规则假定智能体可以获得准确的全球资源信息，例如，来自理想的 GIS 系统。在 SLS 方法中，智能体执行独立的强化学习过程。它与提议的 OSLS 方法的不同之处在于，智能体在收到来自资源的已提交作业的最终完成信号之前不会更新其效用表，并且每个智能体都在没有任何协调信息的情况下独立学习 [5]。</p><p>网格系统的规模可以定义为智能体数$(N)$和资源数$(M)$的组合$(N，M)$。在每个时间步中，每个调度智能体$g_i$ 可能会收到带有泊松过程生成的随机数的作业。工作的到达率表示为 $ξ$ 。作业的长度是从 $[J_{min}, J_{max}]$ 区间内的均匀分布中随机生成的。资源的容量也在区间 $[C_{min}, C_{max}]$ 中统一选择。所以系统可以用参数集$(N，M，ξ，[J_{min}，J_{max}]，[C_{min}，C_{max}])$来描述。因此，由Grids的总处理能力和到达的作业总数共同确定的期望系统负载$γ_{system}$可以计算为：</p><p>$γ_{system} &#x3D; \frac{J_{total}}{C_{total}} &#x3D; \frac{\sum_{j&#x3D;1}^N(J_j^{\alpha v}<em>\xi)}{\sum_{i&#x3D;1}^{N}C_i} &#x3D; \frac{\sum_{j&#x3D;1}^N((J_{min} + J_{max})&#x2F;2</em>\xi_{j})}{\sum_{i&#x3D;1}^{N}C_i} * 100%$</p><p>其中$J_j^{\alpha v}$ 是第 j 个调度程序的作业长度的中值。显然，系统负载不应超过 100%，否则调度系统会崩溃。事实上，超过 90% 的系统负载对于 Grids 来说是非常沉重的。一个有效的作业调度算法可以公平、充分地利用所有资源来平衡系统的负载。为了测试新方法的负载均衡能力，下面进行了几个实验。</p><h4 id="Performance-evaluations-under-different-system-scales"><a href="#Performance-evaluations-under-different-system-scales" class="headerlink" title="Performance evaluations under different system scales"></a>Performance evaluations under different system scales</h4><p>为了实验不同的系统规模，选择了三种系统规模，即(30, 100)、(100, 250)和(300, 1000)。这些配置足够大，可以代表典型网格计算环境的规模。作业长度的分散范围设置为 [5, 995]。资源容量的区间为[50, 350]。工作到达率分别为0.93、0.7和0.93。所以所有的系统负载大约在 70% 左右。它是网格应用程序的典型中等系统负载。仿真结果如图 5 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230405142053921.png" alt="image-20230405142053921" loading="lazy"></p><p>图5中不同作业调度方法的ALoR曲线表明，在中等系统负载下，只有OSL方法、DMMS方法和LLS方法在不同的系统规模下实现了高效的负载均衡。显然，LLS方法是一种集中式的方法，可以达到最优的调度策略。但昂贵的计算和通信成本阻碍了它在现实世界网格中的有效应用。 DMMS方法可以平衡负载，但效率低于LLS方法，因为非协调决策可能会发生冲突，导致某些资源的过度利用&#x2F;利用不足。 OSL算法是去中心化的，只需要有限的通信成本，但可以针对不同的系统规模获得更好的次优策略。结果表明，一开始，OSL 方法的性能可能比 DMMS 和 LLS 差。这是因为使用 OSL 方法的调度器没有网格的先验知识，但是使用其他两种启发式方法的调度器可以从 GIS 系统中获取环境信息。当基于 OSL 的调度器通过试验积累了足够的经验时，最终可以获得良好的调度性能。</p><p>如图所示，SLS规则的性能很差，无法完成作业调度任务。出现这种现象的主要原因是奖励机制不当和同步问题。对于 SLS 方法，无论其 bandit-like 模型如何，它都采用延迟奖励机制。此外，基于 SLS 的调度器无需协调即可独立学习和工作。显然，这种行为会导致某些资源过度利用，而导致其他资源利用不足，这会降低调度性能。这种病理被称为<strong>羊群行为</strong> [18,19]。</p><p>具有 RS 规则的智能体随机选择资源，根本不考虑它们的效率，因此低容量资源上的 LoR 将无限增长。最后，平均负载 ALoR 增加失控。此外，对于 RS 规则，确实规模越大，性能越差。</p><h4 id="Performance-evaluations-under-different-system-loads"><a href="#Performance-evaluations-under-different-system-loads" class="headerlink" title="Performance evaluations under different system loads"></a>Performance evaluations under different system loads</h4><p>为了测试新方法在不同系统负载下的自适应性能，选择了50%、70%和90%三种系统负载配置，系统规模设置为(100, 250)。其他参数与前一个实验相同。图 6 显示了不同系统负载下 ALoR 的变化曲线。很明显，OSL 方法允许智能体比 RS 和 SLS 方法更有效地在资源之间安排作业。此外，即使系统负载增加，OSL 方法也可以收敛到次优策略。因此，所提出的 OSL 方法可以适应不同的系统负载。从图 6 可以看出，对于低系统负载，OSL 甚至可以收敛到一个接近最优的策略，其性能与集中式 LLS 方法相似。当系统负载增加时，OSL 也可以找到与 LLS 相当的次优策略。</p><p><img src="http://cdn.leafii.top/img/image-20230405145121744.png" alt="image-20230405145121744" loading="lazy"></p><h4 id="Performance-evaluations-under-different-resource-capacities"><a href="#Performance-evaluations-under-different-resource-capacities" class="headerlink" title="Performance evaluations under different resource capacities"></a>Performance evaluations under different resource capacities</h4><p>在前面的模拟中，资源容量的区间很宽，即 [50, 350]。事实上，不同的时间间隔会显着影响系统性能。下面选择资源容量的一个窄区间[150, 250]，再次进行上述系统规模(200, 500)的模拟。结果如图 7 所示。</p><p><img src="http://cdn.leafii.top/img/image-20230405150525357.png" alt="image-20230405150525357" loading="lazy"></p><p>在图 7 中，当系统负载较轻时（γsystem ≤ 70%），RS 方法可以很好地进行作业调度。 原因可能是所有资源的容量都大于 150，足以避免保持较长的作业队列。 此外，SLS 方法在系统负载较低时也可以获得良好的性能，如图 7（a）所示。 然而，RS 和 SLS 都无法在高系统负载下获得良好的性能，如图 7（b）和（c）所示。 当系统负载增加时，RS方法的性能下降，最终变得不可行。 然而，OSL 方法可以实现不同资源容量一致的负载平衡。</p><h4 id="Performance-evaluations-under-different-numbers-of-schedulers-and-resources"><a href="#Performance-evaluations-under-different-numbers-of-schedulers-and-resources" class="headerlink" title="Performance evaluations under different numbers of schedulers and resources"></a>Performance evaluations under different numbers of schedulers and resources</h4><p>在下面的模拟中，调度器数量和资源数量的不同比例被选择为（500, 200）和（1000, 500）。 作业长度的区间和资源容量的区间分别为 [5, 995] 和 [250, 750]。 作业到达率为 0.2 和 0.4（因此系统负载分别为 50% 和 80%）。 结果如图 8 所示。从图 8 可以看出，当调度器的数量远大于资源的数量时，SLS 方法具有良好的性能。 结果与文献[5]的结论一致。 如此好的成绩，可能是因为就业率低，资源能力强。 然而，对于现实世界的网格，调度器的数量多于资源的数量并不常见。 此外，请注意 SLS 规则的性能在不同条件下仍然不如 OSL 方法。</p><p><img src="http://cdn.leafii.top/img/image-20230405152315603.png" alt="image-20230405152315603" loading="lazy"></p><h4 id="Other-performance-measures"><a href="#Other-performance-measures" class="headerlink" title="Other performance measures"></a>Other performance measures</h4><p>除了平均资源负载 (ALoR) 之外，还可以使用其他指标来衡量系统性能。通常，ALoR 表示系统的宏观性能，但瞬态性能，例如资源中的最大 LoR（或完工跨度）也很重要。此外，LoR 的标准偏差是评估作业调度算法效率的另一个指标。无花果。图 9 和图 10 显示了 4.1 节中相应的实验结果。</p><p><img src="http://cdn.leafii.top/img/image-20230405153155477.png" alt="image-20230405153155477" loading="lazy"></p><p>从以上两个图中可以发现，OSLS 的最大 LoR 和偏差收敛，而 RS、SLS 和 DMMS 规则发散很快。 尽管 OSLS 曲线的幅度随着系统规模的增加而增加，但它们最终趋于平稳。 在不同的系统负载下获得了相同的结果。 换句话说，所有结果表明OSL算法的瞬态性能和效率是<strong>令人满意</strong>的。</p><h4 id="Performance-evaluation-with-different-learning-rates-and-sharing-factors"><a href="#Performance-evaluation-with-different-learning-rates-and-sharing-factors" class="headerlink" title="Performance evaluation with different learning rates and sharing factors"></a>Performance evaluation with different learning rates and sharing factors</h4><p>在上述所有模拟中，学习率和共享因子均设置为 0.5。事实上，学习因素和共享因素可以看作是新信息和过去经验之间的折衷，以及代理人自己的知识和他人的知识。可以为这两个参数选择一些不同的配置。下面进行与4.1(b)节相同条件的实验，分别评估不同的学习率和共享因子。</p><p><img src="http://cdn.leafii.top/img/image-20230405154828342.png" alt="image-20230405154828342" loading="lazy"></p><p>图 11(a) 显示了 OSL 在不同学习率下的性能变化，分别为 0.2、0.5 和 0.8，其中共享因子等于 0.5。 图 11(b) 显示了 OSL 在不同共享率下的性能变化，分别为 0.2、0.5 和 0.8，其中学习率等于 0.5。 结果表明，α 和 β 的值太大或太小都可能导致不理想的调度性能。 从实证研究中，可以选择学习率和共享因子的中间值以获得良好的性能。</p><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>根据以上实验，OSL算法的优势是显而易见的。通过使用序数共享学习机制，OSL 算法实现了与集中式和基于模型的方法（即 LLS 方法）相当的性能，但计算成本低得多且通信受限。此外，新方法对工作条件的敏感性低于其他算法，并实现了基于 MARL 的有效负载平衡。表 2 显示了本文研究的不同作业调度方法之间的比较总结。</p><p><img src="http://cdn.leafii.top/img/image-20230405155201637.png" alt="image-20230405155201637" loading="lazy"></p><h3 id="Related-works"><a href="#Related-works" class="headerlink" title="Related works"></a>Related works</h3><p>对于 Grids 中基于 RL 的作业调度问题，还有一些其他相关工作。 在[5]中，SLS 方法被用于网格作业调度。 然而，上述实验结果表明，SLS方法仅在用户数远大于资源数的某些特殊情况下具有良好的性能。 此外，其性能仍有待提高。</p><p>在 [6] 中，作者针对网格和其他分布式系统等领域的分布式任务分配问题引入了一种名为加权策略学习器 (WPL) 的新梯度上升学习算法。 WPL 可以在不观察其他智能体行为的情况下学习随机策略。然而，由于观测信息有限且难以获得平衡解，多智能体梯度上升法的收敛速度较慢，尤其是对于大规模问题。因此，作者只是针对一个小规模的问题测试了 WPL，其中服务器和用户的数量都不超过 5 个。</p><p>为了解决动态资源分配中的协调学习问题，在[39,27]中提出了一些基于价值函数的RL算法。为了将标准 Q 学习扩展到具有较大或连续状态-动作空间的资源分配问题，研究了具有函数逼近的 RL 方法。然而，大规模网格应用的问题仍然难以解决。在 [25,26] 中，一种名为 Fair Action Learner (FAL) 算法的多智能体 RL 方法被应用于以分散的方式跨集群共享资源。 FAL 采用直接策略搜索技术，即策略梯度上升 (PGA) 算法来学习决策策略。但是从他们的实验结果来看，学习过程的收敛速度还是很慢.</p><p>在 [40] 中，作者将资源分配问题视为复合 MDP，并提出了一种简化的本地化 RL 方法，其中动作、状态和奖励都是绝对本地化的。本地 RL 方法在数据中心原型的资源分配任务中进行了测试，并获得了一些有希望的结果。但是，智能体之间的适当协调对于获得更好的系统性能至关重要。</p><h3 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h3><p>网格计算的主要关注点之一是开发在动态环境中具有自配置和自优化能力的自主计算系统。 本文提出了基于多智能体强化学习的OSL方法来解决Grids中的作业调度问题。 该方法通过使用分布式学习策略规避了可扩展性问题，并实现了基于有序信息共享机制的多智能体协调。 最后，对OSL算法的性能进行了评价，并与其他算法进行了比较，研究并模拟了一种通用的网格作业调度模型，以描述网格的动态性、随机性、异构性。 仿真结果表明，适当的在线学习方法可以对异构网格系统中的负载平衡质量产生实质性的积极影响，并说明了OSL算法的有效性和效率。 未来的工作可能包括在实际网格环境中改进和应用所提出的方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 容错 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 工作流调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯真题-单词分析</title>
      <link href="/2023/04/04/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/"/>
      <url>/2023/04/04/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组 成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。</p><p>现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这 个字母出现的次数。</p><span id="more"></span><p><strong>输入描述</strong></p><p>输入一行包含一个单词，单词只由小写英文字母组成。</p><p>对于所有的评测用例，输入的单词长度不超过 1000。</p><p><strong>输出描述</strong></p><p>输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪 个。如果有多个字母出现的次数相等，输出字典序最小的那个。</p><p>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。</p><p><strong>输入输出样例</strong></p><p><strong>示例 1</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">lanqiao</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">a2</code></pre><p><strong>示例 2</strong></p><blockquote><p>输入</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">longlonglongistoolong</code></pre><blockquote><p>输出</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">o6</code></pre><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    string word; &#x2F;&#x2F; 定义输入的单词变量    cin &gt;&gt; word; &#x2F;&#x2F; 用输入流为其赋值    int cnt[26] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 初始化计数器    int index &#x3D; -1; &#x2F;&#x2F; 初始化计数器所用的下标    for (char s: word) &#123;        index &#x3D; s - &#39;a&#39;; &#x2F;&#x2F; 获取当前字母在计数器中的下标        cnt[index]++; &#x2F;&#x2F; 对应的计数自增1    &#125;    int max &#x3D; -1; &#x2F;&#x2F; 计数器中的最大值    int max_index &#x3D; -1; &#x2F;&#x2F; 计数器中最大值对应的最小下标    for (int i &#x3D; 0; i &lt; 26; i++) &#123;        if (cnt[i] &gt; max) &#123;            max &#x3D; cnt[i]; &#x2F;&#x2F; 最大值迭代            max_index &#x3D; i; &#x2F;&#x2F; 最大值的最小下标迭代，若最大值未更新，下标也不会更新        &#125;    &#125;    char answer &#x3D; &#39;a&#39; + max_index; &#x2F;&#x2F; 得到字母个数最多的字母    cout &lt;&lt; answer &lt;&lt; endl; &#x2F;&#x2F; 输出题目要求的第一行答案    cout &lt;&lt; max &lt;&lt; endl; &#x2F;&#x2F; 输出题目要求的第二行答案    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯真题-门牌制作</title>
      <link href="/2023/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C/"/>
      <url>/2023/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小蓝要为一条街的住户制作门牌号。</p><p>这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。</p><p>小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。</p><p>请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><span id="more"></span><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int result &#x3D; 0; &#x2F;&#x2F; 初始化需要数字2的个数为0    for (int i &#x3D; 1; i &lt;&#x3D; 2020; i++) &#123; &#x2F;&#x2F; 循环，从1到2020        int temp &#x3D; i; &#x2F;&#x2F; 令temp&#x3D;i，方便后续判断字符2个数的操作        while (temp &gt; 0) &#123;            if (temp % 10 &#x3D;&#x3D; 2) &#123; &#x2F;&#x2F; 如果temp中最后一位是2                result++; &#x2F;&#x2F; result自增            &#125;            temp &#x2F;&#x3D; 10; &#x2F;&#x2F; temp&#x2F;&#x3D;10去掉最后一位数字        &#125;    &#125;    printf(&quot;%d&quot;, result);&#x2F;&#x2F; 输出结果    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯真题-质数</title>
      <link href="/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E8%B4%A8%E6%95%B0/"/>
      <url>/2023/04/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98-%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们知道第一个质数是 22、第二个质数是 33、第三个质数是 55……</p><p>请你计算第 20192019 个质数是多少？</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><span id="more"></span><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int isPrime(int num) &#123;    &#x2F;&#x2F; 判断一个数字是不是质数，return 0代表不是质数， return 1 代表是质数    for (int i &#x3D; 2; i &lt; num; i++) &#123;        &#x2F;&#x2F; 循环中判断是否能被1或者它本身之外的数字整除，若能则不是质数，直接return 0        if (num % i &#x3D;&#x3D; 0) &#123;            return 0;        &#125;    &#125;    &#x2F;&#x2F; 循环结束都没发现能整除的其他数字，可以返回1    return 1;&#125;int main()&#123;    int count &#x3D; 0; &#x2F;&#x2F; 定义计数器，默认为0    int answer &#x3D; 0;    for (int i &#x3D; 2; count !&#x3D; 2019; i++) &#123; &#x2F;&#x2F; 从2开始循环是因为2是第一个质数，不要从1开始循环        if (isPrime(i) &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 若判断为是质数            count++; &#x2F;&#x2F; 计数器++；            answer &#x3D; i; &#x2F;&#x2F; 迭代更新answer        &#125;    &#125;    cout &lt;&lt; answer &lt;&lt; endl; &#x2F;&#x2F; 输出答案    return 0;&#125;</code></pre><ul><li>优化解法</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main() &#123;    int n &#x3D; 2019; &#x2F;&#x2F; 要计算的质数的位置    int num &#x3D; 3; &#x2F;&#x2F; 初始为3，因为第一个质数是2    int count &#x3D; 1; &#x2F;&#x2F; 已经找到了一个质数2，所以从1开始计数    while (count &lt; n) &#123;        num +&#x3D; 2; &#x2F;&#x2F; 只需要判断奇数是否为质数        bool isPrime &#x3D; true; &#x2F;&#x2F; 假设当前数是质数        for (int i &#x3D; 3; i &lt;&#x3D; sqrt(num); i +&#x3D; 2) &#123;            if (num % i &#x3D;&#x3D; 0) &#123;                isPrime &#x3D; false; &#x2F;&#x2F; 如果能被整除，则不是质数                break;            &#125;        &#125;        if (isPrime) &#123;            count++; &#x2F;&#x2F; 找到一个质数        &#125;    &#125;    cout &lt;&lt; num &lt;&lt; endl; &#x2F;&#x2F; 输出第2019个质数    return 0;&#125;</code></pre><ul><li>线性筛法（Linear Sieve）</li></ul><p>线性筛法是一种求解质数的算法，可以在$O(n)$的时间复杂度内预处理出小于等于$n$的所有质数。</p><p>线性筛法的基本思想是从小到大遍历每个正整数，如果它是质数，就将它加入质数数组中，并用它来筛掉它的倍数。在遍历过程中，对于每个数只会被它的最小质因子筛去，因此每个合数只会被筛一次，从而保证了线性时间复杂度。</p><p>下面是线性筛法的伪代码：</p><pre class="language-none"><code class="language-none">primes &#x3D; [] # 质数数组is_prime &#x3D; [True] * (n+1) # 标记是否为质数for i in range(2, n+1):    if is_prime[i]:        primes.append(i) # 将i加入质数数组    for j in range(len(primes)):        if i * primes[j] &gt; n:            break        is_prime[i * primes[j]] &#x3D; False # 将i*primes[j]标记为非质数        if i % primes[j] &#x3D;&#x3D; 0:            break # 如果i是primes[j]的倍数，就跳出循环</code></pre><blockquote><p>如果在内层循环中，$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</p><p>例如，当$i$为$2 \times 3&#x3D;6$时，在内层循环中，$i$会被$2$筛一次，被$3$筛一次，之后就不需要再被其他数筛了。因此，如果$i$是$primes[j]$的倍数，就可以跳出循环，不需要继续遍历$primes$数组中的其他质数。这样可以减少重复的筛选，提高算法的效率。</p></blockquote><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN &#x3D; 20000; &#x2F;&#x2F; 估计2019个质数的上限vector&lt;int&gt; primes; &#x2F;&#x2F; 存储质数bool isPrime[MAXN]; &#x2F;&#x2F; 标记是否为质数int main() &#123;    fill(isPrime, isPrime+MAXN, true); &#x2F;&#x2F; 初始化标记数组，全部设置为true    for (int i&#x3D;2; i&lt;MAXN; i++) &#123;        if (isPrime[i]) &#123; &#x2F;&#x2F; i是质数            primes.push_back(i); &#x2F;&#x2F; 将i加入质数数组            if (primes.size() &#x3D;&#x3D; 2019) &#123;                cout &lt;&lt; primes.back() &lt;&lt; endl;                break;            &#125;        &#125;        for (int j&#x3D;0; j&lt;primes.size() &amp;&amp; i*primes[j]&lt;MAXN; j++) &#123;            isPrime[i*primes[j]] &#x3D; false; &#x2F;&#x2F; 将i*primes[j]标记为非质数            if (i % primes[j] &#x3D;&#x3D; 0) break; &#x2F;&#x2F; 如果i是primes[j]的倍数，就跳出循环        &#125;    &#125;    return 0;&#125;</code></pre><blockquote><p>可以看到，线性筛法的实现相对简单，但需要注意以下几点：</p><ol><li>对于每个数只需要用它的最小质因子来筛去它的倍数，因此内层循环的终止条件为$i \times primes[j] &gt; n$。</li><li>在内层循环中，如果$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</li><li>在初始化标记数组时，除0和1外都初始化为True。</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode968.监控二叉树</title>
      <link href="/2023/03/29/leetcode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/03/29/leetcode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/bst_cameras_01.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/bst_cameras_02.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>贪心算法</li></ul><p>本题是一道贪心算法的题目。通过对题目进行分析，我们可以发现有以下几种情况：</p><p>1.如果一个节点没有被监控，那么它必须要安装一个摄像头。</p><p>2.如果一个节点安装了摄像头，那么它的父节点就可以被监控了。</p><p>3.如果一个节点的子节点被监控了，那么这个节点也可以被监控。</p><p>因此，我们可以采用自下而上的方式进行处理，从叶子节点开始向根节点进行处理。对于每个节点，我们可以有三种状态：</p><p>0：该节点没有装摄像头，且它的子节点中也没有装摄像头的节点，此时应该给他装一个摄像头。</p><p>1：该节点没有装摄像头，但是它的子节点中至少有一个装摄像头的节点，此时应该给他的父节点装一个摄像头。</p><p>2：该节点装摄像头了，因此它无需再安装一个摄像头。</p><p>对于每个节点，我们可以采用递归的方式进行处理。当节点为叶子节点时，它的状态为0。对于其他节点，如果它的子节点中存在状态为0的节点，那么该节点的状态为1，表示需要安装摄像头。如果它的子节点中都存在状态为1或2的节点，那么该节点的状态为0，表示不需要安装摄像头，但是它的父节点需要安装摄像头。如果它的子节点中存在状态为2的节点，那么该节点的状态为1，表示不需要安装摄像头，因为它的子节点已经可以覆盖它了。</p><p>最后，根据根节点的状态来判断是否需要安装摄像头。如果根节点的状态为0或1，那么需要安装一个摄像头。如果根节点的状态为2，那么不需要安装摄像头。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minCameraCover(TreeNode* root) &#123;        int res &#x3D; 0;        if (dfs(root, res) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 根节点未被监控            res++;        &#125;        return res;    &#125;    int dfs(TreeNode* node, int&amp; res) &#123;        if (node &#x3D;&#x3D; nullptr) &#123;            return 2; &#x2F;&#x2F; 空节点不需要监控，返回2        &#125;        int left &#x3D; dfs(node-&gt;left, res);        int right &#x3D; dfs(node-&gt;right, res);        if (left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 左右子节点有未被监控的节点，该节点需要安装摄像头            res++; &#x2F;&#x2F; 安装了摄像头            return 1; &#x2F;&#x2F; return 1是指该节点没有被监控，但是它的子节点中至少有一个被监控的节点。        &#125; else if (left &#x3D;&#x3D; 1 || right &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 左右子节点中至少有一个节点被监控            return 2; &#x2F;&#x2F; return 2是指该节点被监控了。        &#125; else &#123; &#x2F;&#x2F; 左右子节点均被监控            return 0; &#x2F;&#x2F; return 0是指该节点没有装摄像头        &#125;    &#125;&#125;;</code></pre><blockquote><p>其中，dfs函数的返回值为当前节点的状态。如果返回值为0，表示当前节点需要安装摄像头；如果返回值为1，表示当前节点不需要安装摄像头，但是它的父节点需要安装摄像头；如果返回值为2，表示当前节点不需要安装摄像头。res为引用类型，表示安装摄像头的数量。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode113.路径总和II</title>
      <link href="/2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/"/>
      <url>/2023/03/28/leetcode113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/pathsumii1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22输出：[[5,4,11,2],[5,8,4,5]]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/pathsum2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2], targetSum &#x3D; 0输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>本题可以使用深度优先搜索（DFS）求解。从根节点开始，依次搜索左子树和右子树，直到找到符合条件的路径。具体来说，我们可以使用递归的方式，每次遍历到一个节点时，将该节点加入路径中，并更新目标值。如果该节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径，将该路径加入结果数组中。否则，继续搜索左子树和右子树。在搜索之后，需要将当前节点从路径中删除，以便回溯到之前的状态。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        dfs(root, targetSum, res, path);        return res;    &#125;    void dfs(TreeNode* node, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;        if (!node) return;  &#x2F;&#x2F; 如果当前节点为空，则直接返回        path.push_back(node-&gt;val);  &#x2F;&#x2F; 将当前节点的值加入路径中        targetSum -&#x3D; node-&gt;val;     &#x2F;&#x2F; 更新目标值        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 如果当前节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径            res.push_back(path);    &#x2F;&#x2F; 将该路径加入结果数组        &#125; else &#123;            dfs(node-&gt;left, targetSum, res, path);   &#x2F;&#x2F; 搜索左子树            dfs(node-&gt;right, targetSum, res, path);  &#x2F;&#x2F; 搜索右子树        &#125;        path.pop_back();  &#x2F;&#x2F; 回溯：将当前节点从路径中删除，恢复到搜索之前的状态    &#125;&#125;;</code></pre><blockquote><p><code>path.pop_back()</code> 是 C++ 中 vector 容器的成员函数，用于删除 vector 容器中的最后一个元素。在本题中，由于我们在搜索过程中需要记录搜索路径，因此使用了一个 <code>path</code> 数组来保存路径。在每次搜索到一个新节点时，我们将该节点的值加入 <code>path</code> 数组中，如果搜索结束后未找到符合条件的路径，需要将该节点从 <code>path</code> 数组中删除，回溯到之前的状态，继续搜索其他节点。因此，在代码中，<code>path.pop_back()</code> 的作用是删除 <code>path</code> 数组中最后一个元素，以便回溯到之前的状态。</p></blockquote><p>时间复杂度分析：</p><p>本题的时间复杂度为$ O(N^2)$，其中 N 表示二叉树的节点数。在最坏情况下，二叉树的形态类似于一个单链表，此时需要遍历所有节点，时间复杂度为 $O(N)$。对于每个节点，由于需要将该节点加入路径中，时间复杂度为$ O(N)$，因此总时间复杂度为 $O(N^2)$。</p><p>空间复杂度分析：</p><p>本题的空间复杂度为 $O(N)$，其中 N 表示二叉树的节点数。递归调用的栈空间最多为 $O(N)$，路径数组的空间为 $O(N)$，因此总空间复杂度为 $O(N)$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode110.平衡二叉树</title>
      <link href="/2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/03/27/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/balance_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/balance_2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：true</code></pre><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归但空间复杂度较高的解法</li></ul><p>本题可以使用递归的方法来解决。对于每一个节点，我们需要先递归遍历它的左右子树，计算它们的高度差。如果左右子树的高度差超过了1，那么这棵树就不是平衡二叉树。如果左右子树都是平衡二叉树，那么我们可以判断当前节点是不是平衡二叉树：如果左右子树的高度差不超过1，那么当前节点就是平衡二叉树。最后递归返回整棵树的平衡情况。</p><p>在递归函数中，我们需要同时返回当前节点的高度和平衡情况，因此可以使用pair&lt;int, bool&gt;来表示。其中，pair的第一个元素表示高度，第二个元素表示当前节点是否是平衡二叉树。同时，我们需要处理一些边界情况，例如空节点的高度为0，空节点也是平衡二叉树。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root).second;    &#125;        pair&lt;int, bool&gt; checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return make_pair(0, true);        &#125;        auto left &#x3D; checkBalance(node-&gt;left);        auto right &#x3D; checkBalance(node-&gt;right);        if (left.second &amp;&amp; right.second &amp;&amp; abs(left.first - right.first) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return make_pair(max(left.first, right.first) + 1, true);        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return make_pair(0, false);    &#125;&#125;;</code></pre><blockquote><p><code>pair</code>是C++ STL中的一个模板类，用于存储两个不同类型的变量。它将两个变量打包成一个整体，方便传递和使用。</p></blockquote><p>但是它的内存占用过高，因为对于每个节点，它都要单独存一个bool变量用于表示节点是否为二叉树的平衡结点。因此需要进行优化。</p><ul><li>递归，但优化内存占用</li></ul><p>在题目中，我们使用了<code>pair&lt;int, bool&gt;</code>来表示每个节点的高度和平衡情况，但是这种方法会浪费一定的空间，因为每个节点都需要存储一个<code>bool</code>类型的变量。实际上，我们只需要判断每个节点是否平衡，因此可以使用一个<code>int</code>类型的变量来表示平衡情况：-1表示不平衡，非0表示平衡并且代表节点的高度。这样就可以减少空间的使用。</p><p>同时，我们可以将返回值从<code>pair&lt;int, bool&gt;</code>改为<code>int</code>，表示当前节点的高度。如果当前节点不是平衡二叉树，那么直接返回-1，否则返回节点的高度。</p><p>C++代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        return checkBalance(root) !&#x3D; -1;    &#125;    int checkBalance(TreeNode* node) &#123;        if (!node) &#123;            &#x2F;&#x2F; 空节点为平衡二叉树            return 0;        &#125;        int left &#x3D; checkBalance(node-&gt;left);        int right &#x3D; checkBalance(node-&gt;right);        if (left !&#x3D; -1 &amp;&amp; right !&#x3D; -1 &amp;&amp; abs(left - right) &lt;&#x3D; 1) &#123;            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1            return max(left, right) + 1;        &#125;        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡        return -1;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迈向智能云：云系统容错方法回顾</title>
      <link href="/2023/03/27/%E8%BF%88%E5%90%91%E6%99%BA%E8%83%BD%E4%BA%91%EF%BC%9A%E4%BA%91%E7%B3%BB%E7%BB%9F%E5%AE%B9%E9%94%99%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE/"/>
      <url>/2023/03/27/%E8%BF%88%E5%90%91%E6%99%BA%E8%83%BD%E4%BA%91%EF%BC%9A%E4%BA%91%E7%B3%BB%E7%BB%9F%E5%AE%B9%E9%94%99%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems"><a href="#Toward-a-Smart-Cloud-A-Review-of-Fault-Tolerance-Methods-in-Cloud-Systems" class="headerlink" title="Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems"></a>Toward a Smart Cloud: A Review of Fault-Tolerance Methods in Cloud Systems</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文介绍了云计算中提出的容错方法的最新研究进展。本文将容错方法分为三类：1）反应式方法（RAMs）；2）预防性方法（PRMs）；和3）弹性方法（RSMs）。RAMs允许系统进入故障状态，然后尝试恢复系统。PRMs倾向于通过实施机制来避免错误影响系统，从而防止系统进入故障状态。另一方面，最近出现的RSMs旨在最小化系统从故障中恢复所需的时间。本文还探讨了机器学习和人工智能在RSM领域中如何发挥作用以最小化恢复时间。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>首先，介绍了云计算的概念和特点，指出云计算作为一种新型的计算模式，具有高度的可扩展性、灵活性和可靠性等优势。然而，由于云计算系统规模庞大、复杂度高，因此故障率也相应增加。因此，在云计算中实现容错是至关重要的。</p><p>接着，本文介绍了目前在云计算领域中已经提出的容错方法，并指出这些方法存在一些局限性和不足之处。</p><p>常见的容错方法被分类为三类：反应式方法（RAMs）、预防性方法（PRMs）和弹性方法（RSMs）。其中，反应式方法指的是系统在发生故障后才进行恢复；预防性方法则是通过实施机制来避免错误影响系统，从而防止系统进入故障状态；弹性方法旨在最小化系统从故障中恢复所需的时间。具体而言，反应式方法（RAMs）允许系统进入故障状态，然后尝试恢复系统；预防性方法（PRMs）倾向于通过实施机制来避免错误影响系统，从而防止系统进入故障状态；最近出现的弹性方法（RSMs）旨在最小化系统从故障中恢复所需的时间。它们常用的技术如下：</p><ol><li>反应式方法（RAMs）：基于传统的分布式系统容错技术，如复制、检查点&#x2F;重启、检测和恢复等。</li><li>预防性方法（PRMs）：主要采用监控、预测和抢占等技术。在正常操作下，PRMs不断监视系统状态，并在可能发生系统故障时立即调用避免故障的步骤。 </li><li>弹性方法（RSMs）：主要采用快速恢复和自愈能力等技术。RSMs旨在最小化系统从故障中恢复所需的时间，以便尽快将系统恢复到正常状态。</li></ol><p>而传统的反应式方法（RAMs）只能在系统发生故障后才能进行恢复，而预防性方法（PRMs）则需要消耗大量资源来避免错误发生。因此，需要进一步研究新型的容错方法来解决这些问题。 </p><p>在Introduction中，作者详细描述了PRMs和RSMs之间的区别。具体而言，作者指出PRMs主要实现故障预测和避免方法，但没有学习和适应方法；而RSMs则通过不断更新模型和学习结构来适应云系统的动态变化，并根据自身计算环境特征自适应地学习和减轻PRMs的影响。因此，虽然PRMs实现了故障预测，但没有学习和适应方法；而RSMs则通过自适应地学习计算环境特征来减轻PRMs的影响，并在系统发生故障时快速恢复。</p><p>最后，本文介绍了本文所采用的研究框架，并概述了本文各个章节所涉及到的内容。</p><p><img src="http://cdn.leafii.top/img/image-20230328151324660.png" alt="image-20230328151324660" loading="lazy"></p><h2 id="Cloud-Fault-Tolerance-Model"><a href="#Cloud-Fault-Tolerance-Model" class="headerlink" title="Cloud Fault Tolerance Model"></a>Cloud Fault Tolerance Model</h2><p>故障可以是系统中发生的影响系统正常运行的任何事件。通常，故障是系统正常运行的<strong>根本损害</strong>，它们会导致错误。错误反过来会导致系统故障。容错性是衡量系统在出现故障时继续为其客户请求提供服务的能力。本文定义了四种系统错误，分别是瞬态故障（Transient Faults），间歇性故障（Intermittent Faults），永久性故障（Permanent Faults），拜占庭式故障（Byzantine Faults）：</p><ol><li>瞬态故障（Transient Faults）：指系统中的某个组件或部件在短时间内发生故障，但之后又能够自行恢复正常工作。这种故障通常是由于电压波动、电磁干扰等原因引起的。 </li><li>间歇性故障（Intermittent Faults）：指系统中的某个组件或部件在不同时间点上出现故障，但每次故障持续时间很短，并且在下一次出现之前可能会有很长一段时间没有任何问题。这种故障通常是由于松动连接、温度变化等原因引起的。</li><li>永久性故障（Permanent Faults）：指系统中的某个组件或部件发生了无法自行恢复的故障，需要进行更换或修理才能恢复正常工作。这种故障通常是由于硬件损坏、软件错误等原因引起的。</li><li>拜占庭式故障（Byzantine Faults）：指系统中的某个组件或部件出现了任意形式的错误，包括发送错误信息、篡改数据等。这种错误通常是由于恶意攻击、软件漏洞等原因引起的。</li></ol><h2 id="Fault-Tolerance-Challenges-in-cloud-systems"><a href="#Fault-Tolerance-Challenges-in-cloud-systems" class="headerlink" title="Fault Tolerance Challenges in cloud systems"></a>Fault Tolerance Challenges in cloud systems</h2><p>云计算的特点使得云系统容错面临着以下挑战：</p><ul><li>Heterogeneity and the lack of standards（异质性和缺乏标准）：不同硬件和操作系统供应商基于自己的架构部署云，因此可能在同一个大型云系统中部署在异构平台上的组件。这给容错解决方案的设计带来了压力，因为它们必须考虑整个容错解决方案中每个操作系统供应商的方面。因此，在设计容错解决方案时需要考虑到这些异构性和缺乏标准的挑战。</li><li>Need for automation（需要自动化）：未来是智能的，并需要自动化。随着托管云系统的虚拟机数量呈指数级增长，人类管理这些系统将变得几乎不可能。因此，需要考虑自动化来管理这些系统的容错解决方案。然而，自动化面临着缺乏通用框架（API）的挑战，这些框架可以应用于任何云系统以实现容错解决方案，并且需要进行很少的努力（即需要插入式容错）。因此，在未来的容错解决方案中，自动化将成为主要趋势。</li><li>Downtime in the clouds（云中的停机时间）：云架构由多个地理位置分布和由不同供应商管理的数据中心组成。一个数据中心的完全停机可能会影响许多组织。每个组织对云的服务级别协议（SLA）不同，容错提供商必须确保满足所有组织的SLA。因此，在设计容错解决方案时需要考虑到这些挑战。</li><li>Consideration for RPO and RTO（对 RPO 和 RTO 的考虑）：容错解决方案的目标是将恢复点目标（RPO）和恢复时间目标（RTO）都降到最低。其中，<strong>RPO是服务器故障时可能丢失的数据量</strong>，而<strong>RTO是系统在故障后重新运行所需的时间</strong>。通过使用弹性方法来不断最小化RPO和RTO，可以设计出容错解决方案。弹性方法的学习功能可以被定义为最小化RPO和RTO。因此，在设计容错解决方案时需要考虑到这些目标。</li><li>Workloads in the cloud(云计算中的工作负载):云计算中有两种工作负载类型，即云原生和云启用工作负载。云原生应用是完全使用云模型构建的应用程序，由多个服务组成，每个服务都具有弹性、韧性，并可用于组合其他应用程序。而云原生工作负载是由纯云原生应用程序生成的计算工作负载。在某些情况下，不可能将应用程序的所有组件迁移到云上，这导致应用程序的某些组件在企业内部托管，而另一些组件在云上托管。这通常被称为“云启用”。因此，在设计容错解决方案时需要考虑到这些工作负载类型的差异。在这种情况下，主动和弹性方法都应该适用于处理云原生和云活动模型的容错要求。</li></ul><h2 id="Fault-tolerance-and-reliability-in-the-clouds"><a href="#Fault-tolerance-and-reliability-in-the-clouds" class="headerlink" title="Fault tolerance and reliability in the clouds"></a>Fault tolerance and reliability in the clouds</h2><p>虚拟化技术用于提供计算资源，然后这些资源属于许多云用户。 这种资源虚拟化导致了复杂的基础架构设计，这些设计将硬件暴露在它们最初并非设计用于并导致故障的条件下。 故障可能发生在硬件、系统（主机或 VM）、软件或操作员级别。 云系统中的故障可能导致系统发生灾难性中断，从而影响云系统的可靠性。</p><p>云系统的可靠性是衡量云系统在预定条件下向用户提供服务的好坏程度。 此类条件通常定义为 QoS，它构成云服务提供商与客户（或用户）之间合同的一部分。 云系统的可靠性最终取决于承载服务的虚拟机的容错能力。一般来说，云系统中用于容错的技术涉及<strong>检查点 [4]、冗余 [3]、[7] 和网络带宽</strong> [9]、[10] 的优化。 检查点可以发生在进程级别或 VM 级别。 进程或 VM 状态在执行期间不断被保存。 在进程失败的情况下，执行将从检查点开始恢复，而不是从头开始。 如果 VM 发生故障，VM 映像将恢复到另一台机器，并且进程从发生故障的 VM 的检查点继续。</p><p>大多数关于云系统可靠性的研究都集中在优化检查点算法和虚拟机冗余上。刘等人。 [3] 和周等人。 [4] 描述了一种<strong>冗余 VM 方法</strong>，该方法在选择一组 VM 托管服务器时考虑了网络拓扑结构，目的是最大限度地减少网络资源消耗。 周等。 [5] 提出了一种<strong>减少虚拟机检查点期间使用的存储</strong>的解决方案。 最后，周等人。 [5] 对<strong>增强云可靠性</strong>的研究进行了研究。 在大多数情况下，云服务的采用涉及将托管在组织数据中心的现有系统迁移到云环境。 由于低维护成本、高可扩展性和按使用付费模式等特性，组织被云托管的价值主张所吸引。 除了节省托管成本外，此类迁移还应提高系统的<strong>整体可靠性</strong>。 将一些成熟的企业系统迁移到云端并不是一个容易的决定。 尽管将系统迁移到云端有明显的好处，但组织仍然必须根据为此类决策提供信息所需的科学方法做出务实的决策。 此外，还需要考虑重要的考虑因素，例如系统安全性（由组织的安全策略管理）。 一些系统组件最好在本地私有环境中运行。 因此，需要一些<strong>指南</strong>来帮助实施最佳的云迁移结构。<br>邱等。 [11] 介绍了一个<strong>基于可靠性的框架</strong>（ROCloud），在考虑系统上的云迁移时，它可以用作决策制定的一部分。 ROCloud 由两种算法（ROCloud1 和 ROCloud2）组成，用于根据应用程序的结构和历史可靠性信息对其进行<strong>排名</strong>。 ROCloud1 和 ROCloud2 分别用于对普通应用程序和混合应用程序进行排名。 排名结果用于自动选择要使用的最佳容错策略。 该框架使用<strong>四种常见的容错策略</strong>，即 Recovery Block、N-Version Programming、Parallel 和 VM Restart。 每个策略根据<strong>三个参数</strong>对每个系统组件进行排名：响应时间、资源成本和故障率。 进行了实验，结果表明，仅通过过滤一些容易出错的组件并将它们移动到云中，就有了显着的改进。</p><h2 id="Taxonomy-of-fault-tolerance-methods"><a href="#Taxonomy-of-fault-tolerance-methods" class="headerlink" title="Taxonomy of fault tolerance methods"></a>Taxonomy of fault tolerance methods</h2><p>在这部分中，论文详细描述了对容错方法的三个分类，即ReActive Methods (RAMs)、PRoactive Methods (PRMs)和ReSilient Methods (RSMs)。其中，每个分类用到的关键技术如下：</p><ul><li>RAMs（反应性方法）：重点主要是系统恢复。系统的状态在恢复过程中不断保存和使用。使用的关键技术是复制、检查点和重新启动。</li><li>PRMs（主动方法）：主要关注防止系统完全中断。这些方法通过持续监控系统和进行故障预测来工作，以便在故障发生之前很好地预防故障的影响。使用的关键技术是云资源的监控、预测和重新分配。</li><li>RSMs（弹性方法）：这些方法与主动方法具有许多共同特征。 RSM 通过预测故障和实施方法来运行以避免或最小化此类故障对系统的影响。除了监控和预测之外，弹性方法还通过与托管环境交互并结合智能学习来调整（微调）系统容错能力。这是 RSM 与 PRM 显着不同的地方。</li></ul><p><img src="http://cdn.leafii.top/img/image-20230328161146682.png" alt="image-20230328161146682" loading="lazy"></p><h3 id="Reactive-Meghods"><a href="#Reactive-Meghods" class="headerlink" title="Reactive Meghods"></a>Reactive Meghods</h3><p>反应性方法用于减轻故障发生后的影响。根据当前文献，用于反应式容错的关键技术包括检查点&#x2F;重启、复制、SGuard、重试、自定义异常处理、任务重新提交和救援工作流。本节回顾了有关 RAM 的选定论文。</p><h4 id="Checkpointing-x2F-Restarting"><a href="#Checkpointing-x2F-Restarting" class="headerlink" title="Checkpointing&#x2F;Restarting"></a>Checkpointing&#x2F;Restarting</h4><p>检查点&#x2F;重新启动技术通过<strong>不断保存系统状态</strong>来工作，如果发生故障，作业将从最近的状态开始。 这些技术适用于长时间运行的作业。 以下段落将总结一些关于基于检查点的算法的论文，即[26]、[27]、[28]、[29]、[30]、[31]、[32]、[33]、[34] ]、[35]、[36]、[37]。 这些论文的选择基于他们如何将检查点纳入他们的解决方案的变化。</p><p>冈村等。 [27] 提出了一种基于强化学习的动态检查点方案。 这种技术在系统故障分布未知的情况下会变得很有用。 首先，检查点问题被建模为半马尔可夫决策过程。 其次，应用具有代表性的强化学习算法（称为 Q-learning 算法）。 Q-learning 允许构建自适应检查点方案。 该算法由通过学习和交互体验适应环境的智能 体组成。</p><p>穆迪等。 [29] 描述了一种新颖的多级检查点系统。 这种方法旨在降低不断增长的高性能计算 (HPC) 系统的检查点成本。 系统定义了一套 L checkpointing 机制。 每个级别代表一个具有不同成本和弹性级别的检查点机制，最终映射到所使用的存储类型，例如本地内存、USB、远程内存、使用软件 RAID、本地 SSD 或远程文件系统。 第一个级别 1 是成本最低的级别，最后一个级别 L 是成本最高的级别。 较低级别采用轻量级检查点，这些检查点具有较低的开销成本，因此非常适合处理最常见的故障模式。 类似地，较高级别具有昂贵的检查点成本，并且用于不太频繁的故障模式。 Scalable Checkpoint&#x2F;Restart (SCR) 库用于实现系统，它可以将检查点保存到计算节点上的 RAM、Flash 或磁盘。 该系统使用概率马尔可夫模型进一步建模，该模型可用于预测当前和未来系统的性能。 总体结果表明，当前和未来系统的并行文件系统负载<strong>减少了两次</strong>。 迪等人。 [30] 通过开发一种进一步优化级别选择的方法，进一步优化了多级检查点。 此外，Di 等人。 [33] 通过优化核数不确定的系统的检查点间隔来改进多级检查点。</p><p>奥林纳等。 [32] 引入了协作检查点技术，这是一种健壮的检查点算法，由一组规则和策略组成，使检查点决策能够由应用程序、编译器和操作系统（看门人）共同做出。 在这种方法中，开发人员在代码中的最佳位置插入检查点请求，编译器进一步优化这些检查点请求，看门人进行最终调用以授予或拒绝检查点。 网守考虑许多系统运行时因素来授予&#x2F;拒绝检查点请求，例如 CPU 负载、磁盘 I&#x2F;O、网络 I&#x2F;O、作业调度队列、故障事件预测和 QoS 保证。 奥林纳等。 [32] 还表明协作检查点简单实用，可以应用于现有应用程序检查点机制之上。 进行了许多实验，表明协作检查点<strong>优于</strong>周期性检查点。 Jangjaimon 和 Tzeng [35] 提出了一种增强的自适应增量检查点 (EAIC) 容错机制。 EAIC 旨在基于未来的云计算资源即服务 (RaaS) 模型，为托管在多核云基础设施上的多线程云应用程序提供 FT。 调整后的马尔可夫模型 (AMM) 的构建是为了满足现场实例 (SI)、保留实例 (RI) 和硬件故障的需要。 在 RI 中，客户购买预先配置资源（如 CPU、IO 或内存）的预留实例。 对于 SI，客户可以竞标未使用的资源，而且价格通常比 RI 低得多。 结果表明，应用程序运行时间和成本的<strong>显着减少都归功</strong>于多级检查点的使用。 这个观察是在使用 RI 和 SI 时进行的。 赵等。 [36] 提出了一种新方法，该方法确定如何使用对等检查点在云计算中提供弹性和联合可靠性优化。 总的来说，这项工作 [36] 利用云实用程序的检查点技术在数据中心的资源限制下共同最大化可靠性。 主要关注点对点检查点，用于提高网络资源限制下的可靠性。 在正常情况下，VM 映像被发送到中央存储服务器，这可能会由于高带宽使用率而导致网络拥塞。 为了缓解这个问题，点对点检查点是一种分布式方法，云运营商可以选择在具有足够带宽的对等点之间路由检查点的位置。 <strong>仿真结果</strong>表明，与随机点对点检查点和集中式检查点相比，这种方法显着提高了可靠性。 Amoon [37] 描述了一种基于检查点和复制的云计算自适应容错框架。 该框架在某种意义上是<strong>自适应的</strong>，它能够选择最佳的容错方法用于客户的任务。 此外，该框架还提出了一种复制算法，可以自适应地确定应用程序所需的副本数量。 通过这种方式，复制仅适用于发生故障时对云有较大性能影响的虚拟机。 检查点也是<strong>自适应的</strong>，检查点间隔的长度是根据虚拟机的故障概率自适应确定的。</p><h4 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h4><p>复制技术的工作原理是复制一些系统组件，然后将这些组件同时部署到不同的资源中。该技术旨在使系统健壮，提高可用性并保证作业的执行 [9]、[26]、[38]、[39]、[40]、[41]、[42]、[43] , [44], [45], [46], [47]</p><p>Bodı k 等人。 [9] 提出了一种可用于云迁移的新算法。 云迁移的一个挑战是找到一个既能满足容错又能降低带宽成本的最佳部署模型。 该算法还确定了将系统组件复制到云中并实现最佳带宽和容错的最佳方式。 将系统部署到云中的主要挑战之一是服务器可用性。 这与可用带宽直接相关。 数据中心采用本地冗余构建，可让本地服务器在维护或维修时脱机。 当整个数据中心因灾难或网络设备维护而离线时，挑战就来了。 这通常会导致大量服务器脱机。 可用带宽与云系统的部署架构相关联。 部署在一个数据中心的云系统容易出现服务器不可用、网络拥塞等各种网络故障。 如果网络连接完全中断，数据中心将成为单点故障。 增加部署系统的数据中心数量会直接增加带宽使用，但会显着提高容错能力。 因此，<strong>在提供高容错性和减少带宽使用之间找到良好的平衡存在挑战。</strong> 这可以通过 [9] 中描述的算法来解决。 Balasubramanian 和 Garg [38] 描述了分布式系统中基于融合数据结构的故障管理解决方案，旨在处理<strong>数据崩溃和拜占庭故障</strong>。 融合数据结构的设计方式使得主数据结构的恢复可以通过非常有限的复制次数来完成。 融合数据结构的主要<strong>优点</strong>是节省了存储数据结构副本所需的存储空间。 该技术主要适用于基于队列、栈、向量、二叉搜索树、哈希映射和哈希表等数据结构的解决方案的分布式存储。 融合数据结构还大大<strong>节省</strong>了从故障中恢复所需的计算资源。</p><p>库利等人。 [39] 目前 Remus 主要基于检查点和复制。 Remus 的目标是实现一种透明的容错技术，不需要对现有的云应用程序进行任何更改。 在 Remus 中，托管应用程序的虚拟机被配对成一个主虚拟机和一个辅助虚拟机。 Remus 中的复制是异步完成的。 然后采用各种技术来确保主要和次要之间的异步状态复制。 主 VM 的输出被缓冲并异步复制到辅助 VM。 主 VM 在其状态被检查点后立即恢复执行，并且不等待辅助 VM 的确认。 Remus 结合了一种简单的磁盘缓冲技术来保持主虚拟机和辅助虚拟机的磁盘同步。 在主 VM 上发出的磁盘写入立即提交到其本地磁盘，它们同时传输到辅助 VM 上的缓冲区。 辅助 VM 在检查点后提交到其本地磁盘。 </p><p>Castro 和 Liskov [42] 描述了拜占庭容错 (BFT) 协议。 BFT 协议主要<strong>旨在</strong>解决可靠性和保证系统的高可用性。 大多数 BFT 系统对于实际实施而言过于昂贵，因此，据我们所知，到目前为止，还没有关于实施 BFT 技术的商业数据中心的报道。 提供异步、分布式、客户端-服务器系统的 BFT 解决方案至少需要 $(3f+1)$ 个副本，其中一个为主，其余为备份，其中$ f $是在任何给定点可以容忍的最小故障数时间。 BFT 解决方案具有高资源消耗，这可以归因于它们处理故障的方式。 BFT 解决方案依赖于服务器状态机复制 (SMR)，其中每个副本都以相同的顺序执行相同的请求。 副本使用拜占庭协议来就一组给定请求的顺序达成一致。 订单达成一致后开始执行，然后使用多数表决方案选择正确的答案发送回客户端。 以这种方式，在该投票阶段也可以检测到有故障的服务器。</p><p>郑等。 [46] 提出了一种基于组件排名（称为 FTCloud）的可配置容错方法。 FTCloud由两种算法组成； 第一种算法使用组件执行结构并监视执行频率以构建显着组件排名。 第二种算法使用这些重要组件排名以及系统设计人员输入的容错要求来识别云应用程序的重要组件。 完成组件排名后，该算法会自动为重要的云组件确定最佳容错策略。 最重要的观察是，通过容忍一小部分最重要组件的故障，云应用程序的可靠性得到显着提高。 用于重要组件的最佳容错策略基于冗余和复制。 贾瓦尔等人。 [47] 介绍了一种创新的、系统级和模块化的解决方案，用于在云中创建容错。 该解决方案向应用程序开发人员隐藏了 FT 实施细节。 因此，它创建了一个服务层，开发人员可以在其中请求 FT 作为服务。 用户可以指定和应用所需的 FT 级别，而<strong>无需了解</strong>用于实现容错的底层技术。 该解决方案假定客户端应用程序部署在虚拟机上，因此将 FT 的粒度限制为 VM 实例。 具体来说，该方案利用冗余和复制来实现容错，创建多个虚拟机副本，并在出现故障时随时可用以接管。</p><h4 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h4><p>重试技术的工作原理是简单地多次重试<strong>同一资源</strong>上的失败请求 [48]、[49]。</p><p>Ramalingam 和 Vaswani [49] 提出了一种解决方案，该解决方案依赖于重试技术来解决由于云系统中的进程或通信故障引起的故障。在这样的环境中，失败的请求只是重试。重试机制依赖于系统的无能。 Indepotence 被描述为一个标准，使得在存在重复请求和失败的情况下从应用程序获得的结果与在没有重复请求和失败的情况下从这样的应用程序获得的结果<strong>完全相同</strong>。 Indepotence 由一种名为 FAIL 的语言形式化，该语言受云平台的影响。本质上，语言 FAIL 将流程失败、重复请求、数据和事务形式化。 FAIL 的最终目标是保证无能的云服务。这样的系统是去中心化的，不需要分布式协调。结果，这产生了一个完全分散的容错实现，它处理相同请求和进程失败的多次重试。</p><p>王等。[48]分析了重试容错技术对云服务的性能影响。这是通过构建云服务处理时间的数学模型来实现的。该模型后面是处理时间的概率分布，以分析在出现故障时重试作业的影响。还通过计算在定义的阈值下可以成功服务的请求的百分比来反映服务质量。将使用重试技术的云系统的性能与使用 FT 的检查点技术的云系统的性能进行了比较。结果表明，根据检查点方法的恢复率，重试技术的性能可能比检查点技术更好或更差。</p><h4 id="Task-Resubmission"><a href="#Task-Resubmission" class="headerlink" title="Task Resubmission"></a>Task Resubmission</h4><p>在任务重新提交中，当检测到失败的任务时，它会重新提交到相同或<strong>不同的资源</strong>以执行 [44]。</p><p>Plankensteiner 等人。 [44] 描述了重新提交影响启发式，并用它来改进基于重新提交和复制技术的容错方法。 这种方法通常用于在分布在云端的工作流系统中实现容错。 改进基于引入称为重新提交影响的新算法。 重新提交和复制是广泛用于分布式系统容错的基本技术。 重新提交通过对失败资源或新资源重新执行单个任务来操作，这会显着增加任务完成时间。 复制将同一任务的多个副本同时执行到多个资源，并且存在资源使用率高的缺点。 为了<strong>在重新提交和复制之间找到平衡</strong>，该算法计算 RI（Replication Index） 启发式算法，该算法用于描述重新提交任务对工作流整体执行的影响。 RI 是为每个工作流程定义的，它用于推断生成的重复次数。 实验结果表明，与保守方法相比，RI 显着减少了超过 42% 的资源消耗。 除此之外，RI 不会对任务完成率和整体工作流性能产生负面影响。</p><h4 id="Custom-Exception-Handling"><a href="#Custom-Exception-Handling" class="headerlink" title="Custom Exception Handling"></a>Custom Exception Handling</h4><p>自定义异常处理包括软件开发人员将代码插入应用程序的方法，以便它可以在运行时处理特定故障 [50]。</p><p>刘等人。 [50] 提出了一个框架，用于解决通过业务流程执行语言 (BPEL) 引擎实现编排的事务性 Web 服务 (FACTS) 的容错问题。 Web服务主要用于开发现代商业应用程序。 FACTS 是六个组件的集合，即 EXTRA、WS-BPEL 设计器、规范模块、验证模块、实施模块和计划模块。 EXTRA 组件提供了一组高级异常处理策略，这些策略在标准的 WS-BPEL 内置异常和事务处理工具上运行。复合 Web 服务的容错需求通常源自业务需求。服务设计人员使用事件-条件-操作 (ECA) 规则来定义处理故障的逻辑。 ECA 规则又基于 EXTRA 模块中定义的异常策略。验证模块用于验证故障处理逻辑。它通过评估 ECA 规则必须遵守的原则来做到这一点。</p><h4 id="Rescue-Workflow"><a href="#Rescue-Workflow" class="headerlink" title="Rescue Workflow"></a>Rescue Workflow</h4><p>救援工作流是一种旨在解决基于工作流的系统容错的技术。 即使任务失败，工作流也可以继续，<strong>直到</strong>如果不处理失败的任务就无法继续 [51]、[52]。 对基于工作流的系统的容错机制更感兴趣的读者可以参考 [51]。 Hernandez 和 Cole [52] 提出了<strong>救援有向无环图</strong>（Rescue DAG），这是一种基于倒带和迁移的可靠工作流 DAG 调度机制。 该机制依赖于两个关键组件，即 DAG Manager (DAGMan) 和 Rescue DAG。 DAGMan 是元调度器，它负责管理整个工作流，包括将工作流调度到计算资源上。 DAGMan 还包含容错机制。 该机制执行 DAG 工作流失败部分的重新提交。 当一个 DAG 的任务失败时，DAG 中的剩余任务将继续执行，直到由于 DAG 工作流中的任务依赖性而无法继续执行。 在这种情况下，DAGMan 会输出一个名为 Rescue DAG 的特殊文件，其中包含有关成功任务和不成功任务的足够详细信息。 然后使用 Rescue DAG 来恢复工作流。 重新提交失败的任务。 成功的任务不会重新执行，因此可以节省计算资源和时间。</p><h4 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h4><p>负载均衡是云系统容错和运行的关键。 许多服务器在被客户端请求淹没后可能会因计算资源（CPU 或 RAM）耗尽而崩溃。 为了减少此类故障，云系统必须实施负载平衡作为负载保护的第一道防线 [53]、[54]、[55]、[56]。 传统的集中式负载均衡机制不适用于云系统。 云系统具有高度可扩展性，它们建立在分布式服务器上，这些服务器可以托管在多个数据中心（取决于云系统的架构）。 由于此类系统的规模和复杂性，无法将计算请求集中分配给服务器。 蜜蜂觅食行为 [55]、有偏随机抽样 [56] 和主动聚类 [53] 是云系统最常用的负载平衡算法。 分布式负载平衡算法通常具有内置机制，使它们能够协调公平地处理负载。 [54] 中介绍了这些算法的比较研究。</p><h4 id="N-Version-and-Recovery-Block"><a href="#N-Version-and-Recovery-Block" class="headerlink" title="N-Version and Recovery Block"></a>N-Version and Recovery Block</h4><p>N-version 是一种多版本编程模型。多个功能相同的程序是由不同的团队根据同一组需求规范开发的。团队独立工作，根本不交流。 N版本的思想是基于这样一个事实，即独立开发的程序大大降低了两个或多个版本中出现类似故障的概率。恢复块 (RB) 利用输入数据的不同表示来提供设计错误的容忍度 [57]、[58]、[59]、[60]、[61]。</p><p>N-Version 最近已进入云安全 [58] 和恶意攻击（反病毒 [57]）应用程序。 [60] 中介绍了 N 版本和容错之间关系的一些一般背景。 在接下来的段落中，我们将讨论一些研究工作，其中 N 版本技术已被用作云场景中容错的一部分。 </p><p>彭等。 [59] 回顾了增强型 N 版本编程 (ENVP) 和扩展恢复块 (ERB) 技术。 ENVP 和 ERB 可以联合用于提高 Web 服务 (WS) 的可靠性，因此它们对提高云系统的容错能力有直接的贡献。 ENVP 和 ERB 分别是其原始对应的 N 版本 (NVP) 和恢复块容错机制的扩展。 这些技术已经适用于为基于 WS 的容错系统提供支持。 NVP 通过利用多个功能等效的软件组件（或版本）提供容错能力。 另一方面，RB 使用不同的输入数据表示来容忍软件设计错误。</p><p>ENVP 和 ERB 的逻辑在中间件中实现，中间件负责处理服务用户（客户端）和服务提供者（服务）之间的交互。 NVP 和 RB 都通过在中间件中引入验收测试 (AT) 组件进行了扩展。 AT 组件用于在将 WS 的输出传递给决策管理器 (DM) 之前评估其输出的正确性。 实验结果表明，增加更多的 AT 组件可以提高系统的整体可靠性。</p><h3 id="Proactive-Methods"><a href="#Proactive-Methods" class="headerlink" title="Proactive Methods"></a>Proactive Methods</h3><p>主动方法持续监控系统并进行故障预测，以便在故障发生之前很好地预防故障的影响。 在监控中，系统不断地执行故障预测算法来评估系统的状态，以便采取必要的措施来防止故障。 对于运行在虚拟化环境中的云系统，此类故障管理技术更多地依赖于虚拟平台提供的迁移、暂停&#x2F;取消暂停功能。 根据当前文献，用于主动容错的关键技术包括软件更新、自我修复、抢先迁移、监控和 SGuard。 本节回顾了有关 PRM 的选定论文。</p><h4 id="Software-Rejuvenation"><a href="#Software-Rejuvenation" class="headerlink" title="Software Rejuvenation"></a>Software Rejuvenation</h4><p>软件更新 (SR) 是为定期重启而设计的 [62]、[63]、[64]，它基本上涉及优雅地终止系统并重新启动它。 SR 由另外两种技术补充：1）错误计数；和 2) N 版本编程。错误计数也称为“数黑羊”。这是一种在错误发生时对错误进行计数的技术，这些错误计数的记录会被保存下来，以便它可以用于升级和加速恢复过程。</p><h4 id="Self-Healing"><a href="#Self-Healing" class="headerlink" title="Self-Healing"></a>Self-Healing</h4><p>自愈技术是系统的一项功能，可以自动检测、诊断和修复软件和硬件故障。此类系统由部署在多个 VM 上的多个组件组成 [65]、[66]、[67]、[68]。</p><h4 id="Preemptive-Migration"><a href="#Preemptive-Migration" class="headerlink" title="Preemptive Migration"></a>Preemptive Migration</h4><p>抢先迁移是虚拟化环境的一种重要方法。它提供了将程序执行从一台机器实时迁移到另一台机器的机制。此技术可防止即将发生故障的系统组件影响系统的性能。这是通过监视和将组件从即将无法在更稳定的节点上运行的节点移开来实现的 [3]、[13]、[69]、[70]、[71]、[72]、[73] , [74], [75], [76], [77], [78]。 Applying preemptive migration for proactive FT [69] 提出了一种依赖于抢先迁移的主动容错方法的体系结构。</p><p>恩格尔曼等人。 [69] 定义了一种架构，该架构将服务器作为主动 FT 的基础。 该体系结构基于虚拟机（VM）的预先迁移，因此适用于云计算。 此外，还提供了实施选项的分类。 分类由实施所采用的监控策略定义。 该架构的核心是一个反馈回路控制机制，它构成了系统健康监测的一部分。 系统及其应用程序受到监控，并采取预防措施将应用程序组件从预计会发生故障的节点迁移到更健康的节点。 确定了监控系统健康状况的一些挑战。 其中一个关键挑战是每个解决方案目前都在使用自己的一组指标来测量和评估系统组件之间的健康和接口。 需要标准指标和接口。 </p><p>Nagarajan 等人。 [70] 为消息传递接口 (MPI) 应用程序的主动 FT 提供了一种自动和透明的机制。 该机制将虚拟化技术与健康监控和抢先迁移相结合，以实施主动 FT 解决方案。 使用了 XEN 虚拟化环境。 该解决方案利用 XEN 的实时迁移功能，允许客户操作系统与其正在运行的任务一起重新定位到另一个节点。 当检测到节点的健康状况恶化时，将触发迁移。 抢占式迁移机制运行良好，消除了迁移开销。 MPI 任务在迁移过程中继续执行。</p><p>刘等人。 [3] 提出了一种主动协调 FT (PCFT) 解决方案，旨在为并行云系统提供容错能力。 VM 协调机制用于预测恶化的物理机 (PM)。 恶化 PM 上的 VMS 迁移到最佳目标 PM。 机器性能下降的预测<strong>基于对 CPU 温度的监控</strong>。 该算法的复杂性在于找到一个最佳目标 PM，它必须确保效率、有效性和可扩展性要求。</p><h4 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h4><p>预测构成了主动容错算法的核心。提前预测故障，以便云系统有机会采取纠正措施来避免或减少故障的影响 [13]、[17]、[79]、[80]、[81]、[82] , [83], [84]。萨尔夫纳等。 [83]提供了一种通过调查的预测方法。 Tikotekar 等人提出了一个可用于评估各种 FT 方法和政策的模拟框架。 [84]。该框架非常重视使用预测组件的主动 FT。</p><p>瓦莱等人。 [13] 描述了主动容错的通用框架。 该框架基于故障预测，主要目标是避免故障。 当检测到故障时，系统会使用底层虚拟化平台的故障管理功能，例如暂停&#x2F;取消暂停或迁移进程或整个虚拟机节点。 故障预测器利用计算节点上的<strong>本地信息</strong>来预测当前发生故障的概率，故障预测器定期分析本地系统日志，如果检测到异常行为则产生告警事件。 进行了<strong>两个实验</strong>，作为证明该框架在进行迁移时对计算开销的有效性的一部分。 第一个实验是使用 XEN 虚拟化平台完成的，并测量了虚拟机占用空间对迁移成本的影响。 影响是根据虚拟机内存与总迁移时间（以秒为单位）的函数来衡量的。 第二个实验中，使用专为评估容错策略而设计的模拟器进行 [84]。 发现模拟结果与使用 XEN 的物理实验结果一致，得出的结论是该框架减少了计算开销。 </p><p>平托等人。 [17] 通过结合预测来增强 Hadoop 集群中的容错能力。 预测是使用<strong>支持向量机</strong> (SVM) 模型实现的。 SVM 是具有相关学习算法的监督学习模型，这些算法分析用于分类和回归分析的数据。 SVM 分类器托管在监控 PC 上，以对系统故障进行智能预测。 标准的 Hadoop 架构包括一个级别的容错，其中作业从故障节点重新安排到网络中的其他节点。 这会导致效率低下，因为它可能需要重新处理已经完成的子任务。 SVM 预测模型用于更早地预测故障，以便更早地做出重新安排工作的决策。 此外，还结合了强化学习模块以消除误报，从而显着增强集群的容错能力。 </p><p>哥斯达等人。 [79]描述了一种基于预测的主动容错解决方案，可以有效地避免内存错误。 该解决方案源于一项观察，即检查点&#x2F;重启可能无法有效地处理以千万亿次级执行的高性能计算中的内存故障。 这种方法嵌入到操作系统中。 它的工作原理是向操作系统公开可纠正的错误信息，迁移页面并使故障内存脱机以避免应用程序崩溃。 对内存错误模式进行分析，并使用可纠正的错误模式来预测可能发生故障的内存。 在 IBM 的 Blue Gene&#x2F;Q (BG&#x2F;Q) 系统上运行的 Linux 上实现了一个原型，该系统是一个 HPC 系统。</p><h4 id="Monitoring-Feedback-Loop"><a href="#Monitoring-Feedback-Loop" class="headerlink" title="Monitoring (Feedback Loop)"></a>Monitoring (Feedback Loop)</h4><p>监控主要用于<strong>补充</strong>其他主动算法。它用于监视正在运行的应用程序上的一组状态变量。状态变量被过滤并通过反馈循环机制 [14]、[85] 提供给策略管理器。</p><p>Egwutuoha 等人。 [14] 描述了一种主动技术，它依赖于监控为云中的 HPC 提供 FT。 这种 FT 技术的框架最初是由 Egwutuoha 等人提出的。 [85]。 根据这项研究，超过 50% 的 HPC 系统故障是由处理器、硬盘驱动器、集成电路插槽和内存引起的。 强调了与被动方法相比，HPC 计算中<strong>主动容错</strong>的优势。 与主要基于检查点和重启的反应式容错方法不同，主动容错避免了从检查点重启，因此<strong>降低</strong>了运营成本和能源消耗。 Egwutuoha 等人。 [14] 主要关注 MPI 应用程序。 MPI 应用程序实际上是在不同 CPU 或 VM 上并行运行的应用程序，它们通过消息传递交换数据来进行通信，例如 GROMACS 系统 [89]。 Egwutuoha 等人。 [14] 采用回避方法来容忍错误。 这是通过结合使用系统日志和健康监控设施来实现的。 系统日志提供有关可靠性、可用性和可服务性的信息，而健康监控则以硬件和软件的状态为主。 [14] 中提出的主动 FT 解决方案的架构由四种类型的模块组成：1）带有 lm 传感器的节点监控模块；2）故障预测器；3）主动容错策略模块； 4) 控制器模块。 [14] 还提出了容错算法的框架和一些结果的定量分析。 结果表明，通过实施此 FT 模型可显着节省成本。 节省的主要原因是由于立即放弃故障节点而节省了运营成本。</p><p>Park等。 [90] 描述了一种监控技术，可以作为移动云计算中容错的一部分应用。 虽然Park等人。 [90] 没有描述完整的容错技术，它提供了一种<strong>监控技术</strong>，该技术对于在移动云计算中实现 FT 非常有用。 移动云计算被描述为移动计算和云计算的结合。 在移动云计算的背景下，云计算是通过移动设备提供的。 移动设备上的遗留问题似乎已被克服，这些问题包括电池寿命短和 CPU 性能低下。 该论文确定了在移动云计算中使用移动设备的两类，即作为接口的移动设备和作为资源的移动设备。 大多数工作以前都是使用移动设备作为界面进行的，最近的趋势是使用移动设备作为托管云服务的资源。 使用移动设备作为资源面临着大多数与移动性相关的问题。 其中包括由于无线连接不稳定导致的波动性、电源限制、低网络带宽以及由于频繁的位置变化导致的切换问题。 因此，资源监控是在移动云计算中实现可靠的资源调度和容错技术的关键。 一种资源监控技术，需要收集和分析有关每个参与资源状态的动态信息并确保稳定性。 Park等。 [90] 提出了一种基于马尔可夫链的监控技术，旨在监控和分析资源状态。 <strong>主要目的</strong>是解决移动设备的波动性对容错问题的影响。</p><h4 id="SGuard"><a href="#SGuard" class="headerlink" title="SGuard"></a>SGuard</h4><p>SGuard 是一种基于回滚和恢复的技术，用于实时视频流。它对视频流的影响要小得多 [18]。</p><p>权等人。 [18] 向 SGuard 展示了一个弹性容错方法的示例，该方法由反应性故障技术（即检查点、回滚、恢复和复制）的合并形成。 SGuard 是一种相对较新的技术，用于处理部署在多个集群中的分布式流处理引擎 (SPE) 中的故障。这种部署模型类似于基于云的服务。这种方法使用回滚&#x2F;恢复技术来实现容错。在系统运行时，SGuard 在流服务运行时异步执行检查点。故障服务器根据最近的检查点回滚和恢复。故障服务器的检查点、回滚和恢复是<strong>异步</strong>发生的，不会造成任何服务中断。检查点状态保存在分布式文件系统 (DFS) 上，例如 GFS、HDFS 或 Amazon EC2。 SGuard 能够处理软件故障和硬件崩溃。为了掩盖故障，SGuard 进一步采用了复制技术。 SPE 的状态在多个服务器上复制，这些服务器被分类为主要或次要。因此，SGuard 为实时视频流提供了一种破坏性较小的容错解决方案。</p><h3 id="Resilient"><a href="#Resilient" class="headerlink" title="Resilient"></a>Resilient</h3><p>弹性方法使系统能够在出现故障时<strong>继续</strong>为客户端请求提供服务，并在<strong>可接受的时间段</strong>内快速恢复。 故障可能是设备故障、停电或中断造成的。 通常，弹性系统由组件组成，这些组件负责实现在出现故障时继续响应客户端的能力、系统状态的监控、学习和适应系统的能力。 Colman-Meixner 等人。 [91] 对应用于云架构不同层的弹性技术进行了全面调查。 系统监控组件对于密切关注系统状态以及检测和预测即将发生的故障至关重要。 弹性系统的<strong>目标</strong>是通过最大化系统的可用性来最小化系统的整体停机时间。 学习组件负责优化故障恢复，它通过使用环境参数来实现这一点，并使用它们来改进下次发生故障时的处理。 这样，系统就能够从环境中学习并调整其容错机制。</p><p>容错机制的适应通常涉及<strong>部署最佳资源</strong>以使系统避免完全中断。 系统可以在出现故障之前或之后按时<strong>动态</strong>地添加或删除容量。 本质上，弹性方法是通过将用于 RAM 和 PRM 的技术与通过与环境交互学习的能力<strong>相结合</strong>并<strong>适应容错</strong> [19]、[20]、[21]、[22] 、 [23]、[24]、[25]形成的。本节回顾了有关 RSM 的选定论文。</p><h4 id="Machine-Learning-Approaches"><a href="#Machine-Learning-Approaches" class="headerlink" title="Machine Learning Approaches"></a>Machine Learning Approaches</h4><p>机器学习带来了容错的智能方式。云系统能够通过与其环境交互来学习，并相应地调整其故障处理策略。强化学习似乎是 FT 领域中最常用的技术 [19]、[20]、[21]、[22]、[23]、[24]、[25]、[39]、[86]。本节中审查的大多数论文可能不会直接链接到云计算。然而，我们寻求确定信息来源，其中机器学习，特别是强化学习已被用于实施或提高系统的容错能力。这些想法可以很容易地扩展到云环境中。</p><p>董等人。 [86] 为基于优先级队列和动态路由的云提出了一种高度弹性的容错解决方案。该解决方案得到云敏捷性的进一步支持，即动态地动态配置或取消配置额外的云资源的能力。使用分类方法，云服务请求被分成高优先级请求和低优先级请求，并分别映射到高优先级队列和低优先级队列。分布式动态队列用于卸载本地和远程云节点上的请求。队列技术（例如 Rabbit MQ）增加了将请求移交到远程托管的云服务器上进行处理的能力。动态路由监视优先级队列上的负载，当优先级队列上的负载增加时，它会发出在远程站点上提供额外服务的信号。较低优先级队列（可以容忍高延迟的队列）上的服务请求被移交给辅助服务器处理。该解决方案在后端包括一个数据复制层，用于同步主从服务之间的数据，以便它们可以独立运行。</p><p>许等。 [20] 提出了 FT 的统一强化学习（URL）解决方案。 URL 是一种机器学习技术，用于为云计算自动配置 VM 和设备。 VM 是托管云系统的各种组件的虚拟机。 这些设备可以是任何基于 VM 的软件包，例如 Apache 或 Tomcat Web 设备。 VM 和设备都有大量的配置值。 配置这些值以获得最佳性能和可用性的过程很容易出错。 在论文 [20] 中，描述了两个强化学习智能体，即 VMAgent 和 App-Agent。 VM-Agent 用于重新配置 VM，App-Agent 用于重新配置设备。 每个智能体的行为都使用马尔可夫决策过程 (MDP) 建模。 每个智能体的状态被描述为 VM 或设备的配置参数向量。 由于系统的工作负载需求会随着时间的推移而变化，因此 URL 的<strong>目标</strong>是找到能够为给定工作负载产生最佳性能的良好配置。</p><p>吴等。 [21] 建议使用顺序共享学习 (OSL) 来增强弹性和 FT。 OSL 是一种用于作业调度的鲁棒多智能体强化学习 (MARL) 方法。尽管最初是为网格计算设计的，但 OSL 中的<strong>思想也可以应用于云计算</strong>。 OSL 具有高度可扩展性。 OSL 由在智能体之间迭代交换的轻量级和线性效用表组成。实用程序表用于跟踪处理计划作业的系统资源的效率。 OSL 需要非常少的网络通信带宽，智能体只交换作为每个智能体学习算法输入的效用表。 Scheduler Agent 由两个主要组件组成，即 Actor 和 Learner。 Actor 接收要调度的作业，它在队列中缓冲作业（作业缓冲区）并跟踪当前正在运行的作业（提交的作业列表）。 Leaner 收到共享效用表，它使用提交的作业列表中的信息来学习处理当前作业的资源的新分数。分数被更新，效用表被传递到网格中的相邻节点。这种方式可确保最佳性能和最可靠的资源处理作业，从而增强系统的弹性和容错能力。</p><p>Farivar 和 Ahmadabadi [19] 提出了两种策略，可用于设计鲁棒且自适应的容错控制 (FTC) 系统。 尽管 FTC 与云系统没有直接关系，但可以为云系统数据中心借鉴和实施机器学习（尤其是强化学习）和神经网络（NN）的思想和方式。 [22] 中考虑了在基于执行器的系统中使用 NN 进行容错控制的类似方法。 故障是由一些执行器和传感器产生的，这些执行器和传感器可以安装在典型的云数据中心中以监控各个方面，例如入侵和温度。 传感器可以扩展到包括软件定义的传感器，这些传感器可以监控各种软件定义的指标，例如流量或系统负载。 定义了两种 FTC 策略。 第一个策略涉及一个智能观察器，用于监视未知数量的非线性系统。 第二种策略是基于强化学习，它结合了一些未知的非线性故障系统和非线性控制理论来保证系统的稳定性和鲁棒性。 这种非线性系统可以建模为负责托管云系统的服务器基础设施。 进行了模拟，结果证实上述 FTC 策略表现良好。 此外，对于执行器故障，强化学习被发现比神经网络表现更好。 同样，神经网络在基于传感器的故障上的表现优于强化学习。</p><p>Forster 和 Murphy [23] 提出了到多个接收器的反馈路由 (FROMS)，这是一种基于强化学习的无线传感器网络 (WSN) 的基于机器学习的多播路由范例。这是通过将 WSN 中的多播路由建模为强化学习问题来实现的。尽管 WSN 不被视为与云计算直接相关，但有一种观点认为，连接不良的网络中的最终用户设备可以形成一个动态的 WSN 并使用它来访问云服务。在这种情况下，WSN 的容错解决方案可以通过使 WSN 更加健壮来帮助解决云系统的容错问题。 FROMS 基本上是 WSN 的路由协议。 FROMS 的优势包括在不同服务器条件下灵活地优化路由，例如路由长度、电池电量、故障后恢复以及对接收器移动性的支持。这些声明作为 [23] 中获得的实验结果的一部分得到了支持。</p><p>Wang 和 Usher [24] 描述了 RL 在基于智能体的计算中的应用。 RL 通常用于授权自主智能体学习选择适当的行动，通过与环境交互来实现其目标。动作的选择取决于要解决的问题。尽管与容错没有直接联系，Wang 和 Usher [24] 将 RL 应用于制造系统中的计算智能体。著名的 RL 算法 Q-Learning 用于使机器智能体能够学习普遍接受的调度规则，这依赖于先前定义的最佳调度规则。 RL 的这种应用可用于云计算中的容错。由于云计算包括许多不同类型的计算智能体，它们通过 Internet 访问服务。需要解决连接问题，尤其是在移动网络上。可以应用 Q-Learning 算法，使智能体能够根据可用网络接入点列表始终选择最可靠的 Internet 连接。</p><p>Chen 和 Marculescu [25] 提出了一种在线分布式强化学习 (OD-RL) 算法，用于在功率限制下提高多核系统的性能。 OD-RL 算法基于动态电压频率缩放 (DVFS) 技术以节省功率。大多数托管云服务的数据中心都部署在基于多核 (CPU) 系统的服务器基础设施中，因此 OD-RL 适用于云端。强化学习用于学习在 CPU 级别控制电压&#x2F;频率 (VF) 的最佳策略。定义了用于在更粗粒度全局级别管理功率预算级别的最大化-最大方法。我们更感兴趣的是 RL 在更细粒度 CPU 级别的应用。实验结果表明，OD-RL 可显着节省电能、提高吞吐量和能效。</p><h4 id="Fault-Induction"><a href="#Fault-Induction" class="headerlink" title="Fault Induction"></a>Fault Induction</h4><p>Limoncelli [87] 描述了术语反脆弱性以及故障诱导方法在谷歌和亚马逊等大公司中对 FT 的应用。 早在 2000 年代初，亚马逊就开始使用故障感应方法。 这是通过一个名为 GameDay 的程序完成的。 GameDay 是一个程序，旨在通过在给定时间故意使系统出现重大故障来提高弹性，以发现系统之间的缺陷和依赖关系。 GameDay 测试类似于组织中的消防演习。 GameDay 行动不仅关注计算机系统，还包括对软件和人员（暗示业务流程）的测试，目的是让他们为应对实际灾难事件做好准备。 GameDay 演习模拟了一场真实的灾难，因此参与者可以包括组织各个级别的工作人员 [87]。 GameDay 现象已被谷歌和亚马逊等大型组织积极使用。 GameDay 测试可以重复。 只有在重复测试时一切正常时，GameDay 练习才被标记为成功。 这种技术的部分成果是使组织能够从失败中学习。 使用 GameDay 方法已经取得了<strong>显着的成果</strong>。</p><h3 id="Strengths-and-Weaknesses"><a href="#Strengths-and-Weaknesses" class="headerlink" title="Strengths and Weaknesses"></a>Strengths and Weaknesses</h3><p>在本节中，我们将回顾容错方法的优缺点。传统方法的优点和缺点在文献中得到了很好的研究，这些包括 [26]、[12] 和 [31]。因此，在这篇评论中，我们将介绍<strong>机器学习特定方法</strong>的优缺点，因为这是一个新兴领域。</p><p>越来越多地使用云计算导致系统复杂性和规模呈指数级增长。这最终将导致传统的容错方法不再有效和可行的状态。因此，需要替代方法来处理云中的资源管理、安全性和能源效率等容错问题。本研究中审查的论文评估了各种机器学习算法，这些算法对云容错有不同的贡献。</p><p>机器学习提供了能够处理大量数据并不断学习和调整系统的工具和算法。 ML 由三个主要类别组成，即监督学习、无监督学习和强化学习 (RL)。 RL更适合实现控制优化类型的解决方案。因此，RL 是实现容错的首选 [19]、[23]、[92]。</p><p>通常，RL 算法分为两大类，即基于模型和无模型的方法 [93]。 基于模型的方法使用智能体与环境（云）交互的经验构建世界模型。 该模型用于学习价值函数。 无模型方法直接从与环境的交互中估计价值函数。 每个班级都有不同的长处和短处。 基于模型的方法的关键优势在于，在大多数情况下，他们找到了与环境交互较少的良好价值函数，因此通常被视为产生更好的性能，这被称为数据效率 [93]。 然而，这是有代价的，基于模型的方法通常需要更多的计算资源。 无模型方法的主要优势在于它们需要更少的计算资源，因此它们可以支持比基于模型的方法大得多的表示，这被称为计算效率。 无模型算法的另一个优势在于它们是可扩展的，它们随着代表环境的特征数量线性增长 [93]。</p><p>RL 的<strong>最终目标</strong>是学习用于管理智能体行为的最优策略。 RL 系统由许多智能体组成，这些智能体通过一些涉及与环境交互的反复试验的经验来学习。 RL 智能体通过最大化从动作价值函数获得的奖励来不断适应环境。智能体学习从每个系统状态采取的最佳行动。 RL 适用于状态数量极大、结构复杂的系统，因此适用于云系统。然而，此类系统的一个弱点是需要大量的计算资源，尤其是存储和内存。</p><p>一些著名的机器学习工具已与 RL 算法一起使用，包括 Q-Learning、人工神经网络 (ANN)、朴素贝叶斯、随机森林和深度学习 [15]。接下来我们看看使用每种容错解决方案的方法的优点和缺点。 </p><p>Q-Learning 是一种无模型方法，主要用于通过学习每个状态-动作转换的最佳 Q 因子来找到最佳策略。它主要应用于任何具有有限状态的马尔可夫决策过程[20]。 Q-Learning 的关键优势在于它是无模型的，而且实施起来非常直接。 Q-Learning 的主要弱点是跟踪每个 Q-factor 所需的存储量，尤其是当状态-动作对的数量增长太大时。</p><p>人工神经网络可用于补充 Q-Learning。当状态值对的数量太大并且因此不能有效地存储在 Q 因子列表中时，将应用 ANN。因此，给定动作的所有 Q 因子都存储在一个网络中。然而，训练 ANN 来表示 Q 因子可能既复杂又耗时。</p><p>支持向量机是最近应用于强化学习的数据挖掘工具的一个例子，特别是在需要分类或回归时 [94]。 SVM 的优势包括高水平的预测准确性，即使在训练示例包含错误时它们也能发挥作用。在弱点方面，SVM 需要很长的训练时间，学习到的函数很难理解，因为它以权重表示。</p><p>朴素贝叶斯是一种基于贝叶斯定理的分类器，它是基于模型的，可以与强化学习一起使用。它在模型不完全已知且存在不确定性的情况下很有用。朴素贝叶斯的主要优势在于它被认为是快速、健壮的并且可以处理不完整的模型。朴素贝叶斯可以处理非常大的数据集，并且优于许多其他复杂的分类器。朴素贝叶斯的一个主要弱点是它依赖贝叶斯定理，该定理假定所有属性（特征）都是独立的。这样的假设可能导致简单地忽略预测中属性相关性的影响。</p><p>深度强化学习是深度神经网络与 RL 的应用。当状态-动作对的数量变得太大时，这特别有用。不是为每个状态-动作对存储 Q 因子，而是使用深度神经网络来存储每个动作的 Q 因子，这些网络也称为深度 Q 网络 (DQN) [95]。这种方法的关键优势在于能够处理大数据，从而使 RL 能够扩展到以前难以解决的问题领域 [96]。同时，他们的主要弱点与训练时间有关。</p><p>随机森林是基于树的分类结构，已与 RL 一起使用。基于树的算法的优势包括显着减少分类错误（高度准确）和降低计算资源负载 [97]。它们可以处理相当大的特征变量，并且在大型数据库上非常有效。在大多数报道中，随机森林为学习函数近似提供了更好的收敛性 [97]。在弱点方面，随机森林会遇到由过度生长的树木引起的过度拟合问题。交叉验证可用于解决过度拟合问题 [98]。</p><h2 id="Emerging-directions"><a href="#Emerging-directions" class="headerlink" title="Emerging directions"></a>Emerging directions</h2><p>根据作为本研究的一部分审查的论文（见表 2），很明显，目前有大量的容错解决方案<strong>仍然主要基于被动和主动方法</strong>。在云系统的背景下，这些方法的性能、灵活性和可扩展性仍有待证明。对于其中一些方法，不确定它们将如何在部署在分布式和异构云平台上的系统上工作。当前的方法不可扩展，需要某种形式的手动干预才能顺利运行和配置，因此，我们建议云中容错的<strong>未来将基于自动化</strong>。</p><p>在尝试解决其中一些挑战时，我们开始看到基于智能体的云计算的出现作为解决自主云问题的一种手段 [99]。因此，我们认为基于智能体的解决方案（包括强化学习）是云中自主容错的新兴方向。智能体是一个功能齐全的计算节点，能够独立做出决策并通过合作、协调和协商与其他智能体进行交互[99]。我们正在见证基于智能体的<strong>自动化</strong>在云的各个核心方面的出现，例如资源分配 [100]、[101]、作业&#x2F;任务调度 [102]、[103] 和容错 [104]。此外，我们将继续看到高级机器学习技术（例如深度学习）的开发和应用，以支持基于智能体的自动化方法、硬件和基础设施监控 [105]、[106]、[107]、[108]、[ 109] 和弹性缓存 [110] 对自主容错有直接影响。</p><p>以下段落回顾了最近的一些论文，其中研究了与云计算和容错相关的基于智能体的计算和强化学习范例.</p><p>Sim [99] 介绍了基于智能体的云计算的概念，并解释了如何将基于智能体的计算范式应用于云计算基础设施和资源的管理。 根据 Sim [99]，基于智能体的云计算涉及构建云的服务发现、服务协商和服务组合功能。 服务发现由 Cloudle 实现，Cloudle 是一个基于智能体的云服务搜索引擎。 进一步表明，基于智能体的协商机制可用于实现服务协商和云商务。 此外，基于智能体的协作问题解决技术被证明可以解决自动化云服务组合的问题。 实验结果表明，使用基于智能体的云计算自动化方法，智能体在协商云资源方面取得了很高的利用率和成功率。 智能体也可以通过自主选择 Cloudle 机制支持的服务来成功组合云服务。</p><p>阿拉伯内贾德等人。 [101] 描述了另一种自动化方法，其中 RL 可用于自动化云中的动态资源分配问题。目标是实施一个云管理解决方案，该解决方案根据系统工作负载的波动进行自适应和自动缩放。强化学习用于决定何时添加或删除资源，同时仍然保证商定的系统 SLA。使用模糊逻辑方法。比较了两种基于模糊逻辑的动态学习策略，即模糊 SARSA 学习 (FSL) 和模糊 Q 学习 (FQL)。这两种方法都能够处理不同的工作负载模式，例如突发性和周期性工作负载。此外，FSL 和 FQL 能够按需交付资源，同时降低运营成本并避免违反 SLA。</p><p>Dal ılia 和 Coutinho [104] 提出了一种基于自主和强化学习的解决方案，以解决机会主义网格系统中复制和检查点之间的平衡问题。这些机会网格系统被定义为通过使用非专用计算资源的空闲处理能力动态形成的低成本和大型计算网格。此类非专用资源可以在地理上分布在许多不同的管理域中，并且此类资源随机加入和离开网格。因此，需要不断地监测和检测网格形成事件并及时做出反应。 RL 用于自动调整用于在检查点和复制之间切换的阈值。使用 RL，切换决策基于网格中计算节点的数量和可靠性。实验结果表明，该方法能够学习在复制和检查点之间切换的最佳阈值。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文回顾了在分布式或云系统中实现容错的各种方法。我们将容错方法分为三大类：<strong>1）反应性方法； 2) 主动方法； 3）弹性方法</strong>。反应式和主动式方法主要基于传统的容错方法，如复制、检查点、重试、监控和抢占式迁移。</p><p>其中一些方法已在一定程度上用于实现云系统的容错。 例如，大多数使用虚拟化技术的数据中心都依赖于抢占式迁移来处理由服务器中断引起的故障。 这些传统方法有局限性。 首先，它们基于固定的逻辑并以其实现定义的特定方式处理故障。 因此，它们缺乏处理未来可能出现的新故障的能力。 其次，这些实现在做出处理故障的决策时只考虑固有的系统属性。 对可能影响系统性能（例如温度、功率和天气）的外部或环境属性的考虑非常有限。</p><p>由于计算的未来正在向云迁移，系统将面临传统容错方法无法处理的故障。因此，需要开发能够通过与运行环境的交互来学习和适应的系统。此类系统将需要使用<strong>机器学习方法</strong>作为其容错解决方案的一部分。正如我们在本文中所见，机器学习已被用于创建容错解决方案。然而，机器学习主要用作整体容错解决方案的一个子组件。一些解决方案主要使用机器学习来使用一组定义的变量进行预测。在其他应用中，机器学习已被用于管理硬件故障。这样的系统又是固定的并且不够动态以处理未来和未知的故障。</p><p>需要通过定义可在云环境中用于处理故障的可重用框架，将机器学习的应用进一步扩展到容错。这样的框架将被称为智能云。智能云的主要组成部分将是任何一组相互关联的智能体，并通过与它们将在其中执行的环境交互来学习如何处理故障。作为此的直接结果，这些智能体将有权做出连接决策，从而使他们也能够最佳地利用能源。</p><p>本文将未来的研究方向归于自动化。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] M. Armbrust, A. Fox, R. Griffith, A. D. Joseph, R. Katz, A. Konwinski, G. Lee, D. Patterson, A. Rabkin, I. Stoica, and M. Zaharia, “A view of cloud computing,” Commun. ACM, vol. 53, no. 4, pp. 50–58, Apr. 2010. </p><p>[2] A. Abid, M. T. Khemakhem, S. Marzouk, M. B. Jemaa, T. Monteil, and K. Drira, “Toward antifragile cloud computing infrastructures,” Procedia Comput. Sci., vol. 32, pp. 850–855, 2014. </p><p>[3] J. Liu, S. Wang, A. Zhou, S. Kumar, F. Yang, and R. Buyya, “Using proactive fault-tolerance approach to enhance cloud service reliability,” IEEE Trans. Cloud Comput., vol. PP, no. 99, p. 1, 2017, doi: 10.1109&#x2F;TCC.2016.2567392. </p><p>[4] A. Zhou, S. Wang, B. Cheng, Z. Zheng, F. Yang, R. N. Chang, M. R. Lyu, and R. Buyya, “Cloud service reliability enhancement via virtual machine placement optimization,” IEEE Trans. Serv. Comput., vol. 10, no. 6, pp. 902–913, Nov. 2017. </p><p>[5] A. Zhou, S. Wang, Z. Zheng, C. H. Hsu, M. R. Lyu, and F. Yang, “On cloud service reliability enhancement with optimal resource usage,” IEEE Trans. Cloud Comput., vol. 4, no. 4, pp. 452–466, Oct. 2016. </p><p>[6] S. Ananth and A. Saranya, “Reliability enhancement for cloud services—A survey,” in Proc. Int. Conf. Comput. Commun. Inform., Jan. 2016, pp. 1–7. </p><p>[7] J. W. Lin, C. H. Chen, and J. M. Chang, “QoS-aware data replication for data-intensive applications in cloud computing systems,” IEEE Trans. Cloud Comput., vol. 1, no. 1, pp. 101–115, Jan. 2013. </p><p>[8] Z. Qiu and J. F. Prez, “Enhancing reliability and response times via replication in computing clusters,” in Proc. IEEE Int. Conf. Comput. Commun., Apr. 2015, pp. 1355–1363. </p><p>[9] P. Bodık, I. Menache, M. Chowdhury, P. Mani, D. A. Maltz, and I. Stoica, “Surviving failures in bandwidth-constrained datacenters,” in Proc. ACM SIGCOMM Conf. Appl. Technol. Archit. Protocols Comput. Commun., 2012, pp. 431–442. </p><p>[10] J. Liu, S. Wang, A. Zhou, F. Yang, and R. Buy, “Availabilityaware virtual cluster allocation in bandwidth-constrained datacenters,” IEEE Trans. Serv. Comput., vol. PP, no. 99, p. 1, 2017, doi: 10.1109&#x2F;TSC.2017.2694838. </p><p>[11] W. Qiu, Z. Zheng, X. Wang, X. Yang, and M. R. Lyu, “Reliabilitybased design optimization for cloud migration,” IEEE Trans. Serv. Comput., vol. 7, no. 2, pp. 223–236, Apr. 2014. </p><p>[12] P. K. Patra, H. Singh, and G. Singh, “Fault tolerance techniques and comparative implementation in cloud computing,” Int. J. Comput. Appl., vol. 64, no. 14, pp. 37–41, Feb. 2013. </p><p>[13] G. Vallee, K. Charoenpornwattana, C. Engelmann, A. Tikotekar, C. Leangsuksun, T. Naughton, and S. L. Scott, “A framework for proactive fault tolerance,” in Proc. 3rd Int. Conf. Availability Rel. Secur., Mar. 2008, pp. 659–664. </p><p>[14] I. Egwutuoha, S. Chen, D. Levy, B. Selic, and R. Calvo, “A proactive fault tolerance approach to high performance computing (HPC) in the cloud,” in Proc. Int. Conf. Cloud Green Comput., Nov. 2012, pp. 268–273. </p><p>[15] Z. Amin, H. Singh, and N. Sethi, “Review on fault tolerance techniques in cloud computing,” Int. J. Comput. Appl., vol. 116, no. 18, pp. 11–17, Apr. 2015. </p><p>[16] G. P. Sarmila, N. Gnanambigai, and P. Dinadayalan, “Survey on fault tolerant—Load balancing algorithms in cloud computing,” in Proc. Int. Conf. Electron. Commun. Syst., Feb. 2015, pp. 1715–1720. </p><p>[17] J. Pinto, P. Jain, and T. Kumar, “Hadoop distributed computing clusters for fault prediction,” in Proc. Int. Comput. Sci. Eng. Conf., Dec. 2016, pp. 1–6. </p><p>[18] Y. Kwon, M. Balazinska, and A. Greenberg, “Fault-tolerant stream processing using a distributed, replicated file system,” Proc. VLDB Endowment, vol. 1, no. 1, pp. 574–585, Aug. 2008. </p><p>[19] F. Farivar and M. N. Ahmadabadi, “Continuous reinforcement learning to robust fault tolerant control for a class of unknown nonlinear systems,” Appl. Soft Comput., vol. 37, pp. 702–714, 2015. </p><p>[20] C.-Z. Xu, J. Rao, and X. Bu, “URL: A unified reinforcement learning approach for autonomic cloud management,” J. Parallel Distrib. Comput., vol. 72, no. 2, pp. 95–105, 2012. </p><p>[21] J. Wu, X. Xu, P. Zhang, and C. Liu, “A novel multi-agent reinforcement learning approach for job scheduling in grid computing,” Future Generation Comput. Syst., vol. 27, no. 5, pp. 430–439, 2011. </p><p>[22] L. Liu, Z. Wang, and H. Zhang, “Adaptive NN fault-tolerant control for discrete-time systems in triangular forms with actuator fault,” Neurocomput., vol. 152, pp. 209–221, 2015. </p><p>[23] A. Forster and A. L. Murphy, “FROMS: A failure tolerant and mobility enabled multicast routing paradigm with reinforcement learning for WSNs,” Ad Hoc Netw., vol. 9, no. 5, pp. 940–965, 2011. </p><p>[24] Y.-C. Wang and J. M. Usher, “Application of reinforcement learning for agent-based production scheduling,” Eng. Appl. Artif. Intell., vol. 18, no. 1, pp. 73–82, 2005. </p><p>[25] Z. Chen and D. Marculescu, “Distributed reinforcement learning for power limited many-core system performance optimization,” in Proc. Des. Autom. Test Eur. Conf. Exhib., 2015, pp. 1521–1526. </p><p>[26] R. Jhawar and V. Piuri, “Chapter 1—Fault tolerance and resilience in cloud computing environments,” in Cyber Security and IT Infrastructure Protection, J. R. Vacca, Ed. Boston, MA, USA: Syngress, 2014, pp. 1–28. </p><p>[27] H. Okamura, Y. Nishimura, and T. Dohi, “A dynamic checkpointing scheme based on reinforcement learning,” in Proc. IEEE Pacific Rim Int. Symp. Depend. Comput., Mar. 2004, pp. 151–158. </p><p>[28] L. Bautista-Gomez, S. Tsuboi, D. Komatitsch, F. Cappello, N. Maruyama, and S. Matsuoka, “FTI: High performance fault tolerance interface for hybrid systems,” in Proc. ACM&#x2F;IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2011, pp. 32:132:32. </p><p>[29] A. Moody, G. Bronevetsky, K. Mohror, and B. R. D. Supinski, “Design, modeling, and evaluation of a scalable multi-level checkpointing system,” in Proc. ACM&#x2F;IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2010, pp. 1–11. </p><p>[30] S. Di, L. Bautista-Gomez, and F. Cappello, “Optimization of a multilevel checkpoint model with uncertain execution scales,” in Proc. ACM&#x2F;IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2014, pp. 907–918. </p><p>[31] D. Singh, J. Singh, and A. Chhabra, “High availability of clouds: Failover strategies for cloud computing using integrated checkpointing algorithms,” in Proc. Int. Conf. Commun. Syst. Netw. Technol., May 2012, pp. 698–703. </p><p>[32] A. J. Oliner, L. Rudolph, and R. K. Sahoo, “Cooperative checkpointing: A robust approach to large-scale systems reliability,” in Proc. ACM Annu. Int. Conf. Supercomput., 2006, pp. 14–23.</p><p>[33] S. Di, M. S. Bouguerra, L. Bautista-Gomez, and F. Cappello, “Optimization of multi-level checkpoint model for large scale HPC applications,” in Proc. IEEE Int. Parallel Distrib. Process. Symp., May 2014, pp. 1181–1190. </p><p>[34] B. Mohammed, M. Kiran, K. M. Maiyama, M. M. Kamala, and I.-U. Awan, “Failover strategy for fault tolerance in cloud computing environment,” Softw.: Practice Experience, vol. 47, no. 9, pp. 1243–1274, 2017. </p><p>[35] I. Jangjaimon and N. F. Tzeng, “Effective cost reduction for elastic clouds under spot instance pricing through adaptive checkpointing,” IEEE Trans. Comput., vol. 64, no. 2, pp. 396–409, Feb. 2015. </p><p>[36] J. Zhao, Y. Xiang, T. Lan, H. H. Huang, and S. Subramaniam, “Elastic reliability optimization through peer-to-peer checkpointing in cloud computing,” IEEE Trans. Parallel Distrib. Syst., vol. 28, no. 2, pp. 491–502, Feb. 2017. </p><p>[37] M. Amoon, “Adaptive framework for reliable cloud computing environment,” IEEE Access, vol. 4, pp. 9469–9478, 2016. </p><p>[38] B. Balasubramanian and V. K. Garg, “Fault tolerance in distributed systems using fused data structures,” IEEE Trans. Parallel Distrib. Syst., vol. 24, no. 4, pp. 701–715, Apr. 2013. </p><p>[39] B. Cully, G. Lefebvre, D. Meyer, M. Feeley, N. Hutchinson, and A. Warfield, “Remus: High availability via asynchronous virtual machine replication,” in Proc. USENIX Symp. Netw. Syst. Des. Implementation, 2008, pp. 161–174. </p><p>[40] W. Zhao, P. Melliar-Smith, and L. Moser, “Fault tolerance middleware for cloud computing,” in Proc. IEEE Int. Conf. Cloud Comput., Jul. 2010, pp. 67–74. </p><p>[41] T. Wood, R. Singh, A. Venkataramani, P. Shenoy, and E. Cecchet, “ZZ and the art of practical BFT execution,” in Proc. ACM EuroSys Conf. Comput. Syst., 2011, pp. 123–138. </p><p>[42] M. Castro and B. Liskov, “Practical byzantine fault tolerance and proactive recovery,” ACM Trans. Comput. Syst., vol. 20, no. 4, pp. 398–461, Nov. 2002. </p><p>[43] P. Costa, M. Pasin, A. Bessani, and M. Correia, “Byzantine faulttolerant MapReduce: Faults are not just crashes,” in Proc. IEEE Int. Conf. Cloud Comput. Technol. Sci., Nov. 2011, pp. 32–39. </p><p>[44] K. Plankensteiner, R. Prodan, and T. Fahringer, “A new fault tolerance heuristic for scientific workflows in highly distributed environments based on resubmission impact,” in Proc. IEEE Int. Conf. e-Sci., Dec. 2009, pp. 313–320. </p><p>[45] A. Zhou, S. Wang, C.-H. Hsu, M. H. Kim, and K.-S. Wong, “Network failure-aware redundant virtual machine placement in a cloud data center,” Concurrency Comput.: Practice Experience, vol. 29, no. 24, 2017, Art. no. e4290. </p><p>[46] Z. Zheng, T. C. Zhou, M. R. Lyu, and I. King, “Component ranking for fault-tolerant cloud applications,” IEEE Trans. Serv. Comput., vol. 5, no. 4, pp. 540–550, Oct.–Dec. 2012. </p><p>[47] R. Jhawar, V. Piuri, and M. Santambrogio, “Fault tolerance management in cloud computing: A system-level perspective,” IEEE Syst. J., vol. 7, no. 2, pp. 288–297, Jun. 2013. </p><p>[48] C. Wang, L. Xing, H. Wang, Z. Zhang, and Y. Dai, “Processing time analysis of cloud services with retrying fault-tolerance technique,” in Proc. IEEE Int. Conf. Commun. China, Aug. 2012, pp. 63–67. </p><p>[49] G. Ramalingam and K. Vaswani, “Fault tolerance via idempotence,” SIGPLAN Notices, vol. 48, no. 1, pp. 249–262, Jan. 2013. </p><p>[50] A. Liu, Q. Li, L. Huang, and M. Xiao, “Facts: A framework for fault-tolerant composition of transactional web services,” IEEE Trans. Serv. Comput., vol. 3, no. 1, pp. 46–59, Jan. 2010. </p><p>[51] J. Yu and R. Buyya, “A taxonomy of scientific workflow systems for grid computing,” ACM SIGMOD Rec., vol. 34, no. 3, pp. 4449, Sep. 2005. </p><p>[52] I. Hernandez and M. Cole, “Reliable DAG scheduling on grids with rewinding and migration,” in Proc. ICST Int. Conf. Netw. Grid Appl., 2007, pp. 3:1–3:8. </p><p>[53] F. Saffre, R. Tateson, J. Halloy, M. Shackleton, and J. L. Deneubourg, “Aggregation dynamics in overlay networks and their implications for self-organized distributed applications,” Comput. J.,vol.52,no. 4, pp. 397–412, Jul. 2009. </p><p>[54] M. Randles, D. Lamb, and A. Taleb-Bendiab, “A comparative study into distributed load balancing algorithms for cloud computing,” in Proc. IEEE Int. Conf. Adv. Inf. Netw. Appl. Workshops, Apr. 2010, pp. 551–556. </p><p>[55] M. Randles, A. Taleb-Bendiab, and D. Lamb, “Scalable selfgovernance using service communities as ambients,” in Proc. World Conf. Services-I, Jul. 2009, pp. 813–820. </p><p>[56] O. Rahmeh, P. Johnson, and A. Taleb-Bendiab, “A dynamic biased random sampling scheme for scalable and reliable grid networks,” INFOCOMP J. Comput. Sci., vol. 7, no. 4, pp. 1–10, 2008. </p><p>[57] J. Oberheide, E. Cooke, and F. Jahanian, “CloudAV: N-version antivirus in the network cloud,” in Proc. USENIX Conf. Secur. Symp., 2008, pp. 91–106. </p><p>[58] J. Oberheide, K. Veeraraghavan, E. Cooke, J. Flinn, and F. Jahanian, “Virtualized in-cloud security services for mobile devices,” in Proc. ACM Workshop Virtualization Mobile Comput., 2008, pp. 31–35. </p><p>[59] K.-L. Peng, C.-Y. Huang, P.-H. Wang, and C.-J. Hsu, “Enhanced N-version programming and recovery block techniques for web service systems,” in Proc. ACM Int. Workshop Innovative Softw. Develop. Methodologies Practices, 2014, pp. 11–20. </p><p>[60] A. Avizienis, “The N-version approach to fault-tolerant software,” IEEE Trans. Softw. Eng., vol. 11, no. 12, pp. 1491–1501, Dec. 1985. </p><p>[61] P. Hosek and C. Cadar, “VARAN the unbelievable: An efficient N-version execution framework,” in Proc. ACM Int. Conf. Archit. Support Program. Languages Operating Syst., 2015, pp. 339–353. </p><p>[62] R. Hanmer, “Software rejuvenation,” in Proc. ACM Conf. Pattern Languages Programs, 2010, pp. 21:1–21:13. </p><p>[63] M. Melo, J. Araujo, R. Matos, J. Menezes, and P. Maciel, “Comparative analysis of migration-based rejuvenation schedules on cloud availability,” in Proc. IEEE Int. Conf. Syst. Man Cybern., Oct. 2013, pp. 4110–4115. </p><p>[64] F. Xin-Yuan, X. Guo-Zhi, Y. Ren-Dong, Z. Hao, and J. Le-Tian, “Performance analysis of software rejuvenation,” in Proc. Int. Conf. Parallel Distrib. Comput. Appl. Technol., Aug. 2003, pp. 562–566. </p><p>[65] R. Angarita, M. Rukoz, M. Manouvrier, and Y. Cardinale, “A knowledge-based approach for self-healing service-oriented applications,” in Proc. ACM Int. Conf. Manage. Digit. EcoSyst., 2016, pp. 1–8. </p><p>[66] J. O. Kephart and D. M. Chess, “The vision of autonomic computing,” Comput., vol. 36, no. 1, pp. 41–50, Jan. 2003. </p><p>[67] S. Dobson, R. Sterritt, P. Nixon, and M. Hinchey, “Fulfilling the vision of autonomic computing,” Comput., vol. 43, no. 1, pp. 3541, Jan. 2010. </p><p>[68] S. George, D. Evans, and L. Davidson, “A biologically inspired programming model for self-healing systems,” in Proc. ACM Workshop Self-Healing Syst., 2002, pp. 102–104. </p><p>[69] C. Engelmann, G. Vallee, T. Naughton, and S. Scott, “Proactive fault tolerance using preemptive migration,” in Proc. Euromicro Int. Conf. Parallel Distrib. Netw.-Based Process., Feb. 2009, pp. 252–257. </p><p>[70] A. B. Nagarajan, F. Mueller, C. Engelmann, and S. L. Scott, “Proactive fault tolerance for HPC with Xen virtualization,” in Proc. ACM Annu. Int. Conf. Supercomput., 2007, pp. 23–32. </p><p>[71] F. Hao, T. V. Lakshman, S. Mukherjee, and H. Song, “Enhancing dynamic cloud-based services using network virtualization,” in Proc. ACM Workshop Virtualized Infrastructure Syst. Archit., 2009, pp. 37–44. </p><p>[72] T. Wood, K. K. Ramakrishnan, P. Shenoy, and J. van der Merwe, “CloudNet: Dynamic pooling of cloud resources by live wan migration of virtual machines,” ACM SIGPLAN Notices, vol. 46, no. 7, pp. 121–132, Mar. 2011. </p><p>[73] P. Lu, A. Barbalace, and B. Ravindran, “HSG-LM: Hybrid-copy speculative guest OS live migration without hypervisor,” in Proc. ACM Int. Syst. Storage Conf., 2013, pp. 2:1–2:11. </p><p>[74] G. Dhiman, G. Marchetti, and T. Rosing, “vGreen: A system for energy-efficient management of virtual machines,” ACM Trans. Des. Autom. Electron. Syst., vol. 16, no. 1, pp. 6:1–6:27, Nov. 2010. </p><p>[75] T. Knauth and C. Fetzer, “VeCycle: Recycling VM checkpoints for faster migrations,” in Proc. ACM Annu. Middleware Conf., 2015, pp. 210–221. </p><p>[76] J. Li, C. Pu, Y. Chen, V. Talwar, and D. Milojicic, “Improving preemptive scheduling with application-transparent checkpointing in shared clusters,” in Proc. ACM Annu. Middleware Conf., 2015, pp. 222–234. </p><p>[77] A. Polze, P. Troger, and F. Salfner, “Timely virtual machine migration for pro-active fault tolerance,” in Proc. IEEE Int. Symp. Object&#x2F; Component&#x2F;Service-Oriented Real-Time Distrib. Comput. Workshops, Mar. 2011, pp. 234–243. </p><p>[78] Y. Zhong, J. Xu, Q. Li, H. Zhang, and F. Liu, “Memory state transfer optimization for pre-copy based live VM migration,” in Proc. IEEE Workshop Adv. Res. Technol. Ind. Appl., Sep. 2014, pp. 290–293. </p><p>[79] C. H. A. Costa, Y. Park, B. S. Rosenburg, C.-Y. Cher, and K. D. Ryu, “A system software approach to proactive memory-error avoidance,” in Proc. IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2014, pp. 707–718.</p><p>[80] A. Gainaru, F. Cappello, M. Snir, and W. Kramer, “Fault prediction under the microscope: A closer look into HPC systems,” in Proc. IEEE Int. Conf. High Perform. Comput. Netw. Storage Anal., 2012, pp. 77:1–77:11. </p><p>[81] O. Hannache and M. Batouche, “Probabilistic model for evaluating a proactive fault tolerance approach in the cloud,” in Proc. IEEE Int. Conf. Service Operations Logistics Informat., Nov. 2015, pp. 94–99. </p><p>[82] R. Rajachandrasekar, X. Besseron, and D. K. Panda, “Monitoring and predicting hardware failures in HPC clusters with FTBIPMI,” in Proc. IEEE Int. Parallel Distrib. Process. Symp. Workshops PhD Forum, May 2012, pp. 1136–1143. </p><p>[83] F. Salfner, M. Lenk, and M. Malek, “A survey of online failure prediction methods,” ACM Comput. Surveys, vol. 42, no. 3, pp. 10:1–10:42, Mar. 2010. </p><p>[84] A. Tikotekar, G. Vallee, T. Naughton, S. Scott, and C. Leangsuksun, “Evaluation of fault-tolerant policies using simulation,” in Proc. IEEE Int. Conf. Cluster Comput., Sep. 2007, pp. 303–311. </p><p>[85] I. Egwutuoha, S. Chen, D. Levy, and B. Selic, “A fault tolerance framework for high performance computing in cloud,” in Proc. IEEE&#x2F;ACM Int. Symp. Cluster Cloud Grid Comput., May 2012, pp. 709–710. </p><p>[86] T. Tung, S. Y. Chaw, Q. Xie, and Q. Zhu, “Highly resilient systems for cloud,” in Proc. IEEE Int. Conf. Web Serv., Jun. 2012, pp. 678–680. </p><p>[87] T. Limoncelli, “Resilience engineering: Learning to embrace failure,” Commun. ACM, vol. 55, no. 11, pp. 40–47, Nov. 2012. </p><p>[88] A. Benso and P. Prinetto, Eds., Fault Injection Techniques and Tools for Embedded Systems Reliability Evaluation. Berlin, Germany: Springer, 2003. </p><p>[89] H. J. C. Berendsen, D. V. D. Spoel, and R. V. Drunen, “GROMACS: A message-passing parallel molecular dynamics implementation,” Comput. Phys. Commun., vol. 91, pp. 43–56, 1995. </p><p>[90] J. Park, H. Yu, K. Chung, and E. Lee, “Markov chain based monitoring service for fault tolerance in mobile cloud computing,” in Proc. IEEE Workshops Int. Conf. Adv. Inf. Netw. Appl., Mar. 2011, pp. 520–525. </p><p>[91] C. Colman-Meixner, C. Develder, M. Tornatore, and B. Mukherjee, “A survey on resiliency techniques in cloud computing infrastructures and applications,” IEEE Commun. Surveys Tuts.,vol.18,no.3, pp. 2244–2281, Jul.–Sep. 2016. </p><p>[92] H. Li and S. Venugopal, “Using reinforcement learning for controlling an elastic web application hosting platform,” in Proc. ACM Int. Conf. Autonomic Comput., 2011, pp. 205–208. </p><p>[93] R. S. Sutton and A. G. Barto, Reinforcement Learning : An Introduction. Cambridge, MA, USA: MIT Press, 1998. </p><p>[94] T. G. Dietterich and X. Wang, Support Vectors for Reinforcement Learning. Berlin, Germany: Springer, 2001, pp. 600–600. </p><p>[95] Y. Li, “Deep reinforcement learning: An overview,” CoRR, vol. abs&#x2F;1701.07274, 2017, <a href="http://arxiv.org/abs/1701.07274">http://arxiv.org/abs/1701.07274</a> </p><p>[96] K. Arulkumaran, M. P. Deisenroth, M. Brundage, and A. A. Bharath, “Deep reinforcement learning: A brief survey,” IEEE Signal Process. Mag., vol. 34, no. 6, pp. 26–38, Nov. 2017, doi: 10.1109&#x2F;MSP.2017.2743240. </p><p>[97] A. Paul and D. P. Mukherjee, “Reinforced random forest,” in Proc. ACM Indian Conf. Comput. Vis. Graph. Image Process., 2016, pp. 1:1–1:8. </p><p>[98] P. Domingos, “A few useful things to know about machine learning,” Commun. ACM, vol. 55, no. 10, pp. 78–87, Oct. 2012. </p><p>[99] K. M. Sim, “Agent-based cloud computing,” IEEE Trans. Serv. Comput., vol. 5, no. 4, pp. 564–577, Oct.–Dec. 2012. </p><p>[100] K. M. SIM, “Agent-based approaches for intelligent intercloud resource allocation,” IEEE Trans. Cloud Comput., vol. PP, no. 99, p. 1, 2016, doi: 10.1109&#x2F;TCC.2016.2628375. </p><p>[101] H. Arabnejad, C. Pahl, P. Jamshidi, and G. Estrada, “A comparison of reinforcement learning techniques for fuzzy cloud autoscaling,” in Proc. IEEE&#x2F;ACM Int. Symp. Cluster Cloud Grid Comput., May 2017, pp. 64–73. </p><p>[102] D. Cui, Z. Peng, X. Jianbin, B. Xu, and W. Lin, “A reinforcement learning-based mixed job scheduler scheme for grid or IaaS cloud,” IEEE Trans. Cloud Comput., vol. PP, no. 99, p. 1, 2017, doi: 10.1109&#x2F;TCC.2017.2773078. </p><p>[103] L. Wang and E. Gelenbe, “Adaptive dispatching of tasks in the cloud,” IEEE Trans. Cloud Comput., vol. 6, no. 1, pp. 33–45, Jan. 2018, doi: 10.1109&#x2F;TCC.2015.2474406. </p><p>[104] A. Dalılia and L. R. Coutinho, “A fault tolerance approach based on reinforcement learning in the context of autonomic opportunistic grids,” in Proc. Int. Conf. Autonomic Auton. Syst., 2014, pp. 11–17. </p><p>[105] J. F. Murray, G. F. Hughes, and D. Schuurmans, “Machine learning methods for predicting failures in hard drives: A multipleinstance application,” J. Mach. Learn. Res., vol. 6, 2005, Art. no. 816. </p><p>[106] Y. Zhao, X. Liu, S. Gan, and W. Zheng, “Predicting disk failures with HMM- and HSMM-based approaches,” in Proc. Int. Conf. Adv. Data Mining. Appl. Theoretical Aspects, 2010, pp. 390–404. </p><p>[107] B. Zhu, G. Wang, X. Liu, D. Hu, S. Lin, and J. Ma, “Proactive drive failure prediction for large scale storage systems,” in Proc. IEEE Symp. Mass Storage Syst. Technol., 2013, pp. 1–5. </p><p>[108] Y. Wang, Q. Miao, E. Ma, K.-L. Tsui, and M. Pecht, “Online anomaly detection for hard disk drives based on Mahalanobis distance,” IEEE Trans. Rel., vol. 62, no. 1, pp. 136–145, Mar. 2013. </p><p>[109] J. Li, X. Ji, Y. Jia, B. Zhu, G. Wang, Z. Li, and X. Liu, “Hard drive failure prediction using classification and regression trees,” in Proc. IEEE&#x2F;IFIP Int. Conf. Depend. Syst. Netw., 2014, pp. 383–394.</p><p>[110] X. Qin, W. Zhang, W. Wang, J. Wei, H. Zhong, and T. Huang, “On-line cache strategy reconfiguration for elastic caching platform: A machine learning approach,” in Proc. IEEE Annu. Comput. Softw. Appl. Conf., Jul. 2011, pp. 523–534.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 容错 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 工作流调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode108.将有序数组转换为二叉搜索树</title>
      <link href="/2023/03/26/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2023/03/26/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/btree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/btree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归构造树</li></ul><p>在这个实现中，我们采用了递归的方法构建高度平衡的二叉搜索树。在每次递归中，我们找到当前子数组的中间元素作为根节点，然后递归构建左右子树，最后将根节点返回。在递归过程中，我们使用两个指针 <code>left</code> 和 <code>right</code> 分别表示当前子数组的左右边界。如果 <code>left &gt; right</code>，则说明当前子数组为空，递归结束，返回 <code>nullptr</code>。C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F; 调用buildBST函数        return buildBST(nums, 0, nums.size() - 1);    &#125;private:    TreeNode* buildBST(vector&lt;int&gt;&amp; nums, int left, int right) &#123;        if (left &gt; right) &#123;            &#x2F;&#x2F; 若left &gt; right 则直接返回空指针            return nullptr;         &#125;        int mid &#x3D; left + (right - left) &#x2F; 2; &#x2F;&#x2F; 寻找mid的大小，将nums[mid]作为树的根节点        TreeNode* root &#x3D; new TreeNode(nums[mid]); &#x2F;&#x2F; 新建根节点，节点的值为nums[mid]        &#x2F;&#x2F; 递归调用buildBST函数构造left和right树，并将其赋值给root-&gt;left和root-&gt;right        root-&gt;left &#x3D; buildBST(nums, left, mid - 1);         root-&gt;right &#x3D; buildBST(nums, mid + 1, right);        &#x2F;&#x2F; 返回根节点        return root;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode214.最短回文串</title>
      <link href="/2023/03/23/leetcode214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2023/03/23/leetcode214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <em><strong>s</strong></em>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;aacecaaa&quot;输出：&quot;aaacecaaa&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;输出：&quot;dcbabcd&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>KMP算法求解</li></ul><p>本题可以通过将原字符串翻转后与原字符串拼接，然后在新的字符串中找到以原字符串开头的最长回文子串，最后将翻转字符串的前缀加到原字符串前面即可得到新的字符串。为了找到以原字符串开头的最长回文子串，可以使用KMP算法中的next数组，将新的字符串l的next数组求出来，那么l.size() - 1位置处的值就是以原字符串开头的最长回文子串的长度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string shortestPalindrome(string s) &#123;        &#x2F;&#x2F; 将字符串s翻转并存储在rev_s中        string rev_s &#x3D; s;        reverse(rev_s.begin(), rev_s.end());        &#x2F;&#x2F; 将s和rev_s拼接，并用“#”分割        string l &#x3D; s + &quot;#&quot; + rev_s;        &#x2F;&#x2F; 初始化一个大小为l.size()的数组p        vector&lt;int&gt; p(l.size(), 0);        &#x2F;&#x2F; 通过循环遍历l，求出p数组        for (int i &#x3D; 1; i &lt; l.size(); i++) &#123;            int j &#x3D; p[i - 1];            while (j &gt; 0 &amp;&amp; l[i] !&#x3D; l[j]) j &#x3D; p[j - 1];            p[i] &#x3D; (j +&#x3D; l[i] &#x3D;&#x3D; l[j]);        &#125;        &#x2F;&#x2F; 返回一个由rev_s的前缀和s组成的新字符串        return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;    &#125;&#125;;</code></pre><blockquote><p>以输入<code>s=&quot;aacecaaa&quot;</code>为例，说明代码的运行过程：</p><p>首先将字符串s翻转得到rev_s&#x3D;”aaacecaa”，然后将s和rev_s用”#”分割拼接起来得到l&#x3D;”aacecaaa#aaacecaa”。</p><p>然后初始化一个大小为l.size()的数组p，数组中每个元素表示对应位置之前的字符串的最长相同前缀后缀的长度。</p><p>接下来使用KMP算法的思想，通过遍历l来求得数组p的所有元素。从i&#x3D;1开始，依次比较l[i]和l[p[i-1]]，如果不相同，则令j&#x3D;p[i-1]，并循环将j更新为p[j-1]，直到j&#x3D;0或者找到一个位置k使得l[i]和l[k]相等。如果找到了k，则令p[i]&#x3D;k+1，否则令p[i]&#x3D;0。</p><p>经过上述循环遍历后，p数组的最后一个元素p[l.size()-1]表示以原字符串开头的最长回文子串的长度，即3。因此，可以将rev_s的前缀”aa”加到s的前面，得到新的字符串为”aaacecaaa”，这个字符串是由原字符串”aacecaaa”通过添加最少字符得到的回文串。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode151.反转字符串中的单词</title>
      <link href="/2023/03/22/leetcode151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
      <url>/2023/03/22/leetcode151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><span id="more"></span> <p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;  hello world  &quot;输出：&quot;world hello&quot;解释：反转后的字符串中不能存在前导空格和尾随空格。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;a good   example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>暴力解法</li></ul><p>大致思路：将字符串中的每个单词放入动态数组中，然后将动态数组倒序遍历得到结果字符串，最后返回结果字符串，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseWords(string s) &#123;        &#x2F;&#x2F; 特判：如果s的长度为1，则只包含一个单词，此时直接返回s即可        if (s.length() &#x3D;&#x3D; 1) return s;        &#x2F;&#x2F; 新建s_vec动态数组，元素类型为string        vector&lt;string&gt; s_vec;        &#x2F;&#x2F; 定义left，它是指向字符串里第一个单词的第一个字母的指针        int left &#x3D; 0; &#x2F;&#x2F; left的初始化        while (s[left] &#x3D;&#x3D; &#39; &#39;) &#123;            left++;  &#x2F;&#x2F; 防止字符串一开始就是空格        &#125;        &#x2F;&#x2F; 开始循环        for (int i &#x3D; left; i &lt; s.length(); i++) &#123;            &#x2F;&#x2F; 当i指向一个单词右边的第一个空格或者字符串的最后一个元素时            if (s[i] &#x3D;&#x3D; &#39; &#39; || i &#x3D;&#x3D; s.length() - 1) &#123;                if (i &#x3D;&#x3D; s.length()-1) i++; &#x2F;&#x2F; 当i指向字符串的最后一个字母时，需要自增1，否则无法通过substr获得子串                string temp &#x3D; s.substr(left, i - left); &#x2F;&#x2F; 使用substr获得子串                s_vec.push_back(temp); &#x2F;&#x2F; 将子串push进动态数组s_vec中                while (s[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; i &lt; s.length()) &#123;                    i++; &#x2F;&#x2F; 令i从其之后的第一个非空字母开始遍历                &#125;                left &#x3D; i; &#x2F;&#x2F; 更新left的值            &#125;        &#125;        if (s[s.length()-1] !&#x3D; &#39; &#39; &amp;&amp; s[s.length()-2] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 针对字符串最后的一个单词只有一个字母的特判            string temp &#x3D; s.substr(s.length()-1);            s_vec.push_back(temp);        &#125;        int n &#x3D; s_vec.size(); &#x2F;&#x2F; 获取动态数组的大小（也就是总的单词个数）        string result; &#x2F;&#x2F; 定义结果字符串        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123; &#x2F;&#x2F; 反向遍历，将结果同result相加            if (i &#x3D;&#x3D; n - 1) &#123; &#x2F;&#x2F; 第一个单词前无需加空格                result &#x3D; result + s_vec[i];            &#125;            else &#123; &#x2F;&#x2F; 其他单词在同result合并前需要先加一个空格                result &#x3D; result + &quot; &quot; + s_vec[i];             &#125;        &#125;        return result; &#x2F;&#x2F; 返回result字符串    &#125;&#125;;</code></pre><ul><li>空间复杂度为O(1)的解法</li></ul><ol><li>将整个字符串进行反转</li><li>将反转后的字符串的每个单词进行反转</li><li>去除字符串中多余的空格</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseWords(string s) &#123;        reverse(s.begin(), s.end()); &#x2F;&#x2F; 翻转整个字符串        int n &#x3D; s.size();        int idx &#x3D; 0;        for (int start &#x3D; 0; start &lt; n; ++start) &#123;            if (s[start] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 找到单词的起始位置                if (idx !&#x3D; 0) s[idx++] &#x3D; &#39; &#39;; &#x2F;&#x2F; 添加单词间空格                int end &#x3D; start;                while (end &lt; n &amp;&amp; s[end] !&#x3D; &#39; &#39;) s[idx++] &#x3D; s[end++]; &#x2F;&#x2F; 翻转单词                reverse(s.begin() + idx - (end - start), s.begin() + idx); &#x2F;&#x2F; 翻转单词                start &#x3D; end;            &#125;        &#125;        s.erase(s.begin() + idx, s.end()); &#x2F;&#x2F; 删除多余的空格        return s;    &#125;&#125;;</code></pre><blockquote><p>当我们调用reverse函数时，它会将字符串中的字符进行翻转。例如，如果我们有一个字符串”hello”，那么调用reverse函数后，它会变成”olleh”。在这个题目中，我们需要将整个字符串进行翻转，所以我们调用了reverse(s.begin(), s.end())函数来实现这个功能。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于改进差分进化算法的云端科学工作流调度自适应故障检测策略</title>
      <link href="/2023/03/21/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%91%E7%AB%AF%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%B0%83%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5/"/>
      <url>/2023/03/21/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%91%E7%AB%AF%E7%A7%91%E5%AD%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%B0%83%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="基于改进差分进化算法的云端科学工作流调度自适应故障检测策略"><a href="#基于改进差分进化算法的云端科学工作流调度自适应故障检测策略" class="headerlink" title="基于改进差分进化算法的云端科学工作流调度自适应故障检测策略"></a>基于改进差分进化算法的云端科学工作流调度自适应故障检测策略</h2><p>原题目：An adaptive fault detector strategy for scientific workflow scheduling based on improved differential evolution algorithm in cloud</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>讨论了在云计算环境中执行大规模科学工作流程的挑战，并提出了一种基于改进差分进化算法的<strong>自适应故障检测器策略</strong>，以最小化能源消耗、总成本和时间，并在调度科学工作流程时<strong>容忍故障</strong>。此外，该文章还介绍了一种自适应基于网络的模糊推理系统（ANFIS）预测模型，用于主动控制资源负载波动并提高故障预测准确性。</p><span id="more"></span><p><strong>通过对文章的阅读了解容错到底是什么</strong></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>介绍了在大规模的云计算环境中，错误会导致用于计算的虚拟机不可用，因此，通过提出一个有效且高效的容错策略来对错误发生时的问题进行处理是很有必要的。</p><p>传统方法进行容错的实现是需要了解云计算结构以及大量的知识和经验的，在实施时代价昂贵，且在缺少建模的条件下无法准确地进行容错评估。</p><p>在很多现实世界的工作流调度中，多目标优化方法可以用于优化虚拟机的任务调度以满足用户需求。然而大多数的现有方法并未考虑到容错技术的使用。</p><p>Differential evolution算法很高效，但也有陷入局部最优以及收敛过慢的问题，因此本文通过优化F和CR参数来解决这些问题</p><p>总的来说，本文的贡献是提出了一种自适应故障容错工作流调度方法，该方法基于改进差分进化算法和多目标IDE算法，结合主动和反应技术。该方法通过应用自适应基于网络的模糊推理系统（ANFIS）预测模型来预测未来资源负载，从而主动控制资源负载波动并提高故障预测准确性。此外，在故障&#x2F;失败发生后，该方法还通过反应性容错控制器来保证应用程序执行的可靠性。这种方法可以最小化能源消耗、总成本和时间，并在调度科学工作流程时容忍故障。</p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>本文的相关工作主要讨论了故障检测和容错技术在云计算环境中的应用。文章指出，故障发生在系统中表明任务执行能力的无法实现，可能发生在网络的任何节点或任何过程中的不同组件中。相关工作还探讨了云计算环境下的工作流调度问题，并介绍了一些传统方法，如遗传算法、蚁群算法和粒子群优化算法等。此外，相关工作还介绍了一些基于云计算环境的故障检测和容错技术，如虚拟机迁移、备份和恢复等。</p><p><img src="http://cdn.leafii.top/img/image-20230321202533280.png" alt="image-20230321202533280" loading="lazy"></p><h3 id="Workflow-model"><a href="#Workflow-model" class="headerlink" title="Workflow model"></a>Workflow model</h3><p>本文的工作流模型使用了直接无环图（DAG）来表示云计算环境中的工作流。该模型由一组任务和任务之间的依赖关系组成，其中每个任务都有一个权重，表示其参考值。具体地，该模型可以表示为： $W&#x3D;(T,D)$ 其中，$T&#x3D;{T_0,T_1,…,T_n}$是一组任务，$D&#x3D;{(T_i,T_j)|T_i,T_j \in T}$是任务之间的依赖关系集合。 每个任务都有一个权重$w_i$，表示其参考值。因此，我们可以将工作流模型表示为一个带权有向无环图（weighted directed acyclic graph），如下所示： $$G&#x3D;(V,E)$$ 其中，$V&#x3D;{v_0,v_1,…,v_n}$是节点集合，对应于任务集合$T$；$E&#x3D;{(v_i,v_j)|w_{ij}\neq 0}$是边集合，对应于依赖关系集合$D$。</p><p><img src="http://cdn.leafii.top/img/image-20230321202544971.png" alt="image-20230321202544971" loading="lazy"></p><blockquote><p>DAG是一种有向无环图，其中每个节点表示一个任务，每条边表示任务之间的依赖关系。在云计算环境中，DAG通常用于表示工作流模型，其中每个任务都有一个权重，表示其参考值。DAG可以帮助我们更好地理解和可视化工作流程，并且可以用于优化工作流程的调度和执行。在本文中，作者使用了一个样例DAG来说明其应用。</p></blockquote><h3 id="Proposed-framework"><a href="#Proposed-framework" class="headerlink" title="Proposed framework"></a>Proposed framework</h3><p>本文的proposed framework主要提出了一种基于自适应故障容错技术的多目标工作流调度框架。该框架使用了主动和反应技术来控制资源负载波动，并通过反应性容错控制器来保证应用程序执行的可靠性。具体来说，该框架包括以下组件： </p><ol><li>Workflow task queue：将用户提交的工作流程按照一定规则排列在队列中，等待分配到云数据中心的虚拟机上执行。</li><li>MAPE-k control loop：该控制循环由四个组件组成，包括monitor、analyzer、planner和executer。这些组件共享一个知识库，用于监测、分析、计划和执行工作流程。</li><li>ANFIS prediction model：该模型是一种自适应基于网络的模糊推理系统，用于预测未来资源负载，并通过主动控制资源负载波动来提高故障预测准确性。</li><li>Reactive fault-tolerant controller：该控制器是一种反应性容错技术，用于在故障&#x2F;失败发生后保证应用程序执行的可靠性。</li></ol><p> 本文提出的框架可以最小化能源消耗、总成本和时间，并在调度科学工作流程时容忍故障。</p><p><img src="http://cdn.leafii.top/img/image-20230321203418941.png" alt="image-20230321203418941" loading="lazy"></p><h4 id="Monitor-component"><a href="#Monitor-component" class="headerlink" title="Monitor component"></a>Monitor component</h4><p>Monitor component被描述为一个组件，其主要职责是收集云数据中心中的工作流任务信息和资源负载率。具体来说，用户传感器和资源传感器会在预定的时间间隔内从应用程序和云环境中收集足够的数据，并将其提供给Monitor component。其中，用户传感器的职责是收集用户工作流任务的信息（如请求速率、类型、大小等），而资源传感器的职责是收集资源负载率的信息（如CPU负载、应用内存和网络流量）。Monitor component会将监测到的数据进行整合，并存储在知识库中以供分析组件使用。</p><h4 id="Analyzer-component"><a href="#Analyzer-component" class="headerlink" title="Analyzer component"></a>Analyzer component</h4><p>在本文中，Analyzer component被描述为一个组件，其主要职责是分析Monitor component收集到的负载信息，并预测未来的资源负载。具体来说，Analyzer component使用ANFIS神经网络模型来预测未来的资源负载，并根据Monitor component的反馈进行调整。预测值会被传输到Planner component中，以便根据系统条件自适应地选择工作流调度算法。通过分析和预测资源负载，Analyzer component可以帮助实现负载均衡和最佳性能。</p><p>当Analyzer component接收到Monitor component传递的数据后，它会使用ANFIS神经网络模型来预测未来的资源负载。ANFIS模型是一种自适应基于网络的模糊推理系统，可以处理非线性和动态系统，并具有良好的泛化能力。在本文中，ANFIS模型被用于预测未来的资源负载，并根据Monitor component的反馈进行调整。具体来说，当预测值与实际值不匹配时，Analyzer component会根据误差信号对ANFIS模型进行调整，以提高预测准确性。 除了资源负载预测外，Analyzer component还可以执行其他分析任务，例如检查工作流任务之间的依赖关系、计算任务权重和优先级等。通过这些分析任务，Analyzer component可以帮助实现更好的工作流调度和执行效果。</p><h4 id="Fuzzy-Planner-component"><a href="#Fuzzy-Planner-component" class="headerlink" title="Fuzzy Planner component"></a>Fuzzy Planner component</h4><p>在本文中，Fuzzy Planner component被描述为一个组件，其主要职责是根据Analyzer component预测的资源负载来分配工作流任务到高效的云资源上。具体来说，Fuzzy Planner component使用三个模糊if-then规则来进行工作流任务分配： </p><ol><li>如果资源负载被预测为正常，则执行“无变化”命令，并调用IDE调度算法。 </li><li>如果资源负载被预测为高，则执行“未来可能发生错误”的命令，并调用主动容错控制器以减少负载。</li><li>如果资源负载被预测为非常高，则执行“故障发生”的命令。</li></ol><p> 这些规则是基于模糊逻辑和经验知识设计的，并可以根据实际情况进行修改和优化。通过使用Fuzzy Planner component，可以实现更好的工作流任务分配和资源利用率。</p><h5 id="IDE算法"><a href="#IDE算法" class="headerlink" title="IDE算法"></a>IDE算法</h5><p>在本文中，IDE算法的具体设计内容如下：</p><ol><li>初始化种群：首先，随机生成一组初始解作为种群，并计算每个解的适应度值。</li><li>变异操作：对于每个个体，随机选择另外两个不同的个体，并计算它们之间的差异向量。然后，将差异向量与当前个体进行加权和操作，得到一个新的变异向量。</li><li>交叉操作：将变异向量与当前个体进行交叉操作，得到一个新的解。</li><li>选择操作：根据适应度函数选择最优解，并将其作为下一代种群中的父代。</li><li>自适应参数设置：通过自适应参数设置技术来调整IDE算法中的参数。</li></ol><p>具体来说，通过监测种群中最优解和平均适应度值之间的差异来调整缩放因子和交叉概率等参数。 通过以上步骤，IDE算法可以在连续空间中寻找最优解，并且具有较好的收敛速度和搜索能力。</p><p>在本文中，IDE算法优化的目标是最小化工作流任务的makespan、总成本和能源消耗。具体来说，IDE算法的目标函数可以表示为： </p><p>$ f(x) &#x3D; w_1 \times makespan(x) + w_2 \times cost(x) + w_3 \times energy(x) $</p><p>其中，$x$表示工作流任务的调度方案，$makespan(x)$表示完成所有任务所需的时间，$cost(x)$表示执行任务所需的总成本，$energy(x)$表示执行任务所需的总能源消耗。$w_1, w_2, w_3$是权重系数，用于平衡不同目标之间的重要性。 通过优化上述目标函数，IDE算法可以得到一个最优的工作流调度方案，以实现更好的性能和效率。</p><h5 id="Proactive-fault-tolerance-controller"><a href="#Proactive-fault-tolerance-controller" class="headerlink" title="Proactive fault-tolerance controller"></a>Proactive fault-tolerance controller</h5><p>在本文中，Proactive fault-tolerance controller被描述为一种主动容错控制器，其主要目的是防止进入故障区域并将新负载分配给异常的虚拟机。具体来说，当Analyzer component检测到资源负载过高时，Fuzzy Planner component会调用Proactive fault-tolerance controller来减少负载并防止系统进入故障状态。 </p><p>Proactive fault-tolerance controller的实现方式是通过监测虚拟机的资源利用率和性能指标来判断是否存在异常情况。如果发现某个虚拟机出现了异常情况，则Proactive fault-tolerance controller会立即将其从负载均衡中移除，并将其上的任务重新分配给其他正常的虚拟机。这样可以避免故障扩散和系统崩溃。</p><p> 总之，Proactive fault-tolerance controller是一种有效的容错控制器，可以帮助云环境实现更好的容错性能和可靠性。</p><h5 id="Reactive-fault-tolerance-controller"><a href="#Reactive-fault-tolerance-controller" class="headerlink" title="Reactive fault-tolerance controller"></a>Reactive fault-tolerance controller</h5><p>在本文中，Reactive fault-tolerance controller被描述为一种响应式容错控制器，其主要目的是在故障发生后减少故障的影响。具体来说，当Analyzer component检测到某个虚拟机出现故障时，Fuzzy Planner component会调用Reactive fault-tolerance controller来处理故障并恢复系统正常运行。 </p><p>Reactive fault-tolerance controller的实现方式是通过使用复制技术来提供容错能力。具体来说，当某个虚拟机出现故障时，Reactive fault-tolerance controller会将该虚拟机上的任务复制到其他正常的虚拟机上，并重新分配这些任务以保证系统正常运行。这样可以避免任务丢失和系统崩溃。</p><p> 需要注意的是，Reactive fault-tolerance controller的主要缺点是成本较高。因为它需要额外的资源和计算能力来处理故障和执行复制操作。因此，在实际应用中需要权衡成本和性能之间的关系，并选择合适的容错策略。 </p><p>总之，Reactive fault-tolerance controller是一种有效的容错控制器，在云环境中可以帮助提高系统可靠性和容错性能。</p><h4 id="Executer-component-for-the-workflow-tasks-allocation"><a href="#Executer-component-for-the-workflow-tasks-allocation" class="headerlink" title="Executer component for the workflow tasks allocation"></a>Executer component for the workflow tasks allocation</h4><p>执行组件负责根据调度阶段执行的算法将用户发送的所有请求分配给现有的虚拟机。该组件负责实际执行规划组件决定的操作。</p><h3 id="Performance-evaluation"><a href="#Performance-evaluation" class="headerlink" title="Performance evaluation"></a>Performance evaluation</h3><p>实验部分不作具体分析</p><p>在本文中，“Performance evaluation”部分描述了作者如何评估所提出的工作流调度算法的性能。具体来说，作者使用了WorkflowSim-1.0工具包和CloudSim模拟器来模拟云环境中的工作流，并评估所提出的算法在不同负载下的性能表现。</p><p>在实验中，作者使用了一组实验设置，包括虚拟机数量、任务数量、任务大小等参数。通过对这些参数进行不同组合和调整，作者可以模拟不同负载下的云环境，并评估所提出算法的性能表现。 </p><p>最终，作者通过比较所提出算法和其他常用算法（如HEFT、Min-Min等）在不同负载下的性能指标（如makespan、总成本等）来评估其性能。实验结果表明，所提出算法可以显著提高系统性能和效率，并且在各项指标上均优于其他常用算法。 </p><p>总之，“Performance evaluation”部分描述了作者如何评估所提出算法的性能，并给出了实验结果和结论。这些结果可以帮助读者更好地理解该算法的优点和局限性，并为进一步研究和应用提供参考。</p><h4 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h4><p>“Conclusion and future work”部分是本文的结论和未来工作方向。具体来说，该部分总结了本文的主要贡献和发现，并提出了一些未来研究的方向。 </p><p>在结论部分，作者指出所提出的工作流调度算法可以显著提高云环境中的性能和效率，并且在各项指标上均优于其他常用算法。作者还强调了该算法的可扩展性和适应性，并指出它可以应用于不同类型的云环境和工作流场景。 </p><p>在未来工作方向中，作者提出了一些有待进一步研究的问题，如如何进一步优化算法性能、如何处理更复杂的工作流场景、如何实现更高效的容错机制等。这些问题都是当前云计算领域面临的挑战，也是未来研究需要解决的重要问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 容错 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 工作流调度 </tag>
            
            <tag> 进化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode28.找出字符串中第一个匹配项的下标</title>
      <link href="/2023/03/21/leetcode28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/"/>
      <url>/2023/03/21/leetcode28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：haystack &#x3D; &quot;sadbutsad&quot;, needle &#x3D; &quot;sad&quot;输出：0解释：&quot;sad&quot; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：haystack &#x3D; &quot;leetcode&quot;, needle &#x3D; &quot;leeto&quot;输出：-1解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>暴力解法</li></ol><p>首先判断haystack的长度是否小于needle，若小于则直接返回-1.然后对haystack进行遍历，若haystack[i]&#x3D;&#x3D;needle[0]，则说明haystack同needle的第一个字符匹配了，此时直接求haystack在i上长度为needle长度的子串并比较他们是否相等，若相等则直接返回i即可，否则继续遍历haystack。C++解法如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        int m &#x3D; haystack.length();         int n &#x3D; needle.length(); &#x2F;&#x2F; 分别求两个字符串的长度        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; 此判断符合strStr函数的原始定义        if (m &lt; n) return -1; &#x2F;&#x2F; 若haystack长度小于needle长度，则直接返回-1        for (int i &#x3D; 0; i &lt; m; i++) &#123; &#x2F;&#x2F; 遍历匹配第一个字母            if (haystack[i] &#x3D;&#x3D; needle[0]) &#123; &#x2F;&#x2F; 若第一个字母成功匹配                string temp &#x3D; haystack.substr(i, n); &#x2F;&#x2F; 直接求下标为i，长度同needle相等的子串temp                if (temp &#x3D;&#x3D; needle) &#123; &#x2F;&#x2F; 判断temp与needle是否相等                    return i; &#x2F;&#x2F; 若相等，则直接返回i                &#125;            &#125;        &#125;        return -1; &#x2F;&#x2F; 否则返回-1    &#125;&#125;;</code></pre><ol start="2"><li>KMP算法</li></ol><p>KMP的详细介绍：<a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html</a></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void getNext(int* next, const string&amp; s) &#123;        int j &#x3D; -1;        next[0] &#x3D; j;        for(int i &#x3D; 1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 注意i从1开始            while (j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; s[j+1]) &#123; &#x2F;&#x2F;前后缀不相同了                j &#x3D; next[j];            &#125;            if (s[i] &#x3D;&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 找到相同的前后缀                j++;            &#125;            next[i] &#x3D; j; &#x2F;&#x2F; 将j（前缀的长度）赋给next[i]        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if (needle.size() &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);        int j &#x3D; -1;        for (int i &#x3D; 0; i &lt; haystack.size(); i++) &#123; &#x2F;&#x2F; 注意i从0开始            while(j &gt;&#x3D; 0 &amp;&amp; haystack[i] !&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 不匹配                j &#x3D; next[j]; &#x2F;&#x2F; j寻找之前匹配的位置            &#125;            if (haystack[i] &#x3D;&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 匹配，j和i同时向后移动                j++;            &#125;            if (j &#x3D;&#x3D;(needle.size() - 1))  &#123; &#x2F;&#x2F; 文本串s里出现了模式串t                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer05.替换空格</title>
      <link href="/2023/03/20/%E5%89%91%E6%8C%87Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2023/03/20/%E5%89%91%E6%8C%87Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><p><strong>限制：</strong></p><pre class="language-none"><code class="language-none">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>常规思路</li></ul><p>新建一个string类型的变量result，对输入的字符串s的每个字符进行判断，若字符为空格，则<code>result+=&quot;%20;&quot;</code>，否则<code>result+=s[i];</code>，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string replaceSpace(string s) &#123;        string result &#x3D; &quot;&quot;; &#x2F;&#x2F; 定义结果字符串result        int n &#x3D; s.length(); &#x2F;&#x2F; 获取输入字符串s的长度        for(int i &#x3D; 0; i &lt; n; i++) &#123; &#x2F;&#x2F; 进行遍历            if (s[i] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 若s[i]为空格，则result+&#x3D;&quot;%20&quot;;                result +&#x3D; &quot;%20&quot;;            &#125;            else &#123; &#x2F;&#x2F; 否则直接+&#x3D;s[i];                result +&#x3D; s[i];            &#125;        &#125;        return result; &#x2F;&#x2F; 最后返回结果值result    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode541.反转字符串II</title>
      <link href="/2023/03/19/leetcode541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II/"/>
      <url>/2023/03/19/leetcode541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2输出：&quot;bacdfeg&quot;</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;abcd&quot;, k &#x3D; 2输出：&quot;bacd&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文组成</li><li><code>1 &lt;= k &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>直接进行交换即可</li></ul><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int n &#x3D; s.size(); &#x2F;&#x2F; 字符串的长度        for (int i &#x3D; 0; i &lt; n; i +&#x3D; 2 * k) &#123; &#x2F;&#x2F; 每 2k 个字符为一组进行反转            int left &#x3D; i; &#x2F;&#x2F; 左边界            int right &#x3D; min(i + k - 1, n - 1); &#x2F;&#x2F; 右边界，注意防止越界            while (left &lt; right) &#123; &#x2F;&#x2F; 双指针反转                swap(s[left], s[right]); &#x2F;&#x2F; 交换左右指针对应的字符。                left++;                right--; &#x2F;&#x2F; 左右指针向中间移动。            &#125;        &#125;        return s; &#x2F;&#x2F; 返回反转后的字符串    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode124.二叉树中的最大路径和</title>
      <link href="/2023/03/16/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2023/03/16/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/exx1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/exx2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>树形DP<ol><li>首先判断当前节点是否为 null，若为 null 则返回 0。</li><li>递归计算当前节点的左子树和右子树的最大路径和，分别为 <code>left</code> 和 <code>right</code>。</li><li>计算当前子树中包含当前节点的最大路径和 <code>curMax</code>，公式为 <code>node-&gt;val + max(0, max(left, right))</code>，其中 <code>node-&gt;val</code> 表示当前节点的值，<code>max(left, right)</code> 表示当前子树中不包含当前节点的最大路径和，<code>max(0, ...)</code> 的作用是保证当前子树中的路径和一定是非负数。</li><li>更新全局最大路径和 <code>res</code>，公式为 <code>max(res, left+right+node-&gt;val)</code>，其中 <code>left+right+node-&gt;val</code> 表示当前子树中包含当前节点的路径和。</li><li>返回当前子树的最大路径和 <code>curMax</code>。</li></ol></li></ol><p>在递归计算时，每个节点都会计算自己为根节点的最大路径和，并更新全局最大路径和。最终返回的是整棵树中的最大路径和。</p><p>这种递归思路在处理树形结构的问题时非常常见，被称为树形 DP（动态规划）。通过递归计算子树的最大路径和，并将结果传递给父节点，最终得到整棵树的最大路径和。C++代码实现如下:</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxPathSum(TreeNode* root) &#123;        int res &#x3D; INT_MIN;        dfs(root, res);        return res;    &#125;    int dfs(TreeNode* root, int&amp; res) &#123;        if (!root) return 0;        int left &#x3D; max(0, dfs(root-&gt;left, res)); &#x2F;&#x2F; 左子树的最大贡献值        int right &#x3D; max(0, dfs(root-&gt;right, res)); &#x2F;&#x2F; 右子树的最大贡献值        res &#x3D; max(res, root-&gt;val + left + right); &#x2F;&#x2F; 更新最大路径和        return root-&gt;val + max(left, right); &#x2F;&#x2F; 返回当前子树的最大路径和    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode105.从前序与中序遍历序列构造二叉树</title>
      <link href="/2023/03/16/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/03/16/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p> <span id="more"></span><p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/tree-20230316142527347.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]输出: [3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]输出: [-1]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>同<a href="https://leafii.top/2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">106的解法</a>相似,因此在这里只提供代码.</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        &#x2F;&#x2F; 创建根节点        TreeNode* root &#x3D; build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);        return root;    &#125;        TreeNode* build(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd, vector&lt;int&gt;&amp; inorder, int inStart, int inEnd) &#123;        &#x2F;&#x2F; 特判：preStart &gt; preEnd 时，已经没有节点需要处理，返回 NULL        if (preStart &gt; preEnd) &#123;            return nullptr;        &#125;                &#x2F;&#x2F; 创建当前子树的根节点        TreeNode* root &#x3D; new TreeNode(preorder[preStart]);                &#x2F;&#x2F; 在中序遍历序列中查找当前子树根节点的位置        int inRootIndex &#x3D; inStart;        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;            inRootIndex++;        &#125;                &#x2F;&#x2F; 计算当前子树左子树的大小        int leftTreeSize &#x3D; inRootIndex - inStart;                &#x2F;&#x2F; 递归构建当前子树的左子树和右子树        root-&gt;left &#x3D; build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inRootIndex - 1);        root-&gt;right &#x3D; build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inRootIndex + 1, inEnd);                &#x2F;&#x2F; 返回当前子树的根节点        return root;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode106.从中序与后序遍历序列构造二叉树</title>
      <link href="/2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p> <span id="more"></span><p><strong>示例 1:</strong></p><p><img src="http://cdn.leafii.top/img/tree.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]输出：[3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入：inorder &#x3D; [-1], postorder &#x3D; [-1]输出：[-1]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>递归构造</li></ul><p>根据题意，可以得知后序遍历的最后一个元素一定是树的根节点。然后可以在中序遍历中找到该根节点，以此将树分为左子树和右子树。对于左子树和右子树，可以再分别在中序遍历和后序遍历中找到其根节点，以此类推。</p><p>所以该问题可以使用递归的方式解决，每次递归时，先找到后序遍历的最后一个元素作为根节点，在中序遍历中找到该根节点，以此将树分为左子树和右子树。再分别递归左子树和右子树构建二叉树。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        &#x2F;&#x2F; 创建根节点        TreeNode* root &#x3D; build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);        return root;    &#125;    TreeNode* build(vector&lt;int&gt;&amp; inorder, int inStart, int inEnd, vector&lt;int&gt;&amp; postorder, int postStart, int postEnd) &#123;      &#x2F;*            inorder：中序遍历序列；            postorder：后序遍历序列；            inStart：当前子树在中序遍历序列中的起始位置；            inEnd：当前子树在中序遍历序列中的结束位置；            postStart：当前子树在后序遍历序列中的起始位置；            postEnd：当前子树在后序遍历序列中的结束位置。        *&#x2F;        &#x2F;&#x2F; 特判： 若postStart &gt; postEnd时， 无节点需要处理，返回NULL        if (postStart &gt; postEnd) &#123;            return nullptr;        &#125;        &#x2F;&#x2F; 创建新的子树根节点        TreeNode* root &#x3D; new TreeNode(postorder[postEnd]); &#x2F;&#x2F; 后续遍历的最后一个元素一定是根节点        &#x2F;&#x2F; 在中序遍历中寻找当前子树根节点的位置        int inRootIndex &#x3D; inStart;        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;            inRootIndex++;        &#125;        &#x2F;&#x2F; 计算当前子树左子树的大小        int leftTreeSize &#x3D; inRootIndex - inStart;                &#x2F;&#x2F; 根据根节点的位置， 分别递归构建左子树和右子树         root-&gt;left &#x3D; build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);        root-&gt;right &#x3D; build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1);         return root;    &#125;&#125;;</code></pre><p>关于<code>root-&gt;left = build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);</code>和<code>root-&gt;right = build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1); </code>的解释：</p><blockquote><p>在中序遍历中找到了根节点的位置后，在中序遍历中根节点的左边就是左子树的中序遍历，根节点的右边就是右子树的中序遍历，在递归调用时，左子树的中序遍历的右边界指针指向根节点索引-1，同理右子树的中序遍历的左边界指针指向根节点索引+1；计算了左子树的大小之后，可以发现在后序遍历中，从最开始到左子树的大小-1的元素即为左子树对应的后序遍历，因此从最开始索引+左子树大小到最右边索引-1的后序遍历即为右子树的后序遍历，这样一直递归即可得到完整的左右子树，将子树同根节点连接，返回根节点即可得到完整的树。</p></blockquote><p>在整个递归的过程中，我们都不需要额外的空间来存储子数组，而是通过起始和结束下标来表示子数组。这种方式使得我们可以使用较少的空间来解决问题，并且在递归过程中也不需要频繁地拷贝数组，提高了算法的效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode102.二叉树的层序遍历</title>
      <link href="/2023/03/14/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2023/03/14/leetcode102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p> <span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/tree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用队列辅助层序遍历</li></ol><p>注意看这个题的输入与输出，输出的动态数组的元素是元素为整型的数组，比如<code>[[3],[9,20],[15,7]]</code>.因此如果只定义一个队列辅助遍历，无法清晰的区分每层的元素应该插入到哪个数组中，比如如果只使用一个队列进行层次遍历，得到的结果只能是<code>[3,9,20,15,7]</code>，无法从这个结果中得知清晰的二叉树层次结构，所以在这里定义两个队列，首先向一个队列中塞入元素，接着对队首元素进行pop并且将队首元素的左右子树节点分别塞入另一队列中，再将结果数组并入result数组中，再将另一个队列进行同样的遍历操作，具体的C++实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        &#x2F;&#x2F; 定义两个队列 分别为q和another_q 用于层次遍历        queue&lt;TreeNode*&gt; q;        queue&lt;TreeNode*&gt; another_q;        &#x2F;&#x2F; 定义结果数组 其元素为元素为int类型的数组        vector&lt;vector&lt;int&gt;&gt; result;            &#x2F;&#x2F; 若根节点非空 则将根节点push进队列q中         if (root !&#x3D; nullptr) &#123;            q.push(root);        &#125;        &#x2F;&#x2F; 当q或者another_q队列非空时 进行遍历操作        while (!q.empty()|| !another_q.empty()) &#123;            &#x2F;&#x2F; 定义元素为int的临时数组 用于存储每一层的元素            vector&lt;int&gt; temp_vector;            &#x2F;&#x2F; 当队列q非空时 将队列q的元素逐个出队            while (!q.empty()) &#123;                TreeNode* temp_node &#x3D; q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    another_q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;            &#x2F;&#x2F; 当另一个队列another_q非空时 将队列another_q的元素逐个出队            while (!another_q.empty()) &#123;                TreeNode* temp_node &#x3D; another_q.front();                &#x2F;&#x2F; 向临时数组中塞入节点的值                temp_vector.push_back(temp_node-&gt;val);                &#x2F;&#x2F; 塞入之后 将对应元素出队                another_q.pop();                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中                if (temp_node-&gt;left !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;left);                &#125;                if (temp_node-&gt;right !&#x3D; nullptr) &#123;                    q.push(temp_node-&gt;right);                &#125;            &#125;            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组            if (temp_vector.size() !&#x3D; 0) &#123;                result.push_back(temp_vector);                temp_vector.clear();            &#125;        &#125;        &#x2F;&#x2F; 返回结果数组        return result;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode104.二叉树的最大深度</title>
      <link href="/2023/03/13/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2023/03/13/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><pre class="language-none"><code class="language-none">  3 &#x2F; \9  20  &#x2F;  \ 15   7</code></pre><p>返回它的最大深度 3 。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>DFS（深度优先遍历）</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;      &#x2F;&#x2F; 如果当前节点为空，则返回0        if (root &#x3D;&#x3D; nullptr) return 0;      &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) return 1;        int left_depth &#x3D; -1, right_depth &#x3D; -1;      &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度        if (root-&gt;left !&#x3D; nullptr) &#123;            left_depth &#x3D; maxDepth(root-&gt;left);        &#125;      &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度        if (root-&gt;right !&#x3D; nullptr) &#123;            right_depth &#x3D; maxDepth(root-&gt;right);        &#125;      &#x2F;&#x2F; 返回左右子树深度的较大值加1        return max(left_depth, right_depth) + 1;    &#125;&#125;;</code></pre><ol start="2"><li>BFS（广度优先遍历）</li></ol><p>主要思路是使用一个队列来遍历整个二叉树。我们首先将根节点加入队列中，然后在每次循环中取出队列中的一层节点，将该层节点的左右子节点加入队列中。当遍历完所有节点时，队列中存储的即为最后一层节点，此时的深度即为树的深度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) &#123;            return 0;        &#125;        queue&lt;TreeNode*&gt; q;  &#x2F;&#x2F; 创建一个队列，用于BFS遍历        q.push(root);        &#x2F;&#x2F; 将根节点加入队列        int depth &#x3D; 0;       &#x2F;&#x2F; 初始化深度为0        while (!q.empty()) &#123; &#x2F;&#x2F; 当队列不为空时，继续遍历            int size &#x3D; q.size(); &#x2F;&#x2F; 记录队列中当前层的节点数量            for (int i &#x3D; 0; i &lt; size; i++) &#123; &#x2F;&#x2F; 遍历当前层的所有节点                TreeNode* node &#x3D; q.front();  &#x2F;&#x2F; 取出队列头部的节点                q.pop();                     &#x2F;&#x2F; 将该节点从队列中移除                if (node-&gt;left !&#x3D; NULL) &#123;    &#x2F;&#x2F; 如果该节点有左子节点，将其加入队列中                    q.push(node-&gt;left);                &#125;                if (node-&gt;right !&#x3D; NULL) &#123;   &#x2F;&#x2F; 如果该节点有右子节点，将其加入队列中                    q.push(node-&gt;right);                &#125;            &#125;            depth++;  &#x2F;&#x2F; 当前层遍历结束后，深度加1        &#125;        return depth; &#x2F;&#x2F; 返回树的深度    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode111.二叉树的最小深度</title>
      <link href="/2023/03/12/leetcode111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <url>/2023/03/12/leetcode111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ex_depth.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]输出：5</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>DFS（深度优先遍历）</li></ol><p>使用了递归的方式。首先判断根节点是否为空，如果为空，则返回深度为0；如果根节点没有左右子节点，返回深度为1；如果有左右子节点，则分别递归计算左子树和右子树的深度，取两者的较小值再加1，即为该树的最小深度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        &#x2F;&#x2F; 如果当前节点为空，则返回0        if (root &#x3D;&#x3D; nullptr) &#123;            return 0;        &#125;        &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;            return 1;        &#125;        int left_depth &#x3D; INT_MAX, right_depth &#x3D; INT_MAX;        &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度        if (root-&gt;left !&#x3D; nullptr) &#123;            left_depth &#x3D; minDepth(root-&gt;left);        &#125;        &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度        if (root-&gt;right !&#x3D; nullptr) &#123;            right_depth &#x3D; minDepth(root-&gt;right);        &#125;        &#x2F;&#x2F; 返回左右子树深度的较小值加1        return min(left_depth, right_depth) + 1;    &#125;&#125;;</code></pre><ol start="2"><li>BFS（广度优先遍历）</li></ol><p>该代码使用了队列来实现广度优先搜索，从根节点开始，逐层访问该节点的左右子节点，并将子节点及其所在的层数入队，直到找到叶子节点，即没有左右子节点的节点，此时返回该节点所在的层数即可。如果整个二叉树中没有叶子节点，则返回0。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        if (root &#x3D;&#x3D; nullptr) &#123;            return 0;        &#125;        &#x2F;&#x2F; 创建队列， 存储节点以及其所在的层数        queue&lt;pair&lt;TreeNode*, int&gt;&gt; q;        &#x2F;&#x2F; 将根节点和所在的层数入队        q.push(make_pair(root, 1));        while (!q.empty()) &#123;            &#x2F;&#x2F; 取出队首节点和所在的层数            TreeNode* node &#x3D; q.front().first;            int depth &#x3D; q.front().second;            q.pop();            &#x2F;&#x2F; 如果该节点为叶子节点， 直接返回其所在的层数            if (node-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; node-&gt;right &#x3D;&#x3D; nullptr) &#123;                return depth;            &#125;            &#x2F;&#x2F; 如果该节点有左子节点，则将其左子节点和所在的层数入队            if (node-&gt;left !&#x3D; nullptr) &#123;                q.push(make_pair(node-&gt;left, depth+1));                &#125;            &#x2F;&#x2F; 如果该节点有右子节点，则将其右子节点和所在的层数入队            if (node-&gt;right !&#x3D; nullptr) &#123;                q.push(make_pair(node-&gt;right, depth+1));                &#125;        &#125;        return 0;    &#125;&#125;;</code></pre><blockquote><p>一般来说，DFS和BFS的效率取决于二叉树的结构和分布。如果二叉树比较平衡，那么BFS可能更快，因为它可以更早地找到最小深度的叶子节点。如果二叉树比较不平衡，那么DFS可能更快，因为它可以避免访问很多不必要的节点。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode25.K个一组翻转链表</title>
      <link href="/2023/03/09/leetcode25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/09/leetcode25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span> <p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/reverse_ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2输出：[2,1,4,3,5]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/reverse_ex2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3输出：[3,2,1,4,5]</code></pre><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>编写一个函数，用于实现反转链表的核心逻辑，思路如下：</p><ul><li><p>初始化一个前驱节点prev和一个当前节点curr，分别指向空和头节点。</p></li><li><p>循环k次，每次做以下操作：</p><ul><li><p>保存当前节点的下一个节点next，以免丢失。</p></li><li><p>将当前节点的next指针指向前驱节点prev，实现反转。</p></li><li><p>将前驱节点prev更新为当前节点curr，为下一次反转做准备。</p></li><li><p>将当前节点curr更新为下一个节点next，继续遍历链表。</p></li></ul></li></ul><p>这样就可以将链表中的k个节点反转，并返回反转后的头尾指针。</p><blockquote><p>对以上函数进行一个图示说明：</p><p>假设链表为1-&gt;2-&gt;3-&gt;4-&gt;5，k为3，那么反转后的链表应该为3-&gt;2-&gt;1-&gt;4-&gt;5。</p><p>初始状态：</p><pre class="language-text" data-language="text"><code class="language-text">prev: nullcurr: 1next: 2null &lt;- prev   curr -> next -> 3 -> 4 -> 5</code></pre><p>第一次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 1curr: 2next: 3null &lt;- prev &lt;- curr   next -> 4 -> 5</code></pre><p>第二次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 2curr: 3next: 4null &lt;- prev &lt;- curr   next -> 5</code></pre><p>第三次循环：</p><pre class="language-text" data-language="text"><code class="language-text">prev: 3curr: 4next: 5null &lt;- prev &lt;- curr   next </code></pre><p>结束循环，返回{prev, head}即{3,1}。</p><pre class="language-text" data-language="text"><code class="language-text"> prev        head   |           |  v           v null&lt;-3&lt;-2&lt;-1    4->5 </code></pre></blockquote><p>代码的整体思路是：</p><ul><li>定义一个虚拟头节点dummy，指向原链表的头节点head，这样可以方便处理边界情况。</li><li>定义一个前驱节点prev，初始指向dummy，用来连接反转后的链表段。</li><li>用一个while循环遍历整个链表，每次循环做以下操作：<ul><li>定义一个尾部指针tail，初始指向头部指针head，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回dummy-&gt;next即可。</li><li>保存下一段链表的头部指针nextHead，并断开与当前段的连接。</li><li>调用反转函数reverseList，输入当前段的头部指针head和长度k，返回反转后的新头部和新尾部，并将其连接到前驱和下一段上。</li><li>更新前驱为新尾部，更新头部为下一段头部。</li></ul></li></ul><p>这样就可以将整个链表按照每k个节点进行反转，并返回dummy-&gt;next作为新链表的头节点。</p><p>代码的时间复杂度是O(n)，因为我们只需要遍历一次链表，每个节点最多被访问两次。 代码的空间复杂度是O(1)，因为我们只使用了常数个额外变量，没有使用递归或栈。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 定义反转链表的函数，输入一个链表头节点和一个长度k，返回反转后的头节点和尾节点    pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, int k) &#123;        &#x2F;&#x2F; 初始化前驱节点和当前节点        ListNode* prev &#x3D; nullptr;        ListNode* curr &#x3D; head;        &#x2F;&#x2F; 遍历k次，每次将当前节点指向前驱节点，并更新前驱和当前节点        for (int i &#x3D; 0; i &lt; k; i++) &#123;            ListNode* next &#x3D; curr-&gt;next; &#x2F;&#x2F; 保存下一个节点            curr-&gt;next &#x3D; prev; &#x2F;&#x2F; 反转指针            prev &#x3D; curr; &#x2F;&#x2F; 更新前驱            curr &#x3D; next; &#x2F;&#x2F; 更新当前        &#125;        &#x2F;&#x2F; 返回反转后的头节点和尾节点，即原来的尾节点和头节点        return &#123;prev, head&#125;;    &#125;    &#x2F;&#x2F; 定义leetcode 25的主函数，输入一个链表头节点和一个整数k，返回反转后的链表头节点    ListNode* reverseKGroup(ListNode* head, int k) &#123;        &#x2F;&#x2F; 初始化虚拟头节点和前驱节点        ListNode* dummy &#x3D; new ListNode(-1);        dummy-&gt;next &#x3D; head;        ListNode* prev &#x3D; dummy;                while (head !&#x3D; nullptr) &#123; &#x2F;&#x2F; 遍历链表直到为空            &#x2F;&#x2F; 初始化尾部指针为头部指针，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回虚拟头节点的下一个即可            ListNode* tail &#x3D; head;            for (int i &#x3D; 0; i &lt; k - 1; i++) &#123;                tail &#x3D; tail-&gt;next;                if (tail &#x3D;&#x3D; nullptr) return dummy-&gt;next;            &#125;                        &#x2F;&#x2F; 保存下一段链表的头部指针，并断开与当前段的连接            ListNode* nextHead &#x3D; tail-&gt;next;            tail-&gt;next &#x3D; nullptr;            &#x2F;&#x2F; 调用反转函数，得到反转后的新头部和新尾部，并将其连接到前驱和下一段上            auto reversedPair &#x3D; reverseList(head, k);            prev-&gt;next &#x3D; reversedPair.first;            reversedPair.second-&gt;next &#x3D; nextHead;            &#x2F;&#x2F; 更新前驱为新尾部，更新头部为下一段头部            prev &#x3D; reversedPair.second;            head &#x3D; nextHead;                    &#125;            return dummy-&gt;next;     &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode148.排序链表</title>
      <link href="/2023/03/08/leetcode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/08/leetcode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [4,2,1,3]输出：[1,2,3,4]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [-1,5,3,4,0]输出：[-1,0,3,4,5]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>为了解题而解题的解法</li></ol><p>建立一个动态数组nodes，将链表中的每个元素放入动态数组中，然后使用sort排序，接着将动态数组进行遍历，将每个数字新建一个节点放入结果链表中，C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        vector&lt;int&gt; nodes;        while (head !&#x3D; nullptr) &#123;            nodes.push_back(head-&gt;val); &#x2F;&#x2F; 将链表的每个节点的值放入动态数组中            head &#x3D; head-&gt;next;        &#125;        sort(nodes.begin(), nodes.end()); &#x2F;&#x2F; 对动态数组中的元素进行排序        ListNode* sortedList &#x3D; nullptr;        ListNode** cur &#x3D; &amp;sortedList; &#x2F;&#x2F; 定义一个指向指针的指针 cur                for (auto node_num: nodes) &#123;            *cur &#x3D; new ListNode(node_num); &#x2F;&#x2F; 将排序好的数字加入新链表中            cur &#x3D; &amp;((*cur)-&gt;next);        &#125;        return sortedList; &#x2F;&#x2F; 返回链表头节点    &#125;&#125;;</code></pre><blockquote><p>这段代码涉及了指针和地址的操作，可以解读为：</p><p>​        ListNode** cur：定义一个指向指针的指针 cur</p><p>​        &amp;sortedList：获取 sortedList 的地址，也就是一个指向指针 sortedList 的指针</p><p>​        cur &#x3D; &amp;sortedList：将 sortedList 的地址赋值给 cur，此时 cur 指向 sortedList 的指针</p><p> 这样做的目的是为了可以更改 sortedList 的指针，从而修改链表结构。在 for 循环中，*cur 表示指针 cur 所指向的指针，即 sortedList 的指针，将新的节点插入到 sortedList 后，cur 需要指向插入节点的 next 指针，因此使用了 cur &#x3D; &amp;((*cur)-&gt;next) 的写法。</p></blockquote><ol start="2"><li>归并排序</li></ol><p>归并排序的思路如下：利用快慢指针将链表分为左链表和右链表，分而治之，将分得的两个链表进行再一次分割和归并，最终归并得到结果。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    &#x2F;&#x2F; 归并排序    ListNode* sortList(ListNode* head) &#123;        &#x2F;&#x2F; 如果链表为空或只有一个节点，直接返回        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) return head;        &#x2F;&#x2F; 找到链表的中点，用快慢指针法        ListNode* slow &#x3D; head; &#x2F;&#x2F; 慢指针，每次走一步        ListNode* fast &#x3D; head-&gt;next; &#x2F;&#x2F; 快指针，每次走两步        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;            slow &#x3D; slow-&gt;next; &#x2F;&#x2F; 慢指针走到中点            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走到末尾或者null        &#125;        &#x2F;&#x2F; 将链表从中点断开为两个子链表        ListNode* mid &#x3D; slow-&gt;next;         slow-&gt;next &#x3D; nullptr;        &#x2F;&#x2F; 对左右子链表分别进行排序        ListNode* left &#x3D; sortList(head);         ListNode* right &#x3D; sortList(mid);        &#x2F;&#x2F; 合并两个有序的子链表为一个有序的链表        return mergeTwoLists(left, right);    &#125;    &#x2F;&#x2F; 合并两个有序的链表为一个有序的链表    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        &#x2F;&#x2F; 创建一个哑节点作为合并后链表的头结点        ListNode dummy(0);        &#x2F;&#x2F; 创建一个指针cur指向当前合并后链表的最后一个节点，初始为哑节点        ListNode* cur &#x3D; &amp;dummy;        &#x2F;&#x2F; 当l1和l2都不为空时，比较它们的值，将较小的值接在cur后面，并更新对应的指针while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;if (l1-&gt;val &lt; l2-&gt;val) &#123; cur-&gt;next &#x3D; l1; l1 &#x3D; l1-&gt;next;&#125; else &#123; cur-&gt;next &#x3D; l2; l2 &#x3D; l2-&gt;next;&#125;cur &#x3D; cur-&gt;next; &#125;        &#x2F;&#x2F; 当l1或l2有一个为空时，直接将另一个非空的链表接在cur后面即可        if (l1 !&#x3D; nullptr) cur-&gt;next &#x3D; l1;        if (l2 !&#x3D; nullptr) cur-&gt;next &#x3D; l2;        return dummy.next;  &#x2F;&#x2F; 返回哑节点的下一个节点，即合并后链表的头结点    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode142.环形链表II</title>
      <link href="/2023/03/06/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
      <url>/2023/03/06/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist-20230306204553902.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test2-20230306204600878.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2], pos &#x3D; 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test3-20230306204608161.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1], pos &#x3D; -1输出：返回 null解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用hashset存储链表元素的地址，当使用快慢指针确定环形链表存在时，返回相应的环形节点。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#x2F;&#x2F; 如果链表为空或者只有一个元素，则返回null            return nullptr;         ListNode* slow &#x3D; head;        ListNode* fast &#x3D; head-&gt;next;        while (slow !&#x3D; fast) &#123;            if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) return nullptr;            fast &#x3D; fast-&gt;next-&gt;next;            slow &#x3D; slow-&gt;next;        &#125;        &#x2F;&#x2F;此时已经发现有环了，使用hashset存储链表元素地址，若有相同地址的元素就返回该元素        unordered_set&lt;ListNode*&gt; nodes;        ListNode* cur &#x3D; head;        while (cur !&#x3D; nullptr) &#123;            if (nodes.count(cur)) &#123;                return cur;            &#125;            else &#123;                nodes.insert(cur);                cur &#x3D; cur-&gt;next;            &#125;        &#125;        return nullptr;    &#125;&#125;;</code></pre><ol start="2"><li>快慢指针法</li></ol><p>利用快慢指针，找到链表中是否存在环。若存在环，则将快指针重新指向链表的头结点，并将快慢指针以相同的速度向前移动，直到两个指针相遇，即为环的入口节点。</p><p>假设链表的长度为L，环的长度为C，环的入口节点距离头节点的距离为A，快慢指针相遇的节点距离环的入口节点的距离为B。</p><p>当快慢指针相遇时，快指针走过的距离是慢指针的两倍，即：$2 \times (A + B) &#x3D; A + B + n \times C$其中n是快指针在环中走过的圈数。化简得：$A &#x3D; (n - 1) \times C + (C - B)$。这个式子的意义是，从头节点到环的入口节点的距离等于从相遇点到环的入口节点的距离加上(n - 1)圈的环的长度。</p><p>因此，如果让一个新的指针cur从头节点开始走，同时让slow从相遇点开始走，每次都走一步，那么它们会在环的入口节点相遇，因为它们走过的距离都是A。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        &#x2F;&#x2F; 判断链表是否为空或只有一个元素        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) &#123;            return NULL;        &#125;        &#x2F;&#x2F; 定义快慢指针，初始值指向头结点        ListNode* fast &#x3D; head;        ListNode* slow &#x3D; head;        &#x2F;&#x2F; 判断是否存在环        while (fast !&#x3D; NULL &amp;&amp; fast-&gt;next !&#x3D; NULL) &#123;            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走两步            slow &#x3D; slow-&gt;next;       &#x2F;&#x2F; 慢指针走一步            if (fast &#x3D;&#x3D; slow) &#123;      &#x2F;&#x2F; 快慢指针相遇                ListNode* start &#x3D; head; &#x2F;&#x2F; 从头结点开始，与慢指针同时前进，相遇点即为环的起点                while (start !&#x3D; slow) &#123;                    start &#x3D; start-&gt;next;                    slow &#x3D; slow-&gt;next;                &#125;                return start;            &#125;        &#125;        return NULL; &#x2F;&#x2F; 遍历完链表，仍未找到环，返回NULL    &#125;&#125;;</code></pre><blockquote><p>注：在 while 循环中，因为 fast 比 slow 快，所以应该先判断 fast 是否为 NULL 或 fast-&gt;next 是否为 NULL，以保证程序的正确性。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode160.相交链表</title>
      <link href="/2023/03/06/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/06/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><span id="more"></span><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><img src="http://cdn.leafii.top/img/160_statement.png" alt="img" loading="lazy"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/160_example_1_1.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3输出：Intersected at &#39;8&#39;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/160_example_2.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1输出：Intersected at &#39;2&#39;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/160_example_3.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。</code></pre><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>尾部对齐法</li></ol><p>因为当两链表相交时，它们从相交的节点开始到尾节点都是重叠的，因此首先依次遍历两个链表，获取两个链表的长度，然后将长度更长的链表进行对齐操作，之后分别比较对齐后的两链表的元素，若不相等，则分别迭代为next指针指向的元素，若两元素相等，则返回任意一个元素，若不相等，则遍历结束后返回<code>null</code>.</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        &#x2F;&#x2F; 分别计算两个链表的长度        int lenA &#x3D; 0, lenB &#x3D; 0;        ListNode* curA &#x3D; headA;        ListNode* curB &#x3D; headB;        while (curA) &#123;            lenA++;            curA &#x3D; curA-&gt;next;        &#125;        while (curB) &#123;            lenB++;            curB &#x3D; curB-&gt;next;        &#125;        &#x2F;&#x2F; 将较长的链表向后移动，使它们的尾部对齐        curA &#x3D; headA;        curB &#x3D; headB;        if (lenA &gt; lenB) &#123;            for (int i &#x3D; 0; i &lt; (lenA - lenB); i++) &#123;                curA &#x3D; curA-&gt;next;            &#125;        &#125;        else &#123;            for (int i &#x3D; 0; i &lt; (lenB - lenA); i++) &#123;                curB &#x3D; curB-&gt;next;            &#125;        &#125;        while (curA !&#x3D; curB) &#123;            curA &#x3D; curA-&gt;next;            curB &#x3D; curB-&gt;next;        &#125;        if (curA !&#x3D; nullptr) return curA;                return nullptr;    &#125;    &#125;;</code></pre><ol start="2"><li>使用哈希表</li></ol><p>使用一个哈希表存储一个链表的所有元素的地址，接着对另一个链表进行遍历，若另一个链表中有元素的地址和哈希表中的链表地址相等，则返回该元素，否则遍历结束后返回<code>null</code></p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        unordered_set&lt;ListNode*&gt; nodes; &#x2F;&#x2F;使用unordered_set存储链表A的各个元素的地址        while (headA) &#123;            nodes.insert(headA);            headA &#x3D; headA-&gt;next;        &#125;        while (headB) &#123;            if (nodes.count(headB)) &#123; &#x2F;&#x2F; 判断headB的元素地址是否在unordered_set中                return headB;            &#125;            headB &#x3D; headB-&gt;next;        &#125;        return nullptr;    &#125;&#125;;</code></pre><blockquote><p>需要注意的是在C++中因为<code>ListNode</code>没有定义比较方法，所以在这里使用的是 <code>unordered_set&lt;ListNode*&gt;</code></p></blockquote><ol start="3"><li>”快慢指针“法</li></ol><p>使用两个指针分别指向两个链表的头结点，分别进行遍历，若指针在遍历时遍历到了尾节点，则令指向尾节点的指针指向另一个链表的头结点，若两个链表有相交，即有重叠部分时，这两个指针终究会相遇，此时返回相遇的指针即可，若不能相遇，则返回<code>null</code>。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        &#x2F;&#x2F; &quot;快慢指针&quot;        ListNode* pointA &#x3D; headA;        ListNode* pointB &#x3D; headB;        while (pointA !&#x3D; pointB) &#123;            pointA &#x3D; pointA !&#x3D; nullptr? pointA-&gt;next: pointA &#x3D; headB;            pointB &#x3D; pointB !&#x3D; nullptr? pointB-&gt;next: pointB &#x3D; headA;        &#125;        if (pointA !&#x3D; nullptr) return pointA; &#x2F;&#x2F; 需要注意在遍历结束后判断pointA（或pointB)是否为null        return nullptr;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode141.环形链表</title>
      <link href="/2023/03/05/leetcode141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/05/leetcode141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test2.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2], pos &#x3D; 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/circularlinkedlist_test3.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1], pos &#x3D; -1输出：false解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用快慢指针判断是否存在环，如果快指针走到了链表尾部，则直接返回false，若快指针追上了慢指针，则说明链表存在环。C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return false;        ListNode* slow &#x3D; head;        ListNode* fast &#x3D; head-&gt;next;        while (fast !&#x3D; slow) &#123;            &#x2F;&#x2F; 若fast指针走至链表尾部            if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) return false;            fast &#x3D; fast-&gt;next-&gt;next;            slow &#x3D; slow-&gt;next;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode25.交换链表</title>
      <link href="/2023/03/01/leetcode25-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/01/leetcode25-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/swap_ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4]输出：[2,1,4,3]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>直接进行交换，思路如下：</li></ol><p>当链表为空或者只有一个节点时，无需任何操作，直接返回<code>head</code>，否则就定义指针<code>cur</code>和<code>before</code>，初始值分别为<code>head</code>和<code>NULL</code>。当链表中至少有两个节点时进行循环，在循环里定义一个指针<code>tmp</code>，用于指向<code>cur</code>的下一个节点，接下来进行两个节点的交换操作，此时判断before指针是否为空，若不为空则将before的next指向交换完毕的<code>tmp</code>指针，然后更新<code>cur</code>指针的值，继续循环直到链表中未得到交换的元素数小于2停止，最后返回头节点<code>head</code>。C++实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        &#x2F;&#x2F; 如果链表为空或只有一个节点，直接返回头指针        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return head;        &#x2F;&#x2F; 定义指针 cur 和 before，初始值分别为 head 和 NULL        ListNode* cur &#x3D; head;        ListNode* before &#x3D; NULL;        &#x2F;&#x2F; 当链表中至少有两个节点时进行循环        while(cur !&#x3D; NULL &amp;&amp; cur-&gt;next !&#x3D; NULL) &#123;            &#x2F;&#x2F; 定义指针 tmp，将其指向 cur 的下一个节点            ListNode* tmp &#x3D; cur-&gt;next;            &#x2F;&#x2F; 将 cur 的下一个节点指向 tmp 的下一个节点            cur-&gt;next &#x3D; tmp-&gt;next;            &#x2F;&#x2F; 将 tmp 的下一个节点指向 cur，完成交换            tmp-&gt;next &#x3D; cur;            &#x2F;&#x2F; 如果不是第一次交换，则将 before 的下一个节点指向 tmp            if (before !&#x3D; NULL) before-&gt;next &#x3D; tmp;            &#x2F;&#x2F; 如果 cur 是链表头节点，则将 head 指向 tmp            if (cur &#x3D;&#x3D; head) head &#x3D; tmp;            &#x2F;&#x2F; 将 before 指向 cur，cur 指向下一个节点，进行下一次循环            before &#x3D; cur;            cur &#x3D; cur-&gt;next;        &#125;        &#x2F;&#x2F; 返回交换后的链表头指针        return head;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode707.设计链表</title>
      <link href="/2023/02/27/leetcode707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/02/27/leetcode707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和 <code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><span id="more"></span><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回<code>-1</code>。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 <code>index</code> 个节点之前添加值为 <code>val</code> 的节点。如果 <code>index</code> 等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果<code>index</code>小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code> 个节点。</li></ul><p><strong>示例：</strong></p><pre class="language-none"><code class="language-none">MyLinkedList linkedList &#x3D; new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2);   &#x2F;&#x2F;链表变为1-&gt; 2-&gt; 3linkedList.get(1);            &#x2F;&#x2F;返回2linkedList.deleteAtIndex(1);  &#x2F;&#x2F;现在链表是1-&gt; 3linkedList.get(1);            &#x2F;&#x2F;返回3</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= index, val &lt;= 1000</code></li><li>请不要使用内置的 LinkedList 库。</li><li><code>get</code>, <code>addAtHead</code>, <code>addAtTail</code>, <code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的操作次数不超过 <code>2000</code>。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>单链表实现，注意对象成员的定义和初始化。C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class MyLinkedList &#123;private:    struct ListNode &#123;        int val;        ListNode* next;        ListNode(int x) : val(x), next(NULL) &#123;&#125;        &#x2F;&#x2F; 构造函数，用于创建一个新的节点。其中，int x 是该节点的值，val(x) 表示将该值赋给节点的 val 成员变量，next(NULL) 表示将该节点的 next 成员变量初始化为 NULL。整个构造函数的作用是初始化节点的值和指针。    &#125;;    ListNode* head;    int len;public:    &#x2F;** Initialize your data structure here. *&#x2F;    MyLinkedList() &#123;        head &#x3D; NULL;        len &#x3D; 0;    &#125;        &#x2F;** Get the value of the index-th node in the linked list. If the index is invalid, return -1. *&#x2F;    int get(int index) &#123;        if (index &lt; 0 || index &gt;&#x3D; len) &#123;            return -1;        &#125;        ListNode* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        return cur-&gt;val;    &#125;        &#x2F;** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. *&#x2F;    void addAtHead(int val) &#123;        ListNode* newNode &#x3D; new ListNode(val);        newNode-&gt;next &#x3D; head;        head &#x3D; newNode;        len++;    &#125;        &#x2F;** Append a node of value val to the last element of the linked list. *&#x2F;    void addAtTail(int val) &#123;        if (len &#x3D;&#x3D; 0) &#123;            addAtHead(val);            return;        &#125;        ListNode* cur &#x3D; head;        while (cur-&gt;next !&#x3D; NULL) &#123;            cur &#x3D; cur-&gt;next;        &#125;        ListNode* newNode &#x3D; new ListNode(val);        cur-&gt;next &#x3D; newNode;        len++;    &#125;        &#x2F;** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. *&#x2F;    void addAtIndex(int index, int val) &#123;        if (index &lt; 0 || index &gt; len) &#123;            return;        &#125;        if (index &#x3D;&#x3D; 0) &#123;            addAtHead(val);            return;        &#125;        if (index &#x3D;&#x3D; len) &#123;            addAtTail(val);            return;        &#125;        ListNode* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        ListNode* newNode &#x3D; new ListNode(val);        newNode-&gt;next &#x3D; cur-&gt;next;        cur-&gt;next &#x3D; newNode;        len++;    &#125;        &#x2F;** Delete the index-th node in the linked list, if the index is valid. *&#x2F;    void deleteAtIndex(int index) &#123;        if (index &lt; 0 || index &gt;&#x3D; len) &#123;            return;        &#125;        if (index &#x3D;&#x3D; 0) &#123;            ListNode* temp &#x3D; head;            head &#x3D; head-&gt;next;            delete temp;            len--;            return;        &#125;        ListNode* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        ListNode* temp &#x3D; cur-&gt;next;        cur-&gt;next &#x3D; temp-&gt;next;        delete temp;        len--;    &#125;&#125;;</code></pre><ol start="2"><li>双链表实现</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;class MyLinkedList &#123;private:    struct Node &#123;        int val;        Node* prev;        Node* next;        Node(int val) : val(val), prev(nullptr), next(nullptr) &#123;&#125;    &#125;;    Node* head;    Node* tail;    int size;public:    &#x2F;** Initialize your data structure here. *&#x2F;    MyLinkedList() : head(nullptr), tail(nullptr), size(0) &#123;&#125;    &#x2F;** Get the value of the index-th node in the linked list. If the index is invalid, return -1. *&#x2F;    int get(int index) &#123;        if (index &lt; 0 || index &gt;&#x3D; size) &#123;            return -1;        &#125;        Node* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        return cur-&gt;val;    &#125;    &#x2F;** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. *&#x2F;    void addAtHead(int val) &#123;        Node* newNode &#x3D; new Node(val);        if (size &#x3D;&#x3D; 0) &#123;            head &#x3D; tail &#x3D; newNode;        &#125; else &#123;            newNode-&gt;next &#x3D; head;            head-&gt;prev &#x3D; newNode;            head &#x3D; newNode;        &#125;        size++;    &#125;    &#x2F;** Append a node of value val to the last element of the linked list. *&#x2F;    void addAtTail(int val) &#123;        Node* newNode &#x3D; new Node(val);        if (size &#x3D;&#x3D; 0) &#123;            head &#x3D; tail &#x3D; newNode;        &#125; else &#123;            newNode-&gt;prev &#x3D; tail;            tail-&gt;next &#x3D; newNode;            tail &#x3D; newNode;        &#125;        size++;    &#125;    &#x2F;** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list.      * If index is greater than the length, the node will not be inserted. *&#x2F;    void addAtIndex(int index, int val) &#123;        if (index &lt; 0 || index &gt; size) &#123;            return;        &#125;        if (index &#x3D;&#x3D; 0) &#123;            addAtHead(val);            return;        &#125;        if (index &#x3D;&#x3D; size) &#123;            addAtTail(val);            return;        &#125;        Node* cur &#x3D; head;        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;            cur &#x3D; cur-&gt;next;        &#125;        Node* newNode &#x3D; new Node(val);        newNode-&gt;prev &#x3D; cur;        newNode-&gt;next &#x3D; cur-&gt;next;        cur-&gt;next-&gt;prev &#x3D; newNode;        cur-&gt;next &#x3D; newNode;        size++;    &#125;    &#x2F;** Delete the index-th node in the linked list, if the index is valid. *&#x2F;    void deleteAtIndex(int index) &#123;        if (index &lt; 0 || index &gt;&#x3D; size) &#123;            return;        &#125;        if (index &#x3D;&#x3D; 0) &#123;            Node* tmp &#x3D; head;            head &#x3D; head-&gt;next;            if (head !&#x3D; nullptr) &#123;                head-&gt;prev &#x3D; nullptr;            &#125; else &#123;                tail &#x3D; nullptr;            &#125;            delete tmp;        &#125; else if (index &#x3D;&#x3D; size - 1) &#123;            Node* tmp &#x3D; tail;        tail &#x3D; tail-&gt;prev;        tail-&gt;next &#x3D; nullptr;        delete tmp;        &#125; else &#123;            Node* cur &#x3D; head;            for (int i &#x3D; 0; i &lt; index; i++) &#123;                cur &#x3D; cur-&gt;next;            &#125;            cur-&gt;prev-&gt;next &#x3D; cur-&gt;next;            cur-&gt;next-&gt;prev &#x3D; cur-&gt;prev;            delete cur;        &#125;        size--;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode206.反转链表</title>
      <link href="/2023/02/27/leetcode206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/02/27/leetcode206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/rev1ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5]输出：[5,4,3,2,1]</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/rev1ex2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2]输出：[2,1]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归方式</li></ol><p>在这个实现中，我们首先检查链表是否为空或只有一个节点。如果是这样，我们直接返回该节点，因为没有必要反转链表。</p><p>如果链表中有多个节点，我们将递归调用 <code>reverseList</code> 函数来反转链表的后半部分。然后，我们将当前节点连接到反转后的链表的末尾，将当前节点作为新的尾节点，连接到 NULL。最后，返回新的头节点。</p><p>这个递归方法的时间复杂度是 O(n)，其中 n 是链表的长度。虽然它可能需要使用堆栈来存储递归调用的上下文，但它通常比迭代方法更简洁易懂。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * 以链表1-&gt;2-&gt;3-&gt;4-&gt;5举例 * @param head * @return *&#x2F;ListNode* reverseList(ListNode* head) &#123;    if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#123;        &#x2F;*            直到当前节点的下一个节点为空时返回当前节点            由于5没有下一个节点了，所以此处返回节点5         *&#x2F;        return head;    &#125;    &#x2F;&#x2F;递归传入下一个节点，目的是为了到达最后一个节点    ListNode* newHead &#x3D; reverseList(head-&gt;next);    &#x2F;*        第一轮出栈，head为5，head-&gt;next为空，返回5        第二轮出栈，head为4，head-&gt;next为5，执行head-&gt;next-&gt;next&#x3D;head也就是5-&gt;next&#x3D;4，                  把当前节点的子节点的子节点指向当前节点                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4-&gt;next&#x3D;null                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5                  返回节点5        第三轮出栈，head为3，head-&gt;next为4，执行head-&gt;next-&gt;next&#x3D;head也就是4-&gt;next&#x3D;3，                  此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3-&gt;next&#x3D;null                  此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5                  返回节点5        第四轮出栈，head为2，head-&gt;next为3，执行head-&gt;next-&gt;next&#x3D;head也就是3-&gt;next&#x3D;2，                  此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2-&gt;next&#x3D;null                  此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5                  返回节点5        第五轮出栈，head为1，head-&gt;next为2，执行head-&gt;next-&gt;next&#x3D;head也就是2-&gt;next&#x3D;1，                  此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1-&gt;next&#x3D;null                  此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5                  返回节点5        出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1     *&#x2F;    head-&gt;next-&gt;next &#x3D; head;    head-&gt;next &#x3D; nullptr;    return newHead;&#125;</code></pre><ol start="2"><li>迭代方式（头插法）</li></ol><p>头插法的基本思路是，将链表的每个节点插入到新链表的头部。由于头插法是从头部开始插入，因此我们需要一个指针来跟踪新链表的头部。</p><p>在这个实现中，我们首先定义一个新链表的头部指针 <code>newHead</code>，并将其初始化为 NULL。</p><p>然后，我们遍历原链表中的每个节点。在每个迭代中，我们先记录当前节点的下一个节点，然后将当前节点插入到新链表的头部。为此，我们将当前节点的 <code>next</code> 指针指向新链表的头部，然后将新链表的头部指针指向当前节点。</p><p>最后，我们将当前节点更新为原链表中的下一个节点，并重复这个过程，直到我们遍历完整个链表。</p><p>这个方法的时间复杂度是 O(n)，其中 n 是链表的长度。它不需要额外的空间来存储递归调用的上下文，因此它通常比递归方法更快。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        &#x2F;&#x2F; 新链表的头节点指针，初始为 NULL        ListNode* newHead &#x3D; NULL;        &#x2F;&#x2F; 依次遍历原链表中的每个节点        while (head !&#x3D; NULL) &#123;            &#x2F;&#x2F; 记录当前节点的下一个节点            ListNode* next &#x3D; head-&gt;next;            &#x2F;&#x2F; 将当前节点插入到新链表的头部            head-&gt;next &#x3D; newHead;            newHead &#x3D; head;            &#x2F;&#x2F; 处理下一个节点            head &#x3D; next;        &#125;        &#x2F;&#x2F; 返回新链表的头节点指针        return newHead;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode203.移除链表元素</title>
      <link href="/2023/02/26/leetcode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2023/02/26/leetcode203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/removelinked-list.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6输出：[1,2,3,4,5]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [], val &#x3D; 1输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [7,7,7,7], val &#x3D; 7输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>虚拟头节点法：</li></ol><p>若使用常规思路，在移除节点有两种情况：</p><ul><li><p>非头节点的移除：直接讲被删除节点的前一个节点同被删除节点的后一个节点连接，然后删除当前的被删除节点；</p></li><li><p>头节点的移除：新建一个节点指向头节点，令头节点等于头节点的后继节点，然后删除刚才指向头节点的新建节点。</p></li></ul><p>为了防止需要写两个逻辑判断到底怎么删除节点，在这里直接使用一个虚拟节点，他的后继节点指向头节点，此时本来需要被特殊处理的头节点也可以按照非头节点的移除方法进行移除了，在循环的最后删除虚拟头节点，返回虚拟头节点的后继节点（即真实头节点）。C++代码实现思路如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* visualHead &#x3D; new ListNode(0); &#x2F;&#x2F; 新建虚拟头节点        visualHead-&gt;next &#x3D; head;        ListNode* cur &#x3D; visualHead; &#x2F;&#x2F; cur指现在要处理的节点，默认指向虚拟头节点        while (cur-&gt;next!&#x3D;NULL) &#123; &#x2F;&#x2F; 开始循环            if (cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123; &#x2F;&#x2F; 如果值匹配，则进行删除                ListNode* tmp &#x3D; cur-&gt;next;                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;                delete tmp;            &#125; else &#123; &#x2F;&#x2F; 否则当前指针更新为它的next指针指向的元素                cur &#x3D; cur-&gt;next;            &#125;        &#125;        head &#x3D; visualHead-&gt;next; &#x2F;&#x2F; 得到删除对应元素之后的头节点        delete visualHead; &#x2F;&#x2F; 删除虚拟头节点，以降低空间复杂度        return head; &#x2F;&#x2F; 返回头节点，算法结束    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode330.按要求补齐数组</title>
      <link href="/2023/02/23/leetcode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2023/02/23/leetcode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个已排序的正整数数组 <code>nums</code> <em>，</em>和一个正整数 <code>n</code> <em>。</em>从 <code>[1, n]</code> 区间内选取任意个数字补充到 nums 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 nums 中某几个数字的和来表示。</p><p>请返回 <em>满足上述要求的最少需要补充的数字个数</em> 。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3], n &#x3D; 6输出: 1 解释:根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。所以我们最少需要添加一个数字。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,5,10], n &#x3D; 20输出: 2解释: 我们需要添加 [2,4]。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,2,2], n &#x3D; 5输出: 0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>升序排列</strong></li><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>贪心算法</li></ol><p>题目使用的是贪心算法。贪心算法的基本思想是，在每一步选择中都选择当前状态下最优的选择，以求得最终的全局最优解。</p><p>对于这道题，我们的贪心策略是在已经被覆盖的区间内，选择尽可能靠右的数字来扩展区间，这样可以让被覆盖的区间尽可能的大，从而让需要添加的数字的数量尽可能的少。</p><p>当遍历到一个数时，如果这个数小于等于 <code>covered + 1</code>，那么它可以被当前的区间所覆盖，因此可以将它加入到被覆盖的区间内，更新 <code>covered</code> 的值(<code>covered += nums[i]</code>)。如果这个数大于 <code>covered + 1</code>，那么当前的区间无法覆盖它，因此需要添加一个新的数字，使得被覆盖的区间能够扩展到这个数，更新 <code>covered</code> 的值(<code>covered += covered + 1</code>)。</p><p>这个贪心策略的正确性可以通过反证法来证明：假设存在一个更优的解，使得需要添加的数字的数量比当前算法得到的解更少。那么这个更优的解必然包含一个数字 x，它是我们在当前算法中添加的数字。如果将 x 从更优的解中删除，那么这个解就会变成一个覆盖范围更小、需要添加的数字数量相同的解，与我们的假设矛盾。因此，当前算法得到的解就是最优解，贪心策略是正确的。</p><p>可以先求解所有需要被插入的数字，再返回拥有所有被插入数字的数组的长度，实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;        vector&lt;int&gt; patches; &#x2F;&#x2F; 用于保存需要插入的数字        long long int covered &#x3D; 0; &#x2F;&#x2F;用longlong类型存储当前已经被覆盖的数的范围        int i &#x3D; 0; &#x2F;&#x2F;nums数组的下标        while (covered &lt; n) &#123; &#x2F;&#x2F; 只要还没有覆盖到n，就需要添加数字            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;                &#x2F;&#x2F; 如果nums[i]小于等于当前已经被覆盖的数的下一个数(covered + 1)                &#x2F;&#x2F; 那么就可以将nums[i]加入到被覆盖的范围内                covered +&#x3D; nums[i];                i++;            &#125; else &#123;                &#x2F;&#x2F; 如果nums[i]大于covered + 1, 那么就需要添加一个新的数字                int patch &#x3D; covered + 1;                covered +&#x3D; patch;                patches.push_back(patch);            &#125;        &#125;        return patches.size();    &#125;&#125;;</code></pre><p>因为题目并没有要求存储被插入的数组，为了更低的空间占用，可以不存储要插入的数字，直接对计数器<code>count</code>自加一：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;        long long int covered &#x3D; 0;  &#x2F;&#x2F; 用 long long 类型存储当前已经被覆盖的数的范围        int count &#x3D; 0;  &#x2F;&#x2F; 记录需要添加的数字的数量        int i &#x3D; 0;  &#x2F;&#x2F; nums 数组的下标        while (covered &lt; n) &#123;  &#x2F;&#x2F; 只要还没有覆盖到 n，就需要添加数字            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;                &#x2F;&#x2F; 如果 nums[i] 小于等于当前已经被覆盖的数的下一个数（covered + 1）                &#x2F;&#x2F; 那么就可以将 nums[i] 加入到被覆盖的范围内                covered +&#x3D; nums[i];                i++;            &#125; else &#123;                &#x2F;&#x2F; 如果 nums[i] 大于 covered + 1，那么就需要添加一个新的数字                covered +&#x3D; covered + 1;                count++;            &#125;        &#125;        return count;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode435.无重叠区间</title>
      <link href="/2023/02/22/leetcode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
      <url>/2023/02/22/leetcode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p><span id="more"></span> <p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: intervals &#x3D; [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 105</code></li><li><code>intervals[i].length == 2</code></li><li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><p>首先按照区间的结束位置从小到大排序，然后从前往后遍历所有区间，若当前区间和前面的区间不重叠，则保留当前区间，继续向后遍历；否则就舍弃当前区间，再继续向后遍历。最后返回被舍弃的区间数即可。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        int n &#x3D; intervals.size();        if (n &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        &#x2F;&#x2F; 按照区间的结束位置从小到大排序        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;            return a[1] &lt; b[1];        &#125;);        int cnt &#x3D; 1;  &#x2F;&#x2F; 不重叠区间的个数，初始值为1        int end &#x3D; intervals[0][1];  &#x2F;&#x2F; 当前不重叠区间的结束位置，初始值为第一个区间的结束位置        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (intervals[i][0] &gt;&#x3D; end) &#123;  &#x2F;&#x2F; 如果当前区间的起始位置大于等于当前不重叠区间的结束位置                cnt++;  &#x2F;&#x2F; 将不重叠区间的个数加1                end &#x3D; intervals[i][1];  &#x2F;&#x2F; 更新当前不重叠区间的结束位置            &#125;            &#x2F;&#x2F; 如果当前区间的起始位置小于当前不重叠区间的结束位置，说明当前区间与前面的区间重叠了，不能选            &#x2F;&#x2F; 不需要执行任何操作，直接跳过        &#125;        return n - cnt;  &#x2F;&#x2F; 总区间个数减去不重叠区间的个数，即为需要去除的重叠区间的最小个数    &#125;&#125;;</code></pre><p>注：在sort函数中第三个参数为匿名函数，其中的参数是数组，因此：</p><blockquote><p>在排序算法中，通常需要交换数组或容器中的元素位置来实现排序的目的。如果直接将数组或容器作为参数传递给比较函数，那么在函数内部交换元素位置时，就需要复制整个数组或容器，这样会造成不必要的开销。</p><p>因此，通常使用指向数组或容器中元素的指针或引用类型作为比较函数的参数，这样在交换元素位置时只需要交换指针或引用，而不需要复制整个数组或容器。这样可以减小开销，提高效率。</p><p>在本题中，使用 <code>vector&lt;int&gt;&amp;</code> 类型的引用作为比较函数的参数，可以避免复制整个二维向量，同时也可以保证比较函数的参数类型与 STL 中的排序算法所需的参数类型相同，方便函数间的传递和调用。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode45.跳跃游戏II</title>
      <link href="/2023/02/21/leetcode45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
      <url>/2023/02/21/leetcode45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p> <span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [2,3,0,1,4]输出: 2</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li>题目保证可以到达 <code>nums[n-1]</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>贪心算法</li></ol><p>算法思路是：遍历数组，用变量 <code>max_pos</code> 记录当前能够到达的最远位置，用变量 <code>end_pos</code> 记录当前步数下能够到达的最远位置，如果遍历到 <code>end_pos</code>，则更新 <code>end_pos</code> 为 <code>max_pos</code>，并将步数加 1。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        if (n &#x3D;&#x3D; 1) return 0; &#x2F;&#x2F; 如果数组只有一个元素，返回 0        int steps &#x3D; 0, max_pos &#x3D; 0, end_pos &#x3D; 0;        &#x2F;&#x2F; steps：跳跃的步数，max_pos：当前能够到达的最远位置，end_pos：当前步数下能够到达的最远位置        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;            &#x2F;&#x2F; 遍历数组，到达 n - 1 时不需要再跳跃，因为已经到达了终点            max_pos &#x3D; max(max_pos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远位置            if (i &#x3D;&#x3D; end_pos) &#123; &#x2F;&#x2F; 如果到达了当前步数下能够到达的最远位置，需要增加步数                end_pos &#x3D; max_pos; &#x2F;&#x2F; 更新当前步数下能够到达的最远位置                steps++; &#x2F;&#x2F; 增加步数            &#125;        &#125;        return steps; &#x2F;&#x2F; 返回跳跃的步数    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode860.柠檬水找零</title>
      <link href="/2023/02/20/leetcode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
      <url>/2023/02/20/leetcode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：bills &#x3D; [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：bills &#x3D; [5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bills.length &lt;= 105</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路</li></ol><p>使用一个大小为2的数组count存储5元纸币和10元纸币的数量，接着对数组bills进行遍历，当满足条件时将对应的纸币数量进行加减，若成功遍历整个数组，则说明可以找零(<code>return true</code>)，否则无法找零(<code>return false</code>)。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;        vector&lt;int&gt; count(2,0);        for (int i &#x3D; 0; i &lt; bills.size(); i++) &#123;            if (bills[i] &#x3D;&#x3D; 5) &#123;                count[0]++;            &#125;            else if (bills[i] &#x3D;&#x3D; 10) &#123;                if (count[0] !&#x3D; 0) &#123;                    count[0]--;                    count[1]++;                &#125;                else return false;            &#125;            else if (bills[i] &#x3D;&#x3D; 20)&#123;                &#x2F;&#x2F;20 usd&#39;s situation                if (count[1] &gt; 0 &amp;&amp; count[0] &gt; 0) &#123;                    count[0]--;                    count[1]--;                &#125;                else if (count[0] &gt;&#x3D; 3) &#123;                    count[0] -&#x3D; 3;                &#125;                else return false;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode455.分发饼干</title>
      <link href="/2023/02/19/leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
      <url>/2023/02/19/leetcode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><span id="more"></span> <p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路</li></ol><p>对两个数组进行排序，然后使用双层for循环进行贪心的遍历查找；C++实现代码如下，但是显然还有优化空间。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(), g.end());        sort(s.begin(), s.end()); &#x2F;&#x2F;排列数组        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; g.size(); i++) &#123;            for (int j &#x3D; 0; j &lt; s.size(); j++) &#123;                if (s[j] &gt;&#x3D; g[i]) &#123;                    &#x2F;&#x2F; 如果满足条件，则result++,且修改s中的数值。                    &#x2F;&#x2F; g中的无需修改，因为循环会继续                    result++;                    s[j] &#x3D; -1;                    break;                &#125;            &#125;        &#125;        return result;         &#125;&#125;;</code></pre><ol start="2"><li>使用双指针优化刚才的双层for循环，C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(), g.end());        sort(s.begin(), s.end()); &#x2F;&#x2F;排列数组        int result &#x3D; 0;        int i &#x3D; 0, j &#x3D; 0;        while (i &lt; g.size() &amp;&amp; j &lt; s.size()) &#123;            if (s[j] &gt;&#x3D; g[i]) &#123;                result++;                i++;                j++;                        &#125;            else j++;        &#125;        return result;         &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode135.分发糖果</title>
      <link href="/2023/02/17/leetcode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
      <url>/2023/02/17/leetcode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：ratings &#x3D; [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：ratings &#x3D; [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>常规思路</li></ol><p>首先新建一个数组candies，它代表每个人能分得的糖果数，接下来进行两次遍历：第一次从左向右遍历，确保右边评分较高的小孩获得更多的糖果，第二次从右向左遍历，确保左边评分较高的小孩获得更多的糖果。代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        int n &#x3D; ratings.size();        vector&lt;int&gt; candies(n, 1);              &#x2F;&#x2F; 从左往右扫描，保证右边评分高的孩子分到更多的糖果        for (int i &#x3D; 1; i &lt; n; i++) &#123;            if (ratings[i] &gt; ratings[i - 1]) &#123;                candies[i] &#x3D; candies[i - 1] + 1;            &#125;        &#125;              &#x2F;&#x2F; 从右往左扫描，保证左边评分高的孩子分到更多的糖果        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;            if (ratings[i] &gt; ratings[i + 1]) &#123;                candies[i] &#x3D; max(candies[i], candies[i + 1] + 1);            &#125;                    &#125;        &#x2F;&#x2F; 计算糖果总数        int result &#x3D; 0;        for (int item: candies) &#123;            result +&#x3D; item;        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode122.买卖股票的最佳时机II</title>
      <link href="/2023/02/16/leetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
      <url>/2023/02/16/leetcode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。     总利润为 4 + 3 &#x3D; 7 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     总利润为 4 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li><p>使用贪心法</p><p>为什么要使用贪心法？因为题目明确暗示了：“你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。”</p><p>因此解题思路如下：首先定义一个整形变量result用于存储结果，接着从左向右遍历数组price,若<code>price[i] &lt; price[i+1]</code>，则说明第i天的价格低于第i+1天的价格，此时可以在第i天购买股票然后在第i+1天卖出，将卖出的价格减去前一天买入的价格的差值加到result中，然后继续向右遍历，直至遍历结束，返回result.</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n &#x3D; prices.size();        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;            int j &#x3D; i + 1;            if (prices[j] &gt; prices[i]) &#123;                result &#x3D; result - prices[i] + prices[j];            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><p>虽然走了一些弯路，但是还是做出来了，所以… 稍微得瑟一下：</p><p><img src="http://cdn.leafii.top/img/image-20230216164402662.png" alt="image-20230216164402662" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode55.跳跃游戏</title>
      <link href="/2023/02/15/leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2023/02/15/leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>利用栈（<strong>超时</strong>）</li></ol><p>将能到达的数组元素推进栈，模拟树的操作，但是会超时。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int len &#x3D; nums.size();        if (len &gt; 1 &amp;&amp; nums[0] &#x3D;&#x3D; 0) return false;        if (len &#x3D;&#x3D; 1) return true;        stack&lt;int&gt; s; &#x2F;&#x2F; 定义一个栈        int index &#x3D; 0;        if (nums[index] &gt; len) return true;        s.push(index);        while(!s.empty()) &#123;            int temp_index &#x3D; s.top();            int temp_num &#x3D; nums[temp_index];            s.pop();            for (int i &#x3D; 1; i &lt;&#x3D; temp_num; i++) &#123;                if (temp_index + i &#x3D;&#x3D; len - 1) return true;                if (nums[temp_index + i] &gt;&#x3D; (len - (temp_index + i))) return true;                if (nums[temp_index + i] !&#x3D; 0) s.push(temp_index + i);            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><p>用chatGPT分析超时的原因：</p><blockquote><p>您的代码的时间复杂度为 O(2^n)，其中 n 是数组的长度，因为在每个位置都可以有两个选择：跳或不跳，总共有 2^n 种可能的路径。这样的时间复杂度是无法通过本题的。</p><p>此外，您使用了栈来存储待搜索的位置，但这样的做法并不高效。因为每个位置最多只需要被遍历一次，而使用栈会重复遍历一些位置，导致时间复杂度进一步增加。</p></blockquote><ol start="2"><li>使用贪心算法</li></ol><p>使用贪心算法，从左到右遍历数组，用一个变量来维护能够到达的最远距离，如果当前位置在这个最远距离之内，那么更新最远距离。如果遍历结束后最远距离大于等于数组的最后一个位置，那么就说明可以到达最后一个位置，否则就无法到达。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int n &#x3D; nums.size();        int maxPos &#x3D; 0; &#x2F;&#x2F; 当前能到达的最远距离        for (int i &#x3D; 0; i &lt; n; i++) &#123;            if (i &gt; maxPos) return false; &#x2F;&#x2F; 如果当前位置无法到达，则返回false            maxPos &#x3D; max(maxPos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远距离            if (maxPos &gt;&#x3D; n - 1) return true; &#x2F;&#x2F; 如果能够到达最后一个位置，返回true        &#125;        return false;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode101.对称二叉树</title>
      <link href="/2023/02/14/leetcode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/02/14/leetcode101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/symtree1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,4,4,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/symtree2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,2,2,null,3,null,3]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>初见思路（<strong>无法通过</strong>）：</li></ol><p>本来是想直接通过中序遍历获得一个数组，然后从数组的两端向中间进行判断，最后样例通过数为192&#x2F;199，原因是如果输入为<code>[1,2,2,2,null,2]</code>时，中序遍历得到的数组是对称的，但是实际上这个二叉树不是对称的。因此该思路被我放弃了。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F; &#x2F;&#x2F; 3241423 中序遍历 先左再中间最后右子树class Solution &#123;public:    void Middle_order_traversal(TreeNode* rootNode, vector&lt;int&gt;&amp; rst) &#123;        if (rootNode) &#123;            Middle_order_traversal(rootNode -&gt; left, rst);            rst.push_back(rootNode -&gt; val);            Middle_order_traversal(rootNode -&gt; right, rst);        &#125;        else &#123;            rst.push_back(-1);        &#125;    &#125;    bool isSymmetric(TreeNode* root) &#123;        vector&lt;int&gt; rst;        Middle_order_traversal(root, rst);        if (rst.size()%2&#x3D;&#x3D;0) &#123;            return false;        &#125;        int left &#x3D; 0, right &#x3D; rst.size() - 1;        while(left &lt; right) &#123;            if (rst[left] !&#x3D; rst[right]) &#123;                return false;            &#125;            left++;            right--;        &#125;        return true;    &#125;&#125;;</code></pre><ol start="2"><li>使用递归：</li></ol><p>在对root进行判断之后，就使用一个辅助函数对root的左子树和右子树进行判断，判断完成后分别对左子树的左子树和右子树的右子树；左子树的右子树以及右子树的左子树进行判断，两个判断结果进行与运算，递归得到最终结果。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若根节点为空，则返回true        return isSymmetricHelper(root-&gt;left, root-&gt;right);    &#125;    bool isSymmetricHelper(TreeNode* left, TreeNode* right) &#123;        if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若左右都为空，则返回true      &#x2F;&#x2F; if ((left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) || (left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL)) return false; &#x2F;&#x2F; 左右子树一个空一个不空，返回false (下面这行更简练)        if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;若左右节点有一个不为空，则返回false        if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F;若左右节点的值不相等，则返回false        &#x2F;&#x2F;递归检查左右子树是否对称        return isSymmetricHelper(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetricHelper(left-&gt;right, right-&gt;left);    &#125;&#125;;</code></pre><ol start="3"><li>使用迭代</li></ol><p>该解决方案使用队列来存储树的节点，首先将左子树和右子树的根节点加入队列中。然后在循环中，每次取出队列的头两个节点，并比较它们是否对称，如果不对称则返回false。如果对称，则将左节点的左子树节点和右节点的右子树节点加入队列，再将左节点的右子树节点和右节点的左子树节点加入队列。如果队列为空，则说明树是对称的，返回true。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;节点为空，返回true        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 定义一个队列存储节点        q.push(root-&gt;left);        q.push(root-&gt;right);        while (!q.empty()) &#123;            TreeNode* left &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为左节点            TreeNode* right &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为右节点            if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) continue; &#x2F;&#x2F;如果左右节点都为空，则继续迭代            if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;左右节点只有一个不为空，直接返回false            if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F; 左右节点值不等，直接返回false            q.push(left-&gt;left);            q.push(right-&gt;right);            q.push(left-&gt;right);            q.push(right-&gt;left); &#x2F;&#x2F; 注意push的顺序！！！        &#125;         return true; &#x2F;&#x2F;若队列为空，则说明该二叉树是对称的。    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode100.相同的树</title>
      <link href="/2023/02/13/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
      <url>/2023/02/13/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：p &#x3D; [1,2,3], q &#x3D; [1,2,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="http://cdn.leafii.top/img/ex2.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：p &#x3D; [1,2], q &#x3D; [1,null,2]输出：false</code></pre><p><strong>示例 3：</strong></p><p><img src="http://cdn.leafii.top/img/ex3.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：p &#x3D; [1,2,1], q &#x3D; [1,1,2]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>解题思路：</p><p>题目要求判断两棵树是否完全相同。</p><p>我们可以使用递归的方法，递归判断两棵树的根节点是否相同，以及它们的左子树和右子树是否相同。</p><p>如果两棵树都为空，则返回 true。如果有一棵树为空，另一棵树不为空，则返回 false。如果两棵树的根节点的值不相等，则返回 false。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 递归函数，判断两棵树是否相同    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        &#x2F;&#x2F; 如果两棵树都为空，则返回 true        if (!p &amp;&amp; !q) return true;        &#x2F;&#x2F; 如果有一棵树为空，另一棵树不为空，则返回 false        if (!p || !q) return false;        &#x2F;&#x2F; 如果两棵树的根节点的值不相等，则返回 false        if (p-&gt;val !&#x3D; q-&gt;val) return false;        &#x2F;&#x2F; 递归判断两棵树的左子树和右子树是否相同        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);    &#125;&#125;;</code></pre><p>可以将代码简化为：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        &#x2F;&#x2F; 如果两棵树都为空或者都不为空且值相等，则继续递归        if (!p &amp;&amp; !q) return true;        if (p &amp;&amp; q &amp;&amp; p-&gt;val &#x3D;&#x3D; q-&gt;val)            return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);        &#x2F;&#x2F; 否则，返回 false        return false;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:76.最小覆盖子串</title>
      <link href="/2023/02/09/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/02/09/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;输出：&quot;BANC&quot;解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#39;A&#39;、&#39;B&#39; 和 &#39;C&#39;。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;输出：&quot;a&quot;解释：整个字符串 s 是最小覆盖子串。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;输出: &quot;&quot;解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</code></pre><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>滑动窗口</li></ol><p>一个常见的解决方案是使用双指针法和滑动窗口技巧，并利用一个哈希表来维护字符串 <code>t</code> 中字符的出现次数。</p><p>我们用两个指针分别指向当前枚举的子串的左端点和右端点，同时用一个计数器维护当前子串是否已经包含了字符串 <code>t</code> 中的所有字符。</p><p>每当右指针移动到一个字符时，如果该字符在字符串 <code>t</code> 中出现过，则将哈希表中该字符的计数器减一，同时如果该字符的计数器减一后不再为 0，则将计数器减一，表示该字符已经被包含在当前子串中了。</p><p>当计数器变成 0 时，说明当前子串已经包含了字符串 <code>t</code> 中的所有字符，此时开始移动左指针，直到该子串不再包含字符串 <code>t</code> 中的所有字符，此时计数器再次变成非 0 的值，表示当前子串不再完整包含字符串 <code>t</code>。</p><p>在整个过程中，每当移动左指针时，同时记录当前子串的长度是否比之前记录的子串长度更短，如果是，则将当前子串的长度和起始位置记录下来，作为结果的可能。</p><p>这样，我们就可以在 $O(m + n)$ 的时间复杂度内解决此问题。</p><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    string minWindow(string s, string t) &#123;        unordered_map&lt;char, int&gt; t_map;        for (const char&amp; c : t) &#123;            ++t_map[c];        &#125;        int left &#x3D; 0, right &#x3D; 0, count &#x3D; t.length(), min_len &#x3D; INT_MAX, min_start &#x3D; 0;        while (right &lt; s.length()) &#123;            &#x2F;&#x2F; 右指针右移            if (t_map[s[right++]]-- &gt; 0) &#123;                --count;            &#125;            while (count &#x3D;&#x3D; 0) &#123;                if (right - left &lt; min_len) &#123;                    min_len &#x3D; right - left;                    min_start &#x3D; left;                &#125;                &#x2F;&#x2F; 左指针左移                if (t_map[s[left++]]++ &#x3D;&#x3D; 0) &#123;                    ++count;                &#125;            &#125;        &#125;        return min_len &#x3D;&#x3D; INT_MAX ? &quot;&quot; : s.substr(min_start, min_len);    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:59.螺旋矩阵II</title>
      <link href="/2023/02/09/leetcode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
      <url>/2023/02/09/leetcode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个正整数 $n$ ，生成一个包含 $1$ 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 $n \times n$ 正方形矩阵 <code>matrix</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：[[1,2,3],[8,9,4],[7,6,5]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>定义四个变量<code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>，分别代表矩阵的上下左右边界。</li><li>定义一个变量 <code>count</code> 表示当前元素的值，初始值为1。</li><li>只要 <code>top &lt;= bottom &amp;&amp; left &lt;= right</code> ，循环执行以下步骤：<ol><li>先向右填充 <code>top</code> 行的元素，元素的值递增，并将 <code>top</code> 向下移动1。</li><li>向下填充 <code>right</code> 列的元素，元素的值递增，并将 <code>right</code> 向左移动1。</li><li>如果 <code>top &lt;= bottom</code> ，向左填充 <code>bottom</code> 行的元素，元素的值递增，并将 <code>bottom</code> 向上移动1。</li><li>如果 <code>left &lt;= right</code> ，向上填充 <code>left</code> 列的元素，元素的值递增，并将 <code>left</code> 向右移动1。</li></ol></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 0));        int top &#x3D; 0, bottom &#x3D; n - 1, left &#x3D; 0, right &#x3D; n - 1;        int count &#x3D; 1;        while (top &lt;&#x3D; bottom &amp;&amp; left &lt;&#x3D; right) &#123;            for (int j &#x3D; left; j &lt;&#x3D; right; j++) &#123;                matrix[top][j] &#x3D; count++;            &#125;            top++;            for (int i &#x3D; top; i &lt;&#x3D; bottom; i++) &#123;                matrix[i][right] &#x3D; count++;            &#125;            right--;            if (top &lt;&#x3D; bottom) &#123;                for (int j &#x3D; right; j &gt;&#x3D; left; j--) &#123;                    matrix[bottom][j] &#x3D; count++;                &#125;                bottom--;            &#125;            if (left &lt;&#x3D; right) &#123;                for (int i &#x3D; bottom; i &gt;&#x3D; top; i--) &#123;                    matrix[i][left] &#x3D; count++;                &#125;                left++;            &#125;        &#125;        return matrix;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:209.长度最小的子数组</title>
      <link href="/2023/02/07/leetcode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2023/02/07/leetcode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：target &#x3D; 4, nums &#x3D; [1,4,4]输出：1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>滑动窗口法</li></ol><p>直接使用双重for循环会超时，因此在这里使用滑动窗口的思想，在一个for循环中解决问题，在for循环中索引值为窗口的右边界。当<code>sum &gt;= target</code>时，窗口左边的指针进行右移，同时<code>sum -= nums[i++]</code>，最终遍历结束就得到了左指针和右指针的最终位置。结果为右指针-左指针+1.</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int sum &#x3D; 0;        int n &#x3D; nums.size();        for (int num : nums) &#123;            if (num &#x3D;&#x3D; target) &#123;                return 1; &#x2F;&#x2F;若数组中有包含target的值，直接返回1            &#125;            sum +&#x3D; num;        &#125;        if (sum &lt; target) &#123;            return 0; &#x2F;&#x2F;若数组所有正数之和均小于target，则直接返回0        &#125;else if (sum &#x3D;&#x3D; target) &#123;            return nums.size();&#x2F;&#x2F;若数组所有正数之和刚好等于target，则直接返回数组的长度        &#125;else &#123;            int result &#x3D; INT32_MAX;&#x2F;&#x2F;初始化为int的最大值            int sum &#x3D; 0;            int i &#x3D; 0;            int subLength &#x3D; 0;            for(int j &#x3D; 0; j &lt; nums.size(); j++) &#123; &#x2F;&#x2F;窗口右边界                sum +&#x3D; nums[j];                while (sum &gt;&#x3D; target) &#123;                    subLength &#x3D; j - i + 1;                    result &#x3D; result &lt; subLength? result:subLength;                    sum -&#x3D; nums[i++]; &#x2F;&#x2F;滑动窗口                &#125;            &#125;            return result;        &#125;        return 0;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:977.有序数组的平方</title>
      <link href="/2023/02/06/leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2023/02/06/leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-7,-3,2,3,11]输出：[4,9,9,49,121]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>常规思路</li></ol><p>先对每个数组的元素进行平方赋值，然后对数组进行排序。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            nums[i] &#x3D; nums[i] * nums[i];        &#125;        sort(nums.begin(), nums.end()); &#x2F;&#x2F;排序        return nums;    &#125;&#125;;</code></pre><ol start="2"><li>利用指向正负分界线的指针构造“归并排序”</li></ol><p>常规思路未使用题目的“非递减顺序数组”的条件，因此我们新建一个指针，它指向数组中的最后一个非正数元素，然后从中间向两边进行遍历，将平方和较小的结果插入rst数组中。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; rst;        int n &#x3D; nums.size();        &#x2F;&#x2F;1. 获取数组正负边界索引        int index &#x3D; -1;        for(int i &#x3D; 0; i &lt; n; i++) &#123;            if (nums[i] &lt; 0) &#123;                index &#x3D; i;            &#125;            else &#123;                break;            &#125;        &#125;        &#x2F;&#x2F;2. 双指针从中间向两边遍历        int i &#x3D; index;        int j &#x3D; index + 1;        while(i &gt;&#x3D; 0 || j &lt; n) &#123;            if (i &lt; 0) &#123;                rst.push_back(nums[j] * nums[j]);                j++;            &#125;            else if (j &#x3D;&#x3D; n) &#123;                rst.push_back(nums[i] * nums[i]);                i--;            &#125;            else if (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;                rst.push_back(nums[i] * nums[i]);                i--;            &#125;            else &#123;                rst.push_back(nums[j] * nums[j]);                j++;            &#125;        &#125;        return rst;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:704.二分查找</title>
      <link href="/2023/02/05/leetcode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/02/05/leetcode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2输出: -1解释: 2 不存在 nums 中因此返回 -1</code></pre><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>如题目所示，直接使用二分查找即可。C++代码实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int size &#x3D; nums.size();        int left &#x3D; 0;        int right &#x3D; size - 1;        int mid &#x3D; (left + (right - left) &#x2F; 2);        while(nums[mid] !&#x3D; target &amp;&amp; left &lt; right) &#123;            if (nums[mid] &gt; target) &#123;                right &#x3D; mid - 1;            &#125;            else &#123;                left &#x3D; mid + 1;            &#125;            mid &#x3D; (left + (right - left) &#x2F; 2);        &#125;        if (nums[mid] &#x3D;&#x3D; target) &#123;            return mid;        &#125;        return -1;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:37.解数独</title>
      <link href="/2023/02/03/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
      <url>/2023/02/03/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/250px-sudoku-by-l2g-20050714svg.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</code></pre><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>我们可以考虑按照「行优先」的顺序依次枚举每一个空白格中填的数字，通过递归 + 回溯的方法枚举所有可能的填法。当递归到最后一个空白格后，如果仍然没有冲突，说明我们找到了答案；在递归的过程中，如果当前的空白格不能填下任何一个数字，那么就进行回溯。</p><p>由于每个数字在同一行、同一列、同一个九宫格中只会出现一次，因此我们可以使用<code>line[i]，column[j]，block[x][y]</code>分别表示第 i 行，第 j 列，第(x,y) 个九宫格中填写数字的情况。在下面给出的三种方法中，我们将会介绍两种不同的表示填写数字情况的方法。</p><blockquote><p>九宫格的范围为 $0 \leq x \leq 2$以及 $0 \leq y \leq 2$。 具体地，第 i 行第 j 列的格子位于第$(\lfloor i&#x2F;3 \rfloor, \lfloor j&#x2F;3 \rfloor)$个九宫格中，其中$\lfloor u \rfloor$表示对 u 向下取整。</p></blockquote><ol><li>回溯法</li></ol><p><strong>思路</strong>：最容易想到的方法是用一个数组记录每个数字是否出现。由于我们可以填写的数字范围为[1,9]，而数组的下标从 0 开始，因此在存储时，我们使用一个长度为 9 的布尔类型的数组，其中 i 个元素的值为 $\text{True}$，当且仅当数字i+1 出现过。例如我们用 $\textit{line}[2][3] &#x3D; \text{True}$ 表示数字 4 在第 2 行已经出现过，那么当我们在遍历到第 2 行的空白格时，就不能填入数字 4。</p><p><strong>算法</strong>：</p><p>首先对整个数独数组进行遍历，当我们遍历到第i行第j列时：</p><ul><li>若该位置是一个空白格，那么我们将其加入一个用来存储空白格位置的列表中，方便后续的递归操作；</li><li>若该位置是一个数字x，那么我们需要将<code>line[i][x-1],column[j][x-1]</code>以及<code>block[i/3][j/3][x-1]</code>都置为True。</li></ul><p>当我们结束了遍历过程之后，就可以开始递归枚举。当递归到第 $i$ 行第 $j$ 列的位置时，我们枚举填入的数字 $x$。根据题目的要求，数字 $x$ 不能和当前行、列、九宫格中已经填入的数字相同，因此 $line[i][x-1]$，$\textit{column}[j][x-1]$以及 $\textit{block}[\lfloor i&#x2F;3 \rfloor][\lfloor j&#x2F;3 \rfloor][x-1]$ 必须均为 $\text{False}$。</p><p>当我们填入了数字 $x$ 之后，我们要将上述的三个值都置为 $\text{True}$，并且继续对下一个空白格位置进行递归。在回溯到当前递归层时，我们还要将上述的三个值重新置为 $\text{False}$。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:    bool line[9][9];    bool column[9][9];    bool block[3][3][9];    bool valid;    vector&lt;pair&lt;int, int&gt;&gt; spaces;public:    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;        if (pos &#x3D;&#x3D; spaces.size()) &#123;            valid &#x3D; true;            return;        &#125;        auto [i, j] &#x3D; spaces[pos]; &#x2F;&#x2F;获取空位位置        for (int digit &#x3D; 0; digit &lt; 9 &amp;&amp; !valid; ++digit) &#123;            if (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i &#x2F; 3][j &#x2F; 3][digit]) &#123;                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;填符合条件的数字                board[i][j] &#x3D; digit + &#39;0&#39; + 1;                dfs(board, pos + 1); &#x2F;&#x2F;递归                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; false; &#x2F;&#x2F;回溯            &#125;        &#125;    &#125;    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        memset(line, false, sizeof(line));        memset(column, false, sizeof(column));        memset(block, false, sizeof(block));        valid &#x3D; false;        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;                    spaces.emplace_back(i, j); &#x2F;&#x2F;initialize                &#125;                else &#123;                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;                    line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;initialize                &#125;            &#125;        &#125;        dfs(board, 0); &#x2F;&#x2F;从头开始求解，最后得到填满数字的board    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/">https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:198.打家劫舍</title>
      <link href="/2023/02/03/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
      <url>/2023/02/03/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>动态规划分析如下：</p><ol><li>确定dp数组(dp table)以及它的下标的含义：</li></ol><p>dp[i]:考虑下标i以内的房屋，最多可以偷窃的金额为dp[i];</p><ol start="2"><li>确定递推公式</li></ol><p>决定是否偷第i个房间:</p><ul><li>如果偷第i个房间，dp[i] &#x3D; dp[i - 2] + nums[i];</li></ul><p>也就是不偷第i-1，而是找到i-2以内最多的房屋，然后再加上第i间房偷到的钱。</p><ul><li>如果不偷第i个房间，那么dp[i] &#x3D; dp[i - 1];也就是要考虑i-1房（<strong>注意这里是考虑而不是真的要偷i-1房</strong>）</li></ul><p>完成分析后取dp[i]的最大值，也就是dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>因为dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);所以基础就是dp[0]和dp[1];</p><p>因此dp[0] &#x3D; nums[0],dp[1] &#x3D; max(nums[0], nums[1]);</p><ol start="4"><li>确定遍历顺序</li></ol><p>dp[i]是根据dp[i-2]和dp[i-1]推导出来的，那么一定是从前到后遍历。</p><ol start="5"><li>举例推导dp数组</li></ol><p>C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        if(nums.empty()) &#123;            return 0;        &#125;        int size &#x3D; nums.size();        if(size &#x3D;&#x3D; 1) &#123;            return nums[0];        &#125;        vector&lt;int&gt; dp &#x3D; vector&lt;int&gt;(size, 0); &#x2F;&#x2F;3. initialize        dp[0] &#x3D; nums[0];        dp[1] &#x3D; max(nums[0], nums[1]);        &#x2F;&#x2F;4. 遍历        for(int i &#x3D; 2; i &lt; size; i++) &#123;            dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);        &#125;        return dp[size - 1];    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:53.最大子数组和</title>
      <link href="/2023/02/02/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2023/02/02/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1]输出：1</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [5,4,-1,7,8]输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>可以很容易想到$f(i) &#x3D; max{f(i-1) + nums[i], nums[i]}$.C++实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int pre &#x3D; 0, maxAns &#x3D; nums[0];        for (const auto &amp;x: nums) &#123;            pre &#x3D; max(pre + x, x);            maxAns &#x3D; max(maxAns, pre);        &#125;        return maxAns;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:70.爬楼梯</title>
      <link href="/2023/02/01/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2023/02/01/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归</li></ol><p>很明显，该问题可以用$f(x) &#x3D; f(x - 1) + f(x - 2)$并且很容易得知$f(0) &#x3D; 1;f(1) &#x3D; 1;f(2) &#x3D; 2$,但是直接写递归(<code>return climbStairs(n - 1) + climbStairs(n - 2)</code>)会导致时间超限，在这里使用「滚动数组思想」把空间复杂度优化成 $O(1)$。</p><p><img src="http://cdn.leafii.top/img/70_fig1.gif" alt="fig1" loading="lazy"></p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int climbStairs(int n) &#123;        int p &#x3D; 0, q &#x3D; 0, r &#x3D; 1;        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;            p &#x3D; q;             q &#x3D; r;             r &#x3D; p + q;        &#125;        return r;    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/">https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning</title>
      <link href="/2023/02/01/Flexible%20Job-Shop%20Scheduling%20via%20Graph%20Neural%20Network%20and%20Deep%20Reinforcement%20Learning/"/>
      <url>/2023/02/01/Flexible%20Job-Shop%20Scheduling%20via%20Graph%20Neural%20Network%20and%20Deep%20Reinforcement%20Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度"><a href="#Flexible-Job-Shop-Scheduling-via-Graph-Neural-Network-and-Deep-Reinforcement-Learning-通过图神经网络和深度强化学习进行灵活的作业车间调度" class="headerlink" title="Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度"></a>Flexible Job-Shop Scheduling via Graph Neural Network and Deep Reinforcement Learning 通过图神经网络和深度强化学习进行灵活的作业车间调度</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>本文考虑了众所周知的灵活作业车间调度问题，并通过提出一种新颖的 DRL 方法来端到端地学习高质量的 PDR 来解决这些问题。操作选择和机器分配被组合为一个复合决策。此外，基于一种新颖的调度状态异构图表示，提出了一种基于异构图神经网络的体系结构来捕获操作和机器之间的复杂关系。</p><span id="more"></span><ul><li><strong>背景</strong></li></ul><p>本文聚焦柔性车间调度问题(FJSP)，FJSP 允许在任何机器上处理一组可选机器的操作，因此更适合处理新制造范例（例如云制造）中任务-资源关系的灵活性和多样性。</p><p>JSP本来就是NP-hard问题，FJSP问题一般使用启发式方法，为效率牺牲最优性。优先调度规则 (PDR)是一种比较知名并且实践性强的启发式方法，它根据一些优先级规则 [例如，先进先出 (FIFO)] 将作业迭代地分配给机器。与元启发式相比，PDR 直观、易于实现且计算速度非常快，使其更适合处理云制造中的问题，这些问题通常是大规模的，甚至是动态的。</p><ul><li><strong>提出问题</strong></li></ul><p>PDR调度结果远非最优。原因如下：</p><ol><li>施工过程基于优先措施是贪婪的，这可能是短视的。</li><li>决策主要基于每个步骤中符合条件的工作和机器的信息，而全局信息在很大程度上被忽略了。</li><li>目前的PDR主要是根据人类经验设计的，通常不能保证最优性，缺乏适应特定问题和情况的能力</li></ol><p>因此，在这个方向上，最近的一些工作尝试以端到端的方式使用 DRL 自动生成用于调度问题的 PDR，但他们都只关注于非柔性的JSP问题，因为要通过该方式改良FJSP问题的调度有两个重大挑战：</p><ol><li>FJSP 中的决策更加复杂，不仅有操作选择，还有机器分配</li><li>由于操作和机器之间复杂的一对多关系，调度状态可能更难使用神经网络进行编码。</li></ol><p>因此，需要研究的问题就是：</p><ol><li>如何制定调度流程以纳入机器分配</li><li>如何设计表示方案和神经架构以从原始调度状态中提取有用信息。</li></ol><ul><li><strong>解决思路</strong></li></ul><ol><li>本文提出了一种基于 PDR 的 FJSP 调度的 MDP 公式，其中一个动作是选择一个符合条件的操作-机器（O-M）对，以便可以同时做出操作选择和机器分配决策。</li><li>通过用机器节点扩展 FJSP 的析取图，本文提出了一种新颖的异构图结构来表示 MDP 状态，从而可以捕获操作和机器之间的复杂关系。此外，提出了一种两阶段图神经网络（GNN）来获得异构图中节点的特征嵌入，在此基础上使用近端策略优化（PPO）设计和训练策略网络。</li><li>与现有的基于DRL的调度方法中使用的GNN不同，本文中提出的 GNN 适用于专用于 FJSP 的异构图，它不仅捕获操作的状态，还捕获机器和 O-M 关系的状态</li></ol><ul><li><strong>实验结果</strong></li></ul><p>在合成实例和公共基准上进行了广泛的实验。结果表明，在保持高计算效率的同时，所提出的方法可以优于传统的手工 PDR，并有效地泛化到训练中未见过的更大规模的问题和公共基准。</p><p>除了方法上的新颖性外，所提出的方法还具有良好的实用价值。它的神经结构与大小无关；因此，经过训练的策略可以应用于解决不同大小的实例，而不仅仅是训练大小。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>在每次迭代过程中，调度状态首先转化为异构图结构。然后，将具有两阶段嵌入过程的 HGNN 应用于异构图，以提取操作和机器的特征嵌入，决策网络使用这些嵌入来生成动作概率分布，从中采样调度操作。</p><h4 id="MDP-Formulation"><a href="#MDP-Formulation" class="headerlink" title="MDP Formulation"></a>MDP Formulation</h4><p>调度过程：在每个决策步骤t(时间为0或操作完成时)，agent观察当前系统状态$s_t$并做出决策$a_t$,该决策分配一个未调度的操作给空闲的机器，并从当前时间开始，记为$T(t)$.然后，环境过渡到下一个决策步骤$t+1$。该过程迭代直到所有操作都被调度。</p><ul><li><p>状态（State）：在第t步的所有操作和机器的状态构成了状态$s_t$</p></li><li><p>动作（Action）：本文中的动作将操作选择和机器分配结合为一个复合决策。具体来说，一个动作$a_t \in A_t$被定义为在第t步的一个可行的O-M对$(O_{ij}, M_K)$，其中的$O_{ij}$是可行的operation，$M_k$是空闲的机器。</p></li><li><p>状态转移(Transition)：基于$s_t$和$a_t$，环境确定性的过渡到新状态$s_{t+1}$，这是操作完成的时间。在本文中，两种不同的状态由异构图的拓扑和特征来区分。</p></li><li><p>奖励(Reward)：奖励定义为部分调度在 $s_t$ 和 $s_{t+1}$ 的完工时间之差，如$r(s_t, a_t, s_{t+1}) &#x3D; C_{max}(s_t) - C_{max}(s_{t+1}))$.若折扣因子$\gamma &#x3D; 1$时，一次求解过程中的累计奖励可以被记为$G &#x3D; \sum_{t&#x3D;0}^{|O|}r(s-t, a_t,s_{t+1}) &#x3D; C_{max}(s_0) - C_{max}$.对于一个特定的问题实例，$C_{max}(s0)$ 是一个常数，这意味着最小化 $C_{max}$ 和最大化 $G$是等价的。</p></li><li><p>策略(Policy):策略 $π(a_t|s_t)$ 为每个状态 $s_t$ 定义了动作集 $A_t$ 上的概率分布。接下来，本文将设计一个 DRL 算法，将 π 参数化为神经网络，并朝着最大化预期累积奖励的方向对其进行优化。</p></li></ul><h4 id="Heterogeneous-Graph"><a href="#Heterogeneous-Graph" class="headerlink" title="Heterogeneous Graph"></a>Heterogeneous Graph</h4><p>用析取图表示FJSP调度更复杂的原因：</p><ol><li>由于多台机器处理operation，析取弧集合D会明显变得更大。所以这种密集的图很难被有效处理。</li><li>一个操作在不同兼容机器上的处理时间是不同的，很难表示。</li></ol><p>为了解决上述问题，本文通过修改析取图结构，定义了一个新颖的异构图结构$H &#x3D; (O,M,C,E)$。如图所示，操作结点集合O和合取弧集C，增加了一组机器节点M，每个节点对应一台机器$M_k$。原本的析取弧集D由O-M弧集E替换。每个元素$E_{ijk} \in E$是一个将操作结点$O_{ij}$和兼容机器节点$M_k$连接起来的无向的弧。</p><p>该异构图结构拥有以下优点：</p><ol><li>图密度显着降低。</li><li>H 中的机器节点提供了一种方便的方式来注入机器信息并提取有用的特征以区分状态中的不同机器。</li><li>处理时间 $p_{ijk}$ 可以通过简单地附加为 $O-M$ 弧 $E_{ijk}$ 的特征来轻松表示。</li></ol><p>定义异构图之后，每一个状态$s_t$可以由异构图$H_t &#x3D; (O, M, C, E_t)$表示，其中$E_t$在求解过程中动态变化。具体来说：在第t步采取一个动作$(O_{ij},M_k)$后，只保留$E_{ijk}$，去掉$O_{ij}$的其他$O-M$弧，得到$H_{t+1}$。因此，节点之间的相邻关系也会动态变化。</p><p>在每个步骤t，定义$N_t(O_{ij})$ 是操作 $O_{ij}$ 的相邻机器，$N_t(M_k)$ 是机器 $M_k$ 的相邻操作。</p><h4 id="Heterogeneous-Graph-Neural-Network"><a href="#Heterogeneous-Graph-Neural-Network" class="headerlink" title="Heterogeneous Graph Neural Network"></a>Heterogeneous Graph Neural Network</h4><p>作为组合问题中的典型，FJSP 实例具有不同的大小。要使用 DRL 学习实用的调度策略，神经架构必须能够在不同大小的状态图上运行。之前的一些工作表明GNN可以用于实现大小不可知的特性，然而它们都是对齐次图（Homogenous graph）进行处理的，在这里不可用。目前提出的HGNN都没有考虑到FJSP的异构图$H_t$，原因如下：</p><ol><li>首先，$H_t$ 中的不同节点类型具有很强的连接模式。任何机器的邻居只能是通过无向弧连接的操作，而操作可以通过有向或无向弧连接到操作和机器。</li><li>O-M 弧上的特征（即处理时间）对于解决 FJSP 非常重要。</li></ol><p>然而，现有的 HGNN 通常只关注节点特征，不考虑弧特征。</p><p>为了利用异构图结构的特性和优势，本文提出了一种为 FJSP 定制的新型 HGNN 架构，以有效地编码 $H_t$.如图所示：</p><p><img src="http://cdn.leafii.top/img/image-20230202204228094.png" alt="image-20230202204228094" loading="lazy"></p><p>所提出的方法具有两阶段嵌入过程的特点，以便将图的拓扑和数值信息（原始特征）考虑在内，并将 $H_t$ 中的节点映射到$ d$ 维嵌入。</p><p>在第一阶段，机器嵌入$ ν′<em>k \in \R^d$ 通过聚合相关信息更新，而操作嵌入 $μ′</em>{ij} \in \R^d$ 在第二阶段更新。详情如下.</p><h5 id="Machine-Node-Embedding"><a href="#Machine-Node-Embedding" class="headerlink" title="Machine Node Embedding:"></a>Machine Node Embedding:</h5><p>在 $H_t$ 中，机器 $M_k$ 的邻居是一组操作 $N_t(M_k)$，它可能对 $M_k$ 有不同的含义。例如，预计较早开始的操作可能比较晚开始的操作更重要。这促使我们考虑图形注意力网络（GAT）,它通过应用注意力机制自动学习不同节点的重要性.对于齐次图，给定具有特征 $x_i$ 的节点 $i$，GAT 首先计算 $i$ 和其一阶邻域 $N(i)$（包括 $i$ 本身）中的每个$j$ 之间的注意系数 $e_{ij}$（标量）为$e_{ij}&#x3D;LeakyReLU(a^T[W_{x_i}||W_{x_j}])$.</p><p>换句话说，$x_i$ 和 $x_j$ 首先由共享线性变换 $W$ 处理，然后连接 $(||)$ 并馈入具有权重 a 和 LeakyReLU 激活的单层前馈神经网络。然后，使用 softmax 函数对邻域内的系数进行归一化:$\alpha_{ij}&#x3D;\frac{exp(e_{ij})}{\sum_{q\in N(i)exp(e_{iq})}} \forall j\in N(i)$</p><p>最终，GAT 在 $N (i)$ 上聚合（线性变换）特征并应用非线性 $\sigma$ 来获得 $i$ 的嵌入:$x’<em>i &#x3D; \sigma(\sum</em>{j \in N(i)}\alpha_{ij}W_{x_j})$.</p><p><strong>但是</strong>原来的GAT只是针对齐次图的，没有考虑弧特征。在这里，为了满足本文的需要（即计算相邻操作对机器的重要性）.</p><ol><li>可以观察到，对于每个机器 $M_k$，只有一个$O-M$ 弧将其与相邻操作连接起来。因此，每个 $O_{ij} \in N_t(M_k)$ 的原始特征向量通过将其原始原始特征与相应 O-M 弧的原始特征连接起来扩展为 $\mu_{ijk} &#x3D;[\mu_{ij}||\lambda_{ijk}] \in \R^7$.</li><li>在这里，两个线性变换 $W^M \in \R^{d×3}$ 和 $W^O \in \R^{d × 7}$ 分别用于机器和操作节点，而不是使用共享的。</li><li>对于机器 $M_k$，注意系数 $e_{ijk}$，即每个相邻操作的重要性 $O_{ij} \in N_t(M_k)$，可以计算为:$e_{ijk} &#x3D; LeakyReLU(a^T[W^Mv_k||W^O\mu_{ijk}])$,其中$a\in \R^{2d}$。</li></ol><p>通过这种方式，来自异构节点和 O-M 弧的信息可以有效地纳入注意力计算。</p><p>上面的式子中有一件事情未被考虑：原始GAT中涉及的机器$M_k$对自身的注意力系数。这里，$e_{kk}$ 是使用机器特定权重 $W^M$ 计算的，如下所示：$e_{kk} &#x3D; LeakyReLU(a^T[W^M_{V_k}||W^M_{v_k}])$.</p><p>所有 $e_{ijk} \forall O_{ij} \in N_t(M_k)$ 与 $e_kk$ 一起使用 softmax 函数进行归一化，以获得归一化的注意力系数 $α_{ijk}$ 和 $\alpha_{kk}$。</p><p>最终，机器嵌入$v’<em>k$由融合相邻操作和自身的特征计算得到。计算$v’<em>k$的聚合函数为：$v’<em>k &#x3D; \sigma(\alpha</em>{kk}W^M</em>{v_k} + \sum</em>{O_{ij}\in N_t(M_k)}\alpha_{ijk}W^O\mu_{ijk})$</p><h5 id="Operation-Node-Embedding"><a href="#Operation-Node-Embedding" class="headerlink" title="Operation Node Embedding:"></a>Operation Node Embedding:</h5><p>本文直接使用多个MLP对每个源的信息（包括$O_{ij}$本身的特征）进行处理，将结果拼接起来，投影回d维空间作为$O_{ij}$的embedding。</p><p>具体来说，有5个MLP被定义，每一个都有d维的输出，两个 $d_h$ 维隐藏层和 ELU 激活.$O_{ij}$的embedding计算如下:</p><p>$\mu’<em>{ij}&#x3D;MLP</em>{\theta_0}(ELU[MLP_{\theta_1}(\mu_{i,j-1})||MLP_{\theta_2}(\mu_{i, j+1})||MLP_{\theta_3}(\bar{v}’<em>{ij})||MLP</em>{\theta_4(\mu_{ij})}])$</p><p>请注意，无需计算两个虚拟操作 Start 和 End 的嵌入。</p><h5 id="Stacking-and-Pooling"><a href="#Stacking-and-Pooling" class="headerlink" title="Stacking and Pooling:"></a>Stacking and Pooling:</h5><p>上面的嵌入过程可以看作是一个HGNN层，它转换每个操作的原始特征$μ_{ij}$和$ν_k$，为了增强特征提取能力，这里将结构相同但可训练参数独立的 L个HGNN层堆叠起来，以获得最终的嵌入 $μ’^{(L)}_{ij}$ 和 $ν’^{(L)} _k$。</p><p>在HGNN的L层之后，分别对得到的操作嵌入集和机器嵌入集应用均值池化。然后，将生成的两个 d 维向量连接为异构图状态 $H_t$ 的嵌入 $ht \in \R^{2d}$，如下所示：$h_t&#x3D;[\frac{1}{O}\sum_{O_{i,j\in O}\mu_{ij}^{‘(L)}}||\frac{1}{|M|}\sum_{M_{k\in M}}v’^{(L)}_k]$.</p><p>通过上述过程，一个可变大小的异构图可以转化为一个固定维度的嵌入。令 θ 为所有 HGNN 参数的集合。</p><h4 id="Decision-Making"><a href="#Decision-Making" class="headerlink" title="Decision Making"></a>Decision Making</h4><p>由于上述异构图结构和 HGNN，策略 π(at|st) 使用提取的嵌入可以简单方便地表示.</p><p>对于在 $a_t &#x3D;(O_{ij},M_k) \in  A_t$ 处的每个可行动作，在步骤 t，相应的操作、机器和状态嵌入被连接起来并送入 MLP 以获得其在状态 $s_t$ 被选择的优先级索引，如下所示：$P(a_t, s_t)&#x3D;MLP_\omega[\mu’^{(L)}<em>{ij}||v’^{(L)}</em>{k}||h_t]$</p><p>选择每个 $a_t$ 的概率是通过对所有 $P (a_t,s_t)$ 应用 softmax 来计算的:</p><p>$\pi_\omega(a_t|s_t)&#x3D;\frac{exp(P(a_t,s_t))}{\sum_{a’_t\in A_t}exp(P(a’_t,s_t))} \forall a_t \in A_t$.</p><p>在训练过程中，根据策略 $\pi_\omega$ 对动作进行采样，以进行探索。</p><p>请注意，对于神经策略，采样的额外开销通常很小，因为图形处理单元 (GPU) 能够并行采样解决方案。</p><p><img src="http://cdn.leafii.top/img/image-20230203000256621.png" alt="image-20230203000256621" loading="lazy"></p><h4 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h4><p>本文使用 PPO进行训练，它采用了 actor-critic 结构。 Actor 是策略网络 $\pi_\omega$，critic $v_\phi$ 是另一个预测状态 $s_t$ 的值 $v(s_t)$ 的网络。</p><p><img src="http://cdn.leafii.top/img/image-20230203000557428.png" alt="image-20230203000557428" loading="lazy"></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>本节显示<strong>合成</strong>和<strong>公共 FJSP 实例</strong>的实验结果，以验证所提出的方法。</p><h4 id="Experimental-Settings"><a href="#Experimental-Settings" class="headerlink" title="Experimental Settings"></a>Experimental Settings</h4><h5 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h5><p>合成数据来自[1].</p><p>两个著名的 FJSP 基准测试数据:[1] 中的十个 mk 实例 (mk01–mk10) 和 [2] 中的三组 la 实例（rdata、edata 和 vdata，每组有 40 个实例）。</p><p>在四个较小的尺寸上进行训练，并使用最大的两个（30×10 和 40×10）来测试泛化能力</p><p>因此，对这些基准测试可以进一步验证所提出的方法在推广到分布外实例时的效果。有关这些实例的更多详细信息，请参见 [6]。</p><h5 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h5><p>与四个在实践中运行良好的著名 PDR 相比，包括 FIFO、剩余操作最多 (MOR)、最短处理时间 (SPT) 和剩余工作最多 (MWKR) 。</p><p>本文还与 Google OR-Tools 进行了比较。</p><p>对于公共基准，本文还与 DRL 方法 [3] 和 [4] 和 [5] 中的两种最新遗传算法 (GA) 的结果以及 [6] 中收集的最著名解决方案进行了比较。</p><p>对于具有最大完工时间 $C_{max}$ 的每个解决方案，其与最佳解决方案（不一定是最优）的最大完工时间 $C^{BS}_{max}$ 的相对差距计算如下：</p><p>$\epsilon &#x3D; (C_{max}&#x2F;C_^{BS} - 1) \times 100% $</p><h4 id="Performance-on-Synthetic-Instances"><a href="#Performance-on-Synthetic-Instances" class="headerlink" title="Performance on Synthetic Instances"></a>Performance on Synthetic Instances</h4><p>相当稳定并收敛于所有四种训练规模:</p><p><img src="http://cdn.leafii.top/img/image-20230203002931755.png" alt="image-20230203002931755" loading="lazy"></p><ol><li>训练大小实例的评估</li><li>大型实例的泛化性能</li><li>运行时间分析</li></ol><p><img src="http://cdn.leafii.top/img/image-20230203003842530.png" loading="lazy"></p><h4 id="Performance-on-Public-Benchmarks"><a href="#Performance-on-Public-Benchmarks" class="headerlink" title="Performance on Public Benchmarks"></a>Performance on Public Benchmarks</h4><p>进一步评估经过训练的政策在传统研究中经常使用的两个公共基准上的泛化性能:</p><p><img src="http://cdn.leafii.top/img/image-20230203003828665.png" alt="image-20230203003828665" loading="lazy"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>本文提出了一种新颖的端到端 DRL 方法来为 FJSP 学习高质量的 PDR，该方法在实践中得到广泛应用，但很少被现有的基于 DRL 的方法研究。</p><p>底层 MDP 是使用集成方法制定的，该方法将操作选择和机器分配结合为一个决策。然后，提出了一种异构图结构来表示调度状态，该结构由一种新颖的 HGNN 架构处理，以便将图中的数值和拓扑信息转换为特征嵌入。在 HGNN 的基础上，设计了一个 actor-critic 架构，并使用 PPO 进行训练。</p><p>结果表明，所提出的方法以合理的效率优于基线 PDR，并且可以很好地泛化到更大尺寸和公共基准的看不见的实例。</p><p>对于<strong>未来的工作</strong>，该方法将被扩展以处理实际生产中更具挑战性的因素，例如批次、到期日和不确定性。此外，将利用 FJSP 的多最优属性 [46]（即，一个实例可以有多个最优解）来提高训练性能。还将研究与 GA 等高级搜索机制相结合的可能性。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] P. Brandimarte, “Routing and scheduling in a flexible job shop by tabu search,” Ann. Oper. Res., vol. 41, no. 3, pp. 157–183, 1993.</p><p>[2]  J. Hurink, B. Jurisch, and M. Thole, “Tabu search for the job-shop scheduling problem with multi-purpose machines,” OR Spektrum, vol. 15, no. 4, pp. 205–215, 1994.</p><p>[3] B. Han and J. Yang, “A deep reinforcement learning based solution for flexible job shop scheduling problem,” Int. J. Simul. Model., vol. 20, no. 2, pp. 375–386, 2021.</p><p>[4] R. Chen, B. Yang, S. Li, and S. Wang, “A self-learning genetic algorithm based on reinforcement learning for flexible job-shop scheduling problem,” Comput. Ind. Eng., vol. 149, 2020, Art. no. 106778. </p><p>[5] D. Rooyani and F. M. Defersha, “An efficient two-stage genetic algorithm for flexible job-shop scheduling,” IFAC-PapersOnLine, vol. 52, no. 13, pp. 2519–2524, 2019.</p><p>[6] D. Behnke and M. J. Geiger, “Test instances for the flexible job shop scheduling problem with work centers,” Helmut Schmidt Univ., Hamburg, Germany, Tech. Rep. RR-12-01-01, 2012.</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:344.反转字符串</title>
      <link href="/2023/02/01/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/02/01/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>双指针从最左边到最右边遍历交换元素，直至左指针索引值大于右指针索引值。C++实现如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int n &#x3D; s.size();&#x2F;&#x2F;获取数组长度        int left &#x3D; 0, right &#x3D; n - 1;        char temp &#x3D; 0;        while(left &lt; right) &#123;            temp &#x3D; s[left];            s[left] &#x3D; s[right];            s[right] &#x3D; temp;&#x2F;&#x2F;交换操作            left++;            right--; &#x2F;&#x2F;指针移动        &#125;        &#x2F;&#x2F;最后的s即为结果，函数返回类型为void所以无需返回值    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:42.接雨水</title>
      <link href="/2023/01/30/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2023/01/30/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/rainwatertrap.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [4,2,0,3,2,5]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>动态规划</li></ol><p>创建两个长度为n的数组leftMax和rightMax.leftMax[i]表示下标i以及其左边的位置中，height的最大高度，rightMax[i]表示下标i及其右边的位置中，height的最大高度。其中leftMax[0] &#x3D; height[0], rightMax[n - 1] &#x3D; height[n - 1].</p><ul><li>当1 &lt;&#x3D; i &lt;&#x3D; n - 1时， leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);</li><li>当0 &lt;&#x3D; i &lt;&#x3D; n - 2时，rightMax[i] &#x3D; max(rightMax[i + 1], height[i]).</li></ul><p>因此可以正向遍历数组height得到leftMax的每个元素值，反向遍历数组height得到rightMax的每个元素值。</p><p>在得到数组leftMax和rightMax的每个元素值后，对于0&lt;&#x3D;i&lt;n，下标i处能接的雨水量等于min(leftMax[i], rightMax[i]) - height[i].对每个下标i进行遍历，将结果进行累加。</p><p><img src="http://cdn.leafii.top/img/1.png" alt="fig1" loading="lazy"></p><p>C++代码实现如下： </p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int n &#x3D; height.size();        if (n &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        vector&lt;int&gt; leftMax(n);        leftMax[0] &#x3D; height[0];        for (int i &#x3D; 1; i &lt; n; ++i) &#123;            leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);        &#125;        vector&lt;int&gt; rightMax(n);        rightMax[n - 1] &#x3D; height[n - 1];        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; --i) &#123;            rightMax[i] &#x3D; max(rightMax[i + 1], height[i]);        &#125;        int ans &#x3D; 0;        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            ans +&#x3D; min(leftMax[i], rightMax[i]) - height[i];        &#125;        return ans;    &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/">https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:46.全排列</title>
      <link href="/2023/01/29/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2023/01/29/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1]输出：[[0,1],[1,0]]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1]输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>回溯</li></ol><p>用回溯法模拟全排列的过程。</p><p>定义一个递归函数<code>backtrack(first, output)</code>表示从左往右填到第first个位置，当前排列为output，所以有以下两种情况：</p><ul><li>若<code>first = n</code>，则说明n个位置已经填完了，找到了一个可行的解，此时需要把output放入答案数组中，递归结束。</li><li>如果<code>first &lt; n</code>，我们需要考虑在第first个位置上我们需要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组vis来标记已经填过的数，如果有数未被标记，就尝试填入，并将其标记，然后继续调用<code>backtrack(first + 1, output)</code>，回溯时要撤销之前的标记以及已经填入的数字，但是标记数组增加了算法的空间复杂度。</li></ul><p>我们将题目给定的n个数的数组nums划分为左右两个部分，左边为已经填过的数，右边是待填的数，在回溯时只需要动态维护这个数组即可。</p><p>具体的来说，如果我们已经填到第first个位置，那么nums数组中<code>[0, first - 1]</code>是已经填过的数的集合，<code>[first, n - 1]</code>是待填数的集合。我们肯定是用<code>[first, n - 1]</code>的数去填第first个数，假设待填的数的下标为i，那么填完以后我们将第i个数和第first个数交换，即能使得在第first+1个数的时候nums数组的<code>[0, first]</code>部分为已填过的数，<code>[first + 1, n - 1]</code>为待填的数，回溯的时候交换回来就可以完成撤销操作。</p><p>举个简单的例子，假设我们有 <code>[2,5,8,9,10]</code>这 5 个数要填入，已经填到第 3 个位置，已经填了 <code>[8, 9]</code> 两个数，那么这个数组目前为 <code>[8, 9|2, 5, 10]</code> 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10 这个数，为了维护数组，我们将 2 和 10 交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填 <code>[8, 9, 10|2, 5]</code> 。C++实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len) &#123;        &#x2F;&#x2F;所有数都填完了        if (first &#x3D;&#x3D; len) &#123;            res.emplace_back(output);             &#x2F;&#x2F;和push_back()类似，emplace_back() 用来给容器中添加元素。            &#x2F;&#x2F;在容器尾部添加一个元素，调用构造函数原地构造，不需要触发拷贝构造和移动构造。因此比push_back()更加高效。            return;        &#125;        for (int i &#x3D; first; i &lt; len; ++i) &#123;            &#x2F;&#x2F;动态维护数组            swap(output[i], output[first]); &#x2F;&#x2F;swap用于交换两个int型变量的值            &#x2F;&#x2F;继续递归填下一个数            backtrack(res, output, first + 1, len);            &#x2F;&#x2F;撤销操作            swap(output[i], output[first]);        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt; &gt; res;        backtrack(res, nums, 0, (int)nums.size());        return res;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:15/16.三数之和/最接近的三数之和</title>
      <link href="/2023/01/28/leetcode-15-16-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/01/28/leetcode-15-16-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,0], target &#x3D; 1输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 1000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><blockquote><p>这两道题目求解思路很相似，只是第一个题目需要返回所有满足求和条件的组合，第二个题目返回最接近target的sum值。</p></blockquote><p><strong>方法一：排序 + 双指针</strong></p><p>题目要求找到与目标值 $target$ 最接近的三元组，这里的「最接近」即为差值的绝对值最小。我们可以考虑直接使用三重循环枚举三元组，找出与目标值最接近的作为答案，时间复杂度为 $O(N^3)$。然而本题的 $N$ 最大为 $1000$，会超出时间限制。</p><p>那么如何进行优化呢？我们首先考虑枚举第一个元素 $a$，对于剩下的两个元素 $b$ 和 $c$，我们希望它们的和最接近 $target-a$。对于 $b$ 和 $c$，如果它们在原数组中枚举的范围（既包括下标的范围，也包括元素值的范围）没有任何规律可言，那么我们还是只能使用两重循环来枚举所有的可能情况。因此，我们可以考虑对整个数组进行升序排序，这样一来：</p><p>假设数组的长度为 $N$，我们先枚举 $a$，它在数组中的位置为 $i$；</p><p>为了防止重复枚举，我们在位置$[i+1,n)$的范围内枚举 $b$ 和 $c$。</p><p>当我们知道了 $b$ 和 $c$ 可以枚举的下标范围，并且知道这一范围对应的数组元素是有序（升序）的，那么我们是否可以对枚举的过程进行优化呢？</p><p>答案是可以的。借助双指针，我们就可以对枚举的过程进行优化。我们用 $p_b$和 $p_c$分别表示指向 $b$ 和 $c$ 的指针，初始时，$p_b$指向位置$i+1$，即左边界；$p_c$指向位置 $n-1$，即右边界。在每一步枚举的过程中，我们用 $a+b+c$ 来更新答案，并且：</p><p>如果 $a+b+c \ge target$，那么就将 $p_c$向左移动一个位置；</p><p>如果 $a+b+c \le target$，那么就将 $p_b$向右移动一个位置。</p><p>这是为什么呢？我们对 $a+b+c \ge target$ 的情况进行一个详细的分析：</p><p>如果 $a+b+c \ge target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_c$不变而 $p_b$向右移动，那么 $a+b+c$ 的值就会不断地增加，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_c$的情况下，此时的 $p_b$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_c$了，就可以将 $p_c$向左移动一个位置。</p><p>同样地，在 $a+b+c \le target$ 时：</p><p>如果 $a+b+c \le target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_b$不变而 $p_c$向左移动，那么 $a+b+c$ 的值就会不断地减小，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_b$的情况下，此时的 $p_c$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_b$了，就可以将 $p_b$向右移动一个位置。</p><p>实际上，$p_b$和 $p_c$就表示了我们当前可以选择的数的范围，而每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 $target$ 的值的关系，选择「抛弃」左边界的元素还是右边界的元素，从而减少了枚举的范围。这种思路与 11. 盛最多水的容器 中的双指针解法也是类似的。</p><p><strong>小优化</strong></p><p>本题也有一些可以减少运行时间（但不会减少时间复杂度）的小优化。当我们枚举到恰好等于 $target$ 的 $a+b+c$ 时，可以直接返回 $target$ 作为答案，因为不会有再比这个更接近的值了。</p><p>另一个优化与 15. 三数之和的官方题解 中提到的类似。当我们枚举 $a,b,c$中任意元素并移动指针时，可以直接将其移动到下一个与这次枚举到的不相同的元素，减少枚举的次数。</p><h3 id="15题C-实现："><a href="#15题C-实现：" class="headerlink" title="15题C++实现："></a>15题C++实现：</h3><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        &#x2F;&#x2F;对数组进行排序        sort(nums.begin(), nums.end());        int n &#x3D; nums.size();        &#x2F;&#x2F;枚举a        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            &#x2F;&#x2F;保证和上一次枚举的元素不相等            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                continue;            &#125;            int target &#x3D; -nums[i];            &#x2F;&#x2F;使用双指针枚举b和c            int j &#x3D; i + 1, k &#x3D; n - 1;            while (j &lt; k) &#123;                int sum &#x3D;  nums[j] + nums[k];                &#x2F;&#x2F; 如果和为target则直接返回答案                 if (sum &#x3D;&#x3D; target) &#123;                    result.push_back(&#123;nums[i], nums[j], nums[k]&#125;);                &#125;                if (sum &gt; target) &#123;                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针                    int k0 &#x3D; k - 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;                        --k0;                    &#125;                    k &#x3D; k0;                &#125; else &#123;                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针                    int j0 &#x3D; j + 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;                        ++j0;                    &#125;                    j &#x3D; j0;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h3 id="16题C-实现："><a href="#16题C-实现：" class="headerlink" title="16题C++实现："></a>16题C++实现：</h3><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;        &#x2F;&#x2F;对数组进行排序        sort(nums.begin(), nums.end());        int n &#x3D; nums.size();        int best &#x3D; 1e7;&#x2F;&#x2F; initial                &#x2F;&#x2F;根据差值的绝对值来更新答案        &#x2F;*            auto toNumber &#x3D; [&amp;](string const&amp; s) -&gt; unsigned &#123;                ...            &#125;            []：定义匿名函数            [&amp;]：以引用形式捕获所有外部变量，也就是外部变量均可用            (string const &amp;s) ：匿名函数的参数            -&gt;：定义匿名函数            unsigned：函数返回值类型            &#123;...&#125;：函数实现体        *&#x2F;                auto update &#x3D; [&amp;](int cur) &#123;            if (abs(cur - target) &lt; abs(best - target)) &#123;                best &#x3D; cur;            &#125;        &#125;;        &#x2F;&#x2F;枚举 a        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            &#x2F;&#x2F;保证和上一次枚举的元素不相等            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                continue;            &#125;            &#x2F;&#x2F;使用双指针枚举b和c            int j &#x3D; i + 1, k &#x3D; n - 1;            while (j &lt; k) &#123;                int sum &#x3D; nums[i] + nums[j] + nums[k];                &#x2F;&#x2F; 如果和为target则直接返回答案                 if (sum &#x3D;&#x3D; target) &#123;                    return target;                &#125;                update(sum);                if (sum &gt; target) &#123;                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针                    int k0 &#x3D; k - 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;                        --k0;                    &#125;                    k &#x3D; k0;                &#125; else &#123;                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针                    int j0 &#x3D; j + 1;                    &#x2F;&#x2F;移动到下一个不相等的元素                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;                        ++j0;                    &#125;                    j &#x3D; j0;                &#125;            &#125;        &#125;        return best;    &#125;&#125;;</code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>力扣官方题解：<a href="https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/">https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:94.二叉树的中序遍历</title>
      <link href="/2023/01/27/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2023/01/27/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/inorder_1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,3,2]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：root &#x3D; [1]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归算法</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123;      &#x2F;&#x2F;原函数没办法对vector数组的内容进行添加        if(!root) &#123;            return;        &#125;      &#x2F;&#x2F;中 左 右        inorder(root-&gt;left, res);        res.push_back(root -&gt; val);        inorder(root-&gt;right, res);    &#125;    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        inorder(root, result);        return result;    &#125;&#125;;</code></pre><ol start="2"><li>迭代</li></ol><p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; stk;        while (root !&#x3D; nullptr || !stk.empty()) &#123;            &#x2F;&#x2F;结点非空时，将root结点push进去， root迭代至左结点            while(root !&#x3D; nullptr) &#123;                stk.push(root);                root &#x3D; root -&gt; left;            &#125;            &#x2F;&#x2F;符合条件的结点都push进去之后，出栈，然后将root结点的值push进res数组中，            root &#x3D; stk.top();            stk.pop();            res.push_back(root -&gt; val);            &#x2F;&#x2F; 将root结点迭代至右结点            root &#x3D; root -&gt; right;         &#125;        return res;    &#125;    &#125;;</code></pre><ol start="3"><li>Morris遍历算法</li></ol><p>思路与算法</p><p>Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 $O(1)$。</p><p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 $x$）：</p><p>如果 $x$ 无左孩子，先将 $x$ 的值加入答案数组，再访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>如果 $x$ 有左孩子，则找到 $x$ 左子树上最右的节点（即左子树中序遍历的最后一个节点，$x$ 在中序遍历中的前驱节点），我们记为 $predecessor $。根据 $predecessor $ 的右孩子是否为空，进行如下操作。<br>如果 $predecessor $ 的右孩子为空，则将其右孩子指向 $x$，然后访问 $x$ 的左孩子，即 $x &#x3D; x.left $。<br>如果 $predecessor $ 的右孩子不为空，则此时其右孩子指向 $x$，说明我们已经遍历完 $x$ 的左子树，我们将 $predecessor $ 的右孩子置空，将 $x$ 的值加入答案数组，然后访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>重复上述操作，直至访问完整棵树。</p><p>其实整个过程我们就多做一步：假设当前遍历到的节点为 xxx，将 xxx 的左子树中最右边的节点的右孩子指向 xxx，这样在左子树遍历完成后我们通过这个指向走回了 xxx，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        TreeNode *predecessor &#x3D; nullptr;        while (root !&#x3D; nullptr) &#123;            if(root -&gt; left !&#x3D; nullptr) &#123;                &#x2F;&#x2F;predecessor就是当前root节点向左走一步，再一直向右走到无法走为止                predecessor &#x3D; root -&gt; left;                while(predecessor -&gt; right !&#x3D; nullptr &amp;&amp; predecessor -&gt; right !&#x3D; root) &#123;                    predecessor &#x3D; predecessor -&gt; right;                &#125;            &#x2F;&#x2F;让predecessor的右指针指向root，继续遍历左子树            if (predecessor -&gt; right &#x3D;&#x3D; nullptr) &#123;                predecessor -&gt; right &#x3D; root;                root &#x3D; root -&gt; left;            &#125;            &#x2F;&#x2F;说明左子树已经访问完了， 需要断开连接            else &#123;                res.push_back(root -&gt; val);                predecessor -&gt; right &#x3D; nullptr;                root &#x3D; root -&gt; right;                &#125;            &#125;            &#x2F;&#x2F;如果没有左孩子，则直接访问右孩子            else &#123;                res.push_back(root -&gt; val);                root &#x3D; root -&gt; right;            &#125;                    &#125;        return res;            &#125;&#125;;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>力扣官方题解：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:27.移除元素</title>
      <link href="/2023/01/26/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2023/01/26/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><span id="more"></span><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre class="language-none"><code class="language-none">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len &#x3D; removeElement(nums, val);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;</code></pre><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li><p>双指针直接遍历</p><p>使用双指针，左指针为要被修改的元素，右指针为遍历主体，判断元素是否为<code>val</code>。最后返回left即可。C++代码实现如下：</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        &#x2F;&#x2F;双指针        int n &#x3D; nums.size();        int left &#x3D; 0;        for(int right &#x3D; 0; right &lt; n; right++) &#123;            if(nums[right] !&#x3D; val) &#123;                nums[left] &#x3D; nums[right];                left++;            &#125;        &#125;        return left;    &#125;&#125;;</code></pre><ol start="2"><li><p>双指针优化</p><p>初始化两个指针时，左指针为0，右指针为数组的最后一个元素，然后从两边向中间遍历.C++代码实现如下：</p></li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int left &#x3D; 0, right &#x3D; nums.size();        while(left &lt; right) &#123;            if(nums[left] &#x3D;&#x3D; val) &#123;                nums[left] &#x3D; nums[right - 1];                right--;            &#125;            else &#123;                left++;            &#125;        &#125;        return left;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:51.N皇后</title>
      <link href="/2023/01/17/leetcode-51-N%E7%9A%87%E5%90%8E/"/>
      <url>/2023/01/17/leetcode-51-N%E7%9A%87%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 1输出：[[&quot;Q&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>首先来看一下皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p><p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p><p><img src="http://cdn.leafii.top/img/20210130182532303.jpg" alt="51.N皇后" loading="lazy"></p><p>从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p><p>按照我总结的如下回溯模板，我们来依次分析：</p><pre class="language-C++" data-language="C++"><code class="language-C++">void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); &#x2F;&#x2F; 递归        回溯，撤销处理结果    &#125;&#125;</code></pre><ul><li>递归函数参数</li></ul><p>我依然是定义全局变量二维数组result来记录最终结果。</p><p>参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。</p><p>代码如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> result<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> chessboard<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></code></pre><ul><li>递归终止条件</li></ul><p>在如下树形结构中： <img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后" loading="lazy"></p><p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。</p><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">if (row &#x3D;&#x3D; n) &#123;    result.push_back(chessboard);    return;&#125;</code></pre><ul><li>单层搜索的逻辑</li></ul><p>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</p><p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">for (int col &#x3D; 0; col &lt; n; col++) &#123;    if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放        chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后        backtracking(n, row + 1, chessboard);        chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后    &#125;&#125;</code></pre><ul><li>验证棋盘是否合法</li></ul><p>按照如下标准去重：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线 （45度和135度角）</li></ol><p>代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;    &#x2F;&#x2F; 检查列    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 45度角是否有皇后    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 135度角是否有皇后    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p><p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p><p>那么按照这个模板不难写出如下C++代码：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;private:vector&lt;vector&lt;string&gt;&gt; result;&#x2F;&#x2F; n 为输入的棋盘大小&#x2F;&#x2F; row 是当前递归到棋盘的第几行了void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;    if (row &#x3D;&#x3D; n) &#123;        result.push_back(chessboard);        return;    &#125;    for (int col &#x3D; 0; col &lt; n; col++) &#123;        if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放            chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后            backtracking(n, row + 1, chessboard);            chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后        &#125;    &#125;&#125;bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;    &#x2F;&#x2F; 检查列    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 45度角是否有皇后    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    &#x2F;&#x2F; 检查 135度角是否有皇后    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;            return false;        &#125;    &#125;    return true;&#125;public:    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        result.clear();        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#39;.&#39;));        backtracking(n, 0, chessboard);        return result;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer64.求1+2+…+n</title>
      <link href="/2023/01/17/%E5%89%91%E6%8C%87Offer64-%E6%B1%821-2-%E2%80%A6-n/"/>
      <url>/2023/01/17/%E5%89%91%E6%8C%87Offer64-%E6%B1%821-2-%E2%80%A6-n/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p> <span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入: n &#x3D; 3输出: 6</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入: n &#x3D; 9输出: 45</code></pre><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 10000</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>错误解法（使用了if）,虽然通过了但是不符合题意。</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        if(n &#x3D;&#x3D; 1)        &#123;            return 1;        &#125;        else        &#123;            return n + sumNums(n - 1);        &#125;    &#125;&#125;;</code></pre><ol start="2"><li>由于不能使用乘除法，<code>for</code>，<code>while</code>等关键字以及条件判断语句，因此我们能用的挚友加减法，赋值，位运算符和逻辑运算符。</li></ol><p>但是如果使用递归方法，那么递归的结束条件很难不用条件判断语句，那么怎么解决？答案是使用逻辑运算符<code>&amp;&amp;</code>或者<code>||</code>，利用它的短路性质，对于<code> A &amp;&amp; B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>False</code> ，那么 <code>A &amp;&amp; B</code> 已经确定为 <code>False</code>，此时不会去执行表达式 <code>B</code>。同理，对于逻辑运算符 <code>||</code>， 对于 <code>A || B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>True</code> ，那么<code> A || B</code> 已经确定为<code> True</code> ，此时不会去执行表达式<code> B</code>。</p><p>因此我们可以将判断是否为递归的出口看作<code>A&amp;B</code>表达式中的<code>A</code>部分，递归的主体函数看作<code>B</code>部分。如果不是递归出口，就返回<code>True</code>，并继续执行表达式<code>B</code>的部分，否则递归结束。结合逻辑运算符<code>&amp;&amp;</code>的递归实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        n &amp;&amp; (n +&#x3D; sumNums(n-1));        return n;    &#125;&#125;;</code></pre><p>用逻辑运算符<code>||</code>的递归实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        n&#x3D;&#x3D;1 || (n +&#x3D; sumNums(n-1));        return n;    &#125;&#125;;</code></pre><ol start="3"><li>使用C++的sizeof函数进行$\frac{1}{2}(n \times (n+1))$的模拟：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int sumNums(int n) &#123;        bool a[n][n+1]; &#x2F;&#x2F;bool一个元素占一bit        return sizeof(a) &gt;&gt; 1; &#x2F;&#x2F;sizeof(a) 计算了n*(n+1)    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:2.两数相加</title>
      <link href="/2023/01/17/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2023/01/17/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/addtwonumber1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]输出：[7,0,8]解释：342 + 465 &#x3D; 807.</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [0], l2 &#x3D; [0]输出：[0]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>将两个链表遍历相加，大致思路如下：</li></ol><blockquote><p>1.相加的过程中可能存在进位的操作，所以需要采用一个变量carry来记录进位的情况，初始化carry &#x3D; 0;</p><p>2.因为链表的数字是倒着放的，所以相加起来很方便，将两个链表从头到尾一起遍历，如果有值的话就将它们的值相加sum &#x3D; val1+val2+carry。</p><p>3.如果是两个长度不一样的链表，则需要注意将不再继续向后，且让相应位的和为val1+0.</p><p>4.carry的更新，carry &#x3D; sum&#x2F;10, 而当前节点和 curr-&gt;val &#x3D; sum%10.</p><p>5.循环直至l1,l2都为空。</p><p>6.遍历完之后如果carry &#x3D;&#x3D; 1, 新建一个节点存在进位。</p></blockquote><p>代码实现：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode *newHead &#x3D; new ListNode(0);        ListNode *p &#x3D; l1;        ListNode *q &#x3D; l2;        ListNode *curr &#x3D; newHead;        int carry &#x3D; 0; &#x2F;&#x2F;进位        while(p !&#x3D; NULL || q !&#x3D; NULL) &#123;            int sum &#x3D; 0, x &#x3D; 0, y &#x3D; 0;            if(p) &#123;                x &#x3D; p -&gt; val;                p &#x3D; p -&gt; next;            &#125;            if(q) &#123;                y &#x3D; q -&gt; val;                q &#x3D; q -&gt; next;            &#125;            sum &#x3D; x + y + carry;            carry &#x3D; sum &#x2F; 10;            curr -&gt; next &#x3D; new ListNode(sum % 10);            curr &#x3D; curr -&gt; next;        &#125;        if(carry) &#123;            curr -&gt; next &#x3D; new ListNode(carry);        &#125;        return newHead -&gt; next;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:35.搜索插入位置</title>
      <link href="/2023/01/16/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2023/01/16/leetcode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 5输出: 2</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 2输出: 1</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [1,3,5,6], target &#x3D; 7输出: 4</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>目标元素有以下几种情况：</p><p>1.插入在数组头部</p><p>2.插入数组中某个位置</p><p>3.在数组中找到该元素</p><p>4.插入数组尾部</p><p>因此可用顺序遍历或者二分查找来解题</p><ol><li>顺序遍历整个数组的暴力解法</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        for(int i &#x3D; 0; i &lt; nums.size(); i++)        &#123;            if(nums[i] &#x3D;&#x3D; target)            &#123;                return i;            &#125;            else if(nums[i] &gt; target)&#123;                return i;            &#125;        &#125;        return nums.size();    &#125;&#125;;</code></pre><ol start="2"><li>使用二分查找法进行位置的查找</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int l&#x3D;0,r&#x3D;nums.size()-1;&#x2F;&#x2F; 我们定义target在左闭右闭的区间里，[left, right] ，当left&#x3D;&#x3D;right，区间[left, right]依然有效        while(l&lt;&#x3D;r)        &#123;            int mid&#x3D;l+(r-l)&#x2F;2;            if(nums[mid]&lt;target)            &#123;                l&#x3D;mid+1;&#x2F;&#x2F; target 在右区间，所以[middle + 1, right]            &#125;            else if(nums[mid]&#x3D;&#x3D;target)            &#123;                return mid;            &#125;            else            &#123;                r&#x3D;mid-1;&#x2F;&#x2F; target 在左区间，所以[left, middle - 1]            &#125;        &#125;        return r+1;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:20.有效的括号</title>
      <link href="/2023/01/15/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2023/01/15/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;()&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;输出：true</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：s &#x3D; &quot;(]&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>使用栈进行左半边括号的存储，遍历字符串，当遇到右半边括号时进行匹配，若是相匹配的括号则继续遍历字符串直到最后一个字符，否则返回false。实现代码如下：</li></ol><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt; sc; &#x2F;&#x2F;创建栈        for(char a:s)&#123; &#x2F;&#x2F;遍历并判断，首先判断栈是否为空，                       &#x2F;&#x2F;接下来判断两个括号是否匹配。            if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;)&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;(&#39;)                sc.pop(); &#x2F;&#x2F;匹配成功后将栈内的左括号弹出            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;]&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;[&#39;)                sc.pop();            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;&#125;&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;&#123;&#39;)                sc.pop();            else                 sc.push(a); &#x2F;&#x2F;若是左括号，则压入栈内        &#125;        return sc.empty(); &#x2F;&#x2F;遍历结束后，若栈为空，则返回true    &#125;&#125;;</code></pre><ol start="2"><li>官方解答</li></ol><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>我们遍历给定的字符串 sss。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 sss 无效，返回 False\text{False}False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 sss 中的所有左括号闭合，返回<code>True</code>，否则返回 <code>False</code>。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 <code>False</code>，省去后续的遍历判断过程。</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isValid(string s) &#123;        int n &#x3D; s.size();        if (n % 2 &#x3D;&#x3D; 1) &#123;            return false;        &#125;        unordered_map&lt;char, char&gt; pairs &#x3D; &#123;            &#123;&#39;)&#39;, &#39;(&#39;&#125;,            &#123;&#39;]&#39;, &#39;[&#39;&#125;,            &#123;&#39;&#125;&#39;, &#39;&#123;&#39;&#125;        &#125;;        stack&lt;char&gt; stk;        for (char ch: s) &#123;            if (pairs.count(ch)) &#123;                if (stk.empty() || stk.top() !&#x3D; pairs[ch]) &#123;                    return false;                &#125;                stk.pop();            &#125;            else &#123;                stk.push(ch);            &#125;        &#125;        return stk.empty();    &#125;&#125;;</code></pre><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/">https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:23.合并K个升序链表</title>
      <link href="/2023/01/12/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/01/12/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：lists &#x3D; []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：lists &#x3D; [[]]输出：[]</code></pre><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>归并排序(使用单指针)</li></ol><p>在mergeTwoLists函数中，使用了一个虚拟头节点，将其next指向合并后的链表头节点，然后不断更新cur指针的值，使其指向合并后的链表的最后一个节点，最后返回虚拟头节点的next即可。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F; 合并 两个有序链表    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        ListNode* temp1 &#x3D; list1;        ListNode* temp2 &#x3D; list2;        ListNode* newHead &#x3D; new ListNode(); &#x2F;&#x2F; 虚拟头节点        ListNode* cur &#x3D; newHead;        while (temp1 !&#x3D; NULL &amp;&amp; temp2 !&#x3D; NULL) &#123;            if (temp1-&gt;val &lt; temp2-&gt;val) &#123;                cur-&gt;next &#x3D; temp1;                temp1 &#x3D; temp1-&gt;next;            &#125;            else &#123;                cur-&gt;next &#x3D; temp2;                temp2 &#x3D; temp2-&gt;next;            &#125;            cur &#x3D; cur-&gt;next; &#x2F;&#x2F; 更新cur指针的值        &#125;        if (temp1 !&#x3D; NULL) &#123;            cur-&gt;next &#x3D; temp1;                    &#125;        if (temp2 !&#x3D; NULL) &#123;            cur-&gt;next &#x3D; temp2;                    &#125;        return newHead-&gt;next;    &#125;    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        ListNode* head &#x3D; nullptr;        for (int i &#x3D; 0; i &lt; lists.size(); i++) &#123;            head &#x3D; mergeTwoLists(head, lists[i]);        &#125;        return head;    &#125;&#125;;</code></pre><ol start="2"><li>归并排序（使用二级指针实现）</li></ol><p>在mergeTwoLists函数中，使用了一个curNode指针指向合并后的链表，使用了一个二级指针temp，根据list1和list2的值大小，让temp指向较小的那个节点，然后将其插入到curNode之后，并更新curNode指向插入后的链表最后一个节点。最后，如果还有剩余节点，将其直接补充到合并后的链表尾部。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    &#x2F;&#x2F;合并两个有序链表    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)    &#123;        ListNode* head &#x3D; nullptr;        ListNode* curNode &#x3D; nullptr;        ListNode** temp &#x3D; nullptr;        bool isFirst &#x3D; true;        while(list1 !&#x3D; nullptr &amp;&amp; list2 !&#x3D; nullptr)        &#123;            temp &#x3D; (list1 -&gt; val &lt; list2 -&gt; val)? &amp;list1:&amp;list2; &#x2F;&#x2F;使用二级指针，因为temp如果是一级指针，那么temp &#x3D; temp-&gt;next;是无法改变list1和list2的值的，而二级指针可以间接改变list1和list2的地址。            if(isFirst)            &#123;                head &#x3D; *temp;                curNode &#x3D; *temp;                isFirst &#x3D; false;            &#125;            else            &#123;                curNode -&gt; next &#x3D; *temp;                curNode &#x3D; curNode -&gt; next;            &#125;            *temp &#x3D; (*temp) -&gt; next;        &#125;        if(nullptr !&#x3D; list1)        &#123;            if(isFirst)  &#x2F;&#x2F;有一方链表为空            &#123;                head &#x3D; list1;            &#125;            else         &#x2F;&#x2F;剩下结点直接补齐            &#123;                curNode -&gt; next &#x3D; list1;            &#125;        &#125;        if(nullptr !&#x3D; list2)        &#123;            if(isFirst)            &#123;                head &#x3D; list2;            &#125;            else            &#123;                curNode-&gt;next &#x3D; list2;            &#125;        &#125;        return head;    &#125;    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        ListNode* head &#x3D; nullptr;        for(int i &#x3D; 0; i &lt; lists.size(); i++)        &#123;            head &#x3D; mergeTwoLists(head, lists[i]);        &#125;        return head;    &#125;&#125;;</code></pre><ol start="3"><li>使用优先队列</li></ol><p>可以将所有的链表的首节点放入一个小根堆中，每次从堆中取出最小节点，将该节点接入最终链表，并将该节点的下一个节点加入堆中。重复该过程直到堆为空。</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;        &#x2F;&#x2F;如果传进来的链表为空，直接返回空指针。        if(lists.empty()) &#123;            return nullptr;        &#125;        &#x2F;&#x2F;定义一个优先队列，该队列将所有链表的头结点按照节点的值从小到大排列。        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq;        &#x2F;&#x2F;定义一个虚拟头结点和一个当前节点cur。        ListNode dummy(0);        ListNode* cur &#x3D; &amp;dummy;        &#x2F;&#x2F;将所有链表的头结点加入到优先队列中。        for(auto&amp; node: lists) &#123;            if(node) &#123;                pq.push(node);            &#125;        &#125;        &#x2F;&#x2F;每次取出队列中的最小值，将该节点加入到合并后的链表中，并将该节点的下一个节点加入到队列中。        while(!pq.empty()) &#123;            auto temp &#x3D; pq.top();            pq.pop();            cur-&gt;next &#x3D; temp;            cur &#x3D; cur-&gt;next;            if(temp-&gt;next) &#123;                pq.push(temp-&gt;next);            &#125;        &#125;        &#x2F;&#x2F;返回合并后的链表。        return dummy.next;    &#125;private:    &#x2F;&#x2F;自定义比较函数，用于优先队列。 保证队尾元素最大    struct cmp &#123;        bool operator() (const ListNode* a, const ListNode* b) &#123;            return a-&gt;val &gt; b-&gt;val;        &#125;    &#125;;&#125;;</code></pre><p>请注意优先队列的定义方式：</p><blockquote><p><code>priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq</code> 是一个定义了一个<code>priority_queue</code>对象<code>pq</code>，其中包含三个参数：</p><ol><li><code>ListNode*</code> 是存储在堆中的元素的类型，即堆元素的指针类型为<code>ListNode*</code>；</li><li><code>vector&lt;ListNode*&gt;</code> 是底层容器类型，即使用<code>vector</code>来实现堆；</li><li><code>cmp</code> 是比较函数，用于堆中元素的排序方式。</li></ol><p>根据这个定义，我们可以理解<code>priority_queue</code>的工作原理：它是一个基于堆的数据结构，其中的元素按照指定的比较函数<code>cmp</code>进行排序。<code>priority_queue</code>是一个可以高效获取最大（或最小）元素的容器，因此常常被用来实现一些需要对元素进行优先级处理的算法。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:19.删除链表的倒数第N个结点</title>
      <link href="/2023/01/11/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2023/01/11/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="http://cdn.leafii.top/img/remove_ex1.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2输出：[1,2,3,5]</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1], n &#x3D; 1输出：[]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：head &#x3D; [1,2], n &#x3D; 1输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>双指针遍历一次链表，思路如下：</li></ol><p>设置两个指针p，q，分别初始为头结点，然后p指针向后移动n次，接着p和q指针同时移动直到p指针指向链表的最后一个元素，此时q指针指向的是被删除元素的前一个元素，因此将需要被删除的元素进行删除，最终返回头结点即可，需要注意<strong>删除头结点的情况</strong>。实现代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode *q &#x3D; head, *p &#x3D; head, *t &#x3D; head -&gt; next;        if(head &#x3D;&#x3D; NULL)        &#123;            return head;        &#125;        while(n-- &amp;&amp; p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;p指针向后移动n位        &#123;            p &#x3D; p -&gt; next;        &#125;        if(n !&#x3D; -1) &#x2F;&#x2F;删除头结点        &#123;            t &#x3D; head;            head &#x3D; head -&gt; next;            delete t;            return head;        &#125;        while(p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;此时p和q指针一起向后移动，直到p指向最后一个结点        &#123;            q &#x3D; q -&gt; next;            p &#x3D; p -&gt; next;        &#125;        t &#x3D; q -&gt; next;        q -&gt; next &#x3D; t -&gt; next;        delete t;        return head;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:7.整数反转</title>
      <link href="/2023/01/10/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2023/01/10/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; 123输出：321</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; -123输出：-321</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; 120输出：21</code></pre><p><strong>示例 4：</strong></p><pre class="language-none"><code class="language-none">输入：x &#x3D; 0输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>将数字的每位分别提取并进行字符串拼接，最终将字符串转为int型数字，思路如下：</li></ol><p>因为负数对10取余数得到的结果依然为负数，所以如果x为负数，则将minus标记设置为true，并且将x转化为正数，如果x为正数，则minus标记为false，进行x的正负判断之后可以将string类型的ans_str变量进行初始化，接着进行x的特殊值的判断，因为int型的范围是$-2^{31} 到  2^{31}-1$，所以当<code>x=-2147483648</code>时，它无法被转化为正数进行计算，因此需要单独判断，需要单独判断的还有<code>x=0</code>的情况。接着在while循环中进行倒置的过程。倒置结束后对倒置结果进行判断，如果超过范围的话直接返回0（因为无法通过C++的stoi方法转化为int型结果。C++代码实现如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int reverse(int x) &#123;        bool minus &#x3D; false;        string ans_str &#x3D; &quot;0&quot;;        &#x2F;&#x2F;特例判断        if(x &#x3D;&#x3D; -2147483648)&#123;            return 0;        &#125;        if(x &#x3D;&#x3D; 0)        &#123;            return 0;        &#125;        &#x2F;&#x2F;对负数的处理        if(x &lt; 0)        &#123;            ans_str &#x3D; &quot;-0&quot;;            x &#x3D; x * -1;            minus &#x3D; true;        &#125;        &#x2F;&#x2F;在while循环中进行倒置操作，倒置结果储存在ans_str变量中。        while(x !&#x3D; 0)&#123;            int temp_num &#x3D; x % 10;            x &#x3D; x &#x2F; 10;            string temp_str &#x3D; to_string(temp_num);            ans_str &#x3D; ans_str + temp_str;        &#125;        &#x2F;&#x2F;2^31-1 &#x3D; 2147483647        &#x2F;&#x2F;-2^31 &#x3D; -2147483648        &#x2F;&#x2F;通过int型范围设置两个对比的string类型，防止倒置结果超过范围。        string upper &#x3D; &quot;02147483647&quot;;        string lower &#x3D; &quot;-02147483648&quot;;        &#x2F;&#x2F;倒置结果是否超限的判断        if(minus &#x3D;&#x3D; true &amp;&amp; ans_str.length() &#x3D;&#x3D; 12)&#123;            for(int i &#x3D; 0; i &lt; 12; i++)&#123;                if(ans_str[i] &lt; lower[i])&#123;                    break;                &#125;                if(ans_str[i] &gt; lower[i])&#123;                    return 0;                 &#125;            &#125;        &#125;        if(minus &#x3D;&#x3D; false &amp;&amp; ans_str.length() &#x3D;&#x3D; 11)&#123;            for(int i &#x3D; 0; i &lt; 11; i++)&#123;                if(ans_str[i] &lt; upper[i])&#123;                    break;                &#125;                if(ans_str[i] &gt; upper[i])&#123;                    return 0;                &#125;            &#125;        &#125;        &#x2F;&#x2F;最终结果的转化        &#x2F;&#x2F;stoi函数：string -&gt; int        &#x2F;&#x2F;to_string函数：int -&gt; string        int ans &#x3D; stoi(ans_str);        return ans;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decima-Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers</title>
      <link href="/2023/01/10/Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers/"/>
      <url>/2023/01/10/Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers/</url>
      
        <content type="html"><![CDATA[<h2 id="Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers"><a href="#Decima-Robustness-Analysis-and-Enhancement-of-Deep-Reinforcement-Learning-Based-Schedulers" class="headerlink" title="Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)"></a>Decima(Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers)</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>我们设计了黑盒扰动系统，其中训练了一个代理模型来模仿基于 DRL 的调度策略，并且表明，高可信代理模型可以帮助制作有效的扰动。扰动的意思是对作业的节点特性或依赖性进行轻微调整，同时不改变其功能。</p><p>最终，我们研究了提高基于 DRL 的调度程序对此类扰动的鲁棒性的解决方案：我们提出了一种对抗性训练框架，以强制神经模型在训练过程中适应扰动模式，从而消除应用过程中的潜在损害。</p><span id="more"></span><ul><li><strong>提出问题</strong></li></ul><p>各种研究发现深度神经模型（如DRL模型）容易受到对抗性数据实例的影响（如其观察空间或动作空间输入的扰动）产生错误决策，并且缺乏鲁棒性；而在云计算调度问题中，对鲁棒性也有很高的要求，即使系统中没有恶意用户也有可能会有一些特征模式触发调度程序的不当行为，因此这种鲁棒性问题并不总是与对抗性扰动相关联，但研究它的重要性是绝对的。</p><ul><li><strong>解决思路</strong></li></ul><ol><li>研究如何开发一种有效扰乱工作特征的方法。</li><li>在成功模拟有效扰乱工作特征之后，提出对抗训练方法以提升模型的鲁棒性</li></ol><ul><li><strong>实验结果</strong></li></ul><p>我们的实验表明，这种鲁棒性的提高显着降低了工作扰动的成功率。即使扰动成功，它也会降低扰动作业的性能增益。具有对抗性训练的 DRL 调度器能够实现与原始 DRL 调度器相当的调度性能。</p><h3 id="黑盒扰动系统"><a href="#黑盒扰动系统" class="headerlink" title="黑盒扰动系统"></a>黑盒扰动系统</h3><p>首先提出之前有人设计的白盒扰动系统，白盒方法假设用户可以访问 DRL 模型的详细信息，包括模型架构和参数。但白盒扰动系统存在这样一个问题：对于调度策略未知的许多云系统，该假设通常不成立。</p><p>因此工作扰动系统采用黑盒假设来解决这个问题，这意味着恶意用户无法访问 DRL 模型和其他用户的工作，如下图中的阴影方块所示。</p><p><img src="http://cdn.leafii.top/img/image-20230116152713038.png" alt="image-20230116152713038" loading="lazy"></p><p>其核心技术是模型窃取，即利用制造的数据集训练本地代理模型作为目标模型的替代品。代理模型不需要与其目标具有相同的结构，而只是模仿功能。</p><p>恶意用户通过模仿得到相同种类但细节不同的job，然后将job在空闲时间提交以获得调度程序的神经模型。通过执行完成后的调度轨迹，可以得知调度程序在每个时间步做出怎样的决策。因此，它只通过几个调度轨迹就得到了一个比较可信的代理神经网络。并且通过job状态和决策形成的元组，它将一个调度问题解耦成了一个分类问题。</p><p>在该代理模型的帮助下，恶意用户就可以在job提交之前计算并且应用扰动（增加一些任务的并行度或者在任务之间增加依赖关系）来获得额外的计算资源以达成早一些完成任务的目的。</p><h3 id="作业扰动"><a href="#作业扰动" class="headerlink" title="作业扰动"></a>作业扰动</h3><p>作业扰动的目的是在某些时间步将调度决策偏向错误的方向。</p><p><strong>成功施加扰动的难点</strong>：</p><p>首先，扰动可以应用于作业中多达数百个特征，并且很难获得最优计划。</p><p>其次，扰动作业试图抢占动态系统中的资源。它会在调度过程中的一个确定的时间步发生。具体成功时间由当时的系统状态快照决定，这是系统禁止的。</p><h4 id="基于梯度的扰动"><a href="#基于梯度的扰动" class="headerlink" title="基于梯度的扰动"></a>基于梯度的扰动</h4><h5 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h5><p>$job_k$ 的特征形成一个 $m \times n $矩阵 $X_k : (x_i,j)$，其中 $m_k$ 是任务数，$n$ 是特征数。此外，只有解决了任务的依赖关系才能执行任务，这些依赖关系由相邻矩阵 $E_k : (e_i,j)$ 表示，其中 $i, j \in [1, m_k]$。</p><p><strong>关于扰动</strong>：我们只会扰乱<strong>并行性</strong>和<strong>依赖性</strong>。</p><h5 id="特征扰动"><a href="#特征扰动" class="headerlink" title="特征扰动"></a>特征扰动</h5><p>在调度程序执行的过程中，一个任务是否被优先调度取决于它的得分。为了让被扰动的作业优先执行且占用更多资源，必须通过扰动让被扰动的作业获得更高的分数，只有获得更高的分数，它才能被执行。被扰动的作业优先被调度时必须满足下面公式：</p><p>$O_t[\bar{o_t}] &gt; O_t[o_t]$</p><p>但是本身被扰动的作业在被扰动前它的$O_t[\bar{o_t}]$就同$O_t[o_t]$相差很大，因此需要通过扰动使其获得更高的分数。为了决定扰动哪个特征可以使分数增加更多，提出了特征梯度的概念。</p><p>$\nabla \chi_tO_t[\bar{o_t}] &#x3D; \frac{\partial O_t[\bar{o_t}]}{\partial \chi_t}$</p><p>通过特征梯度可以得知作业中哪个特征的扰动对$O_t[o_t]$值的影响更显著。因此可以通过下面式子得知哪个task的哪个feature应该被选择去扰动。</p><p>$T^*, f^* &#x3D; argmax[\frac{\partial O_t[\bar{o_t}]}{\partial \chi_t}]$</p><p>确定了对哪个特征进行扰动，就该进行扰动的实际操作了，沿着值方向对特征进行增量应用扰动，如下式：</p><p>$x_{T^*, f^*} &#x3D; x_{T^*, f^*} + sign([\frac{\partial O_t[\bar{o_t}]}{\partial \chi_t}]_{T^*, f^*}) \times \delta$</p><h5 id="依赖扰动"><a href="#依赖扰动" class="headerlink" title="依赖扰动"></a>依赖扰动</h5><p>因此不能破坏原有任务的依赖性，因此所谓的依赖扰动就是通过加入以前独立的任务来应用依赖性扰动。它的评判标准被定义为下面的式子：</p><p>$\nabla \varepsilon_tO_t[\bar{o_t}] &#x3D; avg[\frac{\partial O_t[\bar{o_t}]}{\partial \varepsilon_t^i}] &#x3D; \frac{1}{K}\sum_{i&#x3D;1}^{K} \frac{\partial \bar{\pi_\theta}(\chi_t, \varepsilon_t^i)}{\partial \varepsilon_t^i}$</p><p>边缘梯度在相邻矩阵 $E_t$ 上形成显着图，其中较高的值表示在应用扰动时输出分量的改进更为显着。因此，在任务$T_f^*$和任务$T_t^*$之间的边被添加了：</p><p>$T_f^*, T_t^* &#x3D; argmax(avg[\frac{\partial O_t[\bar{o_t}]}{\partial \varepsilon_t^i}])$</p><p>识别出的边缘还应该满足这两个任务都属于恶意用户的工作并且之前是独立的。否则，上面的式子将继续寻找下一条除了不满足条件外显着性值最大的边。</p><h4 id="近似扰动"><a href="#近似扰动" class="headerlink" title="近似扰动"></a>近似扰动</h4><p>由于矩阵$\chi_t$和$\varepsilon_t$ 的一些部分不可访问，因此在训练过程中，通过自己的定义，将之前方程中梯度的专用分量可以通过每个独立输入作业的梯度来近似。</p><p>$T^*, f^* \approx argmax[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{X_t}}]$</p><p>$T_f^*, T_t^* \approx argmax(avg[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{E_t^i}}])$</p><p>当原始调度决策不那么明显时，在时间步长 t 应用扰动是至关重要的。我们通过近似来解决决定时间步长的问题。</p><p>通过用原始工作特征$\hat{X}$和$\hat{E^i}$替换即时的工作特征$\hat{X_t}$和$\hat{E_t^i}$。我们以工作的关键路径上的所有任务为目标进行综合考虑，将上面的两个近似式子重构成了以下式子：</p><p>$T^*, f^* \approx argmax[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{X}}]$</p><p>$T_f^*, T_t^* \approx argmax(avg[\frac{\partial O_t[\bar{o_t}]}{\partial \hat{E^i}}])$</p><p>由于特征和依赖扰动计划都是时不变的，因此可以通过以 O(1) 时间成本提交的作业来计算。</p><h3 id="基于-DRL-的调度器的稳健性改进"><a href="#基于-DRL-的调度器的稳健性改进" class="headerlink" title="基于 DRL 的调度器的稳健性改进"></a>基于 DRL 的调度器的稳健性改进</h3><p>我们描述了一个对抗训练框架来提高 DRL 调度器的稳健性。它通过让调度程序在训练期间学习工作扰动的模式来提高鲁棒性。</p><p>在强化学习中，用来更新策略$\pi$的参数$\theta$的梯度可以通过以下式子获得：</p><p>$g &#x3D; E[\sum_{t&#x3D;0}^{\infin}R_t \nabla log_\theta (\pi_\theta(A_t|S_t))]$</p><p>在对抗训练期间，扰动状态 $S_t^*$ 和原始状态 $S_t$ 一起学习，以将梯度引向$\nabla log_\theta (\pi_\theta(A_t|S_t)) + \nabla log_\theta (\pi_\theta(A_t|S_t^*))$。</p><p>在训练阶段添加这种对抗性扰动可以使模型在寻找最高奖励时不那么极端，如果扰动发生在应用阶段 ，则模型会更加稳健。</p><p>对抗训练的整体工作流程为：</p><p><img src="http://cdn.leafii.top/img/image-20230116165033169.png" alt="image-20230116165033169" loading="lazy"></p><p>对抗训练框架的示意图：</p><p><img src="http://cdn.leafii.top/img/image-20230116165112449.png" alt="image-20230116165112449" loading="lazy"></p><p>原始状态和扰动状态被馈送到模型中进行梯度计算，并使用相同的奖励信号更新模型。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h4><p>我们使用 Decima的作业执行引擎作为我们的测试平台。</p><p>在我们的实验中，我们将集群的执行器数量设置为 10 和 20。我们使用 TPC-H 作业 [41] 作为工作负载。作业的统计信息，包括每个作业 DAG 中的级别、任务数以及每个任务的并行度和持续时间，如表 2 所示。作业运行时间遵循重尾分布，大约 20% 的作业占用所有作业运行时间的 80%。</p><p><img src="http://cdn.leafii.top/img/image-20230116171153629.png" alt="image-20230116171153629" loading="lazy"></p><p>我们实现了三种 DRL 算法作为 Decima 调度框架的插件，以证明这个问题对于不同的 DRL 算法是常见的。</p><p>第一种算法是REINFORCE，其每个时间步的奖励是通过使用情景样本的蒙特卡洛方法估计的，原始 Decima 调度程序也使用该方法。</p><p>第二种算法是off-policy policy gradient(OPPG),它使用行为策略来推导调度决策并计算另一个目标策略的重要性采样。</p><p>第三种算法是同步优势演员评论家 (A2C)，参与者(actor)使用策略模型生成动作，而评论家(critic)则使用另一个神经模型来预测每个动作的优势.每个模型中的核心策略都是用全连接神经网络实现的。实际上，A2C 使用 5 种不同的陈旧版本。 A2C 中的演员和评论家由不同的全连接层组成。actor 具有动态数量的输出，形成任务的概率分布，而 critic 仅输出一个单元。</p><p>图神经网络结合了非线性激活和聚合函数，这为调度程序提供了输入的全局视图，以获得更好的调度策略。</p><p>调度程序的脆弱性是通过它们受工作扰动影响的可能性来衡量的。成功的扰动会抢占资源以提前完成扰动的工作，同时延迟其他工作.</p><p>评估脆弱性的三个指标：扰动的成功率、扰动工作的好处（通过降低 JCT(任务完成时间) 来衡量）以及显着延迟的工作数量。而稳健性的提高是通过这些指标的减少来衡量的。</p><h4 id="模型窃取"><a href="#模型窃取" class="headerlink" title="模型窃取"></a>模型窃取</h4><p>忠实的代理神经模型对于<strong>黑盒扰动</strong>的成功至关重要。我们启动 50 个查询来窃取作业调度程序中的模型。每个查询包含 20 个根据时间步长安排的模拟作业。总的来说，我们从 11,000 个调度时间步长中获得了状态和动作对。其中 80% 用于训练，其余 20% 用于测试。代理模型学习如何在每个时间步将调度程序从数百个其他任务中选择的任务分类。最终实验结果表明：CNN 模型达到了 82.2% 的精度来近似 REINFORCE，而 GCN 达到了 85.0% 的精度来近似 OPPG。</p><p><img src="http://cdn.leafii.top/img/image-20230116181602908.png" alt="image-20230116181602908" loading="lazy"></p><h4 id="基于-DRL-的调度程序的脆弱性"><a href="#基于-DRL-的调度程序的脆弱性" class="headerlink" title="基于 DRL 的调度程序的脆弱性"></a>基于 DRL 的调度程序的脆弱性</h4><p>在本节中，进行了多次实验来评估漏洞。在每个实验中，提交了 50 个作业，其中一个作业被扰动了。独立评估不同的基于 DRL 的调度程序。将每个作业的作业完成时间与在相同设置但没有作业扰动的情况下获得的作业完成时间进行比较。</p><p><img src="http://cdn.leafii.top/img/image-20230116181800279.png" alt="image-20230116181800279" loading="lazy"></p><p>(a) 黑盒作业扰动干扰每个基于 DRL 的调度程序的成功率。 (b) 受扰动工作的好处（以减少的 JCT 衡量）和由于扰动工作的好处而严重延迟的正常工作（其 JCT 增加超过 5%）的数量。</p><p><strong>最终结果</strong>：REINFORCE 比其他两个调度程序更容易受到扰动，因为后者有超过 10 个正常作业被显着延迟。 OPPG和A2C的鲁棒性更强主要是因为独立行为策略或批评模型达到了一定的鲁棒性。</p><h4 id="对于扰动的详细说明"><a href="#对于扰动的详细说明" class="headerlink" title="对于扰动的详细说明"></a>对于扰动的详细说明</h4><p>为了理解基于 DRL 的调度器的脆弱性，我们首先给出扰动的统计数据，然后给出一个详细的例子来说明扰动是如何产生影响的。</p><p><strong>在改变并行度方面</strong>：并行度的降低是通过为数据分区插入“合并”运算符来实现的，而并行度的增加是通过在任务代码的开头添加运算符“repartition”来实现的。</p><p><strong>在增加依赖方面</strong>：两个任务的连接是通过“连接”的运算符实现的。</p><p>通过以上方式成功实现了扰动。</p><p><img src="http://cdn.leafii.top/img/image-20230116182309070.png" alt="image-20230116182309070" loading="lazy"></p><p>不同类型的扰动。从左到右，作业受到 (i) 仅增加任务并行度，(ii) 降低作业并行度并添加依赖项，以及 (iii) 仅添加依赖项的干扰。</p><h4 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h4><p>我们提供了一个案例研究来解释用不同方法扰乱的工作如何使他们的 JCT 受益，如图9所示：</p><p><img src="http://cdn.leafii.top/img/image-20230116183729916.png" alt="image-20230116183729916" loading="lazy"></p><p>扰动或调整后的并行度由每个任务节点周围的数字显示。示例作业没有依赖性变化，因为显着性值太低，即改变依赖性不会导致成功的扰动。</p><p>我们使用 REINFORCE 调度程序比较每个扰动作业的任务执行模式和同一环境中的原始作业，如图10所示：</p><p><img src="http://cdn.leafii.top/img/image-20230116183920593.png" alt="image-20230116183920593" loading="lazy"></p><p><strong>实验结果表明</strong>：经过扰动后，这些任务能够在某些调度步骤中具有更高的优先级。这些任务以更高的并行度执行，因此更早完成。它们的完成也可能导致依赖于它们的后续任务的提前执行。</p><h4 id="鲁棒性的提升"><a href="#鲁棒性的提升" class="headerlink" title="鲁棒性的提升"></a>鲁棒性的提升</h4><p>在本节中，我们评估了对抗训练在提高基于 DRL 的调度程序处理扰动工作的鲁棒性方面的有效性。</p><h5 id="对抗训练"><a href="#对抗训练" class="headerlink" title="对抗训练"></a>对抗训练</h5><p>一个健壮的基于 DRL 的调度器的实现方式与第 6.1 节中详述的方式类似。我们还在调度程序中包含了不同的强化学习实现，即 REINFORCE、OPPG 和 A2C。</p><p>每个调度器的正常训练和对抗训练的过程如图11的左栏所示：</p><p><img src="http://cdn.leafii.top/img/image-20230116184150766.png" alt="image-20230116184150766" loading="lazy"></p><blockquote><p>左列显示了基于 DRL 的调度程序的正常和对抗训练过程。每个模型的收敛由平均奖励的扁平化表示。右列显示了基本调度程序和鲁棒调度程序在 50 个作业集上的调度性能。剩余作业数量减少得越快，调度性能越好。具体来说，Reinforce的图如(a)和(b)所示，OPPG的图如(c)和(d)所示，A2C的图如(e)和(f)所示。</p></blockquote><p>该过程的特点是在每个情节中获得的归一化平均奖励。在训练过程中包括受扰动的工作会使收敛花费更长的时间，并且收到的奖励会波动（图 11a 和 11e）。</p><h5 id="调度表现"><a href="#调度表现" class="headerlink" title="调度表现"></a>调度表现</h5><p>我们将每个基于 DRL 的鲁棒调度程序的调度性能与基本对应调度程序进行比较。Jobs的执行流程如图11右栏所示。</p><p>总而言之，强大的 DRL 调度器保持了令人满意的调度性能。</p><h5 id="鲁棒性评估"><a href="#鲁棒性评估" class="headerlink" title="鲁棒性评估"></a>鲁棒性评估</h5><p>我们在“基于 DRL 的调度程序的脆弱性”的相同实验设置下评估了基于 DRL 的鲁棒调度程序的脆弱性，并将展示鲁棒性改进。</p><p>总的来说，我们的对抗训练方法可以提高基于 DRL 的调度程序的鲁棒性并减少工作扰动的影响。</p><h4 id="白盒扰动的脆弱性"><a href="#白盒扰动的脆弱性" class="headerlink" title="白盒扰动的脆弱性"></a>白盒扰动的脆弱性</h4><p>在“Whitebox”中，它拥有了一个更强的假设，即用户可以完全访问 DRL 模型。特征中的所有显着性值空间是在原始 DRL 模型而不是代理模型上计算的。在本节中，我们评估鲁棒调度程序是否也对白盒扰动具有鲁棒性。</p><p><img src="http://cdn.leafii.top/img/image-20230116185045106.png" alt="image-20230116185045106" loading="lazy"></p><p>总的来说，通过代理模型训练的鲁棒调度器可以有效地处理白盒模型产生的扰动作业。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本文中，我们探讨了基于 DRL 的调度程序的稳健性问题。 我们展示了用户可以在代理模型的帮助下扰乱作业以进行抢占，代理模型是为模仿基于 DRL 的调度程序的调度行为而开发的。 就工作自然具有某些特征模式而言，扰动可能是无意的。 这可能导致调度行为的不确定性。 我们提出了一种计算作业扰动的算法，并表明扰动作业具有很高的成功率以获得高调度优先级。 我们表明这种扰动对调度程序有害，因为它会导致系统中其他作业的意外延迟。 我们设计了一个对抗训练框架来提高 DRL 调度程序的稳健性。 广泛的实验表明，鲁棒调度器在保持高调度性能的同时不易受到扰动的影响。</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>TPC-H, 2020. [Online]. Available: <a href="http://www.tpc.org/tpch/">http://www.tpc.org/tpch/</a> default5.asp</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ieeexplore.ieee.org/abstract/document/9937194">Robustness Analysis and Enhancement of Deep Reinforcement Learning-Based Schedulers</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decima-Learning Scheduling Algorithms for Data Processing Clusters</title>
      <link href="/2023/01/09/Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters/"/>
      <url>/2023/01/09/Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters/</url>
      
        <content type="html"><![CDATA[<h2 id="Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters-用强化学习解决调度问题"><a href="#Decima-Learning-Scheduling-Algorithms-for-Data-Processing-Clusters-用强化学习解决调度问题" class="headerlink" title="Decima(Learning Scheduling Algorithms for Data Processing Clusters):用强化学习解决调度问题"></a>Decima(Learning Scheduling Algorithms for Data Processing Clusters):用强化学习解决调度问题</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>解决了在云上的多个以DAG图表示的任务在多个Executor上运行时的调度问题。该问题为NP-Hard难度的问题，在该论文中，作者使用RL和GNN来解决它。</p><span id="more"></span><ul><li><strong>任务描述</strong></li></ul><p>每一个节点表示一个计算的阶段(computation stage)， 每个阶段都包含可以并行计算的任务；</p><p>每一条边表示数据依赖(Data dependencies)，父节点完成之后子节点才可以开始运行。</p><p><img src="http://cdn.leafii.top/img/image-20230115181529685.png" alt="image-20230115181529685" loading="lazy"></p><ul><li><strong>交互过程</strong></li></ul><ol><li>调度器接受任务，并且将挂起的计算阶段映射到可用服务器上运行。</li><li>与此同时不断有新的、随机的任务请求出现，即待分配的任务和可用的服务器都处于动态变化的环境中。</li><li>智能体的观测(Observation)：所有可用作业的信息和服务器在每个调度事件上的状态。(the information of all available jobs and the status of the servers at every scheduling event.)</li><li>目标：最小化任务的平均完成时间。</li></ol><p><img src="http://cdn.leafii.top/img/image-20230115184822403.png" alt="image-20230115184822403" loading="lazy"></p><ul><li>论文贡献：<ul><li>针对具有依赖关系的任务，使用RL训练workload-specific调度算法：Decima</li><li>使用可伸缩的GNN来表示调度策略，可以处理任意形状和大小的DAG表示的任务</li><li>任务随机到达，可以进行在线学习</li></ul></li></ul><h3 id="强化学习模型"><a href="#强化学习模型" class="headerlink" title="强化学习模型"></a>强化学习模型</h3><ul><li>Action组成：(node, 服务器数量)</li><li>当服务器池中有空闲服务器的时候，选择一个node，为其分配相应的节点数量，重复该过程直至所有服务器都处于忙碌状态。这样的<strong>优点</strong>是减少动作空间大小和动作序列的长度，降低强化学习的难度，作者称这是唯一work的设计。</li></ul><p><img src="http://cdn.leafii.top/img/image-20230115190117750.png" alt="image-20230115190117750" loading="lazy"></p><ul><li>State：DAG信息（包括任务数量、平均任务时间、可用服务器数量、待决策的任务数量等</li></ul><h3 id="GNN（DAG信息聚合）"><a href="#GNN（DAG信息聚合）" class="headerlink" title="GNN（DAG信息聚合）"></a>GNN（DAG信息聚合）</h3><p>$e_v &#x3D; g[\sum_{w\in\xi(v)}f(e_w)]+x_v$</p><p>其中x表示节点的特征，w表示所有的子节点，因此节点的打分因子是由子节点分数之和以及节点特征决定的。</p><p><img src="http://cdn.leafii.top/img/image-20230115192627762.png" alt="image-20230115192627762" loading="lazy"></p><p>使用两个非线性函数是因为它能让Decima表达更加广泛多变的聚合函数，例如$f\sim log(\cdot&#x2F;n),g\sim exp(n \times \cdot)$时，Decima能表示下图的关键路径：</p><p><img src="http://cdn.leafii.top/img/image-20230115192642575.png" alt="image-20230115192642575" loading="lazy"></p><p>$e_t^i &#x3D; g[\sum_{w\in \xi(v)}f(e_w^i)]+x_v^i$</p><p>上式为Per-node embeddings表达式，体现了子节点的信息向当前节点汇聚的过程。与Per-node embedding类似，作者为每个Job和所有的任务都分别设计了Per-job embeddings</p><p>${(x_v^i,e_v^i), v\in G_i} \rightarrow y^i$</p><p>以及global embeddings</p><p>${y^1, y^2, …} \rightarrow z$</p><p>GNN(节点信息聚合)的全过程在论文中由下图表示：</p><p><img src="http://cdn.leafii.top/img/image-20230115192235075.png" loading="lazy"></p><p>因此，每个层级的信息聚合由两个非线性变换(f and g)表示；整个GNN由6个非线性变换构成。</p><h3 id="决策网络设计"><a href="#决策网络设计" class="headerlink" title="决策网络设计"></a>决策网络设计</h3><ul><li>调度过程：当某个job完成或者有新job到达时，系统开始调度。</li><li>动作(action)$&lt;v,l_i&gt;$有两个维度，决策网络的输出包括两部分，v是选择哪个任务节点($P_{node}$)，$l_i$是为这个任务分配多少计算资源(Parallelism limit on job)。调度包括以下三个阶段：<ul><li>当任务i使用的服务器比$l_i$少时，Decima为节点$v$分配executors直到executors的数量到达$l_i$.</li><li>上一步完成后，如果有多余的executors，Deciam将继续运行agent得到stage($v$)和parallelism($l_i$).</li><li>上述步骤一直运行，直至没有空闲的executors和未处理的stage($v$).</li></ul></li></ul><p>网络结构如下图所示，包括了GNN部分以及决策网络部分，GNN负责聚合DAG的信息，决策网络负责输出stage($v$)以及并行度上线(parallelism limit)($l_i$):</p><p><img src="http://cdn.leafii.top/img/image-20230115201806948.png" alt="image-20230115201806948" loading="lazy"></p><h3 id="决策网络运行过程"><a href="#决策网络运行过程" class="headerlink" title="决策网络运行过程"></a>决策网络运行过程</h3><ol><li>得到stage(v)</li></ol><ul><li>用非线形网络$q(\cdot)$，得到$q_v^i\triangleq q(e_v^i, y^i, z)$</li><li>使用softmax层，选择调度的stage(v)</li></ul><p>$P(node &#x3D; v) &#x3D; \frac{exp(q_v^i)}{\sum_{u\in A_t}exp(q_u^{j(u)})}$</p><ol start="2"><li>为任务节点分配服务器数量parallelism limit($l_i$)</li></ol><p>计算过程与得到stage(v)类似</p><h3 id="训练模型与实验"><a href="#训练模型与实验" class="headerlink" title="训练模型与实验"></a>训练模型与实验</h3><p>系统的整体结构图如下：</p><p><img src="http://cdn.leafii.top/img/image-20230115203338248.png" alt="image-20230115203338248" loading="lazy"></p><p>模型训练采用的是策略梯度法(PG):</p><p><img src="https://pic2.zhimg.com/v2-83eb2d85ec07441692e6da4f59954399_r.jpg" alt="img" loading="lazy"></p><p><img src="https://pic2.zhimg.com/80/v2-0d73ffcf998e888ae8ad7d745ccb0591_1440w.webp" alt="img" loading="lazy"></p><p>作者在训练时采用以下公式更新策略梯度：</p><p>$\theta \leftarrow \theta + \alpha \sum_{k&#x3D;1}^{T} \nabla_\theta log \pi_\theta (s_k, a_k)(\sum_{k’ &#x3D; k}^{T}r_{k’} - b_k)$</p><p>其中$\alpha$为学习率， $b_k$为baseline，添加baseline是参见此<a href="https://leafii.top/2022/09/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0_PPO%E7%AE%97%E6%B3%95(Proximal%20Policy%20Optimization)/">链接</a></p><p>在训练初期使用较短的任务序列，逐渐加长序列。</p><ul><li>因为在训练初期，agent比较笨，它无法对长序列进行很好的处理，反而会导致任务堆积，学习效率也很低。因此作者的构想为先处理简单的，再逐渐增加难度，效率会高一些。</li><li>这是一种课程学习(curriculum learning)的模式</li></ul><p><strong>与(朴素的)传统方法比较</strong></p><ul><li>朴素的先进任务先执行、最短任务优先会导致资源闲置等待。朴素的公平分配虽然会使服务器没有闲置，但是会导致大量IO开销从而拖慢速度。</li></ul><p>而<strong>Decima</strong></p><ul><li>有选择的将服务器集中在某些小任务上，同时仍然不留下任何资源空闲。</li><li>为每个作业分配适当数量的服务器，这样就不会产生不必要的IO工作。</li></ul><p><strong>实验</strong></p><ul><li>在任务batched arrivals、按泊松分布continuous arrivals两个实验里，Decima完爆传统方法。</li><li>ppt里暂时没看到对任务信息的更进一步描述，比如复杂度分布之类的。不过讲到了Decima完成小任务特别快，并且倾向于对小任务分配更多（但不会过多）的服务器。</li><li>其他实验：解决其他资源调度问题、评估算法各个部分的影响、大规模集群泛化、训练及推理速度、离线优化等，ppt里没讲，等我看了论文再补充</li></ul><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>我们已经将 Decima 实现为一种可插入的调度服务，并行数据处理平台可以通过 RPC 接口与之通信。在 §6.1 中，我们描述了 Decima 与 Spark 的集成。接下来，我们将描述我们基于 Python 的训练基础设施，其中包括一个准确的 Spark 集群模拟器（§6.2）。</p><h4 id="Spark集成"><a href="#Spark集成" class="headerlink" title="Spark集成"></a>Spark集成</h4><p>Spark集群的结构图如图所示：</p><p><img src="http://cdn.leafii.top/img/image-20230117181231455.png" alt="image-20230117181231455" loading="lazy"></p><p>为了在 Spark 中集成 Decima，我们做了两个主要更改：</p><ol><li>每个应用程序的 DAG 调度程序在启动时和调度事件发生时联系 Decima。 Decima 响应下一阶段的工作和并行度限制（§5.2）。</li><li>当新作业到达时，Spark master 会联系 Decima 以确定为其启动多少执行程序，并通过在完成一个阶段后将执行程序从作业中撤走来帮助 Decima。</li></ol><p><strong>State observations.</strong></p><p>(i) 阶段中剩余的任务数量，(ii) 平均任务持续时间，(iii) 当前在该节点上工作的执行者数量，(iv) 可用执行者数量，以及 (v) 可用执行者是否可用当地的工作。我们通过尝试包含捕获集群状态所需的信息来选择这些功能（例如，当前分配给每个阶段的执行者数量），以及可能有助于调度决策（例如，一个阶段的平均任务持续时间）。这些统计数据取决于可用信息（例如，同一作业过去执行的配置文件或运行时指标）和所使用的系统（此处为 Spark）。 Decima 可以很容易地合并额外的信号。</p><p><strong>Neural network architecture.</strong></p><p>图神经网络的六个转换函数 f (·) 和g(·) (§5.1)（节点级、作业级和全局嵌入各两个）和策略网络的两个评分函数 q(·) 和 w( ·) (§5.2) 是使用双隐藏层神经网络实现的，每层有 32 和 16 个隐藏单元。由于这些神经网络可重复用于所有作业和所有并行限制，因此 Decima 的模型是轻量级的——它总共包含 12,736 个参数 (50KB)。将集群状态映射到调度决策所需的时间不到 15 毫秒（图 15b）。</p><p><img src="http://cdn.leafii.top/img/image-20230117181739095.png" alt="image-20230117181739095" loading="lazy"></p><h4 id="Spark模拟"><a href="#Spark模拟" class="headerlink" title="Spark模拟"></a>Spark模拟</h4><p>为了忠实地模拟 Decima 的决策如何与集群交互，我们的模拟器捕获了几个真实世界的效果：</p><p>(1) 来自特定阶段的第一波任务通常比后续任务运行得慢。这是由于 Spark 的流水线任务执行 [63]、任务代码的 JIT 编译 [47] 和预热成本（例如，与其他执行程序建立 TCP 连接）。因此，Decima 的模拟环境从不同的分布中选择<strong>第一波</strong>任务的实际运行时间，而不是后来的波。 </p><p>(2) 为Spark作业添加执行器需要启动JVM进程，耗时2-3秒。 Executors 与工作相关联以进行隔离，因为 Spark 假定它们是长期存在的。因此，每次 Decima 跨作业移动执行程序时，Decima 的环境都会施加空闲时间以反映启动延迟。 </p><p>(3) 高度并行会减慢单个 Spark 任务，因为更广泛的混洗需要额外的 TCP 连接，并在合并来自许多分片的数据时创建更多工作。 Decima 的环境通过从不同并行级别收集的分布中抽样任务持续时间来捕获这些影响（如果此数据可用）</p><p>我们通过将其与真实的 Spark 执行进行比较来验证我们的模拟器的保真度。（结果当然是模拟器的保真度很高啦）</p><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>我们在真实的 Spark 集群测试台上和<strong>阿里巴巴的生产工作负载</strong>模拟中评估了 Decima。</p><p>我们的实验解决了以下问题：</p><p>(1) 与真实 Spark 集群中精心调整的启发式算法相比，Decima 的性能如何 (§7.2)？ </p><p>(2) Decima 的学习能否推广到具有不同机器配置的多资源设置（§7.3）？</p><p>(3) 我们的每一个关键想法如何为 Decima 的业绩做出贡献；当调度环境发生变化时，Decima 如何适应；以及 Decima 训练和训练后做出调度决策的速度有多快？</p><h4 id="现有的baseline算法"><a href="#现有的baseline算法" class="headerlink" title="现有的baseline算法"></a>现有的baseline算法</h4><p>(1) Spark 的默认 FIFO 调度，它按照作业到达的相同顺序运行作业，并根据用户请求为每个作业授予尽可能多的执行程序。 </p><p>(2) 最短作业优先的关键路径启发式 (SJF-CP)，它根据作业的总工作量确定作业的优先级，并在每个作业中运行其关键路径上下一阶段的任务。</p><p>(3) 简单的公平调度，它为每个作业提供平等公平的执行者份额，并轮询来自可运行阶段的任务，以同时耗尽所有分支。 </p><p>(4) 朴素加权公平调度，将执行者分配给与其总工作成比例的工作。 </p><p>(5) 一个精心调整的加权公平调度，给每个作业 Tα i &#x2F;Í iTα i 的总执行者数，其中 Ti 是每个作业 i 的总工作量，α 是一个调整因子。请注意，α &#x3D; 0 简化为简单公平方案，而 α &#x3D; 1 简化为朴素加权公平方案。我们遍历 α ∈ {−2,−1.9,…,2} 以获得最佳因子。 </p><p>(6) 来自俄罗斯方块 [34] 的标准多资源打包算法，它贪婪地调度最大化请求资源向量和可用资源向量的点积的阶段。 </p><p>(7) Graphene<em>，Graphene [36] 对 Decima 的离散执行器类的改编。 Graphene</em> 使用 Graphene 的算法 [36, §4.1] 检测和分组“有问题的”节点，并将它们与（5）中优化调整的并行性一起调度，实现 Graphene 规划策略的本质。我们执行网格搜索以优化超参数（附录 F 中的详细信息）。</p><h4 id="Spark-cluster"><a href="#Spark-cluster" class="headerlink" title="Spark cluster"></a>Spark cluster</h4><p>我们使用运行 Spark v2.2 的 OpenStack 集群，在 <strong>Chameleon Cloud 测试平台</strong>中按照 §6.1 中的描述进行了修改。该集群包括25 个工作虚拟机，每个虚拟机在 m1.xlarge 实例（8 个 CPU，16 GB RAM）上运行两个执行器，在 m1.xxxlarge 实例（16 个 CPU，32 GB RAM）上运行一个主虚拟机。我们的实验考虑 <strong>(i) 批量到达</strong>，其中多个作业同时开始并运行直到完成，以及 <strong>(ii) 连续到达</strong>，其中作业以随机到达间隔分布到达或遵循跟踪。</p><h5 id="批量到达"><a href="#批量到达" class="headerlink" title="批量到达"></a>批量到达</h5><p>最后，Decima 优于所有基线算法，并且比最接近的启发式算法（“优化加权公平”）将平均 JCT 提高了 21%。这是因为 Decima 更好地确定工作的优先级，将高效的执行者份额分配给不同的工作，并利用工作 DAG 结构（§7.4 分解了每个因素的好处）。 Decima 通过端到端 RL 训练自主学习此策略，而性能最佳的基线算法需要仔细调整。</p><p><img src="http://cdn.leafii.top/img/image-20230117184924463.png" alt="image-20230117184924463" loading="lazy"></p><h5 id="连续到达"><a href="#连续到达" class="headerlink" title="连续到达"></a>连续到达</h5><p>Decima 的性能提升来自于更快地完成小作业，Decima 通过为小型作业分配更多执行程序来实现这一点（图 10d）。每个作业的正确执行程序数量取决于工作负载：不加选择地为小型作业提供更多执行程序会低效地使用集群资源（§2.2）。Decima 的执行者分配产生的总工作量与手动调整启发式相似。图 10e 显示了这一点：在对角线以下的作业使用 Decima 的总工作量小于启发式，而在对角线以上的工作在 Decima 中的总工作量更大。大多数小型作业都在对角线上，这表明 Decima 仅在额外的执行程序仍然有效时才增加并行度限制。因此，Decima 成功地在为小型作业提供额外资源以更快完成它们和有效利用资源之间取得平衡。</p><p><img src="http://cdn.leafii.top/img/image-20230117184610020.png" alt="image-20230117184610020" loading="lazy"></p><h4 id="多维资源打包"><a href="#多维资源打包" class="headerlink" title="多维资源打包"></a>多维资源打包</h4><p>我们之前实验中使用的独立 Spark 调度程序只为作业提供对预定义执行程序槽的访问权限。更高级的集群调度器，例如 YARN [75] 或 Mesos [41]，允许作业指定其任务的资源需求并创建适当大小的执行器。将具有多维资源需求（例如，⟨CPU、内存⟩）的任务打包到固定容量的服务器上，进一步增加了调度问题的复杂性 [34、36]。我们使用来自阿里巴巴的生产跟踪来调查 Decima 是否可以使用相同的核心方法学习良好的多维调度策略。</p><h5 id="Industrial-trace"><a href="#Industrial-trace" class="headerlink" title="Industrial trace."></a>Industrial trace.</h5><p>跟踪包含来自生产集群的大约 20,000 个作业。我们使用轨迹的前半部分进行训练，然后将 Decima 的性能与其余部分的其他方案进行比较。</p><h5 id="Multi-resource-environment"><a href="#Multi-resource-environment" class="headerlink" title="Multi-resource environment"></a>Multi-resource environment</h5><p>我们修改 Decima 的环境以提供几个具有不同内存大小的离散执行器类。我们的实验使用了四种类型的执行器，每一种都有 1 个 CPU 内核和 (0.25,0.5,0.75,1) 单位的标准化内存；每个执行器类别占集群执行器总数的 25%。</p><h5 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h5><p> Decima 的平均 JCT 比最佳竞争算法 (Graphene*) 低 32%，表明它在多资源环境中学习了良好的策略。</p><p><img src="http://cdn.leafii.top/img/image-20230117185433516.png" alt="image-20230117185433516" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/image-20230117185729841.png" alt="image-20230117185729841" loading="lazy"></p><h4 id="Decima深挖"><a href="#Decima深挖" class="headerlink" title="Decima深挖"></a>Decima深挖</h4><p>最后，我们展示了 Decima 可以学习的各种调度策略，并分解了我们的关键思想和技术对 Decima 性能的影响。</p><p>在附录中，我们通过详尽搜索工作顺序（附录 H）、学习策略对不断变化的环境的稳健性（附录 I）以及 Decima 对不完整信息的敏感性（附录 J）进一步评估 Decima 的最优性。</p><ul><li><p><strong>学习策略：</strong>Decima 优于其他算法，因为它可以根据高级目标、工作负载和环境条件学习不同的策略。</p></li><li><p><strong>学习架构的影响：</strong>图 14 显示，从 Decima 中删除任何一个组件会导致平均 JCT 比在高集群负载下调整的加权公平启发式更差。这个结果有四个要点。</p><ul><li>首先，并行度控制对 Decima 的性能影响最大。在没有并行控制的情况下，Decima 在每个调度事件中将所有可用的执行程序分配到一个阶段。即使在中等集群负载（例如 55%）下，这也会导致无法跟上传入作业到达率的不稳定策略。</li><li>其次，省略图形嵌入（即，直接将每个节点上的原始特征作为 §5.2 中评分函数的输入）使得 Decima 无法估计作业中的剩余工作并考虑集群中的其他作业。因此，Decima 没有小作业或集群负载的概念，并且随着负载的增加，其学习的策略很快变得不稳定。</li><li>第三，在训练集中使用不固定的工作序列会增加奖励信号的方差（§5.3）。</li><li>第四，仅针对批量工作到达的培训不能推广到连续工作到达。在对分批到达进行训练时，Decima 学会了系统地推迟大型作业，因为这会导致 JCT 总和最低（惩罚总和最低）。</li></ul></li><li><p><strong>推广到不同的工作负载：</strong>我们通过改变 TPC-H 实验（§7.2）中的训练工作量来测试 Decima 的泛化能力。最终结果显著表明，多样化的训练工作负载集有助于使 Decima 的学习策略对工作负载变化具有鲁棒性；我们在§8 中讨论了可能的在线学习。</p></li><li><p><strong>训练和推理性能：</strong></p><ul><li>图 15a 显示了 Decima 在连续 TPC-H 作业到达 (§7.2) 上的学习曲线（蓝色），每 100 次迭代（看不见的）作业到达序列测试模型的快照。每次训练迭代大约需要 5 秒。 Decima 的设计（§5.3）对于训练效率至关重要：省略输入中的并行度限制值（黄色曲线）迫使 Decima 对不同的限制使用单独的评分函数，显着增加要优化的参数数量；对节点（绿色曲线）进行细粒度并行控制会减慢训练速度，因为它增加了 Decima 必须探索的算法空间。</li><li>图 15b 显示了 Decima 在我们的 Spark 测试平台 (§7.2) 中决定调度操作（红色）和调度事件之间的时间间隔（蓝色）所花费的时间的累积分布。 Decima 的平均调度延迟小于 15 毫秒，而调度事件之间的间隔通常在秒级。在不到 5% 的情况下，调度间隔比调度延迟短（例如，当集群在单个调度事件中请求多个调度操作时）。因此，Decima 的调度延迟不会对任务运行时造成可测量的开销。<img src="http://cdn.leafii.top/img/image-20230117193600319.png" alt="image-20230117193600319" loading="lazy"></li></ul></li></ul><h3 id="Decima的讨论"><a href="#Decima的讨论" class="headerlink" title="Decima的讨论"></a>Decima的讨论</h3><p>在本节中，我们将讨论 Decima 技术的未来研究方向和其他潜在应用。</p><ul><li>稳健性和泛化性。</li><li>其他学习目标</li><li>抢占式调度</li><li>潜在的网络和系统应用程序。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Decima 证明了使用强化学习自动学习复杂的集群调度策略是可行的，并且学习到的策略灵活高效。 Decima 的学习创新，例如其图形嵌入技术和流式处理训练框架，可能适用于处理 DAG 的其他系统（例如，查询优化器）。我们将在 <a href="https://web.mit.edu/decima">https://web.mit.edu/decima</a> 上开源 Decima、我们的模型和我们的实验基础设施。这项工作不会引发任何伦理问题。</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>Chameleon Cloud 测试平台.</p><p>阿里巴巴的生产工作负载（感谢来自阿里云智能的 Haiyang Ding 和 Yihui Feng 分享生产集群数据集。）</p><p>我们使用了阿里巴巴早期版本的public cluster-trace-v2018 trace[6,52]</p><blockquote><p>[6]Cluster data collected from production clusters in Alibaba for cluster management research(<a href="https://github.com/alibaba/clusterdata">https://github.com/alibaba/clusterdata</a>.)</p><p>[52]Imbalance in the cloud: An analysis on alibaba cluster trace.</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://zhuanlan.zhihu.com/p/133427987">RL for Scheduling，如何用强化学习解决调度问题？ - 知乎 (zhihu.com)</a></p><p><a href="https://link.zhihu.com/?target=https://web.mit.edu/decima/">Decima (mit.edu)</a></p><p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1MW411w79n?spm_id_from=333.999.0.0">李宏毅深度强化学习(国语)课程(2018)_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:202.快乐数</title>
      <link href="/2023/01/09/leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>/2023/01/09/leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 19输出：true解释：12 + 92 &#x3D; 8282 + 22 &#x3D; 6862 + 82 &#x3D; 10012 + 02 + 02 &#x3D; 1</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：n &#x3D; 2输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>递归暴力求解（C++实现）</li></ol><p>首先确定递归判断的条件：<code>n==1</code>时返回true，当<code>n &lt; 10 &amp;&amp; n % 2 == 0</code>时返回false。</p><p>对输入数字<code>n</code>的每一位数的计算方法为<code>temp = n % 10</code>，取余的结果的平方与sum累加，同时<code>n = n / 10</code>，求得的sum递归传入判断函数中。代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isHappy(int n) &#123;        &#x2F;&#x2F;递归函数的终止条件        if(n &#x3D;&#x3D; 1)        &#123;            return true;        &#125;        if(n &lt; 10 &amp;&amp; n % 2 &#x3D;&#x3D; 0)        &#123;            return false;        &#125;        &#x2F;&#x2F;初始化变量，便于接下来的计算        int sum &#x3D; 0;        int temp &#x3D; 0;        &#x2F;&#x2F;在循环中求每一位的平方值并且加到sum中        while(n !&#x3D; 0)        &#123;            temp &#x3D; n % 10;            n &#x3D; n &#x2F; 10;            sum &#x3D; sum + temp * temp;        &#125;        &#x2F;&#x2F;返回递归函数的返回值        return isHappy(sum);    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:242.有效的字母异位词</title>
      <link href="/2023/01/08/leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>/2023/01/08/leetcode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p><span id="more"></span><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;输出: false</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>暴力解法，用C++实现</li></ol><p>主要思路：首先对两个字符串的长度进行比较，若不一致则返回false，接下来，因为字符串的字母共有26个，因此遍历统计字符串中每个字母的个数，并用一个大小为26的对应数组进行存储，最后遍历对比两个字符串对应的统计个数的数组是否一致，对比的结果即为最终结果，代码如下：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    bool isAnagram(string s, string t) &#123;        &#x2F;&#x2F;对每个字符串的字母个数统计数组的初始化        int arr_s[26] &#x3D; &#123;0&#125;;        int arr_t[26] &#x3D; &#123;0&#125;;        &#x2F;&#x2F;计算两个字符串的长度，如果长度不同，那么一定不是字母异位词        int len_s &#x3D; s.length();        int len_t &#x3D; t.length();        if(len_s !&#x3D; len_t)        &#123;            return false;        &#125;        &#x2F;&#x2F;在遍历中确定每个字母统计的下标，并且+1        for(int i &#x3D; 0; i &lt; len_s; i++)&#123;            int index_s &#x3D; (int)(s[i] - &#39;a&#39;);            int index_t &#x3D; (int)(t[i] - &#39;a&#39;);            arr_s[index_s] &#x3D; arr_s[index_s] + 1;            arr_t[index_t] &#x3D; arr_t[index_t] + 1;        &#125;        &#x2F;&#x2F;对比两个字符串的字母的种类和个数是否一致        for(int i &#x3D; 0; i &lt; 26; i++)&#123;            if(arr_s[i] !&#x3D; arr_t[i])                return false;        &#125;        &#x2F;&#x2F;最终返回结果        return true;    &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A_Bi-Level_Framework_for_Learning_to_Solve_Combinatorial_Optimization_on_Graph</title>
      <link href="/2022/11/05/A-Bi-Level-Framework-for-Learning-to-Solve-Combinatorial-Optimization-on-Graph/"/>
      <url>/2022/11/05/A-Bi-Level-Framework-for-Learning-to-Solve-Combinatorial-Optimization-on-Graph/</url>
      
        <content type="html"><![CDATA[<h1 id="一种双层优化方法"><a href="#一种双层优化方法" class="headerlink" title="一种双层优化方法"></a>一种双层优化方法</h1><ul><li><p>引言:</p><p>论文题目:A Bi-Level Framework for Learning to Solve Combinatorial Optimization on Graphs</p><p>论文对应代码: <a href="https://github.com/Thinklab-SJTU/PPO-BiHyb">https://github.com/Thinklab-SJTU/PPO-BiHyb</a>.</p></li></ul><span id="more"></span><h2 id="Abstract-x2F-Background"><a href="#Abstract-x2F-Background" class="headerlink" title="Abstract&#x2F;Background"></a>Abstract&#x2F;Background</h2><p>组合优化 (CO) 以其NP-hard性质为特征，一直是一个具有挑战性的研究课题。当前，用于组合优化的机器学习 (MLCO) 已成为热门研究主题，但是大多数现有的MLCO方法都通过直接学习端到端解决方案来将CO视为单层优化，由于CO的高度复杂性，很难扩大规模，并且主要受ML模型容量的限制。在本文中，我们提出了一种混合方法来结合两个世界的优点，其中使用上层学习方法开发了一个双层框架来优化图 (例如添加，删除或修改图中的边)，与优化图上的低级启发式算法进行融合求解。这种双层方法简化了对原始硬CO的学习，并可以有效地减轻对模型容量的需求。对几个流行的CO问题 (例如有向无环图调度，图编辑距离和哈密顿循环问题) 的实验和结果表明，它比手动设计的启发式方法和单层学习方法有效。</p><p>本文解决的问题在实际中的例子:</p><ol><li><p>例如计算任务的调度问题，在调度问题中需合理安排计算资源及数据中的CPU的核数指派到合适的任务，实现最大效率的完成，优化目标是最小化完成所有任务的时间；</p></li><li><p>图学习或机器学习中常用到的，图编辑距离，图学习中常用的图之间的距离度量，它通过衡量从图1到图2之间最短的编辑路径所对应的最小的编辑代价来衡量两张图的相似程度，也是一个NP-hard的优化问题，目标为最小化图上的编辑代价；或汉密尔顿回路问题以及著名的欧拉七桥问题等。</p></li></ol><p><img src="http://cdn.leafii.top/img/v2-19dedc188ceaa2e46cc66af55e8b8cc6_1440w.webp" alt="图1 Combinatorial Optimization Problems on Graphs" loading="lazy"></p><h2 id="当前的研究方法-Single-Level-Optimization"><a href="#当前的研究方法-Single-Level-Optimization" class="headerlink" title="当前的研究方法:Single-Level Optimization"></a>当前的研究方法:Single-Level Optimization</h2><h3 id="当前方法"><a href="#当前方法" class="headerlink" title="当前方法"></a>当前方法</h3><p>当前关于此类问题的研究方法都可被总结为Single-Level optimization的优化形式,如下式:寻找合适的x以最小化函数f.式中的x为决策变量,f(x)为目标函数,s.t.为约束条件.</p><p>$$\min _{\mathbf{x}} f(\mathbf{x} \mid \mathcal{G}) \quad s.t. \quad h_i(\mathbf{x}, \mathcal{G}) \leq 0, for\ i&#x3D;1 \ldots I$$</p><p>当前主流思路是直接使用强化学习对其进行端到端的学习,由于问题本身单独为NP-hard问题,因此大部分问题得不到最优解,无法进行端到端的训练.在RL框架下,决策变量会被一系列的决策替代,目标函数对应RL中的reward,约束条件通过限制RL的agent动作的范围来实现.</p><p>在使用强化学习直接处理规模较大的问题时,由于动作序列变长,导致动作空间增大,最终导致稀疏奖励(sparse reward),使得RL比较难以学到有用的信息,而且在默认的求解过程中,框架暗含的假设为:模型存在直接从G(graph)学习到x(solution)的能力–&gt;学习端到端的映射.这为模型的容量设计带来了挑战,也就意味着需要为特定的问题,特定的数据分布去设计不同的模型结构才能实现如此大的模型容量.为了解决上述问题,传统的解决方法(no-learning)通过修改问题本身的结构来辅助问题的求解.例如在求解整数规划问题时使用割平面法(cutting planes)为求解整数规划问题添加额外的约束,来辅助问题能够得到更好更快的解决.</p><h3 id="对当前研究方法的优化"><a href="#对当前研究方法的优化" class="headerlink" title="对当前研究方法的优化"></a>对当前研究方法的优化</h3><p>本文发现,在计算任务调度的过程中,通过修改原先数据有向无环图的结构,比如加两条边,同样一个算法能够在两种修改条件下获得不一样的结果.原来21s完成的任务现在16s就能完成.通过这个思路,可以实现对问题求解的优化.</p><p><img src="http://cdn.leafii.top/img/v2-7a91e3e2eff95e4b00d451531d46eb20_1440w.jpeg" alt="图2 Modify the graph structure to aid problem solving" loading="lazy"></p><h2 id="Our-Formulation-Bi-Level-Optimization"><a href="#Our-Formulation-Bi-Level-Optimization" class="headerlink" title="Our Formulation: Bi-Level Optimization"></a>Our Formulation: Bi-Level Optimization</h2><p>基于以上观察和思路，本文提出了一个双层优化（Bi-Level）方法，其核心引入一个新的变量称为优化过的图结构G’，基于G’给出双层优化的形式，如图3所示。图中上方红色框内表示上层优化部分（Upper-Level Optimization），蓝色框内表示下层优化部分（Lower-Level Optimization）。其中上层优化目标为G’，下层优化目标为一个决策变量与单层优化形式类似。可以发现目标函数及约束条件都是相对于G’。而对于上层优化，通过优化后的G’来实现对最终目标函数值在原先图中G目标函数值的优化。</p><p><img src="http://cdn.leafii.top/img/v2-e3124cd8a67c7b54d85e2f698e43ff65_1440w.webp" alt="图3 Bi-Level Optimization" loading="lazy"></p><p>基于上述框架，本文提出了一个强化学习-传统算法融合的方法如图4所示。针对输入的图结构，首先调用一个传统算法可以求出一个解，在此基础上，加入ReNet Attention GNN 组成的强化学习模型进行决策，该模型在图上预测图如何修改的概率，图中红色的深浅代表了不同的预测概率。</p><p>基于预测概率，进行决策，对图的结构进行修改。基于新的图结构，再次调用传统算法得到新的解，继续调用RL修改图结构，不断循环。图中蓝色为用来做决策的上层算法，通过PPO进行学习。下层黄色表示传统求解算法。蓝色G’表示上层优化需解决的问题，黄色X’表示下层优化需要处理的内容。由于采用强化学习进行学习，总目标函数会作为回馈函数来指导搜索与学习。</p><p><img src="http://cdn.leafii.top/img/v2-bd9fa312c45a18758b841ae450a4cbb8_1440w.webp" alt="图4 Bi-Level Optimization by Reinforcement Learning" loading="lazy"></p><p>该方法的伪代码如下:</p><p><img src="http://cdn.leafii.top/img/image-20221105194049785.png" alt="图5 伪代码" loading="lazy"></p><p>假设:图G的最优解X*可以通过修改G来获得.通过引入以下的主张去验证该假设的可行性:</p><p>Proposition.我们将从图g修改的所有图的集合定义为$\mathbb G$,并且$\mathbb X$是图g的所有可行解的集合.如果启发式算法是一个从$\mathbb G$到$\mathbb X$的超射(surjection),对图g和他的最优解x*,应该存在g*$\in \mathbb G$,使得x*成为求解g*的启发式算法的输出.</p><p>Proof.由超射的定义可知, 因为x* $\in X$,因此必须至少存在一个图G*$\in G$使得X*是通过求解g*的启发式算法的输出.</p><p>在进行完理论上的分析之后,本文基于假设内容原先图上的最优解x*可以通过不断修改图结构来得到.由于直接证明难度较大,因此添加一定限制条件, 如图6所示,但必须注意的是寻找最优的修改过的图这个问题本身也是一个NP-hard问题,本文通过理论上的分析证明优化图结构本身是可行的,同时可启发通过该方向开发性能更强更有用的算法.</p><p><img src="http://cdn.leafii.top/img/v2-e7bf0965896c544159ba0237e8e4f20d_1440w.jpeg" alt="图6 限制条件" loading="lazy"></p><p>在三个问题上使用该算法实现可以发现该框架的通用性,该方法在三个问题都维持了比较general的特性,如图7所示:</p><p><img src="http://cdn.leafii.top/img/v2-6c461ab6a5dee7ad8f73ea2df50ce713_1440w.webp" alt="图7 Implement on 3 Combinatorial Optimization Problems" loading="lazy"></p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>To be continued…</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在macOS上为自己的Latex安装LaTeX.sty文件</title>
      <link href="/2022/11/04/%E5%9C%A8macOS%E4%B8%8A%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84Latex%E5%AE%89%E8%A3%85LaTeX-sty%E6%96%87%E4%BB%B6/"/>
      <url>/2022/11/04/%E5%9C%A8macOS%E4%B8%8A%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84Latex%E5%AE%89%E8%A3%85LaTeX-sty%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>当latex编译报错提醒“xxxx.sty文件不存在”时,mac用户可参考此方法</p><span id="more"></span><p>解决方法:下载目标的sty文件,可以在类似与<a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/8015-m-code-latex-package">此链接</a>寻找</p><p>下载成功后,将解压后的sty文件复制到macOS的路径中,我的参考路径为:<code>/usr/local/texlive/2022/texmf-dist/tex/latex/base/</code>(复制时需要sudo)</p><p>复制后在终端中输入命令:<code>sudo -s texhash</code></p><p>此时再打开texmaker等对文件进行编译即可…</p><p>参考链接:<a href="https://qa.1r1g.com/sf/ask/97357991/">https://qa.1r1g.com/sf/ask/97357991/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAPPO源代码分析</title>
      <link href="/2022/09/30/MAPPO%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/09/30/MAPPO%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>代码地址：<a href="https://github.com/marlbenchmark/on-policy">https://github.com/marlbenchmark/on-policy</a></p><p>官方出品轻量化mappo代码：<a href="https://github.com/tinyzqh/light_mappo">https://github.com/tinyzqh/light_mappo</a></p><p>对应论文：The Surprising Effectiveness of MAPPO in Cooperative, Multi-Agent Games</p><span id="more"></span><h2 id="代码运行"><a href="#代码运行" class="headerlink" title="代码运行"></a>代码运行</h2><p>使用conda新建环境，python版本推荐为3.6.7，并且安装readme中的MPE环境，然后将pycharm中train_mpe.py文件的configuration中的参数设置为<code>--env_name &quot;MPE&quot; --algorithm_name &quot;rmappo&quot; --experiment_name &quot;check&quot; --scenario_name &quot;simple_spread&quot; --num_agents 3 --num_landmarks 3 --seed 1 --n_training_threads 1 --n_rollout_threads 4 --num_mini_batch 1 --episode_length 25 --num_env_steps 10000 --ppo_epoch 10 --use_ReLU --gain 0.01 --lr 7e-4 --critic_lr 7e-4 --wandb_name &quot;leafii&quot; --user_name &quot;leafii&quot;</code>，以免因为电脑配置不足无法运行。安装其他包时要参考文件夹中requirement.txt中的版本，以免由于版本兼容问题造成代码无法正常运行，debug。</p><h2 id="MAPPO算法伪代码"><a href="#MAPPO算法伪代码" class="headerlink" title="MAPPO算法伪代码"></a>MAPPO算法伪代码</h2><p><img src="http://cdn.leafii.top/img/mappo.png" alt="img" loading="lazy"></p><p>有两个网络，分别是策略$\pi_{\theta}$和值函数$V_{\phi}$。（作者在文中说如果智能体是同种类的就采用相同的网络参数，对于每个智能体内部也可以采用各自的actor和critic网络，为了符号的便利性，作者直接使用一个网络参数来表示）。值函数$V_{\phi}$需要学习一个映射： $S \rightarrow \mathbb R$。策略函数$\pi_{\theta}$学习一个映射从观测$o_t^{a}$到一个范围的分布或者是映射到一个高斯函数的动作均值和方差用于之后采样动作。</p><ul><li>Actor的优化目标为：</li></ul><p>$$L(\theta) &#x3D; [\frac{1}{B_n}\sum_{i&#x3D;1}^{B}\sum_{k-1}^{n}min(r_{\theta,i}^{(k)}A_{i}^{(k)},clip(r_{\theta,i}^{(k)},1-\epsilon,1+\epsilon)A_i^{(k)})]+\sigma \frac{1}{B_n}\sum_{i&#x3D;1}^{B}\sum_{k-1}^{n}S[\pi_{\theta}(o_i^{(k)})],where r_{\theta,i}^{(k)}&#x3D;\frac{\pi_{\theta}(a_i^{(k)}|o_i^{(k)})}{\pi_{\theta_{old}}(a_i^{(k)}|o_i^{(k)})}$$</p><p>其中优势函数$A_i^{(k)}$是采用GAE方法的，S表示策略的熵，$\sigma$是控制熵系数的一个超参数。</p><ul><li>Critic网络优化目标为：</li></ul><p>$$L(\phi)&#x3D;\frac{1}{B_n}\sum_{i&#x3D;1}^{B}\sum_{k&#x3D;1}^{n}(max[(V_\phi(s_i^{(k)})-\hat R_i)^2,(clip(V_\phi(s_i^{(k)}),V_{\phi_{old}}(s_i^{(k)}-\varepsilon),V_{\phi_{old}}(s_i^{(k)}+\varepsilon)-\hat R_i)^2]$$</p><p>其中$\hat R_i$是折扣奖励。B表示batch_size的大小，n表示智能体的数量。</p><h2 id="代码整体流程"><a href="#代码整体流程" class="headerlink" title="代码整体流程"></a>代码整体流程</h2><p>每个局部智能体接收一个局部的观察obs，输出一个动作概率，所有的actor智能体都采用一个actor网络。critic网络接收所有智能体的观测obs，<code>cent_obs_space = n * obs_space</code>，其中n为智能体的个数，输出一个V值，V值用于actor的更新。actor的loss和PPO的loss类似，有添加一个熵的loss。Critic的loss更多的是对value的值做normalizer，并且在计算episode的折扣奖励的时候不是单纯的算折扣奖励，有采用gae算折扣回报的方式。</p><ul><li><p>网络定义</p><p>代码定义在<code>onpolicy/algorithms/r_mappo/algorithm/rMAPPOPolicy.py</code></p><p>每一个智能体的观测obs_space为一个18维的向量，有3个智能体，cent_obs_space为一个54维的向量，单个智能体的动作空间act_space 为一个离散的5维的向量</p></li></ul><ol><li><p>actor</p><p>在<code>onpolicy/algorithms/utils/act.py</code>中，输入一个观测（18维），输出一个确切的动作actions和这个动作对数概率。</p></li></ol><pre class="language-python" data-language="python"><code class="language-python">action_dim <span class="token operator">=</span> action_space<span class="token punctuation">.</span>nself<span class="token punctuation">.</span>action_out <span class="token operator">=</span> Categorical<span class="token punctuation">(</span>inputs_dim<span class="token punctuation">,</span> action_dim<span class="token punctuation">,</span> use_orthogonal<span class="token punctuation">,</span> gain<span class="token punctuation">)</span>action_logits <span class="token operator">=</span> self<span class="token punctuation">.</span>action_out<span class="token punctuation">(</span>x<span class="token punctuation">,</span> available_actions<span class="token punctuation">)</span>actions <span class="token operator">=</span> action_logits<span class="token punctuation">.</span>mode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> deterministic <span class="token keyword">else</span> action_logits<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token punctuation">)</span> action_log_probs <span class="token operator">=</span> action_logits<span class="token punctuation">.</span>log_probs<span class="token punctuation">(</span>actions<span class="token punctuation">)</span></code></pre><ol start="2"><li><p>critic</p><p>critic输入维度为<code>cent_obs_space = n * obs_space = 54</code>，输出维度为1。</p></li></ol><pre class="language-python" data-language="python"><code class="language-python">critic_features <span class="token operator">=</span> self<span class="token punctuation">.</span>base<span class="token punctuation">(</span>cent_obs<span class="token punctuation">)</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>_use_naive_recurrent_policy <span class="token keyword">or</span> self<span class="token punctuation">.</span>_use_recurrent_policy<span class="token punctuation">:</span>        critic_features<span class="token punctuation">,</span> rnn_states <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>critic_features<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> masks<span class="token punctuation">)</span>values <span class="token operator">=</span> self<span class="token punctuation">.</span>v_out<span class="token punctuation">(</span>critic_features<span class="token punctuation">)</span></code></pre><h2 id="采样流程"><a href="#采样流程" class="headerlink" title="采样流程"></a>采样流程</h2><ul><li>初始化obs</li></ul><p>在on policy&#x2F;scripts&#x2F;train&#x2F;train_mpe.py的make_train_env(all_args)函数中实例化4个环境：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">return</span> SubprocVecEnv<span class="token punctuation">(</span><span class="token punctuation">[</span>get_env_fn<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>all_args<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>在onpolicy&#x2F;runner&#x2F;shared&#x2F;mpe_runner.py中的的warmup函数中，如果采用centralized_V值函数的训练方式（？？？），那么需要初始化的时候构造出多个智能体的share_obs：</p><pre class="language-python" data-language="python"><code class="language-python">obs <span class="token operator">=</span> self<span class="token punctuation">.</span>envs<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># shape = (4, 3, 18)</span>share_obs <span class="token operator">=</span> obs<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># shape = (4, 54)</span><span class="token comment"># 指定3个智能体</span>share_obs <span class="token operator">=</span> np<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>share_obs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_agents<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># shape = (4, 3, 54)</span></code></pre><p>在share_obs中会将n&#x3D;3个智能体的obs叠加在一起作为share_obs。</p><ul><li><code>collect()</code>采用<code>rollout</code>方式采样数据</li></ul><p>在onpolicy&#x2F;runner&#x2F;shared&#x2F;mpe_runner.py中的的collect函数中，调用<code>self.trainer.prep_rollout()</code>函数将actor和critic都设置为<code>eval()</code>格式,然后用<code>np.concatenate()</code>函数将并行的环境的数据拼接在一起，这一步是将并行采样的那个纬度降掉:</p><pre class="language-python" data-language="python"><code class="language-python">value<span class="token punctuation">,</span> action<span class="token punctuation">,</span> action_log_prob<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> rnn_states_critic \    <span class="token operator">=</span> self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>policy<span class="token punctuation">.</span>get_actions<span class="token punctuation">(</span>np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>share_obs<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>obs<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>rnn_states<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment"># ?</span>                            np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>rnn_states_critic<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>masks<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>将数据传入总的MAPPO策略网络R_MAPPOPolicy(onpolicy&#x2F;algorithms&#x2F;r_mappo&#x2F;algorithm&#x2F;rMAPPOPolicy.py)中去获取一个时间步的数据。在get_actions()里面调用actor去获取动作以及动作的对数概率，critic网络去获取对于cent_obs的状态值函数的输出：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 调用actor去获取动作和动作的对数概率                                      </span>actions<span class="token punctuation">,</span> action_log_probs<span class="token punctuation">,</span> rnn_states_actor <span class="token operator">=</span> self<span class="token punctuation">.</span>actor<span class="token punctuation">(</span>obs<span class="token punctuation">,</span>rnn_states_actor<span class="token punctuation">,</span> masks<span class="token punctuation">,</span> available_actions<span class="token punctuation">,</span> deterministic<span class="token punctuation">)</span></code></pre><p>在这里obs的shape是(4*3, 18),输出actions和action_log_probs的shape都为(12,1).</p><pre class="language-python" data-language="python"><code class="language-python">values<span class="token punctuation">,</span> rnn_states_critic <span class="token operator">=</span> self<span class="token punctuation">.</span>critic<span class="token punctuation">(</span>cent_obs<span class="token punctuation">,</span> rnn_states_critic<span class="token punctuation">,</span> masks<span class="token punctuation">)</span>   <span class="token comment"># 调用critic去对动作打分，得到values</span></code></pre><p>cent_obs’s shape is (5*2, 14),values’s shape is (12,1),and rnn_states’s shape is (12, 1, 64).</p><pre class="language-python" data-language="python"><code class="language-python">values <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 将value转化成4层3行1列的数据</span>actions <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 这action转化成4层3行1列的数据</span>action_log_probs <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>action_log_prob<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>rnn_states <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>rnn_states<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>rnn_states_critic <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>rnn_states_critic<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>actions_env <span class="token operator">=</span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span>self<span class="token punctuation">.</span>envs<span class="token punctuation">.</span>action_space<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">[</span>actions<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># 5维 (4, 3, 5)</span></code></pre><p>最后将(<code>12 , 1</code>)的<code>actions</code>转换成(<code>4, 3, 1</code>)的形式，方便之后并行送到并行的环境中去，作者这里还将动作进行了<code>one-hot</code>编码，最后变成了(<code>4, 3, 5</code>)的形式送入到环境中去。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># Obser reward and next obs</span>obs<span class="token punctuation">,</span> rewards<span class="token punctuation">,</span> dones<span class="token punctuation">,</span> infos <span class="token operator">=</span> self<span class="token punctuation">.</span>envs<span class="token punctuation">.</span>step<span class="token punctuation">(</span>actions_env<span class="token punctuation">)</span>data <span class="token operator">=</span> obs<span class="token punctuation">,</span> rewards<span class="token punctuation">,</span> dones<span class="token punctuation">,</span> infos<span class="token punctuation">,</span> values<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> action_log_probs<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> rnn_states_critic<span class="token comment"># insert data into buffer</span>self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre><p>环境下一次输出的<code>obs</code>还是(<code>4, 3, 18</code>)的形式，之后调<code>insert</code>方法将数据添加到<code>buffer</code>里面，在<code>insert</code>方法里面会将局部观测构造一个全局观测<code>share_obs</code>其shape&#x3D;(<code>4, 3, 54</code>)出来：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>    obs<span class="token punctuation">,</span> rewards<span class="token punctuation">,</span> dones<span class="token punctuation">,</span> infos<span class="token punctuation">,</span> values<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> action_log_probs<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> rnn_states_critic <span class="token operator">=</span> data    rnn_states<span class="token punctuation">[</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>recurrent_N<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    rnn_states_critic<span class="token punctuation">[</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>rnn_states_critic<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    masks <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_agents<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    masks<span class="token punctuation">[</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dones <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>use_centralized_V<span class="token punctuation">:</span>        share_obs <span class="token operator">=</span> obs<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        share_obs <span class="token operator">=</span> np<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>share_obs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_agents<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        share_obs <span class="token operator">=</span> obs    self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>insert<span class="token punctuation">(</span>share_obs<span class="token punctuation">,</span> obs<span class="token punctuation">,</span> rnn_states<span class="token punctuation">,</span> rnn_states_critic<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> action_log_probs<span class="token punctuation">,</span> values<span class="token punctuation">,</span> rewards<span class="token punctuation">,</span> masks<span class="token punctuation">)</span></code></pre><p>上述过程循环迭代<code>self.episode_length=100</code>次。</p><h2 id="训练流程"><a href="#训练流程" class="headerlink" title="训练流程"></a>训练流程</h2><ul><li>计算优势函数</li></ul><p>在训练之前，首先调用<code>self.compute()</code>函数计算<code>episode</code>的折扣回报，在计算折扣回报之前，先算这个<code>episode</code>最后一个状态的状态值函数<code>next_values</code>，其<code>shape=(12, 1)</code>然后调用<code>compute_returns</code>函数计算折扣回报:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 计算这个episode的折扣回报，先用rMAPPOPolicy.py里面的get_values计算一下next_values</span>    <span class="token triple-quoted-string string">"""Calculate returns for the collected data."""</span>    self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>prep_rollout<span class="token punctuation">(</span><span class="token punctuation">)</span>    next_values <span class="token operator">=</span> self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>policy<span class="token punctuation">.</span>get_values<span class="token punctuation">(</span>np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>share_obs<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                             np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>rnn_states_critic<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                             np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>masks<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    next_values <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>_t2n<span class="token punctuation">(</span>next_values<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n_rollout_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>compute_returns<span class="token punctuation">(</span>next_values<span class="token punctuation">,</span> self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>value_normalizer<span class="token punctuation">)</span>  <span class="token comment"># 折扣回报的的计算方式</span></code></pre><p>有了数据之后就可以开始计算<strong>折扣回报</strong>了（在这里有采用<code>gae</code>算折扣回报的方式，并且有将<code>value</code>做<code>normalizer</code>）。<code>compute_returns</code>函数在<code>onpolicy/utils/shared_buffer.py</code> 中，核心代码如下：</p><pre class="language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> next_valuegae <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> step <span class="token keyword">in</span> <span class="token builtin">reversed</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>rewards<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> self<span class="token punctuation">.</span>_use_popart <span class="token keyword">or</span> self<span class="token punctuation">.</span>_use_valuenorm<span class="token punctuation">:</span>    delta <span class="token operator">=</span> self<span class="token punctuation">.</span>rewards<span class="token punctuation">[</span>step<span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> value_normalizer<span class="token punctuation">.</span>denormalize<span class="token punctuation">(</span>      self<span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span>step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>masks<span class="token punctuation">[</span>step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> \     <span class="token operator">-</span> value_normalizer<span class="token punctuation">.</span>denormalize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span>    gae <span class="token operator">=</span> delta <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> self<span class="token punctuation">.</span>gae_lambda <span class="token operator">*</span> self<span class="token punctuation">.</span>masks<span class="token punctuation">[</span>step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> gae    self<span class="token punctuation">.</span>returns<span class="token punctuation">[</span>step<span class="token punctuation">]</span> <span class="token operator">=</span> gae <span class="token operator">+</span> value_normalizer<span class="token punctuation">.</span>denormalize<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>算完折扣回报后调用<code>self.train()</code>函数进行训练:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 算完折扣回报之后调用self.train()函数进行训练</span>  <span class="token triple-quoted-string string">"""Train policies with data in buffer. """</span>  self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>prep_training<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 将网络设置为train（）的格式</span>  train_infos <span class="token operator">=</span> self<span class="token punctuation">.</span>trainer<span class="token punctuation">.</span>train<span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>after_update<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 将buffer的第一个元素设置为其episode最后的一个元素</span>  <span class="token keyword">return</span> train_infos</code></pre><p>在<code>self.trainer.train(self.buffer)</code>函数中先基于数据，计算优势函数(优势函数是针对全局的观测信息所得到的)：</p><pre class="language-python" data-language="python"><code class="language-python">advantages <span class="token operator">=</span> <span class="token builtin">buffer</span><span class="token punctuation">.</span>returns<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>value_normalizer<span class="token punctuation">.</span>denormalize<span class="token punctuation">(</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>value_preds<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>advantages_copy <span class="token operator">=</span> advantages<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>advantages_copy<span class="token punctuation">[</span><span class="token builtin">buffer</span><span class="token punctuation">.</span>active_masks<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0.0</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>nanmean_advantages <span class="token operator">=</span> np<span class="token punctuation">.</span>nanmean<span class="token punctuation">(</span>advantages_copy<span class="token punctuation">)</span> <span class="token comment"># float, shape = (1)</span>std_advantages <span class="token operator">=</span> np<span class="token punctuation">.</span>nanstd<span class="token punctuation">(</span>advantages_copy<span class="token punctuation">)</span>  <span class="token comment"># float, shape = (1)</span>advantages <span class="token operator">=</span> <span class="token punctuation">(</span>advantages <span class="token operator">-</span> mean_advantages<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>std_advantages <span class="token operator">+</span> <span class="token number">1e-5</span><span class="token punctuation">)</span></code></pre><p>然后从<code>buffer</code>中采样数据，把线程、智能体的纬度全部降掉</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 从 data_generator 中采样</span><span class="token keyword">for</span> sample <span class="token keyword">in</span> data_generator<span class="token punctuation">:</span>  <span class="token comment"># 进行一次 PPO 更新</span>  value_loss<span class="token punctuation">,</span> critic_grad_norm<span class="token punctuation">,</span> policy_loss<span class="token punctuation">,</span> dist_entropy<span class="token punctuation">,</span> actor_grad_norm<span class="token punctuation">,</span> imp_weights \                        <span class="token operator">=</span> self<span class="token punctuation">.</span>ppo_update<span class="token punctuation">(</span>sample<span class="token punctuation">,</span> update_actor<span class="token punctuation">)</span></code></pre><p><code>ppo_update</code>函数大体流程是:</p><ol><li>从buffer中抽样建立sample</li><li>将抽样的数据传递给rMAPPOPolicy.py中的evaluate_actions函数，得到 values, action_log_probs, dist_entropy</li><li>计算actor的loss</li><li>计算critic的loss</li></ol><p>然后在<code>onpolicy/algorithms/r_mappo/r_mappo.py</code>中</p><pre class="language-python" data-language="python"><code class="language-python">share_obs_batch<span class="token punctuation">,</span> obs_batch<span class="token punctuation">,</span> rnn_states_batch<span class="token punctuation">,</span> rnn_states_critic_batch<span class="token punctuation">,</span> actions_batch<span class="token punctuation">,</span>\         value_preds_batch<span class="token punctuation">,</span> return_batch<span class="token punctuation">,</span>masks_batch<span class="token punctuation">,</span>active_masks_batch<span class="token punctuation">,</span>old_action_log_probs_batch<span class="token punctuation">,</span> \        adv_targ<span class="token punctuation">,</span> available_actions_batch <span class="token operator">=</span> sample</code></pre><p>拿到采样之后的数据，把<code>obs</code>送给<code>actor</code>网络，得到<code>action_log_probs</code>, <code>dist_entropy</code>。把<code>cent_obs</code>送到<code>critic</code>得到新的<code>values</code>。</p><ul><li>计算actor的loss</li></ul><p>在<code>ppo_update()</code>中，利用新老动作的概率分布和优势函数之后就可以更新<code>actor</code>网络了：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># actor update</span>imp_weights <span class="token operator">=</span> torch<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>action_log_probs <span class="token operator">-</span> old_action_log_probs_batch<span class="token punctuation">)</span>surr1 <span class="token operator">=</span> imp_weights <span class="token operator">*</span> adv_targsurr2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>clamp<span class="token punctuation">(</span>imp_weights<span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>clip_param<span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>clip_param<span class="token punctuation">)</span> <span class="token operator">*</span> adv_targpolicy_action_loss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span>torch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>surr1<span class="token punctuation">,</span> surr2<span class="token punctuation">)</span><span class="token punctuation">,</span>                                             dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>                                             keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token operator">*</span> active_masks_batch<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> active_masks_batch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>policy_loss <span class="token operator">-</span> dist_entropy <span class="token operator">*</span> self<span class="token punctuation">.</span>entropy_coef<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>计算critic的loss</li></ul><p>新的<code>value</code>和老的<code>value_preds_batch</code>和计算的<code>return_batch</code>送到<code>onpolicy/algorithms/r_mappo/r_mappo.py</code>文件的<code>cal_value_loss</code>函数中去计算<code>critic</code>的<code>loss</code>：</p><pre class="language-python" data-language="python"><code class="language-python">value_loss <span class="token operator">=</span> self<span class="token punctuation">.</span>cal_value_loss<span class="token punctuation">(</span>values<span class="token punctuation">,</span> value_preds_batch<span class="token punctuation">,</span> return_batch<span class="token punctuation">,</span> active_masks_batch<span class="token punctuation">)</span></code></pre><p>and then</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 对value做一个clipped</span>value_pred_clipped <span class="token operator">=</span> value_preds_batch <span class="token operator">+</span> <span class="token punctuation">(</span>values <span class="token operator">-</span> value_preds_batch<span class="token punctuation">)</span><span class="token punctuation">.</span>clamp<span class="token punctuation">(</span><span class="token operator">-</span>self<span class="token punctuation">.</span>clip_param<span class="token punctuation">,</span> self<span class="token punctuation">.</span>clip_param<span class="token punctuation">)</span><span class="token comment"># 然后计算误差的clip</span>error_clipped <span class="token operator">=</span> return_batch <span class="token operator">-</span> value_pred_clippederror_original <span class="token operator">=</span> return_batch <span class="token operator">-</span> values<span class="token comment"># 然后直接计算loss</span>value_loss_clipped <span class="token operator">=</span> mse_loss<span class="token punctuation">(</span>error_clipped<span class="token punctuation">)</span>value_loss_original <span class="token operator">=</span> mse_loss<span class="token punctuation">(</span>error_original<span class="token punctuation">)</span><span class="token comment"># 算出loss之后反向传播即可</span><span class="token punctuation">(</span>value_loss <span class="token operator">*</span> self<span class="token punctuation">.</span>value_loss_coef<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><p>以下实验来源于Policy Regularization via Noisy Advantage Values for<br>Cooperative Multi-agent Actor-Critic methods(arXiv:2106.14334v13 )</p><h3 id="算法表现对比"><a href="#算法表现对比" class="headerlink" title="算法表现对比"></a>算法表现对比</h3><p>首先展示了论文介绍的算法以及其对比算法在SMAC各种场景下的胜率,将自己算法效果好于或者等于其他算法的效果的场景下的胜率进行加粗展示:</p><p><img src="http://cdn.leafii.top/img/image-20221031140635091.png" alt="image-20221031140635091" loading="lazy"></p><p>论文对该表的解释:</p><blockquote><p>表 2 中的实验结果表明 (1) NV-MAPPO 在大多数困难场景 2 上的性能显着超过 MAPPO，例如 5m_vs_6m (+65%)、走廊 (+97%)、6h_vs_8z (+87%) 和 3s5z_vs_3s6z (+31%)。 （2）NV-IPPO在Super Hard场景3s5z_vs_3s6z（96%）和6h_vs_8z（94%）中取得了超高的胜率；我们推测这是因为噪声还可以防止 IPPO 由于非平稳性而过拟合。 (3) NV-MAPPO 在硬场景上的平均性能优于 Fine-tuned QMIX 和 MAPPO-FP。 (4) 我们在附录 B.1 中比较了 MAPG 和 NV-MAPG，发现 NV-MAPG 的性能也明显优于 MAPG。</p><p>所有这些结果表明，噪声值函数在实际任务中效果很好。由于我们使用 Fine-tuned QMIX [5] 作为基线，QMIX 的中位测试获胜率明显优于过去文献中的实验结果 [14, 19, 20, 26]。至此，NV-MAPPO 和 NV-IPPO 在 SMAC 中共同实现了 SOTA。具体来说，NV-IPPO（适用于 3s5z_vs_3s6z 和 6h_vs_8z）和 NVMAPPO（适用于其他硬场景）在所有硬场景中的平均胜率为 97%。</p></blockquote><h3 id="NA-MAPPO和NV-MAPPO的对比"><a href="#NA-MAPPO和NV-MAPPO的对比" class="headerlink" title="NA-MAPPO和NV-MAPPO的对比"></a>NA-MAPPO和NV-MAPPO的对比</h3><p>接着又对NA-MAPPO和NV-MAPPO进行了对比,并对NA-MAPPO算法胜率的较大方差进行了解释,算法胜率的方差可以显示出算法的稳定性.</p><p><img src="http://cdn.leafii.top/img/image-20221031141622734.png" alt="image-20221031141622734" loading="lazy"></p><blockquote><p>如图4所示，我们发现噪声优势方法在某些情况下可能会损害算法的稳定性，即噪声优势方法的胜率有很大的方差。我们推测，可能是显性噪声破坏了政策梯度的原有方向。 但是，在smac的某些困难情况下，NA-MAPPO的性能仍可与NV-MAPPO媲美; 我们注意到NA-MAPPO非常容易实现。所有这些结果表明，噪声优势值确实改善了vanilla MAPPO的性能。</p></blockquote><p>然后对NV-MAPPO的噪声值函数如何影响性能进行进一步的实验分析:</p><p><img src="http://cdn.leafii.top/img/image-20221031141816194.png" alt="image-20221031141816194" loading="lazy"></p><blockquote><p>接下来，我们对NV-MAPPO的噪声值函数如何影响性能进行进一步的实验分析。我们在图 5 中展示了一些 Hard 场景下代理维度中值函数𝑣𝑖的标准差。我们发现，<strong>在某些场景中，𝑣𝑖 的大方差意味着 NV-MAPPO 在这些场景中相对于 vanilla MAPPO 的性能提升也很大</strong>，如3s5z_vs_3s6z和6h_vs_8z（见图5和图4）。该定律表明，NV-MAPPO 的性能提升确实来自价值函数的噪声扰动。</p></blockquote><p>最后分析了噪声值函数在3𝑠5𝑧_𝑣𝑠_3𝑠6𝑧场景下对策略熵的影响</p><p><img src="http://cdn.leafii.top/img/image-20221031142025436.png" alt="image-20221031142025436" loading="lazy"></p><blockquote><p>最后分析了噪声值函数对方案3 𝑠 5 𝑧 _ 𝑣𝑠 _ 3 𝑠 6 𝑧 策略熵的影响。如图6所示，vanilla MAPPO策略的熵迅速下降，并落入局部最优解，因此胜率始终为零。对于NV-MAPPO，我们平滑了采样的优势值，并且噪声可以防止策略过拟合，因此策略的熵会更加谨慎地降低。</p></blockquote><h3 id="策略熵和好奇心探索的异同"><a href="#策略熵和好奇心探索的异同" class="headerlink" title="策略熵和好奇心探索的异同"></a>策略熵和好奇心探索的异同</h3><p>policy entropy，从动作空间的角度出发，尽可能探索各种不同的动作，使得策略熵最大化，隐含着各种状态空间也会被探索到。policy entropy依据action的Q值来分配探索的概率，而不是$\epsilon-greedy$中固定概率$\epsilon&#x2F;|A|$探索较低Q值的action.另外policy entropy不简单是一个正则项,有另一个完整的RL框架来描述它,参见<a href="https://zhuanlan.zhihu.com/p/57210858">此链接</a></p><p>curiosity，从状态空间的角度出发，尽可能探索环境的状态转移方式，并把未知的状态转移方式作为内部rewards，以期改变agent的行为。参考<a href="https://zhuanlan.zhihu.com/p/58923482">此链接</a></p><p>应用上，policy entropy适合连续动作空间，如操作机械臂等，得到的策略更鲁棒；curiosity适合sparse rewards的问题，如走迷宫，它能为训练提供更丰富的学习信号。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>多智能体强化学习(二) MAPPO算法详解 <a href="https://blog.csdn.net/weixin_39059031/article/details/117283800">https://blog.csdn.net/weixin_39059031/article/details/117283800</a></li><li>多智能体强化学习MAPPO源代码解读 <a href="https://blog.csdn.net/onlyyyyyyee/article/details/118888711">https://blog.csdn.net/onlyyyyyyee/article/details/118888711</a></li><li>如何理解强化学习中的”好奇心探索”和”策略熵”的异同？ - bigiceberg M的回答 - 知乎 <a href="https://www.zhihu.com/question/311267842/answer/631757642">https://www.zhihu.com/question/311267842/answer/631757642</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习_PPO算法(Proximal Policy Optimization)</title>
      <link href="/2022/09/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0_PPO%E7%AE%97%E6%B3%95(Proximal%20Policy%20Optimization)/"/>
      <url>/2022/09/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0_PPO%E7%AE%97%E6%B3%95(Proximal%20Policy%20Optimization)/</url>
      
        <content type="html"><![CDATA[<p>本文介绍强化学习中的PPO(Proximal Policy Optimization)算法。</p><span id="more"></span><p>PPO(Proximal Policy Optimization)是OpenAI使用的默认RL方法，PPO方法可以被理解为</p><p><code>Policy Gradient -&gt; (On Policy -&gt; Off Policy) -&gt; (Add Constraint) -&gt; PPO(Proximal Policy Optimization)</code></p><h2 id="RL相关要素"><a href="#RL相关要素" class="headerlink" title="RL相关要素"></a>RL相关要素</h2><p>强化学习是指智能体在给定环境中进行动作的选择，在动作选择并执行之后同环境交互获得新的状态，每一对State（状态）和Action（动作）可以得到相应的Reward（奖励），强化学习的目标就是最大化Reward。</p><p>状态，动作更替可以用Trajectory（迹）来表示：</p><p>$$Trajectory\ \tau &#x3D; {s_1,a_1,s_2,a_2,…,s_T,a_T}\tag{1}$$</p><p>每一条Trajectory的概率为:</p><p>$$p_\theta(\tau) &#x3D;p(s_1)p_\theta(a_1|s_1)p(s_2|s_1,a_1)p_\theta(a_2|s_2)p(s_3|s_2,a_2)…&#x3D;p(s_1)\prod_{t&#x3D;1}^{T}p_\theta(a_t|s_t)p(s_{t+1}|s_t,a_t)\tag{2}$$</p><p>在这个式子中我们可以看到，$p_\theta(a_t|s_t)$是Actor得出的，这个是我们可以控制的，但是$p(s_{t+1}|s_t,a_t)$是动作$a_t$在状态$s_t$下与环境交互转移到状态$s_{t+1}$的概率，这是由环境本身决定的，我们自己无法控制它。</p><p>在强化学习中一条Trajectory的Expected Reward为：</p><p>$$\overline R_\theta &#x3D; \sum_{\tau}R(\tau)p_\theta(\tau)&#x3D;E_{\tau\sim p_\theta(\tau)}[R(\tau)]\tag{3})$$</p><p>其中的$R(\tau)$为：</p><p>$$R(\tau) &#x3D; \sum_{t&#x3D;1}^{T} r_t\tag{4}$$</p><h2 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h2><p>想要最大化Reward，在上一节我们又获得了$\overline R_\theta$的公式，此时我们对$\overline R_\theta$求梯度:</p><p>$$\nabla \overline R_\theta &#x3D; \sum_{\tau}R(\tau)\nabla p_\theta(\tau)&#x3D;\sum_{\tau}R(\tau)p_\theta(\tau)\frac{\nabla p_\theta(\tau)}{p_\theta(\tau)}\tag{5}$$</p><p>在上式中，$R(\tau)$不一定是需要可微的，它甚至可以是一个黑盒。</p><p>$$\nabla f(x) &#x3D; f(x)\nabla logf(x)\tag{6}$$</p><p>接着将梯度公式(6)代入(5)中，得：</p><p>$$\nabla \overline R_\theta &#x3D; \sum_{\tau}R(\tau)p_\theta(\tau)\nabla logp_\theta(\tau)&#x3D; E_{\tau \sim p_\theta(\tau)}[R(\tau)\nabla logp_\theta(\tau)] \approx \frac{1}{N}\sum_{n&#x3D;1}^{N}R(\tau^n)\nabla logp_\theta(\tau^n)$$</p><p>$$&#x3D; \frac{1}{N}\sum_{n&#x3D;1}^{N}\sum_{t&#x3D;1}^{T_n}R(\tau^n)\nabla logp_\theta(a_t^n|s_t^n)\tag{7}$$</p><p>在式子(7)中，由于$\sum_{\tau}$和$p_{\theta}(\tau)$的存在，因此将它们写成期望$E_{\tau \sim p_\theta(\tau)}$的形式。$p_{\theta}(\tau)$相当于$\nabla logp_\theta(\tau)$的一个weight（权重）。并且在$p_\theta(\tau)$中，$\tau$相当于有两项，一项是来自环境本身（无法求梯度），另一项来自智能体Agent，因此将$\nabla logp_\theta(\tau)$更进一步写作$logp_\theta(a_t^n|s_t^n)$</p><p>因此的Policy Gradient的基本过程可以这样描述：在环境中取得数据，在给定的策略$\pi_\theta$下，获得不同的Trajectory，每个Trajectory拥有不同的状态，动作以及对应的奖励值，收集状态动作对之后，将其带入式(7)中，进行参数$\theta$的更新：$\theta \leftarrow \theta + \eta\nabla \overline R_\theta$,在更新之后对新的环境重新获取数据，循环往复，我们可以看到在这个流程中，在环境中取得的数据仅被使用了一次，因此Policy Gradient是一个严格的On-Policy算法。</p><h3 id="Tip-1-Add-a-Baseline"><a href="#Tip-1-Add-a-Baseline" class="headerlink" title="Tip 1: Add a Baseline"></a>Tip 1: Add a Baseline</h3><p>在某些情况下，$\theta \leftarrow \theta + \eta\nabla \overline R_\theta$中的$R(\tau^n)$始终为正，如果采样数量足够多，即使是奖励都为正的动作，我们也可以按照奖励值的大小决定每个动作的优劣，并以此修改下个动作被选中的概率（好的动作增加被选中的概率，差的动作降低被选中的概率），但是在训练的环境下，总会有一些奖励为正的动作无法被采样，但是其他动作的奖励都为正，它们被选中的概率增加好，这就导致未被采样的动作的概率降低，哪怕未被采样的动作实质上优于一部分甚至全部被采样的动作。因此可以将式(7)进行如下修改：</p><p>$$\nabla \overline R_\theta &#x3D; \frac{1}{N}\sum_{n&#x3D;1}^{N}\sum_{t&#x3D;1}^{T_n}(R(\tau^n)-b)\nabla logp_\theta(a_t^n|s_t^n)\tag{8}$$</p><p>在这里的b就是新增的baseline，通常$b \approx E[R(\tau)]$，这样就可以有效的降低未被采样的动作被“误杀”。</p><h3 id="Tip-2-Assign-Suitable-Credit"><a href="#Tip-2-Assign-Suitable-Credit" class="headerlink" title="Tip 2: Assign Suitable Credit"></a>Tip 2: Assign Suitable Credit</h3><p>在一条Trajectory中，每个动作如果只由总的R来反映权重是不合适的，比如在$(s_a,a_1),(s_b,a_2),(s_c,a_3)$中的单步奖励值分别为+5，+0，-2，R&#x3D;5-2&#x3D;+3 但是对于a2，a3这种并未对Reward结果最大化做出正向贡献的action反而也被赋予了值为+3的Reward作为权重，这是不合理的。我们应该让每一个action前的R值都正确的反映它在当前Trajectory中的作用，到底是好还是坏。我们可以把式(8)中的$R(\tau^n)$改写为$\sum_{t’&#x3D;t}^{T_n}r_{t’}^{n}$:</p><p>$$\nabla \overline R_\theta \approx \frac{1}{N}\sum_{n&#x3D;1}^{N}\sum_{t&#x3D;1}^{T_n}(\sum_{t’&#x3D;t}^{T_n}r_{t’}^{n}-b)\nabla p_\theta(a_t^n|s_t^n)\tag{9}$$</p><p>$\sum_{t’&#x3D;t}^{T_n}r_{t’}^{n}$又可以进一步写为$\sum_{t’&#x3D;t}^{T_n}\gamma^{t’-t} r_{t’}^{n}$，其中$\gamma$作为discount factor(折扣因子)并且$\gamma &lt; 1$，因此可以得到：</p><p>$$\nabla \overline R_\theta \approx \frac{1}{N}\sum_{n&#x3D;1}^{N}\sum_{t&#x3D;1}^{T_n}(\sum_{t’&#x3D;t}^{T_n}\gamma^{t’-t} r_{t’}^{n}-b)\nabla p_\theta(a_t^n|s_t^n)\tag{10}$$</p><h2 id="On-policy-v-s-Off-policy"><a href="#On-policy-v-s-Off-policy" class="headerlink" title="On-policy v.s. Off-policy"></a>On-policy v.s. Off-policy</h2><ul><li>On-policy：agent学习与交互的环境是相同的。<strong>On-Policy可以翻译为”同策略”</strong></li><li>Off-policy：agent学习的环境和交互的环境并不相同。<strong>Off-Policy可以翻译为”异策略”</strong></li></ul><h3 id="从On-policy转向Off-policy的分析"><a href="#从On-policy转向Off-policy的分析" class="headerlink" title="从On- policy转向Off-policy的分析"></a>从On- policy转向Off-policy的分析</h3><p>On-policy的情况下，Policy Gradient的公式为:</p><p>$$\nabla \overline R_\theta &#x3D; E_{\tau \sim p_\theta(\tau)}[R(\tau)\nabla logp_\theta(\tau)]\tag{11}$$</p><p>在On-policy中，我们使用$\pi_{\theta}$去收集数据，当$\theta$被更新的时候，我们必须去重新采样训练数据。</p><p>我们现在的目标是：使用$\pi_{\theta’}$采样获得数据去训练$\theta$。$\theta’$是一个固定的值，因此我们可以重复利用采样的数据。</p><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><p>如果正常从p中进行采样获得x的期望值：</p><p>$$E_{x\sim p}[f(x)] \approx \frac{1}{N}\sum_{i&#x3D;1}^{N}f(x^i)\tag{12}$$</p><p>但是现在我们不从p中采样，只能从q中采样呢？</p><p>$$E_{x\sim p}[f(x)] \approx \frac{1}{N}\sum_{i&#x3D;1}^{N}f(x^i)&#x3D;\int f(x)p(x)dx&#x3D; \int f(x) \frac{p(x)}{q(x)}q(x)dx&#x3D; E_{x\sim q}[f(x)\frac{p(x)}{q(x)}]\tag{13}$$</p><p>通过这样的变换，我们就达到了从q中采样获取x期望值的效果。</p><p>重要性采样公式为：</p><p>$$E_{x\sim p}[f(x)]&#x3D; E_{x\sim q}[f(x)\frac{p(x)}{q(x)}]\tag{14}$$</p><h3 id="On-policy-gt-Off-policy"><a href="#On-policy-gt-Off-policy" class="headerlink" title="On-policy-&gt;Off-policy"></a>On-policy-&gt;Off-policy</h3><p>$$\nabla \overline R_\theta &#x3D; E_{(s_t,a_t)\sim \pi_\theta}[A^\theta(s_t,a_t)\nabla logp_\theta(a_t^n|s_t^n)]&#x3D;E_{(s_t,a_t)\sim \pi_\theta’}[\frac{P_\theta(s_t,a_t)}{P_\theta’(s_t,a_t)}A^{\theta’}(s_t,a_t)\nabla logp_\theta(a_t^n|s_t^n)]$$</p><p>$$&#x3D;E_{(s_t,a_t)\sim \pi_\theta’}[\frac{p_\theta(a_t|s_t)}{p_\theta’(a_t|s_t)}\frac{p_\theta(s_t)}{p_\theta’(s_t)}A^{\theta’}(s_t,a_t)\nabla logp_\theta(a_t^n|s_t^n)]\tag{15}$$</p><p>由于我们假设$\theta$与$\theta’$是一样的，因此${p_\theta(s_t)}$和 $ p_\theta’(s_t)$这两个同环境相关的参数可以约掉，而${p_\theta(a_t|s_t)}$和${p_\theta’(a_t|s_t)}$是同动作选择相关，并没有假设它们的动作选择一致，因此不能约掉。因此我们得到：</p><p>$$J^{\theta’}(\theta) &#x3D; E_{(s_t,a_t)\sim \pi_{\theta’}}[\frac{p_\theta(a_t|s_t)}{p_{\theta’}(a_t|s_t)}A^{\theta’}(s_t,a_t)]\tag{16}$$</p><h3 id="Add-Constraint"><a href="#Add-Constraint" class="headerlink" title="Add Constraint"></a>Add Constraint</h3><p>$\theta$和$\theta’$的区别是一个值得讨论的问题。在这里我们所说的区别并不是$\theta$和$\theta’$参数上的不同，而是说它们在表现上的不同的程度需要被限制，而想要这个区别被限制，就必须要使它可以被量化。因此，在PPO中，使用$KL(\theta,\theta’)$对$\theta$和$\theta’$在表现上的不同的程度进行量化。由此可以得到两个算法，即Proximal Policy Optimization(PPO)和TRPO(Trust Region Policy Optimization)：</p><ul><li>Proximal Policy Optimization(PPO)</li></ul><p>$$J_{PPO}^{\theta’}(\theta) &#x3D; J^{\theta’}(\theta) - \beta KL(\theta,\theta’)\tag{17}$$</p><ul><li>TRPO(Trust Region Policy Optimization)</li></ul><p>$$J_{TRPO}^{\theta’}(\theta) &#x3D; E_{(s_t,a_t)\sim \pi_{\theta’}}[\frac{p_\theta(a_t|s_t)}{p_{\theta’}(a_t|s_t)}A^{\theta’}(s_t,a_t)]\tag{18}$$</p><p>在TRPO中，$KL(\theta,\theta’)$以单独的限制存在，一般为$KL(\theta,\theta’)&lt;\delta$.</p><p>因此，PPO算法的伪代码如下：</p><ul><li><p>Initial policy parameters $\theta^0$</p></li><li><p>In each iteration:</p><ul><li>Using $\theta^k$ to interact with the environment to collect ${s_t,a_t}$ and compute advatage $A_{\theta^k}(st,at)$</li><li>Find $\theta$ optimizing $J_{PPO}(\theta)$</li><li>$J_{PPO}^{\theta^k} &#x3D; J^{\theta^k}(\theta) - \beta \times KL(\theta,\theta^k)$ # Update parameters several times</li></ul></li><li><p>与此同时，动态调整$\beta$:</p><ul><li>If $KL(\theta,\theta^k) &gt; KL_{max}$,increase $\beta$</li><li>If $KL(\theta,\theta^k) &lt; KL_{min}$,decrease $\beta$</li></ul></li></ul><p>这就完成了 KL Penalty的建立。</p><h2 id="第二种PPO算法"><a href="#第二种PPO算法" class="headerlink" title="第二种PPO算法"></a>第二种PPO算法</h2><p>在这个PPO算法中，并不是使用KL函数，而是使用clip函数，所谓的clip函数是指$clip(\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)},1-\epsilon,1+\epsilon)$，当$\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)}$的值小于$1-\epsilon$时，它的值取$1-\epsilon$,当$\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)}$的值大于$1+\epsilon$时，它的值取$1+\epsilon$.因此可得：</p><p>$$J_{PPO2}^{\theta^k}(\theta) \approx \sum_{(s_t,a_t)}min(\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t|s_t)}A^{\theta^k}(s_t,a_t),clip(\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)},1-\epsilon,1+\epsilon)A^{\theta^k}(s_t,a_t))\tag{19}$$</p><p>$\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t|s_t)}$和$clip(\frac{p_\theta(a_t|s_t)}{p_\theta^k(a_t,s_t)},1-\epsilon,1+\epsilon)$的图像如图所示：</p><p><img src="http://cdn.leafii.top/img/secondppo.png" alt="secondppo" loading="lazy"></p><h2 id="PPO的网络结构"><a href="#PPO的网络结构" class="headerlink" title="PPO的网络结构"></a>PPO的网络结构</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>一个actor网络，一个critic网络</p><p><img src="http://cdn.leafii.top/img/v2-1c0bdce5fe4df17df7c4a987c4f7c9b1_1440w.jpeg" alt="img" loading="lazy"></p><ul><li>actor网络的输入为状态，输出为动作概率$\pi(a_t|s_t)$(对于离散动作空间而言)或者动作概率分布参数（对于连续动作空间而言）</li><li>critic网络的输入为状态，输出为状态的价值。</li></ul><p>显然，如果actor网络输出的动作能够使优势（$A^\theta(s_t,a_t)$）变大，那么就越好。如果critic网络输出的状态价值越准确，那么就越好。</p><h3 id="产生experience的过程"><a href="#产生experience的过程" class="headerlink" title="产生experience的过程"></a>产生experience的过程</h3><p>已知一个状态$s_0$，通过actor网络得到所有动作的概率（图中以三个动作：$a,b,c$为例），然后依概率采样得到动作$a_0$，然后将$a_0$输入到环境中，得到$s_1$和$r_1$。状态价值$v(s_0)$是通过critic网络输出得到的，这样就得到一个experience：$(s_0,a_0,r_1,v(s_0),logP(a_0|s_0))$，然后将experience放入经验池中(当然之后还会计算$A(s_0,a_0))$以及$G_0$，经验池中也存放了这两个信息)。</p><p><img src="http://cdn.leafii.top/img/v2-053ff8d2e893a3ce59c67dac0406eeb6_1440w.jpeg" alt="img" loading="lazy"></p><blockquote><p>注：虽然$v(s_0)$可以用一条轨迹的折扣回报得到，即：$v(s_0)&#x3D;r_1+\gamma r_2+…+\gamma^{T}r_{T+1}+\gamma^{T+1}v(s_{T+1})$,但是轨迹末状态的下一状态$s_{T+1}$的$v(s_{T+1})$还是需要critic网络来估计，当然如果$s_{T+1}$是正常游戏结束，而不是达到了最大步长，那么令$v(s_{T+1}&#x3D;0$)。与其这样，还不如直接用critic网络直接估计$v(s_0)$，而且值得注意的是，$v(s_0)&#x3D;r_1+\gamma r_2+…+\gamma^{T}r_{T+1}+\gamma^{T+1}v(s_{T+1})$正是我们critic网络作为监督学习的真值</p></blockquote><p>以上是离散动作的情况，如果是连续动作，就输出概率分布的参数（比如高斯分布的均值和方差），然后按照概率分布去采样得到动作$a_0$。</p><p><strong>经验池</strong>存在的意义是更加方便的计算一条轨迹上状态的累积折扣回报$v(s_t)$以及优势$A(s_t,a_t)$而不是消除experience的相关性。</p><h3 id="Actor网络的更新流程"><a href="#Actor网络的更新流程" class="headerlink" title="Actor网络的更新流程"></a>Actor网络的更新流程</h3><p>对优势函数进行定义：</p><p>$$\hat A_t &#x3D; \delta_t+(\gamma \lambda)\delta_{t+1}+…+…+(\gamma \lambda)^{T-t+1}\delta_{T-1},\tag{20}$$</p><p>$$where \delta_t &#x3D; r_t + \gamma V(s_{t+1}) - V(s_t)\tag{21}$$</p><p>因为Actor网络需要输出的动作优势尽可能的大，所以它的训练需要用以下表达式作为Loss函数:</p><p>$$L^{CLIP}(\theta) &#x3D; \hat {\mathbb E}_t[min(r_t(\theta)\hat A_t,clip(r_t(\theta),1-\epsilon,1+\epsilon)\hat A_t\tag{22}$$</p><p>其中$$r_t(\theta) &#x3D; \frac{\pi_\theta(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t)}$$</p><p><strong>值得注意的是：</strong> 和TD3算法的单步TD不同，PPO算法使用多步TD，因此它需要跑完一条轨迹后，才开始计算各个<strong>状态的累积回报</strong>和<strong>动作的优势</strong>。具体而言，状态价值 ，$v(s_0)$，$v(s_1)$ 是通过critic网络输出得到的，动作优势 $A(s_0,a_0)$ 是通过首先计算$ \delta_0&#x3D;r_1+v(s_1)−v(s_0) $，然后用 $\gamma \lambda$作为折扣因子去计算动作优势 $A(s_0,a_0)$ ，具体可以看公式（20）。</p><p>因此训练actor网络的时候需要将经验池中的所有数据都拿出来，计算loss，然后用梯度上升法，多更新几步梯度。更新完成后即将经验池清空，等待下一个新的actor网络与环境互动去收集数据。</p><p>PyTorch 代码如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># train actor net</span>        all_pi_tensor <span class="token operator">=</span> self<span class="token punctuation">.</span>actor_net<span class="token punctuation">(</span>state_tensor<span class="token punctuation">)</span>        pi_tensor <span class="token operator">=</span> all_pi_tensor<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> action_tensor<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        surrogate_advantage_tensor <span class="token operator">=</span> <span class="token punctuation">(</span>pi_tensor <span class="token operator">/</span> old_pi_tensor<span class="token punctuation">)</span> <span class="token operator">*</span>                 advantage_tensor        clip_times_advantage_tensor <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token operator">*</span> surrogate_advantage_tensor        max_surrogate_advantage_tensor <span class="token operator">=</span> advantage_tensor <span class="token operator">+</span>                 torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>advantage_tensor <span class="token operator">></span> <span class="token number">0.</span><span class="token punctuation">,</span>                clip_times_advantage_tensor<span class="token punctuation">,</span> <span class="token operator">-</span>clip_times_advantage_tensor<span class="token punctuation">)</span>        clipped_surrogate_advantage_tensor <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>                surrogate_advantage_tensor<span class="token punctuation">,</span> max_surrogate_advantage_tensor<span class="token punctuation">)</span>        actor_loss_tensor <span class="token operator">=</span> <span class="token operator">-</span>clipped_surrogate_advantage_tensor<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        actor_loss_tensor<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>actor_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="Critic网络的更新流程"><a href="#Critic网络的更新流程" class="headerlink" title="Critic网络的更新流程"></a>Critic网络的更新流程</h3><p>Actor网络更新后，接着拿从经验池buffer中采出的数据进行Critic网络的更新（数据已经计算了状态价值，折扣回报$G_t$的计算是基于多步TD的方法，从那个状态开始，用每一步环境返回的奖励 R 与折扣因子相乘后累加，即：$G_t &#x3D; r_{t+1} + \gamma r_{t+2} + … + \gamma^{T-t}r_{T+1} + \gamma^{T+1-t}v(s_{T+1})$，其中$v(s_{T+1})$为网络的估计值，更新方式即为：计算好的折扣回报 $G_T$与Critic网络预测当前状态价值 $v(s_t)$ 做差，用MSEloss作为Loss函数，对神经网络进行训练。</p><p>pytorch代码如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># train critic net</span>        pred_tensor <span class="token operator">=</span> self<span class="token punctuation">.</span>critic_net<span class="token punctuation">(</span>state_tensor<span class="token punctuation">)</span>        critic_loss_tensor <span class="token operator">=</span> self<span class="token punctuation">.</span>critic_loss<span class="token punctuation">(</span>pred_tensor<span class="token punctuation">,</span> return_tensor<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        critic_loss_tensor<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>critic_optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="为什么说TRPO和PPO是On-policy的？"><a href="#为什么说TRPO和PPO是On-policy的？" class="headerlink" title="为什么说TRPO和PPO是On-policy的？"></a>为什么说TRPO和PPO是On-policy的？</h2><p><strong>首先我们明确什么是on-policy，什么是off-policy？</strong></p><ul><li>on-policy：就是要训练的agent跟环境互动的agent是同一个agent,也就是我们采样的网络和要优化的网络是否是同一个网络。</li><li>off-policy：那肯定就是跟上面相反的。</li></ul><p>那么进入正题，我们一般认为PPO是off-policy的原因就是因为PPO使用actor网络去sampler然后填充经验池，然后使用这个经验池中的数据去更新这个actor多个epoch，当更新到第二个epoch的时候那么actor就变成了actor1,然而经验池中的数据仍然是actor网络采样得到的，那么就造成了从更新第二个epoch开始采样的actor和要优化的actor不是同一个网络，那么可能就会认为它是off-pocliy的。</p><p>其实可以很简单的解释这个问题，根据off-policy的定义，采样的网络和要优化的网络不是一个网络，那么对于PPO来说，<strong>使用一批数据从更新actor的第二个epoch开始，数据虽然都是旧的actor采样得到的，但是我们并没有直接使用这批数据去更新我们的新的actor，而是使用imporance sampling先将数据分布不同导致的误差进行了修正</strong>。那么这个importance sampling的目的就是让这两者数据分布之间的差异尽可能的缩小，<strong>那么就可以近似理解成做了importance sampling之后的数据就是我们的更新（这里的更新指的是多个epoch更新的中间过程）后的actor采样得来的，这样就可以理解成我们要优化得actor和采样得actor是同一个actor，那么他就是on-policy的。</strong></p><h2 id="Conclusion-3"><a href="#Conclusion-3" class="headerlink" title="Conclusion[3]"></a>Conclusion[3]</h2><p>We have introduced proximal policy optimization, a family of policy optimization methods that <strong>use multiple epochs of stochastic gradient ascent to perform each policy update</strong>.These methods <strong>have the stability and reliability of trust-region methods but are much simpler to implement</strong>**, requiring only few lines of code change to a vanilla policy gradient implementation, applicable in more general settings (for example, when <strong>using a joint architecture for the policy and value function</strong>), and have better overall performance.</p><p>我们介绍了近程策略优化，这是一系列策略优化方法，使用随机梯度上升的多个周期来执行每个策略更新。 这些方法具有信任域方法的稳定性和可靠性，但实现起来要简单得多，只需要很少的代码行就可以改变成一个普通的策略梯度实现，适用于更一般的设置（例如，当使用策略和值函数的联合体系结构时），并且具有更好的整体性能。 </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p>【DRL-16】Proximal Policy Optimization : <a href="https://zhuanlan.zhihu.com/p/142312072">https://zhuanlan.zhihu.com/p/142312072</a></p></li><li><p>为什么说TRPO和PPO是on-policy的？:<a href="https://zhuanlan.zhihu.com/p/387193698">https://zhuanlan.zhihu.com/p/387193698</a></p></li><li><p>Proximal Policy Optimization Algorithms:arXiv:1707.06347v2 [cs.LG] 28 Aug 2017</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用SHAP解释机器学习</title>
      <link href="/2022/08/09/%E7%94%A8SHAP%E8%A7%A3%E9%87%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/08/09/%E7%94%A8SHAP%E8%A7%A3%E9%87%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="用SHAP解释机器学习"><a href="#用SHAP解释机器学习" class="headerlink" title="用SHAP解释机器学习"></a>用SHAP解释机器学习</h1><h2 id="什么是Explainable-AI？"><a href="#什么是Explainable-AI？" class="headerlink" title="什么是Explainable AI？"></a>什么是Explainable AI？</h2><p>关于要如何解释自己模型预测出来的结果，我们都需要了解为何我们训练出的模型会做出如此判断，是基于什么原因作出这种判断，会不会model完全用了非常诡异的特征去下决策（但说不定是对的？）以下归纳出几个我们为什么想知道我们训练出来的模型到底在说什么？</p><ul><li>确认模型的合理性：在我们需要做出决策，倚重模型做判断时，我们需要知道，这个模型所参考的数据特征是否正如我们想象的一样。若我们不知道演算法建议的理由，那下决策肯定会觉得害怕，如同依赖了一个名为AI的黑盒子一般。</li><li>改良模型：这点其实和第一点略为相同，如果我们能知道我们的模型所预测的依据，我们就可以去试着改善它。特别是当模型和资料中，存在了一些恰恰好的bias，若我们没试着看背后的原因的话，通常很难发现一些问题。以过去的专案经验当作例子，我们使用影像检验在找瑕疵物件时，预测的效果不错，但取细看背后的原因，却发现模型依赖背景而做出决断。详细的情况是物件的缺陷在拍摄当天时有个固定的光影，模型判断defect的依据竟然是用那个光影，而非物件上的瑕疵。</li><li>从模型上学习：当模型真正的从品质良好的训练资料集中得到了有用的判断依据，人类就可以从模型中学到一些东西。例如为期，人类目前很显然已经被AI击败，但在无关输赢的时候，职业棋手目前早已寻求AI的帮助，让自己的技术更上一层楼。</li></ul><h2 id="SHAP-Value"><a href="#SHAP-Value" class="headerlink" title="SHAP Value"></a>SHAP Value</h2><p>以上几点让我们了解Explainable AI的必要性，那我们该如何下手去理解每个预测我们的模型是如何理解的呢？</p><p>SHAP values（SHapley Additive exPlanations）是一个Python的视觉化分析套件，让我们能轻易地了解我们的模型做出决策的依据。</p><p>那对我们来说，什么时候该用SHAP value呢？</p><p>举例：</p><ul><li>制造业的入料控制以达到最佳化结果，你如何正确地减少不必要的入料，也可以达到一样的产能。</li><li>利用Users的使用行为，找到诈骗账号。并对模型做出解释，借此在各种features中找到诈骗账号一般性具有的行为。</li></ul><h2 id="SHAP估计"><a href="#SHAP估计" class="headerlink" title="SHAP估计"></a>SHAP估计</h2><p>除了这个方法，还可以使用SHAP（SHapley Additive exPlanations）来估计Shapley values，SHAP将模型的预测值解释为每个输入特征的归因值之和。换句话说，就是计算每一个特征的Shapley value，依此来衡量特征对最终预测值的影响。用公式表示：</p><p>$$g(z’)&#x3D;\phi_0+\sum_{j&#x3D;1}^{M}\phi_jz’_j$$</p><ul><li>g(z’)为被简化的可解释的模型</li><li>z’表示相应的特征是否存在（1或0），M是输入特征的个数，因此可以表示成$z’\in{0,1}^M$</li><li>$\phi_i$代表我们要求的Shapley value</li><li>$\phi_0$代表平均值</li></ul><h2 id="Kernel-SHAP"><a href="#Kernel-SHAP" class="headerlink" title="Kernel SHAP"></a>Kernel SHAP</h2><p>$$g(z’)&#x3D;\phi_0+\sum_{k&#x3D;1}^{M}\phi_kz’_k$$</p><p>Kernel SHAP 的计算流程：</p><ul><li>Sample coalitions $z’_k\in{0,1}^M,k\in{1,…,K}$(1&#x3D;feature present in coalition,0 &#x3D; feature absent).</li><li>Get prediction for each $z’_k$ by first converting z’k to the original feature space and then applying model f:$f(h_x(z’_k))$</li><li>Compute the weight for each $z’_k$ with the SHAP kernel.</li><li>Fit weighted linear model.</li><li>Return Shapley values $\phi_k$, the coefficients from the linear model.</li></ul><p>Kernel SHAP 计算流程的详细说明：</p><p>Step 1:</p><ul><li>Sample coalitions $z’_k\in{0,1}^M,k\in{1,…,K}$(1&#x3D;feature present in coalition,0 &#x3D; feature absent).</li></ul><p>我们只想要求Age的Shapley value，而Weight和Color都嫌不要求，因此将Age，Weight，Color的z设为（1，0，0）</p><p><img src="http://cdn.leafii.top/img/1*tBYED5khakp0zlEV-mWdfQ.png" alt="Step 1" loading="lazy"></p><p>Step 2:</p><ul><li>Get prediction for each $z’_k$ by first converting z’k to the original feature space and then applying model f:$f(h_x(z’_k))$</li></ul><p>我们取得DATA里的值，假设有一笔资料的Age，Weight，Color为0.5,20,Blue,由于我们Age，Weight，Color的z设为（1，0，0），因此只需保留Age的正确性（0.5），其他两个都随机替代其他资料存在的值，例如Weight从20换成17，Color从Blue换成Pink，注意，17和Pink必须要是DATA里有存在的值，不能随机填。</p><p><img src="http://cdn.leafii.top/img/1*l8aco7sQ4LcjLWFUggBSmg.png" alt="Step 2" loading="lazy"></p><p>Step 3:</p><ul><li>Compute the weight for each $z’_k$ with the SHAP kernel.</li></ul><p>Kernel SHAP中权重的计算根据Simplified Features中0或1的数量，若有很多0或是很多1，我们取较高的权重，若0和1的数量相近则取较低的权重。</p><p><img src="http://cdn.leafii.top/img/1*RxUaGj_RH6FfCSwklWQVzA.png" alt="Step 3" loading="lazy"></p><p>Step 4:</p><ul><li>Fit weighted linear model.</li></ul><p>最后再根据资料来fit一个weighted linear model，而获得的weight其实就是特征对应的Shapley values</p><p><img src="http://cdn.leafii.top/img/1*Q8KsY0ehupv_VxMzYcHWTg.png" alt="Step 4" loading="lazy"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://medium.com/ai-academy-taiwan/%E5%8F%AF%E8%A7%A3%E9%87%8B-ai-xai-%E7%B3%BB%E5%88%97-shap-2c600b4bdc9e">可解釋 AI (XAI) 系列 — SHAP</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习基础 </tag>
            
            <tag> 博弈论基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shapley_Values</title>
      <link href="/2022/08/09/Shapley-Values/"/>
      <url>/2022/08/09/Shapley-Values/</url>
      
        <content type="html"><![CDATA[<p>Shapley Values是博弈论大师Lloyd Stowell Shapley基于合作博弈理论(cooperative game theory)提出来的解决方案，通常被翻译为夏普利值、沙普利值，是一种基于贡献的分配方式。<span id="more"></span></p><h1 id="Shapley-Values"><a href="#Shapley-Values" class="headerlink" title="Shapley Values"></a>Shapley Values</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shapley Values是博弈论大师Lloyd Stowell Shapley基于合作博弈理论(cooperative game theory)提出来的解决方案，通常被翻译为夏普利值、沙普利值，是一种基于贡献的分配方式。这种方法根据玩家们在Game中得到的总支出公平的分配总支出给玩家们</p><ul><li>玩家们 -&gt; features value of the instance</li><li>Game -&gt; model</li><li>总支出 -&gt; prediction</li></ul><blockquote><p>博弈根据是否可以达成具有约束力的协议，分为合作博弈和非合作博弈。合作博弈是指一些参与者以同盟、合作的方式进行的博弈，博弈活动就是不同集团之间的对抗。<br>合作博弈研究人们达成合作时如何分配合作得到的收益，即收益分配问题。合作博弈采取的是一种合作的方式，或者说是一种妥协。<br>合作博弈亦称为正和博弈，是指博弈双方的利益都有所增加，或者至少是一方的利益增加，而另一方的利益不受损害，因而整个社会的利益有所增加的。</p></blockquote><p>合作博弈存在的两个基本条件是：</p><ol><li>对联盟来说，整体收益大于其每个成员单独经营时的收益之和。</li><li>对联盟内部而言，应存在具有帕累托改进性质的分配规则，即每个成员都能获得不少于不加入联盟时所获的收益。</li></ol><p>Shapley Value的四个公理：</p><ol><li>对称性：如果player i和player j满足$v(S\cup i)&#x3D;v(S \cup j)$，对于任意不包含i和j的联盟S都成立，那么$\phi_i(v)&#x3D;\phi_j(v)$.</li><li>有效性：合作各方获利总和等于合作获利($\sum_{i\in P}\phi_{i}(v)&#x3D;v(P)$)</li><li>冗员性：如果i是一个player，满足$v(S)&#x3D;v(S\cup j)$对任意一个联盟S成立，那么$\phi_i(v)&#x3D;0$;也就是说如果一个人加入任何一个联盟对联盟的收益都没有影响，也就是说，他对任何一个联盟都没有贡献，那这个人就不应该分得任何payoff，所以它的夏普利值为0.</li><li>任意两个game无关，它的夏普利值可以相加。($\phi[u+v]&#x3D;\phi[u]+\phi[v]$对任何games u和v都成立)</li></ol><h2 id="公式1"><a href="#公式1" class="headerlink" title="公式1"></a>公式1</h2><p>记$I&#x3D;{1,2,…,n}$为n个合作人的集合</p><p>$$\phi_i(v)&#x3D;\sum_{s\in S_i}\omega(|s|)[v(s)-v(s\setminus{i})]$$ </p><p>其中，$S_i$是$I$中包含成员$i$的所有子集形成的集合，$|s|$是集合s元素的个数，$\omega(|s|)$是加权因子</p><p>$s\setminus {i}$，表示集合s中去掉元素i后的集合</p><p>$v(s)-v(s\setminus{i})$，成员i在联盟中的贡献，即成员i的边际贡献；</p><p>$\omega(|s|)$，即权重$\omega(|s|)&#x3D;\frac{(|s|-1)!(n-|s|)!}{n!}$</p><p>Shapley Value由两权重系数和边际贡献两部分构成</p><p>公式的理解：</p><p>成员i的联盟会有很多个，我们列出包含成员i所有的联盟，然后依次计算每个联盟中，成员i的边际贡献，并将该边际贡献乘以该联盟出现的概率（权重），把结果值加起来就是成员i的夏普利值。</p><p>这里的边际贡献还好理解，联盟的收益-剔除成员i后联盟的收益，即成员i对联盟带来的增益贡献（边际贡献）；</p><p>权重公式的理解：</p><p>从公式来看，它只和联盟s的成员个数有关，分母n!表示n个成员的全排列，分子$(|s|-1)!(n-|s|)!$表示联盟s中除了成员i的排列数乘以联盟剩下的成员$(n-|s|)$要加入联盟s的排列数</p><p><img src="http://cdn.leafii.top/img/v2-6506bfe5e6131535f7616b2d9d705f21_1440w.jpg" alt="img" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/v2-9e6d676f7a66893cae2f49a13b31a4bb_1440w.jpg" alt="img" loading="lazy"></p><h2 id="公式2"><a href="#公式2" class="headerlink" title="公式2"></a>公式2</h2><p>初始方程：</p><p>$$\phi_i(v)&#x3D;\sum_{S\subseteq N\setminus{i}}\frac{|S|!(|N|-|S|-1)!}{|N|!}(v(S\cup{i})-v(S))$$</p><p>让我们把它分解一下。在一个联盟game（前面描述的场景）中，我们有一组 p 个玩家。我们还有一个函数 val，它给出了这些参与者的任何子集的值，也就是说，S 是${x_1,…,x_p}$的子集，然后 val（S）给出了该子集的值。因此，对于一个联合博弈（p，v），我们可以使用这个方程来计算玩家 i 的贡献，即 Shapley 值。</p><p>我们重写一下初始方程：</p><p><img src="http://cdn.leafii.top/img/change.png" alt="change" loading="lazy"></p><p>接下来通过分解方程的不同部分，以便加深理解，在这里我们定义一个具体的场景，使其所有部分都不再那么抽象。</p><p>假设我们经营一家生产砖块的工厂。我们的一个生产团队由四个人组成：Amanda、Ben、Claire和Don（从现在开始我将以他们名字的首字母来称呼他们）。每周他们一起设法生产出X块砖。由于我们工厂运转良好，有一笔奖金要发给队员们，但是为了让我们以公平的方式做到这一点，我们需要弄清楚每个人对每周生产X数量的砖块贡献了多少。</p><p>最困难的是，我们有好几个因素都会影响团队可以生产的砖块数量。其中之一是团队规模，因为团队规模越大，生产的砖块就越多。另一个可能是团队成员之间的合作程度。问题是，我们无法以有意义的方式量化这些影响，但幸运的事，我们可以使用Shapley值来回避这个问题。</p><p>我们现在已经定义了玩家（A、B、C和D）以及他们参与的game（生产砖块）。让我们从计算生产的X砖中有多少可以归于Don开始，即计算D的Shapley值。如果我们把它与Shapley值公式的参数联系起来，我们就得到：</p><p>$$N&#x3D;{A,B,C,D}\\ i&#x3D;D$$ </p><p>所以D是我们的球员i，整个N组由所有四个队员A，B，C和D组成，我们先看一下Shapley值公式的这一部分：</p><p>$$S\subseteq N\setminus{i}$$</p><p>也就是说，我们需要把我们的团队成员排除在我们现在关注的人之外。然后，我们需要考虑所有可能形成的子集。所以如果我们从组中排除D，我们就只剩下{A,B,C}。从这个剩余的组中，我们可以形成以下子集：</p><p><img src="http://cdn.leafii.top/img/ziji.png" alt="ziji" loading="lazy"></p><p>我们总共可以构造出其余团队成员的8个不同子集。其中一个子集是空集，即它没有任何成员。</p><p>现在让我们把注意力转移到这个部分：</p><p>$$(v(S\cup{i})-v(S))$$</p><p>这是我们Shapley值的一个基本概念的应用：在game中增加玩家i的边际价值。所以对于任何给定的子集，我们要比较它的值和当包括玩家i的时候它的值。通过这样做，我们得到了将玩家i添加到该子集的边际值。</p><p>我们把它和我们的例子联系起来，想看看如果我们把D加到8个子集中的每一个子集上，每周生产的砖块数量有什么不同。我们可以将这8个边缘值直观地表示为：</p><p>$$\nabla v_{A,D}\space \nabla v_{AB,D} \ \nabla v_{\emptyset,D} \space \space \nabla v_{B,D} \space \space \nabla v_{BC,D} \space \space \nabla v_{ABC,D} \ \nabla v_{C,D} \space \space \nabla v_{CA,D}$$</p><p>你可以将每种情况都视为我们需要观察的不同场景，以便公平地评估D对整个生产的贡献程度。这意味着，我们需要观察如果没有人工作（即空集合）会产生多少砖块，并将其与只有D工作时的情况进行比较。我们还需要观察AB产生的砖块数量，并将其与AB产生的砖块数量以及所有8个集合中D可以产生的砖块数量进行比较。</p><p>好吧，我们现在已经知道我们需要计算8个不同的边缘值。Shapley值方程告诉我们，我们需要它们加在一起。然而，在我们做这些之前，我们还需要调整每一个边际值，从等式的这一部分可以看出：</p><p><img src="http://cdn.leafii.top/img/%E7%9C%8B%E5%87%BA.png" alt="看出" loading="lazy"></p><p>它计算出除玩家i以外的所有剩余团队成员的子集的排列可以有多少个。或者换句话说：如果你有｜N｜-1个玩家，你能用它们组成多少个｜S｜大小的组？然后我们用这个数字除以玩家i对所有大小为｜S｜的群体的边际贡献。</p><p>在我们的场景中，｜N｜-1&#x3D;3，也就是说，当我们计算D的Shapely值时，这些是剩下的团队成员数量。在我们的例子中，我们将使用等式的那一部分来计算我们可以形成多少个0、1、2和3大小的组，因为这些只是我们可以用剩下的成员构造的组大小。因此，例如，如果有｜S｜&#x3D;2，那么我们可以构造3个不同的大小为2的组：AB、BC和CA。这意味着我们应该对8个边缘值中的每一个应用以下比例因子：</p><p>$$\frac{1}{3}\nabla v_{A,D}\space\space \frac{1}{3}\nabla v_{BC,D} \ 1\nabla v_{\emptyset,D} \space \space \frac{1}{3}\nabla v_{B,D} \space \space \frac{1}{3}\nabla v_{BC,D} \space \space 1\nabla v_{ABC,D} \ \frac{1}{3}\nabla v_{C,D} \space \space \frac{1}{3}\nabla v_{CA,D}$$</p><p>让我们思考一下为什么要这样做。我们想知道D对团队总产出的贡献有多大。为了做到这一点，我们计算了他对我们所能形成的团队中每个集合的贡献。通过添加这个比例因子，我们平均了其他团队成员对每个子集大小的影响。这意味着，当我们将D加入到一个0，1，2和3大小的团队中时，我们能够捕获这些团队的平均边际贡献。</p><p>接下来，分解最后一部分：</p><p>$$\frac{1}{|N|}$$</p><p>我们需要应用到所有的边际值，然后才能求和。我们必须把它们和总队员数分开。</p><p>我们为什么要这么做？好吧，如果我们看看砖厂的例子，我们已经平均出了其他团队成员对每个子集大小的影响，这样我们就可以算出D对0、1、2和3大小的组的贡献。最后一块拼图是平均小组规模的影响，也就是说，D贡献了多少与小组规模无关。</p><p>我们现在终于可以计算出D的Shapley值了，我们观察到他对团队中所有不同的子集的贡献是多少。我们还对团队成员组成和团队规模的影响进行了平均，这最终允许我们计算：</p><p><img src="http://cdn.leafii.top/img/finalcalculate.png" alt="finalcalculate" loading="lazy"></p><p>数学符号更多的是一个图形化的说明，而不是一个数学的说明（这是我在脑海中想象它的方式）</p><p>在这里，我们得到了D的Shapely值。在我们为团队的其他成员完成这项工作之后，我们将知道每个人对每周生产的X块砖的贡献，这样我们就可以在所有团队成员中公平的分配奖金。</p><p>$$X&#x3D;v({A,B,C,D})&#x3D;\phi_A(v)+\phi_B(v)+\phi_C(v)+\phi_D(v)$$</p><p>我们可以发现，我们不需要知道任何关于值函数v的内部工作原理，只需要观察它为不同子集提供的值，我们可以从参与game的玩家中得到这些值。</p><p>这才是Shapley值背后真正的力量和吸引力，但是对于一组参与game的n个玩家，你将需要分析$2^n$个子集才能计算Shapley值。</p><h2 id="公式3"><a href="#公式3" class="headerlink" title="公式3"></a>公式3</h2><p>Shapley Values通过S中玩家的值函数val定义的：</p><p>$$\phi_j(val) &#x3D; \sum_{S \subseteq {x_1,…,x_p}\setminus{x_j}}{\frac{|S|!(p-|S|-1)!}{p!}} (val(S\cup{x_j})-val(S))$$</p><ul><li>$x_1,…,x_p$为建立模型所使用的所有特征，p为所有的特征数量。</li><li>S为除了$x_j$的子集合。</li><li>Val(S)是对于集合S的预测值减去期望值（平均预测值）。</li></ul><p>$$val_x(S)&#x3D;\int \hat f (x_1,…,x_p)d\mathbb{P}_{x\notin S}-E_X(\hat f(X))$$</p><p>下面通过一个例子了解公式。</p><h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><p>假设工程师们需要合作写一个project，共计100行code，图一显示了工程师期望产出code的行数，也就是对应的val(S)</p><p><img src="http://cdn.leafii.top/img/1*cB0F5OI9ChFjUY1ohmoneg.png" alt="图一. 工程师期望产出code的行数" loading="lazy"></p><p>而我们想要计算出x1这位工程师的Shapley value，也就是他的贡献值该如何计算呢？可以参考一下图二的计算流程，三位工程师，会有六种排列组合，需要针对每种情形来计算出x1的Shapley value，因为先后顺序是会影响他的贡献值的，接着再把六个值加总平均就可以得到x1的Shapley value了。</p><p><img src="http://cdn.leafii.top/img/1*S7sGEbWojrrR-VW3NC9yxg.png" alt="图二.x1的Shapley value计算流程" loading="lazy"></p><p>在下图代入公式看看结果：</p><p><img src="http://cdn.leafii.top/img/1*KGgy9XwcDAdXRhWG0TaKTg.png" alt="计算结果" loading="lazy"></p><p>最后我们可以分别计算出x2和x3的Shapley values，如图三所示，最后得到的x1 是 34.17, x2 是 41.7, x3 是 24.17，而这三个值相加就等于100行code，简单来说，这个Shapley values其实就是想要衡量个别的特征对模型的贡献程度是多少，而不收到其他特征的影响。</p><p><img src="http://cdn.leafii.top/img/1*9ccuwFjqTof7bPb_UIsHlA.png" alt="图三.x1，x2，x3的Shapley values计算过程" loading="lazy"></p><h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><p>某互联网公司今天需要加班，需要编写一个500行的程序代码，产品经理找了三个程序员来完成。按照完成量发奖金：1号普通程序员独立能写100行，2号大神程序员独立能写125行，3号美女程序员能写50行。但如果程序员两两合作，会产生不同的编码效率：1号和2号合作能写270行，2号与3号合作能写350行，1号与3号合作能写375行。当然，三名程序员共同合作能完成500行。若共有1000元项目奖金，该如何给这三名程序员分配呢？</p><p>下面，我们尝试用Shapley值经行计算。首先，计算可能的联盟数量。显然，三个人的联盟形成方法一共有6种：</p><p> （1）1号邀请2号加入组成S联盟，3号加入S联盟；</p><p> （2）1号邀请3号加入组成S联盟，2号加入S联盟；</p><p> （3）2号邀请1号加入组成S联盟，3号加入S联盟；</p><p> （4）2号邀请3号加入组成S联盟，1号加入S联盟；</p><p> （5）3号邀请1号加入组成S联盟，2号加入S联盟；</p><p> （6）3号邀请2号加入组成S联盟，1号加入S联盟；</p><p>按照Shapley值的计算过程，下一步需要计算每位程序员的边际贡献，</p><p><img src="http://cdn.leafii.top/img/1382625-20190219170542329-2104584582.png" alt="img" loading="lazy"></p><p> 1号普通程序员的Shapley值为：$\frac{100 + 100 + 145 + 150 + 325 + 150}{6}&#x3D; \frac{970}{6}$</p><p> 2号大神程序员的Shapley值为：$\frac{170 + 125 + 125 + 125 + 125 + 300}{6} &#x3D;  \frac{970}{6}$</p><p> 3号美女程序员的Shapley值为：$\frac{230 + 275 + 230 + 225 + 50  +  50}{6} &#x3D; \frac{1060}{6}$</p><p> 三人的Shapley值的总和正好等于500。  所以根据Shapley值，1号普通程序员应该获得奖金为：1000 x 0.3233 &#x3D; 323.3元，2号大神程序员应该获得奖金同样为323.3元，3号美女程序员获得奖金为353.3元。</p><h2 id="蒙特卡洛采样近似"><a href="#蒙特卡洛采样近似" class="headerlink" title="蒙特卡洛采样近似"></a>蒙特卡洛采样近似</h2><p>其实这样直接计算Shapley value是非常耗费计算资源的，而当feature values比较多时，可能的联盟数量呈指数性增加，因此对于计算精确的Shapley值是一个大问题，对于这个问题， Štrumbelj et al. 提出了蒙特卡洛采样的近似值：</p><p>$$\hat \phi_j&#x3D;\frac{1}{M}\sum_{m&#x3D;1}^{M}(\hat f(x_{+j}^{m})-\hat f(x_{-j}^{m}))$$</p><ul><li>$x_{+j}&#x3D;(x_1,…,x_{j-1},x_{j},z_{j+1},…,z_p)$，意思是除了特征值$x_j$以外，其他不在联盟内的特征值被来自随机数据点z的特征值替换。</li><li>$x_{-j}&#x3D;(x_1,…,x_{j-1},z_{j},z_{j+1},…,z_p)$，表示连特征值$x_j$都要替换</li></ul><h2 id="Shapley-Value的线性扩展形式-Multilinear-extension-form"><a href="#Shapley-Value的线性扩展形式-Multilinear-extension-form" class="headerlink" title="Shapley Value的线性扩展形式(Multilinear extension form)"></a>Shapley Value的线性扩展形式(Multilinear extension form)</h2><p>用v表示一个p个人的合作博弈，P是这个game中的carrier，那么multilinear extesion(MLE) of v 就是一个函数$f:[0,1]^p \rightarrow \R$</p><p>$$f(x_1,…,x_p)&#x3D;\sum_{S\subseteq P}[\prod_{i\in S}x_i\prod_{j\notin S}(1-x_j)]v(S)$$</p><p>这个函数有两个解释方法：</p><ol><li>对于这个game中的联盟S，我们把联盟中的人（即$i\in S$）看成统一体，这个统一体和不是联盟中的人进行一个inessential game;</li><li>把公式中的$x_i$看作player i加入联盟S的概率，因此联盟S形成的概率就是S中的每个人都加入S的概率和S外的每个人都不加入S的概率乘起来，再乘上这个概率对应的colition S的value，那么函数f就可以看作所有coalition的expected value，也就是一个期望的形式。</li></ol><p><strong>定理：</strong>game v是inessential当且仅当它的multilinear function $f$是变量的线性组合。</p><p>也就是说$f(x_1,…,x_n)&#x3D;\sum_{i&#x3D;1}^{n}v(i)x_i$，其中$v(S)&#x3D;\sum_{i\in S}v(i),∀S\in P$</p><p>只要理解了MLE的解释，就不难理解这个定理了，证明比较简单。</p><p>用MLE求夏普利值，公式如下：<br>$$\phi_i[v]&#x3D;\int_{0}^{1}\frac{\partial f(t,…,t)}{\partial x_i}dt$$</p><p>其中$\frac{\partial f(t,…,t)}{\partial x_i}$可以理解为player i对这个game的边际贡献（marginal contribution），对这个贡献求积分，就是衡量player i对所有包含它的联盟的总贡献(reflecting individual conributions)，跟shapely值的思想一致。从偏导的定义出发，求$f$对$x_i$ 的偏导相当于衡量$x_i$每变化一单位，$f$ 会变化多少，也就是$x_i$的变化对$f$的影响，其中$x_i$表示player i 加入联盟S的概率，$f$是所有coalition的expected value，而$x_i$对$f$的影响则可以理解为player i对整个game的影响力，也就是贡献。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://medium.com/ai-academy-taiwan/%E5%8F%AF%E8%A7%A3%E9%87%8B-ai-xai-%E7%B3%BB%E5%88%97-shap-2c600b4bdc9e">可解釋 AI (XAI) 系列 — SHAP</a></p><p>[2] <a href="https://www.cnblogs.com/tianqianlan/p/10402628.html">SHAPLEY值的一个应用</a></p><p>[3] <a href="https://zhuanlan.zhihu.com/p/461394890">Shapley Value（夏普利值）</a></p><p>[4] <a href="https://zhuanlan.zhihu.com/p/483891565">关于Shapley Value（夏普利值）的公式</a></p><p>[5] <a href="https://www.leiphone.com/category/ai/6mCCOMPuEXDym6nj.html">机器学习中的 Shapley 值怎么理解？</a></p><p>[6] <a href="https://zhuanlan.zhihu.com/p/383269529">合作博弈中夏普利值（Shapley Value）的主要思想、公理及求解公式的理解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习基础 </tag>
            
            <tag> 博弈论基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas数据处理</title>
      <link href="/2022/06/08/Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2022/06/08/Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Pandas数据处理"><a href="#Pandas数据处理" class="headerlink" title="Pandas数据处理"></a>Pandas数据处理</h1><p>​本文主要写Pandas在数据处理时需要掌握的方法。</p><span id="more"></span><h2 id="运算方法"><a href="#运算方法" class="headerlink" title="运算方法"></a>运算方法</h2><p>​我们已经提过如何用Pandas有效地筛选数据，也知道一些基本的统计学运算方法，而在这一节中，我们想要关注的是在Pandas中如何运算。</p><h3 id="筛选赋值运算"><a href="#筛选赋值运算" class="headerlink" title="筛选赋值运算"></a>筛选赋值运算</h3><p>​在之前筛选数据的教学中，我们能成功找出数据中的某个部分，那么针对这个找出的部分，我们对它进行操作也是没问题的。比如下面我们先生成一组数据，然后再对这组数据进行筛选运算。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npdata <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>  data<span class="token punctuation">,</span>  index<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"abcdef"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  columns<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">    A   B   C   Da -12 -11 -10  -9b  -8  -7  -6  -5c  -4  -3  -2  -1d   0   1   2   3e   4   5   6   7f   8   9  10  11</code></pre><p>​筛选出<code>A</code>的column出来，对<code>A</code>的内容进行乘0的运算。</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">]</span> <span class="token operator">*=</span> <span class="token number">0</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   A   B   C   Da  0 -11 -10  -9b  0  -7  -6  -5c  0  -3  -2  -1d  0   1   2   3e  0   5   6   7f  0   9  10  11</code></pre><p>​同样，在筛选数据教学中我们提到的<code>iloc</code>,<code>loc</code>功能也是可以用来对某数据进行运算的。<code>iloc</code>找的是index，<code>loc</code>找的是标签。</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">     A   B   C   Da  100 -11 -10  -9b  200  -7  -6  -5c    0  -3  -2  -1d    0   1   2   3e    0   5   6   7f    0   9  10  11</code></pre><p>​这只是赋值，现在你拿这些赋值的方法进行运算试试：</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">     A   B   C   Da  200 -22 -20 -18b  200  -7  -6  -5c    0  -3  -2  -1d    0   1   2   3e    0   5   6   7f    0   9  10  11</code></pre><p>​试一试条件运算，下面做的就是对于<code>df[&quot;A&quot;]</code>，我要找出<code>df[&quot;A&quot;]</code>中等于0的数，把这些数赋值成-1.</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">]</span><span class="token punctuation">[</span>df<span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">     A   B   C   Da  200 -22 -20 -18b  200  -7  -6  -5c   -1  -3  -2  -1d   -1   1   2   3e   -1   5   6   7f   -1   9  10  11</code></pre><p>​基本上，pandas 中可以用于筛选数据的方法都可以用来进一步把筛选出来的数据赋予新的值。</p><h3 id="Apply方法"><a href="#Apply方法" class="headerlink" title="Apply方法"></a>Apply方法</h3><p>​另一种比较方便的批处理数据的方法，我比较喜欢用的是 <code>apply</code>。这是一种可以针对数据做自定义功能的运算。意味着可以简化数据做复杂的功能运算。 上面我们提到的筛选运算，其实是一种简单的运算方式，如果当运算变得复杂，甚至还需要很多局部变量来缓存运算结果，我们就可以尝试把运算过程放置在一个 <code>func</code> 中， 模块化。</p><p>​比如我定义下面这批数据：</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">,</span> columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   A  B0  4  91  4  92  4  9</code></pre><p>​如果对<code>df</code>做全量的平方根计算，一般的方法是这样：</p><pre class="language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>df<span class="token punctuation">)</span></code></pre><p>​但是如果用<code>apply</code>，就会变成</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">     A    B0  2.0  3.01  2.0  3.02  2.0  3.0</code></pre><p>​我们把<code>np.sqrt</code>这个函数当成一个参数传入了<code>apply</code>，看起来好像没什么用，还不如直接使用<code>np.sqrt(df)</code>来的方便。的确这个case写成<code>np.sqrt(df)</code>是要简单点。但是下面这种case呢？</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">1</span>df<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> result_type<span class="token operator">=</span><span class="token string">'expand'</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   0  10  8 -91  8 -92  8 -9</code></pre><p>​在这个自定义的函数中，对 <code>df</code> 中的每一行，每行第 0 位乘以 2，第 1 位乘以 -1，我们原本的 col0，就都乘了 2，而 col1 就都乘了-1。提示一下，<code>apply</code> 里面还有不同的参数项可以选，我使用了一个 <code>result_type=&quot;expand&quot;</code> 的配置，让输出的结果可以生成多 column，要不然， 会只生成一个 column，所有的结果都写在这一个 column 里。要不你试试删除刚才写的 <code>result_type</code>，观察一下生成结果的变化。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#df.apply(func, axis=1)</span><span class="token number">0</span>    <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token number">1</span>    <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token number">2</span>    <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">)</span>dtype<span class="token punctuation">:</span> <span class="token builtin">object</span></code></pre><p>​顺带提一下，如果 <code>reult_type=&quot;broadcast&quot;</code>，那么原 column 和 index 名会继承到新生成的数据中。仔细对比上下两次的运行，你就能发现不同的表现了。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">1</span>df<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> result_type<span class="token operator">=</span><span class="token string">'broadcast'</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   A  B0  8 -91  8 -92  8 -9</code></pre><p>​如果只想改一个column：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">4</span>  df<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">0    161    162    16</code></pre><p>​想要返回原df，但只修改一个column：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">4</span>df<span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">    A  B0  16  91  16  92  16  9</code></pre><p>​想对row进行操作时，修改axis的值为0，并且修改func中对应的运算规则:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">4</span>last_row <span class="token operator">=</span> df<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"last_row:\n"</span><span class="token punctuation">,</span> last_row<span class="token punctuation">)</span>df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> last_row<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\ndf:\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">last_row: A    64B    36dtype: int64df:     A   B0  16   91  16   92  64  36</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​想对数据做特殊的运算，甚至想自定义功能，对数据做批量处理，我们今天就介绍了两大类方法，一种是直接索引-运算，一种是利用 pandas 的 apply 来做更为丰富的运算模式。</p><h2 id="文字处理"><a href="#文字处理" class="headerlink" title="文字处理"></a>文字处理</h2><p>​相比 Python 的科学运算神器 Numpy，Pandas 还有一个特别优势的地方，那就是处理数据库当中的文字信息。 对比 Numpy，Numpy 是一个纯数据处理的库，在数据处理的速度上， 是要优于 Pandas 的。但是在处理数据的丰富度上，比如要处理文字，日期型数据的时候，Pandas 还是有很大优势的。 今天我们就来看看处理文本数据时，Pandas 可以怎么用。</p><h3 id="格式化字符"><a href="#格式化字符" class="headerlink" title="格式化字符"></a>格式化字符</h3><ul><li><code>str.upper(); str.lower(); str.len()</code></li></ul><p>​需要对标一下Python中自带的文字处理功能：Python本身就有很多自带的文字函数，如<code>strip()</code>，<code>upper()</code>等：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pdpy_s <span class="token operator">=</span> <span class="token string">"A,B,C,Aaba,Baca,CABA,dog,cat"</span>pd_s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">,</span><span class="token string">"Aaba"</span><span class="token punctuation">,</span><span class="token string">"Baca"</span><span class="token punctuation">,</span><span class="token string">"CABA"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"cat"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  dtype<span class="token operator">=</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"python:\n"</span><span class="token punctuation">,</span> py_s<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npandas:\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">python: A,B,C,AABA,BACA,CABA,DOG,CATpandas: 0       A1       B2       C3    AABA4    BACA5    CABA6     DOG7     CATdtype: string</code></pre><p>​**注意如果要用到 Pandas 丰富的文字处理功能，你要确保 Series 或者 DataFrame 的 <code>dtype=&quot;string&quot;</code>**，如果不是 string， 比如我们刚从一个 excel 中读取出来一个数据，自动读的，没有解析到 string 格式， 我们怎么调整呢？ 其实也简单。</p><pre class="language-python" data-language="python"><code class="language-python">pd_not_s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"Aaba"</span><span class="token punctuation">,</span> <span class="token string">"Baca"</span><span class="token punctuation">,</span> <span class="token string">"CABA"</span><span class="token punctuation">,</span> <span class="token string">"dog"</span><span class="token punctuation">,</span> <span class="token string">"cat"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"pd_not_s type:"</span><span class="token punctuation">,</span> pd_not_s<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token comment">#pd_not_s type: object</span>pd_s <span class="token operator">=</span> pd_not_s<span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"pd_s type:"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token comment">#pd_s type: string</span></code></pre><p>​好，牢记这点，我们接着来对比原生Python的功能。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"python lower:\n"</span><span class="token punctuation">,</span> py_s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npandas lower:\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"python len:\n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> py_s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npandas len:\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">python lower: a,b,c,aaba,baca,caba,dog,catpandas lower: 0       a1       b2       c3    aaba4    baca5    caba6     dog7     catdtype: stringpython len: [1, 1, 1, 4, 4, 4, 3, 3]pandas len: 0    11    12    13    44    45    46    37    3dtype: Int64</code></pre><ul><li><code>str.strip(); str.lstrip(); str.rstrip()</code></li></ul><p>​再来对比一下对文字的裁剪：</p><pre class="language-python" data-language="python"><code class="language-python">py_s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"   jack"</span><span class="token punctuation">,</span> <span class="token string">"jill "</span><span class="token punctuation">,</span> <span class="token string">"    jesse    "</span><span class="token punctuation">,</span> <span class="token string">"frank"</span><span class="token punctuation">]</span>pd_s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>py_s<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"python strip:\n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>s<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> py_s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npandas strip:\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n\npython lstrip:\n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>s<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> py_s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npandas lstrip:\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n\npython rstrip:\n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>s<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> py_s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npandas rstrip:\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">python strip: [&#39;jack&#39;, &#39;jill&#39;, &#39;jesse&#39;, &#39;frank&#39;]pandas strip: 0     jack1     jill2    jesse3    frankdtype: stringpython lstrip: [&#39;jack&#39;, &#39;jill &#39;, &#39;jesse    &#39;, &#39;frank&#39;]pandas lstrip: 0         jack1        jill 2    jesse    3        frankdtype: stringpython rstrip: [&#39;   jack&#39;, &#39;jill&#39;, &#39;    jesse&#39;, &#39;frank&#39;]pandas rstrip: 0         jack1         jill2        jesse3        frankdtype: string</code></pre><ul><li><code>str.split()</code></li></ul><p>​从结果可能看不清空白符有多少，但是实际上是把空白符都移除掉了。下面再对比一下<code>split</code>拆分方法。</p><pre class="language-python" data-language="python"><code class="language-python">pt_s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a_b_c"</span><span class="token punctuation">,</span> <span class="token string">"jill_jesse"</span><span class="token punctuation">,</span> <span class="token string">"frank"</span><span class="token punctuation">]</span>pd_s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>py_s<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"python split:\n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> py_s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npandas split:\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">python split: [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;jill&#39;, &#39;jesse&#39;], [&#39;frank&#39;]]pandas split: 0        [a, b, c]1    [jill, jesse]2          [frank]dtype: object</code></pre><p>​咦，pandas 这样拆分起来怪怪的，把结果都放到了一个 column 里面，我还记得上一节用 <code>apply()</code> 的时候，我可以加一个 <code>result_type=&quot;expand&quot;</code>，同样，在 <code>split</code> 中也有类似的功能，可以将拆分出来的结果放到不同的 column 中去。</p><pre class="language-python" data-language="python"><code class="language-python">pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">,</span> expand<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">       0      1     20      a      b     c1   jill  jesse  &lt;NA&gt;2  frank   &lt;NA&gt;  &lt;NA&gt;</code></pre><p>​你看，一共拆出了三个 column，但是有些 column 因为没有 split 出那么多值，所以显示的也是 <code>pd.nan</code></p><p>​这里还有一点我想说，我们上面都是在 <code>Series</code> 里面做实验，其实 <code>DataFrame</code> 也是一样的。 <strong>你要做的，只是先选一个 column 或者 row，拿到一个 Series 再开始做 str 的处理</strong></p><pre class="language-python" data-language="python"><code class="language-python">pd_df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>pd_df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">0    A1    BName: 0, dtype: object</code></pre><h3 id="正则方案"><a href="#正则方案" class="headerlink" title="正则方案"></a>正则方案</h3><ul><li><code>str.contains(); str.match(); </code></li></ul><p>​正则是一个很有用的东西，我们在Python 基础中也花了大功夫来学习正则表达式， 用特殊规则获取到特殊的文本。在演示的第一件事情就是它是否真的可以找到一些东西。我们用 <code>str.contains()</code> 或 <code>str.match()</code> 来确认它真的找到了匹配文字。</p><p>​注意，如果你还不了解正则表达式，我强烈建议你先看一下我的正则教学。 要不然你也看不懂我写的匹配规则，比如这里 <code>[0-9][a-z]</code> 表示要匹配 0<del>9 的任何数字，之后再接着匹配 a</del>z 的任何字母。</p><pre class="language-python" data-language="python"><code class="language-python">pattern <span class="token operator">=</span> <span class="token string">r"[0-9][a-z]"</span>s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"1a"</span><span class="token punctuation">,</span> <span class="token string">"11c"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">"string"</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>contains<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">0    False1     True2     True3    Falsedtype: boolean</code></pre><p>​现在请你把 <code>str.contains()</code> 换成 <code>str.match()</code> 看看结果有无变化。仔细的你肯定发现了，<code>11c</code> 这个字符，用 <code>contains()</code> 可以匹配， 但是 <code>match()</code> 却不能。那是因为 <strong>只要包含正则规则，<code>contains</code> 就为 True， 但是 <code>match()</code> 的意思是你的正则规则要完全匹配才会返回 True。</strong></p><p>那么为了要让 <code>match</code> 匹配 <code>11c</code> 我们就需要把规则改成 <code>r&quot;[0-9]+?[a-z]</code>。至于为什么， 那请看到我的正则教学。</p><pre class="language-python" data-language="python"><code class="language-python">pattern <span class="token operator">=</span> <span class="token string">r"[0-9]+?[a-z]"</span>s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">0    False1     True2     True3    Falsedtype: boolean</code></pre><ul><li><code>str.startswith(); str.endswith()</code></li></ul><p>​下面我们在对比下原生 Python 中我比较常用的 <code>startswith</code>, <code>endswith</code> 这两个前后匹配。</p><pre class="language-python" data-language="python"><code class="language-python">py_s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"1a"</span><span class="token punctuation">,</span> <span class="token string">"21c"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">]</span>pd_s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>py_s<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"py_s startswith '1':\n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>s<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> py_s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npy_s endswith 'c':\n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>s<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> py_s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n\npd_s startswith '1':\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npd_s endswith 'c':\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">py_s startswith &#39;1&#39;: [True, True, False, False]py_s endswith &#39;c&#39;: [False, False, True, True]pd_s startswith &#39;1&#39;: 0     True1     True2    False3    Falsedtype: booleanpd_s endswith &#39;c&#39;: 0    False1    False2     True3     Truedtype: boolean</code></pre><p>​当然，pandas 的 <code>str.startswith()</code> 和 <code>str.endswith()</code> 都是可以支持正则的。使用方式和上面的 <code>str.match()</code> 等一样。</p><ul><li><code>str.replace()</code></li></ul><p>​还有一个十分有用，而且我觉得是最重要的，就是 <code>replace</code> 了，因为这真的减轻了我们很多复制粘贴的工作，比如 Excel 中人工按照一个规则修改老板给的新任务。 下面同样，我们对比 Python 原生的 replace，来验证一下。</p><pre class="language-python" data-language="python"><code class="language-python">py_s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"1a"</span><span class="token punctuation">,</span> <span class="token string">"21c"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">]</span>pd_s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>py_s<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"py_s replace '1' -> '9':\n"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>s<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"9"</span><span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> py_s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n\npd_s replace '1' -> '9':\n"</span><span class="token punctuation">,</span> pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"9"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">py_s replace &#39;1&#39; -&gt; &#39;9&#39;: [&#39;9&#39;, &#39;9a&#39;, &#39;29c&#39;, &#39;abc&#39;]pd_s replace &#39;1&#39; -&gt; &#39;9&#39;: 0      91     9a2    29c3    abcdtype: string</code></pre><p>​但是比原生 Python 强大的是，这个 replace 是支持正则的。我们把所有数字都替换成这个 <code>NUM</code> 吧。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"pd_s replace -> 'NUM':"</span><span class="token punctuation">)</span>pd_s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">r"[0-9]"</span><span class="token punctuation">,</span> <span class="token string">"NUM"</span><span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">pd_s replace -&gt; &#39;NUM&#39;:0        NUM1       NUMa2    NUMNUMc3        abcdtype: string</code></pre><ul><li><code>str.extract(); str.extractall()</code></li></ul><p>​除了替换原本文字里的东西，我们还可以去从原本文字里找到特定的文字。有点像正则中的 <code>findall</code> 函数。</p><pre class="language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a1'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'c3'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>extract<span class="token punctuation">(</span><span class="token string">r"([ab])(\d)"</span><span class="token punctuation">)</span></code></pre><p>​<code>r&quot;([ab])(\d)&quot;</code> 这一个正则匹配我简单介绍一下，其中有两个括号，第一个括号是想提取的第一种规则，第二个是第二种想提取的规则。 那么运行出来，你会看到有两个 column，分别对应着这两个提取规则出来的值。最后一行出来的结果是两个 NaN，也就意味着第三个数据没有提取出来任何东西。</p><p>​运行结果：</p><pre class="language-none"><code class="language-none">     0    10    a    11    b    22  NaN  NaN</code></pre><p>​对应 <code>str.extract()</code> 还有一个 <code>str.extractall()</code> 函数，用来返回所有匹配，而不是第一次发现的匹配。</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><ul><li><code>str.cat()</code></li></ul><p>​将两个文本 Series 拼接到一起的方法多种多样。大多情况我们是想结合两个 Series 而形成一个新的 Series。比如下面这样。</p><pre class="language-python" data-language="python"><code class="language-python">s1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">"string"</span><span class="token punctuation">)</span>s2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">"string"</span><span class="token punctuation">)</span>s1<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>cat<span class="token punctuation">(</span>s2<span class="token punctuation">)</span></code></pre><p>​上面这是将两个文字拼接成新的文字，如果你想了解如何在 pandas 中做 df 的数据上的拼接，比如 2 columns 和 3 columns 的 df 做横向拼接等， 我们会在这节 Pandas 的拼接专门讲到，因为里面涉及的拼接方法实在是太多了， 在这里讲不完。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>​可以看到，文字处理包罗万象，有很多方法。我们挑重点的，调有用的。如果觉得这些对于你还不够， 你可以参考到<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html">官方文档</a>，获取到更多信息。</p><h2 id="异常数据处理"><a href="#异常数据处理" class="headerlink" title="异常数据处理"></a>异常数据处理</h2><p>​异常数据，我常代指的是机器学习或者是统计分析中的脏数据。为什么他们异常或者脏呢？ 是因为这些数据不符合你期望当中的规律，给你或你的模型带来困扰。而且很可能是收集数据时，</p><p>​因为人工差错、机器传感器差错而导致的数据异常。再或者某一个 sample 的数据没有被采集，这也会引发数据批量处理中的异常。</p><p>​既然数据异常经常发生，又无可避免，我们就来看看如何能找到合适的解决方案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas统计展示</title>
      <link href="/2022/06/08/Pandas%E7%BB%9F%E8%AE%A1%E5%B1%95%E7%A4%BA/"/>
      <url>/2022/06/08/Pandas%E7%BB%9F%E8%AE%A1%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Pandas统计展示"><a href="#Pandas统计展示" class="headerlink" title="Pandas统计展示"></a>Pandas统计展示</h1><p>​本文主要写Pandas在统计展示方面的知识。</p><span id="more"></span><h2 id="基础统计方法"><a href="#基础统计方法" class="headerlink" title="基础统计方法"></a>基础统计方法</h2><p>​在Pandas上做数据统计，要比在Numpy上做舒服很多，因为在数据展示上，有很多额外的信息辅助你来消化这些信息。而且你还能比较方便地绘制成图。</p><p>​在本节内容中我们会对比Numpy中的方法和Pandas的不同，来解释为什么人们在做数据分析的时候喜欢用Pandas。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>​在分析数据或者统计数据的时候，首先得有数据，我简单创建了一份数据，后续的工作将会依赖于这份数据，所以请你帮我点击一下下面的 Run 键，初始化一下这份数据。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npdata <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">1.39</span><span class="token punctuation">,</span> <span class="token number">1.77</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0.34</span><span class="token punctuation">,</span> <span class="token number">1.91</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.05</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0.34</span><span class="token punctuation">,</span> <span class="token number">1.47</span><span class="token punctuation">,</span> <span class="token number">1.22</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">0.27</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.61</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"r0"</span><span class="token punctuation">,</span> <span class="token string">"r1"</span><span class="token punctuation">,</span> <span class="token string">"r2"</span><span class="token punctuation">,</span> <span class="token string">"r3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"c0"</span><span class="token punctuation">,</span> <span class="token string">"c1"</span><span class="token punctuation">,</span> <span class="token string">"c2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df</code></pre><p>​ 运行结果：</p><pre class="language-none"><code class="language-none">      c0    c1    c2r0  1.39  1.77  Noner1  0.34  1.91 -0.05r2  0.34  1.47  1.22r3  None  0.27 -0.61</code></pre><p>​你在日常生活中，也经常是以这种 2 维表格型数据为主，而且因为各种不可知原因，你的数据可能存在缺失状况。比如有人没交作业，有数据还没被采集到等等。 如果你使用 Excel 收集的数据（用 Pandas 读 Excel），那这种情况可能更加多。</p><h3 id="快速总结"><a href="#快速总结" class="headerlink" title="快速总结"></a>快速总结</h3><p>​通常，如果我们不知道这份数据包含了什么，想快速了解一下这份数据的基础信息，我们可以直接先上一个 <code>describe()</code>，让 Pandas 自动帮我们描述一下这份数据的基础信息。</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">          c0    c1    c2count   3.00  4.00  3.00unique  2.00  4.00  3.00top     0.34  1.77 -0.05freq    2.00  1.00  1.00</code></pre><p>​这里，会显示出来 <code>count</code> 计数（剔除掉 None 或者 NAN 这种无效数据），所以你在结果中能看到 <code>c0</code>，<code>c2</code> 两个的有效数是 3 个，而 <code>c1</code> 有效数有 4 个。</p><p>​<code>unique</code> 表示的是每个 column 中有多少独特的数据。这个在初步感知数据丰富度上会有一定的作用。</p><p>​<code>top</code> 表示出现最多的数据是哪一个，这组数据在 <code>c0</code> column 处，我们能观察到 <code>0.34</code> 出现了两次，所以它选的 top 是 <code>0.34</code>。</p><p>​<code>freq</code> 是继续了 <code>top</code>，表述的是这个出现频率最多的数据，出现的次数有多少次。</p><p>​上面这份数据还不是纯数据，如果是存数值型的数据，我们跑 <code>describe()</code> 还能看到统计学的信息。</p><pre class="language-python" data-language="python"><code class="language-python">df1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"c0"</span><span class="token punctuation">,</span> <span class="token string">"c1"</span><span class="token punctuation">,</span> <span class="token string">"c2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\ndescribe:\n"</span><span class="token punctuation">,</span> df1<span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">         c0        c1        c2a  0.053206  0.686505  0.439459b  0.083406  0.096903  0.212163c  0.369903  0.877894  0.918427d  0.169573  0.563210  0.900700describe:              c0        c1        c2count  4.000000  4.000000  4.000000mean   0.169022  0.556128  0.617687std    0.142708  0.332400  0.349645min    0.053206  0.096903  0.21216325%    0.075856  0.446634  0.38263550%    0.126490  0.624858  0.67008075%    0.219656  0.734352  0.905132max    0.369903  0.877894  0.918427</code></pre><p>​平均数（mean），均方差（std），最小值（min），统计学的 25 分位，50 分位，75 分位各是多少，最大值（max）是多少。</p><h3 id="日常一般用法"><a href="#日常一般用法" class="headerlink" title="日常一般用法"></a>日常一般用法</h3><ul><li>均值中位数<code>df.mean()；df.median()</code></li></ul><p>​像上面，我们已经可以从 <code>describe()</code> 功能中略知一二了，但是你肯定也不满足于这些简单的描述信息。那么我们看看还有哪些简单实用的统计学功能。 比较常用的，我们通常会想知道一组数据的均值，用 <code>mean()</code> 就好了。</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>​这样可以直接输出每一个 columns 的均值，因为这是在对 df 的第0个维度在做求均值。也可以这么写。</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre><p>​ 运行结果：</p><pre class="language-none"><code class="language-none">c0    0.690000c1    1.355000c2    0.186667dtype: float64</code></pre><p>​当然，如果你不想对第 0 个维度，而是想对第 1 个维度求均值呢（后面的功能中 axis 的用法都基本相似）。我们只需要把 <code>axis=0</code> 换成 <code>axis=1</code></p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">r0    1.580000r1    0.733333r2    1.010000r3   -0.170000dtype: float64</code></pre><p>​还有一个比较有用的参数 <code>skipna</code>，这个是用来处理数据中有 <code>None</code> 或者是 <code>NaN</code> 时用的。我们需不需要排除掉有 None 或者 NaN 的数据。 如果需要 skip 掉这些，我们就还是会计算所有行列的数值，只是在计数的时候，扣掉这些 None 和 NaN。<strong>而当 <code>skipna=False</code> 的时候， Pandas 只要遇到了 None 或者 NaN，就不计算这列、行的数据了。所以下面你会看到，它只返回了一个 column 的结果。</strong></p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>skipna<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment">#c1    1.355</span><span class="token comment">#dtype: float64</span></code></pre><p>​你看，对比 <a href="https://mofanpy.com/tutorials/data-manipulation/numpy/operations/">Numpy 的用法</a>，你会发现， Pandas 在展示信息上还是挺对用户考虑的，它把行名等都展示出来，让人不犯迷糊。</p><p>​有了上面的 <code>mean()</code> 的用法做铺垫，理解后面的用法也方便很多。比如在计算人民收入的时候， 我们常用中值来代替均值，原因很简单，<strong>极高收入群体总是拉高了我们的平均收入， 用中位数反倒能反映出群众的真实收入。</strong> 查中值的方式也很简单，就是 <code>median()</code>。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 最后一个为高收入人</span>s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"mean():"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 拉高平均收入，拉高仇恨</span><span class="token comment">#mean(): 26750.0</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"median():"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>median<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 比较合理</span><span class="token comment">#median(): 3000.0</span></code></pre><ul><li>累加累乘<code>df.sum()；df.prod()</code></li></ul><p>​有了上面的<code>mean()</code>和<code>median()</code>的用法做铺垫，理解后面的用法也方便很多。比如要对数据做累加和累乘的运算，我们使用方式和<code>mean()</code>就没啥差别。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"c0"</span><span class="token punctuation">,</span><span class="token string">"c1"</span><span class="token punctuation">,</span><span class="token string">"c2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   c0  c1  c20   0   1   21   3   4   52   6   7   83   9  10  11</code></pre><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sum():\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nsum(axis=0):\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nsum(axis=1):\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">sum(): c0    18c1    22c2    26dtype: int64sum(axis&#x3D;0): c0    18c1    22c2    26dtype: int64sum(axis&#x3D;1): 0     31    122    213    30dtype: int64</code></pre><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"prod():\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>prod<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nprod(axis=0):\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>prod<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nprod(axis=1):\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>prod<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">prod(): c0      0c1    280c2    880dtype: int32prod(axis&#x3D;0): c0      0c1    280c2    880dtype: int32prod(axis&#x3D;1): 0      01     602    3363    990dtype: int32</code></pre><ul><li>最大最小<code>df.max(); df.min()</code></li></ul><p>​同理，理解了上面的用法，查找最大最小也不是问题。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"max():\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nmin():\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">max(): c0     9c1    10c2    11dtype: int32min(): c0    0c1    1c2    2dtype: int32</code></pre><p>​不过你注意到没，这种 <code>max()</code> 和 <code>min()</code> 都是对某一维度进行操作的，肯定有时候，你想要找到那个全局最大最小的数，这怎么找？ 哈哈，那你就做两次操作吧。或者你可以先把它转成 numpy，然后展平了求全局最大最小。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>values<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 用 Numpy 的方式运算</span><span class="token comment">#11</span><span class="token comment">#11</span></code></pre><p>​如果想计算 mean 或者 median 这种，你想想然后再试试，用哪种方式比较合适呢？</p><ul><li>处理空值 <code>df.isnull(); df.notnull(); df.dropna(); df.fillna()</code></li></ul><p>​总有 None 或者 NaN 值有时候挺烦人的，因为在做机器学习或者是统计数据的时候，你也不能放它在那不管。比如在机器学习中，如果有空值，你要么就选择放弃这条数据， 要么就要对它进行科学的填充，有人用均值有人用中值等。所以上面学到的技巧都能在这里用上。</p><p>​第一，你可能想要先看看你的数据中有没有空值。用下面的 <code>isnull()</code> 或者 <code>notnull()</code> 就能找到。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  columns<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nisnull():\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>isnull<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># True 就是空</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nnotnull()\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>notnull<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># False 为空</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">     A    B    C    D0  1.0  2.0  3.0  0.01  3.0  4.0  NaN  1.02  NaN  NaN  NaN  NaN3  NaN  3.0  NaN  4.0isnull():        A      B      C      D0  False  False  False  False1  False  False   True  False2   True   True   True   True3   True  False   True  Falsenotnull()        A      B      C      D0   True   True   True   True1   True   True  False   True2  False  False  False  False3  False   True  False   True</code></pre><p>​发现这里有空值，下面你就可以对这些 None, Null, NaN 做处理了。要么你就放弃这些有空值的数据，用 <code>dropna()</code>。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"默认：\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 默认按 axis=0</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\naxis=1:\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 可以换一个 axis drop</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">默认：      A    B    C    D0  1.0  2.0  3.0  0.0axis&#x3D;1: Empty DataFrameColumns: []Index: [0, 1, 2, 3]</code></pre><p>​当然，你觉得数据只要有值你就想留下来，只去除掉那些全为空的数据，那么你还能在筛选的时候加一个 <code>how=&quot;all&quot;</code> 参数。</p><pre class="language-python" data-language="python"><code class="language-python">df1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df1<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span>how<span class="token operator">=</span><span class="token string">"all"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># how 默认为 "any" </span><span class="token comment">#     0     1    2</span><span class="token comment">#1  1.0  None  3.0</span></code></pre><p>​刚也说了，除了 drop 掉有 None 的，还可以对这些空值进行填充，填充的值也可以自行选定。</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>  <span class="token comment"># 填充 111</span></code></pre><p>​对不同特征<strong>列</strong>做差异化的填充数值。</p><pre class="language-python" data-language="python"><code class="language-python">values <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>df<span class="token punctuation">.</span>fillna<span class="token punctuation">(</span>value<span class="token operator">=</span>values<span class="token punctuation">)</span></code></pre><p>​甚至，如果你有一个每一位上的默认值，你都可以用一个全新的 df 来做空位的填充。</p><pre class="language-python" data-language="python"><code class="language-python">df2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> columns<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"df2:\n"</span><span class="token punctuation">,</span> df2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nfillna(df2):\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>fillna<span class="token punctuation">(</span>df2<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">df2:     A   B   C   D0   0   1   2   31   4   5   6   72   8   9  10  113  12  13  14  15fillna(df2):       A    B     C     D0   1.0  2.0   3.0   0.01   3.0  4.0   6.0   1.02   8.0  9.0  10.0  11.03  12.0  3.0  14.0   4.0</code></pre><ul><li>获取索引 <code>df.idxmin(); df.idxmax()</code></li></ul><p>​一般来说，当你想用 <code>np.argmax()</code> 或者 <code>np.argmin()</code> 的时候，你可以在 pandas 用 <code>idxmax()</code> 和 <code>idxmin()</code> 来替换。原理都一样， 就是找到那个最大最小值的索引。这个的好处是，你只关注索引而不用关注值，你可以对这个索引的值做你想要的后续处理。</p><p>同上面一样，你还能用上面学到的 <code>skipna</code> 来对空值做控制。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  columns<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nidxmax():\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>idxmax<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nidxmax(skipna=False):\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>idxmax<span class="token punctuation">(</span>skipna<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nidxmin():\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>idxmin<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   A  B    C  D0  1  2  3.0  01  3  4  NaN  12  3  5  2.0  13  3  2  2.0  3idxmax(): A    1B    2C    0D    3dtype: int64idxmax(skipna&#x3D;False): A    1.0B    2.0C    NaND    3.0dtype: float64idxmin(): A    0B    0C    2D    0dtype: int64</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​在机器学习或者统计学中，只要你是和数据打交道，就少不了先观察和了解数据。用 Pandas 的这些功能，可以帮你快速了解数据的全貌， 也可以对其中的数据缺失做一些处理。</p><h2 id="绘制图表"><a href="#绘制图表" class="headerlink" title="绘制图表"></a>绘制图表</h2><p>​数据是服务于人的决策的，我们有一大堆数据，如果人没有真正意义上理解这些数据背后的含义，那即使数据量再大，它也是无意义的。所以我们今天来探讨一种让人与数据之间构建信息传递桥梁的方法-数据可视化技术。</p><p>​在 Pandas 中， 就已经可以实现多种多样的数据可视化方案了。</p><p>​我们来看看你拥有的数据可以被 Pandas 表达成什么样。</p><h3 id="散点图Scatter"><a href="#散点图Scatter" class="headerlink" title="散点图Scatter"></a>散点图Scatter</h3><p>​散点图实际在很多生活场景上都有运用的。比如你要描绘数据 sample 之间与拟合曲线之间呈现的关系：</p><p><img src="http://cdn.leafii.top/img/20220608204129.png" loading="lazy"></p><p>​又或者在演示算法是如何进化 ，如何运动的。</p><p><img src="http://cdn.leafii.top/img/20220608204205.png" loading="lazy"></p><p>​这些都是我之前做过的散点图案例，所以适用场景还是非常多的。在 Pandas 中，我们有非常方便的办法来直接对 DataFrame 做散点图。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt <span class="token comment">#一定要加上</span>n <span class="token operator">=</span> <span class="token number">1024</span> <span class="token comment"># data size</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token string">"x"</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token string">"y"</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>color <span class="token operator">=</span> np<span class="token punctuation">.</span>arctan2<span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">"y"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> df<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"x"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"y"</span><span class="token punctuation">,</span> c<span class="token operator">=</span>color<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">.5</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">"rainbow"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>​点击运行之后，你会发现可以做出来一幅非常好看的图。当然这里的参数你可以随意搭配，比如试试不写 <code>c=color</code> 或者去掉 <code>cmap=&quot;rainbow&quot;</code>， 看看会有何影响。</p><p>​我稍微解释一下几个你可能在乎的参数：</p><ul><li>c: 对于这组数据中每个（x,y）数据点的颜色值</li><li>s: 画点的大小（size）</li><li>alpha：不透明度</li><li>cmap：colormap，你可以在<a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">这里</a>找到非常丰富的案例</li></ul><h3 id="折线图-plot"><a href="#折线图-plot" class="headerlink" title="折线图 plot"></a>折线图 plot</h3><p>​同样在这个拟合关系的图中， 我们其实还绘制了一张折线图。可见，折线图也是非常有用的。</p><p><img src="http://cdn.leafii.top/img/20220608210450.png" loading="lazy"></p><p>​同样，还有很多机器学习的loss变化曲线案例都是用折线图绘制出来的。而在Pandas中，折线图的绘制方法很简单。</p><pre class="language-python" data-language="python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">20</span>    <span class="token comment"># data size</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>y <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">0.4</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token string">"x"</span><span class="token punctuation">:</span> x<span class="token punctuation">,</span>    <span class="token string">"y"</span><span class="token punctuation">:</span> y<span class="token punctuation">,</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"x"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"y"</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">.5</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">"r"</span><span class="token punctuation">)</span></code></pre><p>![](<a href="http://cdn.leafii.top/img/Screen">http://cdn.leafii.top/img/Screen</a> Shot 2022-06-08 at 21.07.19.png)</p><p>​我用最朴素的方法，绘制了一条歪歪扭扭的折线图，来体现它真的很折。你可能很感兴趣，为什么这里的 <code>c</code> 参数传入的数值和上面散点图的不一样？ 原来在折线图中，线的颜色最好是一样的，不然当线多了以后，你会发现不同颜色就看不出到底是那条线了。</p><p>​碰到多条线的时候，怎么处理:</p><pre class="language-python" data-language="python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">20</span> <span class="token comment"># data size</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>y1 <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">0.1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>y2 <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">0.4</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token string">"x"</span><span class="token punctuation">:</span>x<span class="token punctuation">,</span>  <span class="token string">"y1"</span><span class="token punctuation">:</span> y1<span class="token punctuation">,</span>  <span class="token string">"y2"</span><span class="token punctuation">:</span> y2<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"x"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"y1"</span><span class="token punctuation">,</span> <span class="token string">"y2"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">.5</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="http://cdn.leafii.top/img/Figure_1.png" loading="lazy"></p><p>​只要我给多个 <code>y</code>，它就能给出多条线的位置，当然还帮你注明哪个颜色是哪条线。</p><h3 id="条形图-bar"><a href="#条形图-bar" class="headerlink" title="条形图 bar"></a>条形图 bar</h3><p>​做两家公司收入对比，或者是年度值变化的时候，我们也很喜欢用条形图。直接点，我们看看 Pandas 的条形图怎么画。 假设有 abd 四家公司，这 5 年的营收对比可以这么画。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>bar<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="http://cdn.leafii.top/img/Figure_2.png" loading="lazy"></p><p>​如果把他们放在一起来看占比多少时，我们还能这么干：</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>stacked<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="http://cdn.leafii.top/img/Figure_3.png" loading="lazy"></p><p>​横着不好看，想画一个竖着的图，Pandas 也能轻松做到。你只需要把 <code>bar()</code> 换成 <code>barh()</code> 就好。多出来的这个 h 就是 horizontal 的意思。</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>barh<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="http://cdn.leafii.top/img/Figure_4.png" loading="lazy"></p><h3 id="分布图-histograms"><a href="#分布图-histograms" class="headerlink" title="分布图 histograms"></a>分布图 histograms</h3><p>​分布图在机器学习和统计学中非常重要，我经常画分布图，比如要画神经网络的参数分布可视化。又或者是GAN生成对抗网络中的数据分布。</p><p><img src="http://cdn.leafii.top/img/20220608215327.png" loading="lazy"></p><p>​我们用<code>plot.hist()</code>就能画出来了，这里的hist是histogram，也就是分布的意思。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>hist<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>​当然还会有多个分布重合在一起，你想对比这看看这些分布有无差别的时候，重合度怎么样的时候。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token string">"a"</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token string">"b"</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token string">"c"</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>hist<span class="token punctuation">(</span>alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> bins<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>​为了使你能轻松辨析出 abc 这几个分布的不同，我把 <code>alpha</code> 不透明度调整了一下，让你能看清楚重叠部分。而且 <code>bins</code> 柱状体的数量也调多了。</p><h3 id="饼图-Pie"><a href="#饼图-Pie" class="headerlink" title="饼图 Pie"></a>饼图 Pie</h3><p>​当你想给 Excel 批量话饼图的时候， 你就能结合读取 Excel 的教学，和这一节一起用。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"boss"</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"meeting"</span><span class="token punctuation">,</span> <span class="token string">"supervise"</span><span class="token punctuation">,</span> <span class="token string">"teaching"</span><span class="token punctuation">,</span> <span class="token string">"team building"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>pie<span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token string">"boss"</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="http://cdn.leafii.top/img/Figure_5.png" loading="lazy"></p><p>​如果你有多张大饼，想要对比？当然也没问题。可以多加一个 <code>subpots</code> 来分开画饼。<code>legend</code> 是用来确定要不要输出图例的，我这里嫌弃图例占地方， 就设置 <code>legend=False</code>。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>    <span class="token punctuation">&#123;</span>        <span class="token string">"bigBoss"</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">"smallBoss"</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"meeting"</span><span class="token punctuation">,</span> <span class="token string">"supervise"</span><span class="token punctuation">,</span> <span class="token string">"teaching"</span><span class="token punctuation">,</span> <span class="token string">"team building"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">)</span>df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>pie<span class="token punctuation">(</span>subplots<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> legend<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="http://cdn.leafii.top/img/Figure_6.png" loading="lazy"></p><h3 id="面积图-area"><a href="#面积图-area" class="headerlink" title="面积图 area"></a>面积图 area</h3><p>​面积图偶尔你还是会看见的，比如在我的 <a href="https://mofanpy.com/tutorials/machine-learning/evolutionary-algorithm/neat-supervised-learning/">进化算法教学中</a>， 就使用了面积图来观看各个种群的占比随时间的变化情况。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>    np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>area<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>​如果你不想上下堆砌在一起观看，而是有统一的一个起点，那可以用这个参数 <code>stacked=False</code>。</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>area<span class="token punctuation">(</span>stacked<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>​好了，这节内容也还挺多的，我就先讲到这里。用 Pandas 画图还可以有很多其他花样， 你可以在这里看到更加细节的<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html">官方文档</a>。 每种画图功能里面，也还有更多参数可以调整。记得不懂就要多在网上搜搜，多看官方文档。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas基本操作</title>
      <link href="/2022/06/05/Pandas%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/06/05/Pandas%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Pandas基本操作"><a href="#Pandas基本操作" class="headerlink" title="Pandas基本操作"></a>Pandas基本操作</h1><p>​本文对Pandas中的一些基本操作进行描述。</p><span id="more"></span><h2 id="从文件读取数据"><a href="#从文件读取数据" class="headerlink" title="从文件读取数据"></a>从文件读取数据</h2><p>​有很多 Pandas 的教学，一开始一般都是开始教 Pandas 的数据结构或者运算方法。 但是我觉得，当你想要使用 Pandas 的时候，<strong>更多是因为你手头有 Excel 数据或者比较格式化的数据， 需要处理分析和表达这些数据。为了解决你这种当务之急，我觉得先解决读取数据这回事。</strong></p><p>​以下操作需要用到的文件为<code>[&#39;体检数据.xlsx&#39;, &#39;体检数据.csv&#39;, &#39;体检数据_sep.csv&#39;, &#39;体检数据_sep.txt&#39;]</code></p><h3 id="Excel文件"><a href="#Excel文件" class="headerlink" title="Excel文件"></a>Excel文件</h3><p>​<a href="https://mofanpy.com/static/files/%E4%BD%93%E6%A3%80%E6%95%B0%E6%8D%AE.xlsx">点击下载</a>所需文件，下载后用Excel打开文件后是这样：</p><p>![](<a href="http://cdn.leafii.top/img/Screen">http://cdn.leafii.top/img/Screen</a> Shot 2022-06-05 at 23.31.25.png)</p><ul><li><code>pd.read_excel()</code></li></ul><p>​将文件放在适宜的目录，我们就可以使用<code>read_excel()</code>方法读出文件了。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddf <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_excel<span class="token punctuation">(</span><span class="token string">"data/体检数据.xlsx"</span><span class="token punctuation">,</span> index_col<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>df</code></pre><p>​运行结果</p><pre class="language-none"><code class="language-none">    姓名   身高  体重   肺活量学号1   小明  168  60  32002   小黄  187  80  38003   小花  170  70  3400</code></pre><p>​在函数中的<code>index_col=0</code>就是告诉Pandas，让它使用第一个column（学号）的数据当作row索引。后面还有很多读取的功能里也有一样的参数。</p><ul><li><code>df.to_excel()</code></li></ul><p>​好，我们既然可以读取Excel文件，那么稍稍修改，再保存起来应该也不成问题。</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"体重"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span>df<span class="token punctuation">.</span>to_excel<span class="token punctuation">(</span><span class="token string">"data/体检数据_修改.xlsx"</span><span class="token punctuation">)</span></code></pre><p>​其实在读取和保存 Excel 文件的时候，还有很多额外的参数可供选择，因为太多了，我们这里就先讲最常用的，如果你要深入研究， 可以到他们的官网来看<a href="https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html#pandas.read_excel">官方文档</a>。</p><h3 id="csv或txt等纯文本文件"><a href="#csv或txt等纯文本文件" class="headerlink" title="csv或txt等纯文本文件"></a>csv或txt等纯文本文件</h3><p>​下载需要的文件：<a href="https://mofanpy.com/static/files/%E4%BD%93%E6%A3%80%E6%95%B0%E6%8D%AE.csv">链接</a>，使用纯文本编辑器打开，就能看到它最原始的样貌了。</p><p>![](<a href="http://cdn.leafii.top/img/Screen">http://cdn.leafii.top/img/Screen</a> Shot 2022-06-05 at 23.44.57.png)</p><ul><li><code>pd.read_csv()</code></li></ul><p>​使用Python的open打开纯文本文件：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"data/体检数据.csv"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class="language-none"><code class="language-none">学号,姓名,身高,体重,肺活量1,小明,168,60,32002,小黄,187,80,38003,小花,170,70,3400</code></pre><p>​使用pandas的<code>read_csv()</code>方法：</p><pre class="language-python" data-language="python"><code class="language-python">df_csv <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">"data/体检数据.csv"</span><span class="token punctuation">,</span> index_col<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>df_csv</code></pre><pre class="language-none"><code class="language-none">学号,姓名,身高,体重,肺活量1,小明,168,60,32002,小黄,187,80,38003,小花,170,70,3400</code></pre><p>​有的时候，你不能保证别人给你的数据，是不是一份标准格式的数据，比如别人不喜欢用 <code>,</code> 来分隔数据点， 而是喜欢用什么乱七八糟的 <code>=</code> 来分隔。这时，Pandas 帮你考虑到了这种问题， 你可以挑选要用哪个字符来识别这些分隔。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"data/体检数据_sep.csv"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>df_csv <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">"data/体检数据_sep.csv"</span><span class="token punctuation">,</span> index_col<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">"="</span><span class="token punctuation">)</span>df_csv</code></pre><p>​提到 csv，你可能还会想用 Excel 打开看看，但是提到 txt，一般你也不会想用 Excel 打开了吧。用 Pandas 打开一个 txt 文件和打开一个 csv 文件，、 其实本质上是一样的，都是打开一个纯文本文件。所以下面我再打开一下 txt。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"data/体检数据_sep.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>df_txt <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">"data/体检数据_sep.txt"</span><span class="token punctuation">,</span> index_col<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">"="</span><span class="token punctuation">)</span>df_txt</code></pre><ul><li><code>df.to_csv()</code></li></ul><p>​能打开，我们就能保存，保存方法同样很简单，只需要 <code>df.to_csv()</code> 就好了，甚至，你还能保存到 Excel 文件，在 Pandas 中它们是可以互相转换的。 同理用 <code>read_excel()</code> 打开的，也能存成 <code>to_csv()</code>。</p><pre class="language-python" data-language="python"><code class="language-python">df_txt<span class="token punctuation">.</span>to_csv<span class="token punctuation">(</span><span class="token string">"data/体检数据_sep_修改.csv"</span><span class="token punctuation">)</span>df_txt<span class="token punctuation">.</span>to_excel<span class="token punctuation">(</span><span class="token string">"data/体检数据_sep_修改.xlsx"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"读保存后的 csv"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">"data/体检数据_sep_修改.csv"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"读保存后的 xlsx"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>pd<span class="token punctuation">.</span>read_excel<span class="token punctuation">(</span><span class="token string">"data/体检数据_sep_修改.xlsx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​做数据分析和机器学习，会用上面的方法来读 Excel 或者是纯文本，我们就已经解决了大部分的需求了。下面我来介绍几个我觉得 Pandas 的额外几个有趣的读取方式。</p><h3 id="其它有趣的"><a href="#其它有趣的" class="headerlink" title="其它有趣的"></a>其它有趣的</h3><ul><li><code>pd.read_clipboard()</code></li></ul><p>​从剪切板里面读取数据，这个很有意思，使用场景并不多，但是指不定哪天你要用 Python 写 APP 的时候，就能用到这个，不是有很多 APP 会识别你的剪切板， 方便你直接复制数据吗。这个功能说不定就能派上用场。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_clipboard<span class="token punctuation">(</span><span class="token punctuation">)</span>df</code></pre><ul><li><code>pd.read_html()</code></li></ul><p>​另外一个是从网页中获取表格型数据，就像下面这个表格。我们也能用 Pandas 调取解析网页当中的表格数据。</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_html<span class="token punctuation">(</span><span class="token string">"https://mofanpy.com/tutorials/data-manipulation/pandas/read-save/"</span><span class="token punctuation">)</span>df</code></pre><p>​还有一些功能，比如让 Pandas 读数据库，读 Json 等，你都可能在后期自己开发的时候偶尔用到。只要用到的时候，查查 <a href="https://pandas.pydata.org/docs/reference/io.html">Pandas 官方文档</a> 还是很有帮助的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​大千世界，数据也是多样的，Pandas 量身为你定制了很多读取数据的方法。从做数据分析和机器学习最常用的 Excel、csv、txt 数据等，到 html，剪切板等有趣的数据类型， 一个 Pandas 都可以帮你搞定。了解完读存数据，接下来，我们就来认真了解，数据在 Pandas 中到底是一个什么样的东西。</p><h2 id="Pandas中的数据是什么"><a href="#Pandas中的数据是什么" class="headerlink" title="Pandas中的数据是什么"></a>Pandas中的数据是什么</h2><p>​上面我们已经提到了在分析数据时最基础的操作就是“用Pandas打开数据文件”，不过我们并没有详细说这份打开的数据它的格式是什么样。但是要了解我们如何更改加工数据，我们必然还是需要了解在Pandas中的数据格式是什么。</p><p>​简单来说，Pandas支持最好的是一维和二维数组，一维数组就是一个序列，一条数据，而二维数据是我们生活中更加常见的种类，基本上所有Excel数据都是二维数据，有横纵交替，用两个维度来定位这个数据。</p><p>​下面来说说Pandas中的一维二维数据特性。</p><h3 id="数据序列Series"><a href="#数据序列Series" class="headerlink" title="数据序列Series"></a>数据序列Series</h3><ul><li>创建</li></ul><p>​一串Python List你肯定不陌生，Pandas中的Series的核心其实就是一串类似于Python List的序列。只是它要比Python List丰富很多，有更多的功能属性。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pdl <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">]</span>s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"list:"</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"series:"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">list: [11, 22, 33]series: 0    111    222    33dtype: int64</code></pre><p>​可见Pandas Series和Python List有很大的区别：Pandas Series帮我们额外维护了一份索引。有这个索引的意义是你可以使用自己喜欢的索引来检索数据：</p><pre class="language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>l<span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>s</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">a    11b    22c    33dtype: int64</code></pre><p>​所以，只要是有索引形式的结构，都可以搞成 Series，比如下面这样：</p><pre class="language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token number">33</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>s</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">a    11b    22c    33dtype: int64</code></pre><p>​后文中的DataFrame也可以使用字典来创建噢。</p><ul><li>转换Numpy</li></ul><p>​既然Python中的List可以用来创建Series，那么使用Numpy也可以创建：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nps <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>s</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">a    0.689052b    0.284041c    0.616957dtype: float64</code></pre><p>​将Series回退到Numpy array或者List：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"array:"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>to_numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"list:"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>values<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># array: [11 22 33]</span><span class="token comment"># list: [11, 22, 33]</span></code></pre><h3 id="数据表DataFrame"><a href="#数据表DataFrame" class="headerlink" title="数据表DataFrame"></a>数据表DataFrame</h3><p>​Pandas首先支持的就是序列数据和表格数据，因为这两种是日常生活中最常用的数据保存和编辑格式了，我们看看如何用Pandas的DataFrame维护一张数据表吧。</p><ul><li>创建</li></ul><p>​在上一节数据文件读取的教学中，你load到的数据实际上就是一个DataFrame，举个简单的例子，将一个二维数组变成Pandas的DataFrame：</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   0  10  1  21  3  4</code></pre><p>​显然，它创建出来的df在真实数据外围，还包上了一层其他的数据（0，1），在DataFrame中，这是用来索引行&#x2F;列的序号，如果要按位置来选去其中的值，也可以这么干。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#第0行，第1列</span><span class="token comment"># 或 第一个维度中的第0号，第二个维度中的第1号</span>df<span class="token punctuation">.</span>at<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token comment">#2</span></code></pre><p>​Pandas 中还有很多方式来选取和改变数据值，请按捺一下激动的小心情， 我们将在下节内容中具体介绍。</p><p>​自动创建的索引序号并不是很可读。我们还能将这些序号换成人类更好理解的文字标签信息:</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"col1"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"col2"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   col1  col20     1     21     3     4</code></pre><p>​可以从结果看出，其实字典中的 key 会被当成是数据中的 column，而 value 会被当做是 row，这个非常符合你在 Excel 中的使用习惯。 因为往往随着数据量变大，你用鼠标滚轮滚动查看不同数据的时候，天然的比较喜欢上下查看不同的数据样本，而不是左右查看，所以一般都是左右记的是数据标签（特征）， 上下排列的是不同数据样本。</p><p>​见识了字典变 DataFrame，其实 Series 也是可以组合变成 DataFrame 的，而且这也非常符合常理， 如果我从 DataFrame 中取出一个 Column， 这不就变成了一条 Series 了吗？</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">"col1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"取出来之后的 type:"</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">"col1"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">0    11    3Name: col1, dtype: int64取出来之后的 type: &lt;class &#39;pandas.core.series.Series&#39;&gt;</code></pre><p>​将两个Series拼接起来：</p><pre class="language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"col1"</span><span class="token punctuation">:</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"col2"</span><span class="token punctuation">:</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>df</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   col1  col20     1     21     3     4</code></pre><p>​来看看 Series 和 DataFrame 构建索引的方式：</p><pre class="language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"col1"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"col2"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">a    1.0b    2.0c    3.0dtype: float64   col1  col2a     1     2b     3     4</code></pre><p>​既然 DataFrame 的 Column 和 Index 这么有意思，十有八九，你会想取出来用一用这些 Column 和 Index，比如你数据比较大的时候，想初步看看这份数据涉及了多少特征， 数据的 index 有多少种的时候，你可以直接获取到这些信息。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>index<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>columns<span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">Index([&#39;a&#39;, &#39;b&#39;], dtype&#x3D;&#39;object&#39;)Index([&#39;col1&#39;, &#39;col2&#39;], dtype&#x3D;&#39;object&#39;)</code></pre><p>​如果写前端的朋友，你们时常会遇到 json 形式的数据，比如可以像下面这样处理。</p><pre class="language-python" data-language="python"><code class="language-python">my_json_data <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span><span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">"height"</span><span class="token punctuation">:</span> <span class="token number">111</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span><span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token string">"height"</span><span class="token punctuation">:</span> <span class="token number">123</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span>pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>my_json_data<span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"jack"</span><span class="token punctuation">,</span> <span class="token string">"rose"</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​Pandas 真的用心良苦，为我们广大数据同胞提供了这么多这么丰富的接口。学会这样观看数据，我们在分析和处理数据的时候就更有把握了。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>​Pandas 中，为了我们提供了日常最常用的数据存储方式，分别是 Series 的一维数据，和 DataFrame 的二维数据，在机器学习中，我们常会接触到 3 维甚至是更高维度， 但是在分析数据的时候，特别是，要结合 Excel 来分析数据的时候，二维数据才是最常用的。</p><h2 id="选取数据"><a href="#选取数据" class="headerlink" title="选取数据"></a>选取数据</h2><p>​Pandas的数据结构和你管理Excel很像，特别是DataFrame就约等于Excel当中的sheet。我们非常适应用Excel来选择和修改数据，但是如果把它程序化，用代码来修改和选取的时候，我们该如何操作呢？</p><p>​Pandas的数据选取和List，Numpy Array还是有挺大差别的，因为它想要维护了很多的人类可读的索引信息，所以它在索引的时候，也有不一样的处理方式，今天我们就来看看Pandas是如何处理数据选取和修改的吧。</p><h3 id="多种选取方式"><a href="#多种选取方式" class="headerlink" title="多种选取方式"></a>多种选取方式</h3><p>​在Pandas中，有丰富的选取数据方式，这可比List，Dictionary，甚至是Numpy还要多样化。我们既能通过文字标签来定位数据，也能通过数值序号来定位。所以为了实现这种多样性，Pandas对于数据的选取采用了不同类型的处理方法，比如<code>.loc</code>,<code>.iloc</code>等，我们来一一介绍吧。</p><p>​面对应用比较多的工作学习场景，我先以 Excel 型的表格数据举例，请你帮我构建一下下面这份 DataFrame：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>  data<span class="token punctuation">,</span>  index<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"abcdef"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  columns<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>dfdata</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">    A   B   C   Da -12 -11 -10  -9b  -8  -7  -6  -5c  -4  -3  -2  -1d   0   1   2   3e   4   5   6   7f   8   9  10  11array([[-12, -11, -10,  -9],       [ -8,  -7,  -6,  -5],       [ -4,  -3,  -2,  -1],       [  0,   1,   2,   3],       [  4,   5,   6,   7],       [  8,   9,  10,  11]])</code></pre><h3 id="选Column"><a href="#选Column" class="headerlink" title="选Column"></a>选Column</h3><p>​看到上面的这份数据之后，我们发现DataFrame会分Column和Row（index）。在机器学习中，通常Column是特征，Row是数据样本，要对某个特征进行分析的时候，比如要做特征数值分布的分析，我们得把特征取出来吧，那么可以进行如下操作：</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span><span class="token string">"B"</span><span class="token punctuation">]</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">a   -11b    -7c    -3d     1e     5f     9Name: B, dtype: int64</code></pre><p>​选一个就这么简单，但偶尔还想多选几个特征，怎么搞呢？回忆一下之前Numpy中的Array是怎么选的？</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"numpy:\n"</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\ndf:\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"C"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">numpy: [[-10 -11] [ -6  -7] [ -2  -3] [  2   1] [  6   5] [ 10   9]]df:     C   Ba -10 -11b  -6  -7c  -2  -3d   2   1e   6   5f  10   9</code></pre><p>​现在可以选column了，那意味着肯定能将Index（Row）的信息也一起考虑到数据筛选的工作当中了。</p><h3 id="loc"><a href="#loc" class="headerlink" title="loc"></a>loc</h3><p>​在Numpy中选取数据一般是按照在维度上的排序来定位的。比如对于你刚刚创建的Numpy数据<code>data</code>：</p><pre class="language-python" data-language="python"><code class="language-python">data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">array([[-3, -2]])</code></pre><p>​而在DataFrame中，同样是上述功能，你也可以这么干：</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">"c"</span><span class="token punctuation">:</span><span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span><span class="token string">"D"</span><span class="token punctuation">]</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">   B  C  Dc -3 -2 -1d  1  2  3</code></pre><p>​不知道你有没有发现，这个 <code>&quot;c&quot;:&quot;d&quot;</code> 和 <code>&quot;B&quot;:&quot;D&quot;</code> 明明对应的是上面 <code>data</code> 的 <code>[2:3]</code> 和 <code>[1:3]</code>，但为什么它还包含了最后一位的 <code>&quot;d&quot;</code> 和 <code>&quot;D&quot;</code> 呢？这的确是 Pandas 的一个用心良苦，我猜他是为了更贴切 Excel 中的使用原则吧，想一想，如果你像下面这样， 在选择 Excel 要被筛选的数据时，从 b 选到 d，其实你是有包含 d 的。所以我说，Pandas 这么设计，原因之一也应该是为了照顾我们吧。</p><p>​除了筛选一个片段，还可以像 Numpy 那样单个单个的选取。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"numpy:\n"</span><span class="token punctuation">,</span>data<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\ndf:\n"</span><span class="token punctuation">,</span>df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">numpy: [[ 0  1  2  3] [-8 -7 -6 -5]]df:    A  B  C  Dd  0  1  2  3b -8 -7 -6 -5</code></pre><p>​上面这两个例子，不难看出，Pandas 选取数据的底层逻辑，和 Python Numpy 的类似，都是按维度的先后（先选第一维，再第二，以此类推）， 开始选取。按数据的索引找到维度上的对应索引区域。</p><p>​下面我再来整个有趣的，如果我不按字母顺序去组织 index，比如从原本的 <code>index=abcdef</code> 换成 <code>index=beacdf</code>， 猜猜下面的这份数据索引会找到哪一份子数据？</p><pre class="language-python" data-language="python"><code class="language-python">df2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>  data<span class="token punctuation">,</span>  index<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"beacdf"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  columns<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df2<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">"e"</span><span class="token punctuation">:</span><span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">    A   B   C   Db -12 -11 -10  -9e  -8  -7  -6  -5a  -4  -3  -2  -1c   0   1   2   3d   4   5   6   7f   8   9  10  11   A  B  C  De -8 -7 -6 -5a -4 -3 -2 -1c  0  1  2  3</code></pre><h3 id="iloc"><a href="#iloc" class="headerlink" title="iloc"></a>iloc</h3><p>​看完面向 Excel 编程，我们再来回到编程本身，用程序的思维去选取数据。这意味着什么？用最朴素的方法，也是意味着能更快找到数据位置，比如直接用位置信息来筛选。 Numpy 不就是这么干的吗？这时 <code>.iloc</code> 功能就派上用场了。</p><p>​看看<code>iloc</code>的功能是什么：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"numpy:\n"</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\ndf:\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">numpy: [[-3 -2]]df:    B  Cc -3 -2</code></pre><p>​简直和 Numpy 的模式一模一样，就是结果中多了一个 DataFrame 的标签信息。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"numpy:\n"</span><span class="token punctuation">,</span>data<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\ndf:\n"</span><span class="token punctuation">,</span>df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">numpy: [[ 0  1  2  3] [-8 -7 -6 -5]]df:    A  B  C  Dd  0  1  2  3b -8 -7 -6 -5</code></pre><h3 id="loc和iloc混搭"><a href="#loc和iloc混搭" class="headerlink" title="loc和iloc混搭"></a>loc和iloc混搭</h3><p>​难免有时候，我们需要混搭 loc 和 iloc 的方式，比如我想要选取第 2 到第 4 位数据的 A C 两个特征，这时咋办？ 想想 Pandas 这么牛逼，肯定有办法解决。的确，它解决的方法是采用索引转换的方式，比如我在 <code>.loc</code> 模式下，将序号索引转换成 <code>.loc</code> 的标签索引。</p><pre class="language-python" data-language="python"><code class="language-python">row_labels <span class="token operator">=</span> df<span class="token punctuation">.</span>index<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"row_labels:\n"</span><span class="token punctuation">,</span> row_labels<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\ndf:\n"</span><span class="token punctuation">,</span>df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>row_labels<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">row_labels: Index([&#39;c&#39;, &#39;d&#39;], dtype&#x3D;&#39;object&#39;)df:    A  Cc -4 -2d  0  2</code></pre><p>​再看看 Column 的 labels 怎么取:</p><pre class="language-python" data-language="python"><code class="language-python">col_labels <span class="token operator">=</span> df<span class="token punctuation">.</span>columns<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"col_labels:\n"</span><span class="token punctuation">,</span> col_labels<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\ndf:\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>row_labels<span class="token punctuation">,</span> col_labels<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">col_labels: Index([&#39;A&#39;, &#39;D&#39;], dtype&#x3D;&#39;object&#39;)df:    A  Dc -4 -1d  0  3</code></pre><p>​清楚了吧，用 <code>df.index</code> 和 <code>df.columns</code> 来调取到全部的标签，然后在用像 Numpy index 索引的方式把这些标签给筛选出来，放到 <code>.loc</code> 里面用。 那反过来，我想要找 A C 两个特征的 前两个数据，这时咋办？</p><pre class="language-python" data-language="python"><code class="language-python">col_index <span class="token operator">=</span> df<span class="token punctuation">.</span>columns<span class="token punctuation">.</span>get_indexer<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"col_index:\n"</span><span class="token punctuation">,</span> col_index<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\ndf:\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> col_index<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">col_index: [0 1]df:     A   Ba -12 -11b  -8  -7</code></pre><p>​同理，<code>df.index.get_indexer([&quot;a&quot;, &quot;b&quot;])</code> 也可以这样获取到 label 对应的 index 信息。</p><h3 id="条件过滤筛选"><a href="#条件过滤筛选" class="headerlink" title="条件过滤筛选"></a>条件过滤筛选</h3><p>​按条件过滤其实是一件很有趣的事，因为很多情况我们事先也不知道具体的 index 是什么，我们更想要从某些条件中筛选数据。 下面我举几个例子，大家应该很容易 get 到其中的奥秘。</p><ul><li><strong>选在 A Column 中小于 0 的那些数据</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span>df<span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">]</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">    A   B   C  Da -12 -11 -10 -9b  -8  -7  -6 -5c  -4  -3  -2 -1</code></pre><ul><li><strong>选在第一行数据不小于 -10 的数据</strong></li></ul><p>​这里注意了你可以用两种方式，一种是 <code>~</code> 来表示 <code>非</code> 什么什么，第二种是直接用 <code>&gt;=-10</code> 来筛选。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"~:\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">~</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n>=:\n"</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">~:     C   Da -10  -9b  -6  -5c  -2  -1d   2   3e   6   7f  10  11&gt;&#x3D;:     C   Da -10  -9b  -6  -5c  -2  -1d   2   3e   6   7f  10  11</code></pre><ul><li><strong>选在第一行数据不小于 -10 或小于 -11 的数据</strong></li></ul><p>​同上面类似的，我还能用或 <code>|</code> 来表示 or 的意思, <code>&amp;</code> 表述 and。比如选在第一行数据不小于 -10 或小于 -11 的数据:</p><pre class="language-python" data-language="python"><code class="language-python">i0 <span class="token operator">=</span> df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">~</span><span class="token punctuation">(</span>i0 <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>i0 <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">    A   C   Da -12 -10  -9b  -8  -6  -5c  -4  -2  -1d   0   2   3e   4   6   7f   8  10  11</code></pre><p>​所以你看，你可以用 <code>.loc</code> 或者 <code>.iloc</code> 来做过滤处理。然后用 <code>.loc</code> 来做筛选。为什么用 <code>.iloc</code> 来筛选呢，比如下面这样：</p><pre class="language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">~</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment">#报错</span></code></pre><p>​这样写居然会导致报错，为什么呢？你分析分析，把 <code>~(df.iloc[0] &lt; -10)</code> 这个筛选条件打印出来看看它是什么值。然后想一想 <code>.iloc</code> 能够接受的值是啥？ 想清楚了，这个问题就迎刃而解了。</p><pre class="language-none"><code class="language-none">A    FalseB    FalseC     TrueD     TrueName: a, dtype: bool</code></pre><h3 id="Series和DataFrame类似"><a href="#Series和DataFrame类似" class="headerlink" title="Series和DataFrame类似"></a>Series和DataFrame类似</h3><p>​既然二维的 DataFrame 你都已经玩过了，Series 的操作就不在话下了。</p><pre class="language-python" data-language="python"><code class="language-python">list_data <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>  list_data<span class="token punctuation">,</span>   index<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">"abcdefgh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>s</code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">a   -4b   -3c   -2d   -1e    0f    1g    2h    3dtype: int64</code></pre><ul><li>按标签筛选数据 <code>.loc</code></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token string">"f"</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">a   -4g    2c   -2dtype: int64 c   -2d   -1e    0f    1dtype: int64</code></pre><ul><li>按 index 筛选数据 <code>.iloc</code></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">d   -1b   -3f    1dtype: int64 c   -2d   -1dtype: int64</code></pre><ul><li><code>iloc</code> 和 <code>loc</code> 互相混用</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span>s<span class="token punctuation">.</span>index<span class="token punctuation">.</span>get_indexer<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>s<span class="token punctuation">.</span>index<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">c   -2d   -1dtype: int64 d   -1c   -2dtype: int64</code></pre><ul><li>按条件过滤筛选</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>s <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">(</span>s <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">(</span>s <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span></code></pre><p>​运行结果：</p><pre class="language-none"><code class="language-none">a   -4b   -3c   -2d   -1e    0f    1g    2dtype: int64 d   -1dtype: int64 a   -4b   -3c   -2d   -1h    3dtype: int64</code></pre><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>​Pandas 的数据筛选方法比 Numpy 丰富多了，介绍的篇幅也有点多，我日常用的最多的还是用条件来筛选，比如在处理机器学习的脏数据的时候，要用很多筛选逻辑。 有时甚至我会觉得 Numpy 的筛选方式不够多，专门把 Numpy 数据转换成 Pandas 数据，然后再用 Pandas 提供的丰富工具处理数据，再转回 Numpy。 相信你用熟了之后，数据处理将要简单很多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy关于数据</title>
      <link href="/2022/05/29/Numpy%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/05/29/Numpy%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy关于数据"><a href="#Numpy关于数据" class="headerlink" title="Numpy关于数据"></a>Numpy关于数据</h1><h2 id="Numpy读取保存数据"><a href="#Numpy读取保存数据" class="headerlink" title="Numpy读取保存数据"></a>Numpy读取保存数据</h2><p>​        数据一般都被记录在存储当中，我们常见的小规模数据大多是 Excel 的 xlsx，csv, json, 或 txt，log 等等格式。 当我们要处理数据，特别是运算数据的时候，我们都能拿 Python 读取出来。而在大数据这种情况下，数据是存储在 MySQL，Mongodb 等这种数据库中的， 同样，Python 也提供了很多接口来读取这些数据。</p><p>​        今天我们想聊聊其中的一部分，用 Numpy 来直接读取数据（通常是纯数值形式的数据），并加以运算的流程。而且看看我们可以如何保存 Numpy 里的数据。</p><span id="more"></span><h3 id="加载常用数据格式"><a href="#加载常用数据格式" class="headerlink" title="加载常用数据格式"></a>加载常用数据格式</h3><ul><li><code>np.loadtxt(), np.fromstring()</code></li></ul><p>​        一般我们都把数据存放在文件中，数据一般长这样：</p><p>![](<a href="http://cdn.leafii.top/img/Screen">http://cdn.leafii.top/img/Screen</a> Shot 2022-06-02 at 22.36.26.png)</p><p>​        如果用Excel打开数据，也有可能像下面这样：</p><p><img src="http://cdn.leafii.top/img/20220603170252.png" loading="lazy"></p><p>​        下面，请使用已经为你准备好了的数据，从上篇文章的里面拷贝了一份，作为csv格式存起来了，使用以下的代码查看文件中的数据：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data file in directory:"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"data/data.csv"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">data file in directory: [&#39;data.csv&#39;, &#39;data.txt&#39;] # StudentID, Age, Score20131,10,6720132,11,8820133,12,9820134,8,10020135,9,7520136,12,78</code></pre><p>​        如果现在要模拟经常要加载的情况，从文件中加载出来。如果使用纯python，可以一行一行读出来，然后保存在list中；但是也可以直接用numpy的方式读取出来：使用<code>np.loadtxt()</code>功能，我们就可以自定义地读取出来数据了。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npdata <span class="token operator">=</span> np<span class="token punctuation">.</span>loadtxt<span class="token punctuation">(</span><span class="token string">"data/data.csv"</span><span class="token punctuation">,</span> delimiter<span class="token operator">=</span><span class="token string">","</span><span class="token punctuation">,</span> skiprows<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[[20131    10    67] [20132    11    88] [20133    12    98] [20134     8   100] [20135     9    75] [20136    12    78]]</code></pre><p>​        在<code>loadtxt</code>的参数中，我们传入<code>，</code>让numpy在做数据分隔的时候，以逗号作为分隔符。同时<code>skiprow</code>可以skip掉第一行的描述型文字（默认也会自动skip掉第一行），还有读取出来的数据要放到定义好了的&#96;dtype&#x3D;np.int类型的array中，这一行的功能就可以轻松读取这个csv文件的数据了。</p><p>​        请注意：<code>np.loadtxt()</code>为什么不叫<code>np.loadcsv()</code>呢？因为csv数据也属于纯文本数据，如果想要加载后缀名为<code>txt</code>的文件，也是没问题的。以上就是最普通的一种加载数据方式。下面我们来看一种更加有趣的加载过程。能不能直接从字符中加载数据呢？</p><p>​        有时候，我需要对字符串加工处理后，直接读这个加工之后的字符串。</p><pre class="language-python" data-language="python"><code class="language-python">row_string <span class="token operator">=</span> <span class="token string">"20131, 10, 67, 20132, 11, 88, 20133, 12, 98, 20134, 8, 100, 20135, 9, 75, 20136, 12, 78"</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>fromstring<span class="token punctuation">(</span>row_string<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">","</span><span class="token punctuation">)</span>data <span class="token operator">=</span> data<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[[20131    10    67] [20132    11    88] [20133    12    98] [20134     8   100] [20135     9    75] [20136    12    78]]</code></pre><p>​        请注意，这种方法目前只能读取一个数值序列，读完这个序列之后，可以再使用numpy的<code>reshape</code>方法把数据定义成你想要的样子。另外要注意的一点是对比<code>np.loadtxt(delimiter=&quot;,&quot;)</code>和<code>np.fromstring(sep=&quot;,&quot;)</code>这两个用来判断分隔符的参数，它们的参数命名是不一样的。</p><p>​        numpy可以读取<code>csv</code>和<code>txt</code>格式的数据，但是无法读取Excel中的xlsx数据格式，未来可以使用Pandas库进行xlsx数据格式的读取。</p><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>​        在日常生活中经常会碰到的数据格式，都能用Numpy读，在读取完之后或者处理完数据之后，如果想把数据保存起来，怎么办呢？好在Numpy还是挺人性化的，也有丰富的方法来处理保存数据这件事。</p><ul><li><code>np.savetxt()</code></li></ul><p>​        Numpy存数据，存哪种数据格式，取决于你想不想这份数据被人查看，或者被其他语言编辑，如果想的话，你就会保存成一些通用的数据格式，比如<code>csv</code>或<code>txt</code>。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"numpy data:\n"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>np<span class="token punctuation">.</span>savetxt<span class="token punctuation">(</span><span class="token string">"data/save_data.csv"</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> delimiter<span class="token operator">=</span><span class="token string">","</span><span class="token punctuation">,</span> fmt<span class="token operator">=</span><span class="token string">'%s'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data file in directory:"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"data/save_data.csv"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">numpy data: [[20131    10    67] [20132    11    88] [20133    12    98] [20134     8   100] [20135     9    75] [20136    12    78]]data file in directory: [&#39;data.csv&#39;, &#39;data.txt&#39;, &#39;save_data.csv&#39;] 20131,10,6720132,11,8820133,12,9820134,8,10020135,9,7520136,12,78</code></pre><ul><li><code>np.save(), np.savez(), np.savez_compressed()</code></li></ul><p>​        还有一些Numpy独有的模式，那就是用二进制的格式保存。如果你没有想让别人看你的数据，你只想自己使用Numpy时加载的话，那你完全就可以用这种方式存储下来。请注意，使用<code>np.save()</code>来保存，保存的是一个以<code>.npy</code>结尾的二进制文件。加载的时候，我们能用<code>np.load()</code>直接加载这个二进制数据文件。</p><pre class="language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">"data/save_data.npy"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data file in directory:"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>npy_data <span class="token operator">=</span> np<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"data/save_data.npy"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>npy_data<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">data file in directory: [&#39;data.csv&#39;, &#39;data.txt&#39;, &#39;save_data.csv&#39;, &#39;save_data.npy&#39;][[20131    10    67] [20132    11    88] [20133    12    98] [20134     8   100] [20135     9    75] [20136    12    78]]</code></pre><p>​        还有一种神奇的保存方式，在一个numpy文件中保存多个numpy array。有时候，你是分开多个array来存放不同类型的数据，比如机器学习中的traindata和testdata。这时我们能用<code>np.savez()</code>保存一个<code>.npz</code>文件将这两个array同时存储好。</p><pre class="language-python" data-language="python"><code class="language-python">train_data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>test_data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>savez<span class="token punctuation">(</span><span class="token string">"data/save_data.npz"</span><span class="token punctuation">,</span> train<span class="token operator">=</span>train_data<span class="token punctuation">,</span> test<span class="token operator">=</span>test_data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data file in directory:"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">data file in directory: [&#39;data.csv&#39;, &#39;data.txt&#39;, &#39;save_data.csv&#39;, &#39;save_data.npy&#39;, &#39;save_data.npz&#39;]</code></pre><p>​        <code>np.savez()</code> 第二、三个参数名 <code>train=xx</code>, <code>test=xx</code> 其实是可以自定义的，这些参数名会作为之后我们加载回来的索引标签。</p><pre class="language-python" data-language="python"><code class="language-python">npz_data <span class="token operator">=</span> np<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"data/save_data.npz"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"train:"</span><span class="token punctuation">,</span> npz_data<span class="token punctuation">[</span><span class="token string">"train"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test:"</span><span class="token punctuation">,</span> npz_data<span class="token punctuation">[</span><span class="token string">"test"</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">train: [1 2 3]test: [11 22 33]</code></pre><p>用 <code>np.savez()</code> 的时候，还有一个方法可以让你更节省空间，那就是用 <code>np.savez_compressed()</code> 来做一次数据压缩。</p><pre class="language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>savez_compressed<span class="token punctuation">(</span><span class="token string">"data/save_data_compressed.npz"</span><span class="token punctuation">,</span> train<span class="token operator">=</span>train_data<span class="token punctuation">,</span> test<span class="token operator">=</span>test_data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data file in directory:"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>npz_data_compressed <span class="token operator">=</span> np<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"data/sace_data_compressed.npz"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"train:"</span><span class="token punctuation">,</span> npz_compressed<span class="token punctuation">[</span><span class="token string">"train"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test:"</span><span class="token punctuation">,</span> npz_data_compressed<span class="token punctuation">[</span><span class="token string">"test"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">import</span> os<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"compressed file size:"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>getsize<span class="token punctuation">(</span><span class="token string">"data/save_data_compressed.npz"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"original file size:"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>getsize<span class="token punctuation">(</span><span class="token string">"data/save_data.npz"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">data file in directory: [&#39;data.csv&#39;, &#39;data.txt&#39;, &#39;save_data.csv&#39;, &#39;save_data.npy&#39;, &#39;save_data.npz&#39;, &#39;save_data_compressed.npz&#39;]train: [1 2 3]test: [11 22 33]compressed file size: 402original file size: 528</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        说了这么多用 numpy 的方式读取与保存的方法，可见 numpy 还是很用心在做数据这件事的。如果你喜欢纯文本，我们看上去比较有意义的存储格式，那你就用 txt 或者 csv 这种方式，如果你追求存储空间和速度，我建议还是用二进制来存储吧~</p><h2 id="标准数据生成"><a href="#标准数据生成" class="headerlink" title="标准数据生成"></a>标准数据生成</h2><p>​        数据是多变的，不光是数据的形态多变，里面的数值也是多变的。通常，我们在创建一个Numpy Array的时候，是想带着一些数值来初始化的，比如我想先要一个全是0的Array</p><p>​所以这节内容我们来说一说怎么带着数值初始化，可以带着怎样的数值初始化。</p><h3 id="创建统一数据"><a href="#创建统一数据" class="headerlink" title="创建统一数据"></a>创建统一数据</h3><ul><li><code>np.zeros(),np.ones(),np.full()</code></li></ul><p>​        首先来点简单的，初始化Array的时候，让他们全部为某数。最简单的就是全0或者全1的数据。</p><p><img src="http://cdn.leafii.top/img/20220604123440.png" loading="lazy"></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npzeros <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"zeros:\n"</span><span class="token punctuation">,</span> zeros<span class="token punctuation">)</span>ones <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nones:\n"</span><span class="token punctuation">,</span> ones<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">zeros: [[0. 0. 0.] [0. 0. 0.]]ones: [[1. 1.] [1. 1.] [1. 1.]]</code></pre><p>​        当我们创建这些数据时，我们不仅仅是可以给定创建的具体数值是0还是1，而且还能指定这个数据的shape是什么。创建出来之后，就可以把它当作普通的Array数据使用就好了，要<code>reshape，transpose，sum</code>等操作，都是可以进行的。</p><p>​        我们可以创建0或1的数据，那我们能不能创建其他数值的数据？答案是肯定的，使用<code>np.full()</code>功能就好了。同样，我们先输入这份数据的shape，然后指定这份数据全部元素的数值。</p><pre class="language-python" data-language="python"><code class="language-python">nines <span class="token operator">=</span> np<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>nines<span class="token punctuation">)</span><span class="token comment">#[[9 9 9]</span><span class="token comment"># [9 9 9]]</span></code></pre><p>​        在处理shape的时候，有一件有趣的事：如果我们手头已经有一份数据，我们想创建一个和它类型一样，大小一样的另一份数据，我们可以调用<code>np.xxx_like()</code>这种形式的功能。看下面的例子：</p><pre class="language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">)</span>ones <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span>data<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>ones_like <span class="token operator">=</span> np<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ones:"</span><span class="token punctuation">,</span> ones<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> ones<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ones_like:"</span><span class="token punctuation">,</span> ones_like<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> ones_like<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ones_like value:\n"</span><span class="token punctuation">,</span> ones_like<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">ones: (2, 3) int32ones_like: (2, 3) int32ones_like value: [[1 1 1] [1 1 1]]</code></pre><ul><li><code>np.zeros_like(),np.ones_like(),np.full_like()</code></li></ul><p>​因为dtype和shape都和源数据一样，那么它们之间做加减乘除运算就很契合了。其实<code>ones_like()</code>算是一种偷懒功能；同理，我们还有<code>np.zeros_like()</code>和<code>np.full_like()</code>这两种。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>full_like<span class="token punctuation">(</span>data<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[[0 0 0] [0 0 0]][[6 6 6] [6 6 6]]</code></pre><h3 id="创建规则数据"><a href="#创建规则数据" class="headerlink" title="创建规则数据"></a>创建规则数据</h3><ul><li><code>np.arange(), np.linspace()</code></li></ul><p>​而创建有些规律的数据也是Numpy的拿手好戏。首先说一个最常见的<code>arange</code>功能，用来得到一个序列，如：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"python range:"</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># python range: [0, 1, 2, 3, 4]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"numpy arange:"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># numpy arange: [0 1 2 3 4]</span></code></pre><p>​同样，<code>np.arange()</code>也可以像<code>range()</code>一样，对范围做自定义变更或者跳跃取值。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># (start, end, step)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"python range:"</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># python range: [3, 5, 7, 9]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"numpy arange:"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># numpy arange: [3 5 7 9]</span></code></pre><p>​还有一个也是用来取一段数字中的值，这个也比较常用，特别是在画折线图的时候，我想要连续在一个区间内取间隔一致的数据点。里面的参数分别代表从start的值到end的值，一共返回这中间num个数据点。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># (start, end, num)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"linspace:"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># linspace: [-1.  -0.5  0.   0.5  1. ]</span></code></pre><p>​        更厉害的是，有时候我们会很纠结，上面是在-1 至 1 之间分了 4 个区域。 而我们想在-1 至 1 之间分 5 个区域，怎么搞？加一个 <code>endpoint=False</code> 就可以返回这 5 个区域的结节点了。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"5 segments:"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> endpoint<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 5 segments: [-1.  -0.6 -0.2  0.2  0.6]</span></code></pre><p>​还有很多做特殊规则的数据的方式，比如 <code>np.identity()</code>, <code>np.eye()</code>, <code>np.logspace()</code> 等等， 这个教学我先介绍一些常用的，当你有需要的时候，你再单个搜索就行了。</p><h3 id="快速创建再添加值"><a href="#快速创建再添加值" class="headerlink" title="快速创建再添加值"></a>快速创建再添加值</h3><ul><li><code>np.empty(), np.empty_like()</code></li></ul><p>​和 <code>np.ones()</code> 这种很相似的，有一个叫 <code>np.empty()</code> 功能，我想单独拎出来介绍一下。 如果你对运算速度有要求，你就得仔细听一下。</p><p>​<code>np.empty()</code> 功能，不会初始化新建 array 里面的数值，所以你会看到这里面的数值都是乱乱的。 <strong>注意，虽然乱乱的，但是它不是随机数哦，你不能把它当随机数使用。</strong> 想用随机数的话，我后面有单独一个教学讲随机数。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果</p><pre class="language-none"><code class="language-none">[[9.03433771e-308 5.09847862e-304 3.53009707e-305] [7.52473700e-302 8.90332017e-305 8.01478727e-302] [2.34157518e-301 6.86145138e-302 3.06135986e-301] [1.17801178e-300 8.83208360e-302 1.14834727e-302]]</code></pre><p>​不能作随机数，又没有具体数值，那么empty为什么存在呢？</p><ol><li>可以把它当成一个placeholder，作为一个容器先放着，之后满满的放数据进去</li><li>创建起来比<code>ones,zeros,full</code>都快一点</li></ol><p>​所以在这种情况下，我们才想使用<code>np.empty()</code>，编写代码查看用两种方法创建的速度：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> timet0 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    _ <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span>t1 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    _ <span class="token operator">=</span> np<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ones time:"</span><span class="token punctuation">,</span> t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"empty time:"</span><span class="token punctuation">,</span> t2 <span class="token operator">-</span> t1<span class="token punctuation">)</span><span class="token comment">#ones time: 0.015000104904174805</span><span class="token comment">#empty time: 0.002000093460083008</span></code></pre><p>​        因此我们能知道empty比ones快了很多很多，给你看一下它的日常使用场景：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> randomempty <span class="token operator">=</span> np<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"empty before:\n"</span><span class="token punctuation">,</span> empty<span class="token punctuation">)</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        empty<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">*</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"empty after:\n"</span><span class="token punctuation">,</span> empty<span class="token punctuation">)</span></code></pre><p>​        所以一般当我有一个数据要根据另一份数据生成的时候，无论我初始化是什么值，到最终都要全部被替换的时候，我就喜欢用 <code>np.empty()</code>。 ok，最后说一句，有 <code>np.empty()</code>，我们也有 <code>np.empty_like()</code> 用法和 <code>np.zeros_like()</code> 这种类似，很方便用的。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>​现在你能够按自己的想法初始化最符合你需要的数据啦。</p><h2 id="随机数和随机操作"><a href="#随机数和随机操作" class="headerlink" title="随机数和随机操作"></a>随机数和随机操作</h2><p>​计算机能模拟随机，是一件十分重要的事。因为计算机本来是一种执行确定步骤，返回确定结果的机器。但是你想要它模拟随机，就得有一些特殊处理。 好在 Python 自己有专门处理随机的功能。而 Numpy 作为 Python 的网红库，当然也自带了很丰富的随机功能。比如各式随机数的生成方式， 随机化当前数列等。甚至你还能加随机，复现一些随机后的结果。</p><h3 id="多种随机数生成"><a href="#多种随机数生成" class="headerlink" title="多种随机数生成"></a>多种随机数生成</h3><p>​提到随机，首先我们想到的当然是生成一批随机数，对这批随机数做计算啦。在深度学习中，这是一件非常重要的事，比如你常会随机生成神经网络的权重，生成遗传算法中的基因序列等等。</p><ul><li><code>np.random.rand(), np.random.random()</code></li></ul><p>​假设现在没有 Numpy，我们当然也能用 Python 自带的 <code>random</code> 来解决，但是效率会低不少。 用 Python 自带的 <code>random</code>，大概是怎么用的呢？</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">print</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 0.5015630814097707</span><span class="token comment"># 10</span></code></pre><p>​但是Python的<code>random</code>没有考虑数组类型的高效数据结构，所以我们在array类型的数据结构时，更喜欢直接使用Numpy来生成。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npdim1<span class="token punctuation">,</span> dim2 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>dim1<span class="token punctuation">,</span> dim2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 你还可以继续添加dim3等更多</span></code></pre><p>​运行结果</p><pre class="language-none"><code class="language-none">[[0.83325372 0.6412798 ] [0.32903089 0.41498545] [0.18548333 0.27637162]]</code></pre><p>​<code>np.random.rand()</code>是一种最方便去生成带shape的<code>[0,1)</code>之间取值的Array。还有一种写法可以实现同样目的：<code>np.random.random()</code>，在其中传入一个shape进去。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">[</span>dim1<span class="token punctuation">,</span> dim2<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​运行结果</p><pre class="language-none"><code class="language-none">[[0.51226037 0.13982879] [0.75661115 0.49357135] [0.01439348 0.00078817]]</code></pre><ul><li><code>np.random.randn(), np.random.randint()</code></li></ul><p>​除了生成<code>[0,1)</code>之间的随机数，Numpy还可以生成其他数值，或使用其他生成规则。比如按照<strong>标准正态分布</strong>去生成。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>dim1<span class="token punctuation">,</span> dim2<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果</p><pre class="language-none"><code class="language-none">[[-1.74779413 -1.81986096] [-0.97003389 -0.19717489] [ 1.29311087  1.51706469]]</code></pre><p>​使用<code>np.random.randint()</code>生成随机整数：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>low<span class="token operator">=</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> high<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#[ 5 -2  5  4 -2 -1  1 -2 -1  5]</span></code></pre><h3 id="给你施加随机"><a href="#给你施加随机" class="headerlink" title="给你施加随机"></a>给你施加随机</h3><ul><li><code>np.random.choice()</code></li></ul><p>​我们已经可以自动生成一批随机数啦，但是 Numpy 的好用功能可不止有这么一些简单的生成功能哦。它还可以对已有的数据做随机化处理。 比如我想随机从一组数据中选择，我就可以用 <code>np.random.choice()</code>。在做遗传算法的时候, 做基因重组配对，就需要经常使用到这个函数。</p><pre class="language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> np<span class="token punctuation">.</span>aray<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"选一个："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 选一个： 3</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"选多个："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>data<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 选多个： [2 6 1]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不重复地选多个（不放回）："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>data<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> replace<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 不重复地选多个(不放回)： [6 4 2]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"带权重地选择："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>data<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> p<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0.2</span><span class="token punctuation">,</span><span class="token number">0.8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 带权重地选择： [4 6 6 6 6 6 4 6 6 4]</span></code></pre><ul><li><code>np.random.shuffle(), np.random.permutation()</code></li></ul><p>​choice这个功能真的经常会用到。而在机器学习中，你也许会经常在epoch迭代训练数据的时候，碰到shuffle的概念。如果你在机器学习中没弄懂也没关系，给你补充一下。Numpy里也有<code>np.random.shuffle()</code>的功能，就是用来<strong>洗牌</strong>的。请注意：<strong>它会将源数据重新排列，如果你想保留原数据的话，记得使用<code>np.copy(data)</code>备份一下</strong></p><pre class="language-python" data-language="python"><code class="language-python">data_copy <span class="token operator">=</span> np<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>data<span class="token punctuation">)</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"源数据："</span><span class="token punctuation">,</span> data_copy<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"after shuffled:"</span>， data<span class="token punctuation">)</span><span class="token comment"># 源数据： [2 1 3 4 6]</span><span class="token comment"># shuffled: [6 2 1 3 4]</span></code></pre><p>​还有一个功能，<code>np.random.permutation()</code>, 它实现的是 <code>np.random.shuffle()</code> 的一种特殊形式。可以说是一种简单处理特殊情况的功能。 它有两个方便之处，1. 直接生成乱序的序列号，2. 对数据乱序。</p><p>而且相比 <code>np.random.shuffle()</code>，<strong>permutation 有一个好处，就是可以返回一个新数据，对原本的数据没有影响。而且还可以处理多维数据。</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"直接出乱序序列："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"多维数据在第一维度上乱序："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果</p><pre class="language-none"><code class="language-none">直接出乱序序列： [2 0 8 5 7 6 1 9 3 4]多维数据在第一维度上乱序： [[ 6  7] [ 2  3] [10 11] [ 4  5] [ 0  1] [ 8  9]]</code></pre><h3 id="随机分布"><a href="#随机分布" class="headerlink" title="随机分布"></a>随机分布</h3><ul><li><code>np.random.normal(), np.random.uniform()</code></li></ul><p>​对于统计学或者机器学习，我们在生成数据的时候，有时需要按照特定的统计学分布来生成，比如需要一个正态分布的抽样数据，或者均匀分布的数据抽样结果。 又或者是其他更高级的，比如泊松分布等等，都可以用 Numpy 来实现。这里我们只介绍一下在机器学习中比较常用的 正态分布 和 均匀分布。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># （均值，方差，size）</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正态分布："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># (最低，最高，size)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"均匀分布:"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果</p><pre class="language-none"><code class="language-none">正态分布： [0.94567776 1.12786411 1.31172487 1.20797385 0.65761211 1.35564439 1.02341514 0.89390523 1.34336123 1.13994983]均匀分布： [-0.15584577  0.49379278 -0.51443373  0.47639447  0.85539253 -0.12520956  0.38551024  0.92961516  0.43014289  0.54910227]</code></pre><h3 id="随机种子的重要性"><a href="#随机种子的重要性" class="headerlink" title="随机种子的重要性"></a>随机种子的重要性</h3><p>​在机器学习中，我们要对比两种随机初始化模型的优劣，或者在强化学习中要固定随机环境的随机序列，用于复现当前配置的情况，我们通常要做的事情就是<strong>伪随机</strong>。 简单说，就是每次都是一组随机，但是我可以后续再完整运行一遍一模一样的随机效果。比如生成两遍一模一样的随机序列。</p><ul><li><code>np.random.seed()</code></li></ul><p>​为了达到这个目的，我们要了解Numpy中的random seed概念，随机种子。当我们把种子固定的时候（用一个数字），同一个种子（数字）产生的随机序列就会一样。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#seed(1) 代表的就是1号随机序列</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​运行结果</p><pre class="language-none"><code class="language-none">[[4.17022005e-01 7.20324493e-01 1.14374817e-04] [3.02332573e-01 1.46755891e-01 9.23385948e-02]]2</code></pre><p>​此时无论你运行多少次上面的代码，你看到的随机结果，都是同一种结果。当你想改变随机种子的时候，可以在<code>seed()</code>中传入不同的数字。</p><p>​有时候还可以这么用：在同一次执行代码时，重新设定种子，让随机在同一次执行中复现。</p><pre class="language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#[0.4359949  0.02592623]</span><span class="token comment"># [0.4359949  0.02592623]</span></code></pre><p>​对于同一份代码，两次运行都是一样的结果。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>​你不光可以利用 Numpy 来创建很多种不同的随机数，还能对数据做随机化处理，甚至还能当上帝，控制计算机的随机过程（seed），让电脑可以复现你的随机过程。</p><h2 id="对速度有洁癖？快来了解Numpy的View与Copy"><a href="#对速度有洁癖？快来了解Numpy的View与Copy" class="headerlink" title="对速度有洁癖？快来了解Numpy的View与Copy"></a>对速度有洁癖？快来了解Numpy的View与Copy</h2><p>​通过这节内容理解Numpy的底层逻辑，在这其中有一个非常重要的概念：那就是<strong>View和Copy</strong>，你会发现，有可能前几天要花10天处理完的数据，学完这个之后，一优化，只需要1小时就搞定了。</p><p>​<strong>如果你对 Numpy 运算速度有追求，我十分建议你了解接下来的内容。如果你是萌新， 目前阶段不用 Numpy 处理大数据（上百MB 的文件），那下面的内容你可以以后再作了解。</strong></p><h3 id="Numpy-Array和Python-List内部结构差别"><a href="#Numpy-Array和Python-List内部结构差别" class="headerlink" title="Numpy Array和Python List内部结构差别"></a>Numpy Array和Python List内部结构差别</h3><p>以后再学！该开始Pandas了噢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy练习_数据清洗</title>
      <link href="/2022/05/25/Numpy%E7%BB%83%E4%B9%A0-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"/>
      <url>/2022/05/25/Numpy%E7%BB%83%E4%B9%A0-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy练习-数据清洗"><a href="#Numpy练习-数据清洗" class="headerlink" title="Numpy练习_数据清洗"></a>Numpy练习_数据清洗</h1><p>​        Numpy 的一切都是和数据打交道，那么在大数据时代，数据其实是不完整，不完美的。比如下面这张图里面， 你会发现，这份数据显然有些不完整的地方，city有数据缺失，duration 虽然是时间上的数据，但是时间单位不统一，时间格式不统一， 这都给后面我们让机器使用这份数据增加难度。</p><span id="more"></span><p><img src="http://cdn.leafii.top/img/20220529123648.png" loading="lazy"></p><p>​        这次课程我会展示如何用 Numpy 处理 Numpy 比较擅长的数据清理。但是在数据清理上，还有一个更好用的 Pandas 库，我们会在后期的教学当中，一步步深入到。</p><h2 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h2><p>​        如果你真有做过数据分析，当你拿到一份数据的时候，是十分期望这份数据没什么问题的，但是事与愿违，通常这份数据都多多少少有些问题。 常见的脏数据种类有：</p><ol><li>数据值缺失</li><li>数据值异常大或小</li><li>格式错误</li><li>非独立数据错误</li></ol><p>​        一般来说，你遇到的数都是需要从外部存储读取出来的，但是为了简化这节的内容，我们直接用Python的List来做一份数据。想要学习使用Numpy读取保存数据的话，可以看下一篇文章。</p><p>​        自造数据</p><pre class="language-python" data-language="python"><code class="language-python">raw_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"Name"</span><span class="token punctuation">,</span> <span class="token string">"StudentID"</span><span class="token punctuation">,</span> <span class="token string">"Age"</span><span class="token punctuation">,</span> <span class="token string">"AttendClass"</span><span class="token punctuation">,</span> <span class="token string">"Score"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token number">20131</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"小花"</span><span class="token punctuation">,</span> <span class="token number">20132</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"小菜"</span><span class="token punctuation">,</span> <span class="token number">20133</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"98"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"小七"</span><span class="token punctuation">,</span> <span class="token number">20134</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"花菜"</span><span class="token punctuation">,</span> <span class="token number">20134</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"刘欣"</span><span class="token punctuation">,</span> <span class="token number">20136</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>raw_data<span class="token punctuation">)</span></code></pre><p>​        这是一份学生上课的考试的数据，里面记录了学生姓名，ID，年龄，是否上过课（1-上过，0-没上），课程成绩信息。 比这复杂的数据还有很多，但是这份数据中的脏数据类型基本上都涵盖了我上面讲的那些。</p><p>​        首先，我们要做的就是把这份 Python list 数据转化成 Numpy 数据。其实用 Python 列表也能做数据清洗工作， 但为什么要用 Numpy 来做呢？这不得不提到 Numpy 面对大数据时，它得天独厚的计算速度优势了。同样一份 1GB 的数据，Python List 处理起来可能要 1 小时， Numpy 优化后，速度可以成倍增长。</p><p>​        首先，我们尝试直接转一下 Python list 到 Numpy Array，看看会不会有问题。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npdata <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>raw_data<span class="token punctuation">)</span>data</code></pre><p>​         运行结果</p><pre class="language-none"><code class="language-none">array([[&#39;Name&#39;, &#39;StudentID&#39;, &#39;Age&#39;, &#39;AttendClass&#39;, &#39;Score&#39;],       [&#39;小明&#39;, 20131, 10, 1, 67],       [&#39;小花&#39;, 20132, 11, 1, 88],       [&#39;小菜&#39;, 20133, None, 1, &#39;98&#39;],       [&#39;小七&#39;, 20134, 8, 1, 110],       [&#39;花菜&#39;, 20134, 98, 0, None],       [&#39;刘欣&#39;, 20136, 12, 0, 12]], dtype&#x3D;object)</code></pre><p>​        你会发现，这时的 array 输出的结果，结尾处有一个标识。<code>dtype=object</code>，这是什么意思呢？（剧透一下：这种 dtype 会对后续数据处理带来很多麻烦） 我们对比一下如果是纯数据的格式，numpy 的 dtype 是什么样。</p><pre class="language-python" data-language="python"><code class="language-python">test1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>test2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.1</span><span class="token punctuation">,</span><span class="token number">2.3</span><span class="token punctuation">,</span><span class="token number">3.4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>test3 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test1.dtype"</span><span class="token punctuation">,</span> test1<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test2.dtype"</span><span class="token punctuation">,</span> test2<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test3.dtype"</span><span class="token punctuation">,</span> test3<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test2 > 2 "</span><span class="token punctuation">,</span> test2 <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data > 2"</span><span class="token punctuation">,</span> data <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># 这里会报错</span><span class="token comment">#TypeError: '>' not supported between instances of 'str' and 'int'</span></code></pre><p>​        我们可以看到不同的array创建方式，可能有不同的dtype，而之前的<code>data.dtype=object</code>，说明Python list直接转换的 <code>data</code>是无法参与诸多Numpy计算的。而只有<code>dtype</code>为<code>int</code>,<code>float</code>这样的数值格式，才能参与运算。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>​        那怎么办呢？我们怎么才能把那个又有 string，又有 None，还有数值的数据转换为 Numpy 能运算的数据呢？ 方法很简单，我们筛选过滤一下。</p><pre class="language-python" data-language="python"><code class="language-python">data_process <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>raw_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">continue</span>    <span class="token comment"># 不要首行字符串</span>    <span class="token comment"># 去掉首列名字</span>    data_process<span class="token punctuation">.</span>append<span class="token punctuation">(</span>raw_data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>data_process<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data.dtype"</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> </code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[[2.0131e+04 1.0000e+01 1.0000e+00 6.7000e+01] [2.0132e+04 1.1000e+01 1.0000e+00 8.8000e+01] [2.0133e+04        nan 1.0000e+00 9.8000e+01] [2.0134e+04 8.0000e+00 1.0000e+00 1.1000e+02] [2.0134e+04 9.8000e+01 0.0000e+00        nan] [2.0136e+04 1.2000e+01 0.0000e+00 1.2000e+01]]</code></pre><p>​        有同学可能注意到了，这份数据没有 <code>float</code>，应该是全部是整数 <code>int</code>，为什么我在创建 array 的时候，选的 <code>dtype=np.float</code> 呢？ 那是因为 <code>dtype=np.int</code> 会报错呀，不信你试试。因为这份数据中存在 <code>None</code>，而只有 <code>np.float</code> 能转换 <code>None</code>，所以不是我不想，而是人家不让。</p><p>另外有趣的一个点是，我们在原始数据中有一个字符串的 98，这个字符串也被转换成数字了，可见 numpy 还自动帮我们处理了一部份能被转换的数字。</p><p>好了，现在总算是把这个数据的预处理做好了，接下来就要来清洗数据啦。</p><h2 id="清洗数据"><a href="#清洗数据" class="headerlink" title="清洗数据"></a>清洗数据</h2><p>​        怎么清洗脏数据，取决于你要拿这个数据做什么，很明显，我们想要看看有没有什么数据是不合逻辑的。比如我发现学号有重复，可能是在输入学生信息的时候手误输错了。</p><pre class="language-python" data-language="python"><code class="language-python">sid <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>unique<span class="token punctuation">,</span> counts <span class="token operator">=</span> np<span class="token punctuation">.</span>unique<span class="token punctuation">(</span>sid<span class="token punctuation">,</span> return_counts<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>counts<span class="token punctuation">)</span><span class="token comment">#[1 1 1 2 1]</span></code></pre><p>​        <code>np.unique()</code> 功能为用来查找数据中独一无二的数据的，<code>return_counts</code> 让我能清楚看到是数据的重复数量。 比如有一个数据重复出现了 2 次。我们来看看是哪个数据出现了多次。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>unique<span class="token punctuation">[</span>counts <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#[20134.]</span></code></pre><p>​        然后综合判断，我们的数据中少了一个 <code>20135</code>，可能就是把某个同学的学号输错了，我们将错误的同学修改过来。</p><pre class="language-python" data-language="python"><code class="language-python">data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20135</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre><p>​        学号应该就没有大问题了。我们来看看第二列 <code>Age</code> 年龄。一眼可以发现，存在两个问题，有一个同学没有年龄。我们看看能不能用平均年龄补全这个缺失的信息。</p><pre class="language-python" data-language="python"><code class="language-python">is_nan <span class="token operator">=</span> np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"is_nan:"</span><span class="token punctuation">,</span> is_nan<span class="token punctuation">)</span>nan_idx <span class="token operator">=</span> np<span class="token punctuation">.</span>argwhere<span class="token punctuation">(</span>is_nan<span class="token punctuation">)</span><span class="token comment"># 计算有数据的平均年龄，用 ~ 符号可以 True/False 对调</span>mean_age <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token operator">~</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"有数据的平均年龄："</span><span class="token punctuation">,</span> mean_age<span class="token punctuation">)</span></code></pre><p>​        <strong>呀！为啥平均年龄有 27.8 岁，不正常啊！是的，在你处理自己的数据的时候，也会遇到不太正常的情况。</strong> 是哪里出问题了呢？原来仔细看，我们居然有一个 98 岁的学生。 这不太正常啊，所以我觉得我也得把这个 98 岁的当异常数据看待。（在你的项目中，你也要综合判断哪些是异常数据）。我也没什么好办法，就用除开 98 和 nan 的数据， 计算其它数的平均值代替他们吧。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># ~ 表示 True/False 对调，&amp; 就是逐个做 Python and 的运算</span>normal_age_mask <span class="token operator">=</span> <span class="token operator">~</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"normal_age_mask:"</span><span class="token punctuation">,</span> normal_age_mask<span class="token punctuation">)</span>normal_age_mean <span class="token operator">=</span> data<span class="token punctuation">[</span>normal_age_mask<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"normal_age_mean:"</span><span class="token punctuation">,</span> normal_age_mean<span class="token punctuation">)</span>data<span class="token punctuation">[</span><span class="token operator">~</span>normal_age_mask<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> normal_age_mean<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ages:"</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​        到这一步之后，我们要看看上课和成绩的数据需不需要清洗。按理来说，如果没有上课（0），课程的成绩应该是不存在的（nan）；上课了（1）才会有成绩。 所以我们观察下面两组数据：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​        你会发现，倒数第二行的数据还算是 ok 的，因为没上课，就没成绩，但是倒数第一行，没上课，怎么还有成绩？还有倒数第三行，成绩居然超出了满分 100 分。这些情况都是我们要处理的情况。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 没上课的转成 nan</span>data<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>nan<span class="token comment"># 超过 100 分和低于 0 分的都处理一下</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>clip<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，数据清洗的工作已经告一段落啦。你会发现，即使是这么小规模的数据，我们也能体验到多种不同情况的数据清洗工作:</p><ol><li>数据值缺失</li><li>数据值异常大或小</li><li>格式错误</li><li>非独立数据错误</li></ol><p>有了这次体验，我相信你在自己的数据上也能更清楚如何操作了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy练习_疫情数据分析</title>
      <link href="/2022/05/23/Numpy%E7%BB%83%E4%B9%A0-%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>/2022/05/23/Numpy%E7%BB%83%E4%B9%A0-%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>​        20年开始的新冠肺炎席卷全球，我们能从肺炎数据中发现什么规律呢？我提前给你准备了从 2020 年 1 月 22 日到 2020 年 7 月 27 日的数据。</p><span id="more"></span><h1 id="疫情数据分析"><a href="#疫情数据分析" class="headerlink" title="疫情数据分析"></a>疫情数据分析</h1><h2 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h2><p>​        2020年1月22日到2020年7月27日的数据<a href="https://pan.baidu.com/s/1HX83ebLmbcGJmf5ErXZiVg">下载链接</a>：提取码：5mrb</p><h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><p>​        用下面的代码在你本地加载数据。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"你下载的 day_wise.csv 数据"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    data <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>covid <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">"date"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token string">"data"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token string">"header"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>h <span class="token keyword">for</span> h <span class="token keyword">in</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> row <span class="token keyword">in</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    split_row <span class="token operator">=</span> row<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>    covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>split_row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    covid<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> split_row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​        确保你的文件引入正确</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 数据</span><span class="token keyword">print</span><span class="token punctuation">(</span>covid<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 数据太多了，我先打 5 行</span><span class="token comment"># print(covid["data"]) # 如果你实在想看全部，就执行这一行</span><span class="token comment"># 日期数据</span><span class="token keyword">print</span><span class="token punctuation">(</span>covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 数据太多了，我先打 5 行</span><span class="token comment"># print(covid["date"]) # 如果你实在想看全部，就执行这一行</span></code></pre><p>​        了解了数据的大概样子，那么来使用你所学到的 Numpy 技能，我们来分析下面这几个问题。</p><ol><li>获取 2020 年 2 月 3 日的所有数据</li><li>2020 年 1 月 24 日之前的累积确诊病例有多少个？</li><li>2020 年 7 月 23 日的新增死亡数是多少？</li><li>从 1 月 25 日到 7 月 22 日，一共增长了多少确诊病例？</li><li>每天新增确诊数和新恢复数的比例？平均比例，标准差各是多少？</li><li>画图展示新增确诊的变化曲线</li><li>画图展示死亡率的变化曲线</li></ol><h2 id="某日所有数据"><a href="#某日所有数据" class="headerlink" title="某日所有数据"></a>某日所有数据</h2><ul><li>获取 2020 年 2 月 3 日的所有数据</li></ul><p>​        解决这个问题之前，我们需要搞懂使用Numpy获取到特定数据的时候，数据的索引是什么。在Numpy中，我们用来索引的大概率是数字，所以我们得搞清楚对应的数字标号是什么。因为我在为你准备的covid数据中，把日期和标题都用Python列表装起来了，所以你可以通过<code>.index(&quot;xxx&quot;)</code>功能来获取到它的索引。</p><p>​        我们需要思考的是：找到这一天所对应的索引。还好我已经把日期都用列表给存储起来了。看看日期的存储方式。将日期转换成<code>date_idx</code>之后，我们就能用这个index来获取到那一天的全部数据了。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"日期列表摘取："</span><span class="token punctuation">,</span> covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>date_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"2020-02-03"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"日期->索引转换："</span><span class="token punctuation">,</span> date_idx<span class="token punctuation">)</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npdata <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>covid<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> header<span class="token punctuation">,</span> number <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>date_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>header<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> number<span class="token punctuation">)</span></code></pre><p>​        至于，这些人数为什么会是一个小数呢？因为 Numpy 在存储一批数据的时候，它会把数据都存成一个模式，在这套数据中，我们都是以小数（float64）的形式存储的， 所以你才会看到有小数点。</p><h2 id="累计确诊"><a href="#累计确诊" class="headerlink" title="累计确诊"></a>累计确诊</h2><ul><li>2020 年 1 月 24 日之前的累积确诊病例有多少个？</li></ul><p>​        有了上一个任务的基础，这个任务我们就更加细致地去获取某个具体的数值，我们确定完日期（row）的 index 之后，再确定标题 （column）的 index。 在这个案例中，我们要确定累积确诊数（Conformed）的索引。</p><pre class="language-python" data-language="python"><code class="language-python">row_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"2020-01-24"</span><span class="token punctuation">)</span>     <span class="token comment"># 获取日期索引</span>column_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"Confirmed"</span><span class="token punctuation">)</span> <span class="token comment"># 获取标题的索引</span>confirmed0124 <span class="token operator">=</span> data<span class="token punctuation">[</span>row_idx<span class="token punctuation">,</span> column_idx<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"截止 1 月 24 日的累积确诊数："</span><span class="token punctuation">,</span> confirmed0124<span class="token punctuation">)</span></code></pre><h2 id="新增死亡"><a href="#新增死亡" class="headerlink" title="新增死亡"></a>新增死亡</h2><ul><li>2020年7月23日的新增死亡数是多少？</li></ul><p>​        这还是一个在Numpy Array中选取数据的过程，我们要搞清楚具体的索引是什么。”New deaths”对应的就是新增死亡数，按照之前的流程把数据拿出来：</p><pre class="language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>covid<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>row_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"2020-07-23"</span><span class="token punctuation">)</span>column_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"New deaths"</span><span class="token punctuation">)</span>result <span class="token operator">=</span> data<span class="token punctuation">[</span>row_idx<span class="token punctuation">,</span>column_idx<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2020 年 7 月 23 日的新增死亡数是:"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span></code></pre><h2 id="总增长数"><a href="#总增长数" class="headerlink" title="总增长数"></a>总增长数</h2><ul><li>从 1 月 25 日到 7 月 22 日，一共增长了多少确诊病例？</li></ul><p>​        获取数据都是小儿科，我们来点真正的数据分析。要基于原有的数据，进行多次加工，来获取新的结论和结果。在这个任务中，我们要进行一次累和的计算。</p><pre class="language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>covid<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>row1_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"2020-01-25"</span><span class="token punctuation">)</span>row2_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"2020-07-22"</span><span class="token punctuation">)</span>column_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"New cases"</span><span class="token punctuation">)</span><span class="token comment"># 注意要 row1_idx+1 得到从 01-25 这一天的新增</span><span class="token comment"># row2_idx+1 来包含 7 月 22 的结果</span>new_cases <span class="token operator">=</span> data<span class="token punctuation">[</span>row1_idx<span class="token punctuation">:</span>row2_idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>column_idx<span class="token punctuation">]</span>overall <span class="token operator">=</span> new_cases<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"共新增："</span><span class="token punctuation">,</span>overall<span class="token punctuation">)</span></code></pre><p>​        但这是通过将每日的新增进行求和，数据是不准确的，我们接下来按照累计确诊的个数计算</p><pre class="language-python" data-language="python"><code class="language-python">confirm_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"Confirmed"</span><span class="token punctuation">)</span>confirmed <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>confirm_idx<span class="token punctuation">]</span>overall2 <span class="token operator">=</span> confirmed<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"另一版本的新增："</span><span class="token punctuation">,</span>overall2<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">共新增： 15247802.0另一版本的新增： 15226291.0</code></pre><p>​        可以看到，两个数据不一致，这是因为有人感染了不止一次，因此导致新增的数据里重复计算了，所以用新增数据计算的结果比累计确诊的方式来计算的要多。</p><p>​        具体分析看看，具体是哪天的数据对不上，详细输出一下。</p><pre class="language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>covid<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>row1_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"2020-01-25"</span><span class="token punctuation">)</span>row2_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"date"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"2020-07-22"</span><span class="token punctuation">)</span>column_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"New cases"</span><span class="token punctuation">)</span>confirm_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"Confirmed"</span><span class="token punctuation">)</span>confirmed <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>confirm_idx<span class="token punctuation">]</span>new_cases <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>column_idx<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>row1_idx<span class="token punctuation">,</span>row2_idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    diff <span class="token operator">=</span> new_cases<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>confirmed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> confirmed<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> diff <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data index:"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token string">"差异："</span><span class="token punctuation">,</span>diff<span class="token punctuation">)</span></code></pre><p>​        运行结果：</p><pre class="language-none"><code class="language-none">data index: 62 差异： 15.0data index: 81 差异： 21.0...data index: 176 差异： 3.0data index: 181 差异： 110.0</code></pre><h2 id="确诊恢复比例"><a href="#确诊恢复比例" class="headerlink" title="确诊恢复比例"></a>确诊恢复比例</h2><ul><li>每天新增确诊数和新恢复数的比例？平均比例，标准差各是多少？</li></ul><p>​        这一个任务，我们需要再计算计算，会要使用到 Numpy 的批量计算功能，首先确定要拿取到的数据是什么，然后再对这些数据进行计算。 按要求，我们要拿到新增确诊数（New cases），和新的恢复数（New recovered）,然后再相除，最后再计算平均值和标准差。</p><pre class="language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>covid<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>new_cases_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"New cases"</span><span class="token punctuation">)</span>new_recovered_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"New recovered"</span><span class="token punctuation">)</span><span class="token comment">#ratio</span>ratio <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>new_cases_idx<span class="token punctuation">]</span> <span class="token operator">/</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>new_recovered_idx<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"比例样本："</span><span class="token punctuation">,</span>ratio<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#比例样本： [         nan  49.5         47.83333333 164.33333333  52.61538462]</span></code></pre><p>​        我靠，为什么有一个nan啊，nan在Numpy中表示的是 Not a Number， 说明计算有问题。我们单独打印一下，看看为什么出现 <code>nan</code>。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>new_cases_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>new_recovered_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 0.0</span><span class="token comment"># 0.0</span></code></pre><p>​        原来是因为 <code>new_recovered_idx</code> 的第一个位置数据为 0，任何数除以 0 是不成立的，所以才会把这个计算给出一个 <code>nan</code> 的结果。 你看做数据分析还是挺有意思吧，会出现各种意想不到的状况。然后我们把 new_recovered 为零的数都剔除掉。</p><pre class="language-python" data-language="python"><code class="language-python">not_zero_mask <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> new_recovered_idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span>ratio <span class="token operator">=</span> data<span class="token punctuation">[</span>not_zero_mask<span class="token punctuation">,</span> new_cases_idx<span class="token punctuation">]</span> <span class="token operator">/</span> data<span class="token punctuation">[</span>not_zero_mask<span class="token punctuation">,</span> new_recovered_idx<span class="token punctuation">]</span><span class="token comment"># 平均比例, 标准差</span>ratio_mean <span class="token operator">=</span> ratio<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>ratio_std <span class="token operator">=</span> ratio<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"比例样本："</span><span class="token punctuation">,</span>ratio<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"平均比例："</span><span class="token punctuation">,</span> ratio_mean<span class="token punctuation">,</span> <span class="token string">"；标准差："</span><span class="token punctuation">,</span> ratio_std<span class="token punctuation">)</span><span class="token comment">#比例样本： [ 49.5         47.83333333 164.33333333  52.61538462  89.88888889]</span><span class="token comment">#平均比例： 7.049556348053241 ；标准差： 19.094025710450307</span></code></pre><p>​        得到计算结果后，我们还是能明显发现，被治好的人的确比新增的要多，这就说明，我们自己的存活率还是挺高的。</p><h2 id="可视化数据"><a href="#可视化数据" class="headerlink" title="可视化数据"></a>可视化数据</h2><ul><li>画图展示新增确诊的变化曲线</li></ul><p>​        有时候，光秃秃的数字并不能生动表现这些数字背后的规律。我们还可以把它画出来。至于如何画，我给你做了一个 <code>draw_line()</code> 的函数，这个函数的背后是 Python 的画图工具 <code>Matplotlib</code>. 不过在这个教程中，并不是重点，我会在<a href="https://mofanpy.com/learning-steps/">之后的画图教程</a>中详细介绍。</p><p>​        现在，我们就来做新增确诊的可视化数据吧。</p><pre class="language-python" data-language="python"><code class="language-python">new_cases_idx <span class="token operator">=</span> covid<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">"New cases"</span><span class="token punctuation">)</span>draw_line<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> new_cases_idx<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​        画图部分省略</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        数据分析是一件非常有趣的事情。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy和pandas学习笔记</title>
      <link href="/2022/05/17/numpy%E5%92%8Cpandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/17/numpy%E5%92%8Cpandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy和Pandas学习笔记"><a href="#Numpy和Pandas学习笔记" class="headerlink" title="Numpy和Pandas学习笔记"></a>Numpy和Pandas学习笔记</h1><p>记录学习的内容，方便今后查阅</p><span id="more"></span><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><h3 id="Numpy的安装"><a href="#Numpy的安装" class="headerlink" title="Numpy的安装"></a>Numpy的安装</h3><p>​        直接使用<code>pip3 install numpy</code>即可，可以在终端使用<code>python3 -c &quot;import numpy&quot;</code>判断是否安装成功，如果在终端里直接输入这个语句没有任何反应，那么说明numpy是安装成功可以使用了的</p><h3 id="Numpy-array-和-Python的List的差别"><a href="#Numpy-array-和-Python的List的差别" class="headerlink" title="Numpy array 和 Python的List的差别"></a>Numpy array 和 Python的List的差别</h3><h4 id="Numpy-array的定义"><a href="#Numpy-array的定义" class="headerlink" title="Numpy array的定义"></a>Numpy array的定义</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#定义numpy array</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="List-和-Numpy-array-共同点"><a href="#List-和-Numpy-array-共同点" class="headerlink" title="List 和 Numpy array 共同点"></a>List 和 Numpy array 共同点</h4><ul><li>它们都可以用来存储、提取以及修改</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npmy_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>my_array <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#都可以正常打印噢</span>my_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>my_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_array<span class="token punctuation">)</span></code></pre><h4 id="Numpy-array的优势何在？"><a href="#Numpy-array的优势何在？" class="headerlink" title="Numpy array的优势何在？"></a>Numpy array的优势何在？</h4><p>​        Numpy的运算速度快，numpy array在内存中使用连续地址，并不像List使用不连续的地址块，因此速度上就有差异，而且Numpy对于批量数据的存储的数据格式也更有效率</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        Numpy Array 和 Python List 在很多使用场景上是可以互换的，不过在大数据处理的场景下，而且你的数据类型又高度统一， 那么 Numpy 绝对是你不二的人选，能提升的运算速度也是杠杠的~</p><h3 id="Numpy的基本操作"><a href="#Numpy的基本操作" class="headerlink" title="Numpy的基本操作"></a>Numpy的基本操作</h3><h4 id="Numpy中的维度"><a href="#Numpy中的维度" class="headerlink" title="Numpy中的维度"></a>Numpy中的维度</h4><p>​        Numpy在多维数据的计算上速度很快！！！我们来学一下怎么用numpy创建并处理多维数据</p><h5 id="创建多维数据"><a href="#创建多维数据" class="headerlink" title="创建多维数据"></a>创建多维数据</h5><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#创建一维</span>cars <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数据："</span><span class="token punctuation">,</span>cars<span class="token punctuation">,</span><span class="token string">"维度："</span><span class="token punctuation">,</span>cars<span class="token punctuation">.</span>ndim<span class="token punctuation">)</span><span class="token comment">#创建二维</span>cars <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">5.1</span><span class="token punctuation">,</span><span class="token number">8.2</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">6.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">4.4</span><span class="token punctuation">,</span><span class="token number">9.1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6.6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数据："</span><span class="token punctuation">,</span>cars<span class="token punctuation">,</span><span class="token string">"维度："</span><span class="token punctuation">,</span>cars<span class="token punctuation">.</span>ndim<span class="token punctuation">)</span><span class="token comment">#创建三维</span>cars <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">5.1</span><span class="token punctuation">,</span><span class="token number">8.2</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">6.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">4.4</span><span class="token punctuation">,</span><span class="token number">9.1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6.6</span><span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">6.1</span><span class="token punctuation">,</span><span class="token number">9.2</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">7.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">5.4</span><span class="token punctuation">,</span><span class="token number">10.1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">7.6</span><span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数据："</span><span class="token punctuation">,</span>cars<span class="token punctuation">,</span><span class="token string">"维度："</span><span class="token punctuation">,</span>cars<span class="token punctuation">.</span>ndim<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"场地1 数据：\n"</span><span class="token punctuation">,</span>cars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"\n场地1 维度:"</span>，cars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ndim<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"场地2 数据：\n"</span><span class="token punctuation">,</span>cars<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"\n场地2 维度:"</span>，cars<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ndim<span class="token punctuation">)</span></code></pre><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><ul><li>把两个一维数组变成一个二维数组</li></ul><pre class="language-python" data-language="python"><code class="language-python">cars1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>cars2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5.2</span><span class="token punctuation">,</span><span class="token number">4.2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>cars <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>cars1<span class="token punctuation">,</span>cars2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#concatenate的意思是连接</span><span class="token keyword">print</span><span class="token punctuation">(</span>cars<span class="token punctuation">)</span></code></pre><ul><li>数据换成二维数组之后想要添加数据</li></ul><pre class="language-python" data-language="python"><code class="language-python">test1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>test2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5.1</span><span class="token punctuation">,</span> <span class="token number">8.2</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">6.3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 首先需要把它们都变成二维，下面这两种方法都可以加维度</span>test1 <span class="token operator">=</span> np<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>test1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>test2 <span class="token operator">=</span> test2<span class="token punctuation">[</span>np<span class="token punctuation">.</span>newaxis<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test1加维度后 "</span><span class="token punctuation">,</span> test1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test2加维度后 "</span><span class="token punctuation">,</span> test2<span class="token punctuation">)</span><span class="token comment"># 然后再在第一个维度上叠加</span>all_tests <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>test1<span class="token punctuation">,</span> test2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"括展后\n"</span><span class="token punctuation">,</span> all_tests<span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">test1加维度后  [[ 5 10 12  6]]test2加维度后  [[ 5.1  8.2 11.   6.3]]括展后 [[ 5.  10.  12.   6. ] [ 5.1  8.2 11.   6.3]]</code></pre><h5 id="合并数据"><a href="#合并数据" class="headerlink" title="合并数据"></a>合并数据</h5><ul><li>只要维度能够对齐，你可以在任意维度上进行合并操作</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第一维度叠加：\n"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>all_tests<span class="token punctuation">,</span> all_tests<span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第二维度叠加：\n"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>all_tests<span class="token punctuation">,</span> all_tests<span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​        运行结果：</p><pre class="language-none"><code class="language-none">第一维度叠加： [[ 5.  10.  12.   6. ] [ 5.1  8.2 11.   6.3] [ 5.  10.  12.   6. ] [ 5.1  8.2 11.   6.3]]第二维度叠加： [[ 5.  10.  12.   6.   5.  10.  12.   6. ] [ 5.1  8.2 11.   6.3  5.1  8.2 11.   6.3]]</code></pre><p>​        看来axis为0的时候，就是把二维数组和二维数组直接合并，而axis为1的时候就是把相对应的数据合并成一个数组，两个数组的原有位置关系不变</p><ul><li>转载一个好的理解axis方法：axis这个参数实际上就是表示的你要修改哪一维度的数据。举个栗子：<br>   有两组数据，它们的维度都是（2，3），即都是两行三列的数据。有小伙伴可能会发愁，当这两组数据合并时，axis参数设为0到底是横向操作还是竖向操作，肯定有小伙伴要在这里思考一下，实际上不用这么麻烦哒~<br>    当axis设为0时，表示我们要修改第一个维度的数据，两组数据的第一个维度都是2，当它们合并时就变成了4，所以合并后的数据的维度就是（4，3），即变成了四行三列。通过这样子思考，就再也不用努力回想到底是横向合并还是竖向合并啦hh<br>    同理，axis设为1，合并后的数据维度就变成了（2，6），即两行六列~<br>    同理，axis参数在其他方法里也可以用同样的方法思考，比如求均值的mean方法，当axis设为0时，对第一个维度的数据进行求均值，维度为（2，3）的数据计算完后就变成了维度为（1，3）的数据，是不是很好理解~</li></ul><p>​        而且除了<code>np.concatenate()</code>之外，还有&#96;&#96;np.vstack()<code>, </code>np.hstack()<code>.</code>这两个方法在二维数组上可以将数据进行横向合并和纵向合并：</p><p><img src="http://cdn.leafii.top/img/Screen%20Shot%202022-05-19%20at%2020.05.47.png" alt="横向合并" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/Screen%20Shot%202022-05-19%20at%2020.29.07.png" alt="纵向合并" loading="lazy"></p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"竖直合并\n"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"水平合并\n"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">竖直合并 [[1 2] [3 4] [5 6] [7 8]]水平合并 [[1 2 5 6] [3 4 7 8]]</code></pre><h5 id="观察形态"><a href="#观察形态" class="headerlink" title="观察形态"></a>观察形态</h5><p>​        除了 <code>np.ndim</code> 来查看数据的形态，其实我们有时候还想更加了解数据的细节问题，比如这个数据的大小，规格。方便我们管理这些数据。</p><ul><li>当我想知道到底有多少车辆测试数据时，你可能会通过遍历的方法来计数。</li></ul><pre class="language-python" data-language="python"><code class="language-python">cars <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5.1</span><span class="token punctuation">,</span> <span class="token number">8.2</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">6.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4.4</span><span class="token punctuation">,</span> <span class="token number">9.1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6.6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>cars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>cars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        count <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"总共多少测试数据："</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span>        </code></pre><p>​        但以下代码与上面代码等价：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"总共多少测试数据："</span><span class="token punctuation">,</span> cars<span class="token punctuation">.</span>size<span class="token punctuation">)</span></code></pre><ul><li>想知道数组有几行（第一维度）几列（第二维度）</li></ul><pre class="language-python" data-language="python"><code class="language-python">cars <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5.1</span><span class="token punctuation">,</span> <span class="token number">8.2</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">6.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4.4</span><span class="token punctuation">,</span> <span class="token number">9.1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6.6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第一个维度："</span><span class="token punctuation">,</span> cars<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第二个维度："</span><span class="token punctuation">,</span> cars<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"所有维度："</span><span class="token punctuation">,</span> cars<span class="token punctuation">.</span>shape<span class="token punctuation">)</span></code></pre><p>​        运行结果：</p><pre class="language-none"><code class="language-none">第一个维度： 3第二个维度： 4所有维度： (3, 4)</code></pre><p>​        <strong>要好好理解维度噢，这很重要</strong></p><h4 id="用numpy进行数据选择"><a href="#用numpy进行数据选择" class="headerlink" title="用numpy进行数据选择"></a>用numpy进行数据选择</h4><p>​        可以使用numpy进行对数据的选择，不管是批量划分，还是按条件筛选，都可以哦qwq</p><h5 id="单个选取"><a href="#单个选取" class="headerlink" title="单个选取"></a>单个选取</h5><ul><li><code>array[1]</code></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#一个一个选qwq！</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a[0]:"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a[1]:"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><img src="http://cdn.leafii.top/img/20220519202955.png" alt="array[1]" loading="lazy"></p><ul><li><code>array[1,2,3]</code></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#一次选择多个</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a[[0,1]]:\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a[[1,1,0]]:\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><ul><li><code>array[1][1]</code></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#对二维数组进行选择</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 选第 2 行所有数</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"b[1]:\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment"># 选第 2 行，第 1 列的数</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"b[1,0]:\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment"># 这个看着有点纠结，如果对应到数据，</span><span class="token comment"># 第一个拿的是数据位是 [1,2]</span><span class="token comment"># 第二个拿的是 [0,3]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"b[[1,0],[2,3]]:\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>​        总之，不管是几维数据，我们都可以在其不同维度上挑选那个维度上对应序号上的数值。而且还能一次从原数据上选取多个数据点。</p><h5 id="切片划分"><a href="#切片划分" class="headerlink" title="切片划分"></a>切片划分</h5><ul><li><code>array[:3]</code></li></ul><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a[0:2]：\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a[1:]：\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a[-2:]：\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#使用 : 就能让你跨着取数字，而且一次取一批。注意，在 Numpy 中：一次取一批和一个个拎起来，拎了一批，是不同的概念哦 一次取一批来的更快， 因为它不用去一个个查看，一个个数了。</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">a[0:2]： [1 2]a[1:]： [2 3]a[-2:]： [2 3]</code></pre><p><img src="http://cdn.leafii.top/img/20220520104622.png" alt="切片划分" loading="lazy"></p><ul><li><code>array[2:4, 1:3]</code></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#在多维上，也可以进行切片划分</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"b[:2]:\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"b[:2, :3]:\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"b[1:3, -2:]:\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">b[:2]: [[1 2 3 4] [5 6 7 8]]b[:2, :3]: [[1 2 3] [5 6 7]]b[1:3, -2:]: [[ 7  8] [11 12]]</code></pre><h5 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h5><ul><li><code>array[array&lt;0]</code></li></ul><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>a<span class="token operator">></span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#运行结果如下</span><span class="token comment">#[ 8  9 10 11 12]</span><span class="token comment">#a>7 的返回结果是布尔类型</span>condition <span class="token operator">=</span> a <span class="token operator">></span> <span class="token number">7</span><span class="token keyword">print</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>condition<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#运行结果如下</span><span class="token comment">#[[False False False False]</span><span class="token comment">#[False False False  True]</span><span class="token comment">#[ True  True  True  True]]</span><span class="token comment">#[ 8  9 10 11 12]</span></code></pre><p>​        这种筛选的底层逻辑就是只要我们得到一种True和False数据，那么就可以进行筛选。</p><pre class="language-python" data-language="python"><code class="language-python">condition <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>condition<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#[ 8  9 11 12]</span></code></pre><ul><li><code>np.where(array, array &lt; 0)</code></li></ul><p>​        除了这种直接用<code>[]</code>的形式，在 Numpy 中，还有一个专用的函数来做数据筛选。这种筛选更强大，它还能做筛选结果的替换工作。 它可已将满足条件的位置变成你设定的数字。下面满足条件的，都改成 <code>-1</code>，不满足的，都还是 <code>a</code> 里面的数字。</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>condition <span class="token operator">=</span> a <span class="token operator">></span> <span class="token number">7</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>condition<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#[[ 1  2  3  4]</span><span class="token comment">#[ 5  6  7 -1]</span><span class="token comment">#[-1 -1 -1 -1]]</span></code></pre><p>​        或者将不满足条件的也变成你期望的数字或者另一组数据</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>condition <span class="token operator">=</span> a <span class="token operator">></span> <span class="token number">7</span><span class="token comment">#满足的变成-1，不满足的变成2</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>condition<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#[[ 2  2  2  2]</span><span class="token comment">#[ 2  2  2 -1]</span><span class="token comment">#[-1 -1 -1 -1]]</span><span class="token comment">#定义b</span>b <span class="token operator">=</span> <span class="token operator">-</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>condition<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#[[-2 -3 -4 -5]</span><span class="token comment">#[-6 -7 -8  8]</span><span class="token comment">#[ 9 10 11 12]]</span></code></pre><p>​        所以 <code>np.where()</code> 函数真的十分强大，每每当我想要按条件选择、替换数据的时候，我脑海中，都是 <code>np.where()</code> 的身影。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>​        数据虽然有格式，但是如果要把数据用起来，还是得学会挑选和筛选。而今天介绍的单个、分段、条件筛选，都是数据工程师必备的一项技能。也是后续数据分析和机器学习的基石。</p><h4 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h4><h5 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h5><ul><li>在Python的List中进行计算的常规步骤</li></ul><pre class="language-python" data-language="python"><code class="language-python">l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">150</span><span class="token punctuation">,</span><span class="token number">166</span><span class="token punctuation">,</span><span class="token number">183</span><span class="token punctuation">,</span><span class="token number">170</span><span class="token punctuation">]</span><span class="token comment">#* 使用循环</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span>    l<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">3</span><span class="token keyword">print</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token comment">#[153, 169, 186, 173]</span><span class="token comment">#* 使用map函数</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">150</span><span class="token punctuation">,</span><span class="token number">166</span><span class="token punctuation">,</span><span class="token number">183</span><span class="token punctuation">,</span><span class="token number">170</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#[153, 169, 186, 173]</span></code></pre><ul><li>使用numpy的方式进行计算 <code>+-*/</code></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">150</span><span class="token punctuation">,</span><span class="token number">166</span><span class="token punctuation">,</span><span class="token number">183</span><span class="token punctuation">,</span><span class="token number">170</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#[153 169 186 173]</span></code></pre><p>​        Numpy 是可以批量进行计算的，只需要简单的 <code>+-*/</code>，就能进行全元素的运算，也就是向量化运算。同理，我们也可以进行其他符号的批量运算。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a + 3:"</span><span class="token punctuation">,</span> a <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a - 3:"</span><span class="token punctuation">,</span> a <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a * 3:"</span><span class="token punctuation">,</span> a <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a / 3:"</span><span class="token punctuation">,</span> a <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#a + 3: [153 169 186 173]</span><span class="token comment">#a - 3: [147 163 180 167]</span><span class="token comment">#a * 3: [450 498 549 510]</span><span class="token comment">#a / 3: [50.         55.33333333 61.         56.66666667]</span></code></pre><ul><li>矩阵点积运算 <code>np.dot()</code></li></ul><p><img src="http://cdn.leafii.top/img/20220520232800.png" loading="lazy"></p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#[[19 22]</span><span class="token comment">#[43 50]]</span><span class="token comment">#[[19 22]</span><span class="token comment">#[43 50]]</span></code></pre><p>​        因此，我们可以得知，dot函数有两种写法，一种是<code>a.dot(b)</code>，另一种是<code>np.dot(a,b)</code>，矩阵还有很多其他的计算，比如 <code>np.outer()</code> 矩阵外积，<code>np.inner()</code> 矩阵内积 （和 <code>np.dot()</code> 的用法稍稍有些不同，你可以理解成 <code>np.dot(a, b）= np.inner(a, b.T)</code>, 把 b 做一次转置）。</p><h5 id="数据统计分析"><a href="#数据统计分析" class="headerlink" title="数据统计分析"></a>数据统计分析</h5><p>​        在数据分析时，大部分时间还是以pandas的使用为主，但是数据量比较大的时候，可以使用numpy，毕竟numpy的速度比Pandas要快上不少。</p><p>​        数据分析的定义：在数据中找到你想要的一些变量，总结数据的规律。</p><ul><li><code>np.max() np.min() np.sum() np.prod() np.count()</code></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#对给定的身高数据，找最高的和最矮的</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">150</span><span class="token punctuation">,</span><span class="token number">166</span><span class="token punctuation">,</span><span class="token number">183</span><span class="token punctuation">,</span><span class="token number">170</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"max:"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"min:"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#或者</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"max:"</span><span class="token punctuation">,</span>a<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"min:"</span><span class="token punctuation">,</span>a<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#计算累加和</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#计算累乘</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>prod<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#计算总共有几个值</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment">#计算一共有多少个非零值</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>arrat<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"非零总数："</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>count_nonzero<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li><code>np.std() np.mean() np.median()</code></li></ul><pre class="language-python" data-language="python"><code class="language-python">month_salary <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">2.1</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"标准差："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>std<span class="token punctuation">(</span>month_salary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"平均工资："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>month_salary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"工资中位数："</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>median<span class="token punctuation">(</span>month_salary<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h5 id="特殊运算符号"><a href="#特殊运算符号" class="headerlink" title="特殊运算符号"></a>特殊运算符号</h5><ul><li><code>np.argmax() np.argmin()</code></li></ul><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">150</span><span class="token punctuation">,</span> <span class="token number">166</span><span class="token punctuation">,</span> <span class="token number">183</span><span class="token punctuation">,</span> <span class="token number">170</span><span class="token punctuation">]</span><span class="token punctuation">)</span>name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"小米"</span><span class="token punctuation">,</span> <span class="token string">"OPPO"</span><span class="token punctuation">,</span> <span class="token string">"Huawei"</span><span class="token punctuation">,</span> <span class="token string">"诺基亚"</span><span class="token punctuation">]</span><span class="token comment">#关心最大/最小数值的序号 使用argmax()/argmin()</span>high_idx <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>a<span class="token punctuation">)</span>low_idx <span class="token operator">=</span> np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; 最高"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span>high_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; 最矮"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span>low_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li><code>np.ceil() np.floor() np.clip()</code></li></ul><p>​        另外一个时不时会用到的功能是，取天花板的值还是地板的值，这个在 AI 算法中也比较常见， 比如我要对其做<strong>取整处理</strong>，抹除小数部分。</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">150.1</span><span class="token punctuation">,</span> <span class="token number">166.4</span><span class="token punctuation">,</span> <span class="token number">183.7</span><span class="token punctuation">,</span> <span class="token number">170.8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ceil:"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"floor:"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​        可以用 <code>np.clip()</code> 来做上下界限的值截取</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">150.1</span><span class="token punctuation">,</span> <span class="token number">166.4</span><span class="token punctuation">,</span> <span class="token number">183.7</span><span class="token punctuation">,</span> <span class="token number">170.8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"clip:"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>clip<span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>​        其实 Numpy 中做数据运算的功能，比我这里列举的要多很多，我只是列举了一些我在数据分析和人工智能算法中，经常会使用到的一些功能。 还有更多的功能，可以在他的<a href="https://numpy.org/devdocs/user/quickstart.html#basic-operations">官方网站</a>查找哦。</p><h4 id="改变数据形态"><a href="#改变数据形态" class="headerlink" title="改变数据形态"></a>改变数据形态</h4><p>​        如何做数据的变换？</p><h5 id="改变形态"><a href="#改变形态" class="headerlink" title="改变形态"></a>改变形态</h5><ul><li><code>array[np.newaxis, :]</code></li></ul><p>​        改变形态，其实是针对与多维度空间上的数据，要改变它的维度信息，和每个维度中的数据格式。所以第一点你就要清楚，如何添加维度。 其实在 <a href="https://mofanpy.com/tutorials/data-manipulation/numpy/ndarray/">多维数据教程中</a> 中我们就提到过添加维度的方法，我这里在总结括展一下。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a_2d <span class="token operator">=</span> a<span class="token punctuation">[</span>np<span class="token punctuation">.</span>newaxis<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> a_2d<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#(6,) (1, 6)</span></code></pre><p>​        除了这种方式的其它几种，能达到同样效果的方式。比如用 <code>None</code> 或者 <code>np.expand_dims()</code></p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a_none <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>a_expand <span class="token operator">=</span> np<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>a<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a_none<span class="token punctuation">.</span>shape<span class="token punctuation">,</span>a_expand<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#(6, 1) (6, 1)</span></code></pre><p>​         除了添加维度，我们还能减少维度，但是下面介绍的减少维度，只能减少那些维度 shape 上为 1 的维度。因为减掉这个维度，数据结构上是没有变化的。</p><pre class="language-python" data-language="python"><code class="language-python">a_squeeze <span class="token operator">=</span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>a_expand<span class="token punctuation">)</span>a_squeeze_axis <span class="token operator">=</span> a_expand<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a_squeeze<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a_squeeze_axis<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#(6,)</span><span class="token comment">#(6,)</span></code></pre><ul><li><code>array.reshape()</code></li></ul><p>​        上述方法都是添加维度的方式，但是，在机器学习中，我们还有一个更常见的操作，是要改变 shape。维度的添加减少，只能添加减少一个维度，数据结构是不变的。 但是 <code>np.reshape()</code> 可以改变数据结构。 举个例子，<code>a[None, :]</code> 之后，<code>a.shape</code> 会在第一个维度上多一个 1，而 <code>a.reshape([2,3])</code> 则可以更加自定义的将维度内的个数进行修改。 从而达到改变维度及尺寸。</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a1 <span class="token operator">=</span> a<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a2 <span class="token operator">=</span> a<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a1 shape:"</span><span class="token punctuation">,</span> a1<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a2 shape:"</span><span class="token punctuation">,</span> a2<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">a1 shape: (2, 3)[[1 2 3] [4 5 6]]a2 shape: (3, 1, 2)[[[1 2]] [[3 4]] [[5 6]]]</code></pre><ul><li><code>array.ravel(), array.flatten()</code></li></ul><p>​        其实还有更过的改变形态的方法，比如让数据变直、展平 的 <code>np.ravel()</code>, <code>np.flatten()</code>，这两个比较特殊， 我会在对速度有洁癖这节的时候详细说明。</p><ul><li><code>array.transpose()</code></li></ul><p>​        在矩阵运算的时候，也有一种形态的转化，叫做矩阵转置，<code>np.transpose()</code>, 在机器学习中也用得很多。这里提一下， 给一个小案例，你们玩玩试试。</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>aT1 <span class="token operator">=</span> a<span class="token punctuation">.</span>TaT2 <span class="token operator">=</span> np<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>aT1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>aT2<span class="token punctuation">)</span></code></pre><p>​         运行结果</p><pre class="language-none"><code class="language-none">[[1 4] [2 5] [3 6]][[1 4] [2 5] [3 6]]</code></pre><h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><ul><li><code>np.column_stack(), np.row_stack()</code></li></ul><p>​        在介绍多维数组的时候， 我们也稍微介绍了一下如何添加和并数组。现在我们再详细把数组的合并拆解都细说一下。</p><p>​        一般来说，在数据分析统计，机器学习中的数据，都是以二维来存储的。行是数据样本（第一维度），列是特征（第二维度）。 所以我们可以组合特征和组合样本。 比如将列<code>column</code>合并，特征 a 的数据和特征 b 的数据合并。</p><pre class="language-python" data-language="python"><code class="language-python">feature_a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>feature_b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">66</span><span class="token punctuation">]</span><span class="token punctuation">)</span>c_stack <span class="token operator">=</span> np<span class="token punctuation">.</span>column_stack<span class="token punctuation">(</span><span class="token punctuation">[</span>feature_a<span class="token punctuation">,</span> feature_b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c_stack<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[[ 1 11] [ 2 22] [ 3 33] [ 4 44] [ 5 55] [ 6 66]]</code></pre><p>​        一条条的数据 sample 和并。</p><pre class="language-python" data-language="python"><code class="language-python">sample_a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>sample_b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>c_stack <span class="token operator">=</span> np<span class="token punctuation">.</span>row_stack<span class="token punctuation">(</span><span class="token punctuation">[</span>sample_a<span class="token punctuation">,</span> sample_b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c_stack<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[[0.  1.1] [1.  2.2]]</code></pre><ul><li><code>np.vstack(), np.hstack(), np.stack()</code></li></ul><p>​        上面的两种方法 <code>np.column_stack()</code> 和 <code>np.row_stack()</code> 和后面的 <code>np.vstack()</code>、<code>np.hstack()</code> 相比， 有些特殊之处，我们先看看使用 <code>vstack</code> 和 <code>hstack</code> 的案例，再说说不同处吧。</p><pre class="language-python" data-language="python"><code class="language-python">feature_a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>feature_b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">66</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>c_stack <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">[</span>feature_a<span class="token punctuation">,</span>feature_b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c_stack<span class="token punctuation">)</span>sample_a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>sample_b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2.2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>c_stack <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">[</span>sample_a<span class="token punctuation">,</span>sample_b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c_stack<span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[[ 1 11] [ 2 22] [ 3 33] [ 4 44] [ 5 55] [ 6 66]][[0.  1.1] [1.  2.2]]</code></pre><p>​        看到了吗？用 <code>column_stack</code> 和 <code>row_stack()</code> 的时候，Numpy 自动帮你处理的维度信息，而用 <code>vstack</code> 和 <code>hstack</code> 的时候，你需要先确保维度信息是正确的，然后再合并。</p><ul><li><code>np.concatenate()</code></li></ul><p>​        有时候，你想要用统一的方法来处理各种不同情况的合并，<code>np.concatenate()</code> 是我最喜欢的方法，管它什么 <code>vstack</code> <code>hstack</code> 甚至是在更高维度上要合并， 我们都可以用 <code>concatenate()</code> 一个功能实现。</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[[1 2] [3 4] [5 6] [7 8]][[1 2 5 6] [3 4 7 8]]</code></pre><h5 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h5><ul><li><code>np.vsplit(), np.hsplit(), np.split()</code></li></ul><p>​        同样，能横着，竖着合并，那也能横着竖着拆解。<code>np.vsplit()</code> 和 <code>np.hsplit()</code> 就是干这事的。 如果直接在 <code>indices_or_sections</code> 后填入数字，就是要整分的段数， 而如果接着的是一个列表，那就按照列表中的 index 来取区间。可以看看下面代码注解中的意思。</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>vsplit<span class="token punctuation">(</span>a<span class="token punctuation">,</span> indices_or_sections<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 分成两段</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>vsplit<span class="token punctuation">(</span>a<span class="token punctuation">,</span> indices_or_sections<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 分片成 [:2]，[2:3], [3:]</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[array([[ 1, 11,  2, 22],       [ 3, 33,  4, 44]]), array([[ 5, 55,  6, 66],       [ 7, 77,  8, 88]])][array([[ 1, 11,  2, 22],       [ 3, 33,  4, 44]]), array([[ 5, 55,  6, 66]]), array([[ 7, 77,  8, 88]])]</code></pre><p>​        <code>np.vsplit</code> 是拿着刀沿着横向切分，那么 <code>np.hsplit</code> 就是沿纵向切分，我就不再举例了。那么有没有既能横切也能纵切的函数呢？ 当然有呀，和 <code>stack</code> 一样，如果直接用 <code>np.split()</code> 你就能选择要切分的维度来自定义切分了。</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>a<span class="token punctuation">,</span> indices_or_sections<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 分成两段</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>a<span class="token punctuation">,</span> indices_or_sections<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 在第二维度，分片成 [:2]，[2:3]，[3:]</span></code></pre><p>​        运行结果</p><pre class="language-none"><code class="language-none">[array([[ 1, 11,  2, 22],       [ 3, 33,  4, 44]]), array([[ 5, 55,  6, 66],       [ 7, 77,  8, 88]])][array([[ 1, 11],       [ 3, 33],       [ 5, 55],       [ 7, 77]]), array([[2],       [4],       [6],       [8]]), array([[22],       [44],       [66],       [88]])]</code></pre><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>​         形态变化和合并拆解都是十分有用的功能，我们介绍了很多种实用的方法来完成这些事， 而懂了这些之后，你的数据分析和机器学习才算是真正迈入入圈的第一步。</p><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><h3 id="Pandas简介-amp-安装"><a href="#Pandas简介-amp-安装" class="headerlink" title="Pandas简介&amp;安装"></a>Pandas简介&amp;安装</h3><h4 id="为什么用Pandas"><a href="#为什么用Pandas" class="headerlink" title="为什么用Pandas"></a>为什么用Pandas</h4><p>​进入大数据时代，感觉我们如果不会一些分析数据的能力，就将要被时代淘汰（明目张胆拉焦虑）。 不过好在现在的技术越来越好，越来越易用，而且网络上也有越来越多的教学内容。 只要你有一些耐心，入门其实并不难。</p><p>​现在我们将要步入新的阶段，对大数据做出新的定义，直面大数据带来的挑战，学会使用 Pandas 来处理你日常的表格&#x2F;画图&#x2F;数据分析等问题。</p><h5 id="你正在面临的问题"><a href="#你正在面临的问题" class="headerlink" title="你正在面临的问题"></a>你正在面临的问题</h5><p>​大数据虽然描述的是海量的数据，但是大数据离你却并不远，特别是大数据所涵盖的技术，在你生活当中，是时刻都能使用这些大数据涉及到的技术， 来解决你生活中的具体问题。</p><p>​是什么时候才会让我想要使用 Pandas 来处理问题呢？我下面列一条，说不定就有你正面临的问题：</p><ul><li>办公自动化<ul><li>上学上班，有 Excel 或者格式化的文本文件，需要进行数据加工处理</li><li>对大量的这些文本文件作图，想要自动化处理</li></ul></li><li>人工智能<ul><li>数据分析，可视化数据规律</li><li>数据前处理，为 AI 模型展平道路</li></ul></li></ul><h4 id="Pandas是什么"><a href="#Pandas是什么" class="headerlink" title="Pandas是什么"></a>Pandas是什么</h4><p>​简单来说，Pandas 是 Python 中一个比较常用的第三方库，里面集成了很多和数据相关的功能组件。上面提到的那些场景中， 无非就是要：</p><ol><li>处理数据</li><li>分析数据</li><li>画图</li></ol><p>​所以 Pandas 就围绕着这些环节施展能力。而且它承接了 Numpy 的能力，使用的底层也是 Numpy。按理来说，我们也能用 Numpy 来实现上述功能， 但为什么 Pandas 还是这么广为流传呢？关于这个话题，我想在后文中详细论述。</p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>​Pandas 是数据的伙伴，帮你处理和分析海量数据，学会用 Python，会很常需要处理数据，只要需要处理数据，希望你都能回想起来有这么一位数据伙伴的存在。</p><h3 id="安装Pandas"><a href="#安装Pandas" class="headerlink" title="安装Pandas"></a>安装Pandas</h3><h5 id="安装Python（略）"><a href="#安装Python（略）" class="headerlink" title="安装Python（略）"></a>安装Python（略）</h5><h5 id="安装Pandas-1"><a href="#安装Pandas-1" class="headerlink" title="安装Pandas"></a>安装Pandas</h5><p>​打开cmd或者terminal，输入指令：</p><pre class="language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> pandas<span class="token comment">#或者</span>pip3 <span class="token function">install</span> pandas</code></pre><p>​安装完成后，打开python编辑器，输入下列代码</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">print</span><span class="token punctuation">(</span>pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#0    1</span><span class="token comment">#1    2</span><span class="token comment">#2    3</span><span class="token comment">#dtype: int64</span></code></pre><h5 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h5><p>​在本地安装起来很简单，使用 Python 自带的 pip 就好了。记得安装好了之后检查一下是否能正常运行， 和是否安装到其他 Python 版本里去了（如果你电脑里有多个 Python 版本的话）。</p><h3 id="Pandas和Numpy的差别"><a href="#Pandas和Numpy的差别" class="headerlink" title="Pandas和Numpy的差别"></a>Pandas和Numpy的差别</h3><p>​我们已经讲过，Pandas 是在 Numpy 上的封装。 继承了 Numpy 的所有优点，但是这种封装有好有坏，我们在这节内容中就先来阐述一下 Pandas 和 Numpy 的对比。</p><h4 id="类比Python"><a href="#类比Python" class="headerlink" title="类比Python"></a>类比Python</h4><p>​用过 Python，你肯定熟悉里面的 List 和 Dictionary, 我比较常拿这两种形态来对比 Numpy 和 Pandas 的关系。</p><pre class="language-python" data-language="python"><code class="language-python">a_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>a_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"list:"</span><span class="token punctuation">,</span> a_list<span class="token punctuation">)</span><span class="token comment">#list: [1, 2, 3]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"dict:"</span><span class="token punctuation">,</span> a_dict<span class="token punctuation">)</span><span class="token comment">#dict: &#123;'a': 1, 'b': 2, 'c': 3&#125;</span></code></pre><p>​上面就是一种最常见的 Python 列表和字典表达方式。而下面，我们展示的就是 Numpy 和 Pandas 的一种构建方式。 试着执行下面的代码。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa_array <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a_df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>    <span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"numpy array:\n"</span><span class="token punctuation">,</span> a_array<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\npandas df:\n"</span><span class="token punctuation">,</span> a_df<span class="token punctuation">)</span></code></pre><p>​运行结果</p><pre class="language-none"><code class="language-none">numpy array: [[1 2] [3 4]]pandas df:    a  b0  1  21  3  4</code></pre><p>​你会发现，我们看到的结果中，Numpy的是没有任何数据标签信息的，你可以认为它是纯数据；而Pandas就像字典一样，还记录着数据的外围信息，比如标签名(Column)和索引(Row index)。所以我总说Numpy是Python里的列表，而Pandas是Python里的字典。</p><h4 id="对比Numpy"><a href="#对比Numpy" class="headerlink" title="对比Numpy"></a>对比Numpy</h4><p>​对于数据运算，既然我们有了 Numpy，为什么还要用 Pandas？对比列表和字典，我们很容易感受到其中的一种原因：Pandas帮我们记录的信息量变多了。</p><p>​在Numpy中，如果你不特别在其他地方标注，你是不清楚记录的这里边记录的是什么信息的，而Pandas记录的信息可以特别丰富，你给别人使用传播数据的时候，这些信息也会一起传递过去。或者你自己处理数据时对照着信息来加工数据，也会更加友善。这就是在我看来Pandas对比Numpy的一个最直观的好处。</p><p>​<strong>另外 Pandas 用于处理数据的功能也比较多，信息种类也更丰富，特别是你有一些包含字符的表格，Pandas 可以帮你处理分析这些字符型的数据表。 当然还有很多其它功能，比如处理丢失信息，多种合并数据方式，读取和保存为更可读的形式等等。</strong></p><p>​但是Pandas也有不足的地方：<strong>运算速度稍微比Numpy慢一些。</strong></p><p>​你想想，因为Pandas是在Numpy之上的一层封装，所以肯定在处理数据的时候要多几层处理，小数据量的处理不要紧，慢一点就慢一点，你也感受不到处理速度的变化；但是当数据量变大时，Numpy处理需要1小时的数据，你用Pandas处理可能得2小时。所以在使用时需要注意自己的实际需求。比如：如果在做少量数据的分析时，因为不涉及到机器学习的模型运算等，我都可以用 Pandas，但如果要模型训练， 训练过程中还一直要调用数据处理的功能， 我肯定毫不犹豫都用 Numpy 来做。</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>​Pandas 是 Numpy 的封装库，继承了 Numpy 的很多优良传统，也具备丰富的功能组件，但是你还是得分情况来酌情选择要使用的工具。</p><hr><p>注：该笔记非原创，主要是对<a href="https://mofanpy.com/">该网站</a>中教程内容的记录</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python入门笔记</title>
      <link href="/2022/04/24/python%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/24/python%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文章旨在记录本人python基础语法学习的回顾总结。知识点来自B站莫烦python的<a href="https://www.bilibili.com/video/BV1wW411Y7ai">python基础教程</a><span id="more"></span></p><h2 id="python入门笔记"><a href="#python入门笔记" class="headerlink" title="python入门笔记"></a>python入门笔记</h2><h3 id="python的安装"><a href="#python的安装" class="headerlink" title="python的安装"></a>python的安装</h3><p><a href="https://www.python.org/downloads/">下载链接</a> 按需下载噢，建议直接下载3.5以上的版本，不推荐2.X版本</p><ul><li>macOS下的安装：直接一直点下一步即可</li><li>windows下的安装：点下一步即可，记得勾选“添加到command line…..”的那个选项噢（否则无法正常使用pip3）</li><li>linux下的安装：<a href="https://www.jianshu.com/p/fd75a5cfe4dd">转载一篇博客</a></li></ul><p>安装完成后进入命令行输入python3 显示如下界面：</p><p><img src="http://cdn.leafii.top/img/20220520104806.png" alt="python3成功安装后iterm界面" loading="lazy"></p><hr><h3 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h3><p>直接上代码吧 比较浅显易懂</p><pre class="language-python" data-language="python"><code class="language-python">say_hi <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"你的第一行代码："</span><span class="token punctuation">,</span> say_hi<span class="token punctuation">)</span></code></pre><p>输出结果：</p><pre class="language-none"><code class="language-none">你的第一行代码： Hello World</code></pre><hr><h3 id="有关数学符号"><a href="#有关数学符号" class="headerlink" title="有关数学符号"></a>有关数学符号</h3><p>在数学里，“&#x3D;”就是等于的意思 但是在编程环境中“&#x3D;”就是赋值的意思，比如<code>sa y_hi = &quot;Hello World&quot;</code>就是把“Hello World”这个值赋值给名为say_hi的变量。在编程环境中的“&#x3D;&#x3D;”符号，才是用来判断是否相等的，比如<code>123==321</code>就会返回一个False值 QWQ！</p><p>还要记得在python里&#x2F;&#x2F;相当于整除，%相当于取余数噢</p><hr><h3 id="自变量variable"><a href="#自变量variable" class="headerlink" title="自变量variable"></a>自变量variable</h3><p>python不用定义类型，可以直接定义变量</p><pre class="language-python" data-language="python"><code class="language-python">apple <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span>APPLE_EGG <span class="token operator">=</span> <span class="token number">11</span>appleEgg <span class="token operator">=</span> <span class="token number">12</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token keyword">print</span><span class="token punctuation">(</span>appleEgg<span class="token punctuation">)</span></code></pre><p>如同第二节里的say_hi 一样，apple和say_hi都是变量的名称，定义变量的方式就是如此</p><p><img src="http://cdn.leafii.top/img/20220520104910.png" alt="运行结果" loading="lazy"></p><hr><h3 id="关于循环与判断"><a href="#关于循环与判断" class="headerlink" title="关于循环与判断"></a>关于循环与判断</h3><ul><li>while循环</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#while循环</span>num1 <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">while</span><span class="token punctuation">(</span>num1 <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"现在num的值为："</span><span class="token punctuation">,</span>num1<span class="token punctuation">,</span><span class="token string">"num自增1！"</span><span class="token punctuation">)</span>    num1 <span class="token operator">=</span> num1 <span class="token operator">+</span> <span class="token number">1</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">现在num的值为： 3 num自增1！现在num的值为： 4 num自增1！现在num的值为： 5 num自增1！现在num的值为： 6 num自增1！现在num的值为： 7 num自增1！现在num的值为： 8 num自增1！</code></pre><ul><li>for循环</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#迭代遍历</span>a_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> a_list<span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">#使用下标遍历</span><span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>a_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>a_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 关于range：range(1,3) --> 1 2 (左闭右开) len(a_list)就是返回a_list这个list的长度</span></code></pre><p>运行结果：</p><p><img src="http://cdn.leafii.top/img/20220520104947.png" alt="for循环代码运行结果" loading="lazy"></p><ul><li>enumerate()函数</li></ul><p>Python 的 enumerate() 函数就像是一个神秘的黑箱，你无法简单地用一句话来概括这个函数的作用与用法。</p><p>enumerate() 函数属于非常有用的高级用法，而对于这一点，很多初学者甚至中级学者都没有意识到。这个函数的基本应用就是用来遍历一个<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>对象，它在遍历的同时还可以得到当前元素的索引位置。</p><pre class="language-python" data-language="python"><code class="language-python">names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Alice"</span><span class="token punctuation">,</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token string">"Carl"</span><span class="token punctuation">]</span><span class="token keyword">for</span> index<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''0: Alice1: Bob2: Carl'''</span></code></pre><p>有很多从C或Java背景转过来的新的Python开发人员有时使用下面这种range(len(…))方法来保存运行中每个元素的索引，同时再用for循环遍历列表：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 警告: 不建议这么写</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>my_items<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> my_items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>通过巧妙地使用enumerate()函数，就像我在上面的“names”例子中写的那样，你可以使你的循环结构看起来更Pythonic和地道。</p><p>你不再需要在Python代码中专门去生成元素索引，而是将所有这些工作都交给enumerate()函数处理即可。这样，你的代码将更容易被阅读，而且减少写错代码的影响。（译者注：写的代码越多，出错几率越高，尽量将自己的代码看起来简洁，易读，Pythonic，才是我们的追求)</p><p>另一个有用的特性是，enumerate()函数允许我们为循环自定义起始索引值。enumerate()函数中接受一个可选参数，该参数允许你为本次循环中的计数器变量设置初始值：</p><pre class="language-python" data-language="python"><code class="language-python">names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Alice"</span><span class="token punctuation">,</span><span class="token string">"Bob"</span><span class="token punctuation">,</span><span class="token string">"Carl"</span><span class="token punctuation">]</span><span class="token keyword">for</span> index<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''1: Alice2: Bob3: Carl'''</span><span class="token comment">##这段代码演示的就是如何将Python的enumerate()函数默认0起始索引值修改为1</span></code></pre><ul><li>if，if else，if elif else</li></ul><pre class="language-python" data-language="python"><code class="language-python">inin <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入一个数字"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> inin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这个数字小于0"</span><span class="token punctuation">)</span><span class="token keyword">elif</span> inin <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这个数字等于3"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment">#else是相对于if来说的</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这个数字大于等于0且不等于3"</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><p><img src="http://cdn.leafii.top/img/20220520105046.png" alt="if判断代码运行结果" loading="lazy"></p><hr><h3 id="使用def定义函数"><a href="#使用def定义函数" class="headerlink" title="使用def定义函数"></a>使用def定义函数</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># a,b为参数 函数可以有返回值也可以没有噢</span>    c <span class="token operator">=</span> a<span class="token operator">+</span>b    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment">#可以通过运行结果看到调用的顺序</span>    <span class="token keyword">return</span> c<span class="token keyword">print</span><span class="token punctuation">(</span>fun<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">35</code></pre><ul><li>函数默认参数</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fun1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span>d<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#可以设置函数的参数为默认值，未写明的调用就直接用定义好的调用值</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token comment">#请注意未定义好初始值的变量不能在已经定义好初始值的变量后面</span>fun1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>fun1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>d<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">1 30 201 2 3</code></pre><hr><h3 id="全局变量-amp-局部变量"><a href="#全局变量-amp-局部变量" class="headerlink" title="全局变量&amp;局部变量"></a>全局变量&amp;局部变量</h3><pre class="language-python" data-language="python"><code class="language-python">APPLE <span class="token operator">=</span> <span class="token number">100</span>a <span class="token operator">=</span> <span class="token boolean">None</span><span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> a    <span class="token comment">#不加global a就会None</span>    a <span class="token operator">=</span> <span class="token number">20</span>    <span class="token keyword">global</span> b    b <span class="token operator">=</span> <span class="token number">120</span>    <span class="token string">'print(a)'</span>    <span class="token keyword">return</span> a<span class="token operator">+</span><span class="token number">103</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'past a:'</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"later a:"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token comment">#通过添加global，使原来是局部变量作用域的变量变为全局变量</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">past a: None123120later a: 20</code></pre><hr><h3 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h3><ul><li>macOS&#x2F;Linux下的模块安装：使用终端里的iterm即可：</li></ul><p><img src="http://cdn.leafii.top/img/20220520105116.png" alt="模块安装" loading="lazy"></p><ul><li>Windows下的安装：去官网下载</li></ul><hr><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><ul><li>创建一个文件并向其写入一些文字</li></ul><pre class="language-python" data-language="python"><code class="language-python">text <span class="token operator">=</span> <span class="token string">"This is my first test.\nThis is next line.\nThis is last line"</span><span class="token comment">#\n代表回车，在文件中就相当于输入一个句子换行</span><span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>my_file <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'my file.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>my_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>text<span class="token punctuation">)</span>my_file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#open函数第一个参数是要打开的文件的文件名，第二个参数是打开方式，w代表写，r代表只读，如果以w方式打开不存在的文件则会直接创建新文件，编辑完文件记得使用close方法保存文件</span></code></pre><ul><li>使用append打开方式（a）向文件末尾添加文字</li></ul><pre class="language-python" data-language="python"><code class="language-python">append_text <span class="token operator">=</span> <span class="token string">"\nThis is appended file."</span><span class="token comment">#a的意思是append</span>my_file <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"my file.txt"</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span>my_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>append_text<span class="token punctuation">)</span>my_file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>读取文件并print</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"my file.txt"</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token comment">#content = file.read()</span><span class="token comment">#readline是一行一行读</span>content <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> content<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>second_read_time <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span>second_read_time<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">This is my first test.This is next line.This is last lineThis is appended file.This is appended file.[&#39;This is my first test.\n&#39;, &#39;This is next line.\n&#39;, &#39;This is last line\n&#39;, &#39;This is appended file.\n&#39;, &#39;This is appended file.&#39;] [&#39;This is my first test.\n&#39;, &#39;This is next line.\n&#39;, &#39;This is last line\n&#39;, &#39;This is appended file.\n&#39;, &#39;This is appended file.&#39;]</code></pre><hr><h3 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h3><ul><li><p>类的定义：</p><p>一般类名首字母大写 再跟上冒号，比如这样：</p></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Calculator</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> <span class="token string">"Casio Calculator"</span>    price <span class="token operator">=</span> <span class="token string">"199"</span>    <span class="token comment">#self是类内函数默认参数 self就是类本身 类似与java中的this</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>        result <span class="token operator">=</span> x <span class="token operator">+</span> y        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">minus</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> x <span class="token operator">-</span> y        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">times</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> x <span class="token operator">*</span> y        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">divide</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> x <span class="token operator">/</span> y        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><p>在类里可以定义属性，也可以定义类中的函数，但注意<strong>类中的函数参数列表的第一个参数必须是self，self类似于java对象中的this指针</strong></p><ul><li>类的实例化及调用：</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#类的实例化</span>cal <span class="token operator">=</span> Calculator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#类中的元素</span>cal<span class="token punctuation">.</span>name<span class="token comment">#类中的方法</span>cal<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><ul><li>类的__init__方法</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Calculator</span><span class="token punctuation">:</span>    <span class="token comment">#name = "Casio Calculator"</span>    <span class="token comment">#price = "199"</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>height<span class="token punctuation">,</span>width<span class="token punctuation">,</span>weight<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">#init这个函数类似java中类的构造函数,但是类中的元素不像java需要提前定义好 类在初始化时会自动执行__init__()函数QWQ！</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'!!!initinit!!!'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>price <span class="token operator">=</span> price        self<span class="token punctuation">.</span>h <span class="token operator">=</span> height        self<span class="token punctuation">.</span>wi <span class="token operator">=</span> width        self<span class="token punctuation">.</span>we <span class="token operator">=</span> weight    <span class="token comment">#self是类内函数默认参数 self就是类本身 类似与java中的this</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>        result <span class="token operator">=</span> x <span class="token operator">+</span> y        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">minus</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> x <span class="token operator">-</span> y        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">times</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> x <span class="token operator">*</span> y        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">divide</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> x <span class="token operator">/</span> y        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> </code></pre><hr><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre class="language-python" data-language="python"><code class="language-python">a_input <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'Please give me a number:'</span><span class="token punctuation">)</span> <span class="token comment">#return a string so it equals '1' not equals 1</span><span class="token keyword">if</span> a_input<span class="token operator">==</span><span class="token string">'1'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is a good one"</span><span class="token punctuation">)</span><span class="token keyword">elif</span> a_input<span class="token operator">==</span><span class="token string">'2'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"see you next time"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"FKU!"</span><span class="token punctuation">)</span>b_input <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'Please give me a b number:'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#return a string so it equals '1' not equals 1</span><span class="token keyword">if</span> b_input<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is a good one"</span><span class="token punctuation">)</span><span class="token keyword">elif</span> b_input<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"see you next time"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"FKU!"</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">Please give me a number:1this is a good onePlease give me a b number:3FKU!</code></pre><p><strong>请注意，python3中的input，默认输入的是字符串，记得转格式再使用</strong></p><hr><h3 id="元组-amp-列表-amp-字典"><a href="#元组-amp-列表-amp-字典" class="headerlink" title="元组&amp;列表&amp;字典"></a>元组&amp;列表&amp;字典</h3><ul><li>元组(tuple)</li></ul><p>元组tuple最大的特征是内容不可变，因此使用频率低，一般常用List</p><ul><li>列表(List)</li></ul><p>列表是我们最常用的一种存储数据机制。它就像一个抽屉一样，存放着各种信息，每一格都是一个存储单元，每一格都可以单独获取。</p><pre class="language-python" data-language="python"><code class="language-python">files <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"f1.txt"</span><span class="token punctuation">,</span> <span class="token string">"f2.txt"</span><span class="token punctuation">,</span> <span class="token string">"f3.txt"</span><span class="token punctuation">,</span> <span class="token string">"f4.txt"</span><span class="token punctuation">,</span> <span class="token string">"f5.txt"</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"files[0] "</span><span class="token punctuation">,</span> files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"files[3] "</span><span class="token punctuation">,</span> files<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"files[-1] "</span><span class="token punctuation">,</span> files<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"files[-3] "</span><span class="token punctuation">,</span> files<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>运行结果</p><pre class="language-none"><code class="language-none">files[0]  f1.txtfiles[3]  f4.txtfiles[-1]  f5.txtfiles[-3]  f3.txt</code></pre><p>在列表中，既然你已经把东西按顺序存放到抽屉中了，那你就可以按照顺序拿到你存放的东西。 在Python中，我们将上面的数字号叫做 index 索引。现实中第1个位置的东西，在Python中，是第0位。 <strong>所以Python的第一个索引永远都是 0。</strong> 除了正着来取东西，我们完全也可以反着来取东西，第一个反着取的序号是 <strong>-1</strong>。以此类推，-3 这个索引就是倒着数第三个。</p><p>而且在Python中，还很方便的可以一次性拿到多个抽屉的结果。比如下面我们就来演示一下取从多少位到多少位的东西。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"files[:3] "</span><span class="token punctuation">,</span> files<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"files[2:4] "</span><span class="token punctuation">,</span> files<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"files[-3:] "</span><span class="token punctuation">,</span> files<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">files[:3]  [&#39;f1.txt&#39;, &#39;f2.txt&#39;, &#39;f3.txt&#39;]files[2:4]  [&#39;f3.txt&#39;, &#39;f4.txt&#39;]files[-3:]  [&#39;f3.txt&#39;, &#39;f4.txt&#39;, &#39;f5.txt&#39;]</code></pre><p><strong>在列表中，你可以存放不同类型的元素，字符，数字，甚至列表里还能有列表。</strong></p><ul><li>多维List</li></ul><pre class="language-python" data-language="python"><code class="language-python">a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>multi_dim_a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>multi_dim_a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">13</code></pre><ul><li>字典(dictionary)</li></ul><p>key-&gt;value  一一对应 这里的key对应的就是list中的index哦！这个字典中的 key 都是唯一的，如果你的抽屉出现了重名，我相信你应该也不知道到底是哪个抽屉放着想要找的东西吧。 而 value 是多样的，你可以放一个字符，一个数字，甚至一个列表，甚至是另一个字典。当你想要索引的时候，用 key 就能找到里面的内容。同列表，字典也是可以修改的。</p><pre class="language-python" data-language="python"><code class="language-python">a_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>d <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'apple'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'pear'</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'orange'</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">&#125;</span>d2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string">'abandon'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token string">'bear'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">:</span><span class="token string">'ciliba'</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>d2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#删除字典元素 del</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">del</span> d<span class="token punctuation">[</span><span class="token string">'orange'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token comment">#添加元素的话直接定义就行</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>d<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token comment">#字典里也可以加字典 function</span>dd <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'apple'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'pear'</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token string">'a'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">'orange'</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>dd<span class="token punctuation">[</span><span class="token string">'pear'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p> 运行结果：</p><pre class="language-none"><code class="language-none">abandon1&#123;&#39;apple&#39;: 1, &#39;pear&#39;: 2, &#39;orange&#39;: 3&#125;&#123;&#39;apple&#39;: 1, &#39;pear&#39;: 2&#125;&#123;&#39;apple&#39;: 1, &#39;pear&#39;: 2&#125;&#123;&#39;apple&#39;: 1, &#39;pear&#39;: 2, &#39;b&#39;: 20&#125;a</code></pre><hr><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>载入模块</li></ul><p>可以使用<code>import 模块名</code> 来载入模块，也可以用<code>import time as t</code>使t成为被引入模块time的别名，方便调用。如果只想使用一个模块中的部分功能：<code>from time import time,localtime</code>,其中time，localtime就是time模块中的两个方法名。也可以使用from引入模块中的所有方法，引入后调用方法无需输入方法前的模块名，如<code>from time import *</code></p><ul><li>自定义模块</li></ul><p>自己编写的.py文件和当前在编码的文件同路径时，直接使用import引入即可，或者把自己编写的.py文件复制&#x2F;移动到python系统下载其他模块的默认目录中也可以。</p><hr><h3 id="continue-amp-break"><a href="#continue-amp-break" class="headerlink" title="continue&amp;break"></a>continue&amp;break</h3><ul><li>在没有continue，break时：</li></ul><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token boolean">True</span><span class="token keyword">while</span> a<span class="token punctuation">:</span>    b <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'type sth:'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> b<span class="token operator">==</span><span class="token string">'1'</span><span class="token punctuation">:</span>        a <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"finish running"</span><span class="token punctuation">)</span></code></pre><ul><li>有break时</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    b <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'type sth:'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> b<span class="token operator">==</span><span class="token string">'1'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"still in while"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"finish running"</span><span class="token punctuation">)</span></code></pre><ul><li>有continue时 continue跳过循环范围内的的后续代码:else … print… 从而不输出still in while</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    b <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'type sth:'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> b<span class="token operator">==</span><span class="token string">'1'</span><span class="token punctuation">:</span>d        <span class="token keyword">continue</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"still in while"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"finish running"</span><span class="token punctuation">)</span></code></pre><hr><h3 id="错误处理try"><a href="#错误处理try" class="headerlink" title="错误处理try"></a>错误处理try</h3><ul><li>没有try时</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'eee.txt'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token comment">#如果文件名输入错误，或者文件不存在时会直接报错，影响程序后续执行</span></code></pre><ul><li>使用try</li></ul><pre class="language-python" data-language="python"><code class="language-python">filename <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'input file name:'</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span><span class="token string">'r+'</span><span class="token punctuation">)</span><span class="token comment"># 捕获错误</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'there is no file QWQ'</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'do you want to create a new file?(y/n)'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> response <span class="token operator">==</span> <span class="token string">'y'</span><span class="token punctuation">:</span>        <span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token comment">#如果try成功了</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'aaa'</span><span class="token punctuation">)</span><span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><hr><h3 id="使用lambda，zip，map"><a href="#使用lambda，zip，map" class="headerlink" title="使用lambda，zip，map"></a>使用lambda，zip，map</h3><p>map 分两部分 功能和参数合起来，lambda相当于简化的功能&#x2F;函数，zip是迭代器所需要的东西，直接上代码：</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token comment">#zip是把a和b竖向合并</span><span class="token builtin">zip</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token comment">#zip返回值是一个功能</span>ll <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span><span class="token comment">##[(1, 4), (2, 5), (3, 6)] 此为print(ll)的结果</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>j <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>j<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment">## 0.5 8</span><span class="token comment">## 1.0 10</span><span class="token comment">## 1.5 12</span><span class="token comment">#能否zip更多元素？</span>lll <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>lll<span class="token punctuation">)</span><span class="token comment">##[(1, 1, 4), (2, 2, 5), (3, 3, 6)]  此为print(lll)的结果</span><span class="token comment">#lambda:</span><span class="token comment"># 未使用lambda</span><span class="token keyword">def</span> <span class="token function">fun1</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>fun1<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">## 5</span>  <span class="token comment"># 使用lambda 可提高代码可读性</span>fun2 <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span>x<span class="token operator">+</span>y<span class="token keyword">print</span><span class="token punctuation">(</span>fun2<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">## 5</span><span class="token comment">#map</span><span class="token comment">#把已知的功能加上所要给的参数一起输入运算 是一个object</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span>fun1<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">## [10]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span>fun1<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">## [5, 7, 9]</span></code></pre><hr><h3 id="深复制-amp-浅复制"><a href="#深复制-amp-浅复制" class="headerlink" title="深复制&amp;浅复制"></a>深复制&amp;浅复制</h3><ul><li><p>浅复制与深复制的区别：浅拷贝，拷贝父对象不会拷贝子对象，深拷贝的话完全拷贝父及子对象</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> copya <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>b <span class="token operator">=</span> a<span class="token comment">#id是在硬盘中的索引</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">11</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">12</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token comment">#改变a的值，b也跟着变</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">==</span><span class="token builtin">id</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#浅复制 只复制值 不复制地址</span>c <span class="token operator">=</span> copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">==</span><span class="token builtin">id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>c<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">22222</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>d<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>e <span class="token operator">=</span> copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">==</span><span class="token builtin">id</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token builtin">id</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#True</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">11</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">333</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token comment">#所以浅复制的list中的list是无法幸免的 还是会被同步</span>e <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token builtin">id</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#False</span><span class="token comment">#list表有单独索引，这个不一样。但是表内元素索引一样的，说明都指向那个元素，感觉空间节省了。</span></code></pre></li></ul><hr><h3 id="pickle存放数据"><a href="#pickle存放数据" class="headerlink" title="pickle存放数据"></a>pickle存放数据</h3><p>可以使用pickle保存一些你之后想再次利用的数据，以二进制形式保存噢，后缀名一般为.pickle。</p><ul><li>保存数据</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pickle<span class="token comment">#可以在你想保存运算结果时做到保存和提取的功能</span>a_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'da'</span><span class="token punctuation">:</span><span class="token number">111</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'23'</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">:</span><span class="token string">'sad'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'pickle_example.pickle'</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token comment">#dump()函数！！file的后缀名记得是.pickle哦</span>pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>a_dict<span class="token punctuation">,</span><span class="token builtin">file</span><span class="token punctuation">)</span><span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>从.pickle文件中读取数据</li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'pickle_example.pickle'</span><span class="token punctuation">,</span><span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span><span class="token comment">#使用with开头的这个句子不用file.close()诶 好神奇qwq！</span><span class="token comment">#file = open('pickle_example.pickle','rb')</span>    a_dict1 <span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a_dict1<span class="token punctuation">)</span><span class="token comment">#file.close()</span></code></pre><hr><h3 id="使用set来找不同"><a href="#使用set来找不同" class="headerlink" title="使用set来找不同"></a>使用set来找不同</h3><pre class="language-python" data-language="python"><code class="language-python">char_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>char_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&#123;'a', 'c', 'b', 'd'&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>char_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&lt;class 'set'></span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&lt;class 'dict'></span>sentence <span class="token operator">=</span> <span class="token string">'Welcome Back to This Tutorial'</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&#123;'T', 'W', 'h', 'i', 'r', 'o', 'm', 'a', ' ', 'u', 'e', 'c', 'B', 't', 'l', 's', 'k'&#125;</span><span class="token comment">#print(set([sentence,char_list])) 会报错 不能传列表+列表的形式</span>unique_char <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span>char_list<span class="token punctuation">)</span>unique_char<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>unique_char<span class="token punctuation">)</span><span class="token comment">#&#123;'b', 'a', 'x', 'd', 'c'&#125;</span><span class="token comment">#unique_char.add(['a','x']) 也错了捏</span><span class="token comment">#可以减东西吗？qwq</span>unique_char<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>unique_char<span class="token punctuation">)</span><span class="token comment">#单独去除东西呢？</span>unique_char<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token comment">#返回值为None哦 打印出的结果就是None</span><span class="token keyword">print</span><span class="token punctuation">(</span>unique_char<span class="token punctuation">)</span><span class="token comment">#&#123;'a', 'c', 'd', 'b'&#125;</span><span class="token comment">#如果remove一个不存在的元素，就会报错 所以使用discard()</span><span class="token keyword">print</span><span class="token punctuation">(</span>unique_char<span class="token punctuation">.</span>discard<span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>unique_char<span class="token punctuation">)</span><span class="token comment">#比较两个set set1=&#123;'b', 'a', 'x', 'd', 'c'&#125; set2 = &#123;'a','e','i'&#125;</span>set1 <span class="token operator">=</span> unique_charset2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>set2<span class="token punctuation">.</span>difference<span class="token punctuation">(</span>set1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&#123;'e', 'i'&#125; differece是做差 不具备可交换性</span><span class="token keyword">print</span><span class="token punctuation">(</span>set1<span class="token punctuation">.</span>difference<span class="token punctuation">(</span>set2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&#123;'x', 'b', 'd', 'c'&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>set1<span class="token punctuation">.</span>intersection<span class="token punctuation">(</span>set2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&#123;'a'&#125; intersection为取交集</span><span class="token keyword">print</span><span class="token punctuation">(</span>set2<span class="token punctuation">.</span>intersection<span class="token punctuation">(</span>set1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&#123;'a'&#125;</span></code></pre><hr><h3 id="RegEx-正则表达"><a href="#RegEx-正则表达" class="headerlink" title="RegEx 正则表达"></a>RegEx 正则表达</h3><p>请参考<a href="https://mofanpy.com/tutorials/python-basic/interactive-python/regex/">这个链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的操作（pta题目）</title>
      <link href="/2022/03/29/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88pta%E9%A2%98%E7%9B%AE%EF%BC%89/"/>
      <url>/2022/03/29/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88pta%E9%A2%98%E7%9B%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本题要求实现给定二叉搜索树的5种常用操作。</p><span id="more"></span>函数接口定义：<pre class="language-C" data-language="C"><code class="language-C">BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );</code></pre><p>其中BinTree结构定义如下：</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123;    ElementType Data;    BinTree Left;    BinTree Right;&#125;;</code></pre><ul><li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li><li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li><li>函数<code>Find</code>在二叉搜索树<code>BST</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li><li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li><li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li></ul><h2 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h2><pre class="language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123;    ElementType Data;    BinTree Left;    BinTree Right;&#125;;void PreorderTraversal( BinTree BT ); &#x2F;* 先序遍历，由裁判实现，细节不表 *&#x2F;void InorderTraversal( BinTree BT );  &#x2F;* 中序遍历，由裁判实现，细节不表 *&#x2F;BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main()&#123;    BinTree BST, MinP, MaxP, Tmp;    ElementType X;    int N, i;    BST &#x3D; NULL;    scanf(&quot;%d&quot;, &amp;N);    for ( i&#x3D;0; i&lt;N; i++ ) &#123;        scanf(&quot;%d&quot;, &amp;X);        BST &#x3D; Insert(BST, X);    &#125;    printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\n&quot;);    MinP &#x3D; FindMin(BST);    MaxP &#x3D; FindMax(BST);    scanf(&quot;%d&quot;, &amp;N);    for( i&#x3D;0; i&lt;N; i++ ) &#123;        scanf(&quot;%d&quot;, &amp;X);        Tmp &#x3D; Find(BST, X);        if (Tmp &#x3D;&#x3D; NULL) printf(&quot;%d is not found\n&quot;, X);        else &#123;            printf(&quot;%d is found\n&quot;, Tmp-&gt;Data);            if (Tmp&#x3D;&#x3D;MinP) printf(&quot;%d is the smallest key\n&quot;, Tmp-&gt;Data);            if (Tmp&#x3D;&#x3D;MaxP) printf(&quot;%d is the largest key\n&quot;, Tmp-&gt;Data);        &#125;    &#125;    scanf(&quot;%d&quot;, &amp;N);    for( i&#x3D;0; i&lt;N; i++ ) &#123;        scanf(&quot;%d&quot;, &amp;X);        BST &#x3D; Delete(BST, X);    &#125;    printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\n&quot;);    return 0;&#125;&#x2F;* 你的代码将被嵌在这里 *&#x2F;</code></pre><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><pre class="language-none"><code class="language-none">105 8 6 2 4 1 0 10 9 756 3 10 0 555 7 0 10 3</code></pre><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><pre class="language-none"><code class="language-none">Preorder: 5 2 1 0 4 8 6 7 10 96 is found3 is not found10 is found10 is the largest key0 is found0 is the smallest key5 is foundNot FoundInorder: 1 2 4 6 8 9</code></pre><h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><pre class="language-C" data-language="C"><code class="language-C">BinTree Insert( BinTree BST, ElementType X )&#123;    &#x2F;&#x2F;如果是一个空节点    if(!BST)&#123;        BST &#x3D; (BinTree)malloc(sizeof(struct TNode));&#x2F;&#x2F;既然为空所以要生成一个        BST-&gt;Data &#x3D; X;        BST-&gt;Left &#x3D; NULL;        BST-&gt;Right &#x3D; NULL;    &#125;    else&#123;&#x2F;&#x2F;一般情况        if(X &lt; BST-&gt;Data)&#123;&#x2F;&#x2F;插入值小于节点，应该往左子树中找位置            BST-&gt;Left &#x3D; Insert(BST-&gt;Left,X);&#x2F;&#x2F;递归插入左子树        &#125;        else if(X &gt; BST-&gt;Data)&#123;&#x2F;&#x2F;插入值大于节点，应该往右子树中找            BST-&gt;Right &#x3D; Insert(BST-&gt;Right,X);&#x2F;&#x2F;递归插入右子树        &#125;        &#x2F;&#x2F;如果相等说明X已经存在，什么也不做    &#125;    return BST;&#125;Position Find( BinTree BST, ElementType X )&#123;    while(BST)&#123;&#x2F;&#x2F;直接循环查找，类似链表        if(X &lt; BST-&gt;Data)&#123;            BST &#x3D; BST-&gt;Left;&#x2F;&#x2F;小于节点，找左子树        &#125;        else if(X &gt; BST-&gt;Data)&#123;&#x2F;&#x2F;大于节点，找右子树            BST &#x3D; BST-&gt;Right;        &#125;        else&#123;&#x2F;&#x2F;相等则找到            return BST;        &#125;    &#125;    return NULL;&#125;Position FindMin( BinTree BST )&#123;    if(!BST)&#123;        return NULL;    &#125;    else if(!BST-&gt;Left)        return BST;    else return FindMin(BST-&gt;Left);&#125;Position FindMax( BinTree BST )&#123;    if(!BST)return NULL;    else if(!BST-&gt;Right)return BST;    else return FindMax(BST-&gt;Right);&#125;BinTree Delete( BinTree BST, ElementType X )&#123;    Position temp;    if(!BST)&#123;        printf(&quot;Not Found\n&quot;);&#x2F;&#x2F;如果最终树为空，说明没有    &#125;    else&#123;&#x2F;&#x2F;这里类似于插入重点在于找到后怎么办        if(X &lt; BST-&gt;Data)&#123;            BST-&gt;Left &#x3D; Delete(BST-&gt;Left,X);&#x2F;&#x2F;从左子树递归删除        &#125;        else if(X &gt; BST-&gt;Data)&#123;            BST-&gt;Right &#x3D; Delete(BST-&gt;Right,X);&#x2F;&#x2F;从右子树递归删除        &#125;        else&#123;&#x2F;&#x2F;当前BST就是要删除的节点              if(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;&#x2F;&#x2F;要被删除的节点有左右两个孩子，就从右子树中找最小的数填充删除的节点                temp &#x3D; FindMin(BST-&gt;Right);&#x2F;&#x2F;找最小                BST-&gt;Data &#x3D; temp-&gt;Data;&#x2F;&#x2F;填充删除的节点                BST-&gt;Right &#x3D; Delete(BST-&gt;Right,temp-&gt;Data);&#x2F;&#x2F;删除拿来填充的那个节点              &#125;              else&#123;&#x2F;&#x2F;只有一个子节点                temp &#x3D; BST;                if(!BST-&gt;Left)&#123;&#x2F;&#x2F;只有右节点                    BST &#x3D; BST-&gt;Right;&#x2F;&#x2F;直接赋值就可以                &#125;                else if(!BST-&gt;Right)&#123;&#x2F;&#x2F;只有左节点                    BST &#x3D; BST-&gt;Left;&#x2F;&#x2F;直接赋值就可以                &#125;                free(temp);&#x2F;&#x2F;如果啥也没有直接删除就可以，当然上面两种情况赋值后也要删除              &#125;        &#125;    &#125;    return BST;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOs汇编入门(HelloWorld)</title>
      <link href="/2021/05/13/macOs%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8-HelloWorld/"/>
      <url>/2021/05/13/macOs%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8-HelloWorld/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编入门"><a href="#汇编入门" class="headerlink" title="汇编入门"></a>汇编入门</h1><p>本文介绍在macOs下如何安装nasm以及在nasm下进行HelloWorld的编写</p><span id="more"></span><hr><h2 id="安装nasm"><a href="#安装nasm" class="headerlink" title="安装nasm"></a>安装nasm</h2><p>在终端中输入<code>brew install nasm</code>即可。默认的nasm版本太低无法写64位程序 呜呜！</p><ul><li>注：安装完成后输入命令nasm -v查看是否可以显示版本！可以显示版本就说明安装好了哦!</li></ul><p><img src="http://cdn.leafii.top/img/20220520110215.png" alt="安装成功" loading="lazy"></p><hr><h2 id="nasm的helloworld的编写"><a href="#nasm的helloworld的编写" class="headerlink" title="nasm的helloworld的编写"></a>nasm的helloworld的编写</h2><ol><li>编写以下代码(文件命名为helloworld.asm):</li></ol><pre class="language-nasm" data-language="nasm"><code class="language-nasm"><span class="token keyword">SECTION .data</span>   <span class="token label function">msg:</span> db <span class="token string">"hello world!"</span>, <span class="token number">0x0a</span><span class="token label function">len:</span> equ <span class="token operator">$</span><span class="token operator">-</span>msg  <span class="token keyword">SECTION .text</span><span class="token keyword">global _main</span>  <span class="token label function">kernel:</span>     syscall     ret <span class="token label function">_main:</span>     mov <span class="token register variable">rax</span>,<span class="token number">0x2000004</span>     mov <span class="token register variable">rdi</span>,<span class="token number">1</span>     mov <span class="token register variable">rsi</span>,msg     mov <span class="token register variable">rdx</span>,len     call kernel       mov <span class="token register variable">rax</span>,<span class="token number">0x2000001</span>     mov <span class="token register variable">rdi</span>,<span class="token number">0</span>     call kernel</code></pre><ol start="2"><li>保存后退出，进入iterm中该文件所在的目录，按ls确认当前文件是否在目录中</li></ol><p><img src="http://cdn.leafii.top/img/20220520110255.png" alt="确定文件" loading="lazy"></p><ol start="3"><li><p>输入以下命令生成helloworld.o文件：<code>nasm -f macho64 -o helloworld.o helloworld.asm</code></p><p><img src="http://cdn.leafii.top/img/20220520110333.png" alt="生成" loading="lazy"></p></li><li><p>输入以下命令生成helloworld可执行文件:<code>ld -o helloworld -e _main helloworld.o -lSystem</code></p></li></ol><p><img src="http://cdn.leafii.top/img/20220520110408.png" alt="生成可执行文件" loading="lazy"></p><ol start="5"><li>输入命令<code>./helloworld</code>运行可执行文件</li></ol><p><img src="http://cdn.leafii.top/img/20220520110441.png" alt="运行可执行文件" loading="lazy"></p><hr><p>参考链接：<a href="https://blog.csdn.net/u011987514/article/details/72615406">https://blog.csdn.net/u011987514/article/details/72615406</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nasm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim的配置及其使用</title>
      <link href="/2021/04/27/vim%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/04/27/vim%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="vim的配置及其使用"><a href="#vim的配置及其使用" class="headerlink" title="vim的配置及其使用"></a>vim的配置及其使用</h1><p>本文将记录本人学习vim的一些笔记以及对自己mac上面的vim的一些配置。</p><span id="more"></span><hr><h2 id="vim教程"><a href="#vim教程" class="headerlink" title="vim教程"></a>vim教程</h2><p><code>vim 文件名</code> 进入vim (默认进入命令模式)</p><ul><li>输入<code>i</code> (it means insert)进入编辑模式(在当前字符前)</li><li>输入<code>a</code>(it means append)进入编辑模式（在当前字符后添加字符）</li><li>输入<code>shift+i </code>在行前插入</li><li>输入<code>shift+a</code> 在行尾插入</li><li>输入<code>o</code>在下一行进行插入</li><li>输入<code>shift + o</code> 在当前一行的上一行插入</li><li>按<code>esc</code>退出编辑模式</li></ul><p>退出编辑模式后，回到命令模式下</p><ul><li>按<code>w</code>(word)跳动到下一个单词</li><li>按<code>b</code>(back)跳动到上一个单词</li><li><code>control+f</code>(forward) 代表下一页（等同于pagedown）</li><li><code>control+b</code>(backward)代表上一页（等同于pageup）</li><li><code>数字+gg</code>跳转到指定行</li><li><code>xx+j/k</code>跳转到这一行的下&#x2F;上xx行 比如向上10行 就是10j，向下10行就是10k</li><li>命令输入错误可以按esc进行命令的清除</li><li><code>/word+回车</code>查找指定单词，按<code>n</code>查找符合条件的下一个 <code>shift+n</code>查找符合条件的上一个</li><li><code>?word+回车</code>查找指定单词，按<code>n</code>查找符合条件的上一个 <code>shift+n</code>查找符合条件的下一个</li><li><code>cc</code>剪切光标所在的一行 删除后自动进入编辑模式</li><li><code>c2c</code>连续剪切两行</li><li><code>p</code>粘贴命令 </li><li><code>u</code>（undo）恢复上一步操作</li></ul><p>按：就可以开始输入指令</p><ul><li><code>：w</code> 保存</li><li><code>：q</code> 退出</li><li></li></ul><hr><p>vim中的方向键</p><p>hjkl means 左下上右</p><hr><p>Visual模式： <code>v</code> 这时可以通过hjkl移动光标选择文本，再使用c（剪切）yy（复制）p（粘贴）</p><p>808</p>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-1021-删除最外层的括号</title>
      <link href="/2021/03/14/leetcode-1021-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2021/03/14/leetcode-1021-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-1021-删除最外层的括号"><a href="#leetcode-1021-删除最外层的括号" class="headerlink" title="leetcode:1021.删除最外层的括号"></a>leetcode:1021.删除最外层的括号</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有效括号字符串为空 <code>(&quot;&quot;)</code>、<code>&quot;(&quot; + A + &quot;)&quot; </code>或 <code>A + B</code>，其中 <code>A </code>和<code>B</code>都是有效的括号字符串，<code>+</code> 代表字符串的连接。例如，<code>&quot;&quot;</code>，<code>&quot;()&quot;</code>，<code>&quot;(())()&quot;</code> 和 <code>&quot;(()(()))&quot;</code> 都是有效的括号字符串。</p><p>如果有效字符串<code> S</code> 非空，且不存在将其拆分为 <code>S = A+B </code>的方法，我们称其为<strong>原语（primitive）</strong>，其中 <code>A </code>和 <code>B</code> 都是非空有效括号字符串。</p><p>给出一个非空有效字符串 <code>S</code>，考虑将其进行原语化分解，使得：<code>S = P_1 + P_2 + ... + P_k</code>，其中 <code>P_i </code>是有效括号字符串原语。</p><p>对<code> S</code> 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回<code>S</code>。</p><span id="more"></span><ul><li>示例1：</li></ul><pre class="language-none"><code class="language-none">输入：&quot;(()())(())&quot;输出：&quot;()()()&quot;解释：输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;，删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; &#x3D; &quot;()()()&quot;。</code></pre><ul><li>示例2:</li></ul><pre class="language-none"><code class="language-none">输入：&quot;(()())(())(()(()))&quot;输出：&quot;()()()()(())&quot;解释：输入字符串为 &quot;(()())(())(()(()))&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;，删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; &#x3D; &quot;()()()()(())&quot;。</code></pre><ul><li>示例3:</li></ul><pre class="language-none"><code class="language-none">输入：&quot;()()&quot;输出：&quot;&quot;解释：输入字符串为 &quot;()()&quot;，原语化分解得到 &quot;()&quot; + &quot;()&quot;，删除每个部分中的最外层括号后得到 &quot;&quot; + &quot;&quot; &#x3D; &quot;&quot;。</code></pre><p><small>提示：</small></p><ol><li><code>S.length &lt;= 10000</code></li><li><code>S[i]</code>为<code>(</code>或<code>)</code></li><li><code>S</code>是一个有效括号字符串</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>简洁的Java实现</li></ol><p>主要思路：定义level作为层数，初始化level为0，遍历输入的String对象的每个字符，如果遇到’(‘，就level++，如果遇到’)’就level–，如果level&gt;&#x3D;1，则在要输出的字符串末尾加上被遍历的字符，代码如下：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">removeOuterParentheses</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token class-name">S</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">StringBuilder</span> outputStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch <span class="token operator">:</span> <span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                level<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>level <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                outputStr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                level<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> outputStr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>作者：huaouo</p><ol start="2"><li>借助栈原语化分解后删除最外层括号——Java</li></ol><p>主要思路：遍历字符串，遇到左括号就入栈，遇到右括号就出栈，每次栈空的时候，都说明找到了一个原语，记录下每个原语的起始位置和结束位置，取原字符串在原语的起始位置+1到原语的结束位置的子串便得到原语删除了最外层括号的字符串，拼接，即可解出答案。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">removeOuterParentheses</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token class-name">S</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">StringBuilder</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 初始化原语的起始位置</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 初始化原语的结束位置</span>        <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">// 标志每个原语</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 遇到左括号，入栈</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 遇到的第一个左括号，是原语的开始位置，记录下原语开始位置</span>                    start <span class="token operator">=</span> i<span class="token punctuation">;</span>                    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 遇到右括号，出栈</span>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 当栈空的时候，找到了一个完整的原语</span>                    end <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">// 记录下结束位置</span>                    ans<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 去掉原语的最外层括号，并追加到答案中</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">// 置标志为false，往后接着找下一个原语</span>                    start <span class="token operator">=</span> end<span class="token punctuation">;</span><span class="token comment">// 往后找，再次初始化原语开始位置</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>作者：zi-mo-10</p><hr><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-outermost-parentheses">https://leetcode-cn.com/problems/remove-outermost-parentheses</a></p><p>链接：<a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/solution/jian-ji-de-java-shi-xian-by-huaouo/">https://leetcode-cn.com/problems/remove-outermost-parentheses/solution/jian-ji-de-java-shi-xian-by-huaouo/</a></p><p>链接：<a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/solution/chao-xiang-xi-ti-jie-si-lu-jie-zhu-zhan-yuan-yu-hu/">https://leetcode-cn.com/problems/remove-outermost-parentheses/solution/chao-xiang-xi-ti-jie-si-lu-jie-zhu-zhan-yuan-yu-hu/</a></p><p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode:1.两数之和</title>
      <link href="/2021/03/13/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2021/03/13/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode:1.两数之和"></a>leetcode:1.两数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><span id="more"></span><p>你可以按任意顺序返回答案。</p><ul><li>示例1:</li></ul><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</code></pre><ul><li>示例2</li></ul><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]</code></pre><ul><li>示例3</li></ul><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1]</code></pre><p><small>提示：</small></p><ul><li><code>2 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol><li>暴力解法</li></ol><p>直接使用双层for循环。java实现如下：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                    a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>                    <span class="token keyword">return</span> a<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li>哈希表解法：</li></ol><p>一种常见的解决方案是使用哈希表存储数组中的每个数字和它的索引，并在遍历数组时查找与当前数字的差值（目标值减去当前数字）是否存在于哈希表中。如果存在，则说明找到了两个数字，否则将当前数字和索引插入哈希表中。</p><p>C++实现：</p><pre class="language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int, int&gt; m;        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            int temp &#x3D; target - nums[i];            if (m.count(temp)) &#123;                return &#123;m[temp], i&#125;;            &#125;            m[nums[i]] &#x3D; i;        &#125;        return &#123;&#125;;    &#125;&#125;;</code></pre><p>java实现：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> hashtable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>hashtable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>力扣：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA2020版如何创建Servlet的javaWeb项目</title>
      <link href="/2021/03/05/IDEA2020%E7%89%88%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAServlet%E7%9A%84javaWeb%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/03/05/IDEA2020%E7%89%88%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAServlet%E7%9A%84javaWeb%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA2020版如何创建Servlet的javaWeb项目"><a href="#IDEA2020版如何创建Servlet的javaWeb项目" class="headerlink" title="IDEA2020版如何创建Servlet的javaWeb项目"></a>IDEA2020版如何创建Servlet的javaWeb项目</h1><p>2020款idea很多地方都变了，昨天在创建javaweb项目中发现已经不会创建了，所以我写这篇笔记记录一下QAQ</p><span id="more"></span><h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h2><p>主要思路：先创建空白项目，然后添加框架支持。</p><ol><li>在idea中点击file-&gt;new-&gt;Project&#x2F;Module；</li></ol><p><img src="http://cdn.leafii.top/img/20220520110725.png" loading="lazy"></p><ol start="2"><li>在选中Java的情况下，直接点击Next；</li></ol><p><img src="http://cdn.leafii.top/img/20220520110904.png" loading="lazy"></p><ol start="3"><li>然后再点击下一步；</li></ol><p><img src="http://cdn.leafii.top/img/20220520110921.png" loading="lazy"></p><ol start="4"><li>填写你的项目名称和位置，点击finish;</li></ol><p><img src="http://cdn.leafii.top/img/20220520110957.png" loading="lazy"></p><ol start="5"><li><p>此时的工程目录结构如下：，我们在工程的文件夹上鼠标右键-&gt;add FrameWork Support ；<img src="http://cdn.leafii.top/img/20220520111035.png" loading="lazy"><img src="http://cdn.leafii.top/img/20220520111157.png" loading="lazy"></p></li><li><p>在新的页面勾选Web Application，并点击OK；<img src="http://cdn.leafii.top/img/20220520114704.png" loading="lazy"></p></li><li><p>在WEB-INF中增加 classes 和 lib<img src="http://cdn.leafii.top/img/20220520141823.png" loading="lazy"></p></li><li><p>进入Project Structure配置classes和lib两个目录<img src="http://cdn.leafii.top/img/20220520141844.png" loading="lazy"></p></li><li><p>添加TomCat到Idea中，点击AddConfiguration，点击新窗口左上角的+号，选择Tomcat下的local，配置好tomcat的路径，然后在deployment标签下添加你的项目的exploded包，点击OK;<img src="http://cdn.leafii.top/img/20220520141902.png" loading="lazy"></p></li><li><p>配置ServletApi到工程的运行库里：点击File-&gt;Project Structure,点击Modules标签，点击下方的+号，选择Library…，然后选择你的相应的Tomcat，点击ok，就可以添加ServletApi到你的项目中。<img src="http://cdn.leafii.top/img/20220520141920.png" loading="lazy"></p></li><li><p>新建一个Servlet类，这个就不截图了奥直接上代码</p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">top<span class="token punctuation">.</span>leafii<span class="token punctuation">.</span>servlet</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">jakarta<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">implements</span> <span class="token class-name">Servlet</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">ServletConfig</span> servletConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">ServletConfig</span> <span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> servletRequest<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> servletResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用了Servlet哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getServletInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="12"><li>对应的web.xml文件</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd<span class="token punctuation">"</span></span>         <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>HelloServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>top.leafii.servlet.HelloServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>HelloServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span></code></pre><ol start="13"><li>调用了HelloServlet后<img src="http://cdn.leafii.top/img/20220520141942.png" loading="lazy"></li></ol><p>可以看到 已经完成了 可以开始你的javaWeb之旅了</p><hr><p>参考链接：<a href="https://blog.csdn.net/gaoqingliang521/article/details/108677301">IntelliJ IDEA创建Servlet最新方法 Idea版本2020.2.2以及IntelliJ IDEA创建Servlet 404问题（超详细）_gaoqingliang521的专栏-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用正则表达式</title>
      <link href="/2021/03/03/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/03/03/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>很多不太懂正则的朋友，在遇到需要用正则校验数据时，往往是在网上去找很久，结果找来的还是不很符合要求。所以我最近把开发中常用的一些正则表达式整理了一下，在这里分享一下。给自己留个底，也给朋友们做个参考。</p><span id="more"></span><h2 id="一、校验数字的表达式"><a href="#一、校验数字的表达式" class="headerlink" title="一、校验数字的表达式"></a>一、校验数字的表达式</h2><pre class="language-none"><code class="language-none">1. 数字：^[0-9]*$2. n位的数字：^\d&#123;n&#125;$3. 至少n位的数字：^\d&#123;n,&#125;$4. m-n位的数字：^\d&#123;m,n&#125;$5. 零和非零开头的数字：^(0|[1-9][0-9]*)$6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$7. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$9. 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10. 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$12. 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$13. 非负整数：^\d+$ 或 ^[1-9]\d*|0$14. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></pre><h2 id="二、校验字符的表达式"><a href="#二、校验字符的表达式" class="headerlink" title="二、校验字符的表达式"></a>二、校验字符的表达式</h2> <pre class="language-none"><code class="language-none">1. 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$3. 长度为3-20的所有字符：^.&#123;3,20&#125;$4. 由26个英文字母组成的字符串：^[A-Za-z]+$5. 由26个大写英文字母组成的字符串：^[A-Z]+$6. 由26个小写英文字母组成的字符串：^[a-z]+$7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$11. 可以输入含有^%&amp;&#39;,;&#x3D;?$\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\x22]+ 12. 禁止输入含有~的字符：[^~\x22]+</code></pre><h2 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h2> <pre class="language-none"><code class="language-none">1. Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?3. InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\s]* 或 ^http:&#x2F;&#x2F;([\w-]+\.)+[\w-]+(&#x2F;[\w-.&#x2F;?%&amp;&#x3D;]*)?$4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$5. 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$6. 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;7. 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$ 8. 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$ 12. 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15. 钱的输入格式： 16. 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ 17. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 18. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 19. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 20. 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 24. 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 25. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$26. 中文字符的正则表达式：[\u4e00-\u9fa5] 27. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 28. 空白行的正则表达式：\n\s*\r (可以用来删除空白行) 29. HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;&#x2F;\1&gt;|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 30. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 31. 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)32. 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)33. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)34. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></pre><hr><p>原文：<a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html">http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言の排序和查找</title>
      <link href="/2021/01/28/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/01/28/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言の排序和查找"><a href="#Go语言の排序和查找" class="headerlink" title="Go语言の排序和查找"></a>Go语言の排序和查找</h1><ul><li>本文主要讲Go语言的以下知识点<ul><li>冒牌排序</li><li>顺序查找</li><li>二分法查找</li><li>二维数组</li></ul></li></ul><span id="more"></span><h2 id="排序的基本介绍"><a href="#排序的基本介绍" class="headerlink" title="排序的基本介绍"></a>排序的基本介绍</h2><p>排序是将一组数据，依指定的顺序进行排列的过程。</p><p>排序的分类：</p><ol><li><p>内部排序：</p><p>指将需要处理的所有数据都加载到内部存储器中进行排序。包括（交换式排序法，选择式排序法和插入式排序法）；</p></li><li><p>外部排序法：</p><p>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。</p></li></ol><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的排序码，若发现逆序则交换，使排序码较小的元素逐渐从后部移向前部（从下标较大的单元移向下标较小的单元），就像水底下的气泡一样逐渐向上冒。</p><p>因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较（优化）。</p><h2 id="冒泡排序的思路分析"><a href="#冒泡排序的思路分析" class="headerlink" title="冒泡排序的思路分析"></a>冒泡排序的思路分析</h2><p><img src="http://cdn.leafii.top/img/20220520150853.png" loading="lazy"></p><h2 id="冒泡排序实现"><a href="#冒泡排序实现" class="headerlink" title="冒泡排序实现"></a>冒泡排序实现</h2><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>arr <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"排序前arr="</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span>temp <span class="token operator">:=</span> <span class="token number">0</span><span class="token comment">//用于交换的临时变量</span><span class="token comment">//冒泡排序--一步一步推导出来的</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token comment">//交换</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"排序后arr="</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//定义数组</span>arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span><span class="token number">224</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">&#125;</span><span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main arr="</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token comment">//有序的哦</span><span class="token punctuation">&#125;</span></code></pre><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p>需要牢记冒泡排序的代码！能默写出来才行</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><p>介绍</p><p>在Golang中，我们常用的查找有两种：</p><ol><li>顺序查找</li><li>二分查找（数组有序）</li></ol></li><li><p>案例演示：</p><ol><li>有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王</li></ol><p>猜数游戏：从键盘中任意输入一个名称，判断数列中是否包含此名称【使用顺序查找】</p><p>代码：</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>names <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token string">"白眉鹰王"</span><span class="token punctuation">,</span><span class="token string">"金毛狮王"</span><span class="token punctuation">,</span><span class="token string">"紫衫龙王"</span><span class="token punctuation">,</span><span class="token string">"青翼蝠王"</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> heroName <span class="token operator">=</span> <span class="token string">""</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入要查找的人名..."</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>heroName<span class="token punctuation">)</span><span class="token comment">//按顺序查找 第一种方式</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> heroName <span class="token operator">==</span> names<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"找到%v，下标为%v \n"</span><span class="token punctuation">,</span> heroName<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"没有找到%v \n"</span><span class="token punctuation">,</span> heroName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//顺序查找 第二种方式 （推荐）</span>index <span class="token operator">:=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> heroName <span class="token operator">==</span> names<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>index <span class="token operator">=</span> i <span class="token comment">//赋值</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"找到%v, 下标为%v\n"</span><span class="token punctuation">,</span> heroName<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"没有找到"</span><span class="token punctuation">,</span>heroName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter08&#x2F;demo02&#x2F;main  go run .&#x2F;main.go请输入要查找的人名...金毛狮王找到金毛狮王，下标为1 找到金毛狮王, 下标为1</code></pre><ol start="2"><li>请对一个有序数组进行二分查找 {1,8,10,89,1000,1234},输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示“没有这个数”。【使用到递归】</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token comment">//"time"</span><span class="token comment">//"math/rand"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">BinaryFind</span><span class="token punctuation">(</span>arr <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>leftIndex <span class="token builtin">int</span><span class="token punctuation">,</span>rightIndex <span class="token builtin">int</span><span class="token punctuation">,</span>findVal <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> leftIndex <span class="token operator">></span> rightIndex <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"找不到哦找不到哦"</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">&#125;</span>middle <span class="token operator">:=</span> <span class="token punctuation">(</span>leftIndex <span class="token operator">+</span> rightIndex<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">></span> findVal <span class="token punctuation">&#123;</span><span class="token function">BinaryFind</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> leftIndex<span class="token punctuation">,</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> findVal<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> findVal <span class="token punctuation">&#123;</span><span class="token function">BinaryFind</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightIndex<span class="token punctuation">,</span> findVal<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"这个数字的下标位置在"</span><span class="token punctuation">,</span>middle<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> arrs <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">89</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1234</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入一个数："</span><span class="token punctuation">)</span><span class="token keyword">var</span> num <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token function">BinaryFind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>arrs<span class="token punctuation">)</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter08&#x2F;demo03&#x2F;main  go run .&#x2F;main.go请输入一个数：1001找不到哦找不到哦 ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter08&#x2F;demo03&#x2F;main  go run .&#x2F;main.go请输入一个数：1000这个数字的下标位置在 4</code></pre><h2 id="二维数组的介绍"><a href="#二维数组的介绍" class="headerlink" title="二维数组的介绍"></a>二维数组的介绍</h2><p>如你所见 就是二维数组罢了</p><h2 id="二维数组应用场景"><a href="#二维数组应用场景" class="headerlink" title="二维数组应用场景"></a>二维数组应用场景</h2><p>比如开发了一个五子棋游戏，棋盘就需要二维数组来表示。如图<img src="http://cdn.leafii.top/img/20220520150929.png" loading="lazy"></p><h2 id="二维数组快速入门"><a href="#二维数组快速入门" class="headerlink" title="二维数组快速入门"></a>二维数组快速入门</h2><p>快速入门案例：</p><ul><li>请用二维数组输出如下图形</li></ul><pre class="language-none"><code class="language-none">0 0 0 0 0 00 0 1 0 0 00 2 0 3 0 00 0 0 0 0 0</code></pre><ul><li>代码演示</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">int</span>  arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>  arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>      fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v "</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="使用方式1-先声明-x2F-定义，再赋值"><a href="#使用方式1-先声明-x2F-定义，再赋值" class="headerlink" title="使用方式1:先声明&#x2F;定义，再赋值"></a>使用方式1:先声明&#x2F;定义，再赋值</h2><ul><li>语法 <code>var 数组名 [大小][大小]类型</code></li><li>比如 <code>var arr [2][3]int</code>,再赋值</li><li>使用演示</li><li>二维数组在内存的存在形式（重点）</li></ul><p><img src="http://cdn.leafii.top/img/20220520150952.png" loading="lazy"></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> arr2 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">// 以这个为例来分析arr2在内存的布局！！</span>arr2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr2[0]的地址%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr2[1]的地址%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr2[0][0]的地址%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr2[1][0]的地址%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter08&#x2F;demo04&#x2F;main  go run .&#x2F;main.go[[0 0 0] [0 10 0]]arr2[0]的地址0xc0000ac030arr2[1]的地址0xc0000ac048arr2[0][0]的地址0xc0000ac030arr2[1][0]的地址0xc0000ac048</code></pre><h2 id="使用方式2-直接初始化"><a href="#使用方式2-直接初始化" class="headerlink" title="使用方式2:直接初始化"></a>使用方式2:直接初始化</h2><ul><li>声明：<code>var 数组名 [大小][大小]类型 = [大小][大小]类型&#123;&#123;初值..&#125;,&#123;初值..&#125;&#125;</code></li><li>赋值（有默认值，比如int类型的就是0）</li><li>使用演示</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> arr3 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"arr3="</span><span class="token punctuation">,</span>arr3<span class="token punctuation">)</span></code></pre><pre class="language-none"><code class="language-none">arr3&#x3D; [[1 2 3] [4 5 6]]</code></pre><ul><li>说明：二维数组在声明&#x2F;定义时也对应有四种写法[和一维数组类似]</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> 数组名 <span class="token punctuation">[</span>大小<span class="token punctuation">]</span><span class="token punctuation">[</span>大小<span class="token punctuation">]</span>类型 <span class="token operator">=</span> <span class="token punctuation">[</span>大小<span class="token punctuation">]</span><span class="token punctuation">[</span>大小<span class="token punctuation">]</span>类型<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> 数组名 <span class="token punctuation">[</span>大小<span class="token punctuation">]</span><span class="token punctuation">[</span>大小<span class="token punctuation">]</span>类型 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">[</span>大小<span class="token punctuation">]</span>类型<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>初值<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>初值<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> 数组名 <span class="token operator">=</span> <span class="token punctuation">[</span>大小<span class="token punctuation">]</span><span class="token punctuation">[</span>大小<span class="token punctuation">]</span>类型<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>初值<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>初值<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> 数组名 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">[</span>大小<span class="token punctuation">]</span>类型<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>初值<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>初值<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><ul><li>双层for循环完成遍历</li><li>for-range方式完成遍历</li></ul><p><strong>实例演示：</strong></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//for循环遍历</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>arr3<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>      fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr3[%v][%v] = %v\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> arr3<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//for-range遍历二维数组</span>  <span class="token keyword">for</span> i<span class="token punctuation">,</span> v1 <span class="token operator">:=</span> <span class="token keyword">range</span> arr3 <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> j<span class="token punctuation">,</span> v2 <span class="token operator">:=</span> <span class="token keyword">range</span> v1 <span class="token punctuation">&#123;</span>      fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr3[%v][%v] = %v \t"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> v2<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter08&#x2F;demo05&#x2F;main  go run .&#x2F;main.goarr3[0][0] &#x3D; 1  arr3[0][1] &#x3D; 2  arr3[0][2] &#x3D; 3arr3[1][0] &#x3D; 4  arr3[1][1] &#x3D; 5  arr3[1][2] &#x3D; 6arr3[0][0] &#x3D; 1  arr3[0][1] &#x3D; 2  arr3[0][2] &#x3D; 3 arr3[1][0] &#x3D; 4  arr3[1][1] &#x3D; 5  arr3[1][2] &#x3D; 6 </code></pre><h2 id="二维数组的应用案例"><a href="#二维数组的应用案例" class="headerlink" title="二维数组的应用案例"></a>二维数组的应用案例</h2><ul><li><p>要求如下：</p><p>定义二维数组，用于保存三个班，每个班五名同学成绩，并求出每个班级平均分，以及所有班级平均分</p></li><li><p>代码</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> scores <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">float64</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请按照提示输入成绩："</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>scores<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>      fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"请输入%v班的第%v个成绩："</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>      fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>scores<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//计算各班平均分</span>  totalSum <span class="token operator">:=</span> <span class="token number">0.0</span>  count <span class="token operator">:=</span> <span class="token number">0</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    sum <span class="token operator">:=</span> <span class="token number">0.0</span>    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>scores<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>      sum <span class="token operator">+=</span> scores<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>      count<span class="token operator">++</span>    <span class="token punctuation">&#125;</span>    totalSum <span class="token operator">+=</span> sum    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"第%d个班的总分为%v,平均分为%v \n"</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span> sum <span class="token operator">/</span> <span class="token function">float64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>scores<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"所有人总分为%v,平均分为%v\n"</span><span class="token punctuation">,</span>totalSum<span class="token punctuation">,</span> totalSum <span class="token operator">/</span> <span class="token function">float64</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter08&#x2F;demo06&#x2F;main  go run .&#x2F;main.go请按照提示输入成绩：请输入1班的第1个成绩：70请输入1班的第2个成绩：80请输入1班的第3个成绩：60.5请输入1班的第4个成绩：99请输入1班的第5个成绩：100请输入2班的第1个成绩：78请输入2班的第2个成绩：97请输入2班的第3个成绩：87请输入2班的第4个成绩：67请输入2班的第5个成绩：66请输入3班的第1个成绩：99请输入3班的第2个成绩：56请输入3班的第3个成绩：87请输入3班的第4个成绩：75请输入3班的第5个成绩：70.4第1个班的总分为409.5,平均分为81.9 第2个班的总分为395,平均分为79 第3个班的总分为387.4,平均分为77.47999999999999 所有人总分为1191.9,平均分为79.46000000000001</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言の数组与切片</title>
      <link href="/2021/01/25/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"/>
      <url>/2021/01/25/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言の数组与切片"><a href="#Go语言の数组与切片" class="headerlink" title="Go语言の数组与切片"></a>Go语言の数组与切片</h1><ul><li>本文章主要讲Go语言的数组与切片</li></ul><span id="more"></span><h2 id="为什么需要数组"><a href="#为什么需要数组" class="headerlink" title="为什么需要数组"></a>为什么需要数组</h2><ul><li><p>问题</p><p>一个养鸡场有 6 只鸡，它们的体重分别是 3kg,5kg,1kg,3.4kg,2kg,50kg 。请问这六只鸡的总体重是多少?平均体重是多少? 请你编一个程序。&#x3D;》数组</p></li><li><p>使用传统方法来解决</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>hen1 <span class="token operator">:=</span> <span class="token number">3.0</span>hen2 <span class="token operator">:=</span> <span class="token number">5.0</span>hen3 <span class="token operator">:=</span> <span class="token number">1.0</span>hen4 <span class="token operator">:=</span> <span class="token number">3.4</span>hen5 <span class="token operator">:=</span> <span class="token number">2.0</span>hen6 <span class="token operator">:=</span> <span class="token number">50.0</span>totalWeight <span class="token operator">:=</span> hen1 <span class="token operator">+</span> hen2 <span class="token operator">+</span> hen3 <span class="token operator">+</span> hen4 <span class="token operator">+</span> hen5 <span class="token operator">+</span> hen6avgWeight <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2f"</span><span class="token punctuation">,</span> totalWeight <span class="token operator">/</span> <span class="token number">6</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"totalWeight = %v,avgWeight = %v \n"</span><span class="token punctuation">,</span> totalWeight<span class="token punctuation">,</span> avgWeight<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">totalWeight &#x3D; 64.4,avgWeight &#x3D; 10.73 </code></pre><p><strong>说明：</strong></p><ol><li>使用传统方法不利于数据的管理和维护</li><li>传统的方法不够灵活，因此我们需要引出新的数据类型：数组</li></ol></li></ul><h2 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h2><p>​数组可以存放多个同一类型数据。数组也是一种数据类型，在 Go 中，数组是值类型。</p><h2 id="数组的快速入门"><a href="#数组的快速入门" class="headerlink" title="数组的快速入门"></a>数组的快速入门</h2><p>我们使用数组的方法来解决养鸡场的问题</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> hens <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token builtin">float64</span>hens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3.0</span>hens<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5.0</span>hens<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1.0</span>hens<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3.4</span>hens<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2.0</span>hens<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">50.0</span>hens<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">150.0</span>totalWeight <span class="token operator">:=</span> <span class="token number">0.0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>hens<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>totalWeight <span class="token operator">+=</span> hens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">&#125;</span>avgWeight <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.2f"</span><span class="token punctuation">,</span> totalWeight <span class="token operator">/</span> <span class="token function">float64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>hens<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"totalWeight = %v,avgWeight = %v \n"</span><span class="token punctuation">,</span> totalWeight<span class="token punctuation">,</span> avgWeight<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">totalWeight &#x3D; 214.4,avgWeight &#x3D; 30.63 </code></pre><p>​<strong>说明：</strong></p><pre><code>1. 使用数组来解决问题，程序的可维护性增加2. 方法代码更加清晰，也容易扩展</code></pre><h2 id="数组定义和内存布局"><a href="#数组定义和内存布局" class="headerlink" title="数组定义和内存布局"></a>数组定义和内存布局</h2><ul><li><p>定义</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> 数组名 <span class="token punctuation">[</span>数组大小<span class="token punctuation">]</span>数据类型<span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token comment">//赋初值</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">30</span> <span class="token comment">//......</span></code></pre></li><li><p>数组在内存布局（重要）</p><p><img src="http://cdn.leafii.top/img/20220520151438.png" loading="lazy"></p><ul><li>对上图的总结：</li></ul><ol><li>数组的地址可以通过数组名来获取 <code>&amp;intArr</code></li><li>数组的第一个元素的地址，就是数组的首地址</li><li>数组的各个元素的地址间隔是依据数组的类型决定，比如 <code>int64-&gt;8 int32-&gt;4...</code></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> intArr <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">// int占8个字节</span><span class="token comment">//当我们定义完数组后，其实数组的各个元素有默认值 0</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>intArr<span class="token punctuation">)</span>intArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>intArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20</span>intArr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">30</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>intArr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"intArr的地址=%p intArr[0]的地址=%p intArr[1]的地址=%p intArr[2]的地址=%p \n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>intArr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>intArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>intArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>intArr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo02&#x2F;main  go run .&#x2F;main.go[0 0 0][10 20 30]intArr的地址&#x3D;0xc0000b8000 intArr[0]的地址&#x3D;0xc0000b8000 intArr[1]的地址&#x3D;0xc0000b8008 intArr[2]的地址&#x3D;0xc0000b8010 </code></pre><h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><ul><li>访问数组元素</li></ul><p><strong>数组名[下标]</strong> 比如：你要使用a数组的第三个元素 a[2]</p><ul><li>快速入门案例</li></ul><p>从终端循环输入5个成绩，保存到float64数组，并输出。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> score <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"请输入第%d个元素的值\n"</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>score<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//变量数组打印</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"score[%d]=%v"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> score<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo02&#x2F;main  go run .&#x2F;main.go请输入第1个元素的值5请输入第2个元素的值4请输入第3个元素的值3请输入第4个元素的值2请输入第5个元素的值1score[0]&#x3D;5      score[1]&#x3D;4      score[2]&#x3D;3      score[3]&#x3D;2      score[4]&#x3D;1 </code></pre><ul><li>四种初始化数组的方式</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//四种初始化数组的方式</span><span class="token keyword">var</span> numArr01 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"numArr01="</span><span class="token punctuation">,</span> numArr01<span class="token punctuation">)</span><span class="token keyword">var</span> numArr02 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"numArr02="</span><span class="token punctuation">,</span> numArr02<span class="token punctuation">)</span><span class="token comment">//这里的[...]是规定的写法</span><span class="token keyword">var</span> numArr03 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"numArr03="</span><span class="token punctuation">,</span> numArr03<span class="token punctuation">)</span><span class="token keyword">var</span> numArr04 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">900</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token number">999</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"numArr04="</span><span class="token punctuation">,</span> numArr04<span class="token punctuation">)</span><span class="token comment">//类型推导</span>strArr05 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">"jack"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span><span class="token string">"rose"</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"strArr05="</span><span class="token punctuation">,</span>strArr05<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo02&#x2F;main  go run .&#x2F;main.gonumArr01&#x3D; [1 2 3]numArr02&#x3D; [5 6 7]numArr03&#x3D; [8 9 10]numArr04&#x3D; [900 800 999]strArr05&#x3D; [ tom jack rose]</code></pre><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="方式1-常规遍历"><a href="#方式1-常规遍历" class="headerlink" title="方式1-常规遍历"></a>方式1-常规遍历</h3><p>看上面的，不再赘述</p><h3 id="方式2-for-range结构遍历"><a href="#方式2-for-range结构遍历" class="headerlink" title="方式2-for-range结构遍历"></a>方式2-for-range结构遍历</h3><p>这是Go语言的独有的结构，可以用来遍历访问数组的元素。</p><ul><li>for-range的基本语法</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> array01 <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span></code></pre><p>说明</p><ol><li>第一个返回值index是数组的下标</li><li>第二个value是在该下标位置的值</li><li>他们都是仅在for循环内部可见的局部变量</li><li>遍历数组元素的时候，如果不想使用下标index，可以直接把下标index标为下划线_</li><li>index和value的名称不是固定的，即程序员可以自行指定，一般命名为index和value</li></ol><ul><li>for-range的案例</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//演示for-range遍历数组</span>heroes <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"宋江"</span><span class="token punctuation">,</span> <span class="token string">"吴用"</span><span class="token punctuation">,</span> <span class="token string">"卢俊义"</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> heroes <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"i=%v v=%v"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span> v<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"heroes[%d]=%v\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> heroes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> heroes <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"元素的值=%v\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo02&#x2F;main  go run .&#x2F;main.goi&#x3D;0 v&#x3D;宋江heroes[0]&#x3D;宋江i&#x3D;1 v&#x3D;吴用heroes[1]&#x3D;吴用i&#x3D;2 v&#x3D;卢俊义heroes[2]&#x3D;卢俊义元素的值&#x3D;宋江元素的值&#x3D;吴用元素的值&#x3D;卢俊义</code></pre><h2 id="数组使用的注意事项和细节"><a href="#数组使用的注意事项和细节" class="headerlink" title="数组使用的注意事项和细节"></a>数组使用的注意事项和细节</h2><ol><li>数组是多个相同类型数据的组合，一个数组一旦声明&#x2F;定义了，其长度是固定的，不能动态变化</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//数组是多个相同类型数据的组合，一个数组一旦声明/定义了，其长度是固定的，不能动态变化。</span><span class="token keyword">var</span> arr01 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>arr01<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>arr01<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token comment">//会报错</span>arr01<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1.1</span> <span class="token comment">//数组类型和初始化的值的类型不匹配哦</span><span class="token comment">//其长度是固定的，不能动态变化，否则报越界</span>arr01<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">890</span> <span class="token comment">//数组不能动态增长</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>arr01<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li><p><code>var arr []int</code>这时arr就是一个slice切片，切片后面专门讲解。</p></li><li><p>数组中的元素可以是任何数据类型，包括值类型和引用类型，但是不能混用。</p></li><li><p>数组创建后，如果没有赋值，有默认值（零值）</p><pre class="language-none"><code class="language-none">数组类型数组： 默认值为 0字符串数组： 默认值为 &quot;&quot;bool数组： 默认值为false</code></pre></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> arr01 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">float32</span><span class="token keyword">var</span> arr02 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token keyword">var</span> arr03 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">bool</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr01=%v arr02=%v arr03=%v\n"</span><span class="token punctuation">,</span> arr01<span class="token punctuation">,</span> arr02<span class="token punctuation">,</span> arr03<span class="token punctuation">)</span></code></pre><ol start="5"><li>使用数组的步骤<ol><li>生命数组并开辟空间</li><li>给数组各个元素赋值（默认零值）</li><li>使用数组</li></ol></li><li>数组的下标是从0开始的</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> arr04 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token comment">// 0-2</span><span class="token keyword">var</span> index <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">3</span>arr04<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"tom"</span> <span class="token comment">//arr04[3]越界奥</span></code></pre><ol start="7"><li>数组下标必须在指定范围内使用，否则报panic：数组越界，比如<code>var arr [5]int</code> 则有效下标为0-4</li><li>Go的数组属值类型，在默认情况下是值传递，因此会进行值拷贝。数组见不会相互影响</li></ol><p><img src="http://cdn.leafii.top/img/20220520151047.png" loading="lazy"></p><ol start="9"><li><p>如想在其它函数中，去修改原来的数组，可以使用引用传递（指针方式）<img src="http://cdn.leafii.top/img/20220520151231.png" loading="lazy"></p></li><li><p>长度是数组类型的一部分，在传递函数参数时 需要考虑数组的长度，看下面的案例：</p></li></ol><p><img src="http://cdn.leafii.top/img/20220520151128.png" loading="lazy"></p></li></ul><h2 id="数组的应用案例"><a href="#数组的应用案例" class="headerlink" title="数组的应用案例"></a>数组的应用案例</h2><ol><li>创建一个byte类型的26个元素的数组，分别放置’A’-‘Z’.使用for循环访问所有元素并打印出来。提示：字符数据运算’A’+1-&gt;’B’</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> arr01 <span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>arr01<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  arr01<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'A'</span> <span class="token operator">+</span> <span class="token function">byte</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">//要将i转成byte类型</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>arr01<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> arr01<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo02&#x2F;main  go run .&#x2F;main.go      ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre><ol start="2"><li>请求出一个数组的最大值，并得到对应的下标。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> intArr <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">932</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">&#125;</span>maxVal <span class="token operator">:=</span> intArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>maxValIndex <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>intArr<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> intArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>maxVal <span class="token punctuation">&#123;</span>maxVal <span class="token operator">=</span> intArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>maxValIndex <span class="token operator">=</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"maxVal = %v, maxValIndex = %v \n"</span><span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> maxValIndex<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo02&#x2F;main  go run .&#x2F;main.gomaxVal &#x3D; 932, maxValIndex &#x3D; 2 </code></pre><ol start="3"><li>请求出一个数组的和和平均值 for-range</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> doubleArr2 <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">float64</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> sum <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> val <span class="token operator">:=</span> <span class="token keyword">range</span> doubleArr2 <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> val<span class="token punctuation">&#125;</span><span class="token keyword">var</span> avg <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>doubleArr2<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"sum = %v avg = %v\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span> avg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo02&#x2F;main  go run .&#x2F;main.gosum &#x3D; 55 avg &#x3D; 5.5</code></pre><ol start="4"><li>要求：随机生成五个数，并将其反转打印，复杂应用。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token string">"math/rand"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> intArr3 <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token builtin">len</span> <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>intArr3<span class="token punctuation">)</span>rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  intArr3<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"交换前："</span><span class="token punctuation">,</span>intArr3<span class="token punctuation">)</span><span class="token comment">//反转打印</span>temp <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  temp <span class="token operator">=</span> intArr3<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">]</span>  intArr3<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> intArr3<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  intArr3<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"交换后："</span><span class="token punctuation">,</span>intArr3<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo02&#x2F;main  go run .&#x2F;main.go交换前： [76 85 22 96 35]交换后： [35 96 22 85 76] ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo02&#x2F;main  go run .&#x2F;main.go交换前： [8 60 13 96 46]交换后： [46 96 13 60 8]</code></pre><h2 id="为什么需要切片"><a href="#为什么需要切片" class="headerlink" title="为什么需要切片"></a>为什么需要切片</h2><ul><li><p>需求</p><p>我们需要一个数组用于保存学生的成绩，但是学生的个数是不确定的，怎么办？ 答案：使用切片</p></li></ul><h2 id="切片的基本介绍"><a href="#切片的基本介绍" class="headerlink" title="切片的基本介绍"></a>切片的基本介绍</h2><ol><li><p>切片的英文是 slice</p></li><li><p>切片是数组的一个引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制。</p></li><li><p>切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度 len(slice)都一样。 </p></li><li><p>切片的长度是可以变化的，因此切片是一个可以动态变化数组。</p></li><li><p>切片定义的基本语法:</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//var 切片名 []类型</span><span class="token comment">//比如</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span></code></pre></li></ol><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>演示一个切片的基本使用：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> intArr <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">66</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">&#125;</span><span class="token comment">//声明/定义一个切片</span><span class="token comment">//slice := intArr[1:3]</span><span class="token comment">//1. slice就是切片名</span><span class="token comment">//2. intArr[1:3]表示slice引用到intArr这个数组</span><span class="token comment">//3. 引用intArr数组的起始下标为1，最后的下标为3（但是不包含3）</span>slice <span class="token operator">:=</span> intArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"intArr:"</span><span class="token punctuation">,</span> intArr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice 的元素是 :"</span><span class="token punctuation">,</span> slice<span class="token punctuation">)</span> <span class="token comment">// 22  33</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice的元素个数:"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice的容量:"</span><span class="token punctuation">,</span><span class="token function">cap</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 切片的容量是可以动态变化的</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo03&#x2F;main  go run .&#x2F;main.gointArr: [1 22 33 66 99]slice 的元素是 : [22 33]slice的元素个数: 2slice的容量: 4</code></pre><h2 id="切片在内存中形式（重要）"><a href="#切片在内存中形式（重要）" class="headerlink" title="切片在内存中形式（重要）"></a>切片在内存中形式（重要）</h2><ul><li><p>基本介绍</p><p>为了让大家更加深入的理解切片，我们画图分析切片在内存中是如何布局的，这是一个非常重要的知识点：（以前面的案例来分析）</p></li><li><p>画出前面的切片内存布局</p></li></ul><p><img src="http://cdn.leafii.top/img/20220520151257.png" loading="lazy"></p><ul><li><p>对上面的分析图总结</p><ol><li>slice的确是一个引用类型</li><li>slice从底层来说，其实就是一个数据结构（strcut结构体）</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> slice <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  ptr <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span>  <span class="token builtin">len</span> <span class="token builtin">int</span>  <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h2 id="切片的使用"><a href="#切片的使用" class="headerlink" title="切片的使用"></a>切片的使用</h2><ul><li><p>方式1</p><p>第一种方式：定义一个切片，然后让切片去引用一个已经创建好的数组，比如前面的案例就是这样的。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> slice <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"arr:"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice 的元素是 :"</span><span class="token punctuation">,</span> slice<span class="token punctuation">)</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice的元素个数:"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">)</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice的容量:"</span><span class="token punctuation">,</span><span class="token function">cap</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li><p>方式2</p><p>第二种方式：通过make来创建切片</p><p>基本语法：<code>var 切片名 []type = make([]type,len,[cap])</code></p><p>参数说明：type就是数据类型，len是大小，cap是指定切片容量，可选，<strong>如果你分配了cap，则要求cap&gt;&#x3D;len</strong></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>slice<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>slice<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token comment">//对于切片，必须make使用</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice的size="</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice的cap="</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="http://cdn.leafii.top/img/20220520151314.png" loading="lazy"></p><p>对上面代码的小结：</p><ol><li>通过make方式创建切片可以指定切片的大小和容量</li><li>如果没有给切片的各个元素赋值，那么就会使用默认值【int, float &#x3D;&gt;0     string&#x3D;&gt;””   bool&#x3D;&gt;false】</li><li>通过make方式创建的切片对应的数组是由make底层维护，对外不可见，即只能通过slice去访问各个元素。</li></ol></li><li><p>方式3</p><p>第三种方式：定义一个切片，直接就指定具体数组，使用原理类似make的方式</p><p>案例演示：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//方式3</span><span class="token comment">//第3种方式：定义一个切片，直接就指定具体数组，使用原理类似make的方式</span><span class="token keyword">var</span> strSlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token string">"jack"</span><span class="token punctuation">,</span> <span class="token string">"mary"</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"strSlice = "</span><span class="token punctuation">,</span> strSlice<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"strSlice size = "</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>strSlice<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"strSlice cap = "</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>strSlice<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li><p>方式1和方式2的区别（面试）</p><p>方式1是直接引用数组，这个数组是事先存在的，程序员是可见的。</p><p>方式2是通过make来创建切片，make也会创建一个数组，是由切片在底层进行维护，程序员是看不见的。make创建切片的示意图：</p><p><img src="http://cdn.leafii.top/img/20220520151330.png" loading="lazy"></p></li></ul><h2 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h2><p>切片的遍历和数组一样，也有两种方式</p><ul><li>for循环常规方式遍历</li><li>for-range结构遍历切片</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">&#125;</span>slice <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token comment">// 20,30,40</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"slice[%v] = %v\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> slice<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token operator">:=</span> <span class="token keyword">range</span> slice <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"i = %v, v = %v\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo04&#x2F;main  go run .&#x2F;main.goslice[0] &#x3D; 20   slice[1] &#x3D; 30   slice[2] &#x3D; 40i &#x3D; 0, v &#x3D; 20   i &#x3D; 1, v &#x3D; 30   i &#x3D; 2, v &#x3D; 40</code></pre><h2 id="切片的使用的注意事项和细节讨论"><a href="#切片的使用的注意事项和细节讨论" class="headerlink" title="切片的使用的注意事项和细节讨论"></a>切片的使用的注意事项和细节讨论</h2><ol><li><p>切片初始化时 var slice &#x3D; arr[startIndex:endIndex]</p><pre class="language-none"><code class="language-none">说明:从 arr 数组下标为 startIndex，取到 下标为 endIndex 的元素(不含 arr[endIndex])。</code></pre></li><li><p>切片初始化时，仍然不能越界。范围在 [0-len(arr)] 之间，但是可以动态增长.</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> slice <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>end<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">></span> <span class="token keyword">var</span> slice <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>end<span class="token punctuation">]</span><span class="token keyword">var</span> slice <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">></span> <span class="token keyword">var</span> slice <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token keyword">var</span> slice <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">></span> <span class="token keyword">var</span> slice <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span></code></pre></li><li><p>cap是一个内置函数，用于统计切片的容量，即最大可以存放多少个元素。</p></li><li><p>切片定义完后，还不能使用，因为本身是一个空的，需要让其引用到一个数组，或者 make一个空间供切片来使用</p></li><li><p>切片可以继续切片【演示】</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">&#125;</span>slice <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token comment">// 20,30,40</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"slice[%v] = %v\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> slice<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token operator">:=</span> <span class="token keyword">range</span> slice <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"i = %v, v = %v\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//定义slice2</span>  slice2 <span class="token operator">:=</span> slice<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">// slice [ 20, 30, 40]   [30]</span>  slice2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">// 因为arr， slice和slcie2指向的数据空间是同一个，因此slice2[0]=100</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice2 = "</span><span class="token punctuation">,</span> slice2<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice = "</span><span class="token punctuation">,</span>slice<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"arr = "</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>用append内置函数，可以对切片进行动态追加</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> slice3 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token comment">//通过append直接给slice3追加具体的元素</span>slice3 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>slice3<span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice3="</span>，slice3<span class="token punctuation">)</span> <span class="token comment">// 100 200 300 400 500 600</span><span class="token comment">//通过append将切片slice3追加给slice3</span>slice3 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>slice3<span class="token punctuation">,</span> slice3<span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">//100 200 300 400 500 600 100 200 300 400 500 600</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice3 append slice3 = "</span><span class="token punctuation">,</span> slice3<span class="token punctuation">)</span></code></pre><p>对上面的代码的小结</p><p><img src="http://cdn.leafii.top/img/20220520151348.png" loading="lazy"></p><p>切片append操作的底层原理分析：</p><p>切片append操作的本质就是对数组扩容</p><p>go 底层会创建一下新的数组newArr(安装扩容后大小)</p><p>将 slice 原来包含的元素拷贝到新的数组 newArr<br>slice 重新引用到 newArr<br>注意 newArr 是在底层来维护的，程序员不可见.</p></li><li><p>切片的拷贝操作</p><p>切片使用copy内置函数完成拷贝，举例说明</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> slice4 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">var</span> slice5 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token function">copy</span><span class="token punctuation">(</span>slice5<span class="token punctuation">,</span> slice4<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice4="</span><span class="token punctuation">,</span> slice4<span class="token punctuation">)</span><span class="token comment">// 1 , 2, 3 , 4 , 5</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice5="</span><span class="token punctuation">,</span> slice5<span class="token punctuation">)</span><span class="token comment">// 1 ,2, 3,4,5,0,0,0,0,0</span></code></pre><p><strong>对上面代码的说明：</strong></p><ol><li>copy(para1, para2) 参数的数据类型是切片</li><li>按照上面的代码来看, slice4 和 slice5 的数据空间是独立，相互不影响，也就是说 slice4[0]&#x3D; 999,slice5[0] 仍然是 1</li></ol></li><li><p>关于拷贝的注意事项</p><ul><li>下面的代码又没有错误？</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> slice <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token comment">// [0]</span><span class="token function">copy</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span>a<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span></code></pre><p>**上面的代码没有问题，可以运行，最后输出的是[1]</p></li><li><p>切片是引用类型，所以在传递时，遵守引用传递机制。看两段代码，并分析底层原理<img src="http://cdn.leafii.top/img/20220520151403.png" loading="lazy"></p></li></ol><h2 id="string和slice"><a href="#string和slice" class="headerlink" title="string和slice"></a>string和slice</h2><ol><li>string底层是一个byte数组，因此string也可以进行切片处理案例演示:</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//string底层是一个byte数组，因此string也可以进行切片处理</span>  str <span class="token operator">:=</span> <span class="token string">"hello@atguigu"</span>  <span class="token comment">//使用切片获取到 atguigu</span>  slice <span class="token operator">:=</span> str<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"slice="</span><span class="token punctuation">,</span>slice<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li>string和切片在内存的形式，以”abcd”画出内存示意图</li></ol><p><img src="http://cdn.leafii.top/img/20220520151421.png" loading="lazy"></p><ol start="3"><li>string是不可变的，也就是说不能通过str[0]&#x3D;’z’方式来修改字符串</li></ol><pre class="language-go" data-language="go"><code class="language-go">str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'z'</span> <span class="token comment">//编译不会通过，会报错，因为string是不可变的</span></code></pre><ol start="4"><li>如果需要修改字符串，可以先将string -&gt; []byte  或者 []rune -&gt; 修改 -&gt; 重写转成string</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//如果需要修改字符串，可以先将string -> []byte  或者 []rune -> 修改 -> 重写转成string</span><span class="token comment">//"hello@atguigu"=>改成"zello@atguigu"</span>str <span class="token operator">:=</span> <span class="token string">"hello@atguigu"</span>arr1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>arr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'z'</span>str <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"str="</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token comment">//细节，我们转成[]byte后，可以处理英文和数字，但是不能处理中文</span><span class="token comment">//原因：[]byte字节来处理string中的字符，而一个汉子是3个字节，因此会出现乱码</span><span class="token comment">//解决方法：将string转成[]rune即可，因为[]rune是按字符处理，兼容汉字</span>arr1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>arr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'北'</span>str <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"str="</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span></code></pre><h2 id="切片的课堂练习"><a href="#切片的课堂练习" class="headerlink" title="切片的课堂练习"></a>切片的课堂练习</h2><p><strong>题目</strong>：编写一个函数fbn(n int)，要求完成</p><ol><li>可以接收一个 n int</li><li>能够将斐波那契的数列放到切片中</li><li>提示, 斐波那契的数列形式:</li></ol><p><code>arr[0] = 1; arr[1] = 1; arr[2]=2; arr[3] = 3; arr[4]=5; arr[5]=8</code></p><ul><li>代码+思路：</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">fbn</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//声明一个切片，切片大小n</span>  fbnSlice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint64</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>  <span class="token comment">//第一个数和第二个数的斐波那契数为1</span>  fbnSlice<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  fbnSlice<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment">//进行for循环存放斐波那契数列</span>  <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    fbnSlice<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> fbnSlice<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> fbnSlice<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> fbnSlice<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  fnbSlice <span class="token operator">:=</span> <span class="token function">fbn</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"fnbSlice="</span><span class="token punctuation">,</span> fnbSlice<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter07&#x2F;demo04&#x2F;main  go run .&#x2F;main.gofnbSlice&#x3D; [1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765]</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言の函数、包和错误处理</title>
      <link href="/2021/01/19/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2021/01/19/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言の函数、包和错误处理"><a href="#Go语言の函数、包和错误处理" class="headerlink" title="Go语言の函数、包和错误处理"></a>Go语言の函数、包和错误处理</h1><p>本文章主要讲解了Go语言的函数，包和错误处理等知识。</p><span id="more"></span><h2 id="为什么需要函数"><a href="#为什么需要函数" class="headerlink" title="为什么需要函数"></a>为什么需要函数</h2><h3 id="完成需求"><a href="#完成需求" class="headerlink" title="完成需求"></a>完成需求</h3><p>输入两个数，再输入一个运算符（+-*&#x2F;），得到结果。</p><h3 id="使用传统的方法解决"><a href="#使用传统的方法解决" class="headerlink" title="使用传统的方法解决"></a>使用传统的方法解决</h3><ul><li>代码</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> n1 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">1.2</span><span class="token keyword">var</span> n2 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">2.3</span><span class="token keyword">var</span> operator <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token char">'-'</span><span class="token keyword">switch</span> operator <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'+'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v + %v = %v\n"</span><span class="token punctuation">,</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> n1 <span class="token operator">+</span> n2<span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'-'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v - %v = %v\n"</span><span class="token punctuation">,</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> n1 <span class="token operator">-</span> n2<span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'*'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v * %v = %v\n"</span><span class="token punctuation">,</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> n1 <span class="token operator">*</span> n2<span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'/'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v / %v = %v\n"</span><span class="token punctuation">,</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> n1 <span class="token operator">/</span> n2<span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go1.2 - 2.3 &#x3D; -1.0999999999999999</code></pre><ul><li>分析上面的代码问题<ol><li>可以完成功能需求，但代码冗余</li><li>与此同时不利于代码的维护</li><li>函数可以解决这个问题奥</li></ol></li></ul><h2 id="函数的基本概念"><a href="#函数的基本概念" class="headerlink" title="函数的基本概念"></a>函数的基本概念</h2><p>​为完成某一功能的程序指令（语句）的集合，称为函数。</p><p>在Go中，函数分为：自定义函数、系统函数（查看Go编程手册）</p><h2 id="函数的基本语法"><a href="#函数的基本语法" class="headerlink" title="函数的基本语法"></a>函数的基本语法</h2><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> 函数名 <span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span> <span class="token punctuation">(</span>返回值列表<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  执行语句<span class="token operator">...</span>  <span class="token keyword">return</span> 返回值列表<span class="token punctuation">&#125;</span></code></pre><ol><li>形参列表：表示函数的输入</li><li>函数的语句：表示为了实现某一功能代码块</li><li>函数可以有返回值，也可以没有</li></ol><h2 id="快速入门案例"><a href="#快速入门案例" class="headerlink" title="快速入门案例"></a>快速入门案例</h2><p>使用函数解决前面的计算问题。</p><p>走代码：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">cal</span><span class="token punctuation">(</span>n1 <span class="token builtin">float64</span><span class="token punctuation">,</span>n2 <span class="token builtin">float64</span><span class="token punctuation">,</span> operator <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> res <span class="token builtin">float64</span><span class="token keyword">switch</span> operator <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'+'</span><span class="token punctuation">:</span>res <span class="token operator">=</span> n1 <span class="token operator">+</span> n2<span class="token keyword">case</span> <span class="token char">'-'</span><span class="token punctuation">:</span>res <span class="token operator">=</span> n1 <span class="token operator">-</span> n2<span class="token keyword">case</span> <span class="token char">'*'</span><span class="token punctuation">:</span>res <span class="token operator">=</span> n1 <span class="token operator">*</span> n2<span class="token keyword">case</span> <span class="token char">'/'</span><span class="token punctuation">:</span>res <span class="token operator">=</span> n1 <span class="token operator">/</span> n2<span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"操作符号错误哦！"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> n1 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">1.2</span><span class="token keyword">var</span> n2 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">2.3</span><span class="token keyword">var</span> operator <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token char">'+'</span>result <span class="token operator">:=</span> <span class="token function">cal</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> operator<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h2 id="包的引出"><a href="#包的引出" class="headerlink" title="包的引出"></a>包的引出</h2><ol><li>在实际的开发中，我们往往需要在不同的文件中，去调用其他文件的定义的函数，比如main.go中，去使用utils.go文件中的函数，如何实现？-&gt;包</li><li>现在有两个程序员共同开发一个Go项目，程序员xiaoming希望定义函数Cal，程序员xiaoqiang也想定义函数也叫Cal。两个程序员为此还吵了起来，怎么办？-&gt;包</li></ol><h2 id="包的原理图"><a href="#包的原理图" class="headerlink" title="包的原理图"></a>包的原理图</h2><p>包的本质实际上就是创建不同的文件夹，来存放程序文件。</p><p><img src="http://cdn.leafii.top/img/20220520151521.png" loading="lazy"></p><h2 id="包的基本概念"><a href="#包的基本概念" class="headerlink" title="包的基本概念"></a>包的基本概念</h2><p>​说明：go的每一个文件都是属于一个包的，也就是说go是以包的形式来管理文件和项目目录结构的</p><h2 id="包的三大作用"><a href="#包的三大作用" class="headerlink" title="包的三大作用"></a>包的三大作用</h2><ul><li><p>区分相同名字的函数、变量等标识符</p></li><li><p>当程序文件很多时，可以很好的管理项目</p></li><li><p>控制函数、变量等访问范围，即作用域</p></li></ul><h2 id="包的相关说明"><a href="#包的相关说明" class="headerlink" title="包的相关说明"></a>包的相关说明</h2><ul><li><p>打包基本语法</p><p><code>package 包名</code></p></li><li><p>引入包的基本语法</p><p><code>import &quot;包的路径&quot;</code></p></li></ul><h2 id="包使用的快速入门"><a href="#包使用的快速入门" class="headerlink" title="包使用的快速入门"></a>包使用的快速入门</h2><p>包快速入门-Go相互调用函数，我们将func Cal定义到文件utils.go，将utils.go放到一个包中，当其它文件需要使用到utils.go的方法时，可以import该包，就可以使用了。【演示：新建项目的目录结构】</p><p><img src="http://cdn.leafii.top/img/20220520151536.png" loading="lazy"></p><ul><li>utils.go:</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> utils<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//将计算的功能，放到一个函数中，然后在需要使用，调用即可</span><span class="token comment">//为了让其它包的文件使用Cal函数，需要将C大写类似其它语言的public</span><span class="token keyword">func</span> <span class="token function">Cal</span><span class="token punctuation">(</span>n1 <span class="token builtin">float64</span><span class="token punctuation">,</span>n2 <span class="token builtin">float64</span><span class="token punctuation">,</span> operator <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> res <span class="token builtin">float64</span><span class="token keyword">switch</span> operator <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'+'</span><span class="token punctuation">:</span>res <span class="token operator">=</span> n1 <span class="token operator">+</span> n2<span class="token keyword">case</span> <span class="token char">'-'</span><span class="token punctuation">:</span>res <span class="token operator">=</span> n1 <span class="token operator">-</span> n2<span class="token keyword">case</span> <span class="token char">'*'</span><span class="token punctuation">:</span>res <span class="token operator">=</span> n1 <span class="token operator">*</span> n2<span class="token keyword">case</span> <span class="token char">'/'</span><span class="token punctuation">:</span>res <span class="token operator">=</span> n1 <span class="token operator">/</span> n2<span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"操作符号错误哦！"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">&#125;</span></code></pre><ul><li>Main.go</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"go_code/chapter06/demo02/utils"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//请大家完成这样一个需求：</span><span class="token comment">//输入两个数，再输入一个运算符（+,-,*,/)，得到结果。。</span><span class="token comment">//分析思路...</span><span class="token keyword">var</span> n1 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">1.2</span><span class="token keyword">var</span> n2 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">2.3</span><span class="token keyword">var</span> operator <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token char">'+'</span>result <span class="token operator">:=</span> utils<span class="token punctuation">.</span><span class="token function">Cal</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span>n2<span class="token punctuation">,</span>operator<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"result="</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h2 id="包使用的注意事项和细节讨论"><a href="#包使用的注意事项和细节讨论" class="headerlink" title="包使用的注意事项和细节讨论"></a>包使用的注意事项和细节讨论</h2><ol><li>在给一个文件打包时，该包对应一个文件夹，比如这里的utils文件夹对应的包名就是utils，文件的包名通常和文件所在的文件夹名一致，一般为小写字母。</li><li>当一个文件要使用其它包函数或变量时，需要先引入对应的包</li></ol><ul><li>引入方式1:<code>import &quot;包名&quot;</code></li><li>引入方式2:</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"包名"</span>  <span class="token string">"包名"</span><span class="token punctuation">)</span></code></pre><ul><li>package指令在文件第一行，然后是import指令。</li><li>在import包时，路径从$GOPATH的src下开始，不用带src，编译器会自动从src开始引入。</li></ul><ol start="3"><li>为了让其它包的文件可以访问到本包的函数，则该函数名的首字母需要大写，类似其他语言的public，这样才能跨包访问。比如utils.go的<em>Cal</em>函数</li><li>在访问其它包函数，变量时，其语法是 包名.函数名,比如这个main.go文件中的<code>utils.Cal(90, 80, &quot;+&quot;)</code></li><li>如果包名较长，Go支持给包取别名，注意细节；取别名后，原来的包名就不能使用了<ul><li>说明：如果给包取了别名，则**需要使用别名来访问该包的函数和变量。</li></ul></li><li>在同一包下，不能有相同的函数名（也不能有相同的全局变量名），否则报重复定义</li><li>如果你要编译成一个可执行程序文件，就需要将这个包声明为main，即<code>package main</code>这个就是一个语法规范，如果你是写一个库，包名可以自定义</li></ol><p><img src="http://cdn.leafii.top/img/20220520151554.png" loading="lazy"></p><h2 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h2><h3 id="通俗易懂的方式的理解"><a href="#通俗易懂的方式的理解" class="headerlink" title="通俗易懂的方式的理解"></a>通俗易懂的方式的理解</h3><p><img src="http://cdn.leafii.top/img/20220520151621.png" loading="lazy"></p><h3 id="函数-调用过程"><a href="#函数-调用过程" class="headerlink" title="函数-调用过程"></a>函数-调用过程</h3><p>介绍：为了让大家更好地理解函数调用过程，看两个案例，并画出示意图，这个很重要</p><ol><li>传入一个数+1</li></ol><p><img src="http://cdn.leafii.top/img/20220520151636.png" loading="lazy"></p><p>对上图说明</p><ol><li><p>在调用一个函数时，会给该函数分配一个新的空间，编译器会通过自身的处理让这个新的空间和其它的栈的空间去分开来</p></li><li><p>在每个函数对应的栈中，数据空间时独立的，不会混淆</p></li><li><p>当一个函数调用完毕（执行完毕）后，程序会销毁这个函数对应的栈空间。</p></li><li><p>计算两个数，并返回</p></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//一个函数 test</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>n1 <span class="token operator">=</span> n1 <span class="token operator">+</span> <span class="token number">1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"test() n1="</span><span class="token punctuation">,</span>n1<span class="token punctuation">)</span> <span class="token comment">//输入结果=？</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">getSum</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">:=</span> n1 <span class="token operator">+</span> n2fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"getSum sum = "</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token comment">// 30</span><span class="token comment">//当函数有return语句时，就是将结果返回给调用者</span><span class="token comment">//即谁调用我，就返回给谁</span><span class="token keyword">return</span> sum<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>n1 <span class="token operator">:=</span> <span class="token number">10</span><span class="token comment">//调用test</span><span class="token function">test</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main() n1="</span><span class="token punctuation">,</span>n1<span class="token punctuation">)</span><span class="token comment">//输出结果=？</span>sum <span class="token operator">:=</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main sum="</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token comment">// 30</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter06&#x2F;demo03&#x2F;main  go run main.go test() n1&#x3D; 11main() n1&#x3D; 10getSum sum &#x3D;  30main sum&#x3D; 30</code></pre><h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><ul><li>基本语法和说明</li></ul><pre class="language-go" data-language="go"><code class="language-go">Go函数支持返回多个值，这一点是其它编程语言没有的。<span class="token keyword">func</span> 函数名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span> （返回值类型列表） <span class="token punctuation">&#123;</span>  语句<span class="token operator">...</span>  <span class="token keyword">return</span> 返回值列表<span class="token punctuation">&#125;</span></code></pre><ol><li>如果返回多个值时，在接收时，希望忽略某个返回值，则使用<code>_</code>符号表示占位忽略</li><li>如果返回值只有一个，（返回值类型列表）可以不写<code>()</code></li></ol><ul><li><p>案例演示1</p><p>请编写要给函数，可以计算两个数的和和差，并返回结果。</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  n1 <span class="token operator">:=</span> <span class="token number">10</span>  <span class="token comment">//调用test</span>  <span class="token function">test</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main() n1="</span><span class="token punctuation">,</span>n1<span class="token punctuation">)</span><span class="token comment">//输出结果？</span>  sum <span class="token operator">:=</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main sum ="</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token comment">//30</span>  <span class="token comment">//调用getSumAndSub</span>  res1<span class="token punctuation">,</span>res2 <span class="token operator">:=</span> <span class="token function">getSumAndSub</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//res1 = 3 res2 = -1 </span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"res1=%v res2=%v\n"</span><span class="token punctuation">,</span>res1<span class="token punctuation">,</span> res2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//编写函数，可以计算两个数的和和差，并返回结果</span><span class="token keyword">func</span> <span class="token function">getSumAndSub</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">int</span> <span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  sum <span class="token operator">:=</span> n1 <span class="token operator">+</span> n2  sub <span class="token operator">:=</span> n1 <span class="token operator">-</span> n2  <span class="token keyword">return</span> sum<span class="token punctuation">,</span> sub<span class="token punctuation">&#125;</span></code></pre><ul><li><p>案例演示2</p><p>一个细节说明：希望忽略某个返回值，则使用<code>_</code>符号表示占位忽略</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//希望忽略某个返回值，则使用`_`符号表示占位忽略</span><span class="token boolean">_</span><span class="token punctuation">,</span> res3 <span class="token operator">=</span> <span class="token function">getSumAndSub</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res3="</span><span class="token punctuation">,</span>res3<span class="token punctuation">)</span></code></pre><h2 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>一个函数在<strong>函数体内</strong>又<strong>调用了本身</strong>，我们称为递归调用</p><h3 id="递归调用快速入门"><a href="#递归调用快速入门" class="headerlink" title="递归调用快速入门"></a>递归调用快速入门</h3><ul><li>代码1</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> n <span class="token operator">></span> <span class="token number">2</span> <span class="token punctuation">&#123;</span>    n<span class="token operator">--</span>    <span class="token function">test</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"n="</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">//通过分析来看递归调用的特点</span><span class="token punctuation">&#125;</span></code></pre><p>上面代码的分析图：</p><p><img src="http://cdn.leafii.top/img/20220520151656.png" loading="lazy"></p><ul><li>代码2</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test2</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> n <span class="token operator">></span> <span class="token number">2</span> <span class="token punctuation">&#123;</span>    n<span class="token operator">--</span>    <span class="token function">test2</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"n="</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//看一段代码</span>  <span class="token comment">//test(4) //通过分析来看下递归调用的特点</span>  <span class="token function">test2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// ？通过分析来看下递归调用的特点</span><span class="token punctuation">&#125;</span></code></pre><p>对上面代码分析的示意图：</p><p><img src="http://cdn.leafii.top/img/20220520151726.png" loading="lazy"></p><h3 id="递归调用的总结"><a href="#递归调用的总结" class="headerlink" title="递归调用的总结"></a>递归调用的总结</h3><p><strong>函数递归需要遵守的重要原则：</strong></p><ol><li>执行一个函数时，就创建一个新的受保护的独立空间（新函数栈）</li><li>函数的局部变量是独立的，不会相互影响</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，死循环了 :) </li><li>当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当函数执行完毕或者返回时，该函数本身也会被系统销毁</li></ol><h3 id="递归课堂练习题"><a href="#递归课堂练习题" class="headerlink" title="递归课堂练习题"></a>递归课堂练习题</h3><ul><li><p>题1:斐波那契数</p><p>请使用递归的方式，求出斐波那契数1，1，2，3，5，8，13…</p><p>给你一个整数n，求出它的斐波那切数是多少？</p><ul><li>思路</li></ul><ol><li>当n&#x3D;&#x3D;1 || n&#x3D;&#x3D;2, 返回1</li><li>当n&gt;2, 返回f(n-1) + f(n-2)</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fbn</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> n<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">fbn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fbn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  res <span class="token operator">:=</span> <span class="token function">fbn</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment">//测试</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span><span class="token function">fbn</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span><span class="token function">fbn</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span><span class="token function">fbn</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p>题2:求函数值</p><p>已知 <em><em>f(1)&#x3D;3;f(n)&#x3D;2</em>(n-1)+1</em>*;</p><p>请使用递归的思想编程，求出f(n)的值？</p><ul><li><p>思路</p><p>递归就完事了奥铁子</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">/*已知 f(1)=3;f(n)=2*(n-1)+1;请使用递归的思想编程，求出f(n)的值？*/</span><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"f(1)="</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"f(5)="</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre></li></ul></li><li><p>题3:猴子吃桃子问题</p><p>有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个!以后每天猴子都吃其中的一半，然后再多吃一个。当到第十天时，想再吃时(还没吃)，发现只有 <strong>1</strong> 个桃子了。问题:最初共多少个桃子? </p><ul><li>思路分析:<ol><li>第10天只有1个桃子</li><li>第9天有（第十天桃子数量+1）*2个</li><li>第n天有peach(n)&#x3D;(peach(n+1)+1)*2</li></ol></li><li>代码</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">peach</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">10</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">peach</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h2 id="函数使用的注意事项和细节讨论"><a href="#函数使用的注意事项和细节讨论" class="headerlink" title="函数使用的注意事项和细节讨论"></a>函数使用的注意事项和细节讨论</h2><ol><li>函数的形参列表可以是多个，返回值列表也可以是多个。</li><li>形参列表和返回值列表的数据类型可以是值类型和引用类型。</li><li>函数的命名遵循标识符命名规范，首字母不能是数字，首字母大写该函数可以被本包文件和其它包文件使用，类似 public , 首字母小写，只能被本包文件使用，其它包文件不能使用，类似 private</li><li>函数中的变量是局部的，函数外不生效【案例说明】</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//n1 是 test函数的局部变量，只能在test函数中使用</span>  <span class="token keyword">var</span> n1 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//这里不能使用n1，因为n1是test函数的局部变量</span>  <span class="token comment">//fmt.Println("n1=",n1)</span><span class="token punctuation">&#125;</span></code></pre><ol start="5"><li>基本数据类型和数组默认都是<strong>值传递</strong>，即进行值拷贝。在函数内修改，不会影响到原来的值。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test02</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  n1 <span class="token operator">=</span> n1 <span class="token operator">+</span> <span class="token number">10</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"test02() n1="</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  num <span class="token operator">:=</span> <span class="token number">20</span>  <span class="token function">test02</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main() num="</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>如果希望函数内的变量能修改函数外的变量（指的是默认以值传递的方式的数据类型），可以传入变量的地址&amp;，函数内以指针的方式操作变量。从效果上看类似引用。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test03</span><span class="token punctuation">(</span>n1 <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">*</span>n1 <span class="token operator">=</span> <span class="token operator">*</span>n1 <span class="token operator">+</span> <span class="token number">10</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"test03() n1="</span><span class="token punctuation">,</span> <span class="token operator">*</span>n1<span class="token punctuation">)</span> <span class="token comment">//30</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  num <span class="token operator">:=</span> <span class="token number">20</span>  <span class="token function">test03</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main() num="</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token comment">// 30</span><span class="token punctuation">&#125;</span></code></pre><p><img src="http://cdn.leafii.top/img/20220520151742.png" loading="lazy"></p><ol start="7"><li>Golang的函数不支持函数重载</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test02</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  n1 <span class="token operator">=</span> n1 <span class="token operator">+</span> <span class="token number">10</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"test02() n1="</span><span class="token punctuation">,</span>n1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">test02</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//这是错误的奥！！！！！</span><span class="token punctuation">&#125;</span></code></pre><ol start="8"><li>在Golang中，<strong>函数也是一种数据类型</strong>，可以赋值给一个变量，则该变量就是一个函数类型的变量了。<strong>通过该变量可以对函数调用</strong></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">getSum</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> n1 <span class="token operator">+</span> n2<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  a <span class="token operator">:=</span> getSum  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"a的类型%T， getSum类型是%T \n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> getSum<span class="token punctuation">)</span>    res <span class="token operator">:=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span> <span class="token comment">//等价 res := getSum(10, 40)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="9"><li>函数既然是一种数据类型，因此在Golang中，函数可以作为形参，并且调用哦</li></ol><pre class="language-go" data-language="go"><code class="language-go">res2 <span class="token operator">:=</span> <span class="token function">myFun</span><span class="token punctuation">(</span>getSum<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res2="</span><span class="token punctuation">,</span> res2<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">myFun</span><span class="token punctuation">(</span>funvar <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">,</span> num1 <span class="token builtin">int</span><span class="token punctuation">,</span> num2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">funvar</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="10"><li><p>为了简化数据类型定义，Golang支持自定义数据类型</p><p>基本语法：<code>type 自定义数据类型名 数据类型 //理解：相当于一个别名</code></p><p>案例：<code>type myInt int  //这时myInt就等价int来使用了哦！ </code></p><p>案例：<code>type mySum func(int, int) int //这时mySum就等价一个 函数类型fu nc(int, int) int</code></p></li></ol><p><img src="http://cdn.leafii.top/img/20220520151809.png" loading="lazy"></p><ol start="11"><li>支持对函数返回值命名</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">getSumAndSub</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sum <span class="token builtin">int</span><span class="token punctuation">,</span> sub <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sub <span class="token operator">=</span> n1 <span class="token operator">-</span> n2sum <span class="token operator">=</span> n1 <span class="token operator">+</span> n2<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>a1<span class="token punctuation">,</span> b1 <span class="token operator">:=</span> <span class="token function">getSumAndSub</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"a1=%v,b1=%v \n"</span><span class="token punctuation">,</span>a1<span class="token punctuation">,</span> b1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="12"><li>使用<code>_</code>标示符，忽略返回值</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">cal</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sum <span class="token builtin">int</span><span class="token punctuation">,</span> sub <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  sum <span class="token operator">=</span> n1 <span class="token operator">+</span> n2  sub <span class="token operator">=</span> n1 <span class="token operator">-</span> n2  <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  res1<span class="token punctuation">,</span><span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>  fml<span class="token punctuation">.</span><span class="token function">Ptintf</span><span class="token punctuation">(</span><span class="token string">"res1=%d"</span><span class="token punctuation">,</span>res1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="13"><li>Go支持可变参数</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//支持0到多个参数</span><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>args<span class="token operator">...</span> <span class="token builtin">int</span><span class="token punctuation">)</span> sum <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//支持1到多个参数</span><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> args<span class="token operator">...</span> <span class="token builtin">int</span><span class="token punctuation">)</span> sum <span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>说明：<ol><li>args是slice切片，通过args[index]可以访问到各个值。</li><li>案例演示：编写一个函数sum，可以求出1到多个int的和</li><li>如果一个函数的形参列表中有可变参数，则可变参数需要放在形参列表最后。</li></ol></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//案例演示:编写一个函数sum，可以求出 1到多个int的和</span><span class="token comment">//参数的使用</span><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> args<span class="token operator">...</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">&#123;</span>  sum <span class="token operator">:=</span> n1  <span class="token comment">//遍历args</span>  <span class="token keyword">for</span> i<span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    sum <span class="token operator">+=</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">//args[0] 表示取出args切片的第一个元素值，其它以此类推</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> sum<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  res4 <span class="token operator">:=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res4="</span><span class="token punctuation">,</span>res4<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h2 id="函数的课堂练习"><a href="#函数的课堂练习" class="headerlink" title="函数的课堂练习"></a>函数的课堂练习</h2><ul><li>题1</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2 <span class="token builtin">float32</span><span class="token punctuation">)</span> <span class="token builtin">float32</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"n1 type=%T \n"</span><span class="token punctuation">,</span>n1<span class="token punctuation">)</span>  <span class="token comment">//n1 type = float32</span>  <span class="token keyword">return</span> n1 <span class="token operator">+</span> n2<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"sum="</span><span class="token punctuation">,</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// sum = 3</span><span class="token punctuation">&#125;</span><span class="token comment">//代码有误错误？输出什么？</span></code></pre><p>没有错误。</p><pre class="language-none"><code class="language-none">n1 type&#x3D;float32 sum&#x3D; 3</code></pre><ul><li>题2</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> mySum <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> n1 <span class="token operator">+</span> n2<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">sum2</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span>n2<span class="token punctuation">,</span>n3 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> n1 <span class="token operator">+</span> n2<span class="token punctuation">&#125;</span><span class="token comment">//使用自定义数据类型（type）来简化定义 </span><span class="token keyword">func</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>funcVar mySum<span class="token punctuation">,</span> num1 <span class="token builtin">int</span><span class="token punctuation">,</span> num2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">funcVar</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  a <span class="token operator">:=</span> sum  b <span class="token operator">:=</span> sum2  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">myFunc</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//ok</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">myFunc</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//error</span>  <span class="token punctuation">&#125;</span><span class="token comment">/*错误：fmt.Println(myFunc(b,1,2))错误，原因是类型不匹配。因为不能把func sum2(n1,n2,n3 int) int 赋给func(int,int) int*/</span></code></pre><ul><li>题3：请编写一个函数swap(n1 *int,n2 *int)可以交换n1和n2的值</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">swap</span><span class="token punctuation">(</span>n1 <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//定义一个临时变量</span>  t <span class="token operator">:=</span> <span class="token operator">*</span>n1  <span class="token operator">*</span>n1 <span class="token operator">=</span> <span class="token operator">*</span>n2  <span class="token operator">*</span>n2 <span class="token operator">=</span> t<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  a <span class="token operator">:=</span> <span class="token number">10</span>  b <span class="token operator">:=</span> <span class="token number">20</span>  <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"a=%v,b=%v \n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">a&#x3D;20,b&#x3D;10 </code></pre><h2 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用。</p><h3 id="案例说明："><a href="#案例说明：" class="headerlink" title="案例说明："></a>案例说明：</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//init函数，通常可以在init函数中完成初始化工作 </span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"init()..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main()..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>输出结果是：</p><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter06&#x2F;demo04&#x2F;main  go run .&#x2F;main.goinit()...main()...</code></pre><h3 id="init函数的注意事项和细节"><a href="#init函数的注意事项和细节" class="headerlink" title="init函数的注意事项和细节"></a>init函数的注意事项和细节</h3><ol><li>如果一个文件同时包含<strong>全局变量定义，init函数和main函数</strong>，则执行的流程全局变量定义-&gt;init函数-&gt;main函数</li></ol><p><img src="http://cdn.leafii.top/img/20220520151852.png" loading="lazy"></p><ol start="2"><li>init函数最主要的作用，就是完成一些初始化的工作，比如下面的案例</li></ol><p><img src="http://cdn.leafii.top/img/20220520151828.png" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/20220520151920.png" loading="lazy"></p><ol start="3"><li>细节说明：面试题：案例如果main.go和utils.go都含有变量定义，init函数时，执行的流程又是什么样呢？</li></ol><p><img src="http://cdn.leafii.top/img/20220520152039.png" loading="lazy"></p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​Go支持匿名函数，匿名函数就是没有名字的函数，如果我们某个函数只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用。</p><h3 id="匿名函数使用方式1"><a href="#匿名函数使用方式1" class="headerlink" title="匿名函数使用方式1"></a>匿名函数使用方式1</h3><p>​在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次。【案例演示】</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次</span>    <span class="token comment">//案例演示，求两个数的和，使用匿名函数的方式完成</span>  res1 <span class="token operator">:=</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> n1 <span class="token operator">+</span> n2  <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res1="</span><span class="token punctuation">,</span> res1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h3 id="匿名函数使用方式2"><a href="#匿名函数使用方式2" class="headerlink" title="匿名函数使用方式2"></a>匿名函数使用方式2</h3><p>​将<strong>匿名函数赋给一个变量</strong>（函数变量），再通过该<strong>变量来调用匿名函数</strong>【案例演示】</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//将匿名函数func (n1 int, n2 int) int 赋给a变量</span><span class="token comment">//则a的数据类型就是函数类型，此时，我们可以通过a完成调用</span>a <span class="token operator">:=</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> n1 <span class="token operator">-</span> n2<span class="token punctuation">&#125;</span>res2 <span class="token operator">:=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res2="</span><span class="token punctuation">,</span> res2<span class="token punctuation">)</span>res3 <span class="token operator">:=</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res3="</span><span class="token punctuation">,</span> res3<span class="token punctuation">)</span></code></pre><h3 id="全局匿名函数"><a href="#全局匿名函数" class="headerlink" title="全局匿名函数"></a>全局匿名函数</h3><p>​如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>  <span class="token comment">//func1就是一个全局匿名函数</span>  Fun1 <span class="token operator">=</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> n1 <span class="token operator">*</span> n2  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//全局匿名函数的使用</span>res4 <span class="token operator">:=</span> <span class="token function">Fun1</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res4="</span><span class="token punctuation">,</span> res4<span class="token punctuation">)</span></code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>​基本介绍：闭包就是<strong>一个函数</strong>和<strong>其相关的引用环境</strong>组合的一个整体（实体）</p><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//累加器</span><span class="token keyword">func</span> <span class="token function">AddUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> n <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>  <span class="token keyword">return</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">=</span> n <span class="token operator">+</span> x    <span class="token keyword">return</span> n  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//使用前面的代码</span>  f <span class="token operator">:=</span> <span class="token function">AddUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//11</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//13</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//16</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p>对上面代码的说明和总结</p><ol><li><p>AddUpper是一个函数，返回的数据类型是<code>fun (int) int</code></p></li><li><p>闭包的说明</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> n <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">return</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  n <span class="token operator">=</span> n <span class="token operator">+</span> x  <span class="token keyword">return</span> n<span class="token punctuation">&#125;</span></code></pre><p>返回的是一个匿名函数，但是这个匿名函数引用到函数外的n，因此这个匿名函数就和n形成一个整体，构成闭包。</p></li><li><p>可以这么理解：闭包是类，函数是操作，n是字段。函数和它使用到n构成闭包。</p></li><li><p>当我们反复的调用f函数时，n初始化一次，所以每调用一次就进行累计。</p></li><li><p>我们要搞清楚闭包的关键，就是要分析出返回的函数它使用（引用）到那些变量，因为函数和它引用到的变量共同构成闭包。</p></li><li><p>对上面代码的一个修改，加深对闭包的理解</p></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//累加器</span><span class="token keyword">func</span> <span class="token function">AddUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> n <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>  <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"hello"</span>  <span class="token keyword">return</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">=</span> n <span class="token operator">+</span> x    str <span class="token operator">+=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span> <span class="token comment">// => 36 = '$'</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"str="</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span> <span class="token comment">//1. str = "hello$" 2. str = "hello$$" 3. str = "hello$$$"</span>    <span class="token keyword">return</span> n  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//使用前面的代码</span>  f <span class="token operator">:=</span> <span class="token function">AddUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//11</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//13</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//16</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h3 id="闭包的最佳实践"><a href="#闭包的最佳实践" class="headerlink" title="闭包的最佳实践"></a>闭包的最佳实践</h3><ul><li>请编写一个程序，具体要求如下：</li></ul><ol><li>编写一个函数 makeSuffix (suffix string) 可以接收一个文件后缀名(比如.jpg)，并返回一个闭包</li><li>调用闭包，可以传入一个文件名，如果该文件名没有指定的后缀(比如.jpg)，则返回 文件名.jpg，如果已经有.jpg后缀，则返回原文件名。</li><li>要求使用闭包的方式完成</li><li>Strings.HasSuffix， 该函数可以判断某个字符串是否有指定的后缀 。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"strings"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">makeSuffix</span><span class="token punctuation">(</span>suffix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token operator">!</span>strings<span class="token punctuation">.</span><span class="token function">HasSuffix</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>suffix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> name <span class="token operator">+</span> suffix    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> name    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//返回一个闭包</span>  f <span class="token operator">:=</span> <span class="token function">makeSuffix</span><span class="token punctuation">(</span><span class="token string">".jpg"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件名处理后="</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"winter"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件名处理后="</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"winter.jpg.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>上面代码的总结和说明：</p><ol><li>返回的匿名函数和 makeSuffix (suffix string) 的 suffix 变量 组合成一个闭包,因为 返回的函数引用 到 suffix 这个变量</li><li>我们体会一下闭包的好处，如果使用传统的方法，也可以轻松实现这个功能，但是传统方法需要每 次都传入 后缀名，比如 .jpg ,而闭包因为可以保留上次引用的某个值，所以我们传入一次就可以反复 使用。可以仔细的体会一把!</li></ol><h2 id="函数的defer"><a href="#函数的defer" class="headerlink" title="函数的defer"></a>函数的defer</h2><h3 id="为什么需要defer"><a href="#为什么需要defer" class="headerlink" title="为什么需要defer"></a>为什么需要defer</h3><p>​在函数中，程序员经常需要创建资源（比如：数据库连接、文件句柄、锁等），为了在<strong>函数执行完毕后，及时的释放资源</strong>，Go的设计者提供defer（延时机制）。</p><h3 id="快速入门案例-1"><a href="#快速入门案例-1" class="headerlink" title="快速入门案例"></a>快速入门案例</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈（defer栈）</span>  <span class="token comment">//当函数执行完毕后，再从defer栈，按照先入后出的方式出栈，执行</span>  <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok1 n1="</span><span class="token punctuation">,</span>n1<span class="token punctuation">)</span><span class="token comment">//defer 3. ok1 n1 = 10</span>  <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok2 n2="</span><span class="token punctuation">,</span>n2<span class="token punctuation">)</span><span class="token comment">//defer 2. ok2 n2 = 20</span>    res <span class="token operator">:=</span> n1 <span class="token operator">+</span> n2 <span class="token comment">// res = 30</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok3 res="</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>  <span class="token keyword">return</span> res<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  res <span class="token operator">:=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token comment">// 4. res = 30</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter06&#x2F;demo06&#x2F;main  go run .&#x2F;main.gook3 res&#x3D; 30ok2 n2&#x3D; 20ok1 n1&#x3D; 10res&#x3D; 30</code></pre><h3 id="defer的注意事项和细节"><a href="#defer的注意事项和细节" class="headerlink" title="defer的注意事项和细节"></a>defer的注意事项和细节</h3><ol><li>当go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入到一个栈中【暂时称此栈为defer栈】，然后继续执行函数下一个语句</li><li>当函数执行完毕后，再从defer栈中，依次从栈顶取出语句执行（注：遵守栈 先入后出的机制），所以可以看到前面案例输出的顺序。</li><li>在defer将语句放入到栈时，也会将相关的值拷贝同时入栈。<strong>请看一段代码：</strong></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span> n2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//当执行到defer时，暂时不执行，会讲defer后面的语句压入到独立的栈(defer栈)</span>  <span class="token comment">//当函数执行完毕后，再从defer栈，按照先入后出的方式出栈，执行</span>  <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok1 n1="</span><span class="token punctuation">,</span>n1<span class="token punctuation">)</span> <span class="token comment">//defer 3. ok1 n1=10</span>  <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok2 n2="</span><span class="token punctuation">,</span>n2<span class="token punctuation">)</span> <span class="token comment">//defer 2. ok2 n2=20</span>  <span class="token comment">//增加一句话</span>  n1<span class="token operator">++</span> <span class="token comment">//n1 = 11</span>  n2<span class="token operator">++</span> <span class="token comment">//n2 = 21</span>  res <span class="token operator">:=</span> n1 <span class="token operator">+</span> n2 <span class="token comment">// res = 32</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok3 res="</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span> <span class="token comment">//1. ok3 res= 32</span>  <span class="token keyword">return</span> res<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  res <span class="token operator">:=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token comment">//4. res = 32</span><span class="token punctuation">&#125;</span></code></pre><p><img src="http://cdn.leafii.top/img/20220520152102.png" loading="lazy"></p><h3 id="defer的最佳实践"><a href="#defer的最佳实践" class="headerlink" title="defer的最佳实践"></a>defer的最佳实践</h3><p>defer最主要的价值是在，当函数执行完毕后可以及时的释放函数创建的资源。看看模拟代码： </p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//关闭文件资源</span>  file <span class="token operator">=</span> <span class="token function">openfile</span><span class="token punctuation">(</span>文件名<span class="token punctuation">)</span>  <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//其他代码</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//释放数据库资源</span>  connect <span class="token operator">=</span> <span class="token function">openDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">defer</span> cinnect<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//其他代码</span><span class="token punctuation">&#125;</span></code></pre><p>说明</p><ol><li>在Golang编程中的通常做法是，创建资源后，比如（打开了文件，获取了数据库的链接，或者是锁资源），可以执行defer file.Close() defer connect.Close()</li><li>在defer后，可以继续使用创建资源。</li><li>当函数完毕后，系统会依次从defer栈中，取出语句，关闭资源</li><li>这种机制，非常简洁，程序员不用再为什么时候关闭资源而烦心。</li></ol><h2 id="函数参数传递方式"><a href="#函数参数传递方式" class="headerlink" title="函数参数传递方式"></a>函数参数传递方式</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​我们在讲解函数注意事项和使用细节时，已经讲过值类型和引用类型了，这里我们再系统总结一 下，因为这是重难点，值类型参数默认就是值传递，而引用类型参数默认就是引用传递。</p><h3 id="两种传递方式"><a href="#两种传递方式" class="headerlink" title="两种传递方式"></a>两种传递方式</h3><ol><li>值传递</li><li>引用传递</li></ol><p>  其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。</p><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ol><li>值类型：基本数据类型int系列，float系列，bool，string，数组和结构体struct</li><li>引用类型：指针、slice切片、map、管道chan、interface等都是引用类型</li></ol><h3 id="值传递和引用传递使用特点"><a href="#值传递和引用传递使用特点" class="headerlink" title="值传递和引用传递使用特点"></a>值传递和引用传递使用特点</h3><ol><li>值类型默认是值传递，变量直接存储值，内存通常在栈中分配【示意图】</li></ol><p><img src="http://cdn.leafii.top/img/20220520152119.png" loading="lazy"></p><ol start="2"><li>引用类型默认是引用传递：变量存储的是一个地址，这个地址对应的空间才真正存储数据（值），内存通常在堆上分配，当没有任何变量引出这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收。【示意图】</li></ol><p><img src="http://cdn.leafii.top/img/20220520152137.png" loading="lazy"></p><ol start="3"><li>如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量。从效果上看类似引用。这个案例在前面详解函数使用注意事项中有。</li></ol><p><img src="http://cdn.leafii.top/img/20220520152150.png" loading="lazy"></p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ol><li>函数内部声明&#x2F;定义的变量叫局部变量，作用域仅限于<strong>函数内部</strong></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//age 和 Name 的作用域就只在test函数内部</span>  age <span class="token operator">:=</span> <span class="token number">10</span>  Name <span class="token operator">:=</span> <span class="token string">"tom~"</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span></code></pre><ol start="2"><li>函数外部声明&#x2F;定义的变量叫全局变量，作用域在整个包都有效，如果其首字母为大写，则作用 域在整个程序有效</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span><span class="token punctuation">(</span>  <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//函数外部声明/定义的变量叫全局变量</span><span class="token comment">//作用域在整个包都有效，如果其首字母为大写，则作用域在整个程序有效</span><span class="token keyword">var</span> age <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">50</span><span class="token keyword">var</span> Name <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"jack~"</span><span class="token comment">//函数</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//age和Name的作用域就只在test函数内部</span>  age <span class="token operator">:=</span> <span class="token number">10</span>  Name <span class="token operator">:=</span> <span class="token string">"tom~"</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"age="</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">//10</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Name="</span><span class="token punctuation">,</span> Name<span class="token punctuation">)</span> <span class="token comment">// tom~</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"age="</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">// 50</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Name="</span><span class="token punctuation">,</span> Name<span class="token punctuation">)</span> <span class="token comment">//jack~</span>  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>如果变量是在一个代码块，比如for&#x2F;if中，那么这个变量的作用域就在该代码块</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//如果变量是在一个代码块，比如for/if中，那么这个变量的作用域就在该代码块</span><span class="token keyword">for</span> i<span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token comment">//局部变量</span><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></code></pre><h3 id="变量作用域的课堂练习"><a href="#变量作用域的课堂练习" class="headerlink" title="变量作用域的课堂练习"></a>变量作用域的课堂练习</h3><ul><li>题1</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"tom~"</span><span class="token keyword">func</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// tom~</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  name <span class="token operator">:=</span> <span class="token string">"jack~"</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// jack</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// tom</span>  <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//tom</span>  <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// jack</span>  <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// tom</span><span class="token punctuation">&#125;</span></code></pre><ul><li>题2</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> Age <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">20</span> <span class="token comment">// ok</span>Name <span class="token operator">:=</span> <span class="token string">"tom"</span> <span class="token comment">// var Name stringName = "tom"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span>Name<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p><strong>错误，因为赋值语句 不能在函数体外面</strong></p><h2 id="函数课堂练习（综合）"><a href="#函数课堂练习（综合）" class="headerlink" title="函数课堂练习（综合）"></a>函数课堂练习（综合）</h2><ol><li>函数可以没有返回值案例，编写一个函数，从终端输入一个整数打印出对应的金字塔</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//将打印金字塔的代码封装到函数中</span><span class="token keyword">func</span> <span class="token function">printPyramid</span><span class="token punctuation">(</span>totalLevel <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//i表示层数</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> totalLevel<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//在打印*前先打印空格</span>    <span class="token keyword">for</span> k <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> totalLevel <span class="token operator">-</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">&#123;</span>      fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">//j表示每层打印多少</span>    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>      fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//调用printPyramid函数就可以打印金字塔</span>  <span class="token comment">//从终端输入一个整数打印出对应的金字塔</span>  <span class="token keyword">var</span> n <span class="token builtin">int</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入打印金字塔的层数"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span>  <span class="token function">printPyramid</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">请输入打印金字塔的层数3  * ********</code></pre><ol start="2"><li>编写一个函数，从终端输入一个整数（1到9），打印出对应的乘法表</li></ol><ul><li>思路：将九九乘法表以函数的方式封装，在需要打印时，直接调用即可</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">printMulti</span><span class="token punctuation">(</span>num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//打印出九九乘法表</span>  <span class="token comment">//i表示层数</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> j<span class="token operator">:=</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>      fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v * %v = %v \t"</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">*</span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//从终端输入一个整数表示要打印的乘法表对应的数</span>  <span class="token keyword">var</span> num <span class="token builtin">int</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入九九乘法表的对应数"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span>  <span class="token function">printMulti</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">请输入九九乘法表的对应数71 * 1 &#x3D; 1 1 * 2 &#x3D; 2       2 * 2 &#x3D; 4 1 * 3 &#x3D; 3       2 * 3 &#x3D; 6       3 * 3 &#x3D; 9 1 * 4 &#x3D; 4       2 * 4 &#x3D; 8       3 * 4 &#x3D; 12      4 * 4 &#x3D; 16 1 * 5 &#x3D; 5       2 * 5 &#x3D; 10      3 * 5 &#x3D; 15      4 * 5 &#x3D; 20      5 * 5 &#x3D; 25 1 * 6 &#x3D; 6       2 * 6 &#x3D; 12      3 * 6 &#x3D; 18      4 * 6 &#x3D; 24      5 * 6 &#x3D; 30      6 * 6 &#x3D; 36 1 * 7 &#x3D; 7       2 * 7 &#x3D; 14      3 * 7 &#x3D; 21      4 * 7 &#x3D; 28      5 * 7 &#x3D; 35      6 * 7 &#x3D; 42       7 * 7 &#x3D; 49 </code></pre><ol start="3"><li>编写函数，对给定的一个二位数组（3 * 3）转置，这个题将数组的时候再完成8</li></ol><h2 id="字符串常用的系统函数"><a href="#字符串常用的系统函数" class="headerlink" title="字符串常用的系统函数"></a>字符串常用的系统函数</h2><p>​说明：字符串在我们程序开发中，使用的是非常多的，常用的函数需要同学们掌握[带看手册或者 官方编程指南]</p><ol><li>统计字符串的长度，按字节 len(str)</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  str <span class="token operator">:=</span> <span class="token string">"hello叶"</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"str len="</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 8</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li>字符串遍历，同时处理有中文的问题 <code>r := []rune(str)</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">str2 <span class="token operator">:=</span> <span class="token string">"hello北京"</span><span class="token comment">//字符串遍历，同时处理有中文的问题 r := []rune(str)</span>r <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"字符=%c\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>字符串转整数：<code>n,err := strong.Atoi(&quot;12&quot;)</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">n<span class="token punctuation">,</span> err <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"转换错误"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"转成的结果是"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>整数转字符串 <code>str = strconv.Itoa(12345)</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">str <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str=%v, str=%T"</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> str<span class="token punctuation">)</span></code></pre><ol start="5"><li>字符串 转 []byte: <code>var bytes = []byte(&quot;hello go&quot;)</code></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> bytes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello go"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"bytes = %v \n"</span><span class="token punctuation">,</span>bytes<span class="token punctuation">)</span></code></pre><ol start="6"><li>[]byte 转 字符串：<code>str = string([]byte&#123;97,98,99&#125;)</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">str <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#123;</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">98</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str=%v\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span></code></pre><ol start="7"><li>10进制转2，8，16进制： <code>str = strconv.FormatInt(123,2) // 2-&gt;8, 16</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">str <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">FormatInt</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"123对应的二进制是=%v\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span>str <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">FormatInt</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"123对应的16进制是%v\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span></code></pre><ol start="8"><li>查找子串是否在指定的字符串中： <code>strings.Contains(&quot;seafood&quot;, &quot;foo&quot;) //true</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">b <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Contaions</span><span class="token punctuation">(</span><span class="token string">"seafood"</span><span class="token punctuation">,</span> <span class="token string">"mary"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"b=%v\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span></code></pre><ol start="9"><li>统计一个字符串有几个指定的子串： <code>strings.Count(&quot;seheese&quot;, &quot;e&quot;) //4</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">num <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token string">"ceheese"</span><span class="token punctuation">,</span> <span class="token string">"e"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"num=%v\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span></code></pre><ol start="10"><li>不区分大小写的字符串比较(&#x3D;&#x3D;是区分字母大小写的): <code>fmt.Println(strings.EqualFold(&quot;abc&quot;, &quot;Abc&quot;)) // true</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">b <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">EqualFold</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"Abc"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"b=%v\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token comment">// true</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"结果"</span><span class="token punctuation">,</span><span class="token string">"abc"</span> <span class="token operator">==</span> <span class="token string">"Abc"</span><span class="token punctuation">)</span> <span class="token comment">//false 区分字母大小写</span></code></pre><ol start="11"><li>返回子串在字符串第一次出现的index值，如果没有返回-1:<code>strings.Index(&quot;NLT_abc&quot;, &quot;abc&quot;) //4</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">index <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span><span class="token string">"NLT_abc"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"index=%v\n"</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre><ol start="12"><li>返回子串在字符串最后一次出现的index，如没有返回-1:<code>strings.LastIndex(&quot;go golang&quot;,&quot;go&quot;)</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">index <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">LastIndex</span><span class="token punctuation">(</span><span class="token string">"go golang"</span><span class="token punctuation">,</span><span class="token string">"go"</span><span class="token punctuation">)</span> <span class="token comment">//3</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"index=%v\n"</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span></code></pre><ol start="13"><li>将指定的子串替换成 另外一个子串:<code> strings.Replace(&quot;go go hello&quot;, &quot;go&quot;, &quot;go 语言&quot;, n)</code> n 可以指定你希望替换几个，如果 n&#x3D;-1 表示全部替换</li></ol><pre class="language-go" data-language="go"><code class="language-go">str2 <span class="token operator">=</span> <span class="token string">"go go hello"</span>str <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span> <span class="token string">"go"</span><span class="token punctuation">,</span> <span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str=%v str2=%v\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span> str2<span class="token punctuation">)</span></code></pre><ol start="14"><li><p>按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组:</p><p><code>strings.Split(&quot;hello,wrold,ok&quot;, &quot;,&quot;)</code></p></li></ol><pre class="language-go" data-language="go"><code class="language-go">strArr <span class="token operator">:=</span> <span class="token builtin">string</span><span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string">"hello,world,ok"</span><span class="token punctuation">,</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>strArr<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str[%v]=%v\n"</span><span class="token punctuation">,</span> strArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"strArr=%v\n"</span><span class="token punctuation">,</span>strArr<span class="token punctuation">)</span></code></pre><ol start="15"><li>将字符串的字母进行大小写的转换：<code>strings.ToLower(&quot;Go&quot;) // go strings.ToUpper(&quot;Go&quot;) // GO</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">str <span class="token operator">:=</span> <span class="token string">"golang Hello"</span>str <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">ToLower</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>str <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str=%v\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span> <span class="token comment">// GOLANG HELLO</span></code></pre><ol start="16"><li>将字符串左右两边的空格去掉：<code> strings.TrimSpace(&quot;tn a lone gopher ntrn&quot;)</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">str <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">TrimSpace</span><span class="token punctuation">(</span><span class="token string">"tn a lone gopher ntrn"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str=%q\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span> </code></pre><ol start="17"><li>将字符串左右两边指定的字符去掉 : <code>strings.Trim(&quot;! hello! &quot;, &quot; !&quot;)//// [&quot;hello&quot;] //将左右两边 !和 &quot;&quot;去掉</code></li></ol><pre class="language-go" data-language="go"><code class="language-go">str <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">Trim</span><span class="token punctuation">(</span><span class="token string">"! hello! "</span><span class="token punctuation">,</span> <span class="token string">" !"</span><span class="token punctuation">)</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str=%q\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span></code></pre><ol start="18"><li><p>将字符串左边指定的字符去掉：<code> strings.TrimLeft(&quot;!hello!&quot;,&quot;!&quot;) //[&quot;hello&quot;]将左边！和&quot;&quot;去掉</code></p></li><li><p>将字符串右边指定的字符去掉：<code> strings.TrimRight(&quot;!hello!&quot;,&quot;!&quot;) //[&quot;hello&quot;]将右边！和&quot;&quot;去掉</code></p></li><li><p>判断字符串是否以指定的字符串开头:<code> strings.HasPrefix(&quot;ftp://192.168.10.1&quot;, &quot;ftp&quot;) // true</code></p></li></ol><pre class="language-go" data-language="go"><code class="language-go">b <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span><span class="token string">"ftp://192.168.10.1"</span><span class="token punctuation">,</span> <span class="token string">"hsp"</span><span class="token punctuation">)</span> <span class="token comment">// false</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"b=%v\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span></code></pre><ol start="21"><li>判断字符串是否以指定的字符串结束：<code>strings.HasSuffix(&quot;NLT_abc.jpg&quot;,&quot;abc&quot;) //false</code></li></ol><h2 id="时间和日期相关函数"><a href="#时间和日期相关函数" class="headerlink" title="时间和日期相关函数"></a>时间和日期相关函数</h2><h3 id="基本的介绍"><a href="#基本的介绍" class="headerlink" title="基本的介绍"></a>基本的介绍</h3><p>​说明：在编程中，程序员会经常用到日期相关的函数，比如：统计某段代码执行花费的时间等等。</p><ol><li>时间和日期相关函数，需要导入time包</li></ol><p><img src="http://cdn.leafii.top/img/20220520152211.png" loading="lazy"></p><ol start="2"><li>time.Time类型，用于表示时间</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//看看日期和时间相关函数和方法使用</span>  <span class="token comment">// 1.获取当前时间</span>  now <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"now=%v now type=%T\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">,</span> now<span class="token punctuation">)</span>  <span class="token comment">// 2.通过now可以获取到年月日，时分秒</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"年=%v\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"月=%v\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"月=%v\n"</span><span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"日=%v\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"时=%v\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Hour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"分=%v\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Minute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"秒=%v\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>格式化日期时间</p><ul><li>方式1:就是使用Printf或者Sprintf</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//格式化日期时间</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"当前年月日 %d-%d-%d %d:%d:%d \n"</span><span class="token punctuation">,</span>now<span class="token punctuation">.</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Hour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Minute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"dateStr=%v\n"</span><span class="token punctuation">,</span> dateStr<span class="token punctuation">)</span></code></pre><ul><li>使用time.Format()方法完成：</li></ul><pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>对上面代码的说明：</p><p>“2006&#x2F;01&#x2F;02 15:04:05”这个字符串的各个数字是固定的，必须是这样写。</p><p>“2006&#x2F;01&#x2F;02 15:05:05”这个字符串各个数字可以自由的组合，这样可以按程序需求来返回时间和日期</p><ol start="5"><li>时间的常量</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span><span class="token punctuation">(</span>  Nanosecond Duration <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//纳秒</span>  Microsecond<span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> Nanosecond <span class="token comment">//微秒</span>  Millisecond<span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> Microsecond <span class="token comment">//毫秒</span>  Second<span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> Millisecond <span class="token comment">//秒</span>  Minute<span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> Second <span class="token comment">//分钟</span>  Hour<span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> Minute <span class="token comment">//小时</span><span class="token punctuation">)</span></code></pre><p>​常量的作用：<strong>在程序中可用于获取指定时间单位的时间，比如想得到100毫秒</strong></p><p>​100 * time.Millisecond</p><ol start="6"><li>结合Sleep来使用一下时间常量</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//需求，每隔1秒打印一个数字，打印到100时就退出</span><span class="token comment">//需求2:每隔0.1秒打印一个数字，打印到100时就退出</span>i <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>  i<span class="token operator">++</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token comment">//休眠</span>  <span class="token comment">//time.Sleep(time.Second)</span>  time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">100</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">break</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="7"><li>time的Unix和UnixNano的方法</li></ol><p><img src="http://cdn.leafii.top/img/20220520152226.png" loading="lazy"></p></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//Unix和UnixNano的使用</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"unix时间戳=%v unixnano时间戳=%v\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">2018</span>unix时间戳<span class="token operator">=</span><span class="token number">1527584269</span> unixnano时间戳<span class="token operator">=</span><span class="token number">1527584269975756200</span></code></pre><h3 id="时间和日期的课堂练习"><a href="#时间和日期的课堂练习" class="headerlink" title="时间和日期的课堂练习"></a>时间和日期的课堂练习</h3><p>编写一段代码来统计 函数test03执行的时间</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"time"</span>  <span class="token string">"strconv"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  str <span class="token operator">:=</span> <span class="token string">""</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    str <span class="token operator">+=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//在执行test03前，先获取到当前的unix时间戳</span>  start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  end <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"执行test03()耗费时间为%v秒\n"</span><span class="token punctuation">,</span> end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><p>​Golang设计者为了编程方便，提供了一些函数，这些函数可以直接使用，我们称为Go的内置函数。文档：<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a> -&gt; builtin</p><ol><li>len:用来求长度，比如string、array、slice、map、channel</li><li>new:用来分配内存，主要用来分配值类型，比如int、float32,struct…返回的是指针</li></ol><p>举例说明 <strong>new</strong> 的使用:</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  num1 <span class="token operator">:=</span> <span class="token number">100</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"num1的类型%T , num1的值=%v , num1的地址%v\n"</span><span class="token punctuation">,</span> num1<span class="token punctuation">,</span> num1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>num1<span class="token punctuation">)</span>  num2 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// *int</span>  <span class="token comment">//num2的类型%T => *int</span>  <span class="token comment">//num2的值 = 地址 0xc0420404c098 （系统分配）</span>  <span class="token comment">//num2的地址 %v = 地址 0xc04206a020 (系统分配)</span>  <span class="token comment">//num2指向的值 = 100</span>  <span class="token operator">*</span>num2 <span class="token operator">=</span> <span class="token number">100</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"num2的类型%T , num2的值=%v , num2的地址%v\n nu2这个指针， 指向的值=%v"</span><span class="token punctuation">,</span> num2<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>num2<span class="token punctuation">,</span> <span class="token operator">*</span>num2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">num1的类型int , num1的值&#x3D;100 , num1的地址0xc00001e090num2的类型*int , num2的值&#x3D;0xc00001e098 , num2的地址0xc00000e030 num2这个指针指向的值&#x3D;100 </code></pre><p>上面代码对应的内存分析图：</p><p><img src="http://cdn.leafii.top/img/20220520152245.png" loading="lazy"></p><ol start="3"><li>make: 用来<strong>分配内存</strong>，主要用来<strong>分配引用类型</strong>，比如channel 、 map 、slice。这个之后讲解。</li></ol><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  num1 <span class="token operator">:=</span> <span class="token number">10</span>  num2 <span class="token operator">:=</span> <span class="token number">0</span>  res <span class="token operator">:=</span> num1 <span class="token operator">/</span> num2  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//测试</span>  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main()下面的代码..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">panic: runtime error: integer divide by zerogoroutine 1 [running]:main.test()        &#x2F;Users&#x2F;leafii&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter06&#x2F;demo10&#x2F;main&#x2F;main.go:8 +0x11main.main()        &#x2F;Users&#x2F;leafii&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter06&#x2F;demo10&#x2F;main&#x2F;main.go:13 +0x25exit status 2</code></pre><ul><li>对上面代码的总结<ol><li>在默认情况下，当发生错误后(panic) ,程序就会退出(崩溃.)</li><li>如果我们希望:当发生错误后，可以捕获到错误，并进行处理，保证程序可以继续执行。还可 以在捕获到错误后，给管理员一个提示(邮件,短信。。。)</li><li>这里引出我们要将的错误处理机制</li></ol></li></ul><h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><ol><li><p>Go语言追求简洁优雅，所以，Go 语言不支持传统的 try…catch…finally 这种处理。 </p></li><li><p>Go中引入的处理方式为:<strong>defer</strong>,<strong>panic</strong>,**recover<br>**</p></li><li><p>这几个异常的使用场景可以这么简单描述:Go 中可以抛出一个 panic 的异常，然后在 defer 中</p><p>通过 recover 捕获这个异常，然后正常处理</p></li></ol><h3 id="使用defer-recover来处理错误"><a href="#使用defer-recover来处理错误" class="headerlink" title="使用defer+recover来处理错误"></a>使用defer+recover来处理错误</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//使用defer + recover 来捕获和处理异常</span>  <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//recover() 内置函数，可以捕获到异常</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> nul <span class="token punctuation">&#123;</span> <span class="token comment">//说明捕获到错误</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"err="</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  num1 <span class="token operator">:=</span> <span class="token number">10</span>  num2 <span class="token operator">:=</span> <span class="token number">0</span>  res <span class="token operator">:=</span> num1 <span class="token operator">/</span> num2  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//测试</span>  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main()下面的代码..."</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none"> ~&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter06&#x2F;demo10&#x2F;main  go run .&#x2F;main.goerr&#x3D; runtime error: integer divide by zeromain()下面的代码...main()下面的代码...main()下面的代码...^Csignal: interrupt</code></pre><h3 id="错误处理的好处"><a href="#错误处理的好处" class="headerlink" title="错误处理的好处"></a>错误处理的好处</h3><p>进行错误处理后，程序不会轻易挂掉，如果加入预警代码，就可以让程序更加的健壮。【案例演示】</p><pre class="language-go" data-language="go"><code class="language-go"> ~<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">/</span>src<span class="token operator">/</span>go_code<span class="token operator">/</span>chapter06<span class="token operator">/</span>demo11<span class="token operator">/</span>main  <span class="token keyword">go</span> run <span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span>err<span class="token operator">=</span> runtime <span class="token builtin">error</span><span class="token punctuation">:</span> integer divide by zero发送邮件给admin@outlook<span class="token punctuation">.</span>com~~~~~~~~~<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>下面的代码<span class="token operator">...</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>下面的代码<span class="token operator">...</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>下面的代码<span class="token operator">...</span><span class="token operator">^</span>Csignal<span class="token punctuation">:</span> interrupt</code></pre><h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><h3 id="自定义错误的介绍"><a href="#自定义错误的介绍" class="headerlink" title="自定义错误的介绍"></a>自定义错误的介绍</h3><p>Go程序中，也支持自定义错误，使用error.New和panic内置函数</p><ol><li>errors.New(“错误说明”)，会返回一个error类型的值，表示一个错误</li><li>panic内置函数，接收一个interface{}类型的值（也就是任何值了）作为参数。可以接收error类型的变量，<strong>输出错误信息，并退出程序。</strong></li></ol><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"errors"</span><span class="token punctuation">)</span><span class="token comment">//函数去读取以配置文件init.conf的信息</span><span class="token comment">//如果文件名传入不正确，我们就返回一个自定义的错误</span><span class="token keyword">func</span> <span class="token function">readConf</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">"config.ini"</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//读取</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//返回一个自定义错误</span>    <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"读取文件错误.."</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  err <span class="token operator">:=</span> <span class="token function">readConf</span><span class="token punctuation">(</span><span class="token string">"config2.ini"</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//如果读取文件发送错误，就输出这个错误，并终止程序</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"test02()继续执行..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//测试</span>  <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main()下面的代码..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">panic: 读取文件错误..goroutine 1 [running]:main.test02()        &#x2F;Users&#x2F;leafii&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter06&#x2F;demo12&#x2F;main&#x2F;main.go:21 +0x5amain.main()        &#x2F;Users&#x2F;leafii&#x2F;go&#x2F;src&#x2F;go_code&#x2F;chapter06&#x2F;demo12&#x2F;main&#x2F;main.go:27 +0x25exit status 2</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言の程序流程控制</title>
      <link href="/2021/01/15/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2021/01/15/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言の程序流程控制"><a href="#Go语言の程序流程控制" class="headerlink" title="Go语言の程序流程控制"></a>Go语言の程序流程控制</h1><h2 id="程序流程控制介绍"><a href="#程序流程控制介绍" class="headerlink" title="程序流程控制介绍"></a>程序流程控制介绍</h2><p>在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程控制语句。</p><ol><li>顺序控制</li><li>分支控制</li><li>循环控制</li></ol><span id="more"></span><h2 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h2><p>​程序从上到下逐行执行，中间没有任何判断和跳转。</p><p>​一个案例说明，必须下面的代码中，没有判断，也没有跳转，因此程序按照默认的流程执行，即顺序控制。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> days <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">97</span><span class="token keyword">var</span> week <span class="token builtin">int</span> <span class="token operator">=</span> days <span class="token operator">/</span> <span class="token number">7</span><span class="token keyword">var</span> day <span class="token builtin">int</span> <span class="token operator">=</span> days <span class="token operator">%</span> <span class="token number">7</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d个星期零%d天\n"</span><span class="token punctuation">,</span> week<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token keyword">var</span> huashi <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">134.2</span><span class="token keyword">var</span> sheshi <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">5.0</span> <span class="token operator">/</span> <span class="token number">9</span> <span class="token operator">*</span> <span class="token punctuation">(</span>huashi <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v 对应的摄氏温度=%v \n"</span><span class="token punctuation">,</span> huashi<span class="token punctuation">,</span> sheshi<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">13个星期零6天134.2对应的摄氏温度&#x3D; 19 </code></pre><h3 id="程序控制的流程图"><a href="#程序控制的流程图" class="headerlink" title="程序控制的流程图"></a>程序控制的流程图</h3><p><img src="http://cdn.leafii.top/img/20220520152341.png" loading="lazy"></p><h3 id="顺序控制举例和注意事项"><a href="#顺序控制举例和注意事项" class="headerlink" title="顺序控制举例和注意事项"></a>顺序控制举例和注意事项</h3><p>​Golang中定义变量时采用合法的前向引用。如：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> num1 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">//声明了num1</span>  <span class="token keyword">var</span> num2 <span class="token builtin">int</span> <span class="token operator">=</span> num1 <span class="token operator">+</span> <span class="token number">20</span> <span class="token comment">//使用num1</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>错误形式：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> num2 <span class="token builtin">int</span> <span class="token operator">=</span> num1 <span class="token operator">+</span> <span class="token number">20</span> <span class="token comment">//使用num1</span>  <span class="token keyword">var</span> num1 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">//声明num1 (❌)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h2 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h2><h3 id="分支控制的基本介绍"><a href="#分支控制的基本介绍" class="headerlink" title="分支控制的基本介绍"></a>分支控制的基本介绍</h3><p>分支控制就是让程序有选择执行。有下面三种形式</p><ol><li>单分支</li><li>双分支</li><li>多分枝</li></ol><h3 id="单分支控制"><a href="#单分支控制" class="headerlink" title="单分支控制"></a>单分支控制</h3><ul><li>基本语法</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> 条件表达式<span class="token punctuation">&#123;</span>  执行代码块<span class="token punctuation">&#125;</span></code></pre><p><strong>说明：当条件表达式为true时，就会执行{}的代码。注意{}是必须有的，就算你只写一行代码。</strong></p><ul><li>应用案例</li></ul><p>编写一个程序，可以输入人的年龄,如果该同志的年龄大于 18 岁,则输出 “你年龄大 于 18,要对自己的行为负责!”。      需求—【分析】—&gt;代码</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> age <span class="token builtin">int</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入年龄："</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>age<span class="token punctuation">)</span>    <span class="token keyword">if</span> age <span class="token operator">></span> <span class="token number">18</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你年龄大于18，要对自己的行为负责！"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go请输入年龄：10➜  main go run .&#x2F;main.go请输入年龄：29你年龄大于18，要对自己的行为负责！➜  main </code></pre><ul><li><p>单分支的流程图</p><p>流程图可以用<strong>图形方式</strong>来更加清晰的描述程序执行的流程。</p><p><img src="http://cdn.leafii.top/img/20220520152357.png" loading="lazy"></p></li><li><p>单分支的细节说明</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> age <span class="token operator">:=</span> <span class="token number">20</span><span class="token punctuation">;</span> age <span class="token operator">></span> <span class="token number">18</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你年龄大于18，要对自己的行为负责!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h3 id="双分支控制"><a href="#双分支控制" class="headerlink" title="双分支控制"></a>双分支控制</h3><ul><li>基本语法</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> 条件表达式<span class="token punctuation">&#123;</span>  执行代码块<span class="token number">1</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  执行代码块<span class="token number">2</span><span class="token punctuation">&#125;</span></code></pre><p><strong>说明：当条件表达式成立，即执行代码块1，否则执行代码块2.{}也是必须有的。</strong></p><ul><li>应用案例</li></ul><p>编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁,则输出 “你年龄大于 18,要对 自己的行为负责!”。否则 ,输出”你的年龄不大这次放过你了.”</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> age <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入年龄："</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>age<span class="token punctuation">)</span><span class="token keyword">if</span> age <span class="token operator">></span> <span class="token number">18</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你年龄大于18，要对自己的行为负责！"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你的年龄不大这次放过你了."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go请输入年龄：19你年龄大于18，要对自己的行为负责！➜  main go run .&#x2F;main.go请输入年龄：12你的年龄不大这次放过你了.</code></pre><ul><li>双分支流程图的分析</li></ul><p><img src="http://cdn.leafii.top/img/20220520152412.png" loading="lazy"></p><ul><li>对双分支的总结</li></ul><ol><li>从上图看，条件表达式就是age&gt;18</li><li>执行代码块1 就是 fmt.Prinltn(“你的年龄大于18”)…</li><li>执行代码块2 就是 fmt.Println(“你的年龄不大”)…</li><li>双分支<strong>只会执行其中的一个分支。</strong></li></ol><h3 id="单分支和双分支的案例"><a href="#单分支和双分支的案例" class="headerlink" title="单分支和双分支的案例"></a>单分支和双分支的案例</h3><ol><li>对下列代码，若有输出，指出输出结果.</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">var</span> y <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>y <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hihihi"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"x is ="</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果是 hihihi</span></code></pre><ol start="2"><li>对下列代码，若有输出，指出输出结果.</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">2</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token keyword">else</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment">//没有&#123;&#125; 所以编译错误哦</span></code></pre><ol start="3"><li>对下列代码，若有输出，指出输出结果.</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//编译错误，因为else不能换行</span></code></pre><ol start="4"><li>对下列代码，若有输出，指出输出结果.</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//输出ok 但是建议把if(x>2)写成if x > 2</span></code></pre><ol start="5"><li>编写程序，声明 2 个 int32 型变量并赋值。判断两数之和，如果大于等于 50，打印“hello world!</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> n1 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">10</span>  <span class="token keyword">var</span> n2 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">50</span>  <span class="token keyword">if</span> n1 <span class="token operator">+</span> n2 <span class="token operator">>=</span><span class="token number">50</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello,world"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>编写程序，声明 2 个 float64 型变量并赋值。判断第一个数大于 10.0，且第 2 个数小于 20.0，打 印两数之和。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> n3 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">11.0</span><span class="token keyword">var</span> n4 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">17.0</span><span class="token keyword">if</span> n3 <span class="token operator">></span> <span class="token number">10.0</span> <span class="token operator">&amp;&amp;</span> n4 <span class="token operator">&lt;</span> <span class="token number">20.0</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"和="</span><span class="token punctuation">,</span><span class="token punctuation">(</span>n3<span class="token operator">+</span>n4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="7"><li>定义两个变量 int32，判断二者的和，是否能被 3 又能被 5 整除，打印提示信息</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> num1 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">var</span> num2 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">if</span> <span class="token punctuation">(</span>num1 <span class="token operator">+</span> num2<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>num1 <span class="token operator">+</span> num2<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"能被3又能被5整除"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="8"><li>判断一个年份是否是闰年，闰年的条件是符合下面二者之一:(1)年份能被4整除，但不能被100 整除;(2)能被 400 整除</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> year <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">2019</span><span class="token keyword">if</span> <span class="token punctuation">(</span>year <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> year <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">||</span> year <span class="token operator">%</span> <span class="token number">400</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> <span class="token string">"是闰年!``"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h3 id="多分支控制"><a href="#多分支控制" class="headerlink" title="多分支控制"></a>多分支控制</h3><ul><li>基本语法</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> 条件表达式<span class="token number">1</span> <span class="token punctuation">&#123;</span>  执行代码块<span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">&#123;</span>  执行代码块<span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token operator">...</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  执行代码块n<span class="token punctuation">&#125;</span></code></pre><ul><li>说明：</li></ul><ol><li>多分支的判断流程如下：<ol><li>先判断条件表达式1是否成立，如果为真，就执行代码块1</li><li>如果条件表达式1如果为假，就去判断条件表达式2是否成立，如果条件表达式2为真，就执行代码块2</li><li>以此类推</li><li>如果所有的条件表达式不成立，则执行else的语句块。</li></ol></li><li>else 不是必须的</li><li>多分支只能有一个执行入口。</li></ol><ul><li>看一个多分支的流程图</li></ul><p><img src="http://cdn.leafii.top/img/20220520152427.png" loading="lazy"></p><ul><li>多分支的快速入门案例</li></ul><p>岳小鹏参加 Golang 考试，他和父亲岳不群达成承诺: 如果:</p><p>​成绩为 100 分时，奖励一辆 BMW; </p><p>​成绩为(80，99]时，奖励一台 iphone7plus; </p><p>​当成绩为[60,80]时，奖励一个 iPad; </p><p>​其它时，什么奖励也没有。 请从键盘输入岳小鹏的期末成绩，并加以判断</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> score <span class="token builtin">int</span>  fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"请输入成绩:"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>score<span class="token punctuation">)</span>  <span class="token keyword">if</span> score <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"奖励BMW"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> score <span class="token operator">></span> <span class="token number">80</span> <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">99</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"奖励一台iphone12 pro max"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> score <span class="token operator">>=</span> <span class="token number">60</span> <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span><span class="token number">80</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"奖励一个iPad"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"啥也没"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p>多分支的课堂练习</p><p>案例演示2</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> b <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span>  <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> b<span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token operator">!</span>b<span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token comment">//c</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果是b</span><span class="token comment">//如果写成b=flase;能编译通过吗？如果能，结果是？（不能通过，if的条件表达式不是赋值语句)</span></code></pre><p>​案例演示3</p><p><img src="http://cdn.leafii.top/img/20220520152442.png" loading="lazy"></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"math"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> a <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">1.0</span><span class="token keyword">var</span> b <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">4.0</span><span class="token keyword">var</span> c <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">2.0</span>m <span class="token operator">:=</span> b <span class="token operator">*</span> b <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">*</span> a <span class="token operator">*</span> c<span class="token comment">//多分支判断</span><span class="token keyword">if</span> m <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>  x1 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">-</span>b <span class="token operator">+</span> math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">*</span> a  x2 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">-</span>b <span class="token operator">-</span> math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">*</span> a  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"x1=%v x2=%v \n"</span><span class="token punctuation">,</span> x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">&#123;</span>  x1 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">-</span>b <span class="token operator">+</span> math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">*</span> a  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"x1=%v\n"</span><span class="token punctuation">,</span> x1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"无解..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.gox1&#x3D;-4%                                                                                           ➜  main go run .&#x2F;main.gox1&#x3D;-0.5857864376269049 x2&#x3D;-3.414213562373095%                                                    ➜  main go run .&#x2F;main.gox1&#x3D;-0.5857864376269049 x2&#x3D;-3.414213562373095 ➜  main </code></pre><p>​案例演示4</p><p><img src="http://cdn.leafii.top/img/20220520152501.png" loading="lazy"></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> height <span class="token builtin">int32</span><span class="token keyword">var</span> money <span class="token builtin">float32</span><span class="token keyword">var</span> handsome <span class="token builtin">bool</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入身高（厘米）"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>height<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入财富（千万）"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>money<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入是否帅气（true or false）"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handsome<span class="token punctuation">)</span><span class="token keyword">if</span> height <span class="token operator">></span> <span class="token number">180</span> <span class="token operator">&amp;&amp;</span> money <span class="token operator">></span><span class="token number">1.0</span> <span class="token operator">&amp;&amp;</span> handsome <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"一定要嫁给他！！！"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> height <span class="token operator">></span> <span class="token number">180</span> <span class="token operator">||</span> money <span class="token operator">></span><span class="token number">1.0</span> <span class="token operator">||</span> handsome<span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"勉勉强强嫁给他吧"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"不嫁......"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go请输入年龄：10➜  main go run .&#x2F;main.go请输入年龄：29➜  main go run .&#x2F;main.go请输入身高（厘米）190请输入财富（千万）12请输入是否帅气（true or false）true一定要嫁给他！！！➜  main go run .&#x2F;main.go请输入身高（厘米）120请输入财富（千万）1请输入是否帅气（true or false）false不嫁......➜  main go run .&#x2F;main.go请输入身高（厘米）120请输入财富（千万）1.2请输入是否帅气（true or false）false勉勉强强嫁给他吧➜  main </code></pre><h3 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h3><ul><li><p>基本介绍</p><p>在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外层分支。</p></li><li><p>基本语法</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> 条件表达式<span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> 条件表达式<span class="token punctuation">&#123;</span>      <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>说明：嵌套分支不宜过多，建议控制在3层内</strong></p><ul><li>示例代码1</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> second <span class="token builtin">float64</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入秒数"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>second<span class="token punctuation">)</span><span class="token keyword">if</span> second <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> gender <span class="token builtin">string</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入性别"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gender<span class="token punctuation">)</span>  <span class="token keyword">if</span> gender <span class="token operator">==</span> <span class="token string">"男"</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"进入决赛的男子组"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"进入决赛的女子组"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"out......"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go 请输入秒数100out......➜  main go run .&#x2F;main.go请输入秒数3请输入性别男进入决赛的男子组➜  main go run .&#x2F;main.go请输入秒数4请输入性别女进入决赛的女子组</code></pre><ul><li><p>示例代码2</p><p>出票系统：根据淡旺季的月份和年龄，打印票价</p><p>4到10是旺季：</p><p>​成人（18-60）：60</p><p>​儿童（&lt;18):半价 30</p><p>​老人（&gt;60): 1&#x2F;3 20</p><p>淡季: </p><p>​成人:40</p><p>​其他:20</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> month <span class="token builtin">int</span><span class="token keyword">var</span> age <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入月份"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>month<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>month<span class="token operator">>=</span><span class="token number">4</span> <span class="token operator">&amp;&amp;</span> month <span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入购票人年龄:"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>age<span class="token punctuation">)</span>  <span class="token keyword">if</span> age<span class="token operator">&lt;</span><span class="token number">18</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"您购买的票是旺季儿童票，享受半价优惠：30元"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> age <span class="token operator">></span> <span class="token number">60</span><span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"您购买的票是旺季老人票，享受1/3折：20元"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"您购买的票是旺季成人票，原价购买，60元"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入购票人年龄:"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>age<span class="token punctuation">)</span>  <span class="token keyword">if</span> age<span class="token operator">&lt;</span><span class="token number">18</span> <span class="token operator">||</span> age<span class="token operator">></span><span class="token number">60</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"您购买的票是淡季其他票，享受半价优惠：20元"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"您购买的票是淡季成人票，原价购买，40元"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go 请输入秒数100➜  main go run .&#x2F;main.go# command-line-arguments➜  main go run .&#x2F;main.go请输入月份6请输入购票人年龄:19您购买的票是旺季成人票，60元➜  main go run .&#x2F;main.go请输入月份2请输入购票人年龄:12您购买的票是淡季其他票，20元➜  main go run .&#x2F;main.go请输入月份9请输入购票人年龄:61您购买的票是旺季老人票，20元➜  main go run .&#x2F;main.go请输入月份10请输入购票人年龄:71您购买的票是旺季老人票，20元➜  main </code></pre><h2 id="switch分支控制"><a href="#switch分支控制" class="headerlink" title="switch分支控制"></a>switch分支控制</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>switch语句用于基于不同条件执行不同动作，每一个case分支都是唯一的，从上到下逐疫测试，知道匹配为止。</li><li>匹配项后面也不需要再加break</li></ol><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> 表达式 <span class="token punctuation">&#123;</span>  <span class="token keyword">case</span> 表达式<span class="token number">1</span><span class="token punctuation">,</span>表达式<span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">:</span>  语句块<span class="token number">1</span>  <span class="token keyword">case</span> 表达式<span class="token number">3</span>，表达式<span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">:</span>  语句块<span class="token number">2</span>  <span class="token comment">//这里可以有多个case语句</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>  语句块<span class="token punctuation">&#125;</span></code></pre><h3 id="switch的流程图"><a href="#switch的流程图" class="headerlink" title="switch的流程图"></a>switch的流程图</h3><p><img src="http://cdn.leafii.top/img/20220520152516.png" loading="lazy"></p><ul><li>说明和总结<ol><li>switch的执行的流程是，先执行表达式，得到值，然后和case的表达式进行比较，如果相等，就匹配到，然后执行对应的case的语句块，然后退出switch控制。</li><li>如果switch的表达式的值没有和任何的case的表达式匹配成功，则执行default的语句块，执行后退出switch的控制</li><li>golang的case后的表达式可以有多个，使用 逗号 间隔。</li><li>golang中的case语句块不需要写break，因为默认会有，即在默认情况下，当程序执行完case语句块后，就直接退出该switch控制结构。</li></ol></li></ul><h3 id="switch快速入门案例"><a href="#switch快速入门案例" class="headerlink" title="switch快速入门案例"></a>switch快速入门案例</h3><ul><li><p>案例：</p><p>请编写一个程序，该程序可以接收一个字符，比如: a,b,c,d,e,f,g a表示星期一，b表示星期二 … 根据用户的输入显示相依的信息.要求使用 switch 语句完成</p></li><li><p>代码</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token comment">//分析思路</span><span class="token comment">//1. 定义一个变量接收字符</span><span class="token comment">//2. 使用switch完成</span><span class="token keyword">var</span> key <span class="token builtin">byte</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入一个字符 a,b,c,d,e,f,g"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token keyword">switch</span> key <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'a'</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周一"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'b'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周二"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'c'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周三"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'d'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周四"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'e'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周五"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'f'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周六"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'g'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周日"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"输入有误..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">请输入一个字符 a,b,c,d,e,f,ga周一➜  main ➜  main go run .&#x2F;main.go请输入一个字符 a,b,c,d,e,f,gq输入有误...</code></pre><h3 id="switch的使用的注意事项"><a href="#switch的使用的注意事项" class="headerlink" title="switch的使用的注意事项"></a>switch的使用的注意事项</h3><ol><li>case&#x2F;switch后是一个表达式（即：常量值、变量、一个有返回值的函数等都可以）</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//写一个很简单的函数</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>char <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">byte</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> char <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//</span>  <span class="token keyword">var</span> key <span class="token builtin">byte</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入一个字符 a,b,c,d,e,f,g"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">)</span>    <span class="token keyword">switch</span> <span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">&#123;</span> <span class="token comment">//修改成函数了哦！！</span><span class="token keyword">case</span> <span class="token char">'a'</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周一"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'b'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周二"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'c'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周三"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'d'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周四"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'e'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周五"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'f'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周六"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'g'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周日"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"输入有误..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li>case后的各个表达式的值的数据类型，必须和switch的表达式数据类型一致</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> n1 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">var</span> n2 <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">switch</span> n1 <span class="token punctuation">&#123;</span><span class="token keyword">case</span> n2 <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok1"</span><span class="token punctuation">)</span> <span class="token comment">//错误，因为n2和n1的数据类型不一致</span><span class="token keyword">default</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"没匹配到"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>case 后面可以带多个表达式，使用逗号间隔。比如<code>case 表达式1，表达式2...</code></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> n1 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">var</span> n2 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">switch</span> n1 <span class="token punctuation">&#123;</span><span class="token keyword">case</span> n2<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok1"</span><span class="token punctuation">)</span><span class="token keyword">default</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"没匹配到"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>case后面的表达式如果是常量值（字面量），则要求不能重复</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> n1 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">var</span> n2 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">switch</span> n1 <span class="token punctuation">&#123;</span><span class="token keyword">case</span> n2<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">:</span>        <span class="token comment">//case后面可以有多个表达式</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok1"</span><span class="token punctuation">)</span> <span class="token keyword">case</span> <span class="token number">5</span> <span class="token punctuation">:</span>                <span class="token comment">// 错误，因为前面我们有常量5，因此重复，就会报错哦</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok2~"</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"没匹配到"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="5"><li>case后面不需要带break，程序匹配到一个case后就会执行对应的代码块，然后退出switch，如果一个都匹配不到，则执行default</li><li>default语句不是必须的</li><li>switch后也可以不带表达式，类似 if-else分支来使用。【案例演示】</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> age <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">switch</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> age <span class="token operator">==</span> <span class="token number">10</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"age == 10"</span><span class="token punctuation">)</span><span class="token keyword">case</span> age <span class="token operator">==</span> <span class="token number">20</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"age == 20"</span><span class="token punctuation">)</span><span class="token keyword">default</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"没有匹配到哦"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>score <span class="token operator">:=</span> <span class="token number">90</span><span class="token keyword">switch</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> score <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"成绩优秀.."</span><span class="token punctuation">)</span><span class="token keyword">case</span> score <span class="token operator">>=</span><span class="token number">70</span> <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">90</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"成绩优良.."</span><span class="token punctuation">)</span><span class="token keyword">case</span> score <span class="token operator">>=</span><span class="token number">60</span> <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">70</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"成绩及格.."</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"不及格！"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="8"><li>switch后也可以直接声明&#x2F;定义一个变量，分号结束，<strong>不推荐</strong>。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> grade <span class="token operator">:=</span> <span class="token number">90</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> grade <span class="token operator">></span> <span class="token number">90</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"成绩优秀.."</span><span class="token punctuation">)</span><span class="token keyword">case</span> grade <span class="token operator">>=</span><span class="token number">70</span> <span class="token operator">&amp;&amp;</span> grade <span class="token operator">&lt;=</span> <span class="token number">90</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"成绩优良.."</span><span class="token punctuation">)</span><span class="token keyword">case</span> grade <span class="token operator">>=</span><span class="token number">60</span> <span class="token operator">&amp;&amp;</span> grade <span class="token operator">&lt;=</span> <span class="token number">70</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"成绩及格.."</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"不及格！"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="9"><li>switch穿透-fallthrough，如果在case语句块后增加fallthrough，则会继续执行下一个case，也叫switch穿透。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//switch的穿透fallthrought</span><span class="token keyword">var</span> num <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">switch</span> num <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token number">10</span> <span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok1"</span><span class="token punctuation">)</span><span class="token keyword">fallthrough</span><span class="token comment">//默认只能穿透一层</span><span class="token keyword">case</span> <span class="token number">20</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok2"</span><span class="token punctuation">)</span><span class="token keyword">fallthrough</span><span class="token keyword">case</span> <span class="token number">30</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok3"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"没有匹配到哦"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.gook1ok2ok3➜  main </code></pre><ol start="10"><li>Type Switch : switch 语句还可以被用于 type-switch 来判断某个interface变量中实际指向的变量类型【interface体验】</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">10.0</span>x <span class="token operator">=</span> y<span class="token keyword">switch</span> i <span class="token operator">:=</span> x<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token boolean">nil</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">" x 的类型～ : %T"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token builtin">int</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"x 是 int 型"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token builtin">float64</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"x 是 float64 型 "</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">float64</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"x 是 func(int) 型"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"x 是 bool 或 string 型"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"未知型"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.gox 是 float64 型 </code></pre><h3 id="switch课堂练习"><a href="#switch课堂练习" class="headerlink" title="switch课堂练习"></a>switch课堂练习</h3><ol><li>使用switch把小写类型的char型转为大写（键盘输入）。只转换a,b,c,d,e 其他的输出”other”。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> ch <span class="token builtin">byte</span>fmt<span class="token punctuation">.</span><span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span> <span class="token comment">//获取输入</span><span class="token comment">//fmt.Printf("%c",ch)</span><span class="token comment">//fmt.Println();</span><span class="token keyword">switch</span> ch <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'a'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'b'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'c'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'d'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token char">'e'</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"other"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li>对学生成绩大于60分的，输出“合格”。低于60分的，输出“不合格”。（注：输入的成绩不能大于100）</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> score <span class="token builtin">float64</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入成绩"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>score<span class="token punctuation">)</span><span class="token keyword">switch</span> <span class="token function">int</span><span class="token punctuation">(</span>score <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"及格"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"不及格"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"输入有误..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go请输入成绩86及格➜  main go run .&#x2F;main.go请输入成绩12不及格</code></pre><h3 id="switch和if的比较"><a href="#switch和if的比较" class="headerlink" title="switch和if的比较"></a>switch和if的比较</h3><p>总结了什么情况下使用switch，什么情况下使用if</p><ol><li>如果判断的具体数值不多，而且符合整数、浮点数、字符、字符串这几种类型。建议使用switch语句，简洁高效。</li><li>其他情况：对区间判断和结果为bool类型的判断，使用if，if的使用范围更广。</li></ol><h2 id="for循环控制"><a href="#for循环控制" class="headerlink" title="for循环控制"></a>for循环控制</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>听其名而知其意。这就是让我们的一段代码循环的执行。</p><h3 id="一个实际的需求"><a href="#一个实际的需求" class="headerlink" title="一个实际的需求"></a>一个实际的需求</h3><ul><li><p>案例：</p><p>编写一个程序，可以打印10句</p><p>“你好 Golang！”。想一想怎么做？</p><ul><li>使用传统的方式实现</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ul><li>for循环的快速入门</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好 Golang"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h3 id="for循环的基本语法"><a href="#for循环的基本语法" class="headerlink" title="for循环的基本语法"></a>for循环的基本语法</h3><ul><li><p>语法格式</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> 循环变量初始化；循环条件；循环变量迭代 <span class="token punctuation">&#123;</span>  循环操作（语句）<span class="token punctuation">&#125;</span></code></pre></li><li><p>对上面的语法格式说明</p><ul><li>对for循环来说，有四个要素：<ol><li>循环变量初始化</li><li>循环条件</li><li>循环操作（语句），有人也叫循环体</li><li>循环变量迭代</li></ol></li></ul></li><li><p>for循环执行的顺序说明：</p><ol><li>执行循环变量初始化，比如 <code>i:=1</code></li><li>执行循环条件，比如 <code>i &lt;= 10</code></li><li>如果循环条件为真，就执行循环操作：比如<code>fmt.Println(&quot;...&quot;)</code></li><li>执行循环变量迭代，比如 <code>i++</code></li><li>反复执行2， 3， 4步骤，直到 循环条件为False，就退出for循环。</li></ol></li></ul><h3 id="for循环执行流程分析"><a href="#for循环执行流程分析" class="headerlink" title="for循环执行流程分析"></a>for循环执行流程分析</h3><ul><li>for循环的流程图</li></ul><p><img src="http://cdn.leafii.top/img/20220520152530.png" loading="lazy"></p><ul><li>对照代码分析for循环的执行过程</li></ul><p><img src="http://cdn.leafii.top/img/20220520152543.png" loading="lazy"></p><h3 id="for循环的使用注意事项和细节讨论"><a href="#for循环的使用注意事项和细节讨论" class="headerlink" title="for循环的使用注意事项和细节讨论"></a>for循环的使用注意事项和细节讨论</h3><ol><li>循环条件是返回一个布尔值的表达式</li><li>for循环的第二种使用方式</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> 循环执行条件 <span class="token punctuation">&#123;</span>  <span class="token comment">//循环执行语句</span><span class="token punctuation">&#125;</span></code></pre><p>将变量初始化和变量迭代写到其他位置</p><ul><li>案例演示：</li></ul><p><img src="http://cdn.leafii.top/img/20220520152555.png" loading="lazy"></p><ol start="3"><li>for循环的第三种使用方式</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//循环执行语句</span><span class="token punctuation">&#125;</span></code></pre><p>上面的写法等价 <code>for ; ; &#123;&#125;</code> 是一个<strong>无限循环</strong>，通常需要<strong>配合break语句</strong>使用</p><p><img src="http://cdn.leafii.top/img/20220520152608.png" loading="lazy"></p><ol start="4"><li>Golang提供for-range的方式，可以方便遍历字符串和数组（注：数组的遍历，我们放到讲数组的时候再讲解），<strong>案例说明如何遍历字符串</strong>。</li></ol><ul><li>字符串遍历方式1-传统方式</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> str <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"hello,world"</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%c \n"</span><span class="token punctuation">,</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//使用到下标</span><span class="token punctuation">&#125;</span></code></pre><ul><li>字符串遍历方式2-for-range</li></ul><pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>str <span class="token operator">=</span> <span class="token string">"abc~ok"</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> val <span class="token operator">:=</span> <span class="token keyword">range</span> str <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"index=%d, val=%c \n"</span><span class="token punctuation">,</span>index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p>上面代码的细节讨论</p><p>如果我们的字符串含有中文，那么传统的遍历字符串方式就是错误的，会出现乱码。原因是传统的对字符串的遍历是按照<strong>字节来遍历</strong>，而一个汉字在utf8编码是对应3个字节。</p><p>如何解决？</p><p>​需要要将 str 转成 []rune切片。</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> str <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"hello,world!北京"</span>str2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment">// 就是把str转成[]rune</span><span class="token keyword">for</span> i <span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%c \n"</span><span class="token punctuation">,</span> str2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//使用到下标</span><span class="token punctuation">&#125;</span></code></pre><p>​对应for-range遍历方式而言，是按照字符方式遍历。因此如果有字符串有中文，也是ok的</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> str <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"abc~ok上海"</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> val <span class="token operator">:=</span> <span class="token keyword">range</span> str <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"index=%d, val=%c \n"</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>golang中还有一个<strong>byte</strong>数据类型与rune相似，它们都是用来表示字符类型的变量类型。它们的不同在于：</p><ul><li>byte 等同于int8，常用来处理ascii字符</li><li>rune 等同于int32,常用来处理unicode或utf-8字符</li></ul><h3 id="for循环的课堂练习"><a href="#for循环的课堂练习" class="headerlink" title="for循环的课堂练习"></a>for循环的课堂练习</h3><ol><li>打印1-100之间所有是9的倍数的整数的个数及总和。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> sum <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> i<span class="token operator">%</span><span class="token number">9</span><span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>sum <span class="token operator">+=</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d \n"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go0 9 18 27 36 45 54 63 72 81 90 99 sum &#x3D; 594 ➜  main </code></pre><ol start="2"><li>完成下面的表达式输出，6是可变的。</li></ol><p><img src="http://cdn.leafii.top/img/20220520152624.png" loading="lazy"></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> n <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"请输入参数:"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token keyword">var</span> m <span class="token builtin">int</span> <span class="token operator">=</span> n<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d \n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>m<span class="token punctuation">,</span><span class="token punctuation">(</span>i<span class="token operator">+</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>m<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go请输入参数:60 + 6 &#x3D; 6 1 + 5 &#x3D; 6 2 + 4 &#x3D; 6 3 + 3 &#x3D; 6 4 + 2 &#x3D; 6 5 + 1 &#x3D; 6 6 + 0 &#x3D; 6 ➜  main go run .&#x2F;main.go请输入参数:80 + 8 &#x3D; 8 1 + 7 &#x3D; 8 2 + 6 &#x3D; 8 3 + 5 &#x3D; 8 4 + 4 &#x3D; 8 5 + 3 &#x3D; 8 6 + 2 &#x3D; 8 7 + 1 &#x3D; 8 8 + 0 &#x3D; 8 </code></pre><h2 id="while和do-while的实现"><a href="#while和do-while的实现" class="headerlink" title="while和do..while的实现"></a>while和do..while的实现</h2><p>​Go语言没有while和do…while语法，这一点需要注意，如果我们需要使用类似的其他语言（java&#x2F;c的while和do…while)，<strong>可以通过for循环来实现其使用效果。</strong></p><h3 id="while循环的实现"><a href="#while循环的实现" class="headerlink" title="while循环的实现"></a>while循环的实现</h3><pre class="language-go" data-language="go"><code class="language-go">循环变量初始化<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> 循环条件表达式 <span class="token punctuation">&#123;</span>    <span class="token keyword">break</span> <span class="token comment">//跳出for循环..</span>  <span class="token punctuation">&#125;</span>  循环操作（语句）  循环变量迭代<span class="token punctuation">&#125;</span></code></pre><ul><li>说明<ol><li>for循环是一个无限循环</li><li>break语句就是跳出for循环</li></ol></li><li>使用上面的while实现完成输出10句“HelloWorld”</li></ul><pre class="language-go" data-language="go"><code class="language-go">i <span class="token operator">:=</span> <span class="token number">10</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"HelloWorld \n"</span><span class="token punctuation">)</span>  i<span class="token operator">--</span><span class="token punctuation">&#125;</span></code></pre><h3 id="do-while的实现"><a href="#do-while的实现" class="headerlink" title="do..while的实现"></a>do..while的实现</h3><pre class="language-go" data-language="go"><code class="language-go">循环变量初始化<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>  循环操作（语句）  循环变量迭代  <span class="token keyword">if</span> 循环条件表达式 <span class="token punctuation">&#123;</span>    <span class="token keyword">break</span> <span class="token comment">//跳出for循环..</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></code></pre><ul><li><p>说明</p><ol><li>上面的循环是先执行，再判断，因此至少执行一次。</li><li>当循环条件成立后，就会执行break，break就是跳出for循环，结束循环。</li></ol></li><li><p>案例演示</p><p>使用do..while实现10句“HelloWorldd”</p></li></ul><pre class="language-go" data-language="go"><code class="language-go">i <span class="token operator">:=</span> <span class="token number">10</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"HelloWorld \n"</span><span class="token punctuation">)</span>i<span class="token operator">--</span><span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="多重循环控制（重点，难点）"><a href="#多重循环控制（重点，难点）" class="headerlink" title="多重循环控制（重点，难点）"></a>多重循环控制（重点，难点）</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>将一个循环放在另一个循环体内，就形成了嵌套循环。在外边的 for 称为外层循环在里面的 for 循环称为内层循环。【建议一般使用两层，最多不要超过3层】</li><li>实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。</li><li>外层循环次数为 <strong>m</strong> 次，内层为 <strong>n</strong> 次，则内层循环体实际上需要执行 <strong>m*n</strong> 次</li></ol><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><ol><li>统计 3 个班成绩情况，每个班有 5 名同学，求出各个班的平均分和所有班级的平均分[学生的成绩从键盘输入]</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> classNum <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">var</span> stuNum <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">var</span> sum <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token keyword">var</span> score <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token keyword">var</span> totalsum <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> classNum<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> stuNum<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"请输入%d班级的 第%d个学生的成绩： \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>score<span class="token punctuation">)</span>sum <span class="token operator">+=</span> score<span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"第%d个班级的平均分为：%v \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> sum <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">)</span><span class="token punctuation">(</span>stuNum<span class="token punctuation">)</span><span class="token punctuation">)</span>totalsum <span class="token operator">+=</span> sum<span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"全体学生的平均分为: %v \n"</span><span class="token punctuation">,</span> totalsum <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>classNum<span class="token punctuation">)</span> <span class="token operator">*</span> stuNum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li>统计三个班及格人数，每个班有5名同学</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> classNum <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">var</span> stuNum <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">var</span> sum <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token keyword">var</span> score <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token keyword">var</span> totalsum <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> classNum<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">=</span> <span class="token number">0.0</span>topNum <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> stuNum<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"请输入%d班级的 第%d个学生的成绩： \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>score<span class="token punctuation">)</span><span class="token keyword">if</span> score <span class="token operator">>=</span> <span class="token number">60</span> <span class="token punctuation">&#123;</span>topNum<span class="token operator">++</span><span class="token punctuation">&#125;</span>sum <span class="token operator">+=</span> score<span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"第%d个班级的及格人数为%d, 平均分为：%v \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> topNum<span class="token punctuation">,</span> sum <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">)</span><span class="token punctuation">(</span>stuNum<span class="token punctuation">)</span><span class="token punctuation">)</span>totalsum <span class="token operator">+=</span> sum<span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"全体学生的平均分为: %v \n"</span><span class="token punctuation">,</span> totalsum <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>classNum<span class="token punctuation">)</span> <span class="token operator">*</span> stuNum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go请输入1班级的 第1个学生的成绩： 88请输入1班级的 第2个学生的成绩： 88请输入1班级的 第3个学生的成绩： 66请输入1班级的 第4个学生的成绩： 77请输入1班级的 第5个学生的成绩： 88第1个班级的平均分为：81.4 请输入2班级的 第1个学生的成绩： 请输入2班级的 第2个学生的成绩： 9请输入2班级的 第3个学生的成绩： 00请输入2班级的 第4个学生的成绩： 7请输入2班级的 第5个学生的成绩： 6➜  main go run .&#x2F;main.go请输入1班级的 第1个学生的成绩： 59请输入1班级的 第2个学生的成绩： 59请输入1班级的 第3个学生的成绩： 5请输入1班级的 第4个学生的成绩： 69请输入1班级的 第5个学生的成绩： 69第1个班级的及格人数为2, 平均分为：52.2 请输入2班级的 第1个学生的成绩： 99请输入2班级的 第2个学生的成绩： 99请输入2班级的 第3个学生的成绩： 99请输入2班级的 第4个学生的成绩： 99请输入2班级的 第5个学生的成绩： 99第2个班级的及格人数为5, 平均分为：99 请输入3班级的 第1个学生的成绩： 98请输入3班级的 第2个学生的成绩： 98请输入3班级的 第3个学生的成绩： 98请输入3班级的 第4个学生的成绩： 98请输入3班级的 第5个学生的成绩： 98第3个班级的及格人数为5, 平均分为：98 全体学生的平均分为: 83.06666666666666 </code></pre><ol start="3"><li>打印金字塔 【经典案例】</li></ol><p>使用for循环完成下面的案例：请编写一个程序，可以接受一个整数，表示层数，打印出金字塔。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token comment">/*     * ********   *******      **********/</span><span class="token keyword">var</span> n <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"请输入层数："</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> j <span class="token operator">:=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> k <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p><strong>有手就行</strong></p><pre class="language-none"><code class="language-none">请输入层数：3   *  *** *****➜  main go run .&#x2F;main.go请输入层数：5     *    ***   *****  ******* *********➜  main go run .&#x2F;main.go请输入层数：12            *           ***          *****         *******        *********       ***********      *************     ***************    *****************   *******************  ********************* ***********************➜  main </code></pre><ol start="4"><li>打印出九九乘法表</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d*%d=%d\t"</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">*</span> j<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">1*1&#x3D;11*2&#x3D;2   2*2&#x3D;41*3&#x3D;3   2*3&#x3D;6   3*3&#x3D;91*4&#x3D;4   2*4&#x3D;8   3*4&#x3D;12  4*4&#x3D;161*5&#x3D;5   2*5&#x3D;10  3*5&#x3D;15  4*5&#x3D;20  5*5&#x3D;251*6&#x3D;6   2*6&#x3D;12  3*6&#x3D;18  4*6&#x3D;24  5*6&#x3D;30  6*6&#x3D;361*7&#x3D;7   2*7&#x3D;14  3*7&#x3D;21  4*7&#x3D;28  5*7&#x3D;35  6*7&#x3D;42  7*7&#x3D;491*8&#x3D;8   2*8&#x3D;16  3*8&#x3D;24  4*8&#x3D;32  5*8&#x3D;40  6*8&#x3D;48  7*8&#x3D;56  8*8&#x3D;641*9&#x3D;9   2*9&#x3D;18  3*9&#x3D;27  4*9&#x3D;36  5*9&#x3D;45  6*9&#x3D;54  7*9&#x3D;63  8*9&#x3D;72  9*9&#x3D;81</code></pre><h2 id="跳转控制语句–break"><a href="#跳转控制语句–break" class="headerlink" title="跳转控制语句–break"></a>跳转控制语句–break</h2><h3 id="看一个具体需求，引出break"><a href="#看一个具体需求，引出break" class="headerlink" title="看一个具体需求，引出break"></a>看一个具体需求，引出break</h3><p>随机生成1-100的一个数，直到生成了99这个数，看看你一共用了几次？</p><ul><li><p>分析：</p><p>编写一个无限循环的控制，不停的生成随机数，当生成了99时，退出这个无限循环</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//如何生成随机数</span><span class="token comment">//在Go中需要生成一个随机种子，否则返回的值总是固定的。</span><span class="token comment">//time.Now().Unix():返回一个从1970.1.1 00:00:00到现在的秒数</span>rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">,</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><h3 id="break的快速入门案例"><a href="#break的快速入门案例" class="headerlink" title="break的快速入门案例"></a>break的快速入门案例</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> n <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">var</span> count <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0</span>rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">99</span><span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>count<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"生成99共进行了 %d 次"</span><span class="token punctuation">,</span>count<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ul><li>运行结果：</li></ul><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go生成99共进行了 26 次➜  main go run .&#x2F;main.go生成99共进行了 76 次➜  main go run .&#x2F;main.go生成99共进行了 15 次➜  main go run .&#x2F;main.go生成99共进行了 15 次➜  main go run .&#x2F;main.go生成99共进行了 25 次</code></pre><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​break语句用于终止某个语句块的执行，用于中断当前for循环或跳出switch语句。</p><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token punctuation">&#123;</span>  <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">.</span>  <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">.</span>  <span class="token keyword">break</span>  <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">.</span>  <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><h3 id="以for循环使用break为例，画出示意图"><a href="#以for循环使用break为例，画出示意图" class="headerlink" title="以for循环使用break为例，画出示意图"></a>以for循环使用break为例，画出示意图</h3><p><img src="http://cdn.leafii.top/img/20220520152638.png" loading="lazy"></p><h3 id="break的注意事项和使用细节"><a href="#break的注意事项和使用细节" class="headerlink" title="break的注意事项和使用细节"></a>break的注意事项和使用细节</h3><ol><li>break语句出现在多层嵌套的语句块中时，可以<strong>通过标签</strong>指明要终止的是哪一层语句块</li><li>案例：</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> i <span class="token builtin">int</span><span class="token keyword">var</span> j <span class="token builtin">int</span><span class="token keyword">var</span> k <span class="token builtin">int</span><span class="token comment">//lable2:</span><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>lable1<span class="token punctuation">:</span><span class="token keyword">for</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">122</span><span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">&#123;</span><span class="token comment">//break // break 默认会跳出最近的for循环</span><span class="token keyword">break</span> lable1<span class="token comment">//break lable2</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"i:%d j:%d k:%d \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>对上面案例的说明：<ol><li>break默认会跳出最近的for循环</li><li>break后面可以指定标签，跳出标签对应的for循环</li></ol></li></ol><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ol><li>100以内的数求和，求出 当和 第一次大于20的当前数</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> sum <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> i<span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">></span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"i:%d \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.goi:6 ➜  main </code></pre><ol start="2"><li>实现登录验证，有三次机会，如果用户名为“张无忌”，密码“888”提示登录成功，否则提示还有几次机会。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> username <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"张无忌"</span><span class="token keyword">var</span> loginname <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">var</span> loginpwd <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">var</span> pwd <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"888"</span><span class="token keyword">var</span> count <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">for</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> count <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"欢迎登陆，剩余的尝试登录次数错误次数：%d次 \n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"请输入用户名："</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>loginname<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"请输入密码："</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>loginpwd<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"已经无法继续登陆了！"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> loginname <span class="token operator">==</span> username <span class="token operator">&amp;&amp;</span> loginpwd <span class="token operator">==</span> pwd <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"登录成功！"</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>count<span class="token operator">--</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"密码输入错误，剩余尝试次数减一！\n"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go欢迎登陆，剩余的尝试登录次数错误次数：3次 请输入用户名：张三丰请输入密码：888密码输入错误，剩余尝试次数减一！欢迎登陆，剩余的尝试登录次数错误次数：2次 请输入用户名：张无忌请输入密码：888登录成功！</code></pre><h2 id="跳转控制语句-continue"><a href="#跳转控制语句-continue" class="headerlink" title="跳转控制语句-continue"></a>跳转控制语句-continue</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>continue语句用于结束本次循环，继续执行下一次循环。</li><li>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环，这个和前面的break标签的使用的规则一样。</li></ul><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token punctuation">&#123;</span>  <span class="token operator">...</span><span class="token operator">...</span>  <span class="token keyword">continue</span>  <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">&#125;</span></code></pre><h3 id="continue流程图"><a href="#continue流程图" class="headerlink" title="continue流程图"></a>continue流程图</h3><p><img src="http://cdn.leafii.top/img/20220520152656.png" loading="lazy"></p><h3 id="案例分析continue的使用"><a href="#案例分析continue的使用" class="headerlink" title="案例分析continue的使用"></a>案例分析continue的使用</h3><p><img src="http://cdn.leafii.top/img/20220520152710.png" loading="lazy"></p><h3 id="continue的课堂练习"><a href="#continue的课堂练习" class="headerlink" title="continue的课堂练习"></a>continue的课堂练习</h3><ul><li>continue实现：打印1到100之间的奇数（要求使用for循环+continue）</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> i<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 </code></pre><h2 id="跳转控制语句-goto"><a href="#跳转控制语句-goto" class="headerlink" title="跳转控制语句-goto"></a>跳转控制语句-goto</h2><h3 id="goto的基本介绍"><a href="#goto的基本介绍" class="headerlink" title="goto的基本介绍"></a>goto的基本介绍</h3><ol><li>Go语言的goto语句可以无条件地转移到程序中指定的行。</li><li>goto语句通常与条件语句配合使用。可用来实现条件转移，跳出循环体等功能。</li><li>在Go程序设计中一般不主张使用goto语句，以免造成程序流程的混乱，使理解和调试程序都产生困难</li></ol><h3 id="goto基本语法"><a href="#goto基本语法" class="headerlink" title="goto基本语法"></a>goto基本语法</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">goto</span> label <span class="token operator">...</span><span class="token operator">...</span>label<span class="token punctuation">:</span>statement</code></pre><h3 id="goto的流程图"><a href="#goto的流程图" class="headerlink" title="goto的流程图"></a>goto的流程图</h3><p><img src="http://cdn.leafii.top/img/20220520152325.png" loading="lazy"></p><h3 id="快速入门案例"><a href="#快速入门案例" class="headerlink" title="快速入门案例"></a>快速入门案例</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token keyword">var</span> n <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token comment">//演示goto的使用</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok1"</span><span class="token punctuation">)</span><span class="token keyword">if</span> n <span class="token operator">></span> <span class="token number">20</span> <span class="token punctuation">&#123;</span><span class="token keyword">goto</span> label1<span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok2"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok3"</span><span class="token punctuation">)</span>label1<span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok4"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok5"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok6"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok7"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.gook1ok4ok5ok6ok7</code></pre><h2 id="跳转控制语句-return"><a href="#跳转控制语句-return" class="headerlink" title="跳转控制语句-return"></a>跳转控制语句-return</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>return使用在方法或者函数中，表示跳出所在的方法或函数，在讲解函数的时候，会详细的介绍。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">3</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"哇哇"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-none"><code class="language-none">➜  main go run .&#x2F;main.go哇哇 1哇哇 2</code></pre><ul><li>说明<ol><li>如果return是在普通的函数，则表示跳出该函数，即不再执行函数中return后面代码，也可以理解成终止函数。</li><li>如果return是在main函数，表示终止main函数，也就是说终止程序。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言の运算符</title>
      <link href="/2021/01/09/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2021/01/09/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言の运算符"><a href="#Go语言の运算符" class="headerlink" title="Go语言の运算符"></a>Go语言の运算符</h1><p>本文介绍了Go语言的运算符</p><span id="more"></span><h2 id="运算符的基本介绍"><a href="#运算符的基本介绍" class="headerlink" title="运算符的基本介绍"></a>运算符的基本介绍</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等等</p><ol><li>算术运算符</li><li>赋值运算符</li><li>比较运算符&#x2F;关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>其他运算符</li></ol><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>算术运算符是对数值类型的变量进行运算的，比如：加减乘除。在Go程序中使用的非常多</p><h3 id="算术运算符的一览表"><a href="#算术运算符的一览表" class="headerlink" title="算术运算符的一览表"></a>算术运算符的一览表</h3><table><thead><tr><th>运算符</th><th>运算</th><th>范例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-4</td><td>-4</td></tr><tr><td>+</td><td>加</td><td>5+5</td><td>10</td></tr><tr><td>-</td><td>减</td><td>6-4</td><td>2</td></tr><tr><td>*</td><td>乘</td><td>3*4</td><td>12</td></tr><tr><td>&#x2F;</td><td>除</td><td>5&#x2F;5</td><td>1</td></tr><tr><td>%</td><td>取模（取余）</td><td>7%5</td><td>2</td></tr><tr><td>++</td><td>自增</td><td>a&#x3D;2 a++</td><td>a&#x3D;3</td></tr><tr><td>–</td><td>自减</td><td>a&#x3D;2 a–</td><td>a&#x3D;1</td></tr><tr><td>+</td><td>字符串相加</td><td>“He” + “llo”</td><td>“Hello”</td></tr></tbody></table><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><ul><li>案例：演示算术运算符的使用。</li></ul><p>+，-，*，&#x2F;，%，++，–，重点讲解&#x2F;、%</p><p>自增：++</p><p>自减：–</p><ul><li>演示&#x2F;的使用的特点</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//重点讲解 / 、%</span><span class="token comment">//说明：如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">var</span> n1 <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">4</span> <span class="token comment">//</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token comment">//如果我们希望保留小数部分，则需要有浮点数参与运算</span><span class="token keyword">var</span> n2 <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">10.0</span> <span class="token operator">/</span> <span class="token number">4</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p><strong>运行结果</strong></p><pre class="language-none"><code class="language-none">222.5</code></pre><ul><li>演示 % 的使用特点</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//演示 % 的使用</span><span class="token comment">// 看一个公式 a % b = a - a / b * b</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"10 % 3 ="</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">// =-1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"-10 % 3 = "</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// =-10-(-10)/3*3=-10-(-9)=-1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"10 % -3 = "</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token operator">%</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// =1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"-10 % -3 = "</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span> <span class="token operator">%</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">//=-1</span><span class="token punctuation">&#125;</span></code></pre><p><strong>运行结果</strong></p><pre class="language-none"><code class="language-none">10 % 3 &#x3D; 1-10 % 3 &#x3D;  -110 % -3 &#x3D;  1-10 % -3 &#x3D;  -1</code></pre><ul><li>++和–的使用</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//演示 ++ 和 -- 的使用</span><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>i<span class="token operator">++</span> <span class="token comment">//等价 i = i + 1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment">//11</span>i<span class="token operator">--</span> <span class="token comment">//等价 i = i - 1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment">// 10</span><span class="token punctuation">&#125;</span></code></pre><p><strong>运行结果</strong></p><pre class="language-none"><code class="language-none">i&#x3D; 11i&#x3D; 10</code></pre><h3 id="算术运算符使用的注意事项"><a href="#算术运算符使用的注意事项" class="headerlink" title="算术运算符使用的注意事项"></a>算术运算符使用的注意事项</h3><ol><li>对于除号”&#x2F;“，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。例如： x:&#x3D;19&#x2F;5, 结果是3</li><li>当对一个数取模时，可以等价 a%b&#x3D;a-a&#x2F;b*b, 这样我们可以看到 取模的一个本质运算。</li><li>Golang的自增自减只能当作一个独立语言使用时，不能这样使用：</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//在Golang中，++ 和 -- 只能独立使用</span><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token keyword">var</span> a <span class="token builtin">int</span>a <span class="token operator">=</span> i<span class="token operator">++</span> <span class="token comment">//错误 i++只能独立使用</span>a <span class="token operator">=</span> i<span class="token operator">--</span> <span class="token comment">//错误 i--只能独立使用</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>Golang的++和–只能写在变量的后面，不能写在变量的前面，即：只有a++,a–；没有++a,–a</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span>i<span class="token operator">++</span><span class="token operator">++</span>i <span class="token comment">//错误，在Golang没有 前++</span>i<span class="token operator">--</span><span class="token operator">--</span>i <span class="token comment">//错误，在Golang没有 前--</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></code></pre><ol start="5"><li>Golang的设计者去掉 c&#x2F;java 中的自增自减的容易混淆的写法，让Golang更加简洁，统一。（强制性的）</li></ol><h3 id="课堂练习1"><a href="#课堂练习1" class="headerlink" title="课堂练习1"></a>课堂练习1</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span>i <span class="token operator">=</span> i<span class="token operator">++</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">//问 结果是多少，为什么？</span><span class="token comment">//上面的代码报错，因为i=i++编译不通过</span></code></pre><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">if</span> i<span class="token operator">++</span> <span class="token operator">></span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token comment">//问 结果是多少，为什么？</span><span class="token comment">//上面的代码报错，因为i++ > 10编译不通过</span></code></pre><h3 id="课堂练习2"><a href="#课堂练习2" class="headerlink" title="课堂练习2"></a>课堂练习2</h3><ol><li>假如还有97天放假，问:97天相当于几个星期零几天?</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> day <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">97</span><span class="token keyword">var</span> week <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">97</span> <span class="token operator">/</span> <span class="token number">7</span><span class="token keyword">var</span> day <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">97</span> <span class="token operator">%</span> <span class="token number">7</span></code></pre><ul><li>解答</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> day <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">97</span><span class="token keyword">var</span> week <span class="token builtin">int</span> <span class="token operator">=</span> day <span class="token operator">/</span> <span class="token number">7</span><span class="token keyword">var</span> aday <span class="token builtin">int</span> <span class="token operator">=</span> day <span class="token operator">%</span> <span class="token number">7</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>week<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>aday<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/**打印结果：13    6 **/</span></code></pre><ol start="2"><li>定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为5&#x2F;9*(华氏温度-100),请求出华氏温度对应的摄氏温度。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> huashi <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">134.2</span><span class="token keyword">var</span> sheshi <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">5.0</span> <span class="token operator">/</span> <span class="token number">9</span> <span class="token operator">*</span> <span class="token punctuation">(</span>huashi <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v 对应的摄氏温度=%v\n"</span><span class="token punctuation">,</span> huashi<span class="token punctuation">,</span> sheshi<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/**134.2 对应的摄氏温度=19**/</span></code></pre><h2 id="关系运算符（比较运算符）"><a href="#关系运算符（比较运算符）" class="headerlink" title="关系运算符（比较运算符）"></a>关系运算符（比较运算符）</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>关系运算符的结果都是bool型，也就是 要么是true，要么是false</li><li>关系表达式常用于<strong>if结构</strong>的条件中或<strong>循环结构</strong>的条件中</li></ol><h3 id="关系运算符一览图"><a href="#关系运算符一览图" class="headerlink" title="关系运算符一览图"></a>关系运算符一览图</h3><table><thead><tr><th>运算符</th><th>运算</th><th>范例</th><th>结果</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>相等于</td><td>4&#x3D;&#x3D;3</td><td>false</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>4！&#x3D;3</td><td>true</td></tr><tr><td>&lt;</td><td>小于</td><td>4&lt;3</td><td>false</td></tr><tr><td>&gt;</td><td>大于</td><td>4&gt;3</td><td>true</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>4&lt;&#x3D;3</td><td>false</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>4&gt;&#x3D;3</td><td>true</td></tr></tbody></table><h3 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//演示关系运算符的使用</span>varn1int<span class="token operator">=</span><span class="token number">9</span>varn2int<span class="token operator">=</span><span class="token number">8</span>fmt<span class="token punctuation">.</span> <span class="token function">Println</span><span class="token punctuation">(</span>n1 <span class="token operator">==</span> n2<span class="token punctuation">)</span> <span class="token comment">//false</span>fmt<span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token function">Print1n</span><span class="token punctuation">(</span>n1 <span class="token operator">!=</span> n2<span class="token punctuation">)</span> <span class="token comment">//true</span>fmt <span class="token punctuation">.</span><span class="token function">Print1n</span><span class="token punctuation">(</span>n1 <span class="token operator">></span> n2<span class="token punctuation">)</span> <span class="token comment">//true</span>fmt<span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token function">Print1n</span><span class="token punctuation">(</span>n1 <span class="token operator">>=</span> n2<span class="token punctuation">)</span> <span class="token comment">//true</span>fmt <span class="token punctuation">.</span><span class="token function">Print1n</span><span class="token punctuation">(</span>n1 <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token comment">//flase</span>fmt <span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n1 <span class="token operator">&lt;=</span> n2<span class="token punctuation">)</span> <span class="token comment">//flase</span>flag<span class="token operator">:=</span>n1<span class="token operator">></span>n2fmt<span class="token punctuation">.</span> <span class="token function">Print1n</span><span class="token punctuation">(</span><span class="token string">" flag="</span><span class="token punctuation">,</span> f1ag<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span> </code></pre><h3 id="关系运算符的细节说明"><a href="#关系运算符的细节说明" class="headerlink" title="关系运算符的细节说明"></a>关系运算符的细节说明</h3><ol><li>关系运算符的结果都是bool型，也就是要么是true，要么是false。</li><li>关系运算符组成的表达式，我们称为关系表达式：a&gt;b</li><li>**比较运算符”&#x3D;&#x3D;”不能误写成”&#x3D;” **</li></ol><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>用于连接多个条件（一般来讲就是关系表达式），最终的结果也是一个bool值</p><h3 id="逻辑运算的说明"><a href="#逻辑运算的说明" class="headerlink" title="逻辑运算的说明"></a>逻辑运算的说明</h3><p><strong>假定A值为true，B值为false</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td><strong>逻辑与</strong>运算符。如果两边的操作数都是true，则为true，否则为false</td><td>（A&amp;&amp;B)为false</td></tr><tr><td>||</td><td><strong>逻辑或</strong>运算符。如果两边的操作数有一个true,则为true，否则为false。</td><td>（A||B）为true</td></tr><tr><td>！</td><td><strong>逻辑非</strong>运算符。如果条件为true，则逻辑为false，否则为true。</td><td>！(A&amp;&amp;B)为true</td></tr></tbody></table><h3 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//演示逻辑运算符的使用8&amp;</span><span class="token keyword">var</span> age <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">40</span><span class="token keyword">if</span> age <span class="token operator">></span><span class="token number">30</span><span class="token operator">&amp;&amp;</span> age <span class="token operator">&lt;</span> <span class="token number">50</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span> <span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok1"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> age <span class="token operator">></span><span class="token number">30</span><span class="token operator">&amp;&amp;</span> age <span class="token operator">&lt;</span> <span class="token number">40</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span> <span class="token function">Print1n</span><span class="token punctuation">(</span> <span class="token string">"ok2"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//演示逻辑运算符的使用</span><span class="token keyword">if</span> age<span class="token operator">></span>38Ilage<span class="token operator">&lt;</span>5e<span class="token punctuation">&#123;</span>fmt <span class="token punctuation">.</span> <span class="token function">PrintIn</span><span class="token punctuation">(</span> <span class="token string">"ok3"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> age<span class="token operator">></span><span class="token number">30</span><span class="token operator">|</span>age<span class="token operator">&lt;</span><span class="token number">40</span><span class="token punctuation">&#123;</span>fmt <span class="token punctuation">.</span> <span class="token function">Println</span><span class="token punctuation">(</span> <span class="token string">"ok4"</span> <span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//演示逻辑运算符的使用!</span><span class="token keyword">if</span> age<span class="token operator">></span><span class="token number">30</span><span class="token punctuation">&#123;</span>fmt <span class="token punctuation">.</span> <span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok5"</span> <span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token punctuation">(</span>age <span class="token operator">></span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span> <span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ok6"</span> <span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h3 id="注意事项和细节说明"><a href="#注意事项和细节说明" class="headerlink" title="注意事项和细节说明"></a>注意事项和细节说明</h3><ol><li><p>&amp;&amp;也叫<strong>短路与</strong>：如果<strong>第一个条件为false</strong>，则第二个条件不会判断，最终结果为<strong>false</strong></p></li><li><p>||也叫<strong>短路或</strong>：如果<strong>第一个条件为true</strong>，则第二个条件不会判断，最终结果为<strong>true</strong></p></li><li><p>案例演示</p></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//声明一个函数(测试)</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span> <span class="token string">"test..."</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span><span class="token number">10</span><span class="token comment">//短路与</span><span class="token comment">//说明因为i &lt; 9为false ,因此后面的test() 就不执行</span><span class="token keyword">if</span> i<span class="token operator">&lt;</span><span class="token number">9</span> <span class="token operator">&amp;&amp;</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span> <span class="token function">Println</span><span class="token punctuation">(</span> <span class="token string">"ok.."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//说明 因为 i > 9为true ,因此后面的test() 就不执行</span><span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">9</span> <span class="token operator">||</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span> <span class="token function">Print1n</span><span class="token punctuation">(</span> <span class="token string">"hello..."</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><h3 id="基本的介绍"><a href="#基本的介绍" class="headerlink" title="基本的介绍"></a>基本的介绍</h3><p>赋值运算符就是将某个运算后的值，赋给指定的变量。</p><h3 id="赋值运算符的分类"><a href="#赋值运算符的分类" class="headerlink" title="赋值运算符的分类"></a>赋值运算符的分类</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td><td>C&#x3D;A+B将A+B表达式结果赋值给C</td></tr><tr><td>+&#x3D;</td><td>相加后再赋值</td><td>C+&#x3D;A 等于 C&#x3D;C+A</td></tr><tr><td>-&#x3D;</td><td>相减后再赋值</td><td>C-&#x3D;A 等于 C&#x3D;C-A</td></tr><tr><td>*&#x3D;</td><td>相乘后再赋值</td><td>C*&#x3D;A 等于 C&#x3D;C*A</td></tr><tr><td>&#x2F;&#x3D;</td><td>相除后再赋值</td><td>C&#x2F;&#x3D;A 等于 C&#x3D;C&#x2F;A</td></tr><tr><td>%&#x3D;</td><td>求余后再赋值</td><td>C%&#x3D;A 等于 C&#x3D;C%A</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>左移后赋值</td><td>C&lt;&lt;&#x3D;2 等于 C&#x3D;C&lt;&lt;2</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>右移后赋值</td><td>C&gt;&gt;&#x3D;2 等于 C&#x3D;C&gt;&gt;2</td></tr><tr><td>&amp;&#x3D;</td><td>按位与后赋值</td><td>C&amp;&#x3D;2 等于 C&#x3D;C&amp;2</td></tr><tr><td>^&#x3D;</td><td>按位异或后赋值</td><td>C^&#x3D;2 等于 C&#x3D;C^2</td></tr><tr><td>|&#x3D;</td><td>按位或后赋值</td><td>C|&#x3D;2 等于 C&#x3D;C|2</td></tr></tbody></table><p>**说明:**后半部分的赋值运算涉及到二进制相关知识哦！</p><h3 id="赋值运算的案例演示"><a href="#赋值运算的案例演示" class="headerlink" title="赋值运算的案例演示"></a>赋值运算的案例演示</h3><ol><li>赋值基本案例</li><li>有两个变量，a和b，要求将其进行交换，最终打印结果</li><li>+&#x3D;的使用案例</li><li>案例</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//赋值运算符的使用演示</span>    <span class="token comment">//var i int</span>    <span class="token comment">// i = 10 // 基本赋值</span>        <span class="token comment">//有两个变量，a和b，要求将其进行交换，最终打印结果</span>    <span class="token comment">// a = 9, b = 2 ==> a = 2 , b = 9</span>    a <span class="token operator">:=</span> <span class="token number">9</span>    b <span class="token operator">:=</span> <span class="token number">2</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"交换前的情况： a = %v, b = %v\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>    <span class="token comment">//定义一个临时变量</span>    t <span class="token operator">:=</span> a    a <span class="token operator">=</span> b    b <span class="token operator">=</span> t    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"交换后的情况: a = %v, b = %v\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>        <span class="token comment">//复合赋值的操作</span>    a <span class="token operator">+=</span> <span class="token number">17</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"a+=17 --> a = a + 17 = %v"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h3 id="赋值运算符的特点"><a href="#赋值运算符的特点" class="headerlink" title="赋值运算符的特点"></a>赋值运算符的特点</h3><ol><li>运算顺序从右往左</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> c <span class="token builtin">int</span>c <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">3</span> <span class="token comment">// 赋值运算的执行顺序是从右向左</span></code></pre><ol start="2"><li>赋值运算符的左边 只能是变量，右边可以是变量，表达式，常量值！</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//赋值运算符的左边 只能是变量，右边可以是变量，表达式，常量值！</span><span class="token comment">//表达式:任何有值的都可以看做是表达式</span><span class="token keyword">var</span> d <span class="token builtin">int</span>d <span class="token operator">=</span> a <span class="token comment">//</span>d <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">8</span> <span class="token comment">// =的右边是表达式</span>d <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">90</span> <span class="token comment">// =的右边是表达式</span>d <span class="token operator">=</span> <span class="token number">890</span> <span class="token comment">//890常量</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></code></pre><ol start="3"><li>复合赋值运算符等价于下面的效果</li></ol><p>a +&#x3D; 3  &lt;&#x3D;&#x3D;&gt; a &#x3D; a + 3</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>有两个变量，a和b，要求将其进行交换，但是不允许使用中间变量，最终打印结果</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">9</span><span class="token keyword">var</span> b <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>a <span class="token operator">=</span> a <span class="token operator">+</span> b    b <span class="token operator">=</span> a <span class="token operator">-</span> b   <span class="token comment">//    = a+b-b = a</span>a <span class="token operator">=</span> a <span class="token operator">-</span> b   <span class="token comment">//    = a+b-a = b</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"a = %v b = %v "</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></code></pre><p>牛牛牛！</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符”&amp;”是双目运算符。其功能是参与运算的两数各对应的二进位相与。运算规则是:同时为1，结果为1,否则为0</td></tr><tr><td>|</td><td>按位或运算符川”是双目运算符。其功能是参 与运算的两数各对应的二进位相或.运算规则是:同时为1，结果为1,否则为0</td></tr><tr><td>^</td><td>按位异或运算符”是双目运算符。其功能是参与运算的两数各对应的二进位相异或。运算规则是:当二进位不同时，结果为1,否则为0</td></tr><tr><td>&lt;&lt;</td><td>左移运算符&lt;&lt;”是双目运算符。其功能把&lt;&lt;”左边的运算数的各二进位全部左移若干位，高位丢弃，低位补0。左移n位就是乘以2的n次方。</td></tr><tr><td>&gt;&gt;</td><td>右移运算符&gt;&gt;”是双目运算符。其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，右移n位就是除以2的n次方</td></tr></tbody></table><h2 id="其他运算符说明"><a href="#其他运算符说明" class="headerlink" title="其他运算符说明"></a>其他运算符说明</h2><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>返回变量存储地址</td><td>&amp;a;将给出变量a的实际地址</td></tr><tr><td>*</td><td>指针变量</td><td>*a;是一个指针变量</td></tr></tbody></table><p>举例说明：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//演示一下 &amp; 和 * 的使用</span>    a <span class="token operator">:=</span> <span class="token number">100</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"a的地址="</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span>        <span class="token keyword">var</span> ptr <span class="token operator">*</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ptr指向的值是:"</span> ，<span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h3 id="课堂案例"><a href="#课堂案例" class="headerlink" title="课堂案例"></a>课堂案例</h3><ul><li>案例1：求两个数的最大值</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//求两个数的最大值</span>    <span class="token keyword">var</span> n1 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">var</span> n2 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">40</span>    <span class="token keyword">var</span> max <span class="token builtin">int</span>    <span class="token keyword">if</span> n1 <span class="token operator">></span> n2<span class="token punctuation">&#123;</span>        max <span class="token operator">=</span> n1    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        max <span class="token operator">=</span> n2    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"max="</span><span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ul><li>案例2：求三个数的最大值</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//求两个数的最大值</span>    <span class="token keyword">var</span> n1 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">var</span> n2 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">40</span>    <span class="token keyword">var</span> max <span class="token builtin">int</span>    <span class="token keyword">if</span> n1 <span class="token operator">></span> n2<span class="token punctuation">&#123;</span>        max <span class="token operator">=</span> n1    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        max <span class="token operator">=</span> n2    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"max="</span><span class="token punctuation">,</span>max<span class="token punctuation">)</span>    <span class="token comment">//求三个数的最大值思路：先求两个数的最大值，再用第三个数与最大值相比，取较大的数。</span>    <span class="token keyword">var</span> n3 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">45</span>    <span class="token keyword">if</span> n3 <span class="token operator">></span> max <span class="token punctuation">&#123;</span>        max <span class="token operator">=</span> n3    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"三个书中最大值是="</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><p>Go语言明确不支持三元运算符，官方<a href="https://golang.org/doc/faq#Does_Go_have_a_ternary_form">说明</a></p><p><img src="http://cdn.leafii.top/img/20220520154005.png" loading="lazy"></p><p>演示在Go语言中实现三元运算符的效果：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> n <span class="token builtin">int</span><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">var</span> j <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token comment">//传统的三元运算</span><span class="token comment">//n = i > j ? i : j</span><span class="token keyword">if</span> i <span class="token operator">></span> j <span class="token punctuation">&#123;</span>    n <span class="token operator">=</span> i<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    n <span class="token operator">=</span> j<span class="token punctuation">&#125;</span><span class="token keyword">return</span> n <span class="token comment">//12</span></code></pre><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><h3 id="运算符的优先级的一览表"><a href="#运算符的优先级的一览表" class="headerlink" title="运算符的优先级的一览表"></a>运算符的优先级的一览表</h3><p><img src="http://cdn.leafii.top/img/20220520154022.png" loading="lazy"></p><h3 id="对上图的说明"><a href="#对上图的说明" class="headerlink" title="对上图的说明"></a>对上图的说明</h3><ol><li>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。</li><li>只有单目运算符、赋值运算符是从右向左运算的。</li><li>梳理一个大概的优先级：<ol><li>括号，++，–</li><li>单目运算</li><li>算术运算符</li><li>移位运算</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>逗号</li></ol></li></ol><h2 id="键盘输入语句"><a href="#键盘输入语句" class="headerlink" title="键盘输入语句"></a>键盘输入语句</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。InputDemo.go</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>导入fmt包</li><li>调用fmt包的fmt.Scanln()或者fmt.Scanf()</li></ol><p><img src="http://cdn.leafii.top/img/20220520154040.png" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/20220520154058.png" loading="lazy"></p><h3 id="案例演示-3"><a href="#案例演示-3" class="headerlink" title="案例演示"></a>案例演示</h3><ul><li>要求：可以从控制台接收用户信息，【姓名，年龄，薪水，是否通过考试】</li></ul><ol><li>使用fmt.Scanln()获取</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//要求：可以从控制台接收用户信息，</span><span class="token comment">//【姓名，年龄，薪水，是否通过考试】</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//1. 先声明需要的变量</span><span class="token keyword">var</span> name <span class="token builtin">string</span><span class="token keyword">var</span> age <span class="token builtin">byte</span><span class="token keyword">var</span> sal <span class="token builtin">float32</span><span class="token keyword">var</span> isPass <span class="token builtin">bool</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入姓名"</span><span class="token punctuation">)</span><span class="token comment">//当程序执行到 fmt.Scanln(&amp;name),程序会停止在这里，等待用户输入，并回车</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>name<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入年龄"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>age<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入薪水"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sal<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入是否通过考试"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>isPass<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"名字是 %v \n年龄是 %v \n薪水是 %v \n是否通过考试 %v\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> sal<span class="token punctuation">,</span> isPass<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果</p><pre class="language-none"><code class="language-none">请输入姓名leafii请输入年龄23请输入薪水60000请输入是否通过考试true名字是 leafii年龄是 23薪水是 60000是否通过考试 true</code></pre><ol start="2"><li>使用fmt.Scanf()获取</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//要求：可以从控制台接收用户信息，</span><span class="token comment">//【姓名，年龄，薪水，是否通过考试】</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//1. 先声明需要的变量</span><span class="token keyword">var</span> name <span class="token builtin">string</span><span class="token keyword">var</span> age <span class="token builtin">byte</span><span class="token keyword">var</span> sal <span class="token builtin">float32</span><span class="token keyword">var</span> isPass <span class="token builtin">bool</span><span class="token comment">//方式2：fmt.Scanf，可以按指定的格式输入</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"请输入你的姓名，年龄，薪水，是否通过考试，使用空格隔开"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token string">"%s %d %f %t"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>age<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>isPass<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"名字是 %v \n年龄是 %v \n薪水是 %v \n是否通过考试 %v\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> sal<span class="token punctuation">,</span> isPass<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">请输入你的姓名，年龄，薪水，是否通过考试，使用空格隔开leafii 23 60000 true名字是 leafii年龄是 23薪水是 60000是否通过考试 true</code></pre><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>对于整数，有四种表示方式：</p><ul><li>二进制：0，1，满2进1。在Golang中，不能直接使用二进制来表示一个整数，它沿用了c的特点</li><li>十进制：0-9，满10进1.</li><li>八进制：0-7，满8进1.以数字0开头表示。</li><li>十六进制：0-9及A-F，满16进1。以0x 或0X开头表示。（A到F不区分大小写）</li></ul><h3 id="进制的图示"><a href="#进制的图示" class="headerlink" title="进制的图示"></a>进制的图示</h3><table><thead><tr><th>十进制</th><th>十六进制</th><th>八进制</th><th>二进制</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td><td>2</td><td>10</td></tr><tr><td>3</td><td>3</td><td>3</td><td>11</td></tr><tr><td>4</td><td>4</td><td>4</td><td>100</td></tr><tr><td>5</td><td>5</td><td>5</td><td>101</td></tr><tr><td>6</td><td>6</td><td>6</td><td>110</td></tr><tr><td>7</td><td>7</td><td>7</td><td>111</td></tr><tr><td>8</td><td>8</td><td>10</td><td>1000</td></tr><tr><td>9</td><td>9</td><td>11</td><td>1001</td></tr><tr><td>10</td><td>A</td><td>12</td><td>1010</td></tr><tr><td>11</td><td>B</td><td>13</td><td>1011</td></tr><tr><td>12</td><td>C</td><td>14</td><td>1100</td></tr><tr><td>13</td><td>D</td><td>15</td><td>1101</td></tr><tr><td>14</td><td>E</td><td>16</td><td>1110</td></tr><tr><td>15</td><td>F</td><td>17</td><td>1111</td></tr><tr><td>16</td><td>10</td><td>20</td><td>10000</td></tr><tr><td>17</td><td>11</td><td>21</td><td>10001</td></tr></tbody></table><h3 id="进制转换的介绍"><a href="#进制转换的介绍" class="headerlink" title="进制转换的介绍"></a>进制转换的介绍</h3><p>总览:</p><p><img src="http://cdn.leafii.top/img/20220520154112.png" loading="lazy"></p><h3 id="其他进制转十进制"><a href="#其他进制转十进制" class="headerlink" title="其他进制转十进制"></a>其他进制转十进制</h3><p><img src="http://cdn.leafii.top/img/20220520154125.png" loading="lazy"></p><h3 id="二进制如何转十进制"><a href="#二进制如何转十进制" class="headerlink" title="二进制如何转十进制"></a>二进制如何转十进制</h3><p>134 &#x3D; 4 * 1 + 3 * 10 + 10 * 10 &#x3D; 4 + 30 + 100 &#x3D; 134</p><ul><li><p><strong>规则：</strong>从最低位开始（右边），将每个位上的数提取出来，乘以2的（位数-1）次方然后<strong>求和</strong>。</p></li><li><p>案例： 请将二进制：1011转成十进制的数</p></li></ul><p>1011 &#x3D; 1 * 1 + 1 * 2 + 0 * 2  * 2 + 1 * 2 * 2 * 2 &#x3D; 1 + 2 + 0 + 8 &#x3D; 11</p><h3 id="八进制转换成十进制实例"><a href="#八进制转换成十进制实例" class="headerlink" title="八进制转换成十进制实例"></a>八进制转换成十进制实例</h3><ul><li><p><strong>规则：</strong>从最低位开始（右边），将每个位上的数提取出来，乘以8的（位数-1）次方然后<strong>求和</strong>。</p></li><li><p>案例:请将0123转成十进制的数</p></li></ul><p>0123 &#x3D; 3 * 1 + 2 * 8 + 1 * 8 * 8 + 0 * 8 * 8 * 8 &#x3D; 3 + 16 + 64 &#x3D; 83</p><h3 id="十六进制转成十进制"><a href="#十六进制转成十进制" class="headerlink" title="十六进制转成十进制"></a>十六进制转成十进制</h3><ul><li><p><strong>规则：</strong>从最低位开始（右边），将每个位上的数提取出来，乘以16的（位数-1）次方然后<strong>求和</strong>。</p></li><li><p>案例：请将0x34A转成十进制的数</p></li></ul><p>0x34A &#x3D; 10 * 1 + 4 * 16 + 3 * 16 * 16 &#x3D; 10 + 64 + 768 &#x3D; 842</p><h3 id="其他进制转成10进制的课堂练习"><a href="#其他进制转成10进制的课堂练习" class="headerlink" title="其他进制转成10进制的课堂练习"></a>其他进制转成10进制的课堂练习</h3><ul><li><p>课堂练习: 请将</p><ul><li>二进制： 110001100 转成十进制</li></ul><p>110001100(2) &#x3D;1 * 2 <sup>2</sup>+ 1 * 2 <sup>3</sup> + 1 * 2<sup>7</sup> + 1 * 2<sup>8</sup> &#x3D; 396</p><ul><li>八进制： 02456 转成十进制</li></ul><p>02456(8) &#x3D; 6 * 1 + 5 * 8 + 4 * 8<sup>2</sup> + 2 * 8<sup>3</sup> &#x3D;  1326 </p><ul><li>十六进制： 0xA45 转成十进制</li></ul><p>0xA45 (16) &#x3D;  5 * 1 + 4 * 16 + 10 * 16<sup>2</sup> &#x3D; 2629</p></li></ul><h3 id="十进制如何转成其他进制"><a href="#十进制如何转成其他进制" class="headerlink" title="十进制如何转成其他进制"></a>十进制如何转成其他进制</h3><p><img src="http://cdn.leafii.top/img/20220520154336.png" loading="lazy"></p><h3 id="十进制如何转二进制"><a href="#十进制如何转二进制" class="headerlink" title="十进制如何转二进制"></a>十进制如何转二进制</h3><p><img src="http://cdn.leafii.top/img/20220520154356.png" loading="lazy"></p><h3 id="十进制转成八进制"><a href="#十进制转成八进制" class="headerlink" title="十进制转成八进制"></a>十进制转成八进制</h3><p><img src="http://cdn.leafii.top/img/20220520154409.png" loading="lazy"></p><h3 id="十进制转十六进制"><a href="#十进制转十六进制" class="headerlink" title="十进制转十六进制"></a>十进制转十六进制</h3><p><img src="http://cdn.leafii.top/img/20220520154423.png" loading="lazy"></p><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ul><li><p>请将</p><ul><li>123 转成二进制</li></ul><p>123（10） &#x3D;   1111011 (2)</p><ul><li>678转成八进制</li></ul><p>678(10) &#x3D; 1246(8)</p><ul><li>8912 转成十六进制</li></ul><p>8912(10) &#x3D; 22D0(16)</p></li></ul><h3 id="二进制如何转成八进制、十六进制"><a href="#二进制如何转成八进制、十六进制" class="headerlink" title="二进制如何转成八进制、十六进制"></a>二进制如何转成八进制、十六进制</h3><p><img src="http://cdn.leafii.top/img/20220520154440.png" loading="lazy"></p><h3 id="二进制转换成八进制"><a href="#二进制转换成八进制" class="headerlink" title="二进制转换成八进制"></a>二进制转换成八进制</h3><ul><li><p>**规则:**将二进制数每三位一组(从低位开始组合),转成对应的八进制数即可。</p></li><li><p>案例:请将二进制: 11010101 转成八进制<br>11010101&#x3D; 0325</p></li></ul><h3 id="二进制转成十六进制"><a href="#二进制转成十六进制" class="headerlink" title="二进制转成十六进制"></a>二进制转成十六进制</h3><ul><li><p>**规则:**将二进制数每四位一组(从低位开始组合),转成对应的十六进制数即可。</p></li><li><p>案例:请将二进制: 11010101 转成十六进制</p><p>11010101 &#x3D; 0xD5</p></li><li><p>课堂练习：请将</p><ul><li>二进制：11100101 转成 八进制</li><li>二进制： 1110010110 转成 十六进制</li></ul></li></ul><h3 id="八进制、十六进制转成二进制"><a href="#八进制、十六进制转成二进制" class="headerlink" title="八进制、十六进制转成二进制"></a>八进制、十六进制转成二进制</h3><p><img src="http://cdn.leafii.top/img/20220520154455.png" loading="lazy"></p><h3 id="八进制转成二进制"><a href="#八进制转成二进制" class="headerlink" title="八进制转成二进制"></a>八进制转成二进制</h3><ul><li><p><strong>规则：</strong>将八进制数每一位，转成对应的一个3位的二进制数即可。</p></li><li><p>案例：请将0237转换成二进制</p><p>0237（8） &#x3D; 10011111（2）</p></li></ul><h3 id="十六进制转成二进制"><a href="#十六进制转成二进制" class="headerlink" title="十六进制转成二进制"></a>十六进制转成二进制</h3><ul><li><p><strong>规则：将十六进制数每一位，转成对应的一个4位的二进制数即可。</strong></p></li><li><p>案例：请将0x237转成二进制</p><p>0x237(16) &#x3D; 1000110111(2)</p></li></ul><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="位运算的思考题"><a href="#位运算的思考题" class="headerlink" title="位运算的思考题"></a>位运算的思考题</h3><ol><li>请看下面的代码段，回答a,b,c,d结果是多少？</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">>></span> <span class="token number">2</span>    <span class="token keyword">var</span> b <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">>></span> <span class="token number">2</span>    <span class="token keyword">var</span> c <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span>    <span class="token keyword">var</span> d <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span>    <span class="token comment">//a b c d结果是多少？</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"a="</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"b="</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"c="</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"d="</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/*a= 0b= -1c= 4d= -4*/</span></code></pre><ol start="2"><li>请回答在Golang中，下面的表达式运算的结果是：</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">3</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token operator">&amp;</span><span class="token number">7</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/**235-2*/</span></code></pre><h3 id="二进制在运算中的说明"><a href="#二进制在运算中的说明" class="headerlink" title="二进制在运算中的说明"></a>二进制在运算中的说明</h3><p>二进制是逢2进位的进位制，0、1是基本算符。</p><p>现代的电子计算机技术全部采用的是二进制，因为它只使用0、1两个数学符号，非常简单方便，易于用电子方式实现。计算机内部处理的信息，都是采用二进制数来表示的。二进制（Binary）数用0和1两个数字及其组合来表示任何数。进位规则是“逢2进1“，数字1在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增。</p><p>在计算机的内部，运行各种运算时，都是以二进制的方式来运行。</p><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><p><img src="http://cdn.leafii.top/img/20220520154512.png" loading="lazy"></p><h3 id="位运算符和移位运算符"><a href="#位运算符和移位运算符" class="headerlink" title="位运算符和移位运算符"></a>位运算符和移位运算符</h3><ul><li>Golang有3个位运算<ul><li>按位与&amp;    ：    两位全为1，结果为1，否则为0</li><li>按位或|    ：    两位有一个为1，结果为1，否则为0</li><li>按位异或^    ：    两位一个为0，一个为1，结果为1，否则为0</li></ul></li><li>案例练习</li></ul><p>2&amp;3&#x3D;?  2|3&#x3D;?  2^3&#x3D;?</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//2&amp;3=?  2|3=?  2^3=?</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//2</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//3</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//3</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">//-4</span><span class="token punctuation">&#125;</span></code></pre><p><img src="http://cdn.leafii.top/img/20220520154525.png" loading="lazy"></p><ul><li><p>Golang中有两个移位运算符：</p><ul><li>右移运算符   &gt;&gt;:    低位溢出，符号位不变，并用符号位补溢出的高位</li><li>左移运算符    &lt;&lt;:    符号位不变，低位补0</li></ul></li><li><p>案例演示</p><p>a :&#x3D; 1 &gt;&gt; 2   &#x2F;&#x2F;  0000 0001 &#x3D;&gt; 0000 0000  &#x3D; 0</p><p>c :&#x3D; 1 &lt;&lt; 2 &#x2F;&#x2F; 0000 0001 &#x3D;&#x3D;&gt; 0000 0100 &#x3D;&gt; 4</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法》（第四版）环境搭建</title>
      <link href="/2021/01/07/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/01/07/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="《算法》（第四版）环境搭建"><a href="#《算法》（第四版）环境搭建" class="headerlink" title="《算法》（第四版）环境搭建"></a>《算法》（第四版）环境搭建</h1><p>最近开封了买了很久都没读的《算法》（红色封面的），如果想运行里面的代码需要安装一个与本书搭配的jar包，因此有了这篇博客。</p><span id="more"></span><h2 id="算法运行库的下载和配置"><a href="#算法运行库的下载和配置" class="headerlink" title="算法运行库的下载和配置"></a>算法运行库的下载和配置</h2><ol><li><p>下载作者提供的运行库，下载地址：<a href="http://algs4.cs.princeton.edu/code/">点我</a> 点开页面之后使劲往下翻，翻到下图位置时，就知道点哪个下载了 嘿嘿嘿嘿</p><p><img src="http://cdn.leafii.top/img/20220520154626.png" loading="lazy"></p></li></ol><p><strong>我们需要下载两个内容，一个是库，一个是测试的数据。库是algs4.jar，数据是algs4-data.zip。</strong></p><ol start="2"><li>在C盘建立目录<code>C:\Program Files\algs4</code>，然后把algs4.jar放在里面。（什么目录都可以）</li><li>在CLASSPATH环境变量中，添加值<code>C:\Program Files\algs4\algs4.jar</code> (就是刚刚存放algs4.jar的路径)</li></ol><p><strong>注:如果你没有配置过CLASSPATH，请复制以下语句进CLASSPATH，使你的CLASSPATH变成这样</strong></p><pre class="language-none"><code class="language-none">.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;C:\Users\yeyun\alsgs4\algs4.jar</code></pre><h2 id="测试数据的使用"><a href="#测试数据的使用" class="headerlink" title="测试数据的使用"></a>测试数据的使用</h2><ol><li>在idea中创建一个HelloWorld工程，选择你的JDK，下一步。</li><li>为项目添加jar包：File–&gt;Project Strcuture–&gt;Modules，然后点加号，点击，JARS…..,选择你的Jar包的位置，点确定。如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/20220520154641.png" loading="lazy"></p><ol start="3"><li>将测试数据解压到src目录下：</li></ol><p><img src="http://cdn.leafii.top/img/20220520154656.png" loading="lazy"></p><ol start="4"><li>使用第一章第一节的测试代码：</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">top<span class="token punctuation">.</span>leafii<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>day01</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">edu<span class="token punctuation">.</span>princeton<span class="token punctuation">.</span>cs<span class="token punctuation">.</span>algs4<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySearch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">BinarySearch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> lo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hi <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>lo <span class="token operator">&lt;=</span> hi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Key is in a[lo..hi] or not present.</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span>      <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> hi <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">rank</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// read the integers from a file</span>        <span class="token class-name">In</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">In</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> whitelist <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readAllInts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// sort the array</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>whitelist<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// read integer key from standard input; print if not in whitelist</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StdIn</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> key <span class="token operator">=</span> <span class="token class-name">StdIn</span><span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">BinarySearch</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>whitelist<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token class-name">StdOut</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="5"><li>在BinarySearch类所在的文件夹右键，选择open in terminal，输入编译命令:<code>javac BinarySearch.java</code></li><li>在src文件夹上右键，点击open in terminal</li></ol><p><img src="http://cdn.leafii.top/img/20220520154710.png" loading="lazy"></p><ol start="6"><li>在命令行中输入命令：<code>java top.leafii.demo.day01.BinarySearch tinyW.txt &lt; tinyT.txt</code>（注意你的包名）</li><li>成功了！运行结果如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/20220520154724.png" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java命令报错 找不到或无法加载主类这件事</title>
      <link href="/2021/01/07/%E5%85%B3%E4%BA%8Ejava%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99-%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%96%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BB%E8%BF%99%E4%BB%B6%E4%BA%8B/"/>
      <url>/2021/01/07/%E5%85%B3%E4%BA%8Ejava%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99-%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%96%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BB%E8%BF%99%E4%BB%B6%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="关于java命令报错-找不到或无法加载主类这件事"><a href="#关于java命令报错-找不到或无法加载主类这件事" class="headerlink" title="关于java命令报错 找不到或无法加载主类这件事"></a>关于java命令报错 找不到或无法加载主类这件事</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天在配置《算法》（第四版）所需要的环境后，进行java命令+输入输出流文件时报错了！报错如图所示：</p><p><img src="http://cdn.leafii.top/img/20220520154754.png" loading="lazy"></p><p>咋回事呢？</p><span id="more"></span><h2 id="或许，是因为没有写包名？"><a href="#或许，是因为没有写包名？" class="headerlink" title="或许，是因为没有写包名？"></a>或许，是因为没有写包名？</h2><p><img src="http://cdn.leafii.top/img/20220520154808.png" loading="lazy"></p><p>还是不行!!!咋回事呢？</p><h2 id="写个HelloWorld试试？可能是java命令出问题了？"><a href="#写个HelloWorld试试？可能是java命令出问题了？" class="headerlink" title="写个HelloWorld试试？可能是java命令出问题了？"></a>写个HelloWorld试试？可能是java命令出问题了？</h2><p>在D盘根目录写一个Hello.java，代码如下（其实就是Helloworld啦）</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>然而运行的时候…</p><p><img src="http://cdn.leafii.top/img/20220520154822.png" loading="lazy"></p><p>？？？？？？怎么回事呢？</p><h2 id="用家里的Mac的终端试试能不能写Java代码"><a href="#用家里的Mac的终端试试能不能写Java代码" class="headerlink" title="用家里的Mac的终端试试能不能写Java代码"></a>用家里的Mac的终端试试能不能写Java代码</h2><p>可以的，一样的代码，它就能运行，咱就不行，怎么回事呢？</p><h2 id="干脆重新安装JDK试试"><a href="#干脆重新安装JDK试试" class="headerlink" title="干脆重新安装JDK试试!"></a>干脆重新安装JDK试试!</h2><h3 id="卸载旧的JDK"><a href="#卸载旧的JDK" class="headerlink" title="卸载旧的JDK"></a>卸载旧的JDK</h3><p>打开控制面板–&gt;卸载程序–&gt;找到Java开头的两个应用</p><p><img src="http://cdn.leafii.top/img/20220520154835.png" loading="lazy"></p><p>给他们都卸载了！</p><p>把环境变量配置的JAVA_HOME,以及Path中的两个java运行路径都删除！</p><h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><p>当然是去甲骨文官网下载啦，[官网地址](<a href="https://www.oracle.com/java/technologies/javase-downloads.html">Java SE - Downloads | Oracle Technology Network | Oracle</a>)</p><p>选择合适的jdk版本的合适系统的安装包，点击下载，同意协议，登陆账户后自动开始下载</p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>双击安装就好了</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol><li><p>右键此电脑–&gt;属性–&gt;高级系统设置–&gt;环境变量</p></li><li><p>配置JAVA_HOME(在用户变量里），路径为你的java安装目录，我的安装目录如下</p></li></ol><p><img src="http://cdn.leafii.top/img/20220520154850.png" loading="lazy"></p><ol start="3"><li>配置Path（在系统变量里），路径为jdk和jre的运行目录，我的path配置如下</li></ol><p><img src="http://cdn.leafii.top/img/20220520154901.png" loading="lazy"></p><ol start="4"><li>虽然在java1.6以上不需要配置CLASSPATH，但是因为我要配置额外的运行库，所以要在系统变量里配置完整CLASSPATH，值如下</li></ol><pre class="language-none"><code class="language-none">.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code></pre><ol start="5"><li>因为配置了算法第四版的运行库，所以要在CLASSPATH中添加</li></ol><pre class="language-none"><code class="language-none">;C:\Users\yeyun\alsgs4\algs4.jar</code></pre><p><strong>配置结束之后，点击三次确定，打开cmd（或gitbash），输入java -version，如果不报错并显示版本，则配置成功</strong></p><h2 id="现在再试试Helloworld能跑起来吗？"><a href="#现在再试试Helloworld能跑起来吗？" class="headerlink" title="现在再试试Helloworld能跑起来吗？"></a>现在再试试Helloworld能跑起来吗？</h2><p><img src="http://cdn.leafii.top/img/20220520154915.png" loading="lazy"></p><p>可以的，成功了！，再试试书上的示例代码可以跑起来吗？</p><p><img src="http://cdn.leafii.top/img/20220520154937.png" loading="lazy"></p><p>可以了！</p><h2 id="反省问题"><a href="#反省问题" class="headerlink" title="反省问题"></a>反省问题</h2><p>其实jdk并没有问题，因为在idea上运行代码，项目都没有任何问题的，只是在命令行的时候出了问题！那么是哪里出了问题呢？</p><p>是CLASSPATH环境变量配置的问题！以前配置jdk的时候没有配置CLASSPATH，所以以前可以直接用java命令运行，但是现在因为配置了算法第四版的运行库，反而配置了CLASSPATH，但是并没有配置其它的默认的CLASSPATH，导致系统不知道你在运行java命令时的此时的.class文件的目录什么的（和.;这个环境变量内容有关系），配置之后就一切正常了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果使用java命令运行.class文件时报错：找不到或无法加载主类，请进行如下操作：</p><ol><li><p>检查你运行的类是不是处于某个包内，要在这个包的上一级目录，运行这个包中的类，并且在类名之前加上包名，如<code>java top.leafii.day01.HelloWorld</code> ，这样如果可以运行，那么就是你java命令要运行的包名没有弄清楚</p></li><li><p>检查你的环境变量是否配置正确，如果配置了其它的CLASSPATH，那就把默认的<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code>也加上（注意分号)</p></li><li><p>如果实在不知道怎么搞，就重装一遍JDK！不过一般都是上面这两个情况。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言の变量</title>
      <link href="/2021/01/04/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E5%8F%98%E9%87%8F/"/>
      <url>/2021/01/04/Go%E8%AF%AD%E8%A8%80%E3%81%AE%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言の变量"><a href="#Go语言の变量" class="headerlink" title="Go语言の变量"></a>Go语言の变量</h1><p>本文章主要写Go语言中使用的变量类型以及其知识点</p><span id="more"></span><h2 id="为什么需要变量"><a href="#为什么需要变量" class="headerlink" title="为什么需要变量"></a>为什么需要变量</h2><p><strong>因为变量是高级程序语言的程序的基本组成单位，如下面的代码的实例：</strong></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">getVal</span><span class="token punctuation">(</span>num1 <span class="token builtin">int</span><span class="token punctuation">,</span> num2 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sum <span class="token operator">:=</span> num1 <span class="token operator">+</span> num2    sub <span class="token operator">:=</span> num2 <span class="token operator">-</span> num1    <span class="token keyword">return</span> sum<span class="token punctuation">,</span> sub<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sum<span class="token punctuation">,</span> sub <span class="token operator">:=</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"sum="</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span><span class="token string">"sub="</span><span class="token punctuation">,</span> sub<span class="token punctuation">)</span>    sum2<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token comment">//只取出第一个返回值</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"sum="</span><span class="token punctuation">,</span> sum2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>以上代码中的sum,sub都是变量。</p><h2 id="变量的介绍"><a href="#变量的介绍" class="headerlink" title="变量的介绍"></a>变量的介绍</h2><h3 id="变量的概念"><a href="#变量的概念" class="headerlink" title="变量的概念"></a>变量的概念</h3><p>变量相当于内存中一个数据存储空间的表示，你可以把变量看作是一个房间的门牌号，通过门牌号我们可以找到房间，同样的道理，通过变量名可以访问到变量&#x2F;变量的值。</p><h3 id="变量的使用步骤"><a href="#变量的使用步骤" class="headerlink" title="变量的使用步骤"></a>变量的使用步骤</h3><ol><li>声明变量（也叫定义变量）</li><li>非变量赋值</li><li>使用变量</li></ol><h2 id="变量快速入门案例"><a href="#变量快速入门案例" class="headerlink" title="变量快速入门案例"></a>变量快速入门案例</h2><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//定义变量/声明变量</span><span class="token keyword">var</span> i <span class="token builtin">int</span><span class="token comment">//给i赋值</span>i <span class="token operator">=</span> <span class="token number">10</span><span class="token comment">//使用变量</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>输出结果：</p><p><img src="http://cdn.leafii.top/img/20220520153338.png" loading="lazy"></p><h2 id="变量使用注意事项"><a href="#变量使用注意事项" class="headerlink" title="变量使用注意事项"></a>变量使用注意事项</h2><ol><li>变量表示内存中的一个存储区域</li><li>该区域有自己的名称（变量名）和类型（数据类型）</li></ol><p>示意图:</p><p><img src="http://cdn.leafii.top/img/20220520153353.png" loading="lazy"></p><ol start="3"><li><p>Golang变量使用的三种方式</p><ol><li>指定变量类型，声明后若不赋值，使用默认值。<code>var i int</code></li><li>根据值自行判定变量类型（类型推导）<code>var num = 10.11</code></li><li>省略var,注意 :&#x3D; 左侧的变量不应该是已经声明过的，否则会导致编译错误</li></ol><pre class="language-go" data-language="go"><code class="language-go">name <span class="token operator">:=</span> <span class="token string">"tom"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"name="</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span></code></pre></li><li><p>多变量声明</p><p>在编程中，有时我们需要一次性声明多个变量，Golang也提供这样的语法，举例说明:</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//该案例演示golang如何一次性声明多个变量</span>    <span class="token comment">// var n1, n2, n3 int</span>    <span class="token comment">// fmt.Println("n1=",n1, "n2=",n2 ,"n3=",n3)</span>        <span class="token comment">//方式2</span>    <span class="token comment">// var n1, name, n3 = 100, "tom", 888</span>    <span class="token comment">// fmt.Println("n1=",n1, "name=",name ,"n3=",n3)</span>        <span class="token comment">//方式3 同样可以使用类型推导</span>    n1<span class="token punctuation">,</span> name<span class="token punctuation">,</span> n3 <span class="token operator">:=</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"tom~"</span><span class="token punctuation">,</span> <span class="token number">888</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"n1="</span><span class="token punctuation">,</span>n1<span class="token punctuation">,</span> <span class="token string">"name="</span><span class="token punctuation">,</span>name <span class="token punctuation">,</span><span class="token string">"n3="</span><span class="token punctuation">,</span>n3<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span></code></pre><p>​如何一次性声明多个全局变量【在go中函数外部定义变量就是全局变量】：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//定义全局变量</span><span class="token keyword">var</span> n1 <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">var</span> n2 <span class="token operator">=</span> <span class="token number">200</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"jack"</span><span class="token comment">//上面的声明方式，也可以改成一次性声明</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    n3 <span class="token operator">=</span> <span class="token number">300</span>    n4 <span class="token operator">=</span> <span class="token number">900</span>    name2 <span class="token operator">=</span> <span class="token string">"mary"</span><span class="token punctuation">)</span></code></pre><ol start="5"><li>该区域的数据值可以在同一类型范围内不断变化（重点）</li></ol></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">//变量使用的注意事项</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//该区域的数据值可以在同一类型范围内不断变化</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>    i <span class="token operator">=</span> <span class="token number">30</span>    i <span class="token operator">=</span> <span class="token number">50</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    i <span class="token operator">=</span> <span class="token number">1.2</span><span class="token comment">//int， 原因是不能改变数据类型</span><span class="token punctuation">&#125;</span></code></pre><ol start="6"><li>变量在<strong>同一个作用域</strong>（在一个函数或者代码块）内不能重名</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">59</span>i <span class="token operator">:=</span> <span class="token number">99</span><span class="token comment">//错误!</span></code></pre><h2 id="变量的声明，初始化和赋值"><a href="#变量的声明，初始化和赋值" class="headerlink" title="变量的声明，初始化和赋值"></a>变量的声明，初始化和赋值</h2><ul><li><p>声明变量</p><ul><li>基本语法： var 变量名 数据类型</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token comment">//这就是声明了一个变量，变量名为a</span><span class="token keyword">var</span> num1 <span class="token builtin">float32</span> <span class="token comment">//这也是声明了一个变量，表示一个单精度类型的小数，变量名是num1</span></code></pre></li><li><p>初始化变量</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//在声明变量的时候，就给值</span><span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">45</span> <span class="token comment">//这就是初始化变量a</span><span class="token comment">//使用细节，如过声明时就直接赋值，可以省略数据类型</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">400</span></code></pre></li><li><p>给变量赋值</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//先声明变量</span><span class="token keyword">var</span> num <span class="token builtin">int</span> <span class="token comment">//默认0</span><span class="token comment">//赋值</span>num <span class="token operator">=</span> <span class="token number">780</span> <span class="token comment">//这就是赋值</span></code></pre></li></ul><h2 id="程序中”-“号的使用"><a href="#程序中”-“号的使用" class="headerlink" title="程序中”+“号的使用"></a>程序中”+“号的使用</h2><ol><li>当左右两边都是数值型时，则做加法运算</li><li>当左右两边都是字符串，则做字符串拼接</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">//演示golang中"+"的使用</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">2</span>    <span class="token keyword">var</span> r <span class="token operator">=</span> i <span class="token operator">+</span> j    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"r="</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>        <span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">"hello"</span>    <span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">"world"</span>    <span class="token keyword">var</span> res <span class="token operator">=</span> str1 <span class="token operator">+</span> str2 <span class="token comment">//做拼接操作</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res="</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h2 id="数据类型的基本介绍"><a href="#数据类型的基本介绍" class="headerlink" title="数据类型的基本介绍"></a>数据类型的基本介绍</h2><ul><li>每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间。</li></ul><p><img src="http://cdn.leafii.top/img/20220520153407.png" loading="lazy"></p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​简单地说，就是用于存放整数值的，比如0，-1，2345等等。</p><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//演示Golang中整数类型的使用</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>        <span class="token comment">//测试以下int8的范围 -128~127</span>    <span class="token comment">//其他的 int16,int32,int64,类推...</span>    <span class="token keyword">var</span> j <span class="token builtin">int8</span> <span class="token operator">=</span> <span class="token number">127</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"j="</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h3 id="整数的各个类型"><a href="#整数的各个类型" class="headerlink" title="整数的各个类型"></a>整数的各个类型</h3><ul><li>整形的类型</li></ul><table><thead><tr><th>类型</th><th>有无符号</th><th>占用存储空间</th><th>表数范围</th></tr></thead><tbody><tr><td>int8</td><td>有</td><td>1字节</td><td>-128~127</td></tr><tr><td>int16</td><td>有</td><td>2字节</td><td>-2<sup>15</sup>~2<sup>15</sup>-1</td></tr><tr><td>int32</td><td>有</td><td>4字节</td><td>-2<sup>31</sup>~2<sup>31</sup>-1</td></tr><tr><td>int64</td><td>有</td><td>8字节</td><td>-2<sup>63</sup>~2<sup>63</sup>-1</td></tr></tbody></table><ul><li>整形的无符号类型</li></ul><table><thead><tr><th>类型</th><th>有无符号</th><th>占用存储空间</th><th>表数范围</th></tr></thead><tbody><tr><td>uint8</td><td>无</td><td>1字节</td><td>0~255</td></tr><tr><td>uint16</td><td>无</td><td>2字节</td><td>0~2<sup>16</sup>-1</td></tr><tr><td>uint32</td><td>无</td><td>4字节</td><td>0~2<sup>32</sup>-1</td></tr><tr><td>uint64</td><td>无</td><td>8字节</td><td>0~2<sup>64</sup>-1</td></tr></tbody></table><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//测试一下uint8的范围（0~255），其他的uint16,uint32,uint64类推即可</span><span class="token keyword">var</span> k <span class="token builtin">uint16</span> <span class="token operator">=</span> <span class="token number">255</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"k="</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span></code></pre><ul><li>int的其他类型的说明：</li></ul><table><thead><tr><th>类型</th><th>有无符号</th><th>占用存储空间</th><th>表数范围</th><th>备注</th></tr></thead><tbody><tr><td>int</td><td>有</td><td>32位系统4个字节<br />64位系统8个字节</td><td>-2<sup>31</sup><del>2<sup>31</sup>-1<br />-2<sup>63</sup></del>2<sup>63</sup>-1</td><td></td></tr><tr><td>uint</td><td>无</td><td>32位系统4个字节<br />64位系统8个字节</td><td>-0<del>2<sup>32</sup>-1<br />0</del>2<sup>64</sup>-1</td><td></td></tr><tr><td>rune</td><td>有</td><td>与int32一样</td><td>-2<sup>31</sup>~2<sup>31</sup>-1</td><td>等价int32，表示一个Unicode码</td></tr><tr><td>byte</td><td>无</td><td>与uint8等价</td><td>0~255</td><td>当要存储字符时选用byte</td></tr></tbody></table><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//int,uint,rune,byte的使用</span><span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">8900</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"a="</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token keyword">var</span> b <span class="token builtin">uint</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">var</span> c <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token number">255</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"b="</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token string">"c="</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span></code></pre><h3 id="整形的使用细节"><a href="#整形的使用细节" class="headerlink" title="整形的使用细节"></a>整形的使用细节</h3><ol><li>Golang各整数类型分：有符号和无符号，int uint的大小和系统有关</li><li>Golang的整型默认声明为int型</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//整形的使用细节</span><span class="token keyword">var</span> n1 <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">//? n1是什么类型</span><span class="token comment">//这里我们给大家介绍如何查看某个变量的数据类型</span><span class="token comment">//fmt.Println() 可以用于做格式化输出。</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"n1 的类型 %T \n"</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span></code></pre><ol start="3"><li>如何在程序查看某个变量的字节大小和数据类型 （使用较多）</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//如何在程序查看某个变量的占用字节大小和数据类型 （使用较多）</span><span class="token keyword">var</span> n2 <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token comment">//unsafe.Sizeof(n1) 是unsafe包的一个函数，可以返回n1变量占用的字节数</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"n2 的 类型 %Tn2占用的字节数是 %d"</span><span class="token punctuation">,</span> n2<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ol start="4"><li>Golang程序中整型变量在使用时，遵守保小不保大的原则，即：在保证程序正确运行下，尽量使用占用空间小的数据类型。【如：年龄】</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//Golang程序中整型变量在使用时，遵守保小不保大的原则，</span><span class="token comment">//即：在保证程序正确运行下，尽量使用占用空间小的数据类型。</span><span class="token keyword">var</span> age <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token number">90</span></code></pre><ol start="5"><li>bit:计算机中的最小存储单位。byte：计算机中基本存储单元。1 byte &#x3D; 8 bit</li></ol><h2 id="小数类型-x2F-浮点型"><a href="#小数类型-x2F-浮点型" class="headerlink" title="小数类型&#x2F;浮点型"></a>小数类型&#x2F;浮点型</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>顾名思义，小数类型就是用于存放小数的，如1.2，0.23，-1.91</p><h3 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//演示golang中小数类型使用</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> price <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">89.12</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"price="</span><span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果如下图</p><p><img src="http://cdn.leafii.top/img/20220520153422.png" loading="lazy"></p><h3 id="小数类型分类"><a href="#小数类型分类" class="headerlink" title="小数类型分类"></a>小数类型分类</h3><table><thead><tr><th>类型</th><th>占用存储空间</th><th>表数范围</th></tr></thead><tbody><tr><td>单精度float32</td><td>4字节</td><td>-3.403E38~3.403E38</td></tr><tr><td>双精度float64</td><td>8字节</td><td>-1.798E308~1.798E308</td></tr></tbody></table><p><strong>说明</strong>:</p><ol><li>关于浮点数在机器中存放形式的简单说明，浮点数&#x3D;符号位+指数位+尾数位，浮点数都是有符号的。</li></ol><p><img src="http://cdn.leafii.top/img/20220520153435.png" loading="lazy"></p><ol start="2"><li>尾数部分可能丢失，造成精度损失。 -123.0000901</li></ol><p><img src="http://cdn.leafii.top/img/20220520153454.png" loading="lazy"></p><p><strong>说明：</strong></p><ul><li>float64的精度比float32的要准确</li><li>如果我们要保存一个精度高的数，则应该选用float64</li></ul><ol start="3"><li>浮点型的存储分为三部分：符号位+指数位+尾数位    在存储过程中，精度会有丢失哦</li></ol><h3 id="浮点型使用细节"><a href="#浮点型使用细节" class="headerlink" title="浮点型使用细节"></a>浮点型使用细节</h3><ol><li><p>Golang浮点类型有固定的范围和字段长度，不受具体的操作系统的影响。</p></li><li><p>Golang的浮点型默认声明为float64类型。</p></li><li><p>浮点型常量有两种表示形式</p><ul><li>十进制数形式：如：5.12        .512（必须有小数点）</li><li>科学计数法形式：如： 5.1234e2 &#x3D; 5.12 * 10 ^ 2      5.12E-2 &#x3D; 5.12&#x2F;(10^2)</li></ul></li><li><p>通常情况下，应该使用float64，因为它精度更高。</p></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//Golang的浮点型默认声明为float64类型</span><span class="token keyword">var</span> num5 <span class="token operator">=</span> <span class="token number">1.1</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"num5的数据类型是 %T \n"</span><span class="token punctuation">,</span> num5<span class="token punctuation">)</span><span class="token comment">//十进制数形式：如：5.12        .512（必须有小数点）</span>num6 <span class="token operator">:=</span> <span class="token number">5.12</span>num7 <span class="token operator">:=</span> <span class="token number">.123</span> <span class="token comment">//->0.123</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"num6="</span><span class="token punctuation">,</span> num6<span class="token punctuation">,</span> <span class="token string">"num7="</span><span class="token punctuation">,</span> num7<span class="token punctuation">)</span><span class="token comment">//科学计数法形式：如： 5.1234e2 = 5.12 * 10 ^ 2      5.12E-2 = 5.12/(10^2)</span>num8 <span class="token operator">:=</span> <span class="token number">5.1234e2</span> <span class="token comment">// 5.1234 * 10 ^ 2</span>num8 <span class="token operator">:=</span> <span class="token number">5.1234E2</span> <span class="token comment">// 5.1234 * 10 ^ 2</span></code></pre><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>在Golang中没有专门的字符类型，如果要存储单个字符(字母)，一般使用byte来保存。</p><p><strong>字符串就是一串固定长度的字符连接起来的字符序列。</strong>Go的字符串是由单个字节连接起来的。也就是说对于传统的字符串是由字符组成的，而Go的字符串不同，它是由字节组成的。</p><h3 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//演示Golang中字符类型使用</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> c1 <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token char">'a'</span><span class="token keyword">var</span> c2 <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token char">'0'</span>   <span class="token comment">//字符的0</span><span class="token comment">//当我们直接输出byte值，就是输出了对应字符的码值</span><span class="token comment">//'a' ==> </span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"c1="</span><span class="token punctuation">,</span> c1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"c2="</span><span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token comment">//如果我们希望输出对应字符，需要使用格式化输出</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"c1=%c c2=%c\n"</span><span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token comment">//var c3 byte = '北' //overflow溢出</span><span class="token keyword">var</span> c3 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token char">'北'</span> <span class="token comment">//overflow溢出</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"c3=%c c3对应码值=%d\n"</span><span class="token punctuation">,</span> c3<span class="token punctuation">,</span> c3<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果：</p><p><img src="http://cdn.leafii.top/img/20220520153517.png" loading="lazy"></p><p><strong>对上述代码的说明</strong></p><ol><li>如果我们保存的字符在ASCII表中，比如[0-1，a-z,A-Z]  我们可以直接保存到byte中</li><li>如果我们要保存的字符的对应码值大于255，这时我们可以考虑使用int类型保存</li><li>如果我们需要按照字符的方式输出，此时就需要进行格式化输出，即<code>fmt.Printf(&quot;%c&quot;,c1)</code></li></ol><h3 id="字符类型使用细节"><a href="#字符类型使用细节" class="headerlink" title="字符类型使用细节"></a>字符类型使用细节</h3><ol><li>字符常量是用单引号（”)括起来的单个字符。例如<code>var c1 byte = &#39;a&#39;</code>,<code>car c2 int = &#39;中&#39;</code>,<code>var c3 byte = &#39;9&#39;</code></li><li>Go中允许使用转义字符’\‘来将其后面的字符转变为特殊字符型常量。例如：<code>var c3 char = &#39;\n&#39;  </code>（\n表示换行符）</li><li>Go语言的字符使UTF-8编码，如果想查询字符对应的utf8码值，请点击[链接](<a href="http://www.mytju.com/classcode/tools/encode_utf8.asp">查看字符编码（UTF-8） (mytju.com)</a>). 英文字母占1个自己，汉字占3个字节</li><li>在Go中，字符的本质是一个整数，直接输出时，是该字符对应的 UTF-8编码的码值。</li><li>可以直接给某个变量赋一个数字，然后按格式化输出%c,会输出该数字对应的Unicode字符，如</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> c4 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">22269</span> <span class="token comment">//22269 -> '国'</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"c4 = %c\n"</span><span class="token punctuation">,</span> c4<span class="token punctuation">)</span></code></pre><ol start="6"><li>字符类型可以进行运算，它相当于一个整数，因为每个字符都有对应的Unicode码。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> n1 <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token char">'a'</span>   <span class="token comment">// 10+97 = 107</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"n1 = %c\n"</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span> <span class="token comment">//输出为k</span></code></pre><h3 id="字符类型本质探讨"><a href="#字符类型本质探讨" class="headerlink" title="字符类型本质探讨"></a>字符类型本质探讨</h3><ol><li>字符型存储到计算机中，需要将字符对应的码值（整数）找出来<ul><li>存储： 字符 –&gt; 对应码值  –&gt; 二进制 –&gt; 存储</li><li>读取： 二进制 –&gt;  码值 –&gt; 字符 –&gt; 读取</li></ul></li><li>字符和码值的对应关系是通过字符编码表决定的（这是规定）</li><li>Go语言的编码都统一成了UTF-8。这非常的方便，再也没有编码乱码的困扰了。</li></ol><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>布尔类型，又名bool类型，bool类型数据只允许取值true和false</li><li>bool类型占1个字节</li><li>bool类型适用于逻辑运算，一般用于程序流程控制（之后会详细了解）<ul><li>if条件控制语句</li><li>for循环控制语句</li></ul></li></ol><h3 id="案例演示-3"><a href="#案例演示-3" class="headerlink" title="案例演示"></a>案例演示</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"unsafe"</span><span class="token punctuation">)</span><span class="token comment">//演示Golang中bool类型的使用</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token boolean">false</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"b="</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token comment">//注意事项</span><span class="token comment">//1. bool类型占用的存储空间是1字节</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"b 的占用空间 = "</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//2. bool类型只能取true或false</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果</p><p><img src="http://cdn.leafii.top/img/20220520153537.png" loading="lazy"></p><h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本</p><h3 id="案例演示-4"><a href="#案例演示-4" class="headerlink" title="案例演示"></a>案例演示</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//演示Golang中string类型的使用</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//string的基本使用</span><span class="token keyword">var</span> address <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"北京长城 厉害了1234 hello world！"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h3 id="string的注意事项和细节"><a href="#string的注意事项和细节" class="headerlink" title="string的注意事项和细节"></a>string的注意事项和细节</h3><ol><li>Go语言的字符串的字节使用UTF-8编码标识Unicode文本，这样Golang统一使用UTF-8编码，中文乱码问题不会再困扰程序员。</li><li>字符串一旦赋值了，字符串就不能修改了：在Go中字符串是不可变的。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"hello"</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'a'</span>    <span class="token comment">//这里不能修改str的内容，也就是说Go中的字符串是不可变的</span></code></pre><ol start="3"><li>字符串的两种表示形式<ol><li>双引号，会识别转义字符</li><li>反引号，以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击，输出源代码等效果。</li></ol></li></ol><p>【案例演示】</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//演示Golang中string类型的使用</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//string的基本使用</span>address <span class="token operator">:=</span> <span class="token string">"abc\nabc"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span>str2 <span class="token operator">:=</span> <span class="token string">`package mainimport ("fmt")//演示Golang中string类型的使用func main() &#123;//string的基本使用var address string = "北京长城 厉害了1234 hello world！"fmt.Println(address)&#125;`</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果:</p><p><img src="http://cdn.leafii.top/img/20220520153552.png" loading="lazy"></p><ol start="4"><li>字符串拼接方式</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//字符串拼接方式</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span>str <span class="token operator">+=</span> <span class="token string">" haha!"</span></code></pre><ol start="5"><li>当一行字符串太长时，需要用到多行字符串，可以如下处理</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//当一个拼接的操作很长时，怎么办？可以分行写，但是注意，需要将+保留在上一行。</span>str4 <span class="token operator">:=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span> <span class="token operator">+</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span> <span class="token operator">+</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span> <span class="token operator">+</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span> <span class="token operator">+</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span> <span class="token operator">+</span><span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str4<span class="token punctuation">)</span></code></pre><h2 id="基本数据类型的默认值"><a href="#基本数据类型的默认值" class="headerlink" title="基本数据类型的默认值"></a>基本数据类型的默认值</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>在Go中，数据类型都有一个默认值，当程序员没有赋值时，就会保留默认值，在Go中，默认值又叫零值。</p><h3 id="基本数据类型的默认值-1"><a href="#基本数据类型的默认值-1" class="headerlink" title="基本数据类型的默认值"></a>基本数据类型的默认值</h3><table><thead><tr><th>数据类型</th><th>默认值</th></tr></thead><tbody><tr><td>整形</td><td>0</td></tr><tr><td>浮点型</td><td>0</td></tr><tr><td>字符串</td><td>“”</td></tr><tr><td>布尔类型</td><td>false</td></tr></tbody></table><h2 id="基本数据类型的相互转换"><a href="#基本数据类型的相互转换" class="headerlink" title="基本数据类型的相互转换"></a>基本数据类型的相互转换</h2><h3 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Golang和java&#x2F;C不同，Go在不同类型的变量之间赋值时<strong>需要显式转换</strong>。也就是说Golang中的数据类型不能自动转换。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>表达式T(v)将值v转换为类型T</p><p>T:就是数据类型，比如int32,int64.float32等等</p><p>v：就是需要转换的变量</p><h3 id="案例演示-5"><a href="#案例演示-5" class="headerlink" title="案例演示"></a>案例演示</h3><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> i <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token comment">//希望将 i => float</span><span class="token keyword">var</span> n1 <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token function">float32</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">var</span> n2 <span class="token builtin">int8</span> <span class="token operator">=</span> <span class="token function">int8</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">var</span> n3 <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token function">int64</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">//低精度->高精度</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"i=%v n1=%v n2=%v n3=%v \n"</span><span class="token punctuation">,</span> i <span class="token punctuation">,</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> n3<span class="token punctuation">)</span></code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>Go中，数据类型的转换可以是从 表示范围小–&gt;表示范围大，也可以从 表示范围大–&gt;表示范围小</li><li>被转换的是变量存储的数据（即值），变量本身的数据类型并没有变化！</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> i <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token comment">//被转换的是变量存储的数据(即值)，变量本身的数据类型并没有变化</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"i type is %T\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment">// int32</span></code></pre><ol start="3"><li>在转换中，比如将 int64 转换成 int8 【-128~127】，编译时不会报错，只是转换的结果按<strong>溢出处理</strong>。和我们希望的结果不一样。因此在转换时，需要考虑范围。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//在转换中，比如将 int64  转成 int8 【-128---127】 ，编译时不会报错，</span><span class="token comment">//只是转换的结果是按溢出处理，和我们希望的结果不一样</span><span class="token keyword">var</span> num1 <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">999999</span><span class="token keyword">var</span> num2 <span class="token builtin">int8</span> <span class="token operator">=</span> <span class="token function">int8</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span> <span class="token comment">// </span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"num2="</span><span class="token punctuation">,</span> num2<span class="token punctuation">)</span></code></pre><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><ul><li>练习1</li></ul><p>如何修改一下代码，使之正确</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> n1 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">12</span>    <span class="token keyword">var</span> n2 <span class="token builtin">int64</span>    <span class="token keyword">var</span> n3 <span class="token builtin">int8</span>    n2 <span class="token operator">=</span> n1 <span class="token operator">+</span> <span class="token number">20</span>    n3 <span class="token operator">=</span> n1 <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">&#125;</span></code></pre><p>答案：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> n1 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">12</span>    <span class="token keyword">var</span> n2 <span class="token builtin">int64</span>    <span class="token keyword">var</span> n3 <span class="token builtin">int8</span>    n2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">int64</span><span class="token punctuation">)</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">20</span>     <span class="token comment">//int32 --> int64错误</span>    n3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">int8</span><span class="token punctuation">)</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">20</span>      <span class="token comment">//int32 --> int8 错误</span><span class="token punctuation">&#125;</span></code></pre><ul><li>练习2</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> n1 <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token keyword">var</span> n3 <span class="token builtin">int8</span><span class="token keyword">var</span> n4 <span class="token builtin">int8</span>n4 <span class="token operator">=</span> <span class="token function">int8</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">127</span> <span class="token comment">//编译通过，值溢出</span>n3 <span class="token operator">=</span> <span class="token function">int8</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">128</span> <span class="token comment">//编译不通过</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n4<span class="token punctuation">)</span></code></pre><h2 id="基本数据类型和string的转换"><a href="#基本数据类型和string的转换" class="headerlink" title="基本数据类型和string的转换"></a>基本数据类型和string的转换</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>在程序开发中，我们经常将基本数据类型转成string。或者将string转成基本数据类型。</p><h3 id="基本类型转string类型"><a href="#基本类型转string类型" class="headerlink" title="基本类型转string类型"></a>基本类型转string类型</h3><ul><li><p>方式1：fmt.Sprintf(“%参数”，表达式)   【这个比较灵活】</p><ul><li><p>函数的介绍：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//func Sprintf</span><span class="token keyword">func</span> <span class="token function">Sprintf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span>a <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token comment">//Sprintf根据format参数生成格式化的字符串并返回该字符串。</span></code></pre><p><strong>参数需要和表达式的数据类型相匹配</strong></p></li><li><p>案例演示</p></li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//演示Golang中基本数据练习转成string使用</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> num1 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">99</span><span class="token keyword">var</span> num2 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">23.456</span><span class="token keyword">var</span> b <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">var</span> mychar <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token char">'h'</span><span class="token keyword">var</span> str <span class="token builtin">string</span> <span class="token comment">//空的str</span><span class="token comment">//使用第一种方式来转换  fmt.Sprintf方法</span>str <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> num1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str type %T str=%q\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> str<span class="token punctuation">)</span>str <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> num2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str type %T str=%q\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> str<span class="token punctuation">)</span>str <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str type %T str=%q\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> b<span class="token punctuation">)</span>str <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> mychar<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str type %T str=%q\n"</span><span class="token punctuation">,</span> mychar<span class="token punctuation">,</span> mychar<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ul><li>运行结果</li></ul><pre class="language-none"><code class="language-none">str type string str&#x3D;&quot;99&quot;str type string str&#x3D;&quot;%!d(float64&#x3D;23.456)&quot;str type bool str&#x3D;%!q(bool&#x3D;true)str type uint8 str&#x3D;&#39;h&#39;</code></pre></li><li><p>方式2：使用strconv包的函数</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">FormatBool</span><span class="token punctuation">(</span>b <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token keyword">func</span> <span class="token function">FormatFloat</span><span class="token punctuation">(</span>f <span class="token builtin">float64</span><span class="token punctuation">,</span> fmt <span class="token builtin">byte</span><span class="token punctuation">,</span> prec<span class="token punctuation">,</span> bitSize <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token keyword">func</span> <span class="token function">FormatInt</span><span class="token punctuation">(</span>i <span class="token builtin">int64</span><span class="token punctuation">,</span> base <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token keyword">func</span> <span class="token function">FormatUint</span><span class="token punctuation">(</span>i <span class="token builtin">uint64</span><span class="token punctuation">,</span> base <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span></code></pre><ul><li>案例说明</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"strconv"</span><span class="token punctuation">)</span><span class="token comment">//第二种方式strconv函数</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> num3 <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">99</span><span class="token keyword">var</span> num4 <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">23.456</span><span class="token keyword">var</span> b2 <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">var</span> str <span class="token builtin">string</span> <span class="token comment">//空str</span>str <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">FormatInt</span><span class="token punctuation">(</span><span class="token function">int64</span><span class="token punctuation">(</span>num3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str type %T str=%q\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token comment">//strconv.FormatFloat(num3, 'f', 10, 64)</span><span class="token comment">//说明： 'f'格式 10：表示小数位保留10位 64：表示这个小数是float64</span>str <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">FormatFloat</span><span class="token punctuation">(</span>num4<span class="token punctuation">,</span> <span class="token char">'f'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str type %T str=%q\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> str<span class="token punctuation">)</span>str <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">FormatBool</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str type %T str=%q\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token comment">//strconv包中有一个函数Itoa</span><span class="token keyword">var</span> num5 <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">4567</span>str <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span><span class="token function">int</span><span class="token punctuation">(</span>num5<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"str type %T str=%q\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ul><li>运行结果</li></ul><pre class="language-none"><code class="language-none">str type string str&#x3D;&quot;99&quot;str type string str&#x3D;&quot;23.4560000000&quot;str type string str&#x3D;&quot;true&quot;str type string str&#x3D;&quot;4567&quot;</code></pre></li></ul><h3 id="string类型转基本数据类型"><a href="#string类型转基本数据类型" class="headerlink" title="string类型转基本数据类型"></a>string类型转基本数据类型</h3><ul><li>使用时strconv包的函数</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ParseBool</span><span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">(</span>value <span class="token builtin">bool</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">ParseFloat</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span>bitSize <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>f <span class="token builtin">float64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">ParseInt</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> base <span class="token builtin">int</span><span class="token punctuation">,</span> bitSize <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i <span class="token builtin">int64</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">ParseUint</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">,</span> bitSize <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>n <span class="token builtin">uint64</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span></code></pre><ul><li><p>案例演示</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"strconv"</span><span class="token punctuation">)</span><span class="token comment">//第二种方式strconv函数</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> str <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"true"</span><span class="token keyword">var</span> b <span class="token builtin">bool</span><span class="token comment">// b, _ = strconv.ParseBool(str)</span><span class="token comment">//说明</span><span class="token comment">//1. strconv.ParseBool(str) 函数会返回两个值 （value bool,err error)</span><span class="token comment">//2. 因为我只想获取到value bool, 不限孤鸿去err 所以我使用_忽略</span>b <span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseBool</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"b type %T b=%v\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token keyword">var</span> str2 <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"1234590"</span><span class="token keyword">var</span> n1 <span class="token builtin">int64</span><span class="token keyword">var</span> n2 <span class="token builtin">int</span>n1<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseInt</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>n2 <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"n1 type %T n1=%v\n"</span><span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"n2 type %T n2=%v\n"</span><span class="token punctuation">,</span> n2<span class="token punctuation">,</span> n2<span class="token punctuation">)</span><span class="token keyword">var</span> str3 <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"123.456"</span><span class="token keyword">var</span> f1 <span class="token builtin">float64</span>f1<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseFloat</span><span class="token punctuation">(</span>str3<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"f1 type %T f1=%v\n"</span><span class="token punctuation">,</span> f1<span class="token punctuation">,</span> f1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><ul><li>运行结果</li></ul><pre class="language-none"><code class="language-none">b type bool b&#x3D;truen1 type int64 n1&#x3D;1234590n2 type int n2&#x3D;1234590f1 type float64 f1&#x3D;123.456</code></pre></li><li><p>说明一下</p><p><strong>因为返回的是int64或者float64，所以如果希望得到int32，float32等，要进行如下处理：</strong></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> num5 <span class="token builtin">int</span> <span class="token number">32</span>num5 <span class="token operator">=</span> <span class="token function">int32</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span></code></pre></li></ul><h3 id="string转基本数据类型的注意事项"><a href="#string转基本数据类型的注意事项" class="headerlink" title="string转基本数据类型的注意事项"></a>string转基本数据类型的注意事项</h3><p>​在将string类型转成基本数据类型时，要确保string类型能够转成有效的数据，比如我们可以把“123”，转成一个整数，但是我们不能将”hello”转成一个整数，如果这样做，Golang直接将其转成0，其他类型也是一样的道理.float–&gt;0      bool –&gt; false</p><ul><li>案例说明：</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//注意</span><span class="token keyword">var</span> str4 <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token keyword">var</span> n3 <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">11</span>n3<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseInt</span><span class="token punctuation">(</span>str4<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"n3 type %T n3=%v\n"</span><span class="token punctuation">,</span> n3<span class="token punctuation">,</span> n3<span class="token punctuation">)</span></code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>基本数据类型，变量存的就是值，也叫值类型</li><li>获取变量的地址，用&amp;，比如: var num int, 获取num的地址： &amp;num</li></ol><ul><li>分析一下基本数据类型在内存的布局</li></ul><p><img src="http://cdn.leafii.top/img/20220520153606.png" loading="lazy"></p><ol start="3"><li>指针类型，指针变量保存的是一个地址，这个地址指向的空间存的才是值，比如：<code>var ptr *int = &amp;num</code> ，指针在内存的布局如图所示：<img src="http://cdn.leafii.top/img/20220520153621.png" loading="lazy"></li><li>获取指针类型所指向的值，使用：<em>，比如:<code>var ptr *int</code>，使用</em>ptr获取ptr指向的值。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//演示Golang中指针类型</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//基本数据类型在内存布局</span><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token comment">// i 的地址是什么，&amp;i</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i的地址="</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token comment">//下面的 var ptr *int = &amp;i</span><span class="token comment">//1. ptr是一个指针变量</span><span class="token comment">//2. ptr的类型是 *int</span><span class="token comment">//3. ptr本身的值是 &amp;i</span><span class="token keyword">var</span> ptr <span class="token operator">*</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>ifmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"ptr=%v\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"ptr 的地址=%v\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"ptr 指向的值=%v\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">ptr&#x3D;0xc000014090ptr 的地址&#x3D;0xc000006030ptr 指向的值&#x3D;10</code></pre><ol start="5"><li>一个案例再说明</li></ol><p><img src="http://cdn.leafii.top/img/20220520153641.png" loading="lazy"></p><h3 id="案例演示-6"><a href="#案例演示-6" class="headerlink" title="案例演示"></a>案例演示</h3><ol><li>写一个程序，获取一个int变量num的地址，并显示到终端</li><li>将num的地址赋给指针ptr，并通过ptr去修改num的值</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token comment">//案例演示</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> num <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">9</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"num's address=%v\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token keyword">var</span> ptr <span class="token operator">*</span><span class="token builtin">int</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>num<span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"num=%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">num&#39;s address&#x3D;0xc000014090num&#x3D;10</code></pre><h3 id="指针的课堂练习"><a href="#指针的课堂练习" class="headerlink" title="指针的课堂练习"></a>指针的课堂练习</h3><ol><li>这个代码中有无错误？</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">300</span>    <span class="token keyword">var</span> ptr <span class="token operator">*</span><span class="token builtin">int</span> <span class="token operator">=</span> a<span class="token comment">//错误</span>    <span class="token comment">//应该改成 var ptr *int = &amp;a(取地址)</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">300</span>    <span class="token keyword">var</span> ptr <span class="token operator">*</span><span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a <span class="token comment">//错误 类型不匹配！</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">300</span>    <span class="token keyword">var</span> b <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">400</span>    <span class="token keyword">var</span> ptr <span class="token operator">*</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a <span class="token comment">//OK</span>    <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">//等价于a = 100</span>    ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>b <span class="token comment">// OK</span>    <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">200</span> <span class="token comment">//b = 200</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"a=%d,b=%d,*ptr=%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//输出什么内容？</span><span class="token comment">/*输出a=100,b=200,*ptr=200*/</span></code></pre><h3 id="指针的使用细节"><a href="#指针的使用细节" class="headerlink" title="指针的使用细节"></a>指针的使用细节</h3><ol><li>值类型，都有对应的指针类型，形式为 <em><strong>数据类型</strong>，比如说int的对应的指针就是</em>int,float32对应的指针类型就是 *<strong>float32</strong> 依次类推。</li><li>值类型包括：基本数据类型，int 系列，float系列， bool,string，数组和结构体struct</li></ol><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><h3 id="值类型和引用类型的说明"><a href="#值类型和引用类型的说明" class="headerlink" title="值类型和引用类型的说明"></a>值类型和引用类型的说明</h3><ol><li>值类型：基本数据类型，int 系列，float系列， bool,string，数组和结构体struct</li><li>引用类型：指针、slice切片、map、管道chan、interface等都是引用类型</li></ol><h3 id="值类型和引用类型的使用特点"><a href="#值类型和引用类型的使用特点" class="headerlink" title="值类型和引用类型的使用特点"></a>值类型和引用类型的使用特点</h3><ol><li>值类型：变量直接存储值，内存通常在栈中分配</li></ol><p>示意图：<img src="http://cdn.leafii.top/img/20220520153659.png" loading="lazy"></p><ol start="2"><li>引用类型：变量存储是一个地址，这个地址对应的空间才真正存储数据（值），内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收</li></ol><p>示意图：<img src="http://cdn.leafii.top/img/20220520153801.png" loading="lazy"></p><ol start="3"><li>内存的栈区和堆区示意图<img src="http://cdn.leafii.top/img/20220520153824.png" loading="lazy"></li></ol><h2 id="标识符的命名规范"><a href="#标识符的命名规范" class="headerlink" title="标识符的命名规范"></a>标识符的命名规范</h2><h3 id="标识符概念"><a href="#标识符概念" class="headerlink" title="标识符概念"></a>标识符概念</h3><ol><li>Golang对各种变量，方法，函数等命名时使用的字符序列称为标识符</li><li>凡是自己可以取名字的地方都叫标识符</li></ol><h3 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h3><ol><li>由26个英文字母大小写，0-9，_ 组成</li><li>数字不可以开头。<code>var num int //ok</code>     <code>var 3num int  // error</code></li><li>Golang中严格区分大小写。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> num <span class="token builtin">int</span><span class="token keyword">var</span> Num <span class="token builtin">int</span></code></pre><p><strong>说明：</strong>在Golang中，num和Num是两个不同的变量</p><ol start="4"><li>标识符不能包含空格。</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//这样8行！</span><span class="token keyword">var</span> ab c <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">30</span></code></pre><ol start="5"><li>下划线”_”本身在Go中是一个特殊的标识符，称为空标识符。可以代表任何其它的标识符，但是它对应的值会被忽略（比如：忽略某个返回值)。所以仅能被作为占位符使用，不能作为标识符使用。</li></ol><pre class="language-Go" data-language="Go"><code class="language-Go">&#x2F;&#x2F; _ 是空标识符，用于占用var _ int &#x3D; 40 &#x2F;&#x2F;errorfmt.Println(_) &#x2F;&#x2F;错的！8行！</code></pre><ol start="6"><li>不能以系统<strong>保留关键字</strong>作为标识符（一共有25个），比如  break, if 等等…</li></ol><h3 id="标识符的案例"><a href="#标识符的案例" class="headerlink" title="标识符的案例"></a>标识符的案例</h3><pre class="language-none"><code class="language-none">hello &#x2F;&#x2F;okhello12 &#x2F;&#x2F;ok1hello &#x2F;&#x2F;error 数字开头不可取！h-b &#x2F;&#x2F;error 不能使用！x h &#x2F;&#x2F;error 不能含有空格h_4 &#x2F;&#x2F;ok_ab &#x2F;&#x2F;okint &#x2F;&#x2F;ok 但是最好别这样使用float32 &#x2F;&#x2F;ok 但是最好别这样使用_ &#x2F;&#x2F;error 不行！Abc &#x2F;&#x2F; ok</code></pre><h3 id="标识符命名注意事项"><a href="#标识符命名注意事项" class="headerlink" title="标识符命名注意事项"></a>标识符命名注意事项</h3><ol><li>包名：保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，不要和标准库冲突 fmt</li></ol><p><img src="http://cdn.leafii.top/img/20220520153841.png" loading="lazy"></p><ol start="2"><li>变量名、函数名、常量名：采用驼峰法</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//举例</span><span class="token keyword">var</span> stuName <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"tom"</span>   <span class="token comment">//形式： xxxYyyZzz...</span><span class="token keyword">var</span> goodPrice <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">1234.5</span></code></pre><ol start="3"><li>如果变量名、函数名、常量名首字母大写，则可以被其他的包访问：如果首字母小写，则只能在本包中使用（注:可以简单的理解成，首字母大写是公开的，首字母小写是私有的），在golang没有public，private等关键字。</li></ol><ul><li>案例演示：</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//路径:../main/main.go</span><span class="token keyword">package</span> main<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"fmt"</span>    <span class="token comment">//为了使用utils.go,引入该文件所在的包(注意你的环境变量)</span><span class="token string">"go_code/chapter03/demo10/model"</span><span class="token punctuation">)</span><span class="token comment">//变量的使用事项</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//该区域的数据值可以在同一类型范围内不断变化</span><span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>i <span class="token operator">=</span> <span class="token number">30</span>i <span class="token operator">=</span> <span class="token number">50</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token comment">//i = 1.2 //int 原因是不能改变数据类型</span><span class="token comment">//变量在同一个作用域（在一个函数或者在代码块内）不能重名</span><span class="token comment">//var i int = 59</span><span class="token comment">//i := 99</span><span class="token comment">// 我们使用utils.go 的heroName 包名，标志符</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>model<span class="token punctuation">.</span>HeroName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/***********************************************/</span><span class="token comment">// 路径： ../model/utils.go</span><span class="token keyword">package</span> model<span class="token keyword">var</span> HeroName <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"吴用"</span></code></pre><h2 id="系统保留关键字"><a href="#系统保留关键字" class="headerlink" title="系统保留关键字"></a>系统保留关键字</h2><h3 id="保留关键字介绍"><a href="#保留关键字介绍" class="headerlink" title="保留关键字介绍"></a>保留关键字介绍</h3><p>在Go中，为了简化代码编译过程中对代码的解析，其定义的保留关键字只有25个。详见如下</p><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table><h2 id="系统的预定义标识符"><a href="#系统的预定义标识符" class="headerlink" title="系统的预定义标识符"></a>系统的预定义标识符</h2><h3 id="预定义标识符介绍"><a href="#预定义标识符介绍" class="headerlink" title="预定义标识符介绍"></a>预定义标识符介绍</h3><p>除了保留关键字外，Go还提供了36个预定的标识符，其包括基础数据类型和系统内嵌函数</p><table><thead><tr><th>append</th><th>bool</th><th>byte</th><th>cap</th><th>close</th><th>complex</th></tr></thead><tbody><tr><td>complex64</td><td>complex128</td><td>uint16</td><td>copy</td><td>false</td><td>float32</td></tr><tr><td>float64</td><td>imag</td><td>int</td><td>int8</td><td>int16</td><td>uint32</td></tr><tr><td>int32</td><td>int64</td><td>iota</td><td>len</td><td>make</td><td>new</td></tr><tr><td>nil</td><td>panic</td><td>uint64</td><td>print</td><td>println</td><td>rea</td></tr><tr><td>recover</td><td>string</td><td>true</td><td>uint</td><td>uint8</td><td>uintprt</td></tr></tbody></table><hr><p><strong>Go语言の变量这节结束啦！辛苦啦！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言入门</title>
      <link href="/2021/01/04/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/2021/01/04/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言入门"><a href="#Go语言入门" class="headerlink" title="Go语言入门"></a>Go语言入门</h1><p>本文章通过简单的Go语言代码说明一些Go语言编程的注意事项及知识点</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>要求开发一个hello.go程序，可以在屏幕打印出“hello world”</p><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><ol><li><p>在编写Go语言代码时的目录结构：</p><p><img src="http://cdn.leafii.top/img/20220520155023.png" loading="lazy"></p></li><li><p>编写代码，代码如下：</p></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//输出helloworld</span><span class="token keyword">package</span> main<span class="token comment">//go文件的后缀是.go</span><span class="token comment">//package main表示hello.go所在包为main包</span><span class="token comment">//在go中每个文件都必须归属于一个包</span><span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">//import “fmt”说明引入一个包，包名为fmt，引入目的是使用包内函数（fmt.Println())</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//func main() &#123; </span><span class="token comment">//func表示一个函数，main是主函数，代表程序的入口</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token comment">//表示调用fmt的Println输出hello world字符串</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>在cmd中通过go build命令对go语言进行编译，生成exe文件，默认生成的exe文件与你的代码文件的名称相同，在Windows系统下是后缀为exe可执行文件，在Linux系统中直接生成可执行文件。执行结果如下图所示：</li></ol><p><img src="http://cdn.leafii.top/img/20220520155039.png" loading="lazy"></p><ol start="4"><li>也可以通过go run 命令直接运行hello.go源代码（类似于执行一个脚本文件的形式），执行结果如下图所示：</li></ol><p><img src="http://cdn.leafii.top/img/20220520155053.png" loading="lazy"></p><h2 id="Golang代码执行流程分析"><a href="#Golang代码执行流程分析" class="headerlink" title="Golang代码执行流程分析"></a>Golang代码执行流程分析</h2><ul><li>如果是对源码编译后，再执行，Go的执行流程如下图：</li></ul><p><img src="http://cdn.leafii.top/img/20220520155109.png" loading="lazy"></p><ul><li>如果我们直接对源码进行go run 指令，Go的执行流程如下图:</li></ul><p><img src="http://cdn.leafii.top/img/20220520155120.png" loading="lazy"></p><p><strong>两种执行流程的方式区别</strong></p><pre><code>1. 如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有go开发环境的机器上，仍然可以运行。2. 如果我们是直接go run我们写的源代码，那么如果想要在另一台电脑上也运行，那么那台电脑必须安装Go语言的运行环境，否则无法执行。3. 在编译时，编译器会将程序运行依赖的库文件也包含在可执行文件中，所以可执行文件变大了很多。（go语言的helloworld代码只有5KB，生成的可执行文件有接近2000KB）</code></pre><h2 id="编译和运行说明"><a href="#编译和运行说明" class="headerlink" title="编译和运行说明"></a>编译和运行说明</h2><ol><li>有了Go语言代码的源文件，可以通过编译器将其编译成机器可以识别的二进制码文件</li><li>在该源文件目录下，通过go build 对hello.go文件进行编译，可以指定生成的可执行文件名，在Windows下，必须是.exe的后缀。</li></ol><p><img src="http://cdn.leafii.top/img/20220520155133.png" loading="lazy"></p><ol start="3"><li>如果程序没有错误，那么没有任何提示，并会在当前目录中生成一个可执行文件，该文件是一个二进制码文件，也是可以直接执行的程序。</li><li>如果程序有错误，编译时，会在错误的那一行报错。这有助于程序员的调试。</li></ol><p><img src="http://cdn.leafii.top/img/20220520155146.png" loading="lazy"></p><ol start="5"><li>运行有两种形式<ul><li>直接运行生成的可执行文件，比如hello.exe</li><li>通过运行工具go run 对源代码文件直接进行运行。</li></ul></li></ol><h2 id="Go语言开发的注意事项"><a href="#Go语言开发的注意事项" class="headerlink" title="Go语言开发的注意事项"></a>Go语言开发的注意事项</h2><ol><li>Go语言源代码的扩展名为.go</li><li>Go应用程序的执行入口是main()函数。（与java&#x2F;c相同）</li><li>Go语言严格区分大小写</li><li>Go方法由一条条语句构成，每个语句后不需要分号（编译时会自动为每行后添加分号），这也体现了Go语言代码的简洁性。</li><li>Go编译器都是一行一行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，否则会报错。</li><li>Go语言定义的变量或者import的包如果没有被使用到，代码是无法编译通过的。</li><li>大括号必须成对出现!</li></ol><hr><h2 id="Go语言的转义字符"><a href="#Go语言的转义字符" class="headerlink" title="Go语言的转义字符"></a>Go语言的转义字符</h2><p>常用的转义字符如下：</p><ul><li>\t:表示一个制表符，通常用于排版</li><li>\n:换行符</li><li>\:一个\</li><li>\“:一个”</li><li>\r:一个回车</li></ul><p>案例代码：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span> <span class="token comment">//fmt提供格式化，输入，输出的函数</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//演示转义字符的使用</span><span class="token comment">// \t的使用</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"tom\tjack"</span><span class="token punctuation">)</span><span class="token comment">// \n的使用</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"tom\njack"</span><span class="token punctuation">)</span><span class="token comment">// \\的使用</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello\\world"</span><span class="token punctuation">)</span><span class="token comment">// \"的使用</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"qwq\"ovo"</span><span class="token punctuation">)</span><span class="token comment">// \r的使用</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"owowo\rovo"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>运行效果：</p><p><img src="http://cdn.leafii.top/img/20220520155203.png" loading="lazy"></p><p><strong>注：换行符是直接换行，而回车是指把光标移到头部，将原来字符串中的语句的头部替换为回车后的字符，就如同示例中的owowo中前半段的owo就被\r之后的ovo替换了，最后打印出了ovowo</strong></p><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><p>要求使用一条输出语句，实现下图中的效果：</p><p><img src="http://cdn.leafii.top/img/20220520155217.png" loading="lazy"></p><p>代码：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"姓名\t年龄\t籍贯\t住址\njohn\t12\t河北\t北京"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p><strong>注：学会查看编译器的报错，自己进行bug的排查</strong></p><hr><h2 id="Go语言的注释"><a href="#Go语言的注释" class="headerlink" title="Go语言的注释"></a>Go语言的注释</h2><h3 id="介绍注释"><a href="#介绍注释" class="headerlink" title="介绍注释"></a>介绍注释</h3><p>用于注解说明解释程序的文字就是注释，<strong>注释提高了代码的阅读性</strong>；</p><p>注释是一个程序员必须要具有的良好的编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。</p><h3 id="Go语言中注释的两种形式"><a href="#Go语言中注释的两种形式" class="headerlink" title="Go语言中注释的两种形式"></a>Go语言中注释的两种形式</h3><ol><li><p>行注释</p><ul><li>基本语法</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//注释内容</span></code></pre><ul><li>举例</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//输出helloworld</span><span class="token keyword">package</span> main<span class="token comment">//go文件的后缀是.go</span><span class="token comment">//package main表示hello.go所在包为main包</span><span class="token comment">//在go中每个文件都必须归属于一个包</span><span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">//import “fmt”说明引入一个包，包名为fmt，引入目的是使用包内函数（fmt.Println())</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//func main() &#123; </span><span class="token comment">//func表示一个函数，main是主函数，代表程序的入口</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token comment">//表示调用fmt的Println输出hello world字符串</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>块注释（多行注释）</p><ul><li>基本语法</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">/*注释内容*/</span></code></pre><ul><li>举例说明</li></ul><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">/*这是一个多行注释*/</span></code></pre></li></ol><ul><li>使用细节<ul><li>对于行注释和块注释，被注释的文字，不会被Go编译器执行。</li><li>块注释里不允许有块注释嵌套。</li></ul></li></ul><hr><h2 id="规范的代码风格"><a href="#规范的代码风格" class="headerlink" title="规范的代码风格"></a>规范的代码风格</h2><h3 id="正确的注释和注释风格"><a href="#正确的注释和注释风格" class="headerlink" title="正确的注释和注释风格"></a>正确的注释和注释风格</h3><ol><li>Go官方推荐使用行注释来注释整个方法和语句</li><li>可以看Go源码中的注释的风格</li></ol><h3 id="正确的缩进和空白"><a href="#正确的缩进和空白" class="headerlink" title="正确的缩进和空白"></a>正确的缩进和空白</h3><ol><li>在VSCode中，使用tab进行代码缩进，默认整体朝右边移动，使用shift+tab可以真git向左移动。</li><li>使用gofmt来进行代码的格式化，如图所示：</li></ol><p><img src="http://cdn.leafii.top/img/20220520155232.png" loading="lazy"></p><ol start="3"><li>运算符两边习惯性各加一个空格，如：2 + 4 * 5</li><li>Go语言代码风格辨析：</li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello,Go!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//上面的写法是正确的</span><span class="token comment">//下面的写法是错误的，Go语言不支持这种写法</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"姓名\t年龄\t籍贯\t住址\njohn\t12\t河北\t北京"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p><strong>Go语言设计者希望在一个问题上尽量只有一个解决方法</strong></p><ol start="5"><li>一行最长不超过80个字符，超过的请使用换行展示，尽量保持格式优雅。比如：</li></ol><pre class="language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"HelloWorldHelloWorldHelloWorldHelloWorldHelloWorldHe\n"</span><span class="token punctuation">,</span><span class="token string">"lloWorldHelloWorldHelloWorldHelloWorldHelloWorldHelloWor\n"</span><span class="token punctuation">,</span><span class="token string">"ldHelloWorldHelloWorldHelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><hr><h2 id="知识点总结-x2F-回顾"><a href="#知识点总结-x2F-回顾" class="headerlink" title="知识点总结&#x2F;回顾"></a>知识点总结&#x2F;回顾</h2><p><img src="http://cdn.leafii.top/img/20220520155252.png" loading="lazy"></p><p><img src="http://cdn.leafii.top/img/20220520155308.png" loading="lazy"></p><hr><h2 id="API-x2F-指南的链接"><a href="#API-x2F-指南的链接" class="headerlink" title="API&#x2F;指南的链接"></a>API&#x2F;指南的链接</h2><p>Golang简体中文官方编程指南<a href="https://tour.go-zh.org/welcome/1">地址</a></p><p>Golang中文网 <a href="https://studygolang.com/pkgdoc">在线标准库文档</a></p><p>Golang官方标准API文档<a href="https://golang.org.pkg/">地址</a> </p><p><strong>API:application program interface:应用程序编程接口，也就是我们GO各个包里的各个函数</strong></p><p><strong>Golang中调用函数的方式是<code>import 包</code>，然后使用<code>包名.函数名</code> 进行函数的调用</strong></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言简介及环境配置</title>
      <link href="/2021/01/04/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/01/04/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言简介及环境配置"><a href="#Go语言简介及环境配置" class="headerlink" title="Go语言简介及环境配置"></a>Go语言简介及环境配置</h1><p>本文章主要讲解了Go语言的一些基本特性，以及Go语言编程环境的配置</p><span id="more"></span><h2 id="Go语言简介"><a href="#Go语言简介" class="headerlink" title="Go语言简介"></a>Go语言简介</h2><h3 id="Go语言的学习方向-x2F-应用领域"><a href="#Go语言的学习方向-x2F-应用领域" class="headerlink" title="Go语言的学习方向&#x2F;应用领域"></a>Go语言的学习方向&#x2F;应用领域</h3><p>Go语言，又称作Golang（Go language的简称），可以做区块链研发工，服务器端&#x2F;游戏软件工程师，或者分布式，云计算。</p><h3 id="学习Go语言以及其他编程语言的方法"><a href="#学习Go语言以及其他编程语言的方法" class="headerlink" title="学习Go语言以及其他编程语言的方法"></a>学习Go语言以及其他编程语言的方法</h3><ol><li>高效愉快的学习。</li><li>先建立一个整体框架，然后再去打磨细节。</li><li>在实际工作中，要培养用到什么，能够快速学习什么的能力。</li><li>作为一个工科学生，要先know how，再know why。</li><li>软件编程是一门“做中学”的学科，不是学会了再做，而是做了才会。</li><li>适当的囫囵吞枣。</li><li>学习软件编程应该琢磨别人怎么做，而不是我自己认为应该怎么做的过程。</li></ol><h2 id="Golang的概述"><a href="#Golang的概述" class="headerlink" title="Golang的概述"></a>Golang的概述</h2><h3 id="Golang被创造的原因"><a href="#Golang被创造的原因" class="headerlink" title="Golang被创造的原因"></a>Golang被创造的原因</h3><ol><li>计算机硬件技术更新频繁，性能提高很快。目前主流的编程语言发展明显落后与硬件，无法合理利用多核CPU的优势提升软件系统的性能。</li><li>软件系统复杂度越来越高，维护成本越来越高，目前缺乏一个足够简洁高效的编程语言。</li><li>企业运行维护着很多C&#x2F;C++的项目，它们的运行速度虽然很快，但是编译速度很慢，还存在内存泄漏等一系列的困扰需要去解决。</li></ol><h3 id="Golang的特点"><a href="#Golang的特点" class="headerlink" title="Golang的特点"></a>Golang的特点</h3><ul><li>简介</li></ul><p>Go语言保证了既能到达<strong>静态编译语言的安全和性能</strong>，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言:<strong>Go&#x3D;C+ Python</strong>,说明Go语言既有C静态语言程序的运行速度，又能达到Python动态语言的快速开发。</p><ol><li>从C语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等，也保留了和C语言一样的编译执行方式及弱化的指针 </li><li>引入<strong>包的概念</strong>，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。</li><li>垃圾回收机制，内存自动回收，无需开发人员管理。</li><li><strong>天然并发</strong><ol><li>从语言层面支持并发，实现简单</li><li>goroutine，轻量级线程，可实现大并发处理，高效利用多核。</li><li>基于CPS并发模型（Communicating Sequential Processes）实现</li><li>吸收了管道通信机制，形成Go语言特有的管道channel，通过管道channel，可以实现不同的goroute之间的相互通信。</li><li>函数可以返回多个值。</li><li>新的创新，如切片slice，延时执行defer</li></ol></li></ol><pre class="language-go" data-language="go"><code class="language-go"><span class="token comment">//Go弱化指针演示</span><span class="token keyword">func</span> <span class="token function">testPtr</span><span class="token punctuation">(</span>num <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>num <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token comment">//Go语言函数返回多个值演示</span><span class="token keyword">func</span> <span class="token function">getSumAndSub</span><span class="token punctuation">(</span>n1 <span class="token builtin">int</span><span class="token punctuation">,</span>n2 <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sum <span class="token operator">:=</span> n1 <span class="token operator">+</span> n2    sub <span class="token operator">:=</span> n1 <span class="token operator">-</span> n2    <span class="token keyword">return</span> sum<span class="token punctuation">,</span>sub<span class="token punctuation">&#125;</span></code></pre><h3 id="Go语言开发工具的介绍"><a href="#Go语言开发工具的介绍" class="headerlink" title="Go语言开发工具的介绍"></a>Go语言开发工具的介绍</h3><ol><li>VSCode：支持Go语言语法高亮，也可以安装Go语言插件，还有智能提示，编译运行等功能。</li><li>Sublime Text：可以免费使用，但是保存次数到一定数量会提示购买。</li><li>Vim：它是从vi发展出来的文本编辑器，代码补全，编译及错误跳转等方便编程的功能很丰富，在程序员中被广泛使用。</li><li>Emacs：传说中的神器，不仅是一个编辑器，因为它的功能强大，可以称它为集成开发环境。</li><li>Eclipse IDE:开源免费，并提供GoEclipse插件</li><li>LiteIDE：专门为Go语言开发的跨平台轻量级集成开发环境（IDE)，是国人开发的。</li><li>JetBrains全家桶:如Phpstorm,WebStorm,Pycharm（需要安装插件）以及Goland。</li></ol><p><strong>注：基础阶段建议使用VSCode</strong></p><h3 id="VSCode的安装和使用"><a href="#VSCode的安装和使用" class="headerlink" title="VSCode的安装和使用"></a>VSCode的安装和使用</h3><p><a href="https://code.visualstudio.com/download">VSCode下载链接</a></p><p>按照自己的系统以及位数选择下载，建议选择安装包版。</p><h3 id="Go语言开发环境-安装和配置SDK"><a href="#Go语言开发环境-安装和配置SDK" class="headerlink" title="Go语言开发环境-安装和配置SDK"></a>Go语言开发环境-安装和配置SDK</h3><h3 id="SDK是什么"><a href="#SDK是什么" class="headerlink" title="SDK是什么"></a>SDK是什么</h3><ol><li>SDK的全称为Software Development Kit（软件开发工具包)</li><li>SDK是提供给开发人员使用的，其中包含了对应开发语言的工具包</li></ol><h3 id="Go语言SDK的下载"><a href="#Go语言SDK的下载" class="headerlink" title="Go语言SDK的下载"></a>Go语言SDK的下载</h3><ol><li>进入Go语言的<a href="https://golang.google.cn/">官网</a>，直接点击Download Go</li><li>选择对应的系统即可，一般下载安装版，请注意安装路径不要有中文，特殊符号，空格等。</li><li>安装完毕之后，打开cmd（如果安装到C盘请用管理员模式启动cmd），输入<code>go version</code>,如果可以正确显示版本号，那么Go语言的SDK安装完成。</li><li>如果需要在其他路径中建立文件夹编写Go语言代码，需要在系统变量中添加名为GOPATH，值为你的代码的路径的环境变量。</li></ol><p><strong>如果输入go version提示go不属于系统命令什么的，请重启cmd</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVCの概述</title>
      <link href="/2020/05/17/SpringMVC%E3%81%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/05/17/SpringMVC%E3%81%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><ul><li>Spring 为展现层提供的基于 MVC 设计理念的优秀的 Web 框架，是目前最主流的 MVC 框架之一</li><li>Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架。</li><li>SpringMVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。</li><li>支持 REST 风格的 URL 请求。</li><li>采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。</li><li>基于Servlet实现，方便运行于常用Java EE容器。</li><li><span id="more"></span></li></ul><h2 id="1-1-MVC模式"><a href="#1-1-MVC模式" class="headerlink" title="1.1 MVC模式"></a>1.1 MVC模式</h2><p>MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式：<br><img src="http://cdn.leafii.top/img/20220520170228.png" loading="lazy"></p><ul><li>Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。</li><li>View（视图）是应用程序中处理数据显示的部分。</li><li>Controller（控制器）是应用程序中处理用户交互的部分。<br><img src="http://cdn.leafii.top/img/20220520170241.png" loading="lazy"><br><strong>优点：耦合性低、重用性高、可维护性高。</strong></li></ul><h2 id="1-2-Spring-MVC-模式"><a href="#1-2-Spring-MVC-模式" class="headerlink" title="1.2 Spring MVC 模式"></a>1.2 Spring MVC 模式</h2><p>前端控制器是整个MVC框架中最为核心的一块，它主要用来拦截符合要求的外部请求，并把请求分发到不同的控制器去处理，根据控制器处理后的结果，生成相应的响应发送到客户端。</p><p>Spring MVC使用Servlet来实现(DispatcherServlet)。DispatcherServlet 作为前置控制器是web服务器的入口，是spring mvc最重要的一个类。<br><img src="http://cdn.leafii.top/img/20220520170253.png" loading="lazy"></p><h2 id="1-3-SpringMVC-是什么"><a href="#1-3-SpringMVC-是什么" class="headerlink" title="1.3 SpringMVC 是什么"></a>1.3 SpringMVC 是什么</h2><p>1）一种轻量级的、基于 MVC 的 Web 层应用框架。偏前端而不是基于业务逻辑层。Spring框架的一个后续产品。</p><p>2）Spring 框架结构图(新版本)：<br><img src="http://cdn.leafii.top/img/20220520170306.png" loading="lazy"></p><h2 id="1-4SpringMVC-能干什么"><a href="#1-4SpringMVC-能干什么" class="headerlink" title="1.4SpringMVC 能干什么"></a>1.4SpringMVC 能干什么</h2><ol><li>天生与 Spring 框架集成，如：(IOC,AOP)</li><li>支持 Restful 风格</li><li>进行更简洁的 Web 层开发</li><li>支持灵活的 URL 到页面控制器的映射</li><li>非常容易与其他视图技术集成，如:Velocity、FreeMarker 等等</li><li>因为模型数据不存放在特定的 API 里，而是放在一个 Model 里(Map 数据结构实现， 因此很容易被其他框架使用)</li><li>非常灵活的数据验证、格式化和数据绑定机制、能使用任何对象进行数据绑定， 不必实现特定框架的 API</li><li>更加简单、强大的异常处理</li><li>对静态资源的支持</li><li>支持灵活的本地化、主题等解析</li></ol><h2 id="1-5-SpringMVC-常用组件"><a href="#1-5-SpringMVC-常用组件" class="headerlink" title="1.5 SpringMVC 常用组件"></a>1.5 SpringMVC 常用组件</h2><ul><li>DispatcherServlet：前端控制器</li><li>Controller：处理器&#x2F;页面控制器，做的是 MVC 中的 C 的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理</li><li>HandlerMapping ：请求映射到处理器，找谁来处理，如果映射成功返回一个 HandlerExecutionChain 对象（包含一个 Handler 处理器(页面控制器)对象、多 个 HandlerInterceptor 拦截器对象）</li><li>ViewResolver: 视图解析器，找谁来处理返回的页面。把逻辑视图解析为具体 的 View,进行这种策略模式，很容易更换其他视图技术； 如 InternalResourceViewResolver 将逻辑视图名映射为 JSP 视图</li><li>LocalResolver：本地化、国际化</li><li>MultipartResolver：文件上传解析器</li><li>HandlerExceptionResolver：异常处理器</li></ul><h2 id="1-6-SpringMVC常用注解"><a href="#1-6-SpringMVC常用注解" class="headerlink" title="1.6 SpringMVC常用注解"></a>1.6 SpringMVC常用注解</h2><p>@Controller</p><p>　　负责注册一个bean 到spring 上下文中<br>@RequestMapping</p><p>　　注解为控制器指定可以处理哪些 URL 请求<br>@RequestBody</p><p>　　该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上 ,再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上<br>    浏览器发ajax请求，设置成contentType:”application&#x2F;json”,以json字符串的方式发送对象，服务器端通过@RequestBody把接受道德字符串转成java对象</p><p>@ResponseBody</p><p>　　 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区</p><p>@RestController</p><p>​     </p><p>@ModelAttribute 　　　</p><p>　　在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法</p><p>　　在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数 –绑定到对象中，再传入入参将方法入参对象添加到模型中 </p><p>@RequestParam　</p><p>　　在处理方法入参处使用 @RequestParam 可以把请求参 数传递给请求方法</p><p>@PathVariable</p><p>　　绑定 URL 占位符到入参<br>@ExceptionHandler</p><p>　　注解到方法上，出现异常时会执行该方法<br>@ControllerAdvice</p><p>　　使一个Contoller成为全局的异常处理类，类中用@ExceptionHandler方法注解的方法可以处理所有Controller发生的异常</p><h1 id="2-SpringMVC-HelloWorld"><a href="#2-SpringMVC-HelloWorld" class="headerlink" title="2 SpringMVC-HelloWorld"></a>2 SpringMVC-HelloWorld</h1><h2 id="2-1-新建-maven工程，添加web支持，引入各种-jar-包依赖"><a href="#2-1-新建-maven工程，添加web支持，引入各种-jar-包依赖" class="headerlink" title="2.1.新建 maven工程，添加web支持，引入各种 jar 包依赖"></a>2.1.新建 maven工程，添加web支持，引入各种 jar 包依赖</h2><p><img src="http://cdn.leafii.top/img/20220520170321.png" loading="lazy"><br><img src="http://cdn.leafii.top/img/20220520170338.png" loading="lazy"><br><img src="http://cdn.leafii.top/img/20220520170353.png" loading="lazy"><br><img src="http://cdn.leafii.top/img/20220520170403.png" loading="lazy"></p><h2 id="2-2-引入jar包依赖"><a href="#2-2-引入jar包依赖" class="headerlink" title="2.2 引入jar包依赖"></a>2.2 引入jar包依赖</h2><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.2.0.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="2-3-在-web-xml-中配置-DispatcherServlet"><a href="#2-3-在-web-xml-中配置-DispatcherServlet" class="headerlink" title="2.3. 在 web.xml 中配置 DispatcherServlet"></a>2.3. 在 web.xml 中配置 DispatcherServlet</h2><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span>        <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd<span class="token punctuation">"</span></span>        <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3.1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 配置 SpringMVC 核心控制器： --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springDispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 配置 DispatcherServlet 的初始化參數：设置文件的路径和文件名称 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:springmvc.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springDispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--拦截所有请求--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span></code></pre><p>*<em>拦截所有请求应该将url-pattern的&#x2F;换成&#x2F;<em>，这样可以拦截一切请求</em></em><br><img src="http://cdn.leafii.top/img/20220520170452.png" loading="lazy"><br>新建对应的目录并且将其标记：<br><img src="http://cdn.leafii.top/img/20220520170505.png" loading="lazy"></p><h2 id="2-4-加入-SpringMVC-的配置文件：springmvc-xml"><a href="#2-4-加入-SpringMVC-的配置文件：springmvc-xml" class="headerlink" title="2.4 加入 SpringMVC 的配置文件：springmvc.xml"></a>2.4 加入 SpringMVC 的配置文件：springmvc.xml</h2><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 设置扫描组件的包： --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><h2 id="2-5-需要创建一个入口页面，index-jsp"><a href="#2-5-需要创建一个入口页面，index-jsp" class="headerlink" title="2.5 需要创建一个入口页面，index.jsp"></a>2.5 需要创建一个入口页面，index.jsp</h2><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pageContext.request.contextPath&#125;/helloworld<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>HelloWorld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><h2 id="2-6-编写处理请求的处理器，并标识为处理器"><a href="#2-6-编写处理请求的处理器，并标识为处理器" class="headerlink" title="2.6 编写处理请求的处理器，并标识为处理器"></a>2.6 编写处理请求的处理器，并标识为处理器</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">net<span class="token punctuation">.</span>suncaper<span class="token punctuation">.</span>controller</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Controller</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMapping</span></span><span class="token punctuation">;</span> <span class="token comment">/** * @author nedli */</span><span class="token comment">//1. 用@Controller告诉Spring MVC这是一个处理器，可以处理页面请求</span><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//2. 标志此方法处理 /hello 请求</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//3. 返回.jsp页面的路径，很麻烦</span>        <span class="token keyword">return</span> <span class="token string">"/WEB-INF/views/hello.jsp"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="2-7-配置视图解析器（简化路径配置）"><a href="#2-7-配置视图解析器（简化路径配置）" class="headerlink" title="2.7. 配置视图解析器（简化路径配置）"></a>2.7. 配置视图解析器（简化路径配置）</h2><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 配置视图解析器：如何将控制器返回的结果字符串，转换为一个物理的视图文件（拼接页面地址）--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>internalResourceViewResolver<span class="token punctuation">"</span></span>          <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/WEB-INF/views/<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>这个时候Controller改为</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">net<span class="token punctuation">.</span>suncaper<span class="token punctuation">.</span>controller</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Controller</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMapping</span></span><span class="token punctuation">;</span> <span class="token comment">/** * @author nedli */</span><span class="token comment">//1. 用@Controller告诉Spring MVC这是一个处理器，可以处理页面请求</span><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//2. 标志此方法处理 /hello 请求,使用hello也是一样的效果哦</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//3. 返回.jsp页面的路径</span>        <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="2-8-部署测试"><a href="#2-8-部署测试" class="headerlink" title="2.8.部署测试"></a>2.8.部署测试</h2><p><a href="http://localhost:8080/SpringMVC_01_HelloWorld/index.jsp">http://localhost:8080/SpringMVC_01_HelloWorld&#x2F;index.jsp</a></p><h1 id="3-HelloWorld-深度解析"><a href="#3-HelloWorld-深度解析" class="headerlink" title="3. HelloWorld 深度解析"></a>3. HelloWorld 深度解析</h1><h2 id="3-1-HelloWorld-请求流程图解："><a href="#3-1-HelloWorld-请求流程图解：" class="headerlink" title="3.1 HelloWorld 请求流程图解："></a>3.1 HelloWorld 请求流程图解：</h2><p><img src="http://cdn.leafii.top/img/20220520170525.png" loading="lazy"><br><strong>一般请求的映射路径名称和处理请求的方法名称最好一致（实质上方法名称任意);</strong></p><p><strong>经常有同学会出现配置上错误，把“&#x2F;WEB-INF&#x2F;views&#x2F;”配置成了 “&#x2F;WEB-INF&#x2F;views”;</strong></p><h2 id="3-2-流程分析"><a href="#3-2-流程分析" class="headerlink" title="3.2 流程分析"></a>3.2 流程分析</h2><p><img src="http://cdn.leafii.top/img/20220520170540.png" loading="lazy"></p><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤:"></a>基本步骤:</h1><ul><li>客户端请求提交到 DispatcherServlet</li><li>由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的 Controller</li><li>DispatcherServlet 将请求提交到 Controller（也称为 Handler）</li><li>Controller 调用业务逻辑处理后，返回 ModelAndView</li><li>DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，找到 ModelAndView 指定的视图</li><li>视图负责将结果显示到客户端.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中JavaBeanの生命周期和作用域</title>
      <link href="/2020/04/30/Spring%E4%B8%ADJavaBean%E3%81%AE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2020/04/30/Spring%E4%B8%ADJavaBean%E3%81%AE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Bean的生命周期和作用域"><a href="#Bean的生命周期和作用域" class="headerlink" title="Bean的生命周期和作用域"></a>Bean的生命周期和作用域</h1><h2 id="Bean的”懒加载“"><a href="#Bean的”懒加载“" class="headerlink" title="Bean的”懒加载“"></a>Bean的”懒加载“</h2><p><img src="http://cdn.leafii.top/img/20220520173304.png" loading="lazy"><br>这样编写代码，bean便会在需要的时候注入对象而不是直接注入所有对象。</p><span id="more"></span><ul><li>需要对象时：<img src="http://cdn.leafii.top/img/20220520173342.png" loading="lazy"></li><li>不需要对象时：<img src="http://cdn.leafii.top/img/20220520173417.png" loading="lazy"></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>如果像下图一样获取同一个bean给两个不同命名的Student，其实还是只有一个对象， 他们的hashcode相同<br><img src="http://cdn.leafii.top/img/20220520173439.png" loading="lazy"><br>如果在bean中增加scope属性为prototype，那么就不是单例模式了：<img src="http://cdn.leafii.top/img/20220520173456.png" loading="lazy"></p><h2 id="bean-的作用域"><a href="#bean-的作用域" class="headerlink" title="bean 的作用域"></a>bean 的作用域</h2><p>在 Spring 中，可以在<bean>元素的 scope 属性里设置 bean 的作用域，以决定这个 bean 是单实例的还是多实例的。</p><p>默认情况下，Spring 只为每个在 IOC 容器里声明的 bean 创建唯一一个实例，整个 IOC 容器范围内都能共享该实例：所有后续的 getBean()调用和 bean 引用都将返回这个唯一的 bean 实例。该作用域被称为 singleton，它是所有 bean 的默认作用域。<br><img src="http://cdn.leafii.top/img/20220520173513.png" loading="lazy"><br>当 bean 的作用域为单例时，Spring 会在 IOC 容器对象创建时就创建 bean 的对象实例。而当 bean 的作用域为 prototype 时，IOC 容器在获取 bean 的实例时创建 bean 的实例对象。</p><h2 id="bean-的生命周期"><a href="#bean-的生命周期" class="headerlink" title="bean 的生命周期"></a>bean 的生命周期</h2><ul><li>Spring IOC 容器可以管理 bean 的生命周期，Spring 允许在 bean 生命周期内特定的时间点执行指定的任务。</li><li>Spring IOC 容器对 bean 的生命周期进行管理的过程：<ol><li>通过构造器或工厂方法创建 bean 实例</li><li>为 bean 的属性设置值和对其他 bean 的引用</li><li>调用 bean 的初始化方法</li><li>bean 可以使用了</li><li>当容器关闭时，调用 bean 的销毁方法</li></ol></li><li>在配置 bean 时，通过 init-method 和 destroy-method 属性为 bean 指定初始化和销毁方法：</li></ul><p><code>&lt;bean name=&quot;user&quot; class=&quot;com.bean.User&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;</code></p><ul><li>bean 的后置处理器<ul><li>bean 后置处理器允许在调用初始化方法前后对 bean 进行额外的处理</li><li>bean 后置处理器对 IOC 容器里的所有 bean 实例逐一处理，而非单一实例。其典型应用是：检查 bean 属性的正确性或根据特定的标准更改 bean 的属性。</li><li>bean 后置处理器时需要实现接口：org.springframework.beans.factory.config.BeanPostProcessor。在初始化方法被调用前后，Spring 将把每个 bean 实例分别传递给上述接口的以下两个方法：postProcessBeforeInitialization(Object, String)、postProcessAfterInitialization(Object, String)</li></ul></li><li>添加 bean 后置处理器后 bean 的生命周期<br>①通过构造器或工厂方法创建 bean 实例<br>②为 bean 的属性设置值和对其他 bean 的引用<br>③将 bean 实例传递给 bean 后置处理器的 postProcessBeforeInitialization()方法<br>④调用 bean 的初始化方法<br>⑤将 bean 实例传递给 bean 后置处理器的 postProcessAfterInitialization()方法<br>⑥bean 可以使用了<br>⑦当容器关闭时调用 bean 的销毁方法</li></ul><h2 id="引用外部属性文件"><a href="#引用外部属性文件" class="headerlink" title="引用外部属性文件"></a>引用外部属性文件</h2><p>当 bean 的配置信息逐渐增多时，查找和修改一些 bean 的配置信息就变得愈加困难。这时可以将一部分信息提取到 bean 配置文件的外部，以 properties 格式的属性文件保存起来，同时在 bean 的配置文件中引用 properties 属性文件中的内容，从而实现一部分属性值在发生变化时仅修改 properties 属性文件即可。这种技术多用于连接数据库的基本信息的配置。</p><h3 id="直接配置："><a href="#直接配置：" class="headerlink" title="直接配置："></a>直接配置：</h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mchange.v2.c3p0.ComboPooledDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc:mysql:127.0.0.1:3306/test<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h3 id="使用外部的属性文件"><a href="#使用外部的属性文件" class="headerlink" title="使用外部的属性文件"></a>使用外部的属性文件</h3><h4 id="创建-properties-属性文件"><a href="#创建-properties-属性文件" class="headerlink" title="创建 properties 属性文件"></a>创建 properties 属性文件</h4><pre class="language-prop" data-language="prop"><code class="language-prop">prop.userName&#x3D;rootprop.password&#x3D;rootprop.url&#x3D;jdbc:mysql:127.0.0.1:3306&#x2F;testprop.driverClass&#x3D;com.mysql.jdbc.Driver</code></pre><p>从 properties 属性文件中引入属性值</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!--</span> <span class="token attr-name">指定properties属性文件的位置</span> <span class="token attr-name"><span class="token namespace">→&lt;context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath:jdbc.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 从properties属性文件中引入属性值 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mchange.v2.c3p0.ComboPooledDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;prop.userName&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;prop.password&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;prop.url&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;prop.driverClass&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>手动装配：以 value 或 ref 的方式明确指定属性值都是手动装配。</li><li>自动装配：根据指定的装配规则，不需要明确指定，Spring 自动将匹配的属性值注入 bean 中。</li></ul><h3 id="装配模式"><a href="#装配模式" class="headerlink" title="装配模式"></a>装配模式</h3><ul><li>根据类型自动装配：将类型匹配的 bean 作为属性注入到另一个 bean 中。若 IOC 容器中有多个与目标 bean 类型一致的 bean，Spring 将无法判定哪个 bean 最合适该属性，所以不能执行自动装配</li><li>根据名称自动装配：必须将目标 bean 的名称和属性名设置的完全相同</li><li>通过构造器自动装配：当 bean 中存在多个构造器时，此种自动装配方式将会很复杂。不推荐使用。</li></ul><h2 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring Expression Language，Spring 表达式语言，简称 SpEL。支持运行时查询并可以操作对象图。和 JSP 页面上的 EL 表达式一样，SpEL 根据 JavaBean 风格的 getXxx()、setXxx()方法定义的属性访问对象图，完全符合我们熟悉的操作习惯。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>SpEL 使用#{…}作为定界符，所有在大框号中的字符都将被认为是 SpEL 表达式。</p><h3 id="使用字面量"><a href="#使用字面量" class="headerlink" title="使用字面量"></a>使用字面量</h3><ul><li>整数：<property name="count" value="#{5}"/></li><li>小数：<property name="frequency" value="#{89.7}"/></li><li>科学计数法：<property name="capacity" value="#{1e4}"/></li><li>String 类型的字面量可以使用单引号或者双引号作为字符串的定界符号<pre class="language-none"><code class="language-none">&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;#&#123;&#39;Chuck&#39;&#125;&quot;&#x2F;&gt;&lt;property name&#x3D;&quot;name&quot; value&#x3D;&#39;#&#123;&quot;Chuck&quot;&#125;&#39;&#x2F;&gt;</code></pre></li><li>Boolean：<property name="enabled" value="#{false}"/></li><li>引用其他bean：<property name="detp" value="#{dept}"/></li><li>引用其他 bean 的属性值：<property name="deptName" value="#{dept.deptName}"/></li></ul><h2 id="通过注解配置-bean"><a href="#通过注解配置-bean" class="headerlink" title="通过注解配置 bean"></a>通过注解配置 bean</h2><p>不用注解的话就是这样的<img src="http://cdn.leafii.top/img/20220520173534.png" loading="lazy"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>相对于 XML 方式而言，通过注解的方式配置 bean 更加简洁和优雅，而且和 MVC 组件化开发的理念十分契合，是开发中常用的使用方式。</p><h3 id="使用注解标识组件"><a href="#使用注解标识组件" class="headerlink" title="使用注解标识组件"></a>使用注解标识组件</h3><ul><li>普通组件：@Component   标识一个受 Spring IOC 容器管理的组件</li><li>持久化层组件：@Repository    标识一个受 Spring IOC 容器管理的持久化层组件</li><li>业务逻辑层组件：@Service    标识一个受 Spring IOC 容器管理的业务逻辑层组件</li><li>表述层控制器组件：@Controller     标识一个受 Spring IOC 容器管理的表述层控制器组件</li><li>组件命名规则：<br>①默认情况：使用组件的简单类名首字母小写后得到的字符串作为 bean 的 id（类名为HelloWorld，则在容器中的bean的id为helloWorld）<br>②使用组件注解的 value 属性指定 bean 的 id<br><strong>注意：事实上 Spring 并没有能力识别一个组件到底是不是它所标记的类型，即使将@Respository 注解用在一个表述层控制器组件上面也不会产生任何错误，所以@Respository、@Service、@Controller 这几个注解仅仅是为了让开发人员自己明确 当前的组件扮演的角色。</strong></li></ul><h3 id="扫描组件"><a href="#扫描组件" class="headerlink" title="扫描组件"></a>扫描组件</h3><p>组件被上述注解标识后还需要通过 Spring 进行扫描才能够侦测到。</p><ul><li>指定被扫描的 package</li></ul><p><code>&lt;context:component-scan base-package=&quot;com.component&quot;/&gt;</code></p><ul><li>base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包及其子包中的所有类。</li><li>当需要扫描多个包时可以使用逗号分隔。</li><li>如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属性过滤特定的类</li><li>JAR 包必须在原有 JAR 包组合的基础上再导入一个：spring-aop-4.0.0.RELEASE.jar<br><img src="http://cdn.leafii.top/img/20220520173555.png" loading="lazy"><br><img src="http://cdn.leafii.top/img/20220520173615.png" loading="lazy"><br>但是后面的解析位置现在包含了解析器的功能，因此一般 不写引入解析器的那一行<pre class="language-none"><code class="language-none">&lt;context:annotation-config&gt;&lt;&#x2F;context:annotation-config&gt;</code></pre></li></ul><h3 id="组件装配"><a href="#组件装配" class="headerlink" title="组件装配"></a>组件装配</h3><ul><li><p>需求<br>  Controller 组件中往往需要用到 Service 组件的实例，Service 组件中往往需要用到Repository 组件的实例。Spring 可以通过注解的方式帮我们实现属性的装配。</p></li><li><p>实现依据<br>  在指定要扫描的包时，<a href="context:component-scan">context:component-scan</a> 元素会自动注册一个 bean 的后置处理器：AutowiredAnnotationBeanPostProcessor 的实例。该后置处理器可以自动装配标记了@Autowired、@Resource 或@Inject 注解的属性。</p></li><li><p>@Autowired 注解（重点）<br>  ①根据类型实现自动装配。</p><p>  ②构造器、普通字段(即使是非 public)、一切具有参数的方法都可以应用@Autowired 注解</p><p>  ③默认情况下，所有使用@Autowired 注解的属性都需要被设置。当 Spring 找不到匹配的 bean 装配属性时，会抛出异常。</p><p>  ④若某一属性允许不被设置，可以设置@Autowired 注解的 required 属性为 false</p><p>  ⑤默认情况下，当 IOC 容器里存在多个类型兼容的 bean 时，Spring 会尝试匹配 bean的 id 值是否与变量名相同，如果相同则进行装配。如果 bean 的 id 值不相同，通过类型的自动装配将无法工作。此时可以在@Qualifier 注解里提供 bean的名称。Spring 甚至允许在方法的形参上标注@Qualifiter 注解以指定注入 bean 的名称。</p><p>  ⑥@Autowired 注解也可以应用在数组类型的属性上，此时 Spring 将会把所有匹配的 bean 进行自动装配。</p><p>  ⑦@Autowired 注解也可以应用在集合属性上，此时 Spring 读取该集合的类型信息，然后自动装配所有与之兼容的 bean。</p><p>  ⑧@Autowired 注解用在 java.util.Map 上时，若该 Map 的键值为 String，那么 Spring 将自动装配与值类型兼容的 bean 作为值，并以 bean 的 id 值作为键。<br>  <img src="http://cdn.leafii.top/img/20220520173648.png" loading="lazy"></p></li><li><p>@Resource<br>  @Resource 注解要求提供一个 bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 bean 的名称。</p></li><li><p>@Inject<br>  @Inject 和@Autowired 注解一样也是按类型注入匹配的 bean，但没有 reqired 属性。<br>  <strong>可以在@Resource之类的注解后加上括号，自定义注入对象的名称</strong><br>  <img src="http://cdn.leafii.top/img/20220520173704.png" loading="lazy"><br>  运行结果：<br>  <img src="http://cdn.leafii.top/img/20220520173720.png" loading="lazy"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringIOC容器</title>
      <link href="/2020/04/30/SpringIOC%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/04/30/SpringIOC%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringIOC容器"><a href="#SpringIOC容器" class="headerlink" title="SpringIOC容器"></a>SpringIOC容器</h1><p><strong>本文章用的环境紧贴上一篇</strong></p><h1 id="各种类型的装配"><a href="#各种类型的装配" class="headerlink" title="各种类型的装配"></a>各种类型的装配</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>只保留spring-beans.xml的内容，所以将spring-beans1.xml的bean标签复制到spring-beans.xml中</li><li>当要装配的实体对象中还有实体对象时，可以用下面两种方法装配</li></ol><span id="more"></span><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.springdemo.demo1helloworld.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>AA<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>mikutown<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--以上两种方式无差异--></span>        <span class="token comment">&lt;!--什么时候用以上的那种子标签呢？如果value里有很多很多很多文字就可以用这个方式了 增强代码的可读性--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuNo<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu007<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!--第一种方式：&lt;property name="student" ref="s1"/>--></span><span class="token comment">&lt;!--第二种方式：--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.springdemo.demo1helloworld.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>aa<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>yyss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!--以上两种方式无差异--></span>                <span class="token comment">&lt;!--什么时候用以上的那种子标签呢？如果value里有很多很多很多文字就可以用这个方式了 增强代码的可读性--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuNo<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu009<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p><img src="http://cdn.leafii.top/img/20220520173820.png" loading="lazy"></p><ol start="3"><li>如图所示，可以看到 context可以看到Student但是Student看不到context，IOC可以控制Student类的生命周期，目前的情况而言，两个对象分别是applicationContext和student，applicationContext可以控制student，这种控制称为正常控制，反之则不行<img src="http://cdn.leafii.top/img/20220520173834.png" loading="lazy"></li></ol><h2 id="IOC-Inversion-of-Control-：-反转控制-控制反转"><a href="#IOC-Inversion-of-Control-：-反转控制-控制反转" class="headerlink" title="IOC(Inversion of Control)： 反转控制(控制反转)"></a>IOC(Inversion of Control)： 反转控制(控制反转)</h2><p>在应用程序中的组件需要获取资源时，传统的方式是组件主动的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。</p><p>反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的被动形式。</p><h2 id="DI-Dependency-Injection-：依赖注入"><a href="#DI-Dependency-Injection-：依赖注入" class="headerlink" title="DI(Dependency Injection)：依赖注入"></a>DI(Dependency Injection)：依赖注入</h2><p>IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如：setter 方法)接受来自于容器的资源注入。相对于 IOC 而言，这种表述更直接。</p><h2 id="IOC-容器在-Spring-中的实现"><a href="#IOC-容器在-Spring-中的实现" class="headerlink" title="IOC 容器在 Spring 中的实现"></a>IOC 容器在 Spring 中的实现</h2><ul><li>在通过 IOC 容器读取 Bean 的实例之前，需要先将 IOC 容器本身实例化。</li><li>Spring 提供了 IOC 容器的两种实现方式</li></ul><ol><li>BeanFactory：IOC 容器的基本实现，是 Spring 内部的基础设施，是面向Spring 本身的，不是提供给开发人员使用的。</li><li>ApplicationContext：BeanFactory 的子接口，提供了更多高级特性。面向Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的BeanFactory。</li></ol><ul><li>ApplicationContext 的主要实现类</li></ul><ol><li>ClassPathXmlApplicationContext：对应类路径下的 XML 格式的配置文件</li><li>FileSystemXmlApplicationContext：对应文件系统中的 XML 格式的配置文件</li></ol><h2 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h2><h3 id="创建实体类Student"><a href="#创建实体类Student" class="headerlink" title="创建实体类Student"></a>创建实体类Student</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> studentId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> studentName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token comment">//构造getter，setter忽略</span><span class="token punctuation">&#125;</span></code></pre><h3 id="通过-bean-的-setXxx-方法赋值"><a href="#通过-bean-的-setXxx-方法赋值" class="headerlink" title="通过 bean 的 setXxx()方法赋值"></a>通过 bean 的 setXxx()方法赋值</h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.helloworld.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 使用property子元素为bean的属性赋值,实际是调用setter方法，若实体类没有setter方法，报错 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>studentId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1001<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Tom2015<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h3 id="通过-bean-的构造器赋值"><a href="#通过-bean-的构造器赋值" class="headerlink" title="通过 bean 的构造器赋值"></a>通过 bean 的构造器赋值</h3><ul><li>Spring 自动匹配合适的构造器</li></ul><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.helloworld.bean.Student<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>10010<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>Tom2015<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span> <span class="token punctuation">></span></span></code></pre><ul><li>通过索引值指定参数位置</li></ul><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s3<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.helloworld.bean.Student<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>10010<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>Tom2015<span class="token punctuation">"</span></span>  <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>20<span class="token punctuation">"</span></span>  <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span> <span class="token punctuation">></span></span></code></pre><ul><li>通过类型区分重载的构造器</li></ul><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s3<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.helloworld.bean.Student<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>10010<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Integer<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>Tom2015<span class="token punctuation">"</span></span>  <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span>  <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>20<span class="token punctuation">"</span></span>  <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span>  <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Integer<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span> <span class="token punctuation">></span></span></code></pre><h2 id="p-名称空间"><a href="#p-名称空间" class="headerlink" title="p 名称空间"></a>p 名称空间</h2><p>为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过<bean>元素属性的方式配置 Bean 的属性。(记得导包，不然要报错)<br><img src="http://cdn.leafii.top/img/20220520173854.png" loading="lazy"><br>使用 p 命名空间后，基于 XML 的配置方式将进一步简化。</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s4<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.helloworld.bean.Student<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">p:</span>studentId</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2002<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">p:</span>stuName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Jerry2016<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">p:</span>age</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>18<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p><strong>使用p名称空间时，不可以使用property标签否则会报错</strong></p><h2 id="可注入的值"><a href="#可注入的值" class="headerlink" title="可注入的值"></a>可注入的值</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><ul><li>可以使用字符串表示的值，可以通过 value 属性或 value 子节点的方式指定</li><li>基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式</li></ul><h3 id="null值"><a href="#null值" class="headerlink" title="null值"></a>null值</h3><ul><li>设置property 属性的子节点为<null/></li></ul><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s5<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.helloworld.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>studentId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1001<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>null</span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token comment">//忽略get和set，构造方法</span><span class="token punctuation">&#125;</span></code></pre><h3 id="创建类Customer"><a href="#创建类Customer" class="headerlink" title="创建类Customer"></a>创建类Customer</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Person</span> person<span class="token punctuation">;</span>    <span class="token comment">//忽略get和set</span>    <span class="token keyword">public</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>person <span class="token operator">=</span> person<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="内部-bean"><a href="#内部-bean" class="headerlink" title="内部 bean"></a>内部 bean</h3><p>当 bean 实例仅仅给一个特定的属性使用时，可以将其声明为内部 bean。内部bean 声明直接包含在<property>或<constructor-arg>元素里，不需要设置任何 id 或 name 属性,内部 bean 不能使用在任何其他地方。内部 bean 不能使用在任何其他地方。</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>CustomerBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.common.Customer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.common.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h3 id="外部bean"><a href="#外部bean" class="headerlink" title="外部bean"></a>外部bean</h3><p>可以使用 ‘ref’ 属性来引用已经定义的bean对象。</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>CustomerBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.common.Customer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PersonBean<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PersonBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.common.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h3 id="List注入"><a href="#List注入" class="headerlink" title="List注入"></a>List注入</h3><p>配置 java.util.List 类型的属性，需要指定<list>标签，在标签里包含一些元素。这些标签可以通过<value>指定简单的常量值，通过<ref>指定对其他 Bean 的引用。通过<bean> 指定内置 bean 定义。通过<null/>指定空元素。甚至可以内嵌其他集合。</p><p>配置 java.util.Set 需要使用<set>标签，定义的方法与 List 一样。</p><p>配置数组需要<array>标签，定义的方法与 List 一样。</p><h3 id="创建类Customer-1"><a href="#创建类Customer-1" class="headerlink" title="创建类Customer"></a>创建类Customer</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> persons<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="创建类Person"><a href="#创建类Person" class="headerlink" title="创建类Person"></a>创建类Person</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token comment">//忽略get和set，构造方法</span><span class="token punctuation">&#125;</span></code></pre><h3 id="注入list"><a href="#注入list" class="headerlink" title="注入list"></a>注入list</h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cc<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.spring.bean.Customer <span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 以字面量为值的 List 集合 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>李四<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>persons<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p2<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.common.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.common.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p><strong>list也可以使用array标签来装</strong></p><h2 id="Map注入"><a href="#Map注入" class="headerlink" title="Map注入"></a>Map注入</h2><p>Java.util.Map 通过<map>标签定义，<map>标签里可以使用多个<entry>作为子标签。每个条目包含一个键和一个值。必须在<key>标签里定义键。因为键和值的类型没有限制，所以可以自由地为它们指定<value>、<ref>、<bean>或<null/>元素。</p><p>可以将 Map 的键和值作为<entry>的属性定义：简单常量使用 key 和 value 来定义；bean 引用通过 key-ref 和 value-ref 属性定义。</p><h3 id="创建类Customer-2"><a href="#创建类Customer-2" class="headerlink" title="创建类Customer"></a>创建类Customer</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> map<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="创建类Person-1"><a href="#创建类Person-1" class="headerlink" title="创建类Person"></a>创建类Person</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token comment">//忽略get和set，构造方法</span><span class="token punctuation">&#125;</span></code></pre><h3 id="注入map"><a href="#注入map" class="headerlink" title="注入map"></a>注入map</h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cc<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.spring.bean.Customer <span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>person1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>key</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>person2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>key</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p2<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.common.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.common.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h2 id="通过容器获取-bean"><a href="#通过容器获取-bean" class="headerlink" title="通过容器获取 bean"></a>通过容器获取 bean</h2><h3 id="通过id-值获取"><a href="#通过id-值获取" class="headerlink" title="通过id 值获取"></a>通过id 值获取</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//1.创建IOC容器对象</span><span class="token class-name">ApplicationContext</span> iocContainer <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"配置文件路径"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2.根据id值获取bean实例对象</span><span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> iocContainer<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"配置文件的id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="通过类型获取-bean"><a href="#通过类型获取-bean" class="headerlink" title="通过类型获取 bean"></a>通过类型获取 bean</h3><ul><li>从 IOC 容器中获取 bean 时，除了通过 id 值获取，还可以通过 bean 的类型获取。但如果同一个类型的 bean 在 XML 文件中配置了多个，则获取时会抛出异常，所以同一个类型的 bean 在容器中必须是唯一的。否则就会报错：<img src="http://cdn.leafii.top/img/20220520173916.png" loading="lazy"></li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//1.创建IOC容器对象</span><span class="token class-name">ApplicationContext</span> iocContainer <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"配置文件路径"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2.根据id值获取bean实例对象</span><span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> iocContainer<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="通过类型和id获取-bean"><a href="#通过类型和id获取-bean" class="headerlink" title="通过类型和id获取 bean"></a>通过类型和id获取 bean</h3><p>使用另外一个重载的方法，同时指定 bean 的 id 值和类型。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//1.创建IOC容器对象</span><span class="token class-name">ApplicationContext</span> iocContainer <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"配置文件路径"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2.根据id值获取bean实例对象</span><span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> iocContainer<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"id值"</span><span class="token punctuation">,</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="配置信息的继承"><a href="#配置信息的继承" class="headerlink" title="配置信息的继承"></a>配置信息的继承</h3><p>查看下面两个 Employee 的配置，其中 dept 属性是重复的:</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.parent.bean.Department<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IT<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp01<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.parent.bean.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1001<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Tom<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!-- 重复的属性值 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp02<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.parent.bean.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1002<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Jerry<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>25<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!-- 重复的属性值 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- amazing --></span></code></pre><p>配置信息的继承:</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.parent.bean.Department<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IT<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp01<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.parent.bean.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1001<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Tom<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!-- 重复的属性值 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 以emp01作为父bean，继承后可以省略公共属性值的配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp02<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp01<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1002<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Jerry<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>25<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>Spring 允许继承 bean 的配置，被继承的 bean 称为父 bean。继承这个父 bean 的 bean 称为子 bean 子 bean 从父 bean 中继承配置，包括 bean 的属性配置子 bean 也可以覆盖从父 bean 继承过来的配置。</p><p>父 bean 可以作为配置模板，也可以作为 bean 实例。若只想把父 bean 作为模板，可以设置<bean>的 abstract 属性为 true，这样 Spring 将不会实例化这个 bean。如果一个 bean 的 class 属性没有指定，则必须是抽象 bean，并不是<bean>元素里的所有属性都会被继承。比如：autowire，abstract 等。也可以忽略父 bean 的 class 属性，让子 bean 指定自己的类，而共享相同的属性配置。但此时 abstract 必须设为 true。</p><h3 id="bean-之间的依赖"><a href="#bean-之间的依赖" class="headerlink" title="bean 之间的依赖"></a>bean 之间的依赖</h3><p>有的时候创建一个 bean 的时候需要保证另外一个 bean 也被创建，这时我们称前面的 bean 对后面的 bean 有依赖。例如：要求创建 Employee 对象的时候必须创建 Department。</p><p>这里需要注意的是依赖关系不等于引用关系，Employee 即使依赖 Department 也可以不引用它。</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp03<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.parent.bean.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">depends-on</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1003<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>empName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Kate<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>21<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringIOCの多个配置文件读取方式</title>
      <link href="/2020/04/30/SpringIOC%E3%81%AE%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/04/30/SpringIOC%E3%81%AE%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>本篇文章的环境请查看上一篇</p><h1 id="SpringIOCの多个配置文件读取方式"><a href="#SpringIOCの多个配置文件读取方式" class="headerlink" title="SpringIOCの多个配置文件读取方式"></a>SpringIOCの多个配置文件读取方式</h1><h2 id="1-复制spring-beans-xml为spring-beans1-xml"><a href="#1-复制spring-beans-xml为spring-beans1-xml" class="headerlink" title="1. 复制spring-beans.xml为spring-beans1.xml"></a>1. 复制spring-beans.xml为spring-beans1.xml</h2><span id="more"></span><h2 id="2-在原文件中放s1，新的文件中放s2"><a href="#2-在原文件中放s1，新的文件中放s2" class="headerlink" title="2. 在原文件中放s1，新的文件中放s2"></a>2. 在原文件中放s1，新的文件中放s2<img src="http://cdn.leafii.top/img/20220520170605.png" loading="lazy"></h2><h2 id="3-修改Test-java"><a href="#3-修改Test-java" class="headerlink" title="3. 修改Test.java"></a>3. 修改Test.java<img src="http://cdn.leafii.top/img/20220520170621.png" loading="lazy"><img src="http://cdn.leafii.top/img/20220520170638.png" loading="lazy"></h2><h2 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4. 运行结果"></a>4. 运行结果</h2><pre class="language-none"><code class="language-none">log4j:WARN No appenders could be found for logger (org.springframework.core.env.StandardEnvironment).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http:&#x2F;&#x2F;logging.apache.org&#x2F;log4j&#x2F;1.2&#x2F;faq.html#noconfig for more info.settersetterStudent&#123;id&#x3D;&#39;qwer&#39;, name&#x3D;&#39;hkx&#39;, stuNo&#x3D;&#39;stu001&#39;, student&#x3D;null&#125;</code></pre><h2 id="5-倘或在spring-beans1-xml中添加"><a href="#5-倘或在spring-beans1-xml中添加" class="headerlink" title="5. 倘或在spring-beans1.xml中添加"></a>5. 倘或在spring-beans1.xml中添加</h2><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.springdemo.demo1helloworld.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>AA<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>yys<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--以上两种方式无差异--></span><span class="token comment">&lt;!--什么时候用以上的那种子标签呢？如果value里有很多很多很多文字就可以用这个方式了 增强代码的可读性--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuNo<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu007<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!--添加了上一行--></span><span class="token comment">&lt;!--这里的s1或许会报错，只是预编译错误，运行是没问题的，因为我们导入了两个xml文件进行注入--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>想要消除s1的错误，可以加一个import的标签在beans下<br><code>&lt;import resource=&quot;spring-beans.xml&quot;/&gt;</code><br>这样就不会编译错误了<br>在Test中添加打印student2<br>运行结果依旧正确奥！</p><pre class="language-none"><code class="language-none">log4j:WARN No appenders could be found for logger (org.springframework.core.env.StandardEnvironment).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http:&#x2F;&#x2F;logging.apache.org&#x2F;log4j&#x2F;1.2&#x2F;faq.html#noconfig for more info.settersetterStudent&#123;id&#x3D;&#39;qwer&#39;, name&#x3D;&#39;hkx&#39;, stuNo&#x3D;&#39;stu001&#39;, student&#x3D;null&#125;Student&#123;id&#x3D;&#39;AA&#39;, name&#x3D;&#39;yys&#39;, stuNo&#x3D;&#39;stu007&#39;, student&#x3D;Student&#123;id&#x3D;&#39;qwer&#39;, name&#x3D;&#39;hkx&#39;, stuNo&#x3D;&#39;stu001&#39;, student&#x3D;null&#125;&#125;</code></pre><h2 id="6-beans1文件中已经import了beans文件，其实就不需要在Test类中设置beans的引入啦！"><a href="#6-beans1文件中已经import了beans文件，其实就不需要在Test类中设置beans的引入啦！" class="headerlink" title="6. beans1文件中已经import了beans文件，其实就不需要在Test类中设置beans的引入啦！"></a>6. beans1文件中已经import了beans文件，其实就不需要在Test类中设置beans的引入啦！<img src="http://cdn.leafii.top/img/20220520170657.png" loading="lazy"></h2><p><strong>运行结果依旧正常</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringIOC容器のHelloWorld</title>
      <link href="/2020/04/30/SpringIOC%E5%AE%B9%E5%99%A8%E3%81%AEHelloWorld/"/>
      <url>/2020/04/30/SpringIOC%E5%AE%B9%E5%99%A8%E3%81%AEHelloWorld/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-IOC容器-の-HelloWorld"><a href="#Spring-IOC容器-の-HelloWorld" class="headerlink" title="Spring IOC容器 の HelloWorld"></a>Spring IOC容器 の HelloWorld</h1><h2 id="1-新建对象的项目和模块，maven项目"><a href="#1-新建对象的项目和模块，maven项目" class="headerlink" title="1.新建对象的项目和模块，maven项目"></a>1.新建对象的项目和模块，maven项目</h2><ol><li>新建一个项目，移除原有的模块，新建一个空白的java模块!</li><li><img src="http://cdn.leafii.top/img/20220520175010.png" loading="lazy"><span id="more"></span></li></ol><h2 id="2-通过maven导入spring对应的jar包"><a href="#2-通过maven导入spring对应的jar包" class="headerlink" title="2.通过maven导入spring对应的jar包"></a>2.通过maven导入spring对应的jar包</h2><ol><li><p>右键，add framework support 添加Maven支持，通过Maven导入spring对应的jar包：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.crud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>ssm-crud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>war<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>junit.version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>junit.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring.version</span><span class="token punctuation">></span></span>4.3.10.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mybatis.version</span><span class="token punctuation">></span></span>3.4.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mybatis.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mybatis.spring.version</span><span class="token punctuation">></span></span>1.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mybatis.spring.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>druid.version</span><span class="token punctuation">></span></span>1.1.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>druid.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-dbcp.version</span><span class="token punctuation">></span></span>1.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-dbcp.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jstl.version</span><span class="token punctuation">></span></span>1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jstl.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>log4j.version</span><span class="token punctuation">></span></span>1.2.17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>log4j.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fastjson.version</span><span class="token punctuation">></span></span>1.2.45<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fastjson.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slf4j.version</span><span class="token punctuation">></span></span>1.7.25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slf4j.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jackson.version</span><span class="token punctuation">></span></span>2.8.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jackson.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-fileupload.version</span><span class="token punctuation">></span></span>1.3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-fileupload.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-io.version</span><span class="token punctuation">></span></span>2.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-io.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-codec.version</span><span class="token punctuation">></span></span>1.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-codec.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aspectjweaver.version</span><span class="token punctuation">></span></span>1.8.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aspectjweaver.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- Junit测试 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;junit.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- spring包 core、web、oxm、tx、jdbc、webmvc、aop、context、test --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-oxm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-tx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context-support<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- mybatis核心包 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;mybatis.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- mybatis  代码生成器 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-generator-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- mybatis/spring包 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;mybatis.spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 导入Mysql数据库链接jar包 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.45<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--  阿里巴巴   --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;druid.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-dbcp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-dbcp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;commons-dbcp.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- JSTL标签类 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>jstl<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jstl<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;jstl.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 日志文件管理包 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;log4j.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--  &lt;dependency>              &lt;groupId>org.apache.logging.log4j&lt;/groupId>              &lt;artifactId>log4j-core&lt;/artifactId>              &lt;version>2.3&lt;/version>          &lt;/dependency>          &lt;dependency>              &lt;groupId>org.apache.logging.log4j&lt;/groupId>              &lt;artifactId>log4j-api&lt;/artifactId>              &lt;version>2.3&lt;/version>          &lt;/dependency>--></span>        <span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-jsp-api --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>tomcat-jsp-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>7.0.86<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>c3p0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>c3p0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 格式化对象，方便输出日志 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;fastjson.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>slf4j-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;slf4j.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>slf4j-log4j12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;slf4j.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- json和bean之间相互转换 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;jackson.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;jackson.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-annotations<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;jackson.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 上传组件包 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;commons-fileupload.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;commons-io.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-codec<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-codec<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;commons-codec.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.aspectj<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>aspectjweaver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;aspectjweaver.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax.servlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javax.servlet-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--能加载 java 文件夹中的资源文件 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- Jetty 插件  --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.eclipse.jetty<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jetty-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>9.4.8.v20171121<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scanIntervalSeconds</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scanIntervalSeconds</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>reload</span><span class="token punctuation">></span></span>automatic<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>reload</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>httpConnector</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">></span></span>8080<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>httpConnector</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stopKey</span><span class="token punctuation">></span></span>jettyStopKey1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stopKey</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stopPort</span><span class="token punctuation">></span></span>8520<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stopPort</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>webAppSourceDirectory</span><span class="token punctuation">></span></span>$&#123;basedir&#125;/web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>webAppSourceDirectory</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- Tomcat 7 插件--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.tomcat.maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>tomcat7-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">></span></span>8080<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>contextReloadable</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>contextReloadable</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>warSourceDirectory</span><span class="token punctuation">></span></span>$&#123;basedir&#125;/web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>warSourceDirectory</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!--  打war 的插件 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-war-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>warSourceDirectory</span><span class="token punctuation">></span></span>$&#123;basedir&#125;/web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>warSourceDirectory</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 编译java 文件 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>将以上代码的dependcy部分复制到pom.xml中的相应位置，静静等待包的下载完毕<br>2.复制java1.8的插件进入pom.xml<img src="http://cdn.leafii.top/img/20220520175029.png" loading="lazy"></p></li><li><p>配置resource,这样可以让我们的xml文件在指定的路径可以被读取，被粘贴的位置在build和plugins之间（build&gt;resources&#x3D;plugins)</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre></li></ol><h2 id="3-新建实体对象类和测试类"><a href="#3-新建实体对象类和测试类" class="headerlink" title="3.新建实体对象类和测试类"></a>3.新建实体对象类和测试类</h2><ul><li>创建javapackage，新建一个实体对象Student以及测试类<br>Student.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> id<span class="token punctuation">;</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token class-name">String</span> stuNo<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//无参构造，全参构造，以及全参的get set 省略</span></code></pre>HelloWorldTest.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//运行成功，可以进行下一步</span></code></pre></li></ul><h2 id="4-创建IOC容器"><a href="#4-创建IOC容器" class="headerlink" title="4.创建IOC容器"></a>4.创建IOC容器</h2><ol><li>新建spring配置文件（spring-xxx.xml   或 applicationContext-xx.xml)<br>spring-beans.xml<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 使用bean元素定义一个由IOC容器创建的对象 --></span>    <span class="token comment">&lt;!-- class属性指定用于创建bean的全类名 --></span>    <span class="token comment">&lt;!-- id属性指定用于引用bean实例的标识 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.helloworld.bean.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 使用property子元素为bean的属性赋值 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>studentId<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1001<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Tom2015<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>只复制这一些代码进去<br><img src="http://cdn.leafii.top/img/20220520175046.png" loading="lazy"></li></ol><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">BeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"spring-beans.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">log4j:WARN No appenders could be found for logger (org.springframework.core.env.StandardEnvironment).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http:&#x2F;&#x2F;logging.apache.org&#x2F;log4j&#x2F;1.2&#x2F;faq.html#noconfig for more info.org.springframework.context.support.ClassPathXmlApplicationContext@66048bfd: startup date [Thu Nov 14 17:08:33 CST 2019]; root of context hierarchy</code></pre>上面的警告是因为日志我们还没有配置，下方打印出了我们的beanFactory对象</li><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//        BeanFactory beanFactory = new ClassPathXmlApplicationContext("spring-beans.xml");</span><span class="token comment">//        System.out.println(beanFactory);</span>        <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">"qwer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setStuNo</span><span class="token punctuation">(</span><span class="token string">"stu001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"hkx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">Student&#123;id&#x3D;&#39;qwer&#39;, name&#x3D;&#39;hkx&#39;, stuNo&#x3D;&#39;stu001&#39;&#125;</code></pre></li></ul><ol start="2"><li>使用BeanFactory</li></ol><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">BeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"spring-beans.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"s1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//此时使用BeanFactory对实体类Student进行生产，可是模板是什么呢？</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><strong>此时要将spring-beans.xml进行完善，告诉BeanFactory模板是什么</strong></li></ul><ol start="3"><li>修改spring-beans.xml文件，在beans标签中添加以下代码<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--name属性可以容纳诸如"/abc"这样的名称，但是id不可以，当id中的"s1"无法被找到时将寻找name中的值。--></span><span class="token comment">&lt;!--最好是能用id就不用name--></span><span class="token comment">&lt;!--id对应的是test类中getBean的参数--></span><span class="token comment">&lt;!--    &lt;bean id="s1" name="s1">&lt;/bean>--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.springdemo.demo1helloworld.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre></li><li>再次修改xml文件，增加一个Student类的对象student2</li></ol><ul><li>spring-beans.xml<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.springdemo.demo1helloworld.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>AA<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>yys<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--以上两种方式无差异--></span><span class="token comment">&lt;!--什么时候用以上的那种子标签呢？如果value里有很多很多很多文字就可以用这个方式了 增强代码的可读性--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuNo<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu007<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!--注意在类中引用对象要用ref而不是value--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre></li><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">BeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"spring-beans.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Student</span> student1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"s1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Student</span> student2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"s2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//此时使用BeanFactory对实体类Student进行生产，可是模板是什么呢？</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"student1:"</span><span class="token operator">+</span>student1<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"student2:"</span><span class="token operator">+</span>student2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>运行结果（记得重写Student类的toString方法）<pre class="language-none"><code class="language-none">student1:Student&#123;id&#x3D;&#39;qwer&#39;, name&#x3D;&#39;hkx&#39;, stuNo&#x3D;&#39;stu001&#39;, student&#x3D;null&#125;student2:Student&#123;id&#x3D;&#39;AA&#39;, name&#x3D;&#39;yys&#39;, stuNo&#x3D;&#39;stu007&#39;, student&#x3D;Student&#123;id&#x3D;&#39;qwer&#39;, name&#x3D;&#39;hkx&#39;, stuNo&#x3D;&#39;stu001&#39;, student&#x3D;null&#125;&#125;</code></pre></li></ul><h2 id="5-注入"><a href="#5-注入" class="headerlink" title="5.注入"></a>5.注入</h2><ol><li>此时我们要想一下使用spring-beans.xml构造对象时，使用的是哪种方法，是按照参数的顺序直接进行构造方法，还是先new一个无参对象，再使用属性的set方法呢？</li><li>两种注入的方法:<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Student</span> student1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"idAAA"</span><span class="token punctuation">,</span><span class="token string">"hkx"</span><span class="token punctuation">,</span><span class="token string">"stu001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造注入</span><span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>student<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">"qwer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>student<span class="token punctuation">.</span><span class="token function">setStuNo</span><span class="token punctuation">(</span><span class="token string">"stu001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"hkx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//setter注入</span></code></pre></li><li>通过下图这样的测试，我们得知，使用spring-beans默认所使用的注入方法为setter注入<img src="http://cdn.leafii.top/img/20220520175106.png" loading="lazy"></li><li>但是可以通过指定的方式设置使用构造注入进行注入<br><img src="http://cdn.leafii.top/img/20220520175130.png" loading="lazy"><br><strong>使用constructor-arg标签之后，不关注属性名，只关注该属性值在构造函数中的位置</strong></li><li>此时我们放弃过时的BeanFactory,使用新的框架</li></ol><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"spring-beans.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//      BeanFactory beanFactory = new ClassPathXmlApplicationContext("spring-beans.xml");</span><span class="token comment">//      Student student2 = (Student) beanFactory.getBean("s2");</span>        <span class="token class-name">Student</span> student3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"s3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>新建对象的项目和模块，maven项目</li><li>通过maven导入spring对应的jar包</li><li>新建实体对象 类 和 测试类</li><li>创建IOC容器<br>4.1 新建spring配置文件（spring-xxx.xml 或 applicationContext-xx.xml）<br>4.2 写spring-xxx.xml<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.springdemo.demo1helloworld.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>qwer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>hkx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--以上两种方式无差异--></span><span class="token comment">&lt;!--什么时候用以上的那种子标签呢？如果value里有很多很多很多文字就可以用这个方式了 增强代码的可读性--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stuNo<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu001<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre>4.3 在实体类中添加“引用类型”的属性</li></ol><p><code>&lt;property name=&quot;student&quot; ref=&quot;s1&quot;/&gt;</code><br>   4.4 配置构造注入的方式</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s3<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.springdemo.demo1helloworld.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>idCCC<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yysssy<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu003<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><hr><p>需要掌握以下几点：</p><ol><li>简单类型和引用类型的配置方式：value和ref</li><li>构造注入的方式</li><li>IOC容器的创建  <pre class="language-none"><code class="language-none">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;spring-beans.xml&quot;);</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springの超简略简介</title>
      <link href="/2020/04/30/Spring%E3%81%AE%E8%B6%85%E7%AE%80%E7%95%A5%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/04/30/Spring%E3%81%AE%E8%B6%85%E7%AE%80%E7%95%A5%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学Spring？"><a href="#为什么要学Spring？" class="headerlink" title="为什么要学Spring？"></a>为什么要学Spring？</h1><ul><li>现在主流的框架SSM</li></ul><span id="more"></span><h2 id="S-gt-Spring-IOC容器"><a href="#S-gt-Spring-IOC容器" class="headerlink" title="S-&gt;Spring IOC容器"></a>S-&gt;Spring IOC容器</h2><ul><li>从今天开始写项目再也不能用这种语句<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">UserService</span> userService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//以后不能有这种 new 的语句了 基础类可以new，比如集合，字符串转码</span></code></pre>既然没法new 那么service怎么执行呢？<br>通过<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AutoWired</span>    <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span></code></pre>原来的new UserServiceImpl()就由Spring IOC替我们来完成<br>简单地说 Spring IOC 就是用来创建对象的（滑稽）</li></ul><h2 id="S-gt-Spring-mvc-分层"><a href="#S-gt-Spring-mvc-分层" class="headerlink" title="S-&gt;Spring mvc 分层"></a>S-&gt;Spring mvc 分层</h2><h2 id="M-gt-Mybatis-查数据库"><a href="#M-gt-Mybatis-查数据库" class="headerlink" title="M-&gt;Mybatis 查数据库"></a>M-&gt;Mybatis 查数据库</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatisの关联查询</title>
      <link href="/2020/04/21/Mybatis%E3%81%AE%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/"/>
      <url>/2020/04/21/Mybatis%E3%81%AE%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatisの关联查询"><a href="#Mybatisの关联查询" class="headerlink" title="Mybatisの关联查询"></a>Mybatisの关联查询</h1><h2 id="开始前的准备"><a href="#开始前的准备" class="headerlink" title="开始前的准备"></a>开始前的准备</h2><ul><li>数据库 <span id="more"></span><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">database</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">create</span>  <span class="token keyword">database</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">use</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span><span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span>  <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span>  <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'员工名称'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'王五'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'王六'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'王八'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span>  <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span>  <span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span>  <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'部门名称'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'技术部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'市场部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'销售部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>emp_dept<span class="token punctuation">`</span></span><span class="token punctuation">(</span>  emp_id <span class="token keyword">int</span><span class="token punctuation">,</span>  dept_id <span class="token keyword">int</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>emp_id<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>dept_id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp_dept <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp_dept <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp_dept <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp_dept <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp_dept <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>先导入前三个表，第三个表数据先别insert</li><li>导入mybatis_guanlian_select1项目，此项目的代码都已经用generator生成好了：<a href="https://pan.baidu.com/s/1DoGVquuh1AX-gsXlyKt0ng">密码930b</a></li><li>要实现关联查询，必须要第三张表，表的内容是两个关联表的主键，否则会造成数据冗余<br><img src="http://cdn.leafii.top/img/20220520174744.png" loading="lazy"></li></ul><h2 id="一对一关联查询"><a href="#一对一关联查询" class="headerlink" title="一对一关联查询"></a>一对一关联查询</h2><ol><li>生成的Employee实体类并没有关于部门的字段（因为原来的表没有部门的字段），所以我们现在要添加对应的部门字段<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Dept</span> dept<span class="token punctuation">;</span><span class="token comment">//对应的get set方法省略</span></code></pre></li><li>进入测试类<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> employees <span class="token operator">=</span> employeeMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span>                employees<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Dept</span> dept <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getDept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"->"</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dept<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">?</span>dept<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"天堂"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre></li></ol><ul><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, name from employee DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 5张三-&gt;天堂李四-&gt;天堂王五-&gt;天堂王六-&gt;天堂王八-&gt;天堂</code></pre><strong>由此可知此方法无法select到dept对象！</strong></li></ul><ol start="3"><li>在before里设置自动提交</li></ol><p><code>sqlSession = sqlSessionFactory.openSession(true);</code><br>（或者在after里编写自动提交代码）<br><code>sqlSession.commit()</code><br>（或者像这样编写）<br><img src="http://cdn.leafii.top/img/20220520174804.png" loading="lazy"><br>4. 新增一名employee，name为龙哥，发现需要使用左连接才能查询到龙哥的信息：</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employee e <span class="token keyword">left</span> <span class="token keyword">join</span> emp_dept ed <span class="token keyword">on</span> e<span class="token punctuation">.</span>id<span class="token operator">=</span>ed<span class="token punctuation">.</span>emp_id<span class="token keyword">left</span> <span class="token keyword">join</span> dept d <span class="token keyword">on</span> d<span class="token punctuation">.</span>id<span class="token operator">=</span>ed<span class="token punctuation">.</span>dept_id<span class="token punctuation">;</span></code></pre><ul><li>查询结果<br><img src="http://cdn.leafii.top/img/20220520174820.png" loading="lazy"></li></ul><ol start="5"><li>此时发现查询的数据有我们不需要的，我们修改一下sql语句<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> e<span class="token punctuation">.</span>id<span class="token punctuation">,</span>e<span class="token punctuation">.</span>name<span class="token punctuation">,</span>dept_id<span class="token punctuation">,</span>d<span class="token punctuation">.</span>name <span class="token string">'dept_name'</span> <span class="token keyword">from</span> employee e <span class="token keyword">join</span> emp_dept ed <span class="token keyword">on</span> e<span class="token punctuation">.</span>id<span class="token operator">=</span>ed<span class="token punctuation">.</span>emp_id<span class="token keyword">join</span> dept d <span class="token keyword">on</span> d<span class="token punctuation">.</span>id<span class="token operator">=</span>ed<span class="token punctuation">.</span>dept_id<span class="token punctuation">;</span></code></pre></li></ol><ul><li>查询结果<br><img src="http://cdn.leafii.top/img/20220520174835.png" loading="lazy"></li></ul><ol start="6"><li>编写一对一查询方法</li></ol><ul><li>初步Mapper.xml<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   select   e.id,e.name,dept_id,d.name 'dept_name'   from employee e   join emp_dept ed   on e.id=ed.emp_id   join dept d   on d.id=ed.dept_id; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>此时发现映射的resultMap只有<img src="http://cdn.leafii.top/img/20220520174848.png" loading="lazy"><br>因此我们需要改写resultMap</li></ul><p>&#x3D;-&#x3D;完整版&#x3D;-&#x3D;</p><ul><li><p>Mapper.java</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> <span class="token function">selectAllEmployeeWithDept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Mapper.xml</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatisdemo.domain.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_id<span class="token punctuation">"</span></span>  <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--association是负责将Dept在一对一查询中关联起来--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectAllEmployeeWithDept<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select    e.id,e.name,dept_id,d.name 'dept_name'    from employee e    left join emp_dept ed    on e.id=ed.emp_id    left join dept d    on d.id=ed.dept_id;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>Test.java</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectAllEmployeeWithDept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> employees <span class="token operator">=</span> employeeMapper<span class="token punctuation">.</span><span class="token function">selectAllEmployeeWithDept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span>                employees<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Dept</span> dept <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getDept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"->"</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dept<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">?</span>dept<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"天堂"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li><p>执行结果</p><pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select e.id,e.name,dept_id,d.name &#39;dept_name&#39; from employee e left join emp_dept ed on e.id&#x3D;ed.emp_id left join dept d on d.id&#x3D;ed.dept_id; DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 6张三-&gt;技术部李四-&gt;技术部王六-&gt;市场部王五-&gt;销售部王八-&gt;销售部龙哥-&gt;天堂</code></pre><p>最后把原来的baseResultMap复制一份，重新写一份新的，把原来添加到baseResultMap的代码都删掉</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>EmployeeWithDeptResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatisdemo.domain.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">extends</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!--注意这个extends！继承了BaseResultMap--></span><span class="token comment">&lt;!--就算继承了BaseResultMap，但是type是无法删除的，会导致编译无法通过--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_id<span class="token punctuation">"</span></span>  <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectAllEmployeeWithDept<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>EmployeeWithDeptResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select    e.id,e.name,dept_id,d.name 'dept_name'    from employee e    left join emp_dept ed    on e.id=ed.emp_id    left join dept d    on d.id=ed.dept_id;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li></ul><h2 id="一对一延迟加载（引子）"><a href="#一对一延迟加载（引子）" class="headerlink" title="一对一延迟加载（引子）"></a>一对一延迟加载（引子）</h2><ol><li>再次进行（开始前的准备中的导入项目）</li><li>这次我们不要关联层，重新写数据库<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">database</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">create</span>  <span class="token keyword">database</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">use</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span><span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span>  <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span>  <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'员工名称'</span><span class="token punctuation">,</span>  dept_id <span class="token keyword">int</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'王五'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'王六'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>employee<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'王八'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span>  <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span>  <span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span>  <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'部门名称'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'技术部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'市场部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'销售部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">update</span> employee <span class="token keyword">set</span> dept_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">update</span> employee <span class="token keyword">set</span> dept_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">update</span> employee <span class="token keyword">set</span> dept_id <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">update</span> employee <span class="token keyword">set</span> dept_id <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">update</span> employee <span class="token keyword">set</span> dept_id <span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre></li><li>把导入项目里生成好的Mapper.java,Mapper.xml,都删掉，然后进行generator操作（注意把配置文件里的dept_emp table标签删除）</li><li>此时实验以下单表查询是否可以成功</li></ol><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> employees <span class="token operator">=</span> employeeMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span>                employees<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"->"</span><span class="token operator">+</span>e<span class="token punctuation">.</span><span class="token function">getDeptId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, name, dept_id from employee DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 51:张三-&gt;12:李四-&gt;13:王五-&gt;34:王六-&gt;25:王八-&gt;3</code></pre></li></ul><ol start="5"><li>可是我们现在要查询的是人和部门名，因此要修改employee实体类，添加实体Dept dept在Employee类里<br><strong>注意保留generator生成的成员变量</strong><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Dept</span> dept<span class="token punctuation">;</span><span class="token comment">//get set方法省略</span></code></pre></li><li>此时要想知道怎么查，先写sql语句<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employee e <span class="token keyword">left</span> <span class="token keyword">join</span> dept d<span class="token keyword">on</span> e<span class="token punctuation">.</span>dept_id<span class="token operator">=</span>d<span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre></li></ol><ul><li>查询结果<br><img src="http://cdn.leafii.top/img/20220520174907.png" loading="lazy"></li></ul><ol start="7"><li>现在我们想先查询出Employee表的dept_id,然后通过dept_id查询需要的类别名，再包装显示出来<br>EmpMapper.xml<pre class="language-markup" data-language="markup"><code class="language-markup"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatisdemo.domain.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptId<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!--在查询到dept_id后进行第二次查找，调用deptMapper的selectByPrimaryKey进行查询dept的name操作，然后进行包装--></span><span class="token comment">&lt;!--property是查询到的映射，column是上一个查询的结果中的dept_id，select是调用DeptMapper中的方法所需要的写法，通过namespace映射到相应方法--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_id<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatisdemo.mapper.DeptMapper.selectByPrimaryKey<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span></code></pre></li></ol><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> employees <span class="token operator">=</span> employeeMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span>                employees<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Dept</span> dept <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getDept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"-->"</span><span class="token operator">+</span>dept<span class="token operator">!=</span><span class="token keyword">null</span><span class="token operator">?</span>dept<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt;  Preparing: select id, name from dept where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt; Parameters: 2(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;&#x3D;&#x3D;      Total: 1DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 5技术部技术部销售部市场部销售部</code></pre>很明显，结果是不正确的，发现是因为没有用好()</li><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> employees <span class="token operator">=</span> employeeMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span>                employees<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Dept</span> dept <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getDept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"-->"</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dept<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">?</span>dept<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, name, dept_id from employee DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt;  Preparing: select id, name from dept where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt; Parameters: 1(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;&#x3D;&#x3D;      Total: 1DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt;  Preparing: select id, name from dept where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt; Parameters: 3(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;&#x3D;&#x3D;      Total: 1DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt;  Preparing: select id, name from dept where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt; Parameters: 2(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;&#x3D;&#x3D;      Total: 1DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 5张三--&gt;技术部李四--&gt;技术部王五--&gt;销售部王六--&gt;市场部王八--&gt;销售部</code></pre></li></ul><ol start="8"><li>根据查询结果我们可以知道，这种方法使用了大量的sql语句，因为缓存的缘故，共有4条语句，效率很低<br><strong>为了提升这种写法的效率，我们引入延迟加载的概念。</strong></li></ol><h2 id="一对一延迟加载（懒加载）"><a href="#一对一延迟加载（懒加载）" class="headerlink" title="一对一延迟加载（懒加载）"></a>一对一延迟加载（懒加载）</h2><p><strong>默认不是延迟加载</strong></p><ol><li>倘若我们将测试类的代码写为</li></ol><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> employees <span class="token operator">=</span> employeeMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span>               employees<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span></code></pre></li><li>查询结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, name, dept_id from employee DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt;  Preparing: select id, name from dept where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt; Parameters: 1(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;&#x3D;&#x3D;      Total: 1DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt;  Preparing: select id, name from dept where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt; Parameters: 3(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;&#x3D;&#x3D;      Total: 1DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt;  Preparing: select id, name from dept where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&#x3D;&#x3D;&gt; Parameters: 2(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;&#x3D;&#x3D;      Total: 1DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 5张三李四王五王六王八</code></pre></li></ul><ol start="2"><li>依然使用了如此多的sql语句，在这里我们使用延迟加载,在EmployeeMapper.xml中的association标签中添加属性fetchType并设置值为lazy（此时就是延迟加载）</li></ol><ul><li>Mapper.xml<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatisdemo.domain.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deptId<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!--在查询到dept_id后进行第二次查找，调用deptMapper的selectByPrimaryKey进行查询dept的name操作，然后进行包装--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dept_id<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatisdemo.mapper.DeptMapper.selectByPrimaryKey<span class="token punctuation">"</span></span> <span class="token attr-name">fetchType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lazy<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span></code></pre></li><li>此时执行test后结果为<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, name, dept_id from employee DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 5张三李四王五王六王八</code></pre></li></ul><ol start="3"><li>此时延迟查询就成功了</li></ol><h2 id="延迟加载例子"><a href="#延迟加载例子" class="headerlink" title="延迟加载例子"></a>延迟加载例子</h2><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Employee</span> employee <span class="token operator">=</span> employeeMapper<span class="token punctuation">.</span><span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, name, dept_id from employee where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 3(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1王五</code></pre></li><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Employee</span> employee <span class="token operator">=</span> employeeMapper<span class="token punctuation">.</span><span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span><span class="token function">getDept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li><li>执行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, name, dept_id from employee where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 3(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1王五DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, name from dept where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 3(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1销售部</code></pre></li></ul><p><strong>可以体现出延迟加载，在需要的时候再执行查询</strong></p><p><strong>可以在mybatis-config.xml中configuration标签下添加setting标签设置成如下代码可以实现全部懒加载</strong><br><img src="http://cdn.leafii.top/img/20220520174938.png" loading="lazy"></p><p>##一对多关联查询</p><ol><li>修改Dept实体类<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> employeeList<span class="token punctuation">;</span><span class="token comment">//get set方法省略</span></code></pre></li></ol><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Dept</span> dept <span class="token operator">=</span> deptMapper<span class="token punctuation">.</span><span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dept<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, name from dept where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 2(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1市场部</code></pre></li></ul><ol start="2"><li>目标sql语句<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> d<span class="token punctuation">.</span>id<span class="token punctuation">,</span>d<span class="token punctuation">.</span>name<span class="token punctuation">,</span>e<span class="token punctuation">.</span>id <span class="token string">'e_id'</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span>name <span class="token string">'e_name'</span> <span class="token keyword">from</span> dept d <span class="token keyword">join</span> employee e <span class="token keyword">on</span> d<span class="token punctuation">.</span>id<span class="token operator">=</span>e<span class="token punctuation">.</span>dept_id <span class="token keyword">where</span> d<span class="token punctuation">.</span>id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span></code></pre></li><li>Mapper.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Dept</span> <span class="token function">selectByPrimaryKeyWithEmp</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>Mapper.xml<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap1<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatisdemo.domain.Dept<span class="token punctuation">"</span></span> <span class="token attr-name">extends</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!--因为反射无法读取employeeListの具体的泛型，因此在collection中添加ofType属性--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>employeeList<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>e_id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>e_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByPrimaryKeyWithEmp<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select d.id,d.name,e.id 'e_id',e.name 'e_name'from dept djoin employee eon d.id=e.dept_idwhere d.id=#&#123;value&#125;;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token class-name">Dept</span> dept <span class="token operator">=</span> deptMapper<span class="token punctuation">.</span><span class="token function">selectByPrimaryKeyWithEmp</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dept<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> employeeList <span class="token operator">=</span> dept<span class="token punctuation">.</span><span class="token function">getEmployeeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>employeeList<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> employeeList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> employee <span class="token operator">:</span> employeeList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select d.id,d.name,e.id &#39;e_id&#39;,e.name &#39;e_name&#39; from dept d join employee e on d.id&#x3D;e.dept_id where d.id&#x3D;?; DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 3(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 2销售部----------------王五王八</code></pre><strong>List，Set，数组都可以执行</strong></li></ol><ul><li>如果以后做页面，没有数据是空的很丑怎么办<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>employeeList<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> employeeList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装MySQL5.7</title>
      <link href="/2020/04/21/CentOs7%E5%AE%89%E8%A3%85MySQL5.7/"/>
      <url>/2020/04/21/CentOs7%E5%AE%89%E8%A3%85MySQL5.7/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOs7安装MySQL5-7"><a href="#CentOs7安装MySQL5-7" class="headerlink" title="CentOs7安装MySQL5.7"></a>CentOs7安装MySQL5.7</h1><p>5.7相较于5.6来说，坑很多 因此写教程记录一下，以后用得上</p><h2 id="1-通过ssh连接服务器"><a href="#1-通过ssh连接服务器" class="headerlink" title="1.通过ssh连接服务器"></a>1.通过ssh连接服务器</h2><h2 id="2-安装Mysql"><a href="#2-安装Mysql" class="headerlink" title="2.安装Mysql"></a>2.安装Mysql</h2><ol><li><p>运行以下命令更新YUM源。</p><span id="more"></span></li></ol><pre class="language-none"><code class="language-none">rpm -Uvh  http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-9.noarch.rpm</code></pre><ol start="2"><li>运行以下命令安装MySQL。(镜像可能会稍微有点久，多等一会)</li></ol><pre class="language-none"><code class="language-none">yum -y install mysql-community-server</code></pre><ol start="3"><li>运行以下命令查看MySQL版本号。</li></ol><pre class="language-none"><code class="language-none">mysql -v</code></pre><p>返回结果如下，表示MySQL安装成功。<br><code>mysql  Ver 14.14 Distrib 5.7.28, for Linux (x86_64) using  EditLine wrapper</code></p><h2 id="3-配置MySQL"><a href="#3-配置MySQL" class="headerlink" title="3.配置MySQL"></a>3.配置MySQL</h2><ol><li>运行以下命令启动MySQL服务。</li></ol><pre class="language-none"><code class="language-none">systemctl start mysqld</code></pre><ol start="2"><li>运行以下命令设置MySQL服务开机自启动。</li></ol><pre class="language-none"><code class="language-none">systemctl enable mysqld</code></pre><ol start="3"><li>运行以下命令查看&#x2F;var&#x2F;log&#x2F;mysqld.log文件，获取并记录root用户的初始密码。(下一步重置root用户密码时，会使用该初始密码)</li></ol><pre class="language-none"><code class="language-none">grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log2019-11-13T09:22:30.998148Z 1 [Note] A temporary password is generated for root@localhost: c(dwuSJQP0pq</code></pre><ol start="4"><li>运行下列命令对MySQL进行安全性配置。</li></ol><pre class="language-none"><code class="language-none">mysql_secure_installation</code></pre><h2 id="4-配置MySQL的安全性"><a href="#4-配置MySQL的安全性" class="headerlink" title="4.配置MySQL的安全性"></a>4.配置MySQL的安全性</h2><ol><li>重置root用户的密码。</li></ol><pre class="language-none"><code class="language-none">Enter password for user root: #输入上一步获取的root用户初始密码The &#39;validate_password&#39; plugin is installed on the server.The subsequent steps will run with the existing configuration of the plugin.Using existing password for root.Estimated strength of the password: 100 Change the password for root ? ((Press y|Y for Yes, any other key for No) : Y #是否更改root用户密码，输入YNew password: #输入新密码，长度为8至30个字符，必须同时包含大小写英文字母、数字和特殊符号。特殊符号可以是()&#96; ~!@#$%^&amp;*-+&#x3D;|&#123;&#125;[]:;‘&lt;&gt;,.?&#x2F;Re-enter new password: #再次输入新密码Estimated strength of the password: 100 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : Y</code></pre><ol start="2"><li>输入Y删除匿名用户账号。</li></ol><pre class="language-none"><code class="language-none">By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : Y  #是否删除匿名用户，输入YSuccess.</code></pre><ol start="3"><li>输入Y禁止root账号远程登录。</li></ol><pre class="language-none"><code class="language-none">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : Y #禁止root远程登录，输入YSuccess.</code></pre><ol start="4"><li>输入Y删除test库以及对test库的访问权限。</li></ol><pre class="language-none"><code class="language-none">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : Y #是否删除test库和对它的访问权限，输入Y- Dropping test database...Success.</code></pre><ol start="5"><li>输入Y重新加载授权表。</li></ol><pre class="language-none"><code class="language-none">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : Y #是否重新加载授权表，输入YSuccess.All done!</code></pre><h2 id="5-远程访问MySQL数据库"><a href="#5-远程访问MySQL数据库" class="headerlink" title="5.远程访问MySQL数据库"></a>5.远程访问MySQL数据库</h2><ol><li>通过以下命令登录mysql</li></ol><pre class="language-none"><code class="language-none">mysql -uroot -p</code></pre><ol start="2"><li>依次运行以下命令创建远程登录MySQL的账号。示例账号为root、密码为root。</li></ol><pre class="language-none"><code class="language-none">mysql&gt; grant all on *.* to &#39;root&#39;@&#39;%&#39;IDENTIFIED BY &#39;root&#39;; #使用root替换dms，可设置为允许root账号远程登录。mysql&gt; flush privileges;</code></pre><h2 id="简单密码修改方式"><a href="#简单密码修改方式" class="headerlink" title="简单密码修改方式"></a>简单密码修改方式</h2><ol><li>通过以下命令登录mysql</li></ol><pre class="language-none"><code class="language-none">mysql -uroot -p</code></pre><ol start="2"><li>通过以下命令修改mysql默认的密码安全性</li></ol><pre class="language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> validate_password_policy<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.05</span> sec<span class="token punctuation">)</span> mysql<span class="token operator">></span> mysql<span class="token operator">></span> mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> validate_password_mixed_case_count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span> mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> validate_password_number_count<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span> mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> validate_password_special_char_count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span> mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> validate_password_length<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span> mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'validate_password%'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------------------------------+-------+</span><span class="token operator">|</span> Variable_name                        <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------------------+-------+</span><span class="token operator">|</span> validate_password_dictionary_file    <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">|</span> validate_password_length             <span class="token operator">|</span> <span class="token number">3</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_mixed_case_count   <span class="token operator">|</span> <span class="token number">0</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_number_count       <span class="token operator">|</span> <span class="token number">3</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_policy             <span class="token operator">|</span> LOW   <span class="token operator">|</span><span class="token operator">|</span> validate_password_special_char_count <span class="token operator">|</span> <span class="token number">0</span>     <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------------------+-------+</span></code></pre><ol start="3"><li>修改简单密码：</li></ol><pre class="language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> <span class="token string">'root'</span><span class="token variable">@'localhost'</span> <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected<span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatisの生成器的使用</title>
      <link href="/2020/04/21/Mybatis%E3%81%AE%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/04/21/Mybatis%E3%81%AE%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis生成器的使用"><a href="#Mybatis生成器的使用" class="headerlink" title="Mybatis生成器的使用"></a>Mybatis生成器的使用</h1><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><span id="more"></span><ul><li>项目的目录结构如下<br><img src="http://cdn.leafii.top/img/20220520175202.png" loading="lazy"></li></ul><h3 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h3><ol><li><p>进入mybatis-generator官网:<a href="http://mybatis.org/generator/">官网</a></p></li><li><p>进入mybatis-generator通过maven运行的网站：<a href="http://mybatis.org/generator/running/runningWithMaven.html">点击进入</a></p></li><li><p>将网站中的maven代码复制粘贴到pom中去!（前提是要把所有的需要的depend都添加进去并且配好编译环境&#x3D;-&#x3D;）</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">...</span><span class="token punctuation">></span></span>     ...     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>       ...       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        ...        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-generator-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        ...      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>      ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>    ...  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre></li><li><p>在generator插件中加入mysql的dependicy，因为generator需要连接数据库，如下：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-generator-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token comment">&lt;!--生成器的配置文件 在mybatis-generator官网找--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configurationFile</span><span class="token punctuation">></span></span>$&#123;basedir&#125;/src/main/resources/mybatis/generator/generatorConfig.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configurationFile</span><span class="token punctuation">></span></span>                    <span class="token comment">&lt;!--重复生成覆盖原来的文件，映射文件不可行，依然是追加的方式，所以Mybatis-generator 不能运行两次--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>overwrite</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>overwrite</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;mysqlversion&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span></code></pre></li><li><p>因为在pom中同时引入了两个相同的mysql包，因此我们在控制mysql包版本的时候会很不方便&#x3D;-&#x3D;，此时应该怎么办呢？新建一个mysqlDriver的变量，然后将之前的5.1.48都替换成${mysqlDriver),如下：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mysqlversion</span><span class="token punctuation">></span></span>5.1.48<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mysqlversion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span></code></pre></li><li><p>在pom中编写以下代码</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--生成器的配置文件 在mybatis-generator官网找--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configurationFile</span><span class="token punctuation">></span></span>$&#123;basedir&#125;/src/main/resources/generatorConfig.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configurationFile</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--重复生成覆盖原来的文件，映射文件不可行，依然是追加的方式，所以Mybatis-generator 不能运行两次--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>overwrite</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>overwrite</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependicies</span><span class="token punctuation">></span></span>...</code></pre></li></ol><hr><h3 id="配置generatorConfig-xml"><a href="#配置generatorConfig-xml" class="headerlink" title="配置generatorConfig.xml"></a>配置generatorConfig.xml</h3><ol><li>因为已经定义了生成器的配置文件，所以要在${basedir}&#x2F;src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml路径中新建一个对应的xml文件<img src="http://cdn.leafii.top/img/20220520175218.png" loading="lazy"></li><li>但是一般我们工程量比较大，配置文件容易弄混，因此新建一个文件夹把这个新建的xml文件放进去，一般直接建好文件夹然后再去看配置文件，文件中的路径自己变成了相应的路径（idea可真是智能啊qwq）<img src="http://cdn.leafii.top/img/20220520175256.png" loading="lazy"></li><li>进入官网，有个generatorConfig.xml常用的例子:<a href="http://mybatis.org/generator/configreference/xmlconfig.html">网页链接</a>直接复制以下代码到generatorConfig.xml中(具体代码以网页为准，因为网页会有更新)<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">generatorConfiguration</span>  <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span>  <span class="token string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatorConfiguration</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classPathEntry</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/Program Files/IBM/SQLLIB/java/db2java.zip<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>DB2Tables<span class="token punctuation">"</span></span> <span class="token attr-name">targetRuntime</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyBatis3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdbcConnection</span> <span class="token attr-name">driverClass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>COM.ibm.db2.jdbc.app.DB2Driver<span class="token punctuation">"</span></span>        <span class="token attr-name">connectionURL</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc:db2:TEST<span class="token punctuation">"</span></span>        <span class="token attr-name">userId</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>db2admin<span class="token punctuation">"</span></span>        <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>db2admin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdbcConnection</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaTypeResolver</span> <span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>forceBigDecimals<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaTypeResolver</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaModelGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test.model<span class="token punctuation">"</span></span> <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>\MBGTestProject\src<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>trimStrings<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaModelGenerator</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sqlMapGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test.xml<span class="token punctuation">"</span></span>  <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>\MBGTestProject\src<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sqlMapGenerator</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaClientGenerator</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XMLMAPPER<span class="token punctuation">"</span></span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test.dao<span class="token punctuation">"</span></span>  <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>\MBGTestProject\src<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaClientGenerator</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">schema</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>DB2ADMIN<span class="token punctuation">"</span></span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ALLTYPES<span class="token punctuation">"</span></span> <span class="token attr-name">domainObjectName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Customer<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>useActualColumnNames<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatedKey</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ID<span class="token punctuation">"</span></span> <span class="token attr-name">sqlStatement</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>DB2<span class="token punctuation">"</span></span> <span class="token attr-name">identity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>columnOverride</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>DATE_FIELD<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>startDate<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ignoreColumn</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>FRED<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>columnOverride</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>LONG_VARCHAR_FIELD<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generatorConfiguration</span><span class="token punctuation">></span></span></code></pre></li><li>此时第一次加载会显示有一个dtd标红，fetch一下就好了，dtd正常显示可以多很多代码提示</li><li>此时开始修改配置文件，删除整行都用commond+x，删除第7行的db2语句，修改第8行的id为MysqlTables，然后在下面设置jdbc连接的driver，username，password等参数，也可以将这些信息配置在pom文件中，但是不推荐<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdbcConnection</span> <span class="token attr-name">driverClass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span>                        <span class="token attr-name">connectionURL</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc:mysql://127.0.0.1:3306/mybatisdemo<span class="token punctuation">"</span></span>                        <span class="token attr-name">userId</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span>                        <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdbcConnection</span><span class="token punctuation">></span></span></code></pre></li><li>修改实体类的位置，映射文件的位置，Dao接口的位置<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--2.实体类的位置--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaModelGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.mybatisgenerator.domain<span class="token punctuation">"</span></span> <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>trimStrings<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaModelGenerator</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--3.映射文件的位置--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sqlMapGenerator</span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.mybatisgenerator.mapper<span class="token punctuation">"</span></span>  <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sqlMapGenerator</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--4.Dao接口的位置--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javaClientGenerator</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XMLMAPPER<span class="token punctuation">"</span></span> <span class="token attr-name">targetPackage</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.mybatisgenerator.mapper<span class="token punctuation">"</span></span>  <span class="token attr-name">targetProject</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>src/main/java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enableSubPackages<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javaClientGenerator</span><span class="token punctuation">></span></span></code></pre></li><li>添加目标表的table标签<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">domainObjectName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span></code></pre></li></ol><h3 id="运行mybatis-generator"><a href="#运行mybatis-generator" class="headerlink" title="运行mybatis-generator"></a>运行mybatis-generator</h3><ul><li>点击右侧的Maven工具栏，点击mybatis-generator的build,此时运行显示运行成功<pre class="language-none"><code class="language-none">&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_221.jdk&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;java -Dmaven.multiModuleProjectDirectory&#x3D;&#x2F;Users&#x2F;leafii&#x2F;Documents&#x2F;JavaWeb&#x2F;mybatis_generator -Dmaven.home&#x3D;&#x2F;Users&#x2F;leafii&#x2F;maven&#x2F;apache-maven-3.6.2 -Dclassworlds.conf&#x3D;&#x2F;Users&#x2F;leafii&#x2F;maven&#x2F;apache-maven-3.6.2&#x2F;bin&#x2F;m2.conf &quot;-Dmaven.ext.class.path&#x3D;&#x2F;Applications&#x2F;IntelliJ IDEA.app&#x2F;Contents&#x2F;plugins&#x2F;maven&#x2F;lib&#x2F;maven-event-listener.jar&quot; &quot;-javaagent:&#x2F;Applications&#x2F;IntelliJ IDEA.app&#x2F;Contents&#x2F;lib&#x2F;idea_rt.jar&#x3D;61532:&#x2F;Applications&#x2F;IntelliJ IDEA.app&#x2F;Contents&#x2F;bin&quot; -Dfile.encoding&#x3D;UTF-8 -classpath &#x2F;Users&#x2F;leafii&#x2F;maven&#x2F;apache-maven-3.6.2&#x2F;boot&#x2F;plexus-classworlds-2.6.0.jar org.codehaus.classworlds.Launcher -Didea.version2019.2.4 -s &#x2F;Users&#x2F;leafii&#x2F;maven&#x2F;apache-maven-3.6.2&#x2F;conf&#x2F;settings.xml org.mybatis.generator:mybatis-generator-maven-plugin:1.3.7:generate[INFO] Scanning for projects...[WARNING] [WARNING] Some problems were encountered while building the effective model for leafii.top:mybatis_generator:jar:1.0-SNAPSHOT[WARNING] &#39;build.plugins.plugin.version&#39; for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 58, column 21[WARNING] [WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.[WARNING] [WARNING] For this reason, future Maven versions might no longer support building such malformed projects.[WARNING] [INFO] [INFO] --------------------&lt; leafii.top:mybatis_generator &gt;--------------------[INFO] Building mybatis_generator 1.0-SNAPSHOT[INFO] --------------------------------[ jar ]---------------------------------[INFO] [INFO] --- mybatis-generator-maven-plugin:1.3.7:generate (default-cli) @ mybatis_generator ---Wed Nov 13 09:59:14 CST 2019 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL&#x3D;false, or set useSSL&#x3D;true and provide truststore for server certificate verification.[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time:  0.885 s[INFO] Finished at: 2019-11-13T09:59:14+08:00[INFO] ------------------------------------------------------------------------</code></pre></li></ul><h3 id="生成器优化"><a href="#生成器优化" class="headerlink" title="生成器优化"></a>生成器优化</h3><ol><li>此时打开生成的代码发现里面很多没用的注释，怎么办呢？可以通过修改generatorConfig.xml进行设置默认不添加注释，默认参数在这里寻找：<a href="http://mybatis.org/generator/configreference/commentGenerator.html">网页链接</a><img src="http://cdn.leafii.top/img/20220520175315.png" loading="lazy"><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commentGenerator</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>suppressAllComments<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commentGenerator</span><span class="token punctuation">></span></span></code></pre>插入位置为<img src="http://cdn.leafii.top/img/20220520175333.png" loading="lazy"></li><li>如果不删除已经生成的实体类和接口还有xml，直接重新生成，会发现实体类和接口被重写了，但是xml文件没有被覆盖而是直接被追加了，也就是说把之前的代码追加在源文件里了（代码行数直接加倍了）</li><li>在table部分修改xml代码如下，可以让生成的代码更加简洁，主要的功能还是需要我们自己去手写.<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">tableName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">domainObjectName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span> <span class="token attr-name">enableUpdateByExample</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">enableSelectByExample</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">enableCountByExample</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">enableDeleteByExample</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li></ol><h3 id="Mybatis-generator代码的使用"><a href="#Mybatis-generator代码的使用" class="headerlink" title="Mybatis-generator代码的使用"></a>Mybatis-generator代码的使用</h3><ol><li>删除刚刚修改的table中添加的false选项的那几个代码，以便生成器生成功能全面的代码，点击build，生成代码</li><li>打开UserMapper.java，按下commond+shift+T 设置JUNIT4，新建junit单元测试类，选择所有方法<img src="http://cdn.leafii.top/img/20220520175348.png" loading="lazy"></li><li>在测试类中编写@Before和@After代码<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//读取资源文件</span>         inputStream <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"cfg/mybatis-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建SqlSessionFactory</span>         <span class="token class-name">SqlSessionFactory</span> sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取SqlSession</span>         sqlSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//通过SqlSession进行crud操作</span>         userMapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">UserMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@After</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sqlSession<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>inputStream<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>进入第一个测试类,运行时记得一定要修改相关的配置文件，记得修改log4j配置文件中UserMapper的正确路径，一定要在mybatis.config.xml中正确映射UserMapper.xml，否则无法运行！<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countByExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> count <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">countByExample</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre>执行结果：<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select count(*) from user DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: TRACE [main] - &lt;&#x3D;&#x3D;    Columns: count(*)TRACE [main] - &lt;&#x3D;&#x3D;        Row: 5DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 15</code></pre></li></ol><h3 id="关于UserExample"><a href="#关于UserExample" class="headerlink" title="关于UserExample"></a>关于UserExample</h3><ul><li>UserExample大多数时候是作为筛选条件&#x3D;-&#x3D;</li></ul><h4 id="0-引子"><a href="#0-引子" class="headerlink" title="0.引子"></a>0.引子</h4><ul><li>在测试类里也可以使用UserExample类<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countByExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">UserExample</span> userExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> count <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">countByExample</span><span class="token punctuation">(</span>userExample<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//若countByExample(null)则为查询全部</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select count(*) from user DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: TRACE [main] - &lt;&#x3D;&#x3D;    Columns: count(*)TRACE [main] - &lt;&#x3D;&#x3D;        Row: 5DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 15</code></pre></li></ul><h4 id="0-5-以下两个方法实现了相同的删除功能"><a href="#0-5-以下两个方法实现了相同的删除功能" class="headerlink" title="0.5 以下两个方法实现了相同的删除功能"></a>0.5 以下两个方法实现了相同的删除功能</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteByExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">UserExample</span> userExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userExample<span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andIdEqualTo</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">deleteByExample</span><span class="token punctuation">(</span>userExample<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteByPrimaryKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        userMapper<span class="token punctuation">.</span><span class="token function">deleteByPrimaryKey</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><p><strong>自动生成的代码不能实现批量删除&#x3D;-&#x3D; 我们自己写一个</strong></p><ul><li><p>Mapper.java</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">deleteByPrimaryKey</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除一个    </span><span class="token keyword">int</span> <span class="token function">deleteByPrimaryKeys</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"ids"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//批量删除(Integer... id)写了之后就可以实现批量删除</span></code></pre></li><li><p>Mapper.xml</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delete</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deleteByPrimaryKeys<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   delete from user   where id in <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ids<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   #&#123;id&#125; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delete</span><span class="token punctuation">></span></span></code></pre></li><li><p>Test.java</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteByPrimaryKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       userMapper<span class="token punctuation">.</span><span class="token function">deleteByPrimaryKeys</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre></li><li><p>运行结果</p><pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: delete from user where id in ( ? , ? , ? , ? , ? ) DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(Integer), 2(Integer), 3(Integer), 4(Integer), 5(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;    Updates: 4</code></pre></li></ul><h4 id="1-简单查询"><a href="#1-简单查询" class="headerlink" title="1.简单查询"></a>1.简单查询</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//查询性别为“1”且address为上海的人</span><span class="token class-name">UserExample</span> userExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">UserExample<span class="token punctuation">.</span>Criteria</span> criteria <span class="token operator">=</span> userExample<span class="token punctuation">.</span><span class="token function">createCriteria</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        criteria<span class="token punctuation">.</span><span class="token function">andAddressEqualTo</span><span class="token punctuation">(</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        criteria<span class="token punctuation">.</span><span class="token function">andSexEqualTo</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span>userExample<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> u <span class="token operator">:</span>                users<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span></code></pre><ul><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, username, birthday, sex, address from user WHERE ( address &#x3D; ? and sex &#x3D; ? ) DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 上海(String), 1(String)TRACE [main] - &lt;&#x3D;&#x3D;    Columns: id, username, birthday, sex, addressTRACE [main] - &lt;&#x3D;&#x3D;        Row: 5, 王八, 2018-07-10, 1, 上海DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1User&#123;id&#x3D;5, username&#x3D;&#39;王八&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;上海&#39;&#125;</code></pre></li></ul><h4 id="2-复杂查询"><a href="#2-复杂查询" class="headerlink" title="2.复杂查询"></a>2.复杂查询</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//查询address为北京或广州且sex为0的人</span><span class="token class-name">UserExample</span> userExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">UserExample<span class="token punctuation">.</span>Criteria</span> criteria <span class="token operator">=</span> userExample<span class="token punctuation">.</span><span class="token function">createCriteria</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        criteria<span class="token punctuation">.</span><span class="token function">andAddressIn</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"上海"</span><span class="token punctuation">,</span><span class="token string">"广州"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andSexEqualTo</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span>userExample<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> u <span class="token operator">:</span>                users<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span></code></pre><ul><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, username, birthday, sex, address from user WHERE ( address in ( ? , ? ) and sex &#x3D; ? ) DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 上海(String), 广州(String), 0(String)TRACE [main] - &lt;&#x3D;&#x3D;    Columns: id, username, birthday, sex, addressTRACE [main] - &lt;&#x3D;&#x3D;        Row: 2, 李四, 2018-07-10, 0, 上海DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1User&#123;id&#x3D;2, username&#x3D;&#39;李四&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;0&#39;, address&#x3D;&#39;上海&#39;&#125;</code></pre><strong>注：userExample.createCriteria()与userExample.or()是等价的</strong></li></ul><h4 id="3-插入用户"><a href="#3-插入用户" class="headerlink" title="3.插入用户"></a>3.插入用户</h4><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"hjkx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"青城山"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setBirthday</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        userMapper<span class="token punctuation">.</span><span class="token function">insertSelective</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>以上的insert()和insertSelective()方法的区别在于，insert方法会直接将未设置的属性插入到数据库中，值为null，但是如果使用insertSelective方法，就不会插入那个属性，不会传值过去 可以看看运行结果：<br>insert：</p><pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: insert into user (id, username, birthday, sex, address) values (?, ?, ?, ?, ?) DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: null, hjkx(String), 2019-11-13(Date), null, 青城山(String)DEBUG [main] - &lt;&#x3D;&#x3D;    Updates: 1</code></pre><p>insertSelective</p><pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: insert into user ( username, birthday, address ) values ( ?, ?, ? ) DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: hjkx(String), 2019-11-13(Date), 青城山(String)DEBUG [main] - &lt;&#x3D;&#x3D;    Updates: 1</code></pre><p>看看数据库：<br><img src="http://cdn.leafii.top/img/20220520175404.png" loading="lazy"><br>原因是设置表格时sex的默认值为null，所以成了这样</p><p><strong>总结：插入时使用insert而不是insertSelective</strong></p><h4 id="4-更新性别"><a href="#4-更新性别" class="headerlink" title="4.更新性别"></a>4.更新性别</h4><ul><li>将目标用户的属性修改</li><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateByPrimaryKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"垃圾"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"青城山"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setBirthday</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userMapper<span class="token punctuation">.</span><span class="token function">updateByPrimaryKey</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: update user set username &#x3D; ?, birthday &#x3D; ?, sex &#x3D; ?, address &#x3D; ? where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 垃圾(String), 2019-11-13(Date), 1(String), 青城山(String), 27(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;    Updates: 1</code></pre><strong>如果更新不要用这个方法，很危险，如果只设置了需要更新的字段，那么其他字段会变成null,应该使用updateByPrimaryKeySelective,这样只需要设置需要修改的字段和主键的值就可以</strong><br>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateByPrimaryKeySelective</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userMapper<span class="token punctuation">.</span><span class="token function">updateByPrimaryKeySelective</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: update user SET sex &#x3D; ? where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(String), 27(Integer)DEBUG [main] - &lt;&#x3D;&#x3D;    Updates: 1</code></pre></li></ul><h3 id="3-复杂更新"><a href="#3-复杂更新" class="headerlink" title="3.复杂更新"></a>3.复杂更新</h3><ul><li>Test.java<pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateByExampleSelective</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">UserExample</span> userExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userExample<span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andAddressEqualTo</span><span class="token punctuation">(</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andSexEqualTo</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//条件</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"乌鲁木齐"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//要更新的user</span>        userMapper<span class="token punctuation">.</span><span class="token function">updateByExampleSelective</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span>userExample<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: update user SET sex &#x3D; ?, address &#x3D; ? WHERE ( address &#x3D; ? and sex &#x3D; ? ) DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(String), 乌鲁木齐(String), 上海(String), 0(String)DEBUG [main] - &lt;&#x3D;&#x3D;    Updates: 2</code></pre></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>插入数据时，使用insert方法，所有数据统统insert</strong><br><strong>更新数据时，大部分情况使用updateByPrimaryKeySelective方法，无需设置无关字段，不会修改原来的值</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatisの动态SQL</title>
      <link href="/2020/04/21/Mybatis%E3%81%AE%E5%8A%A8%E6%80%81SQL/"/>
      <url>/2020/04/21/Mybatis%E3%81%AE%E5%8A%A8%E6%80%81SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p> MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。</p><span id="more"></span><p>虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。</p><p>动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。</p><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><hr><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>以上一篇文章的数据为例：<br>数据库：</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">database</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">create</span>  <span class="token keyword">database</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">use</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span>         <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>username<span class="token punctuation">`</span></span>  <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名称'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>birthday<span class="token punctuation">`</span></span>  <span class="token keyword">date</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'生日'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>sex<span class="token punctuation">`</span></span>       <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'性别'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>address<span class="token punctuation">`</span></span>   <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'地址'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">27</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'北京'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'上海'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'王五'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'广州'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'王六'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'深圳'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'王八'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'上海'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">create</span> <span class="token keyword">table</span> employee<span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="案例：三个条件并存的查询"><a href="#案例：三个条件并存的查询" class="headerlink" title="案例：三个条件并存的查询"></a>案例：三个条件并存的查询</h2><ul><li><p>背景：查询符合姓名，性别，地区条件的人</p></li><li><p>Mapper.java</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">selectUserByExample</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Mapper.xml</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByExample<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>baseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select  id, username ,birthday,sex , address from user where username=#&#123;user.username&#125; and sex=#&#123;user.sex&#125; and address=#&#123;user.address&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>Test.java</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectUserByExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"广州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserByExample</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> u <span class="token operator">:</span>                users<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li><p>结果正常</p><pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, username ,birthday,sex , address from user where username&#x3D;? and sex&#x3D;? and address&#x3D;? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 王五(String), 1(String), 广州(String)TRACE [main] - &lt;&#x3D;&#x3D;    Columns: id, username, birthday, sex, addressTRACE [main] - &lt;&#x3D;&#x3D;        Row: 3, 王五, 2018-07-10, 1, 广州DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1User&#123;id&#x3D;3, username&#x3D;&#39;王五&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;广州&#39;&#125;</code></pre></li><li><p>提出问题<br>  <strong>若让sex为空值，那么查出的结果将为空，但是符合条件的却有一条</strong><br>  因此现在想让sql语句实现这样的功能：如果传来的参数不为空，那么就执行响应的判断，如果传来的参数为空，则干脆不执行传来的参数部分的语句。因此我们需要在xml文件中的sql语句中添加动态SQL语句</p></li></ul><h3 id="在sql语句中使用if标签"><a href="#在sql语句中使用if标签" class="headerlink" title="在sql语句中使用if标签"></a>在sql语句中使用if标签</h3><p>Mapper.xml</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByExample<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>baseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   select  id, username ,birthday,sex , address from user where   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user.username!=null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       username=#&#123;user.username&#125;   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user.sex!=null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       and sex=#&#123;user.sex&#125;   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user.address!=null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       and address=#&#123;user.address&#125;   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p><strong>这样当sex或者address为空时，sql语句正常运转</strong></p><ul><li>执行结果(sex为空时)<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, username ,birthday,sex , address from user where username&#x3D;? and address&#x3D;? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 王五(String), 广州(String)TRACE [main] - &lt;&#x3D;&#x3D;    Columns: id, username, birthday, sex, addressTRACE [main] - &lt;&#x3D;&#x3D;        Row: 3, 王五, 2018-07-10, 1, 广州DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1User&#123;id&#x3D;3, username&#x3D;&#39;王五&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;广州&#39;&#125;</code></pre></li><li>问题：如果username为空，且sex为空，那么语句依然会报错：<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, username ,birthday,sex , address from user where and address&#x3D;? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 广州(String)</code></pre>怎么解决呢？</li></ul><h3 id="在动态SQL语句中使用trim"><a href="#在动态SQL语句中使用trim" class="headerlink" title="在动态SQL语句中使用trim"></a>在动态SQL语句中使用trim</h3><ul><li>where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除。</li><li>如果 where 元素没有按正常套路出牌，我们可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为：<br>Mapper.xml<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByExample<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>baseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select  id, username ,birthday,sex , address from user        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>trim</span> <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>where<span class="token punctuation">"</span></span> <span class="token attr-name">prefixOverrides</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>and | or <span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user.username!=null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                username=#&#123;user.username&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user.sex!=null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and sex=#&#123;user.sex&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user.address!=null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and address=#&#123;user.address&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>trim</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li>但是trim这个标签用的不是很多 因为有另一个标签更常用而且还包含了trim的所有功能，这个标签就是where标签</li></ul><h3 id="在动态SQL语句中使用where标签"><a href="#在动态SQL语句中使用where标签" class="headerlink" title="在动态SQL语句中使用where标签"></a>在动态SQL语句中使用where标签</h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByExample<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>baseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select id, username ,birthday,sex , address from user        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user.username!=null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                username=#&#123;user.username&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user.sex!=null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and sex=#&#123;user.sex&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user.address!=null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and address=#&#123;user.address&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--where标签在这里使用与&lt;trim prefix="where" prefixOverrides="and | or ">&lt;/trim>标签的功能等价--></span></code></pre><ol><li>where标签在此时，如果三个语句都为空，就不会在最终的sql语句中出现where，只要有一个不为空，那么where就会显示</li><li>where标签还拥有和trim等价的功能，可以在适当的时间屏蔽and或者or</li></ol><p><strong>因此trim不常用，不是trim功能不够强大，而是where的功能包含了它</strong></p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul><li>动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPostIn<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog.Post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  SELECT *  FROM POST P  WHERE ID in  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span>      <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        #&#123;item&#125;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>*foreach的使用，请看<a href="https://www.leafii.top/archives/mybatisdemofind#%E4%BA%8C%E6%A1%88%E4%BE%8B2%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8Asql-%E5%8F%82%E6%95%B0">Mybatis案例（查询）的案例2：</a><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--演示List做参数的使用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByAddrs<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from user where address in    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addresses<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addr<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        #&#123;addr&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--演示数组做参数的使用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByAddrsA<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from user where address in    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addressses<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addr<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        #&#123;addr&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><strong>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</strong><br><strong>注意:你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</strong></li></ul><h3 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose, when, otherwise"></a>choose, when, otherwise</h3><p>有些时候，我们不想用到所有的条件语句，而只想从中择其一二。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是这次变为提供了”title”就按”title”查找，提供了”author”就按”author”查找，若两者都没有提供，就返回所有符合条件的BLOG（实际情况可能是由管理员按一定策略选出BLOG列表，而不是返回大量无意义的随机结果）。</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogLike<span class="token punctuation">"</span></span>     <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>choose</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      AND title like #&#123;title&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author != null and author.name != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      AND author_name like #&#123;author.name&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>otherwise</span><span class="token punctuation">></span></span>      AND featured = 1    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>otherwise</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>choose</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><hr><p><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">Mybatis关于动态SQL的官方文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis返回结果の查询案例</title>
      <link href="/2020/04/21/Mybatis%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E3%81%AE%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B/"/>
      <url>/2020/04/21/Mybatis%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E3%81%AE%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>将之前的项目复制一份，改名，然后将对应的pom文件中的<br> <img src="http://cdn.leafii.top/img/20220520174529.png" loading="lazy"><br> 改成新的项目名称</li></ol>  <span id="more"></span><ol start="2"><li><p>将新的项目导入到idea中，直接打开pom文件 一直点下一步即可<br> <strong>注意：在编写测试方法时，测试类的名字为UserMapperTest，测试方法的方法名为testXxxx，这样取名符合编程规范</strong></p></li><li><p>数据库：</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">database</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">create</span>  <span class="token keyword">database</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">use</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span>         <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>username<span class="token punctuation">`</span></span>  <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名称'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>birthday<span class="token punctuation">`</span></span>  <span class="token keyword">date</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'生日'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>sex<span class="token punctuation">`</span></span>       <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'性别'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>address<span class="token punctuation">`</span></span>   <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'地址'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">27</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'北京'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'上海'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'王五'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'广州'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'王六'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'深圳'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'王八'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'上海'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h1 id="Mybatis-案例"><a href="#Mybatis-案例" class="headerlink" title="Mybatis 案例"></a>Mybatis 案例</h1><h2 id="案例1：返回单一实体对象"><a href="#案例1：返回单一实体对象" class="headerlink" title="案例1：返回单一实体对象"></a>案例1：返回单一实体对象</h2><ul><li><p>Mapper接口方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//     1.返回单一实体对象</span>     <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">selectById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Mapper.xml</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--1.返回单一实体对象--></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectById<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_int<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>baseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select  id, username ,birthday,sex , address from user where id = #&#123;id&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>test方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//除了主体部分的代码 之后的案例将会省略</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MybatisTest</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">UserMapper</span> userMapper <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">InputStream</span> inputstream <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            inputstream <span class="token operator">=</span> <span class="token class-name">Resources</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"mybatis-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sqlSession <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputstream<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userMapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">UserMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//     1.返回单一实体对象</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//关闭资源</span>    <span class="token annotation punctuation">@After</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sqlSession<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>inputstream<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                inputstream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>运行结果</p><pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, username ,birthday,sex , address from user where id &#x3D; ? DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(Integer)TRACE [main] - &lt;&#x3D;&#x3D;    Columns: id, username, birthday, sex, addressTRACE [main] - &lt;&#x3D;&#x3D;        Row: 1, 张三, 2018-07-10, 1, 北京DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1User&#123;id&#x3D;1, username&#x3D;&#39;张三&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;北京&#39;&#125;</code></pre></li></ul><h2 id="案例2：返回集合实体对象"><a href="#案例2：返回集合实体对象" class="headerlink" title="案例2：返回集合实体对象"></a>案例2：返回集合实体对象</h2><ul><li><p>Mapper接口方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//     2.返回集合实体对象</span>     <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">selectAllUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Mapper.xml</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--2.返回集合实体对象--></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectAllUser<span class="token punctuation">"</span></span>  <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>baseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select  id, username ,birthday,sex , address from user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>test方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//除了主体部分的代码 之后的案例将会省略</span>    <span class="token comment">//     2.返回集合实体对象</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectAllUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectAllUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> u <span class="token operator">:</span>                users<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li><p>运行结果</p><pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, username ,birthday,sex , address from user DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: TRACE [main] - &lt;&#x3D;&#x3D;    Columns: id, username, birthday, sex, addressTRACE [main] - &lt;&#x3D;&#x3D;        Row: 1, 张三, 2018-07-10, 1, 北京TRACE [main] - &lt;&#x3D;&#x3D;        Row: 2, 李四, 2018-07-10, 0, 上海TRACE [main] - &lt;&#x3D;&#x3D;        Row: 3, 王五, 2018-07-10, 1, 广州TRACE [main] - &lt;&#x3D;&#x3D;        Row: 4, 王六, 2018-07-10, 1, 深圳TRACE [main] - &lt;&#x3D;&#x3D;        Row: 5, 王八, 2018-07-10, 1, 上海DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 5User&#123;id&#x3D;1, username&#x3D;&#39;张三&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;北京&#39;&#125;User&#123;id&#x3D;2, username&#x3D;&#39;李四&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;0&#39;, address&#x3D;&#39;上海&#39;&#125;User&#123;id&#x3D;3, username&#x3D;&#39;王五&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;广州&#39;&#125;User&#123;id&#x3D;4, username&#x3D;&#39;王六&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;深圳&#39;&#125;User&#123;id&#x3D;5, username&#x3D;&#39;王八&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;上海&#39;&#125;</code></pre><p><strong>以上的两个例子之前有相似的讲解，比较简单</strong></p></li></ul><hr><h2 id="案例3：返回Map形式的集合"><a href="#案例3：返回Map形式的集合" class="headerlink" title="案例3：返回Map形式的集合"></a>案例3：返回Map形式的集合</h2><ul><li><p>Mapper接口方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//     3.返回Map形式的集合 </span><span class="token comment">//@MapKey确定了与User在Map中绑定的元素对象</span>    <span class="token annotation punctuation">@MapKey</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">selectAllMapUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Mapper.xml</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--3.返回Map形式的集合--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectAllMapUser<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>baseResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select  id, username ,birthday,sex , address from user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>test方法<br>返回为map的好处就是可以快速索引主键 此时的主键是id<br><strong>使用map的优势 如果用list 就得一个一个的遍历 但是如果使用map</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//     3.返回Map形式的集合</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectAllMapUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">></span></span> userMap <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectAllMapUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历map</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> userMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> key<span class="token operator">:</span>keys<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"-->"</span> <span class="token operator">+</span> userMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token comment">//example</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----打印id为4的用户----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token operator">+</span><span class="token string">"-->"</span> <span class="token operator">+</span> userMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>运行结果</p><pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, username ,birthday,sex , address from user DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: TRACE [main] - &lt;&#x3D;&#x3D;    Columns: id, username, birthday, sex, addressTRACE [main] - &lt;&#x3D;&#x3D;        Row: 1, 张三, 2018-07-10, 1, 北京TRACE [main] - &lt;&#x3D;&#x3D;        Row: 2, 李四, 2018-07-10, 0, 上海TRACE [main] - &lt;&#x3D;&#x3D;        Row: 3, 王五, 2018-07-10, 1, 广州TRACE [main] - &lt;&#x3D;&#x3D;        Row: 4, 王六, 2018-07-10, 1, 深圳TRACE [main] - &lt;&#x3D;&#x3D;        Row: 5, 王八, 2018-07-10, 1, 上海DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 51--&gt;User&#123;id&#x3D;1, username&#x3D;&#39;张三&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;北京&#39;&#125;2--&gt;User&#123;id&#x3D;2, username&#x3D;&#39;李四&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;0&#39;, address&#x3D;&#39;上海&#39;&#125;3--&gt;User&#123;id&#x3D;3, username&#x3D;&#39;王五&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;广州&#39;&#125;4--&gt;User&#123;id&#x3D;4, username&#x3D;&#39;王六&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;深圳&#39;&#125;5--&gt;User&#123;id&#x3D;5, username&#x3D;&#39;王八&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;上海&#39;&#125;-----打印id为4的用户----4--&gt;User&#123;id&#x3D;4, username&#x3D;&#39;王六&#39;, birthday&#x3D;Tue Jul 10 00:00:00 CST 2018, sex&#x3D;&#39;1&#39;, address&#x3D;&#39;深圳&#39;&#125;-----------------------</code></pre></li></ul><h2 id="案例4：返回Map形式的数据行"><a href="#案例4：返回Map形式的数据行" class="headerlink" title="案例4：返回Map形式的数据行"></a>案例4：返回Map形式的数据行</h2><ul><li>Mapper接口方法<pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//     4.返回Map形式的数据行</span>     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token function">selectAllMapCol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>Mapper.xml<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--4.返回Map形式的数据行--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectAllMapCol<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select  id, username ,birthday,sex , address from user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li>test方法<pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//     4.返回Map形式的数据行</span>    <span class="token comment">/*原来的3方法，list 返回的是一个User对象    *现在把每一行 返回为Map形式    * 在resultType中写map或者HashMap都可以    *    */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectAllMapCol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span> maps <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectAllMapCol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> map <span class="token operator">:</span>                maps<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> cols <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> col <span class="token operator">:</span>                    cols<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>col<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>col<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre></li><li>运行结果<pre class="language-none"><code class="language-none">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select id, username ,birthday,sex , address from user DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: TRACE [main] - &lt;&#x3D;&#x3D;    Columns: id, username, birthday, sex, addressTRACE [main] - &lt;&#x3D;&#x3D;        Row: 1, 张三, 2018-07-10, 1, 北京TRACE [main] - &lt;&#x3D;&#x3D;        Row: 2, 李四, 2018-07-10, 0, 上海TRACE [main] - &lt;&#x3D;&#x3D;        Row: 3, 王五, 2018-07-10, 1, 广州TRACE [main] - &lt;&#x3D;&#x3D;        Row: 4, 王六, 2018-07-10, 1, 深圳TRACE [main] - &lt;&#x3D;&#x3D;        Row: 5, 王八, 2018-07-10, 1, 上海DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 5birthday:2018-07-10address:北京sex:1id:1username:张三birthday:2018-07-10address:上海sex:0id:2username:李四birthday:2018-07-10address:广州sex:1id:3username:王五birthday:2018-07-10address:深圳sex:1id:4username:王六birthday:2018-07-10address:上海sex:1id:5username:王八</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS无法通过SSH链接到Linux服务器</title>
      <link href="/2020/04/21/macos%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5Linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/04/21/macos%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5Linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="macos无法通过ssh连接Linux云服务器"><a href="#macos无法通过ssh连接Linux云服务器" class="headerlink" title="macos无法通过ssh连接Linux云服务器"></a>macos无法通过ssh连接Linux云服务器</h1><h4 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h4><p>因为本人将自己的阿里云服务器格式化了，因此macos 通过ssh连接时提示：</p><span id="more"></span><pre class="language-none"><code class="language-none">leafii@LeafiideMacBook-Pro  ~sudo sshroot@Password:????????@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that the RSA host key has just been changed.The fingerprint for the RSA key sent by the remote host isea:24:31:8d:03:07:36:db:2f:74:15:5d:58:67:a3:5b.Please contact your system administrator.Add correct host key in &#x2F;var&#x2F;root&#x2F;.ssh&#x2F;known_hosts to get rid of this message.Offending key in &#x2F;var&#x2F;root&#x2F;.ssh&#x2F;known_hosts:1RSA host key for 192.168.1.203 has changed and you have requested strict checking.Host key verification failed.</code></pre><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>Mac保存了秘钥信息，你初始化服务器之后，秘钥就变了，所以不能登录，利用上面的程序清除旧的秘钥信息即可正常登录了！</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>在终端执行命令：</p><pre class="language-none"><code class="language-none">ssh-keygen -R IP(你远程服务器ip地址)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatisの一些查询案例</title>
      <link href="/2020/04/21/Mybatis%E3%81%AE%E4%B8%80%E4%BA%9B%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B/"/>
      <url>/2020/04/21/Mybatis%E3%81%AE%E4%B8%80%E4%BA%9B%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>将之前的项目复制一份，改名，然后将对应的pom文件中的<br><img src="http://cdn.leafii.top/img/20220520174624.png" loading="lazy"><br>改成新的项目名称</li><li>将新的项目导入到idea中，直接打开pom文件 一直点下一步即可<br><strong>注意：在编写测试方法时，测试类的名字为UserMapperTest，测试方法的方法名为testXxxx，这样取名符合编程规范</strong></li></ol><span id="more"></span><h1 id="Mybatis-案例"><a href="#Mybatis-案例" class="headerlink" title="Mybatis 案例"></a>Mybatis 案例</h1><h2 id="一、案例1：入门程序（略过）"><a href="#一、案例1：入门程序（略过）" class="headerlink" title="一、案例1：入门程序（略过）"></a>一、案例1：入门程序（略过）</h2><h2 id="二、案例2：两个以上sql-参数"><a href="#二、案例2：两个以上sql-参数" class="headerlink" title="二、案例2：两个以上sql 参数"></a>二、案例2：两个以上sql 参数</h2><p>数据库：</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">database</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">create</span>  <span class="token keyword">database</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">use</span> mybatisdemo<span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span>         <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>username<span class="token punctuation">`</span></span>  <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户名称'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>birthday<span class="token punctuation">`</span></span>  <span class="token keyword">date</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'生日'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>sex<span class="token punctuation">`</span></span>       <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'性别'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>address<span class="token punctuation">`</span></span>   <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'地址'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">27</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'北京'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'上海'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'王五'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'广州'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'王六'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'深圳'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'王八'</span><span class="token punctuation">,</span> <span class="token string">'2018-07-10'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'上海'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">table</span> employee<span class="token punctuation">(</span>id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>场景: 查在上海的女人</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> whrere sex <span class="token operator">=</span> ? <span class="token operator">and</span> address <span class="token operator">=</span> ?</code></pre><h3 id="1-通过Map-的方式"><a href="#1-通过Map-的方式" class="headerlink" title="1. 通过Map 的方式"></a>1. 通过Map 的方式</h3><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByAddrAndSexA<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       select * from user where sex = #&#123;sex&#125; and address = #&#123;address&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><blockquote><p> mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">selectUserByAddrAndSexA</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"sex"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">,</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> userList <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserByAddrAndSexA</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-通过java-Bean-的方式"><a href="#2-通过java-Bean-的方式" class="headerlink" title="2. 通过java Bean 的方式"></a>2. 通过java Bean 的方式</h3><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByAddrAndSexB<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatisdemo.domain.User<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user where sex = #&#123;sex&#125; and address = #&#123;address&#125; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><blockquote><p> mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">selectUserByAddrAndSexB</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> userList <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserByAddrAndSexB</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>       </code></pre><h3 id="3-通过java-Bean-命名式参数-的方式"><a href="#3-通过java-Bean-命名式参数-的方式" class="headerlink" title="3. 通过java Bean + 命名式参数 的方式"></a>3. 通过java Bean + 命名式参数 的方式</h3><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByAddrAndSexC<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       select * from user where sex = #&#123;u.sex&#125; and address = #&#123;u.address&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">selectUserByAddrAndSexC</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"u"</span><span class="token punctuation">)</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> userList <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserByAddrAndSexC</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="4-通过-命名式参数-的方式"><a href="#4-通过-命名式参数-的方式" class="headerlink" title="4. 通过  命名式参数 的方式"></a>4. 通过  命名式参数 的方式</h3><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByAddrAndSexD<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       select * from user where sex = #&#123;a&#125; and address = #&#123;b&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">selectUserByAddrAndSexD</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> sex<span class="token punctuation">,</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token class-name">String</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> userList <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserByAddrAndSexD</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="三、案例3：以集合或数组作为参数"><a href="#三、案例3：以集合或数组作为参数" class="headerlink" title="三、案例3：以集合或数组作为参数"></a>三、案例3：以集合或数组作为参数</h2><blockquote><p>查询广州、北京、上海、深圳的人</p></blockquote><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserBySomeAddr<span class="token punctuation">"</span></span>  <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       select * from user where address in       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addresses<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addr<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         #&#123;addr&#125;       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">selectUserBySomeAddr</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"addresses"</span><span class="token punctuation">)</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> addresses<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> userList<span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserBySomeAddr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"上海"</span><span class="token punctuation">,</span><span class="token string">"广州"</span><span class="token punctuation">,</span><span class="token string">"深圳"</span><span class="token punctuation">,</span><span class="token string">"北京"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="四、案例4：演示-和-的区别"><a href="#四、案例4：演示-和-的区别" class="headerlink" title="四、案例4：演示# 和 $ 的区别"></a>四、案例4：演示# 和 $ 的区别</h2><blockquote><p>$ 只是字符串的拼接，不能防止SQL注入</p><p><code>$&#123;value&#125;</code> 会被直接替换，而 <code>#&#123;value&#125;</code> 会被使用 <code>?</code>作为 预处理</p></blockquote><blockquote><p>注：JDBC是通过设定传入数据类型进行防注入的</p></blockquote><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByName<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         select * from user where username = '$&#123;value &#125;'<span class="token comment">&lt;!--或者username=#&#123;username&#125;--></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span>  <span class="token function">selectUserByName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-none"><code class="language-none">List&lt;User&gt; users &#x3D; userMapper.selectUserByName(&quot;王八&quot;);</code></pre><blockquote><p>执行结果对比</p></blockquote><p><img src="http://cdn.leafii.top/img/20220520174642.png" loading="lazy"></p><h2 id="五、案例5：模糊查询"><a href="#五、案例5：模糊查询" class="headerlink" title="五、案例5：模糊查询"></a>五、案例5：模糊查询</h2><blockquote><p>场景:查询名字 包含”王“ 字混球</p></blockquote><h3 id="方式1：通过-符号（方便但是不安全）"><a href="#方式1：通过-符号（方便但是不安全）" class="headerlink" title="方式1：通过$符号（方便但是不安全）"></a>方式1：通过$符号（方便但是不安全）</h3><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserLikeName<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     select * from user where username like '%$&#123;value&#125;%' <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//查询有"王"字</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span>  <span class="token function">selectUserLikeName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserLikeName</span><span class="token punctuation">(</span><span class="token string">"王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>功能没问题 但是不能防止SQL注入攻击</strong></p><h3 id="方式2：通过字符串连接函数（安全但是不好看）"><a href="#方式2：通过字符串连接函数（安全但是不好看）" class="headerlink" title="方式2：通过字符串连接函数（安全但是不好看）"></a>方式2：通过字符串连接函数（安全但是不好看）</h3><blockquote><p>使用数据库函数CONCAT<br>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserLikeName1<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       select * from user where username like CONCAT('%',#&#123;value&#125;,'%')    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--使用#符号可以防止sql注入攻击--></span></code></pre><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//查询有"王"字</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span>  <span class="token function">selectUserLikeName1</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserLikeName1</span><span class="token punctuation">(</span><span class="token string">"王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>通过#符号的使用，防止了sql注入，可是依赖性太强</strong></p><h3 id="方式3：通过-lt-bind-gt-标签（中规中矩，安全方便）"><a href="#方式3：通过-lt-bind-gt-标签（中规中矩，安全方便）" class="headerlink" title="方式3：通过&lt;bind&gt; 标签（中规中矩，安全方便）"></a>方式3：通过&lt;bind&gt; 标签（中规中矩，安全方便）</h3><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserLikeName2<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bind</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>%<span class="token punctuation">'</span>+name+<span class="token punctuation">'</span>%<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>       select * from user where username like  #&#123;item&#125;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//查询有"王"字</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span>  <span class="token function">selectUserLikeName2</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserLikeName2</span><span class="token punctuation">(</span><span class="token string">"王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>既可以防止sql注入，又不依赖数据库 任何数据库都可以执行</strong></p><h2 id="六、案例6：插入语句并获得主键"><a href="#六、案例6：插入语句并获得主键" class="headerlink" title="六、案例6：插入语句并获得主键"></a>六、案例6：插入语句并获得主键</h2><h3 id="方式1-通过useGeneratedKeys"><a href="#方式1-通过useGeneratedKeys" class="headerlink" title="方式1: 通过useGeneratedKeys"></a>方式1: 通过useGeneratedKeys</h3><blockquote><p>通过 useGeneratedKeys拿到数据库自动增长的id值，赋给插入对象的主键字段（user 对象的id属性）</p></blockquote><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span> <span class="token attr-name">useGeneratedKeys</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;, #&#123;address&#125; ) <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre><p>段落引用</p><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"龙哥"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"重庆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>userMapper<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//持有持久化ID</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="方式2-通过数据库函数实现"><a href="#方式2-通过数据库函数实现" class="headerlink" title="方式2: 通过数据库函数实现"></a>方式2: 通过数据库函数实现</h3><blockquote><p>自动增长的id :  select last_insert_id()</p><p>获取uuid: select uuid()</p></blockquote><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 字符串类型作为主键 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertEmployee<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selectKey</span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">order</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BEFORE<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            select uuid()        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selectKey</span><span class="token punctuation">></span></span>        insert into employee(id,name) values(#&#123;id&#125;,#&#123;name&#125;)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- int 类型作为主键 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertUser1<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selectKey</span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_int<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">order</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>AFTER<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            select last_insert_id()        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selectKey</span><span class="token punctuation">></span></span>        insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;, #&#123;address&#125;) <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">insertEmployee</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> employee<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">insertUser1</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"> <span class="token class-name">Employee</span> employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/*  employee.setId(IDGener.getUUID()); 默认情况下，缺少主键不能插入数据库*/</span> employee<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"员工222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> employeeMapper<span class="token punctuation">.</span><span class="token function">insertEmployee</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-------------------------------</span> <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"黄爷"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"重庆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> userMapper<span class="token punctuation">.</span><span class="token function">insertUser1</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="七、案例7：更新和删除操作"><a href="#七、案例7：更新和删除操作" class="headerlink" title="七、案例7：更新和删除操作"></a>七、案例7：更新和删除操作</h2><blockquote><p>通过删除和更新，事务处理</p><p>默认情况下 sqlSession 是事务不自动提交，需要显式提交</p></blockquote><blockquote><p>mapper.xml</p></blockquote><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delete</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>deleteUserByName<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      delete  from user where username = #&#123;username&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delete</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>update</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>updateUserNameById<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      update  user set username = #&#123;username&#125; where id = #&#123;id&#125; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>update</span><span class="token punctuation">></span></span></code></pre><blockquote><p>mapper 接口的代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteUserByName</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">updateUserNameById</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>测试代码</p></blockquote><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//true 自动提交 默认是true</span><span class="token comment">//在测试类中如果sqlSession为false，那么如果想要提交事务需要编写代码:</span>   <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDeleteUserByName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> isAuto <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            isAuto <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAutoCommit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userMapper<span class="token punctuation">.</span><span class="token function">deleteUserByName</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span>isAuto<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testUpdateUserNameById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> isAuto <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            isAuto <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAutoCommit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"黄柯"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userMapper<span class="token punctuation">.</span><span class="token function">updateUserNameById</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span>isAuto<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//结束</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis配置文件详解</title>
      <link href="/2020/04/21/Mybatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/21/Mybatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Mybatis配置文件讲解"><a href="#Mybatis配置文件讲解" class="headerlink" title="Mybatis配置文件讲解"></a>Mybatis配置文件讲解</h3><h4 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cfg/jdbc.properties<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>#jdbc.properties是properties文件</code></pre><p>如果有没有引入的“键值对”，可以用</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org/mybatis/example/config.properties<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dev_user<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>F2Fa3!33TYyg<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span></code></pre><span id="more"></span><h4 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h4><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项的意图、默认值等。<img src="http://cdn.leafii.top/img/20220520174231.png" loading="lazy"><br><img src="http://cdn.leafii.top/img/20220520174302.png" loading="lazy"><br><img src="http://cdn.leafii.top/img/20220520174322.png" loading="lazy"></p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lazyLoadingEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>multipleResultSetsEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>useColumnLabel<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>useGeneratedKeys<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>autoMappingBehavior<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PARTIAL<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>autoMappingUnknownColumnBehavior<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>WARNING<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>defaultExecutorType<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SIMPLE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>defaultStatementTimeout<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>25<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>defaultFetchSize<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>safeRowBoundsEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapUnderscoreToCamelCase<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>localCacheScope<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SESSION<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbcTypeForNull<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>OTHER<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lazyLoadTriggerMethods<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>equals,clone,hashCode,toString<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span></code></pre><h4 id="类型别名（typeAliases）"><a href="#类型别名（typeAliases）" class="headerlink" title="类型别名（typeAliases）"></a>类型别名（typeAliases）</h4><p>类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Author<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog.Author<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog.Blog<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Comment<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog.Comment<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Post<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog.Post<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Section<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog.Section<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Tag<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog.Tag<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">></span></span></code></pre><p>当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">></span></span></code></pre><p>每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子：</p><pre class="language-markup" data-language="markup"><code class="language-markup">@Alias("author")public class Author &#123;    ...&#125;</code></pre><p>这是一些为常见的 Java 类型内建的相应的类型别名。它们都是不区分大小写的，注意对基本类型名称重复采取的特殊命名风格。</p><p><img src="http://cdn.leafii.top/img/20220520174343.png" loading="lazy"><br><img src="http://cdn.leafii.top/img/20220520174359.png" loading="lazy"></p><h4 id="类型处理器（typeHandlers）"><a href="#类型处理器（typeHandlers）" class="headerlink" title="类型处理器（typeHandlers）"></a>类型处理器（typeHandlers）</h4><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式<strong>转换</strong>成 Java 类型。下表描述了一些默认的类型处理器。</p><p><strong>提示 从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。</strong><br><img src="http://cdn.leafii.top/img/20220520174415.png" loading="lazy"><br><img src="http://cdn.leafii.top/img/20220520174429.png" loading="lazy"></p><p>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个 JDBC 类型。比如：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// ExampleTypeHandler.java</span><span class="token annotation punctuation">@MappedJdbcTypes</span><span class="token punctuation">(</span><span class="token class-name">JdbcType</span><span class="token punctuation">.</span>VARCHAR<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExampleTypeHandler</span> <span class="token keyword">extends</span> <span class="token class-name">BaseTypeHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNonNullParameter</span><span class="token punctuation">(</span><span class="token class-name">PreparedStatement</span> ps<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">String</span> parameter<span class="token punctuation">,</span> <span class="token class-name">JdbcType</span> jdbcType<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    ps<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getNullableResult</span><span class="token punctuation">(</span><span class="token class-name">ResultSet</span> rs<span class="token punctuation">,</span> <span class="token class-name">String</span> columnName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>columnName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getNullableResult</span><span class="token punctuation">(</span><span class="token class-name">ResultSet</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> columnIndex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>columnIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getNullableResult</span><span class="token punctuation">(</span><span class="token class-name">CallableStatement</span> cs<span class="token punctuation">,</span> <span class="token keyword">int</span> columnIndex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> cs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>columnIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- mybatis-config.xml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeHandlers</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeHandler</span> <span class="token attr-name">handler</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.example.ExampleTypeHandler<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeHandlers</span><span class="token punctuation">></span></span></code></pre><p>使用上述的类型处理器将会覆盖已经存在的处理 Java 的 String 类型属性和 VARCHAR 参数及结果的类型处理器。 要注意 MyBatis 不会通过窥探数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明那是 VARCHAR 类型的字段， 以使其能够绑定到正确的类型处理器上。这是因为 MyBatis 直到语句被执行时才清楚数据类型。</p><p>(详情点击底部友情链接，后续可能暂时用不到自定义&#x3D;-&#x3D;)</p><p>例：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>       <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"z"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">62</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre><p>这个map 想让mybatis通过map 将数据包装成Point类 所以用到这个东西</p><h4 id="对象工厂（略）"><a href="#对象工厂（略）" class="headerlink" title="对象工厂（略）"></a>对象工厂（略）</h4><h4 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h4><p> 例：<br>可以通过mvn网站下载pageHelper插件<br><img src="http://cdn.leafii.top/img/20220520174449.png" loading="lazy"></p><h4 id="环境配置（environments）"><a href="#环境配置（environments）" class="headerlink" title="环境配置（environments）"></a>环境配置（environments）</h4><p>基本用不到</p><h4 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h4><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。 但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:&#x2F;&#x2F;&#x2F; 的 URL），或类名和包名等。例如：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 使用相对于类路径的资源引用 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org/mybatis/builder/AuthorMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org/mybatis/builder/BlogMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org/mybatis/builder/PostMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span></code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 使用完全限定资源定位符（URL） --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file:///var/mappers/AuthorMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file:///var/mappers/BlogMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file:///var/mappers/PostMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span></code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.builder.AuthorMapper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.builder.BlogMapper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.builder.PostMapper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span></code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.builder<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span>#package里的'.'可以换成'/' 嘿嘿！</code></pre><p>这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了，也就是接下来我们要讨论的。</p><h5 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h5><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">附上Mybatis关于配置文件的官网以供查阅&#x3D;-&#x3D;</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis引入日志</title>
      <link href="/2020/04/21/Mybatis%E5%BC%95%E5%85%A5%E6%97%A5%E5%BF%97/"/>
      <url>/2020/04/21/Mybatis%E5%BC%95%E5%85%A5%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h3 id="Mybatis进阶"><a href="#Mybatis进阶" class="headerlink" title="Mybatis进阶"></a>Mybatis进阶</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="引入日志依赖包（pom-xml）"><a href="#引入日志依赖包（pom-xml）" class="headerlink" title="引入日志依赖包（pom.xml）"></a>引入日志依赖包（pom.xml）</h5><p>会自动引入log4j以及slf4j-api<br><strong>引入日志要记得和自己的mybatis版本相匹配！建议在mvn的网站中寻找最匹配版本，如下图所示：</strong><br><img src="http://cdn.leafii.top/img/20220520174034.png" loading="lazy"></p><span id="more"></span><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h6 id="添加log4j-properties在resource下（也就是根目录下）"><a href="#添加log4j-properties在resource下（也就是根目录下）" class="headerlink" title="添加log4j.properties在resource下（也就是根目录下）"></a>添加log4j.properties在resource下（也就是根目录下）</h6><pre class="language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># Global logging configuration</span><span class="token key attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token value attr-value">ERROR, stdout</span><span class="token comment"># MyBatis logging configuration...</span><span class="token key attr-name">log4j.logger.top.leafii.mapper.UserMapper</span><span class="token punctuation">=</span><span class="token value attr-value">TRACE</span><span class="token comment">#top.leafii.mapper.UserMapper换成自己的Mapper类的相对路径</span><span class="token comment"># Console output...</span><span class="token key attr-name">log4j.appender.stdout</span><span class="token punctuation">=</span><span class="token value attr-value">org.apache.log4j.ConsoleAppender</span><span class="token key attr-name">log4j.appender.stdout.layout</span><span class="token punctuation">=</span><span class="token value attr-value">org.apache.log4j.PatternLayout</span><span class="token key attr-name">log4j.appender.stdout.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token value attr-value">%5p [%t] - %m%n</span></code></pre><h6 id="运行你的test方法，看看打印的日志"><a href="#运行你的test方法，看看打印的日志" class="headerlink" title="运行你的test方法，看看打印的日志"></a>运行你的test方法，看看打印的日志</h6><p><img src="http://cdn.leafii.top/img/20220520174103.png" loading="lazy"></p><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><p>####### 修改TRACE为debug</p><p>很多时候我们只注意操作的sql语句是什么 而不是其他的东西，因此我们将log4j.properties中的</p><pre class="language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">log4j.logger.top.leafii.mapper.UserMapper</span><span class="token punctuation">=</span><span class="token value attr-value">TRACE</span><span class="token comment">#修改为</span><span class="token key attr-name">log4j.logger.top.leafii.mapper.UserMapper</span><span class="token punctuation">=</span><span class="token value attr-value">debug</span></code></pre><p><img src="http://cdn.leafii.top/img/20220520174125.png" loading="lazy"><br>现在看看是不是清爽了很多？</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p> 每次我们写mybatis都要重新写log4j配置文件 岂不是很麻烦</p><h5 id="修改pom-xml"><a href="#修改pom-xml" class="headerlink" title="修改pom.xml"></a>修改pom.xml</h5><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="http://cdn.leafii.top/img/20220520174147.png" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatisの入门程序</title>
      <link href="/2020/04/11/Mybatis%E3%81%AE%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/04/11/Mybatis%E3%81%AE%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="Mybatis入门"><a href="#Mybatis入门" class="headerlink" title="Mybatis入门"></a>Mybatis入门</h3><h4 id="为什么使用Mybatis？"><a href="#为什么使用Mybatis？" class="headerlink" title="为什么使用Mybatis？"></a>为什么使用Mybatis？</h4><p>我们要从JDBC程序开始说起</p><h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p>案例场景: 根据 user 表，查询出所有“上海”的用户对象，返回一个pojo的 List集合。</p><span id="more"></span><h5 id="初始化测试数据"><a href="#初始化测试数据" class="headerlink" title="初始化测试数据"></a>初始化测试数据</h5><p>1、创建数据库，数据库名：mybatisDemo</p><p>2、将如下Sql语句在数据库中执行，初始化测试数据</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">-- ------------------------------ Table structure for &#96;user&#96;-- ----------------------------DROP DATABASE IF EXISTS &#96;mybatisDemo&#96;;CREATE DATABASE mybatisDemo CHARSET&#x3D;utf8;DROP TABLE IF EXISTS &#96;user&#96;;CREATE TABLE &#96;user&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;username&#96; varchar(32) NOT NULL COMMENT &#39;用户名称&#39;,  &#96;birthday&#96; date DEFAULT NULL COMMENT &#39;生日&#39;,  &#96;sex&#96; char(1) DEFAULT NULL COMMENT &#39;性别&#39;,  &#96;address&#96; varchar(256) DEFAULT NULL COMMENT &#39;地址&#39;,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;27 DEFAULT CHARSET&#x3D;utf8; -- ------------------------------ Records of user-- ----------------------------INSERT INTO &#96;user&#96; VALUES (&#39;1&#39;, &#39;张三&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;北京&#39;);INSERT INTO &#96;user&#96; VALUES (&#39;2&#39;, &#39;李四&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;上海&#39;);INSERT INTO &#96;user&#96; VALUES (&#39;3&#39;, &#39;王五&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;广州&#39;);INSERT INTO &#96;user&#96; VALUES (&#39;4&#39;, &#39;王六&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;深圳&#39;);INSERT INTO &#96;user&#96; VALUES (&#39;5&#39;, &#39;王八&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;上海&#39;);</code></pre><h5 id="JDBC-实现"><a href="#JDBC-实现" class="headerlink" title="JDBC 实现"></a>JDBC 实现</h5><p>代码：</p><ol><li>创建pojo类<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> sex<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Date</span> birthday<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>     <span class="token comment">// 省略getter ，setter，toString 方法</span>     <span class="token comment">// ......</span>       <span class="token comment">// ......</span><span class="token punctuation">&#125;</span></code></pre>2.编写JDBC代码<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdbcTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">ResultSet</span> resultSet <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">PreparedStatement</span> preparedStatement <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://127.0.0.1:3306/mybatisdemo"</span><span class="token punctuation">;</span>            connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token string">"root"</span><span class="token punctuation">,</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//JDK 1.7 之后才允许</span>            <span class="token comment">//</span>            <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">" select  id, username ,birthday,sex , address from user where address  = ? "</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> addr <span class="token operator">=</span> <span class="token string">"上海"</span><span class="token punctuation">;</span>            preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>            preparedStatement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> isSelect <span class="token operator">=</span> preparedStatement<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>isSelect<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                resultSet <span class="token operator">=</span> preparedStatement<span class="token punctuation">.</span><span class="token function">getResultSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> id <span class="token operator">=</span> resultSet<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">String</span> username <span class="token operator">=</span> resultSet<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Date</span> birthday <span class="token operator">=</span> resultSet<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token string">"birthday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">String</span> sex <span class="token operator">=</span> resultSet<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"sex"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">String</span> address <span class="token operator">=</span> resultSet<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">,</span>sex<span class="token punctuation">,</span>birthday<span class="token punctuation">,</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>                    users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> u <span class="token operator">:</span>                    users<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token comment">/*        ResultSet resultSet = preparedStatement.executeQuery();            int count = preparedStatement.executeUpdate();*/</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span><span class="token comment">//            关闭结果集</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>resultSet<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> resultSet<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//            关闭statement</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>preparedStatement<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> preparedStatement<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//            关闭连接</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> connection<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li></ol><h4 id="JDBC问题分析："><a href="#JDBC问题分析：" class="headerlink" title="JDBC问题分析："></a>JDBC问题分析：</h4><p>上边使用JDBC的原始方法（未经封装）实现了查询数据库表记录的操作。</p><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p><p>2、Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变Java代码。</p><p>3、使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</p><p>4、对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。</p><p>下面我们将通过Mybatis 解决部分问题。</p><h4 id="Mybatis-实现"><a href="#Mybatis-实现" class="headerlink" title="Mybatis 实现"></a>Mybatis 实现</h4><ol><li><p>创建maven工程</p></li><li><p>导入mybatis，jdbc等相关包</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>     <span class="token comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.48<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>     <span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.5.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>     <span class="token comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre></li><li><p>建立数据库和数据表</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">-- ------------------------------ Table structure for &#96;user&#96;-- ----------------------------DROP DATABASE IF EXISTS &#96;mybatisDemo&#96;;CREATE DATABASE mybatisDemo CHARSET&#x3D;utf8;DROP TABLE IF EXISTS &#96;user&#96;;CREATE TABLE &#96;user&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;username&#96; varchar(32) NOT NULL COMMENT &#39;用户名称&#39;,  &#96;birthday&#96; date DEFAULT NULL COMMENT &#39;生日&#39;,  &#96;sex&#96; char(1) DEFAULT NULL COMMENT &#39;性别&#39;,  &#96;address&#96; varchar(256) DEFAULT NULL COMMENT &#39;地址&#39;,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;27 DEFAULT CHARSET&#x3D;utf8;-- ------------------------------ Records of user-- ----------------------------INSERT INTO &#96;user&#96; VALUES (&#39;1&#39;, &#39;张三&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;北京&#39;);INSERT INTO &#96;user&#96; VALUES (&#39;2&#39;, &#39;李四&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;上海&#39;);INSERT INTO &#96;user&#96; VALUES (&#39;3&#39;, &#39;王五&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;广州&#39;);INSERT INTO &#96;user&#96; VALUES (&#39;4&#39;, &#39;王六&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;深圳&#39;);INSERT INTO &#96;user&#96; VALUES (&#39;5&#39;, &#39;王八&#39;, &#39;2018-07-10&#39;, &#39;1&#39;, &#39;上海&#39;);</code></pre></li><li><p>配置jdk编译环境，防止乱码</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span></code></pre></li><li><p>新建实体类和Dao接口</p></li></ol>   <pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> sex<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Date</span> birthday<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//get，set 构造方法以及toString方法省略</span></code></pre>   <pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDao</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">User</span> <span class="token function">selectUserByPrimaryKey</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ol start="6"><li><p>配置使用mybatis</p><ol><li><p>配置文件：mybatis-cofig.xml（数据库连接信息）</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">configuration</span>        <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Config 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>env1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>env1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc:mysql://127.0.0.1:3306/mybatisDemo<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mybatis/mapper/UserMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre></li><li><p>映射文件：UserDao.xml（sql语句 ）</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">mapper</span>        <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatis01hello.dao.UserDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByPrimaryKey<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_int<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.suncaper.mybatis01hello.domain.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user where id = #&#123;id&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre></li></ol></li></ol><p>也可以把配置文件写成这样，使用resultMap的方式让查询出的值与实体类的属性名一一对应：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">mapper</span>        <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.mybatis01.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top.leafii.mybatis01.domain.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUserByAddrSexa<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user where sex=#&#123;sex&#125; and address=#&#123;address&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><pre><code>  * 名称空间namespace要和Dao接口的完整类名对应  * sql语句的id和方法名一致  * 注意写上sql语句的参数和返回类型（parameterType 和 resultType )  * parameterType如果方法中是int，parameterType要写成_int,如果方法中是Integer，就要写成int  * resultType就是为了将查询好的数据的字段名和实体类的属性一一对应  * 记住把映射文件添加到配置文件中(mapper标签 )</code></pre><ol start="7"><li><p>写java运行代码</p><ul><li>读取配置文件</li><li>创建SqlSessionFactory对象</li><li>打开SqlSession 对象（mybatis框架的核心对象）</li><li>通过SqlSession获取UserDao接口对象</li><li>执行对应的sql方法</li><li>关闭SqlSession</li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">UserDao</span> dao <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//1. 读取配置文件</span>        <span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token class-name">Resources</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"mybatis/mybatis-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2. 创建SqlSessionFactory</span>        <span class="token class-name">SqlSessionFactory</span> sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3. 打开SqlSession，SqlSession相当于jdbc的Connection</span>        <span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4. 拿到Dao接口代理对象</span>        <span class="token class-name">UserDao</span> dao <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">UserDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> dao<span class="token punctuation">.</span><span class="token function">selectUserByPrimaryKey</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5.关闭资源</span>        sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><hr><p><a href="https://mybatis.org/mybatis-3/zh/index.html">Mybatis官网</a><br><a href="https://mvnrepository.com/">mavenreposiry网站</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mavenの入门</title>
      <link href="/2020/04/11/Maven%E5%85%A5%E9%97%A8/"/>
      <url>/2020/04/11/Maven%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven入门"><a href="#Maven入门" class="headerlink" title="Maven入门"></a>Maven入门</h1><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>提出需求</p><p> <strong>做项目需要引入很多jar包</strong></p><p> <strong>如果使用Spring框架，要引入jar包</strong></p><p> <strong>SpringMVC Mybatis 都需要很多jar包</strong></p><span id="more"></span><p>解决办法：<br>使用maven</p><h4 id="什么是maven？"><a href="#什么是maven？" class="headerlink" title="什么是maven？"></a>什么是maven？</h4><p>　　Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具，简单的说就是用来管理项目所需要的依赖且管理项目构建的工具。</p><h4 id="maven的安装与配置"><a href="#maven的安装与配置" class="headerlink" title="maven的安装与配置"></a>maven的安装与配置</h4><p>   类似tomcat maven也是需要安装和配置，还有配置到idea中的</p><ol><li><a href="http://maven.apache.org/download.cgi">下载maven</a>  推荐下载tar.gz的解压包<img src="http://cdn.leafii.top/img/20220520160258.png" loading="lazy"></li><li>解压到指定目录</li></ol><pre class="language-none"><code class="language-none">tar -zxvf apa.... ~&#x2F;maven   </code></pre><p>我解压到了~&#x2F;maven&#x2F;apache……</p><ol start="3"><li>执行命令</li></ol><pre class="language-none"><code class="language-none">vim ~&#x2F;.bash_profile</code></pre><p>添加语句：</p><pre class="language-none"><code class="language-none">export M2_HOME&#x3D;$HOME&#x2F;maven&#x2F;apache-maven-3.6.2export PATH&#x3D;$PATH:$M2_HOME&#x2F;bin</code></pre><p>然后</p><pre class="language-none"><code class="language-none">resource ~&#x2F;.bash_profile</code></pre><p>然后执行</p><pre class="language-none"><code class="language-none">mvn -v</code></pre><p>显示<br><img src="http://cdn.leafii.top/img/20220520160313.png" loading="lazy"></p><p>就是安装成功了</p><p>如果你使用的是zsh 那么就需要修改你的zshrc文件 添加</p><pre class="language-none"><code class="language-none">source ~&#x2F;.bash_profile</code></pre><p>这样就可以自动刷新.bash_profile了</p><ol start="4"><li>接下来我们对idea进行配置<img src="http://cdn.leafii.top/img/20220520160327.png" loading="lazy"><br>切记，不但要配置当前项目，还要配置其他项目！</li></ol><p>5.配置conf文件夹中的setting.xml 在mirrors标签里添加</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>alimaven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>aliyun maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://maven.aliyun.com/nexus/content/groups/public/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span> </code></pre><p>使用阿里云的maven镜像，可以使maven下载速度更快哦</p><p>安装完毕啦！</p><hr><h4 id="新建一个maven项目"><a href="#新建一个maven项目" class="headerlink" title="新建一个maven项目"></a>新建一个maven项目</h4><ol><li><img src="http://cdn.leafii.top/img/20220520160342.png" loading="lazy"><br>这里让我们选模板 因为我们只做演示和试用，所以直接点击下一步</li></ol><p>2.这里groupid就是公司开发组的id，第二个就是项目名，第三个是版本<img src="http://cdn.leafii.top/img/20220520160402.png" loading="lazy"></p><ol start="3"><li>然后选择项目路径</li><li>此时进入了编码界面</li></ol><hr><h4 id="maven项目路径详解"><a href="#maven项目路径详解" class="headerlink" title="maven项目路径详解"></a>maven项目路径详解</h4><p> 可以看看当前的目录结构<br><img src="http://cdn.leafii.top/img/20220520160419.png" loading="lazy"></p><p>src中有main文件夹和test文件夹</p><p>main文件夹主要存放你的java代码，test文件夹主要用来运行你自己写的测试类。</p><p>pom.xml就是标识我们所需要的jar包的文件，如果需要添加jar包依赖，要向这个文件中添加代码</p><hr><p>例：添加mysql的java链接jar包：<br><a href="https://mvnrepository.com/">前往maven官网</a> :获取xml代码<br><img src="http://cdn.leafii.top/img/20220520160437.png" loading="lazy"></p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.38<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>将代码放置在pom.xml中，要放置在dependencies标签中<br><img src="http://cdn.leafii.top/img/20220520160640.png" loading="lazy"></p><p>然后maven就会开始自动下载依赖包了<br><img src="http://cdn.leafii.top/img/20220520160654.png" loading="lazy"><br>当字体不再是红色 说明jar包加载好了 此时就可以使用jar包啦！</p><p><img src="http://cdn.leafii.top/img/20220520160713.png" loading="lazy"><br>此时idea可以自动联想了，说明下载好了。<br><img src="http://cdn.leafii.top/img/20220520160727.png" loading="lazy"><br>此时的项目可以直接添加框架支持了</p><hr><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><ol><li>Maven是一个核心引擎，提供了基本的项目处理能力和建设过程的管理，以及一系列的插件是用来执行实际建设任务。maven插件可以完成一些特定的功能。例如，集成jdk插件可以方便的修改项目的编译环境；集成tomcat插件后，无需安装tomcat服务器就可以运行tomcat进行项目的发布与测试。在pom.xml中通过plugin标签引入maven 的功能插件。</li><li>JDK编译版本的插件<br>插件可以去其他第三方仓库进行寻找，或者使用IDEA集成外部Tomcat8及其以上版本，进行项目的发布。</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>showWarnings</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>showWarnings</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span></code></pre><ol start="3"><li>导入依赖<br>导入依赖坐标，无需手动导入jar包就可以引入jar。在pom.xml中使用标签引入依赖。</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.8.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="4"><li>关于scope<br><img src="http://cdn.leafii.top/img/20220520160747.png" loading="lazy"></li></ol><ul><li>compile 编译、测试、运行，A在编译时依赖B，并且在测试和运行时也依赖<br>例如：strus-core、spring-beans。打到war包或jar包</li><li>provided 编译、和测试有效，A在编译和测试时需要B<br>例如：servlet-api就是编译和测试有用，在运行时不用（tomcat容器已提供） 不会打到war</li><li>runtime：测试、运行有效<br>例如：jdbc驱动包 ，在开发代码中针对java的jdbc接口开发，编译不用 在运行和测试时需要通过jdbc驱动包（mysql驱动）连接数据库，需要的 会打到war</li><li>test：只是测试有效，只在单元测试类中用 例如：junit 不会打到war<br>按照依赖强度，由强到弱来排序：(理解) compile&gt; provided&gt; runtime&gt; test</li></ul><hr><p>以上就是全部maven的内容，后续可能会有补充</p>]]></content>
      
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录Javaの一次考试</title>
      <link href="/2020/04/11/%E8%AE%B0%E5%BD%95Java%E3%81%AE%E4%B8%80%E6%AC%A1%E8%80%83%E8%AF%95/"/>
      <url>/2020/04/11/%E8%AE%B0%E5%BD%95Java%E3%81%AE%E4%B8%80%E6%AC%A1%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="记录Javaの一次考试"><a href="#记录Javaの一次考试" class="headerlink" title="记录Javaの一次考试"></a>记录Javaの一次考试</h1><p>今天 考试了<br>试卷以及答案</p><span id="more"></span><p>不定选择题（30分）<br>1．下面程序哪个语句是正确的(   )<br>A.  byte a&#x3D;0,b&#x3D;3; byte c &#x3D;a+b;  默认int<br>B.  short s &#x3D;23; s&#x3D;s+12; 默认int<br>✅C.  short s&#x3D;23; s+&#x3D;12; 默认（short)(s &#x3D; s+12)<br>D.  float f &#x3D; 23+23.23;缺少f后缀</p><ol start="2"><li>下面程序的运行后,结果正确的是：（）<br>int a&#x3D;1,b&#x3D;2;<br>int c&#x3D;(a+b&gt;3?a++:++b);     a+b&#x3D;3 执行++b语句 b &#x3D; b+1 -&gt;b &#x3D; 3    a保持不变  c &#x3D; 3<br>A.  a&#x3D;2,b&#x3D;3    ✅B.  a&#x3D;1,b&#x3D;3       C.  a&#x3D;1,b&#x3D;2           D.  c&#x3D;2<br>3.下面程序执行的结果<br>for(int  i&#x3D;1;i&lt;&#x3D;10;i++){<br>if (i%3&#x3D;&#x3D;0) {<br>   continue; }<br>System.out.println(“java基础”);<br>}<br>在屏幕上打印几次“java基础”?(  )<br>3 6 9不打印 1，2，4，5，7，8，10 共七次打印<br>A. 5  B. 6    ✅C. 7    D. 8</li><li>阅读下面代码段：<br>classDemo{<br>　　public static void main (String[] args){<br>   int[] arr &#x3D; new int[10];<br>　　  System.out.println(arr[1]);<br>　　}}<br>执行结果正确的说法是( )            数组未初始化 默认为0<br>A.  编译时将产生错误               B.  编译时正确，运行时将产生错误<br>C.✅  输出零                         D.  输出空</li><li>和下面代码能完成相同的选项是（）<br>int i&#x3D;1;<br>intsum&#x3D;0;<br>while(i&lt;&#x3D;100){<br>if(i%2&#x3D;&#x3D;0){<br>   sum&#x3D;sum+i;<br>}<br>i++;<br>}     此代码为1到100所有的偶数求和<br>A.  for (int x&#x3D;1; x&lt;&#x3D;100;x++){ sum&#x3D;sum+x;}              B✅.  for (int x &#x3D;0; x&lt;&#x3D;100;x+&#x3D;2){ sum&#x3D;sum+x;}<br>C.  for (int x &#x3D;1; x&lt;&#x3D;100;x+&#x3D;2){ sum&#x3D;sum+x;}             D.上述全对</li><li>以下对继承的描述错误的是（）<br>A)✅ Java中的继承允许一个子类继承多个父类    java不允许多继承<br>B) 父类更具有通用性，子类更具体        正确<br>C) Java中的继承存在着传递性     正确<br>D) 当实例化子类时会递归调用父类中的构造方法    正确<br>&#x2F;&#x2F;对象创建的过程<br>&#x2F;&#x2F; 0.按照1~5顺序构造父类，但依次先类加载所有类型<br>&#x2F;&#x2F; 1.类加载:静态代码块<br>&#x2F;&#x2F; 2.默认初始化成员变量<br>&#x2F;&#x2F; 3.显式初始化成员变量<br>&#x2F;&#x2F; 4.实例代码块<br>&#x2F;&#x2F; 5.构造方法</li><li>下面哪些是合法的标志符（）<br>A.  2variable（数字不能做开头）    B✅.  variable2     C✅.  what$     D✅.  <em>3</em></li><li>下列方法中能和方法int max(int  a, int  b, double  c)构成重载关系的是(  )<br>函数的重载就是在同一个类中允许同时存在一个以上的同名函数，只要它们的参数个数或类型不同即可。<br>在同一个类中可以定义多个同名方法—方法名重载(overload)。<br>A.  double max(int  a, int  b, double c)                  B✅.  void max(int  a, double  c, int b)<br>C✅.  int max(double a, int  b)                           D.  int max(int  x, int  y, double z)</li><li>下面关于循环描述正确的是（）<br>A✅.  while循环先判断循环条件，后执行循环操作         B.  while 至少会执行一次<br>C.  do-while先进行循环条件判断，后执行循环操作       D.✅ do-while循环至少执行一次，后进行循环判断</li><li>以下关于final关键字说法错误的是（）<br>A✅) final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性<br>final关键字不能用来抽象类和接口。<br>B) final修饰的类肯定不能被继承<br>C✅) final修饰的方法不能被重载<br>方法可以被重载 不能被重写<br>D) final修饰的变量不允许被再次赋值</li><li>根据下面的代码，<br>String s &#x3D; null;会抛出NullPointerException异常的有（）<br>A✅) if( (s!&#x3D;null) &amp; (s.length()&gt;0) )                          B) if( (s!&#x3D;null) &amp; &amp; (s.length()&gt;0) )<br>C✅) if( (s&#x3D;&#x3D;null) | (s.length()&#x3D;&#x3D;0) )                         D) if( (s&#x3D;&#x3D;null) || (s.length()&#x3D;&#x3D;0) )<br>考察短路</li><li>以下关于对象序列化描述正确的是（  ）<br>A) 使用FileOutputStream可以将对象进行传输<br>不行！</li></ol><p>B✅) 使用PrintWriter可以将对象进行传输<br>C✅) 使用ObjectOutputStream类完成对象存储，使用ObjectInputStream类完成对象读取<br>D✅) 对象序列化的所属类需要实现Serializable接口</p><ol start="13"><li>下面是有关子类继承父类构造函数的描述，其中正确的是：(  )<br>A. 创建子类的对象时，先调用子类自己的构造函数，然后调用父类的构造函数。  错误<br>&#x2F;&#x2F;对象创建的过程<br>&#x2F;&#x2F; 0.按照1~5顺序构造父类，但依次先类加载所有类型<br>&#x2F;&#x2F; 1.类加载:静态代码块<br>&#x2F;&#x2F; 2.默认初始化成员变量<br>&#x2F;&#x2F; 3.显式初始化成员变量<br>&#x2F;&#x2F; 4.实例代码块<br>&#x2F;&#x2F; 5.构造方法</li></ol><p>B. 子类可以不调用父类的构造函数  错误<br>C✅. 子类必须通过super()关键字调用父类的构造函数<br>D. 子类可以继承父类的构造函数。 错误</p><ol start="14"><li>构造函数何时被调用(    )<br>A、类定义时               B✅.创建对象时<br>C.调用对象方法时           D.使用对象的变量时 </li><li>函数重载是指 (    )<br> A✅、两个或两个以上的函数取相同的函数名，但形参的个数或类型不同<br> B、两个以上的函数取相同的名字和具有相同的参数个数，但形参的类型可以不同<br> C、两个以上的函数名字不同，但形参的个数或类型相同<br> D、两个以上的函数取相同的函数名，并且函数的返回类型相同</li></ol><p>判断题（T&#x2F;F）（10分）</p><ol><li>HashMap集合不允许存储重复键.           ✅</li><li>在Java中声明变量时可以不指定一个类型。      ❎ java是强语言</li><li>数组有length（）这个方法。    ❎ 数组只有length属性</li><li>Object是Java中所有类的共同父类。   ✅</li><li>一个数组可以存放不同类型的数值。   ❎ 只能存放同一个类型的数值</li><li>对象是类的实例.     ✅</li><li>被final修饰后的类，只能指向一个对象，地址不能再更改，对象内部的成员也不能修改。  ❎ 对象内部的成员可以修改</li><li>静态变量是被同一个类的所有实例所共享的。     ✅</li><li>Java中所有的I&#x2F;O都是通过流来实现的。   ✅</li><li>static关键字可以修饰成员变量，也可以修饰局部变量。   ❎ static不能修饰局部变量<br>填空题（10分）</li><li>一个long型数据在内存占( 8 )个字节。  </li><li>表达式19&#x2F;3*3+19%3的值是( 19 )。   18+1&#x3D;19</li><li>若a和b都是整数，则生成[a, b]范围内随机整数的表达式是(          Math.Random()*(b-a+1)+a       )</li><li>若char型变量c存储的是一个大写字母，则输出其对应小写字母的语句是(   System.out.println(c+32)       )</li><li>面向对象特点是（ 封装 ）、（ 继承  ）、（  多态  ）。</li><li>JVM运行java分为（ 编译  ）、（ 运行 ）两个阶段。</li><li>使用继承关键字是（ extends  ）。</li><li>Exception分为（ 运行时异常 ）、（ 编译时异常  ）两大类。</li><li>所有字节输出流的超类是（ InputStream ），所有字节输入流的超类是（  OutputStream  ）。</li><li>所有集合的父接口是（ Collections ）。<br>解答题（20分）<br>1.”&#x3D;&#x3D;”和”equals”的区别。<br>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。<br>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。<br>2.简单说明函数重载和函数重写。<br>Override是覆盖的意思，也就是重写，它与返回值类型无关，只看参数列表;<br>Overload是重载的意思，表示在同一个类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可;<br>两者不同主要体现在：目的不同、范围不同、参数要求不同、返回类型不同。</li></ol><ul><li>同:overload用于增加程序的可读性(做法不同,但是做的同一事情)。 override用于提供其超级类已经提供的方法的特定实现。</li><li>同:overload 在相同的类范围内内执行。 override发生在两类具有继承（继承）的关系。</li><li>参数要求不同:overload参数必须不同。 override参数必须相同。</li><li>返回类型不同:overload中可以相同或不同。 override必须是相同的或协变的。<br>3.请说出作用域public，private，protected，以及不写时的区别<br>1、public： 所修饰的类、变量、方法，在内外包均具有访问权限；<br>2、protected： 这种权限是为继承而设计的，protected所修饰的成员，对所有子类是可访问的，但只对同包的类是可访问的，对外包的非子类是不可以访问；<br>3、包访问权限（default）： 只对同包的类具有访问的权限，外包的所有类都不能访问；  不写的时候<br>4、private： 私有的权限，只对本类的方法可以使用；</li></ul><ol start="4"><li>String s &#x3D; “Hello”;s &#x3D; s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？String s1&#x3D;new String(“java”)创建了几个对象？<br>1）原始的内容没有改变 JVM在堆内存中创建了一个新的“Helloworld”对象，原来的“Hello”对象成为废弃对象<br>2）如果之前的代码没有新建内容为“java”的对象在堆内存中，则创建了两个对象，否则创建了一个对象。<br>5.java的基本数据类型有哪些？<br>byte,short,int,long,float,double,boolean,char</li><li>final, finally, finalize的区别。<br>final：Java中关键字，修饰符。<br> 如果一个类被声明为final，则意味着该类不能被继承，无法派生出新的子类。所以，一个类不能同时被abstract和final修饰。<br>如果将变量或者方法声明为final，可以保证变量和方法在以后的使用中，不会被修改。被final修饰的变量必须在声明时赋初值，在以后的引用中只能读取，不能修改。被final修饰的方法只能使用，不能被重写。<br>finally：表示一种异常处理机制。<br> finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。</li></ol><p>finalize: Java中的Object类的一个方法名。<br>    Java中，垃圾收集器在将对象从内存中清除出去前，需要使用finalize()方法做一些必要的清理工作。这个方法是由垃圾收集器在确定该对象没有被引用时，对该对象调用**finalize()**方法。因为该方法是在Object类中定义的，因此所有的类都继承了该方法。子类可以覆盖该方法来整理系统资源或者执行其他的清理工作。</p><ol start="7"><li><p>实现一个线程的两种方式；调用start()方法和run()方法有什么区别？<br>1)1.通过继承Thread类实现线程<br> 2.通过实现Runnable接口实现线程<br>2）start()方法是开启了一个线程，会自动调用run()方法，此时程序会自动往下执行，此时不等start()方法执行完。<br>如果线程直接调用run()方法，则程序会等run()方法执行完再往下执行。</p></li><li><p>说出ArrayList,Vector, LinkedList的存储性能和特性<br>1）ArrayList和Vector都是数组作为底层，查找比较方便，不擅长大量的添加和删除。Vector与ArrayList相比线程安全<br>2）LinkedList是以链表作为底层，添加删除比较方便，查找效率较低。</p></li><li><p>什么是java序列化，如何实现java序列化？<br>1）序列化：把对象转换为字节序列的过程称为对象的序列化。<br>2）实现Serializable接口，再使用ObjectOutputStream类 即可序列化java类</p></li><li><p>说说&amp;和&amp;&amp;的区别。<br>1.&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。<br>2.&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str !&#x3D; null &amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。If(x&#x3D;&#x3D;33 &amp; ++y&gt;0) y会增长，If(x&#x3D;&#x3D;33 &amp;&amp; ++y&gt;0)不会增长<br>3.&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。<br>编程题（30分）<br>1.Account.java文件中定义了一个银行帐户类Account，其中包括了帐户名属性accountName、存款余额属性amount、存款方法deposit（double money）。阅读并理解这个类，并为其增加一个“取款”方法withdraw()：当存款余额大于取款金额时，执行取款修改余额；当存款余额小于取款金额时，不执行取款；以返回值0表示取款成功，返回值1表示取款不成功。<br>public class Account {<br>private String accountName;<br>private double amount;<br>public void deposit(double money){<br>if(money&gt;0){<br>    this.amount+&#x3D;money;<br>}<br>}</p><p>public int withdraw(double money){<br>if(money&lt;amount){<br>    amount&#x3D;amount-money;<br>    return 0;<br>}<br>else{<br>    return 1;<br>}<br>}</p><p>public Account(String accountName, double amount) {<br>this.accountName &#x3D; accountName;<br>this.amount &#x3D; amount;<br>}</p><p>public Account() {<br>}<br>}<br>2.复制一个文件到另一个目录。<br>public class Copy {<br>public static void main(String[] args) throws IOException {<br>&#x2F;&#x2F; 1.创建流对象<br>&#x2F;&#x2F; 1.1 指定数据源<br>FileInputStream fis &#x3D; new FileInputStream(“D:\test.jpg”);<br>&#x2F;&#x2F; 1.2 指定目的地<br>FileOutputStream fos &#x3D; new FileOutputStream(“test_copy.jpg”);<br>&#x2F;&#x2F; 2.读写数据<br>&#x2F;&#x2F; 2.1 定义数组<br>byte[] b &#x3D; new byte[1024];<br>&#x2F;&#x2F; 2.2 定义长度<br>int len;<br>&#x2F;&#x2F; 2.3 循环读取<br>while ((len &#x3D; fis.read(b))!&#x3D;‐1) {<br>    &#x2F;&#x2F; 2.4 写出数据<br>    fos.write(b, 0 , len);<br>}<br>&#x2F;&#x2F; 3.关闭资源<br>fos.close();<br>fis.close();<br>}<br>}<br>3.键入一个字符串，求其中每个字符出现的次数，并按顺序打印，打印格式如下：<br>a:5<br>b:1<br>f:3<br>…<br>public class Test1 {<br>public static void main(String[] args) {<br>Scanner sc &#x3D; new Scanner(System.in);<br>String s;<br>System.out.print(“请输入字符串”);<br>s &#x3D; sc.nextLine();<br>Map&lt;Character,Integer&gt; map&#x3D;new TreeMap&lt;&gt;();<br>char[] chars &#x3D; s.toCharArray();<br>for(int i&#x3D;0;i&lt;chars.length;i++){<br>    if(map.get(chars[i])&#x3D;&#x3D;null){<br>        map.put(chars[i],1);<br>    }else{<br>        map.put(chars[i],map.get(chars[i])+1);<br>    }<br>}<br>Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries &#x3D; map.entrySet();<br>Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; iterator &#x3D; entries.iterator();<br>while (iterator.hasNext()){<br>    Map.Entry&lt;Character,Integer&gt; entry&#x3D;iterator.next();<br>    System.out.println(entry.getKey()+”:”+entry.getValue());<br>}<br>}<br>}</p></li></ol><h3 id="1-作业评讲："><a href="#1-作业评讲：" class="headerlink" title="1. 作业评讲："></a>1. 作业评讲：</h3><pre><code>* 数组的第一项是a[0]* if(b=true) 太繁琐 直接写成 if(b)* 求平均分要记得将sum设置成double 求的时候</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> avg <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="2-讲解了课堂练习："><a href="#2-讲解了课堂练习：" class="headerlink" title="2. 讲解了课堂练习："></a>2. 讲解了课堂练习：</h3><p>   1)输入一串字符串，输出里面有多少个a，多少个b，多少个c…<br>先用了测试类 junit4是不支持Scanner的 所以不能用test，要用main方法<br>可以通过’c’-‘a’的差值 得到索引值，通过int数组进行获取</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//System.in默认的关联就是键盘</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请输入一串小写字母："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">String</span> str <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//以回车符号作为结束的标志</span>       <span class="token comment">//可以为了测试方便 先把str的值写死，省去输入字符串的时间</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">char</span> a <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">int</span> index <span class="token operator">=</span> a <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>           arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">char</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s <span class="token operator">+</span> <span class="token string">"的个数："</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span></code></pre><hr><p>2）输入1<del>200的整数，5个奇数，5个偶数 不能重复 奇数偶数不能超过5个的上限 最后打印结果 A</del>Z a~z<br>提示信息：<br>    继续输入<br>结果例子：<br>您输入结果：<br>奇数： 1 5 7 65（A） 17*  素数<br>自己写的版本：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isSu</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> isSuSu <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    isSuSu <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span>                <span class="token punctuation">&#123;</span>isSuSu <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> isSuSu<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token function">isChar</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> ss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ss<span class="token operator">></span><span class="token char">'a'</span><span class="token operator">&amp;&amp;</span>ss<span class="token operator">&lt;</span><span class="token char">'z'</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>ss<span class="token operator">></span><span class="token char">'A'</span><span class="token operator">&amp;&amp;</span>ss<span class="token operator">&lt;</span><span class="token char">'Z'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> ss<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            ss <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ss<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isJi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> isJiJi <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            isJiJi <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            isJiJi <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> isJiJi<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isContain</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> isContains <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> aa<span class="token operator">:</span>             arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                isContains <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> isContains<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">:</span>                arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> str <span class="token operator">=</span> a<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSu</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                str <span class="token operator">+=</span> <span class="token string">"*"</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isChar</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                str <span class="token operator">+=</span> <span class="token string">"("</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token function">isChar</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token char">'\t'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> jiShu<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ouShu<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> indexJi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> indexOu <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请输入1~200的数字:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> input <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>input<span class="token operator">>=</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>input<span class="token operator">&lt;=</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>input<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span>indexOu<span class="token operator">>=</span><span class="token number">5</span><span class="token operator">||</span><span class="token function">isContain</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span>ouShu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"偶数数量已满5个或者有重复数字!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">continue</span><span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span>                    ouShu<span class="token punctuation">[</span>indexOu<span class="token punctuation">]</span> <span class="token operator">=</span> input<span class="token punctuation">;</span>                    indexOu<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>indexJi<span class="token operator">>=</span><span class="token number">5</span><span class="token operator">||</span><span class="token function">isContain</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span>jiShu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"奇数数量已满5个或者有重复数字!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    jiShu<span class="token punctuation">[</span>indexJi<span class="token punctuation">]</span> <span class="token operator">=</span> input<span class="token punctuation">;</span>                    indexJi<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你不认识字吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>indexJi<span class="token operator">>=</span><span class="token number">5</span><span class="token operator">&amp;&amp;</span>indexOu<span class="token operator">>=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token comment">//输入部分</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"您输入结果："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"奇数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNum</span><span class="token punctuation">(</span>jiShu<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"偶数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNum</span><span class="token punctuation">(</span>ouShu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>写代码之前一定要分析好需求和设计好写法 多用模块化</strong></p><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><ol><li>一个类与它的对象之间是什么关系？<br>答：类是对象的抽象，是一个拥有静态属性（如姓名，年龄）和动态属性（如睡觉跑步）的一个模板</li><li>如何定义一个类，由哪些部分组成，各个部分的作用是什么？<br>答：语法格式：<br>[&lt; 修饰符&gt;] class &lt; 类名&gt;<br>{<br> [&lt;属性声明&gt;]<br> [&lt;构造器声明&gt;]<br> [&lt;方法声明&gt;]<br>}<br>修饰符是用来做访问控制，类名就是类的名字，属性声明是类的静态属性，方法声明是类的动态属性。<br>说明：修饰符public：类可以被任意访问，类的正文要用{  }括起来</li><li>如何创建一个对象，如何使用该对象？<br>答：&lt; 类名&gt; [对象名] &#x3D; new &lt;类名&gt; [&lt;构造方法&gt;]<br>通过【对象名】.[属性名] 或者 [对象名].[方法名]进行使用</li><li>局部变量和成员变量的区别？<br>答：A:在类中的位置不同<br>成员变量：在类中方法外<br>局部变量：在方法定义中或者方法声明上<br>B:在内存中的位置不同<br>成员变量：在堆内存<br>局部变量：在栈内存<br>C:生命周期不同<br>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失<br>D:初始化值不同<br>成员变量：有默认初始化值<br>局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。<br>注意事项：<br>局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。</li><li>构造方法和成员方法的区别？<br>答：构造方法是初始化一个类的对象时候调用的，它没有返回值，而且名字必须与类的名字一样，而成员函数是由类对象主动调用的，使用点操作符，它有返回值<br>构造函数是赋予对象”生命特征”的,成员方法则是对象所具有的”行为,能力”<br>构造函数只有在建立对象时由系统调用的,其他任何时候你都别指望用他.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaの反射</title>
      <link href="/2020/04/11/Java%E3%81%AE%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/04/11/Java%E3%81%AE%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Javaの反射"><a href="#Javaの反射" class="headerlink" title="Javaの反射"></a>Javaの反射</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="第一章-反射的理解"><a href="#第一章-反射的理解" class="headerlink" title="第一章 反射的理解"></a>第一章 反射的理解</h3><h4 id="1-1-正射"><a href="#1-1-正射" class="headerlink" title="1.1 正射"></a>1.1 正射</h4><p>我们在编写代码时，当需要使用到某一个类的时候，必定先会去了解这是一个什么类，是用来做什么的，有怎么样的功能。之后我们才对这个类进行实例化，之后再使用这个类的实例化对象进行操作。</p><span id="more"></span><p>Person person &#x3D; new Person();<br>person.sleep(“8:00”);</p><h4 id="1-2-反射"><a href="#1-2-反射" class="headerlink" title="1.2 反射"></a>1.2 反射</h4><p>反射则是在代码一开始编写时不知道要初始化的类是什么。因此，自然也无法使用new关键字来创建对象了。而当我们之后得到我们要初始化的类的名称及路径时，我们就可以使用JDK提供的反射API进行反射调用。<br>Class clazz &#x3D; Class.forName(“com.Person”);<br>Method method &#x3D; clazz.getMethod(“sleep”, String.class);<br>Constructor constructor &#x3D; clazz.getConstructor();<br>Object object &#x3D; constructor.newInstance();<br>method.invoke(object, “8:00”);<br>以上两段代码，其结果都是一样的，但是其实现的过程却有很大的差别：</p><ul><li>第一段代码在未运行前就已经确定了要运行的类（Person）；</li><li>第二段代码则是在整个程序运行时从某些地方（例：配置文件）获取到相应的字符串值才能知道要运行的类（”com.Person”）。<br>第二章 反射常用类和常用函数<br>2.1 获取Class对象<br>在反射中，要获取一个类或调用一个类的方法，首先必须要获取到该类的对象，在Java API中，获取Class类对象三种方法：<br>①：Class.forName(“类的路径名”)；<br>Class clazz &#x3D; Class.forName(“com.test.domain.Person”);<br>②：利用已有类对象的getClass()方法；<br>Person person &#x3D; new Person();<br>Class clazz &#x3D; person.getClass();<br>③：对于在编译前就已经知道的类，可以使用.class属性；<br>Class clazz &#x3D; Person.class;<br>同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class对象都是同一个。<br>2.2  Constructor类<br>Constructor是构造方法类，类中的每一个构造方法都是Constructor的对象，通过Constructor对象可以实例化对 象。</li><li>Constructor getConstructor(Class… parameterTypes) 根据参数类型获取构造方法对象，只能获得public修饰的构造方法。</li><li>Constructor getDeclaredConstructor(Class… parameterTypes) 根据参数类型获取构造方法对象，包括private修饰的构造方法。</li><li>Constructor[] getConstructors() 获取所有的public修饰的构造方法</li><li>Constructor[] getDeclaredConstructors() 获取所有构造方法，包括privat修饰的<br>2.3 通过反射创建类对象<br>①：通过class对象的newInstance()方法<br>Class clazz &#x3D; Class.forName(“com.Person”);<br>Person person &#x3D; (Person)clazz.newInstance();<br>②：通过Constructor对象的newInstance()方法；<br>Class clazz &#x3D; Class.forName(“com.Person”);<br>Constructor con &#x3D; clazz.getConstructor();<br>Person person &#x3D; (Person)con.newInstance();<br>2.4  Method类<br>Method是方法类，类中的每一个方法都是Method的对象，通过Method对象可以调用方法。<br>Class类中与Method相关方法：</li><li>Method getMethod(“方法名”, 方法的参数类型… 类型) 根据方法名和参数类型获得一个方法对象，只能是获取public修饰的</li><li>Method getDeclaredMethod(“方法名”, 方法的参数类型… 类型) 根据方法名和参数类型获得一个方法对象，包括private修饰的</li><li>Method[] getMethods() 获取所有的public修饰的成员方法，包括父类中。</li><li>Method[] getDeclaredMethods() 获取当前类中所有的方法，包含私有的，不包括父类中。<br>Method类中常用方法：</li><li>Object invoke(Object obj, Object… args) 根据参数args调用对象obj的该成员方法 如果obj&#x3D;null，则表示该方法是静态方法</li><li>void setAccessible(boolean flag) 暴力反射，设置为可以直接调用私有修饰的成员方法<br>2.5 通过反射操作成员变量<br>①：获取所有成员getFields()&amp;getDeclaredFields();<br>使用getFields()方法可以获取Class类的成员变量，但是无法获取私有属性。<br>使用getDeclaredFields()方法可以获取Class类的所有成员变量。<br>Class clazz &#x3D; Class.forName(“com.Person”);<br>Field[] fields &#x3D; clazz.getFields();<br>for (Field field : fields) {<br>System.out.print(field.getName());<br>}<br>②：获取单个成员getField(String name)&amp;getDeclared(String name)<br>③：修改成员变量的值set(Object obj, Object value)<br>Class clazz &#x3D; Class.forName(“com.test.domain.Person”);<br>Person person &#x3D; (Person)clazz.newInstance();<br>Field field &#x3D; clazz.getField(“name”);<br>field.set(person, “张三”);<br>④：当属性为private时，这是我们无法直接使用set()方法修改它的值，此时应该使用setAccessible()方法取得访问权限：<br>Class clazz &#x3D; Class.forName(“com.Person”);<br>Person person &#x3D; (Person)clazz.newInstance();<br>Field field &#x3D; clazz.getDeclaredField(“name”);<br>field.setAccessible(true);<br>field.set(person, “张三”);<br>第三章 反射案例<br>需求：写一段程序，在不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。<br>步骤：</li><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法<br>1.pro.properties<br>className&#x3D;com.Student<br>methodName&#x3D;sleep<br>2.Student.java<br>public class Student {<br>  public void sleep(){<br>   System.out.println(“sleep…”);<br> }<br>}<br>3.Test.java<br>public class Test {<br>  public static void main(String[] args) {<br>   &#x2F;&#x2F;1.加载配置文件<br>  &#x2F;&#x2F;1.1创建Properties对象<br>  Properties pro &#x3D; new Properties();<br>  &#x2F;&#x2F;1.2加载配置文件，转换为一个集合<br>  &#x2F;&#x2F;1.2.1获取class目录下的配置文件<br>  ClassLoader classLoader &#x3D; Test.class.getClassLoader();<br>  InputStream is &#x3D; classLoader.getResourceAsStream(“pro.properties”);<br>  pro.load(is);<br>  &#x2F;&#x2F;2.获取配置文件中定义的数据<br>  String className &#x3D; pro.getProperty(“className”);<br>  String methodName &#x3D; pro.getProperty(“methodName”);<br>  &#x2F;&#x2F;3.加载该类进内存<br>  Class cls &#x3D; Class.forName(className);<br>  &#x2F;&#x2F;4.创建对象<br>  Object obj &#x3D; cls.newInstance();<br> &#x2F;&#x2F;5.获取方法对象<br> Method method &#x3D; cls.getMethod(methodName);<br> &#x2F;&#x2F;6.执行方法<br>   method.invoke(obj);<br>  }<br>  }<br>}</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="第一章-注解概述"><a href="#第一章-注解概述" class="headerlink" title="第一章  注解概述"></a>第一章  注解概述</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p><h4 id="1-2-作用分类"><a href="#1-2-作用分类" class="headerlink" title="1.2 作用分类"></a>1.2 作用分类</h4><ul><li>编写文档：通过代码里标识的注解生成文档【例如，生成文档doc文档】</li><li>代码分析：通过代码里标识的注解对代码进行分析【例如，注解的反射】</li><li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【例如，Override】</li></ul><h4 id="1-3-常见注解"><a href="#1-3-常见注解" class="headerlink" title="1.3 常见注解"></a>1.3 常见注解</h4><ul><li><p>@author：用来标识作者名。</p></li><li><p>@version：用于标识对象的版本号，适用范围：文件、类、方法。</p></li><li><p>@Override ：用来修饰方法声明，告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。</p></li></ul><h3 id="第二章-自定义注解"><a href="#第二章-自定义注解" class="headerlink" title="第二章 自定义注解"></a>第二章 自定义注解</h3><p>  定义格式：<br>  元注解<br>  public @interface 注解名称{<br>    属性列表;<br>  }<br>  注解本质上就是一个接口，该接口默认继承Annotation接口。</p><h4 id="2-1-注解的属性"><a href="#2-1-注解的属性" class="headerlink" title="2.1 注解的属性"></a>2.1 注解的属性</h4><ul><li><ol><li>属性的作用<br>可以让用户在使用注解时传递参数，让注解的功能更加强大。</li></ol></li><li><ol start="2"><li>属性的格式<br>格式1：数据类型 属性名();<br>格式2：数据类型 属性名() default 默认值;</li></ol></li><li><ol start="3"><li>属性定义示例<br>public @interface Student {<br>String name(); &#x2F;&#x2F; 姓名<br>int age() default 18; &#x2F;&#x2F; 年龄<br>String gender() default “男”; &#x2F;&#x2F; 性别<br>}<br>&#x2F;&#x2F; 该注解就有了三个属性：name，age，gender</li></ol></li></ul><ol start="4"><li>属性适用的数据类型</li></ol><ul><li><p>八种基本数据类型（int,float,boolean,byte,double,char,long,short)</p></li><li><p>String类型，Class类型，枚举类型，注解类型</p></li><li><p>以上所有类型的一维数组</p></li></ul><h4 id="2-2-使用自定义注解"><a href="#2-2-使用自定义注解" class="headerlink" title="2.2 使用自定义注解"></a>2.2 使用自定义注解</h4><p>  定义注解：Book</p><ul><li><p>包含属性：String value() 书名</p></li><li><p>包含属性：double price() 价格，默认值为 100</p></li><li><p>包含属性：String[] authors() 多位作者<br>代码实现：<br>public @interface Book {<br>&#x2F;&#x2F; 书名<br>String value();<br>&#x2F;&#x2F; 价格<br>double price() default 100;<br>&#x2F;&#x2F; 多位作者<br>String[] authors();<br>}<br>使用注解：<br>public class BookShelf {<br>@Book(value &#x3D; “西游记”,price &#x3D; 998,authors &#x3D; {“吴承恩”,”白求恩”})<br>public void showBook(){<br>}<br>}<br>如果属性有默认值，则使用注解的时候，这个属性可以不用赋值。<br>如果属性没有默认值，那么在使用注解时一定要给属性赋值。</p></li></ul><h3 id="第三章-注解之元注解"><a href="#第三章-注解之元注解" class="headerlink" title="第三章 注解之元注解"></a>第三章 注解之元注解</h3><p>  默认情况下，注解可以用在任何地方，比如类，成员方法，构造方法，成员变量等地方。如果要限制注解的使用位置怎么办？那就要学习一个新的知识点：元注解。</p><ul><li><p>@Target</p></li><li><p>@Retention</p></li></ul><h4 id="3-1-元注解之-Target"><a href="#3-1-元注解之-Target" class="headerlink" title="3.1 元注解之@Target"></a>3.1 元注解之@Target</h4><p>  作用：指明此注解用在哪个位置，如果不写默认是任何地方都可以使用。<br>  可选的参数值在枚举类ElemenetType中包括：</p><ul><li><p>TYPE： 用在类,接口上</p></li><li><p>FIELD：用在成员变量上</p></li><li><p>METHOD： 用在方法上</p></li><li><p>PARAMETER：用在参数上</p></li><li><p>CONSTRUCTOR：用在构造方法上</p></li><li><p>LOCAL_VARIABLE：用在局部变量上</p></li></ul><h4 id="3-2-元注解之-Retention"><a href="#3-2-元注解之-Retention" class="headerlink" title="3.2 元注解之@Retention"></a>3.2 元注解之@Retention</h4><p>  作用：定义该注解的生命周期(有效范围)。<br>  可选的参数值在枚举类型RetentionPolicy中包括:</p><ul><li><p>SOURCE：注解只存在于Java源代码中，编译生成的字节码文件中就不存在了。</p></li><li><p>CLASS：注解存在于Java源代码、编译以后的字节码文件中，运行的时候内存中没有，默认值。</p></li><li><p>RUNTIME：注解存在于Java源代码中、编译以后的字节码文件中、运行时内存中，程序可以通过反射获取该注解。</p></li></ul><h4 id="3-3-元注解使用示例"><a href="#3-3-元注解使用示例" class="headerlink" title="3.3 元注解使用示例"></a>3.3 元注解使用示例</h4><p>@Target({ElementType.METHOD,ElementType.TYPE})<br>@interface Stu{<br>String name();<br>}<br>&#x2F;&#x2F; 类<br>@Stu(name&#x3D;”jack”)<br>public class AnnotationDemo02 {<br>&#x2F;&#x2F; 成员变量<br>@Stu(name &#x3D; “lily”) &#x2F;&#x2F; 编译失败<br>private String gender;<br>&#x2F;&#x2F; 成员方法<br>@Stu(name&#x3D;”rose”)<br>public void test(){<br>}<br>&#x2F;&#x2F; 构造方法<br>@Stu(name&#x3D;”lucy”) &#x2F;&#x2F; 编译失败<br>public AnnotationDemo02(){}<br>}</p><h3 id="第四章-注解解析"><a href="#第四章-注解解析" class="headerlink" title="第四章 注解解析"></a>第四章 注解解析</h3><p>通过java技术获取注解数据的过程叫做注解解析。</p><h4 id="4-1-与注解解析相关的接口"><a href="#4-1-与注解解析相关的接口" class="headerlink" title="4.1 与注解解析相关的接口"></a>4.1 与注解解析相关的接口</h4><ul><li>Anontation：所有注解类型的公共接口，类似所有类的父类是Object。</li><li>AnnotatedElement：定义了与注解解析相关的方法，常用方法以下四个<ul><li>boolean isAnnotationPresent(Class annotationClass); 判断当前对象是否有指定的注解，有则返回true，否则 返回false。</li><li>T getAnnotation(Class<T> annotationClass); 获得当前对象上指定的注解对象。</li><li>Annotation[] getAnnotations(); 获得当前对象及其从父类上继承的所有的注解对象。</li><li>Annotation[] getDeclaredAnnotations();获得当前对象上所有的注解对象，不包括父类的。</li></ul></li></ul><h4 id="4-2-获取注解数据的原理"><a href="#4-2-获取注解数据的原理" class="headerlink" title="4.2 获取注解数据的原理"></a>4.2 获取注解数据的原理</h4><p>注解作用在哪个成员上，就可以通过反射获取该成员的对象，通过该成员对象获取该成员的注解。<br>如注解作用在方法上，就通过方法(Method)对象得到它的注解：<br>&#x2F;&#x2F; 得到方法对象<br> Method method &#x3D; clazz.getDeclaredMethod(“方法名”);<br>&#x2F;&#x2F; 根据注解名得到方法上的注解对象<br>Book book &#x3D; method.getAnnotation(Book.class);<br>如注解作用在类上，就通过Class对象得到它的注解：<br>&#x2F;&#x2F; 获得Class对象<br>Class c &#x3D; 类名.class;<br>&#x2F;&#x2F; 根据注解的Class获得使用在类上的注解对象<br>Book book &#x3D; c.getAnnotation(Book.class);</p><h3 id="第五章-使用反射获取注解的数据"><a href="#第五章-使用反射获取注解的数据" class="headerlink" title="第五章 使用反射获取注解的数据"></a>第五章 使用反射获取注解的数据</h3><p>需求说明</p><ol><li>定义注解Book，要求如下：</li></ol><ul><li>包含属性：String value() 书名</li><li>包含属性：double price() 价格，默认值为 100</li><li>包含属性：String[] authors() 多位作者</li><li>限制注解使用的位置：类和成员方法上</li><li>指定注解的有效范围：RUNTIME</li></ul><ol start="2"><li><p>定义BookStore类，在类和成员方法上使用Book注解</p></li><li><p>定义TestAnnotation测试类获取Book注解上的数据<br>代码实现<br>注解Book<br>@Target({ElementType.METHOD,ElementType.TYPE})<br>@Retention(RetentionPolicy.RUNTIME)<br>public @interface Book {<br> &#x2F;&#x2F; 书名<br> String value();<br> &#x2F;&#x2F; 价格<br> double price() default 100;<br> &#x2F;&#x2F; 作者<br> String[] authors();<br> }<br>BookStore类<br>@Book(value &#x3D; “红楼梦”,authors &#x3D; “曹雪芹”,price &#x3D; 998)<br> public class BookStore {</p><p> @Book(value &#x3D; “西游记”,authors &#x3D; “吴承恩”)<br> public void buyBook(){<br> }<br> }<br>TestAnnotation类<br>public class TestAnnotation {<br>public static void main(String[] args) throws Exception{<br>System.out.println(“———获取类上注解的数据———-“);<br>test01();<br>System.out.println(“———获取成员方法上注解的数据———-“);<br>test02();<br>}<br>&#x2F;**</p></li></ol><ul><li><p>获取BookStore类上使用的Book注解数据<br><em>&#x2F;<br>public static void test01(){<br>&#x2F;&#x2F; 获得BookStore类对应的Class对象<br>Class c &#x3D; BookStore.class;<br>&#x2F;&#x2F; 判断BookStore类是否使用了Book注解<br>if(c.isAnnotationPresent(Book.class)) {<br>&#x2F;&#x2F; 根据注解Class对象获取注解对象<br>Book book &#x3D; (Book) c.getAnnotation(Book.class);<br>&#x2F;&#x2F; 输出book注解属性值<br>System.out.println(“书名：” + book.value());<br>System.out.println(“价格：” + book.price());<br>System.out.println(“作者：” + Arrays.toString(book.authors()));<br>}<br>}<br>&#x2F;</em>*</p></li><li><p>获取BookStore类成员方法buyBook使用的Book注解数据<br>*&#x2F;<br>public static void test02() throws Exception{<br>&#x2F;&#x2F; 获得BookStore类对应的Class对象<br>Class c &#x3D; BookStore.class;<br>&#x2F;&#x2F; 获得成员方法buyBook对应的Method对象<br>Method m &#x3D; c.getMethod(“buyBook”);<br>&#x2F;&#x2F; 判断成员方法buyBook上是否使用了Book注解<br>if(m.isAnnotationPresent(Book.class)) {<br>&#x2F;&#x2F; 根据注解Class对象获取注解对象<br>Book book &#x3D; (Book) m.getAnnotation(Book.class);<br>&#x2F;&#x2F; 输出book注解属性值<br>System.out.println(“书名：” + book.value());<br>System.out.println(“价格：” + book.price());<br>System.out.println(“作者：” + Arrays.toString(book.authors()));<br>}<br>}<br>}<br>作业<br>1.定义Person类，私有成员变量有name,age,公开成员变量有sex，成员方法包括gette和setter，构造方法有无参和全参，用反射去创建一个Person对象，用2种方式。<br>2.在第一题中加入方法show，打印一串字符串，利用反射执行该方法。<br>4.在第一题基础之上，利用反射设置name为“张三”,sex为“男”。<br>Person.java<br>public class Person {<br>  private String name;<br>  private int age;<br>  private String sex;</p><p>  @Override<br>  public String toString() {<br>  return “Person{“ +<br>          “name&#x3D;’” + name + ‘&#39;‘ +<br>          “, age&#x3D;” + age +<br>          “, sex&#x3D;’” + sex + ‘&#39;‘ +<br>          ‘}’;<br>  }</p><p>  public void gogogo(){<br>  System.out.println(“通过读取配置文件得到的gogogo方法在运行！”);<br>  }</p><p>  public String getName() {<br>  return name;<br>  }</p><p>  public void setName(String name) {<br>  this.name &#x3D; name;<br>  }</p><p>  public int getAge() {<br>  return age;<br>  }</p><p>  public void setAge(int age) {<br>  this.age &#x3D; age;<br>  }</p><p>  public String getSex() {<br>  return sex;<br>  }</p><p>  public void setSex(String sex) {<br>  this.sex &#x3D; sex;<br>  }</p><p>  public Person() {<br>  }</p><p>  public Person(String name, int age, String sex) {<br>  this.name &#x3D; name;<br>  this.age &#x3D; age;<br>  this.sex &#x3D; sex;<br>  }<br>  public void show(){<br>  System.out.println(“这是一个无参的show方法”);<br>  }<br>}<br>public class Demo1 {<br>  public static void main(String[] args) throws Exception{<br>  &#x2F;&#x2F;1.定义Person类，私有成员变量有name,age,公开成员变量有sex，成员方法包括gette和setter，<br>  &#x2F;&#x2F; 构造方法有无参和全参，用反射去创建一个Person对象，用2种方式。<br>  &#x2F;&#x2F;第一种<br>  Class clazz &#x3D; Class.forName(“com.hmwk124.Person”);<br>  Person p &#x3D; (Person)clazz.newInstance();<br>  &#x2F;&#x2F;第二种<br>  Class clazz1 &#x3D; Class.forName(“com.hmwk124.Person”);<br>  Constructor constructor &#x3D; clazz.getConstructor();<br>  Person p1 &#x3D; (Person)constructor.newInstance();<br>  &#x2F;&#x2F;2.在第一题中加入方法show，打印一串字符串，利用反射执行该方法。<br>  Method show &#x3D; clazz1.getMethod(“show”);<br>  show.invoke(p1);<br>  &#x2F;&#x2F;4.在第一题基础之上，利用反射设置name为“张三”,sex为“男”。<br>  Field name &#x3D; clazz1.getDeclaredField(“name”);<br>  Field sex &#x3D; clazz1.getDeclaredField(“sex”);<br>  name.setAccessible(true);<br>  name.set(p1,”张三”);<br>  sex.setAccessible(true);<br>  sex.set(p1,”男”);<br>  Method toString &#x3D; clazz1.getMethod(“toString”);<br>  System.out.println(toString.invoke(p1));<br>  }<br>}<br>3.编写一个类A，增加一个实例方法showString,用于打印一条字符串，再编写一个测试类TestA ，在测试类中，用键盘输入一个字符串，该字符串就是类A的全名，使用反射机制创建该类的对象，并调用该对象中的方法showString。<br>&#x2F;&#x2F;3.编写一个类A，增加一个实例方法showString,用<br>&#x2F;&#x2F; 于打印一条字符串，再编写一个测试类TestA ，在测试类中，<br>&#x2F;&#x2F; 用键盘输入一个字符串，该字符串就是类A的全名，使用反射机制创<br>&#x2F;&#x2F; 建该类的对象，并调用该对象中的方法showString。<br>public class A {<br>  public void showString(){<br>  System.out.println(“这是A类的showString方法！”);<br>  }<br>}<br>public class TestA {<br>  &#x2F;&#x2F;3.编写一个类A，增加一个实例方法showString,用<br>  &#x2F;&#x2F; 于打印一条字符串，再编写一个测试类TestA ，在测试类中，<br>  &#x2F;&#x2F; 用键盘输入一个字符串，该字符串就是类A的全名，使用反射机制创<br>  &#x2F;&#x2F; 建该类的对象，并调用该对象中的方法showString。<br>  public static void main(String[] args) {<br>  String s;<br>  Scanner sc &#x3D; new Scanner(System.in);<br>  System.out.print(“请输入完整的类名：”);<br>  s &#x3D; sc.nextLine();<br>  Class clazz &#x3D; null;<br>  try {<br>      clazz &#x3D; Class.forName(s);<br>      Constructor constructor &#x3D; clazz.getConstructor();<br>      A a &#x3D; (A) constructor.newInstance();<br>      a.showString();<br>  } catch (ClassNotFoundException e) {<br>      System.out.println(“找不到该类！”);<br>  } catch (NoSuchMethodException e) {<br>      e.printStackTrace();<br>  } catch (InstantiationException e) {<br>      e.printStackTrace();<br>  } catch (IllegalAccessException e) {<br>      e.printStackTrace();<br>  } catch (InvocationTargetException e) {<br>      e.printStackTrace();<br>  }<br>  }<br>}<br>5.在第一题基础上，写一个Properties格式的配置文件，配置类的完整名称和所要执行的方法，写一个程序，读取这个Properties配置文件，获得类的完整名称并加载这个类，并执行读取的方法。<br>public class Demo5 {<br>  &#x2F;&#x2F;在第一题基础上，写一个Properties格式的配置文件，配置类的完整名<br>  &#x2F;&#x2F; 称和所要执行的方法，写一个程序，读取这个Properties配置文件，获<br>  &#x2F;&#x2F; 得类的完整名称并加载这个类，并执行读取的方法。<br>  public static void main(String[] args) throws Exception {<br>  Properties pro &#x3D; new Properties();<br>  ClassLoader cll &#x3D; Demo5.class.getClassLoader();<br>  InputStream is &#x3D; cll.getResourceAsStream(“com&#x2F;hmwk124&#x2F;pro.properties”);<br>  pro.load(is);<br>  String className &#x3D; pro.getProperty(“className”);<br>  String methodName &#x3D; pro.getProperty(“methodName”);<br>  Class clazz &#x3D; Class.forName(className);<br>  Object o &#x3D; clazz.newInstance();<br>  Method method &#x3D; clazz.getMethod(methodName);<br>  method.invoke(o);<br>  }<br>}<br>配置文件：<br>className&#x3D;com.hmwk124.Person<br>methodName&#x3D;gogogo<br>1.自定义注解Hello，包含属性value，name，age（默认值100），设置只能作用于方法和成员变量，生命周期为RUNTIME,创建普通类Person，类中定义成员变量name，方法show（），分别在之上加入注解，利用反射解析注解。<br>Hello.java<br>@Target({ElementType.METHOD,ElementType.FIELD})<br>@Retention(RetentionPolicy.RUNTIME)<br>public @interface Hello {<br>  String value();<br>  String name();<br>  int age() default 100;<br>}<br>Person.java<br>public class Person {<br>  @Hello(value &#x3D; “10”,name&#x3D;”李四”,age &#x3D; 20)<br>  private String name;<br>  @Hello(value &#x3D; “100”,name &#x3D; “张三”,age &#x3D; 18)<br>  public void show(){<br>  }<br>}<br>Demo6.java<br>public class Demo6 {<br>  public static void main(String[] args) throws Exception {<br>  System.out.println(“获取成员变量上注解的数据”);<br>  test01();<br>  System.out.println(“获取方法上注解的数据”);<br>  test02();<br>  }<br>  &#x2F;&#x2F;获取Person类的成员变量上使用的Hello注解数据<br>  public static void test01() throws NoSuchFieldException {<br>  Class clazz &#x3D; Person.class;<br>  Field field &#x3D; (Field) clazz.getDeclaredField(“name”);<br>  System.out.println(field.isAnnotationPresent(Hello.class));<br>  if(field.isAnnotationPresent(Hello.class)){<br>      Hello hello &#x3D; (Hello)field.getAnnotation(Hello.class);<br>      &#x2F;&#x2F;输出Hello注解属性值<br>      System.out.println(“value:” + hello.value());<br>      System.out.println(“name:” + hello.name());<br>      System.out.println(“age:” + hello.age());<br>  }<br>  }<br>  &#x2F;&#x2F;获取方法show上对象的Method对象<br>  public static void test02() throws Exception{<br>  Class clazz1 &#x3D; Person.class;<br>  Method show &#x3D; clazz1.getMethod(“show”);<br>  &#x2F;&#x2F;判断是否使用注解<br>  if(show.isAnnotationPresent(Hello.class)){<br>      Hello hello &#x3D; (Hello)show.getAnnotation(Hello.class);<br>      &#x2F;&#x2F;输出注解属性值<br>      System.out.println(“value:” + hello.value());<br>      System.out.println(“name:” + hello.name());<br>      System.out.println(“age:” + hello.age());<br>  }<br>  }<br>}</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaの网络编程</title>
      <link href="/2020/04/11/Java%E3%81%AE%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/04/11/Java%E3%81%AE%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Javaの网络编程"><a href="#Javaの网络编程" class="headerlink" title="Javaの网络编程"></a>Javaの网络编程</h1><h3 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h3><p>1.1      网络协议<br>       通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p><span id="more"></span><p>​      网络通信协议有很多种，目前应用最广泛的是TCP&#x2F;IP协议(Transmission Control Protocal&#x2F;Internet Protoal传输控制协议&#x2F;英特网互联协议)，它是一个包括TCP协议和IP协议，UDP（User Datagram Protocol）协议和其它一些协议的协议组，在学习具体协议之前首先了解一下TCP&#x2F;IP协议组的层次结构。<br>​       在进行数据传输时，要求发送的数据与收到的数据完全一样，这时，就需要在原有的数据上添加很多信息，以保证数据在传输过程中数据格式完全一致。TCP&#x2F;IP协议的层次结构比较简单，共分为四层，如图所示。<br><img src="http://cdn.leafii.top/img/20220520165106.png" loading="lazy"><br> 上图中，TCP&#x2F;IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP&#x2F;IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。<br>1.2      IP地址和端口号<br>​       要想使网络中的计算机能够进行通信，必须为每台计算机指定一个标识号，通过这个标识号来指定接受数据的计算机或者发送数据的计算机。<br>​       在TCP&#x2F;IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机，目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”。<br>​       随着计算机网络规模的不断扩大，对IP地址的需求也越来越多，IPV4这种用4个字节表示的IP地址面临枯竭，因此IPv6 便应运而生了，IPv6使用16个字节表示IP地址，它所拥有的地址容量约是IPv4的8×1028倍，达到2128个（算上全零的），这样就解决了网络地址资源数量不够的问题。<br>​      通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0<del>65535，其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。<br>​      接下来通过一个图例来描述IP地址和端口号的作用，如下图所示:<br><img src="http://cdn.leafii.top/img/20220520165121.png" loading="lazy"><br>从上图中可以清楚地看到，位于网络中一台计算机可以通过IP地址去访问另一台计算机，并通过端口号访问目标计算机中的某个应用程序。<br>1.3      InetAddress<br>​      了解了IP地址的作用，我们看学习下JDK中提供了一个InetAdderss类，该类用于封装一个IP地址，并提供了一系列与IP地址相关的方法，下表中列出了InetAddress类的一些常用方法。<br><img src="http://cdn.leafii.top/img/20220520165131.png" loading="lazy"></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">InetAddress</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">UnknownHostException</span></span><span class="token punctuation">;</span> <span class="token comment">/* * InetAddress:此类表示互联网协议 (IP) 地址。 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InetAddressDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">UnknownHostException</span>   <span class="token punctuation">&#123;</span>        <span class="token comment">//static InetAddress getByName(String host)</span>         <span class="token comment">//InetAddress address = InetAddress.getByName("itheima");</span>        <span class="token class-name">InetAddress</span> address <span class="token operator">=</span> <span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span><span class="token string">"192.168.1.107"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ip地址是唯一的</span>             <span class="token comment">//System.out.println(address);//itheima/192.168.1.107 ipconfig</span>                 <span class="token class-name">String</span> hostAddress <span class="token operator">=</span> address<span class="token punctuation">.</span><span class="token function">getHostAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//192.168.1.107 返回IP地址</span>        <span class="token class-name">String</span> hostName <span class="token operator">=</span> address<span class="token punctuation">.</span><span class="token function">getHostName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//itheima   返回主机名</span>                 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hostAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hostName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>第2章 UDP协议<br>      UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。<br>2.1      DatagramPacket<br>       前面介绍了UDP是一种面向无连接的协议，因此，在通信时发送端和接收端不用建立连接。UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“集装箱”进行打包，为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。<br>       想要创建一个DatagramPacket对象，首先需要了解一下它的构造方法。在创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端IP地址和端口号。<br>        接下来根据API文档的内容，对DatagramPacket的构造方法进行逐一详细地讲解。<br><img src="http://cdn.leafii.top/img/20220520165149.png" loading="lazy"><br>   使用该构造方法在创建DatagramPacket对象时，指定了封装数据的字节数组和数据的大小，没有指定IP地址和端口号。很明显，这样的对象只能用于接收端，不能用于发送端。因为发送端一定要明确指出数据的目的地(ip地址和端口号)，而接收端不需要明确知道数据的来源，只需要接收到数据即可。<br><img src="http://cdn.leafii.top/img/20220520165159.png" loading="lazy"><br>     使用该构造方法在创建DatagramPacket对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标IP地址（address）和端口号（port)。该对象通常用于发送端，因为在发送数据时必须指定接收端的IP地址和端口号，就好像发送货物的集装箱上面必须标明接收人的地址一样。<br>       上面我们讲解了DatagramPacket的构造方法，接下来对DatagramPacket类中的常用方法进行详细地讲解，如下表所示。<br><img src="http://cdn.leafii.top/img/20220520165210.png" loading="lazy"></p><p>2.2      DatagramSocket<br>       DatagramPacket数据包的作用就如同是“集装箱”，可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包。<br><img src="http://cdn.leafii.top/img/Screen%20Shot%202022-05-20%20at%2016.59.45.png" alt="Screen Shot 2022-05-20 at 16.59.45" loading="lazy">该构造方法用于创建发送端的DatagramSocket对象，在创建DatagramSocket对象时，并没有指定端口号，此时，系统会分配一个没有被其它网络程序所使用的端口号。<br><img src="http://cdn.leafii.top/img/20220520170006.png" loading="lazy"><br>该构造方法既可用于创建接收端的DatagramSocket对象，又可以创建发送端的DatagramSocket对象，在创建接收端的DatagramSocket对象时，必须要指定一个端口号，这样就可以监听指定的端口。<br>      上面我们讲解了DatagramSocket的构造方法，接下来对DatagramSocket类中的常用方法进行介绍。<br><img src="http://cdn.leafii.top/img/20220520170021.png" loading="lazy"><br>2.3      UDP实现<br>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;<br>import java.net.SocketException;</p><p>&#x2F;*</p><ul><li><p>使用UDP协议发送数据<br>   创建发送端Socket对象<br>   创建数据并打包<br>   发送数据<br>   释放资源</p><ul><li></li></ul></li><li><p>DatagramSocket:此类表示用来发送和接收数据,基于UDP协议的</p><ul><li></li></ul></li><li><p>DatagramSocket() ：创建Socket对象并随机分配端口号</p></li><li><p>DatagramSocket(int port) ：创建Socket对象并指定端口号<br><em>&#x2F;<br>public class SendDemo {<br>public static void main(String[] args) throws IOException  {<br>&#x2F;&#x2F;创建发送端Socket对象<br>DatagramSocket ds &#x3D; new DatagramSocket();<br>&#x2F;&#x2F;创建数据并打包<br>&#x2F;</em><br> * DatagramPacket :此类表示数据报包<br> * 数据 byte[]<br> * 设备的地址 ip<br> * 进程的地址  端口号<br>   DatagramPacket(byte[] buf, int length, InetAddress address, int port)<br> *&#x2F;<br><br><br>String s &#x3D; “hello udp,im comming!”;<br>byte[] bys &#x3D; s.getBytes();<br>int length &#x3D; bys.length;<br>InetAddress address &#x3D; InetAddress.getByName(“127.0.0.1”);&#x2F;&#x2F;发送给当前设备<br>int port &#x3D; 8888;<br>&#x2F;&#x2F;打包<br>DatagramPacket dp &#x3D; new DatagramPacket(bys,length,address,port);<br>&#x2F;&#x2F;发送数据<br>ds.send(dp);<br>&#x2F;&#x2F;释放资源<br>ds.close();<br>}<br>}</p></li></ul><p>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;</p><p>&#x2F;*</p><ul><li>使用UDP协议接收数据<br>   创建接收端Socket对象<br>   接收数据<br>   解析数据<br>   输出数据<br>   释放资源</li></ul><p> *&#x2F;<br>public class ReceiveDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建接收端Socket对象<br>        DatagramSocket ds &#x3D; new DatagramSocket(8888);<br>        &#x2F;&#x2F;接收数据<br>        &#x2F;&#x2F;DatagramPacket(byte[] buf, int length)<br>        byte[] bys &#x3D; new byte[1024];<br>        DatagramPacket dp &#x3D; new DatagramPacket(bys,bys.length);</p><pre><code>    System.out.println(1);    ds.receive(dp);//阻塞    System.out.println(2);         //解析数据    //InetAddress getAddress() : 获取发送端的IP对象    InetAddress address = dp.getAddress();    //byte[] getData()  ：获取接收到的数据，也可以直接使用创建包对象时的数组    byte[] data = dp.getData();    //int getLength()  ：获取具体收到数据的长度    int length = dp.getLength();</code></pre><p>​<br>​        &#x2F;&#x2F;输出数据<br>​        System.out.println(“sender —&gt; “ + address.getHostAddress());<br>​        &#x2F;&#x2F;System.out.println(new String(data,0,length));<br>​        System.out.println(new String(bys,0,length));<br>​        &#x2F;&#x2F;释放资源<br>​        ds.close();<br>​    }<br>}<br>第3章     TCP协议<br>​       TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。<br>​       在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。<br>3.1      ServerSocket<br>JDK的java.net包中提供了一个ServerSocket类，该类的实例对象可以实现一个服务器段的程序。<br><img src="http://cdn.leafii.top/img/20220520170040.png" loading="lazy"><br>使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上（参数port就是端口号）。<br><img src="http://cdn.leafii.top/img/20220520170052.png" loading="lazy"><br> ServerSocket对象负责监听某台计算机的某个端口号，在创建ServerSocket对象后，需要继续调用该对象的accept()方法，接收来自客户端的请求。当执行了accept()方法之后，服务器端程序会发生阻塞，直到客户端发出连接请求，accept()方法才会返回一个Scoket对象用于和客户端实现通信，程序才能继续向下执行。<br>3.2      Socket<br>ServerSocket对象可以实现服务端程序，但只实现服务器端程序还不能完成通信，此时还需要一个客户端程序与之交互，为此JDK提供了一个Socket类，用于实现TCP客户端程序。<br><img src="http://cdn.leafii.top/img/20220520170107.png" loading="lazy"><br>使用该构造方法在创建Socket对象时，会根据参数去连接在指定地址和端口上运行的服务器程序，其中参数host接收的是一个字符串类型的IP地址。<br><img src="http://cdn.leafii.top/img/20220520170119.png" loading="lazy"><br>该方法在使用上与第二个构造方法类似，参数address用于接收一个InetAddress类型的对象，该对象用于封装一个IP地址。<br>方法声明<br>功能描述<br>int getPort()<br>该方法返回一个int类型对象，该对象是Socket对象与服务器端连接的端口号<br>InetAddress getLocalAddress()<br>该方法用于获取Socket对象绑定的本地IP地址，并将IP地址封装成InetAddress类型的对象返回<br>void close()<br>该方法用于关闭Socket连接，结束本次通信。在关闭socket之前，应将与socket相关的所有的输入&#x2F;输出流全部关闭，这是因为一个良好的程序应该在执行完毕时释放所有的资源<br>InputStream getInputStream()<br>该方法返回一个InputStream类型的输入流对象，如果该对象是由服务器端的Socket返回，就用于读取客户端发送的数据，反之，用于读取服务器端发送的数据<br>OutputStream getOutputStream()<br>该方法返回一个OutputStream类型的输出流对象，如果该对象是由服务器端的Socket返回，就用于向客户端发送数据，反之，用于向服务器端发送数据</p><p>在Socket类的常用方法中，getInputStream()和getOutStream()方法分别用于获取输入流和输出流。当客户端和服务端建立连接后，数据是以IO流的形式进行交互的，从而实现通信。<br>3.3      TCP协议实现<br>import java.io.IOException;<br>import java.io.OutputStream;<br>import java.net.InetAddress;<br>import java.net.Socket;</p><p>&#x2F;*</p><ul><li><p>使用TCP协议发送数据<br>   创建发送端Socket对象（创建连接）<br>   获取输出流对象<br>   发送数据<br>   释放资源</p><p>Socket(InetAddress address, int port)<br>Exception in thread “main” java.net.ConnectException: Connection refused: connect</p></li></ul><p> *&#x2F;<br>public class ClientDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建发送端Socket对象（创建连接）<br>        Socket s &#x3D; new Socket(InetAddress.getByName(“127.0.0.1”),10086);<br>        &#x2F;&#x2F;获取输出流对象<br>        OutputStream os &#x3D; s.getOutputStream();<br>        &#x2F;&#x2F;发送数据<br>        String str &#x3D; “hello tcp,im comming!!!”;<br>        os.write(str.getBytes());<br>        &#x2F;&#x2F;释放资源<br>        &#x2F;&#x2F;os.close();<br>        s.close();<br>    }<br>}</p><p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.net.InetAddress;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p><p>&#x2F;*</p><ul><li><p>使用TCP协议接收数据<br>   创建接收端Socket对象<br>   监听（阻塞）<br>   获取输入流对象<br>   获取数据<br>   输出数据<br>   释放资源</p><p>ServerSocket：接收端，服务端Socket<br>ServerSocket(int port)<br>Socket accept()</p></li></ul><p> *&#x2F;<br>public class ServerDemo {<br>    public static void main(String[] args) throws IOException  {<br>        &#x2F;&#x2F;创建接收端Socket对象<br>        ServerSocket ss &#x3D; new ServerSocket(10086);<br>        &#x2F;&#x2F;监听（阻塞）<br>        Socket s &#x3D; ss.accept();<br>        &#x2F;&#x2F;获取输入流对象<br>        InputStream is &#x3D; s.getInputStream();<br>        &#x2F;&#x2F;获取数据<br>        byte[] bys &#x3D; new byte[1024];<br>        int len;&#x2F;&#x2F;用于存储读到的字节个数<br>        len &#x3D; is.read(bys);<br>        &#x2F;&#x2F;输出数据<br>        InetAddress address &#x3D; s.getInetAddress();<br>        System.out.println(“client —&gt; “ + address.getHostName());<br>        System.out.println(new String(bys,0,len));<br>        &#x2F;&#x2F;释放资源<br>        s.close();<br>        &#x2F;&#x2F;ss.close();<br>    }<br>}<br>3.4  TCP练习：服务端将接收到的数据转换成大写返回给客户端<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.InetAddress;<br>import java.net.Socket;</p><p>&#x2F;*<br>    需求：使用TCP协议发送数据，并将接收到的数据转换成大写返回</p><pre><code>客户端发出数据服务端接收数据服务端转换数据服务端发出数据客户端接收数据</code></pre><p> *&#x2F;<br>public class ClientDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建客户端Socket对象<br>        Socket s &#x3D; new Socket(InetAddress.getByName(“127.0.0.1”),10010);<br>        &#x2F;&#x2F;获取输出流对象<br>        OutputStream os &#x3D; s.getOutputStream();<br>        &#x2F;&#x2F;发出数据<br>        os.write(“tcp,im comming again!!!”.getBytes());</p><pre><code>    //获取输入流对象    InputStream is = s.getInputStream();    byte[] bys = new byte[1024];    int len;//用于存储读取到的字节个数    //接收数据    len = is.read(bys);    //输出数据    System.out.println(new String(bys,0,len));         //释放资源    s.close();     &#125;</code></pre><p>}</p><p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p><p>public class ServerDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建服务端Socket对象<br>        ServerSocket ss &#x3D; new ServerSocket(10010);<br>        &#x2F;&#x2F;监听<br>        Socket s &#x3D; ss.accept();<br>        &#x2F;&#x2F;获取输入流对象<br>        InputStream is &#x3D; s.getInputStream();<br>        &#x2F;&#x2F;获取数据<br>        byte[] bys &#x3D; new byte[1024];<br>        int len;&#x2F;&#x2F;用于存储读取到的字节个数<br>        len &#x3D; is.read(bys);<br>        String str &#x3D; new String(bys,0,len);<br>        &#x2F;&#x2F;输出数据<br>        System.out.println(str);<br>        &#x2F;&#x2F;转换数据<br>        String upperStr &#x3D; str.toUpperCase();<br>        &#x2F;&#x2F;获取输出流对象<br>        OutputStream os &#x3D; s.getOutputStream();<br>        &#x2F;&#x2F;返回数据（发出数据）<br>        os.write(upperStr.getBytes());</p><pre><code>    //释放资源    s.close();    //ss.close();//服务端一般不关闭&#125;</code></pre><p>}<br>3.5  TCP练习：聊天程序设计<br>&#x2F;&#x2F;创建服务端，并在其中启动读写线程并一直接收客户端连接信息<br>public class ServerDemo {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F;服务端<br>        try {<br>            ServerSocket serverSocket&#x3D;new ServerSocket(8888);<br>            System.out.println(“等待客户端连接。。。”);<br>            while (true){<br>                Socket accept &#x3D; serverSocket.accept();<br>                &#x2F;&#x2F;开启不断写的线程<br>                new Thread(new WriteThread(accept),”服务端”).start();<br>                &#x2F;&#x2F;开启不断读的线程<br>                new Thread(new ReadThread(accept),”服务端”).start();<br>            }<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p><p>&#x2F;&#x2F;创建客户端，并开启读写线程<br>public class ClientDemo {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F;客户端<br>        try {<br>            Socket socket&#x3D;new Socket(“192.168.102.16”,8888);<br>            InputStream is &#x3D; socket.getInputStream();<br>            byte[] b&#x3D;new byte[1024];<br>            new Thread(new WriteThread(socket),”客户端1”).start();<br>            while (true){<br>                int read &#x3D; is.read(b);<br>                System.out.println(new String(b,0,read));<br>            }<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p><p>&#x2F;&#x2F;创建读线程<br>public class ReadThread implements Runnable{<br>    private Socket socket;<br>    private InputStream is;</p><pre><code>public ReadThread(Socket socket) &#123;    this.socket = socket;    try &#123;        is=this.socket.getInputStream();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;  @Overridepublic void run() &#123;    byte[] b=new byte[1024];    while (true)&#123;        int read = 0;        try &#123;            read = is.read(b);            System.out.println(new String(b,0,read));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;创建写线程<br>public class WriteThread implements Runnable {<br>    private Socket socket;<br>    private OutputStream os;</p><pre><code>public WriteThread(Socket socket) &#123;    this.socket = socket;    try &#123;        os=socket.getOutputStream();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;  @Overridepublic void run() &#123;    //不断的写    Scanner scan=new Scanner(System.in);    while (true)&#123;        String msg=scan.nextLine();        msg=Thread.currentThread().getName()+&quot;:&quot;+msg;        try  &#123;            os.write(msg.getBytes());            os.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaの序列化流</title>
      <link href="/2020/04/11/Java%E3%81%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/"/>
      <url>/2020/04/11/Java%E3%81%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Javaの序列化流"><a href="#Javaの序列化流" class="headerlink" title="Javaの序列化流"></a>Java<strong>の序列化流</strong></h1><h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><ol><li><p>概述</p><ul><li><p>Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该 对象的数据 、 对象的类型 和 对象中存储的属性 等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。 对象的数据 、 对象的类型和对象中存储的数据 信息，都可以用来在内存中创建对象。</p><span id="more"></span></li></ul></li><li><p>ObjectOutPutStream类</p><ul><li>将Java对象的原始数据类型写出到文件,实现对象的持久存储。</li><li>一个对象要想序列化，必须满足两个条件:<ol><li>该类必须实现 java.io.Serializable 接口， Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出 NotSerializableException 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</li></ol></li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token comment">// transient瞬态修饰成员,不会被序列化</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addressCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Address  check : "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">" ‐‐ "</span> <span class="token operator">+</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SerializeDemo</span><span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>     <span class="token class-name">Employee</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         e<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"zhangsan"</span><span class="token punctuation">;</span>         e<span class="token punctuation">.</span>address <span class="token operator">=</span> <span class="token string">"beiqinglu"</span><span class="token punctuation">;</span>         e<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>          <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>           <span class="token comment">// 创建序列化流对象      </span>          <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"employee.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 写出对象    </span>         out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 释放资源    </span>         out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             fileOut<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Serialized data is saved"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 姓名，地址被序列化，年龄没有被序列化。</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">IOException</span> i<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>            i<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>ObjectInputPutStream类<ul><li>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。</li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>        <span class="token class-name">Employee</span> e <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">// 创建反序列化流</span>             <span class="token class-name">FileInputStream</span> fileIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"employee.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">ObjectInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>fileIn<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 读取一个对象</span>             e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 释放资源</span>             in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             fileIn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">IOException</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// 捕获其他异常</span>             i<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> c<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>         <span class="token comment">// 捕获类找不到异常    </span>             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Employee class not found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             c<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 无异常,直接打印输出</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Name: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// zhangsan  </span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Address: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// beiqinglu</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"age: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="4"><li>练习<ol><li>将存有多个自定义对象的集合序列化操作，保存到 list.txt 文件中。</li><li>反序列化 list.txt ，并遍历集合，打印对象信息。</li></ol></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//将存有多个自定义对象的集合序列化操作，保存到list.txt文件中</span>    <span class="token comment">//反序列化list.txt，并遍历集合，打印对象信息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Student</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"叶蕴森"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"上程数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Student</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"叶叶叶"</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token string">"下程数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Student</span> s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"蕴蕴蕴"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token string">"左程数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Student</span> s4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"森森森"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token string">"右程数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Student</span> s5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"叶蕴蕴"</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token string">"前程数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Student</span> s6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"蕴蕴森"</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token string">"后程数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s4<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s5<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s6<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"studentList.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileInputStream</span> fillIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"studentList.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>fillIn<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> newlist <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        newlist <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fillIn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> newlist<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">Student</span> next <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><h5 id="转化流"><a href="#转化流" class="headerlink" title="转化流"></a>转化流</h5><ol><li>InputStreamReader类<ul><li>转换流 java.io.InputStreamReader ，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。<br><strong>构造方法</strong><ul><li>InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。</li><li>InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。</li></ul></li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReaderDemo2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 定义文件路径,文件为gbk编码  </span>        <span class="token class-name">String</span> <span class="token class-name">FileName</span> <span class="token operator">=</span> <span class="token string">"E:\\file_gbk.txt"</span><span class="token punctuation">;</span>       <span class="token comment">// 创建流对象,默认UTF8编码  </span>        <span class="token class-name">InputStreamReader</span> isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token class-name">FileName</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 创建流对象,指定GBK编码  </span>        <span class="token class-name">InputStreamReader</span> isr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token class-name">FileName</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token string">"GBK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 定义变量,保存字符        </span>        <span class="token keyword">int</span> read<span class="token punctuation">;</span>       <span class="token comment">// 使用默认编码字符流读取,乱码  </span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>read <span class="token operator">=</span> isr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> ‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>read<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ��Һ�</span>        <span class="token punctuation">&#125;</span>        isr<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 使用指定编码字符流读取,正常解析  </span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>read <span class="token operator">=</span> isr2<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> ‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 大家好</span>           <span class="token punctuation">&#125;</span>        isr2<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li><p>OutputStreamReader类</p><ul><li>转换流 java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</li></ul><p><strong>构造方法</strong></p><ul><li>OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。</li><li>OutputStreamWriter(OutputStream in, String charsetName) : 创建一个指定字符集的字符流。</li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutputDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 定义文件路径  </span>        <span class="token class-name">String</span> <span class="token class-name">FileName</span> <span class="token operator">=</span> <span class="token string">"E:\\out.txt"</span><span class="token punctuation">;</span>       <span class="token comment">// 创建流对象,默认UTF8编码  </span>        <span class="token class-name">OutputStreamWriter</span> osw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token class-name">FileName</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写出数据</span>       osw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保存为6个字节  </span>        osw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 定义文件路径        </span>            <span class="token class-name">String</span> <span class="token class-name">FileName2</span> <span class="token operator">=</span> <span class="token string">"E:\\out2.txt"</span><span class="token punctuation">;</span>              <span class="token comment">// 创建流对象,指定GBK编码   </span>        <span class="token class-name">OutputStreamWriter</span> osw2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token class-name">FileName2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"GBK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写出数据</span>       osw2<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 保存为4个字节  </span>        osw2<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>转换文件编码<ul><li>需求：将GBK编码的文本文件，转换为UTF-8编码的文本文件。</li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransDemo</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 1.定义文件路径    </span>      <span class="token class-name">String</span> srcFile <span class="token operator">=</span> <span class="token string">"file_gbk.txt"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> destFile <span class="token operator">=</span> <span class="token string">"file_utf8.txt"</span><span class="token punctuation">;</span>        <span class="token comment">// 2.创建流对象        </span>     <span class="token comment">// 2.1 转换输入流,指定GBK编码    </span>        <span class="token class-name">InputStreamReader</span> isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token string">"GBK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 2.2 转换输出流,默认utf8编码    </span>        <span class="token class-name">OutputStreamWriter</span> osw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>destFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.读写数据        </span>     <span class="token comment">// 3.1 定义数组    </span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cbuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 3.2 定义长度    </span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>     <span class="token comment">// 3.3 循环读取    </span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> isr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 循环写出</span>           osw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>     <span class="token comment">// 4.释放资源    </span>        osw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        isr<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span></code></pre><h5 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h5><ol><li>PrintStream类<ul><li>平时我们在控制台打印输出，是调用 print 方法和 println 方法完成的，这两个方法都来自于java.io.PrintStream 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。<br><strong>构造方法：</strong></li><li>public PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。</li><li>System.out 就是 PrintStream 类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以将数据输出到指定文本文件中。</li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 调用系统的打印流,控制台直接输出97        </span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 创建打印流,指定文件的名称        </span>        <span class="token class-name">PrintStream</span> ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span><span class="token string">"ps.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 设置系统的打印流流向,输出到ps.txt  </span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setOut</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 调用系统的打印流,ps.txt中输出97  </span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li>PrintWriter类<ul><li>将信息打印到文本。<br><strong>构造方法：</strong><ul><li>public PrintWriter(File file) ： 使用指定的文件名创建一个打印流。</li></ul></li></ul></li></ol><h5 id="随机访问流RandomAccessFile"><a href="#随机访问流RandomAccessFile" class="headerlink" title="随机访问流RandomAccessFile"></a>随机访问流RandomAccessFile</h5><p>RandomAccessFile 类既可以读取文件内容，也可以向文件输出数据</p><p>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读写文件，支持只访问文件的部分内容，可以向已存在的文件后追加内容</p><p>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile 类对象可以自由移动记录指针：</p><p>long getFilePointer()：获取文件记录指针的当前位置</p><p>void seek(long pos)：将文件记录指针定位到 pos 位置</p><p>创建 RandomAccessFile 类可以指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式：</p><p>r: 以只读方式打开</p><p>rw：以读、写方式打开</p><p>读取任意位置的数据:将指针移到需要读取数据的前面：<br><img src="http://cdn.leafii.top/img/20220520165005.png" loading="lazy"><br>追加数据:将指针移到文件末尾：<br><img src="http://cdn.leafii.top/img/20220520165023.png" loading="lazy"><br>追加数据:任意位置插入数据：</p><p>RandomAccessFile依然只能追加，不能像文件的指定位置插入内容。如果强制将文件记录指针移动到中间位置后开始输出内容，则新的内容会覆盖文件中原有的内容。如果需要向文件指定的位置插入内容，程序需要先把插入点后面的内容读入缓冲区，等插入完成后，再将缓冲区的内容追加到文件的后面。<br><img src="http://cdn.leafii.top/img/20220520165037.png" loading="lazy"></p><h5 id="案例12-4"><a href="#案例12-4" class="headerlink" title="案例12-4"></a>案例12-4</h5><p>要求从文件中读取所有产品并按价格高低排序打印，求所有商品总价，并求各个等级商品的总价</p><p>文本内容如下:</p><p>西瓜,88,a,99</p><p>苹果,20.8,a,200</p><p>香蕉,18.9,b,100</p><p>栗子,15.8,c,88</p><p>梨子,8.9,c,199</p><p>荔枝,29.9,b,108</p><p>编写产品类：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">demo</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Fruit</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token comment">//商品名</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> price<span class="token punctuation">;</span><span class="token comment">//价格</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> lv<span class="token punctuation">;</span><span class="token comment">//等级</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment">//存货</span>     <span class="token keyword">public</span> <span class="token class-name">Fruit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Fruit&#123;"</span> <span class="token operator">+</span>                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", price="</span> <span class="token operator">+</span> price <span class="token operator">+</span>                <span class="token string">", lv='"</span> <span class="token operator">+</span> lv <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", count="</span> <span class="token operator">+</span> count <span class="token operator">+</span>                <span class="token char">'&#125;'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token class-name">Fruit</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> price<span class="token punctuation">,</span> <span class="token class-name">String</span> lv<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lv <span class="token operator">=</span> lv<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> price<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token keyword">double</span> price<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getLv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> lv<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLv</span><span class="token punctuation">(</span><span class="token class-name">String</span> lv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lv <span class="token operator">=</span> lv<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>price<span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Fruit</span><span class="token punctuation">)</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>编写测试类</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">demo</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//1.从文件中读取产品并打印</span>    <span class="token comment">//2.按照价格高低排序打印</span>    <span class="token comment">//3.求所有产品总价</span>    <span class="token comment">//4.求各个等级产品总价</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//创建目标文件对象</span>        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"d:/123.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//创建目标文件对象的缓冲字符输入流</span>            <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token comment">//存放商品的集合</span>            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Fruit</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//存放等级及对应总价</span>            <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Double</span><span class="token punctuation">></span></span> map<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//读取目标文件</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//将目标文件按照‘,’切割，并将数据转型，封装进对象，添加进集合</span>                <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> split <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">double</span> v <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> i1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//集合实现了Comparable接口，按照价格高低排序</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Fruit</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">,</span> split<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//定义总价</span>            <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>            <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Fruit</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//遍历所有商品，得到总价</span>                <span class="token class-name">Fruit</span> f <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sum <span class="token operator">=</span> sum <span class="token operator">+</span> f<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> f<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//---------------------------</span>                <span class="token comment">//获取各个等级的总价</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getLv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getLv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>f<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>f<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getLv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getLv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span>f<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>f<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//遍历map，打印等级及其总价</span>            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token punctuation">></span><span class="token punctuation">></span></span> iterator1 <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator1<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> iterator1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>next<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有商品总价:"</span> <span class="token operator">+</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaのIO流</title>
      <link href="/2020/04/11/Java%E3%81%AEIO%E6%B5%81/"/>
      <url>/2020/04/11/Java%E3%81%AEIO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaのIO流"><a href="#JavaのIO流" class="headerlink" title="JavaのIO流"></a>JavaのIO流</h1><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h5 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h5><ul><li>File 类代表与平台无关的文件和目录。</li><li>File  能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。<span id="more"></span></li></ul><ol><li>File的常用方法<br><img src="http://cdn.leafii.top/img/20220520164903.png" loading="lazy"></li><li>遍历给定目录所有文件</li></ol> <pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">am</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">File</span></span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">File</span> file<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"E:\\ftproot\\资料"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">show</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">,</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">File</span> f<span class="token operator">:</span>files<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">+</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">show</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span>s<span class="token operator">+</span><span class="token string">"    "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">+</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>给定目录，删除该目录下的空文件夹</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"/Users/yeyunsen/Documents/大学/大四上/day13/src/com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">File</span> f <span class="token operator">:</span>                files<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除空目录："</span> <span class="token operator">+</span> f<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token string">"成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><h5 id="案例12-1-模拟文件管理器"><a href="#案例12-1-模拟文件管理器" class="headerlink" title="案例12-1:模拟文件管理器"></a>案例12-1:模拟文件管理器</h5><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">demo2</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//定义一个装符合关键字搜索的文件目录</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> listByKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//定义一个装符合后缀名搜索的文件目录</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> listByShuffix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//模拟资源管理器</span>        <span class="token comment">//能够按照关键字搜索，能够按照后缀名搜索，能够复制</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======文件资源管理========="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1.按照关键字搜索"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2.按照后缀名搜索"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3.复制"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4.退出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Scanner</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入操作:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> sca<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                <span class="token function">findBuyKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>                <span class="token function">findBuySuffix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>                <span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>                <span class="token function">loginout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">findBuyKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//按照关键字搜索：</span>        <span class="token comment">// 1.目标目录  2.关键字key</span>        <span class="token class-name">Scanner</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入要查找的目录："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> srcdir <span class="token operator">=</span> sca<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入要查找的文件："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> sca<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>srcdir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">listfile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listByKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">findBuySuffix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//按照后缀名搜索：</span>        <span class="token comment">// 1.目标目录  2.后缀名suffix</span>        <span class="token class-name">Scanner</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入要查找的目录："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> srcdir <span class="token operator">=</span> sca<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入要查找的后缀名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> suffix <span class="token operator">=</span> sca<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>srcdir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">listfile2</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span>suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listByShuffix<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//复制</span>        <span class="token comment">//1.源文件   2.目标文件</span>        <span class="token class-name">Scanner</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入要复制的文件目录："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> srcfile <span class="token operator">=</span> sca<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入要复制的目标目录："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> tofile <span class="token operator">=</span> sca<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BufferedInputStream</span> bis <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>srcfile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>tofile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>tong<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>tong<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            bos<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bos <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    bos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bis <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    bis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loginout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">listfile2</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">,</span> <span class="token class-name">String</span> suffix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">File</span> f <span class="token operator">:</span> files<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">listfile2</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> suffix<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span>suffix<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    listByShuffix<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">listfile</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">,</span> <span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">File</span> f <span class="token operator">:</span> files<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    listByKey<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">listfile</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    listByKey<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="2-IO流概述及其分类"><a href="#2-IO流概述及其分类" class="headerlink" title="2. IO流概述及其分类"></a>2. IO流概述及其分类</h5><p>1).IO流概述</p><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。它的特性是进行数据传输.例如从水源地长江把水导入自来水厂，然后又从自来水厂把水送到各家各户。从长江到自来水厂之间的管道我们可以称之为输入流，从自来水厂把水送到各家各户的管道我们称之为输出流，我们大概可以这么理解。</p><p>IO即为input和output,即输入输出.</p><p>2).IO流分类</p><p>流按照流向数据流向可以分为输入流和输出流。</p><p>流按照处理数据类型的单位不同可以分为字节流和字符流。</p><p>3).IO流继承图<br><img src="http://cdn.leafii.top/img/20220520164917.png" loading="lazy"><img src="http://cdn.leafii.top/img/20220520164930.png" loading="lazy"></p><h5 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3.字节流"></a>3.字节流</h5><p>1).字节流的概念</p><p>InputStream为字节输入流，本身是个抽象类，表示字节输入流的所有类的超类，必须依靠其子类实现各种功能，数据单位位字节。常用方法有：</p><pre><code>    （1） public abstract int read( )：读取一个byte的数据，返回值是高位补0的int类型值。若返回值=-1说明没有读取到任何字节读取工作结束。</code></pre><p>　　 （2） public int read(byte b[ ])：读取b.length个字节的数据放到b数组中。返回值是读取的字节数。该方法实际上是调用下一个方法实现的<br>　　 （3） public int read(byte b[ ], int off, int len)：从输入流中最多读取len个字节的数据，存放到偏移量为off的b数组中。<br>　　 （4） public int available( )：返回输入流中可以读取的字节数。注意：若输入阻塞，当前线程将被挂起，如果InputStream对象调用这个方法的话，它只会返回0，这个方法必须由继承InputStream类的子类对象调用才有用，<br>　　 （5） public long skip(long n)：忽略输入流中的n个字节，返回值是实际忽略的字节数, 跳过一些字节来读取<br>　　 （6） public int close( ) ：我们在使用完后，必须对我们打开的流进行关闭.</p><p>OutputStream为字节输出流，常用方法有：</p><p>　　（1） public void write(byte b[ ])：将参数b中的字节写到输出流。<br>　　（2） public void write(byte b[ ], int off, int len) ：将参数b的从偏移量off开始的len个字节写到输出流。<br>　　（3） public abstract void write(int b) ：先将int转换为byte类型，把低字节写入到输出流中。<br>　　（4） public void flush( ) : 将数据缓冲区中数据全部输出，并清空缓冲区。<br>　　（5） public void close( ) : 关闭输出流并释放与流相关的系统资源。</p><p>2).字节流读取文件</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FISRead</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>       <span class="token comment">// 使用文件名称创建流对象  </span>       <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"read.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 读取数据，返回一个字节  </span>        <span class="token keyword">int</span> read <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> read<span class="token punctuation">)</span><span class="token punctuation">;</span>        read <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> read<span class="token punctuation">)</span><span class="token punctuation">;</span>        read <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> read<span class="token punctuation">)</span><span class="token punctuation">;</span>        read <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> read<span class="token punctuation">)</span><span class="token punctuation">;</span>        read <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> read<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 读取到末尾,返回‐1  </span>       read <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> read<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 关闭资源        </span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//循环改进读取方式</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FISRead</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>          <span class="token comment">// 使用文件名称创建流对象  </span>       <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"read.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 定义变量，保存数据  </span>        <span class="token keyword">int</span> b ；        <span class="token comment">// 循环读取</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>            <span class="token comment">// 关闭资源        </span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//使用字节数组读取</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FISRead</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>       <span class="token comment">// 使用文件名称创建流对象.  </span>       <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"read.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 文件中为abcde</span>       <span class="token comment">// 定义变量，作为有效个数  </span>        <span class="token keyword">int</span> len ；        <span class="token comment">// 定义字节数组，作为装字节数据的容器  </span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 循环读取</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span> len<span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token comment">// 每次读取后,把数组变成字符串打印</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>            <span class="token comment">// 关闭资源        </span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//使用字节数组读取-优化</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FISRead</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>         <span class="token comment">// 使用文件名称创建流对象.  </span>           <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"read.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 文件中为abcde</span>         <span class="token comment">// 定义变量，作为有效个数  </span>        <span class="token keyword">int</span> len ；        <span class="token comment">// 定义字节数组，作为装字节数据的容器  </span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 循环读取</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span> len<span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>b，<span class="token number">0</span>，len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  len 每次读取的有效字节个数</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 关闭资源        </span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>3).文件的拷贝</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Copy</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.创建流对象</span>        <span class="token comment">// 1.1 指定数据源</span>        <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\test.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.2 指定目的地</span>        <span class="token class-name">FileOutputStream</span> fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"test_copy.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.读写数据</span>        <span class="token comment">// 2.1 定义数组</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 2.2 定义长度</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token comment">// 2.3 循环读取</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 2.4 写出数据</span>            fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 3.关闭资源</span>        fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4.字符流"></a>4.字符流</h5><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><p>1).字符流定义及基本用法</p><p>Reader为字符输入流，常用方法有：</p><pre><code>    （1） public int read() throws IOException: 读取一个字符，返回值为读取的字符</code></pre><p>　　 （2） public int read(char cbuf[]) throws IOException:读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量<br>　　 （3） public abstract int read(char cbuf[],int off,int len) throws IOException:读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现。</p><p>Writer为字符输出流，常用法有：</p><pre><code>    （1） public void write(int c) throws IOException：将整型值c的低16位写入输出流</code></pre><p>　　 （2） public void write(char cbuf[]) throws IOException：将字符数组cbuf[]写入输出流<br>　　 （3） public abstract void write(char cbuf[],int off,int len) throws IOException：将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流<br>　　 （4） public void write(String str) throws IOException：将字符串str中的字符写入输出流<br>　　 （5） public void write(String str,int off,int len) throws IOException：将字符串str 中从索引off开始处的len个字符写入输出流<br>　　 （6） flush( ) ：刷空输出流，并输出所有被缓存的字节。<br>　　 （7） close() ：关闭流</p><p>2).字符流操作文件</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//单个字符读取</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FRRead</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 使用文件名称创建流对象  </span>       <span class="token class-name">FileReader</span> fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"read.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 定义变量，保存数据  </span>        <span class="token keyword">int</span> b ；        <span class="token comment">// 循环读取</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> fr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 关闭资源        </span>        fr<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//使用字符数组读取</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FRRead</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 使用文件名称创建流对象  </span>       <span class="token class-name">FileReader</span> fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"read.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 定义变量，保存有效字符个数  </span>        <span class="token keyword">int</span> len ；        <span class="token comment">// 定义字符数组，作为装字符数据的容器</span>         <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cbuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 循环读取</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 关闭资源        </span>        fr<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//使用字符数组读取--优化</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FISRead</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>           <span class="token comment">// 使用文件名称创建流对象  </span>           <span class="token class-name">FileReader</span> fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"read.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 定义变量，保存有效字符个数  </span>        <span class="token keyword">int</span> len ；               <span class="token comment">// 定义字符数组，作为装字符数据的容器</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cbuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 循环读取</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>             <span class="token comment">// 关闭资源    </span>        fr<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//字符流写数据--单个字符</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FWWrite</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 使用文件名称创建流对象</span>        <span class="token class-name">FileWriter</span> fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"fw.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 写出数据  </span>       fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写出第1个字符  </span>       fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token char">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写出第2个字符  </span>       fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token char">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写出第3个字符  </span>       fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">30000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写出第4个字符，中文编码表中30000对应一个汉字。  </span>       fw<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">/*          【注意】关闭资源时,与FileOutputStream不同。        如果不关闭,数据只是保存到缓冲区，并未保存到文件。          */</span>       fw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//字符流写数据--字符数组</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FWWrite</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 使用文件名称创建流对象</span>        <span class="token class-name">FileWriter</span> fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"fw.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 字符串转换为字节数组  </span>       <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> <span class="token string">"上程数据"</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 写出字符数组  </span>       fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>                        fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 关闭资源  </span>        fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//字符流写数据--字符数组</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FWWrite</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 使用文件名称创建流对象</span>      <span class="token class-name">FileWriter</span> fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"fw.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 字符串  </span>      <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token string">"上程数据"</span><span class="token punctuation">;</span>           fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>               fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 关闭资源</span>      fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="5-缓冲流"><a href="#5-缓冲流" class="headerlink" title="5. 缓冲流"></a>5. 缓冲流</h5><p>缓冲流,也叫高效流，是对4个基本的 FileXxx 流的增强，所以也是4个流，按照数据类型分类：</p><p>字节缓冲流： BufferedInputStream ， BufferedOutputStream<br>字符缓冲流： BufferedReader ， BufferedWriter<br>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h6 id="5-1-字节缓冲流"><a href="#5-1-字节缓冲流" class="headerlink" title="5.1 字节缓冲流"></a>5.1 字节缓冲流</h6><p>构造方法</p><ul><li>public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。</li><li>public BufferedOutputStream(OutputStream out) ： 创建一个新的缓冲输出流。</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建字节缓冲输入流</span><span class="token class-name">BufferedInputStream</span> bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"bis.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建字节缓冲输出流</span><span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"bos.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//记录开始时间</span>       <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//创建流对象        </span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>         <span class="token class-name">BufferedInputStream</span> bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"jdk8.exe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"copy.exe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">//读写数据</span>            <span class="token keyword">int</span> b<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> ‐<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                           bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//记录结束时间        </span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"缓冲流复制时间:"</span><span class="token operator">+</span><span class="token punctuation">(</span>end ‐ start<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h6 id="5-2-字符缓冲流"><a href="#5-2-字符缓冲流" class="headerlink" title="5.2 字符缓冲流"></a>5.2 字符缓冲流</h6><p>构造方法</p><ul><li><p>public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。</p></li><li><p>public BufferedWriter(Writer out) ： 创建一个新的缓冲输出流。<br>特有方法</p></li><li><p>BufferedReader： public String readLine() : 读一行文字。</p></li><li><p>BufferedWriter： public void newLine() : 写一行行分隔符,由系统属性定义符号。</p></li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建字符缓冲输入流</span><span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"br.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建字符缓冲输出流</span><span class="token class-name">BufferedWriter</span> bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"bw.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//readLine 方法演示</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedReaderDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建流对象  </span>        <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 定义字符串,保存读取的一行文字        </span>        <span class="token class-name">String</span> line  <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>       <span class="token comment">// 循环读取,读取到最后返回null  </span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"‐‐‐‐‐‐"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>            <span class="token comment">// 释放资源        </span>        br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//newLine 方法演示</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferedWriterDemo</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span>  <span class="token punctuation">&#123;</span>       <span class="token comment">// 创建流对象  </span>            <span class="token class-name">BufferedWriter</span> bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 写出数据  </span>        bw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"上程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 写出换行  </span>        bw<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bw<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 释放资源        </span>        bw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h6 id="案例8-3-恢复文本排序"><a href="#案例8-3-恢复文本排序" class="headerlink" title="案例8-3:恢复文本排序"></a>案例8-3:恢复文本排序</h6><p>请将文本信息恢复顺序</p><pre class="language-none"><code class="language-none">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Recovery</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">///Users/yeyunsen/Documents/大学/大四上/day13/chushibiao.txt</span>        <span class="token comment">///Users/yeyunsen/Documents/大学/大四上/day13/out.txt</span>        <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\Administrator\\Desktop\\day13\\day13\\chushibiao.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BufferedWriter</span> bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\Administrator\\Desktop\\day13\\day13\\out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> s<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">=</span>br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> split <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//String.valueOf(int i) : 将 int 变量 i 转换成字符串</span>            <span class="token class-name">String</span> value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                bw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"."</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                bw<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                bw<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        bw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaの生产者消费者问题</title>
      <link href="/2020/04/08/Java%E3%81%AE%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/08/Java%E3%81%AE%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Javaの生产者消费者问题"><a href="#Javaの生产者消费者问题" class="headerlink" title="Javaの生产者消费者问题"></a>Javaの生产者消费者问题</h1><h3 id="生产者消费者问题（多线程应用经典案例）"><a href="#生产者消费者问题（多线程应用经典案例）" class="headerlink" title="生产者消费者问题（多线程应用经典案例）"></a>生产者消费者问题（多线程应用经典案例）</h3><p>生产者在生产商品，而消费者在消费生产的商品。生产者把生产的商品放进容器中，而消费者从容器中取出商品进行消费。可是在整个过程中，如果容器装满了，那么生产者应该停止生产，如果容器中没有商品了，消费应该停止消费。这就是一个典型的多生产，多消费的案例。</p><span id="more"></span><ol><li><p>单生产单消费</p><ul><li>在学习过程中，为了代码简单明了，大家很容易看懂，就把上述的多生产和多消费进行简化，要求生产者生产一个商品，消费者消费一个商品，然后生产者继续生产，消费者进行消费，以此类推下去。</li><li>分析案例：</li><li>生产和消费同时执行，需要多线程。但是执行的任务却不相同，处理的资源确实相同的：线程间的通信。</li><li>思路：1、描述一下资源。2、描述生产者，具备着自己的任务。3、描述消费者，具备着自己的任务。</li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//描述资源。属性：商品名称和编号，  行为：对商品名称赋值，获取商品。</span><span class="token keyword">class</span> <span class="token class-name">Resource</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//对外提供设置商品的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//给成员变量赋值并加上编号。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">+</span> count<span class="token punctuation">;</span>        <span class="token comment">//编号自增。</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">//打印生产了哪个商品。</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....生产了...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....消费了...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//描述生产者</span><span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Resource</span> r<span class="token punctuation">;</span>    <span class="token comment">//生产者以创建就应该明确资源</span>    <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//生产者生产商品的任务</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//生产者无限制的生产</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            r<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"面包"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//描述消费者</span><span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Resource</span> r<span class="token punctuation">;</span>    <span class="token comment">//生产者以创建就应该明确资源</span>    <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//生产者生产商品的任务</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            r<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">ThreadDemo5</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//创建资源对象</span>        <span class="token class-name">Resource</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//创建生产者对象</span>        <span class="token class-name">Producer</span> pro <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建消费者对象</span>        <span class="token class-name">Consumer</span> con <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//创建线程对象</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启线程</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>上述代码进行运行时发现有严重的问题。</p><p>问题1：数据错误：已经被生产很早期的商品，才被消费到。</p><p>出现线程安全问题，加入了同步解决。使用同步函数。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Resource</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//对外提供设置商品的方法</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//给成员变量赋值并加上编号。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">+</span> count<span class="token punctuation">;</span>        <span class="token comment">//编号自增。</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">//打印生产了哪个商品。</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....生产者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....消费者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>先前问题已解决：不会在消费到之前很早期的商品。</p><p>但加入同步后又有新的问题产生了。</p><p>问题2：发现了连续生产却没有消费，同时对同一个商品进行多次消费。希望的结果应该是生产一个商品，就被消费掉。生产下一个商品。搞清楚几个问题？生产者什么时候生产呢？消费者什么时候应该消费呢？</p><p>当容器中没有面包时，就生产，如果有了面包，就不要生产。</p><p>当容器中已有面包时，就消费，如果没有面包，就不要消费。</p><p>2).等待唤醒机制</p><p>生产者生产了商品后应该告诉消费者来消费。这时的生产者应该处于等待状态。消费者消费了商品后，应该告诉生产者，这时消费者处于等待状态。</p><p>等待：wait();</p><p>通知：notify();&#x2F;&#x2F;唤醒</p><p>问题解决：实现生产一个消费一个。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//描述资源。属性：商品名称和编号，  行为：对商品名称赋值，获取商品。</span><span class="token keyword">class</span> <span class="token class-name">Resource</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">//对外提供设置商品的方法</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span><span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//给成员变量赋值并加上编号。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">+</span> count<span class="token punctuation">;</span>        <span class="token comment">//编号自增。</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">//打印生产了哪个商品。</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....生产者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将标记改为true。</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//唤醒消费者。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span><span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....消费者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将标记改为false。</span>        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">//唤醒生产者。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>等待&#x2F;唤醒机制：</p><p>wait(): 会让线程处于等待状态，其实就是将线程临时存储到了线程池中。</p><p>notify():会唤醒线程池中任意一个等待的线程。</p><p>notifyAll():会唤醒线程池中所有的等待线程。</p><p>记住：这些方法必须使用在同步中，因为必须要标识wait，notify等方法所属的锁。同一个锁上的notify，只能唤醒该锁上的被wait的线程。</p><p>为什么这些方法定义在Object类中呢？</p><p>因为这些方法必须标识所属的锁，而锁可以是任意对象，任意对象可以调用的方法必然时Object类中的方法。</p><p>3).多生产多消费-1</p><p>上述程序只是一个生产和一个消费者，其实就是所谓的单生产和单消费，可是我们都知道生活中经常会有多个生产者和消费者，把代码改为多个生产者或多个消费者。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ThreadDemo5</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//创建资源对象</span>        <span class="token class-name">Resource</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//创建生产者对象</span>        <span class="token class-name">Producer</span> pro <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建消费者对象</span>        <span class="token class-name">Consumer</span> con <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//创建线程对象</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启线程</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t4<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>把生产者和消费者改为多个时，又有新的问题发生了。</p><p>问题1:生产了商品没有被消费，同一个商品被消费多次。</p><p>问题原因：</p><p>被唤醒的线程没有判断标记，造成问题1的产生。</p><p>解决：只要让被唤醒的线程必须判断标记就可以了。将if判断标记的方式改为while判断标记。记住：多生产多消费，必须时while判断条件。</p><p>当把if改为while之后又出现问题了。</p><p>问题2：发现while判断后，死锁了。</p><p>原因：生产方唤醒了线程池中生产方的线程。本方唤醒了本方。</p><p>解决：希望本方要唤醒对方，没有对应的方法，所以只能唤醒所有。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//描述资源。属性：商品名称和编号，  行为：对商品名称赋值，获取商品。</span><span class="token keyword">class</span> <span class="token class-name">Resource</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">//对外提供设置商品的方法</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span><span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//给成员变量赋值并加上编号。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">+</span> count<span class="token punctuation">;</span>        <span class="token comment">//编号自增。</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">//打印生产了哪个商品。</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....生产者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将标记改为true。</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//唤醒消费者。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span><span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....消费者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将标记改为false。</span>        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">//唤醒生产者。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="Lock接口和Condition接口"><a href="#Lock接口和Condition接口" class="headerlink" title="Lock接口和Condition接口"></a>Lock接口和Condition接口</h5><hr><p>4.1 Lock接口</p><p>4.1.1 synchronized的缺陷</p><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。</p><p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><p>1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</p><p>2）线程执行发生异常，此时JVM会让线程自动释放锁。</p><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p><p>　　再举个例子：</p><p>当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p><p>但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p><p>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。另外，通过Lock可以知道线程有没有成功获取到锁。这个是  synchronized无法办到的。<br>4.1.2 Lock接口</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lock</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><p>　　由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">&#123;</span>    <span class="token comment">//处理任务</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token punctuation">&#125;</span><span class="token keyword">finally</span><span class="token punctuation">&#123;</span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//释放锁</span><span class="token punctuation">&#125;</span></code></pre><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p>　　tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><p>　　所以，一般情况下通过tryLock来获取锁时是这样使用的：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">try</span><span class="token punctuation">&#123;</span>         <span class="token comment">//处理任务</span>     <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               <span class="token punctuation">&#125;</span><span class="token keyword">finally</span><span class="token punctuation">&#123;</span>         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//释放锁</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//如果不能获取锁，则直接做其他事情</span><span class="token punctuation">&#125;</span></code></pre><p>4.2 Condition接口</p><p>虽然把锁换成了显示的锁，可是使用的等待和唤醒还是Object中的wait和notify，这就会导致锁和等待唤醒机制处于两个对象上，而我们想要的应该是那个锁下的线程等待和唤醒，也就是等待唤醒机制和锁有一定的关联关系。Condition对象的出现其实就是替代了Object中的监视器方法。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span> <span class="token comment">//描述资源。属性：商品名称和编号，  行为：对商品名称赋值，获取商品。</span><span class="token keyword">class</span> <span class="token class-name">Resource</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">//创建锁对象</span>    <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取监视器对象，其实就是让锁和监视器关联起来</span>    <span class="token class-name">Condition</span> con <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//对外提供设置商品的方法</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//获取锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span><span class="token punctuation">&#123;</span>con<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//给成员变量赋值并加上编号。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">+</span> count<span class="token punctuation">;</span>            <span class="token comment">//编号自增。</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//打印生产了哪个商品。</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....生产者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//将标记改为true。</span>            flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token comment">//唤醒消费者。</span>            con<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">finally</span><span class="token comment">//由于锁的动作一定要释放，所以使用try-finally组合</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//释放锁</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//获取锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span><span class="token punctuation">&#123;</span>con<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....消费者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//将标记改为false。</span>            flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment">//唤醒生产者。</span>            con<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">finally</span><span class="token comment">//由于锁的动作一定要释放，所以使用try-finally组合</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//释放锁</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>将所有的监视器方法替换成了Condition。功能和之前的老程序的功能一样，仅仅是用新的对象。改了写法而已。但是问题依旧；效率还是低。低效的原因是本方可能唤醒的是本方，而我们希望本方可以唤醒对方中的一个。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span> <span class="token comment">//描述资源。属性：商品名称和编号，  行为：对商品名称赋值，获取商品。</span><span class="token keyword">class</span> <span class="token class-name">Resource</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">//定义一个锁对象。</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取锁上的Condition对象。为了解决本方唤醒对方的问题。可以一个锁创建两个监视器对象。</span>    <span class="token keyword">private</span> <span class="token class-name">Condition</span> produce <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//负责生产。</span>    <span class="token keyword">private</span> <span class="token class-name">Condition</span> consume <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//负责消费。</span>    <span class="token comment">//对外提供设置商品的方法</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//获取锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span><span class="token punctuation">&#123;</span>produce<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//给成员变量赋值并加上编号。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">+</span> count<span class="token punctuation">;</span>            <span class="token comment">//编号自增。</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//打印生产了哪个商品。</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....生产者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//将标记改为true。</span>            flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token comment">//唤醒消费者。</span>            consume<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">finally</span><span class="token comment">//由于锁的动作一定要释放，所以使用try-finally组合</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//释放锁</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//获取锁</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span><span class="token punctuation">&#123;</span>consume<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".....消费者...."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//将标记改为false。</span>            flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment">//唤醒生产者。</span>            produce<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">finally</span><span class="token comment">//由于锁的动作一定要释放，所以使用try-finally组合</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//释放锁</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="多生产多消费-2"><a href="#多生产多消费-2" class="headerlink" title="多生产多消费 -2"></a>多生产多消费 -2</h5><p>前面的程序出现的问题是，多个生产者，生产同一个商品，或者多个消费者消费同一个商品，其实在生活中我们会到多个生产者同时生产同类以商品，而多个消费者消费这同一类商品。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">BoundedBuffer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//锁</span>    <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull  <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生产</span>    <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//消费</span>     <span class="token keyword">private</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存储商品的容器。</span>    <span class="token keyword">int</span> putptr<span class="token comment">/*生产者使用的角标*/</span><span class="token punctuation">,</span> takeptr<span class="token comment">/*消费者使用的角标*/</span><span class="token punctuation">,</span> count<span class="token comment">/*计数器*/</span><span class="token punctuation">;</span>     <span class="token comment">/*生产者使用的方法，往数组中存储商品*/</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> x<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//判断计数器是否已到数组长度。满了。</span>                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生产就等待。</span>             x<span class="token operator">=</span>x<span class="token operator">+</span>number<span class="token punctuation">;</span>            items<span class="token punctuation">[</span>putptr<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//按照角标将商品存储到数组中</span>            number<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putptr <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//如果存储的角标到了数组的长度，就将角标归零。</span>                putptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token operator">++</span>count<span class="token punctuation">;</span><span class="token comment">//计数器自增。</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"生产了"</span><span class="token operator">+</span>x<span class="token operator">+</span><span class="token string">",当前数量:"</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//唤醒一个消费者</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//如果计数器为0，说明没有商品，消费者等待。</span>                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Object</span> x <span class="token operator">=</span> items<span class="token punctuation">[</span>takeptr<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//从数组中通过消费者角标获取商品。</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeptr <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//如果消费的角标等于了数组的长度，将角标归零。</span>                takeptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token operator">--</span>count<span class="token punctuation">;</span><span class="token comment">//计数器自减。</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"消费了"</span><span class="token operator">+</span>x<span class="token operator">+</span><span class="token string">",当前数量:"</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//唤醒生产者。</span>         <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//生产者</span><span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">BoundedBuffer</span> r<span class="token punctuation">;</span>     <span class="token comment">//生产者以创建就应该明确资源</span>    <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token class-name">BoundedBuffer</span> r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//生产者生产商品的任务</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//生产者无限制的生产</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span><span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                r<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"苹果"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">BoundedBuffer</span> r<span class="token punctuation">;</span>    <span class="token comment">//生产者以创建就应该明确资源</span>    <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token class-name">BoundedBuffer</span> r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//生产者生产商品的任务</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span><span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                r<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemo5</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//创建资源对象</span>        <span class="token class-name">BoundedBuffer</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BoundedBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//创建生产者对象</span>        <span class="token class-name">Producer</span> pro <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建消费者对象</span>        <span class="token class-name">Consumer</span> con <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//创建线程对象</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启线程</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t4<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="用集合实现多生产多消费"><a href="#用集合实现多生产多消费" class="headerlink" title="用集合实现多生产多消费"></a>用集合实现多生产多消费</h3><p>Resource.java</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Resource</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Condition</span> notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> nn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            name <span class="token operator">=</span> nn <span class="token operator">+</span> number<span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            number<span class="token operator">++</span><span class="token punctuation">;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"生产了"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//！！！！这边容易忘记！！！！！！</span>                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">Object</span> o <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"消费了"</span> <span class="token operator">+</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            notFull<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>Producer.java</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Resource</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>               <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>           r<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"柚子"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>Cudtomer.java</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Resource</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            r<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>main方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Resource</span> r<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Producer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Customer</span> customer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>customer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>customer<span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t4<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaのMap接口，多线程，死锁</title>
      <link href="/2020/04/08/Java%E3%81%AEMap%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%AD%BB%E9%94%81/"/>
      <url>/2020/04/08/Java%E3%81%AEMap%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaのMap接口，多线程，死锁"><a href="#JavaのMap接口，多线程，死锁" class="headerlink" title="JavaのMap接口，多线程，死锁"></a>JavaのMap接口，多线程，死锁</h1><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>1).Map接口介绍</p><p>Map 用于保存具有映射关系的数据，因此 Map 集合里保存着两组值，一组值用于保存 Map 里的 Key，另外一组用于保存 Map 里的 Value <span id="more"></span></p><p>Map 中的 key 和  value 都可以是任何引用类型的数据</p><p>Map 中的 Key 不允许重复，即同一个 Map 对象的任何两个 Key 通过 equals 方法比较中返回 false</p><p>Key 和 Value 之间存在单向一对一关系，即通过指定的 Key 总能找到唯一的，确定的 Value。<br><img src="http://cdn.leafii.top/img/20220520164732.png" loading="lazy"><br>2).HashMap集合</p><p>HashMap是 Map 接口使用频率最高的实现类。</p><p>HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。与HashSet一样，此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</p><p>HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。</p><p>3).遍历HashMap</p><p>   ①Map集合遍历键找值方式：即通过元素中的键，获取键所对应的值</p><p>   操作步骤：</p><p>   1.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。</p><p>   2.遍历键的Set集合，得到每一个键</p><p>   3.根据键，获取键所对应的值</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> map<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"007"</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span><span class="token string">"hello2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"003"</span><span class="token punctuation">,</span><span class="token string">"hello3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"004"</span><span class="token punctuation">,</span><span class="token string">"hello4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"005"</span><span class="token punctuation">,</span><span class="token string">"hello5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> key<span class="token operator">=</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>   ②Map集合遍历键值对方式：即通过集合中每个键值对（Entry）对象，获取键值对对象中的键与值</p><p>操作步骤：</p><p>   1.获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。</p><p>   2.遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象</p><p>   3.通过键值对(Entry)对象，获取Entry对象中的键与值。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> map<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"007"</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span><span class="token string">"hello2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"003"</span><span class="token punctuation">,</span><span class="token string">"hello3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"004"</span><span class="token punctuation">,</span><span class="token string">"hello4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"005"</span><span class="token punctuation">,</span><span class="token string">"hello5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> entry<span class="token operator">=</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" :"</span> <span class="token operator">+</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><p>3).TreeMap集合</p><ul><li>TreeMap是用键来进行升序顺序来排序的。通过Comparable 或 Comparator来排序。</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">pm</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">TreeMap</span></span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//输入一串字符串，然后输出每个字符出现的次数，用TreeMap</span>        <span class="token class-name">String</span> s<span class="token operator">=</span><span class="token string">"aklsdhajhfakjhgdasdgahg中华787人民共45678和国"</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> map<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> entry<span class="token operator">=</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>4).Properties集合</p><ul><li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件由于属性文件里的 key、value 都是字符串类型，所以 properties 里的 Key 和 Value 都是字符串类型的</li></ul><h3 id="斗地主洗牌发牌"><a href="#斗地主洗牌发牌" class="headerlink" title="斗地主洗牌发牌"></a>斗地主洗牌发牌</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo4</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//斗地主发牌</span>        <span class="token comment">//先把牌弄出来，2个集合，一个集合装花色，一个集合装数字</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> type <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        type<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"♣"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        type<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"♠"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        type<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"♦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        type<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"♥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> dot <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//添加数字牌</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dot<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//添加非数字牌</span>        dot<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dot<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Q"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dot<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"K"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dot<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dot<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span></span> poke <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token operator">:</span>dot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> sc <span class="token operator">:</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                poke<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>sc<span class="token operator">+</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        poke<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">,</span><span class="token string">"大王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poke<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">53</span><span class="token punctuation">,</span><span class="token string">"小王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entries <span class="token operator">=</span> poke<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> entry <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//分配编号</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> number <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">54</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            number<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//打乱牌号</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">shuffle</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        System.out.println(number.size());</span>        <span class="token comment">//新建三个人，一个底牌来接收牌号</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> boom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//分配牌号</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">51</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">3</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                p1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">3</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                p2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">3</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                p3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">51</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">53</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            boom<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//按照编号排序</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>boom<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//新建四个集合来装牌</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> p11 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> p21 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> p31 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> pboom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> i <span class="token operator">:</span>                p1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p11<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>poke<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> i <span class="token operator">:</span>                p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p21<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>poke<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> i <span class="token operator">:</span>                p3<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p31<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>poke<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> i <span class="token operator">:</span>                boom<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pboom<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>poke<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p11<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p21<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p31<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pboom<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="输入字符串-统计各个字符的个数"><a href="#输入字符串-统计各个字符的个数" class="headerlink" title="输入字符串 统计各个字符的个数"></a>输入字符串 统计各个字符的个数</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请输入字符串："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> str <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Character</span> c<span class="token operator">:</span>strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> entry <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="关于集合的总结："><a href="#关于集合的总结：" class="headerlink" title="关于集合的总结："></a>关于集合的总结：</h5><p>1）Set集合和List集合的区别?</p><p>Set: 不允许元素重复, 集合元素唯一(元素可以为null), 不能保证迭代顺序恒久不变, 无序(存储和取出不一致).</p><p>List: 允许元素重复, 并且元素有序(存储和取出一致).</p><p>2).Set 集合存储元素时可以保证元素的唯一性, 原因什么?</p><p>HashSet 集合的add()方法底层依赖于双列集合HashMap, 它依赖于两个方法 equals()和hashCode(); 先比较元素hashCoede值,  再比较equals().</p><p>3).HashSet元素如何添加？</p><p>当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值,判断已经存储在集合中的对象的hashCode值是否与添加的对象的hashCode值一致:若不一致:直接添加进去;若一致,再进行equals方法比较,equals方法如果返回true,表明对象已经添加进去了,就不会再添加新的对象了,否则添加进去;如果我们重写了equals方法,也要重写hashCode方法,反之亦然;。</p><p>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode方法返回值也相等。<br>4).ArrayList和LinkedList有什么区别？</p><p>ArrayList和LinkedList在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下：<br>1．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。</p><p>2．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。</p><p>3．LinkedList不支持高效的随机元素访问。</p><p>4．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间</p><p>可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。</p><p>5).HashMap和HashTable有什么区别？</p><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p><ol><li>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li><li>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li><li>另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li><li>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li><li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li></ol><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="1-线程概述"><a href="#1-线程概述" class="headerlink" title="1.线程概述"></a>1.线程概述</h4><pre><code>  1. 进程</code></pre><ul><li><p>程序（program）是对数据描述与操作的代码的集合，是应用程序执行的脚本。</p></li><li><p>进程（process）是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行 一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p>多任务（multi task）在一个系统中可以同时运行多个程序，即有多个独立运行的任务，每个任务对应一个进程。</p><ol start="2"><li>线程</li></ol><ul><li><p>线程（thread）：比进程更小的运行单位，是程序中单个顺序的流控制。一个进程中可以包含多个线程。</p></li><li><p>简单来讲，线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序。</p></li><li><p>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</p></li><li><p>操作系统给每个线程分配不同的CPU时间片，在某一时刻，CPU只执行一个时间片内的线程，多个时间片中的相应线程在CPU内轮流执行。</p></li></ul><ol start="3"><li>多线程应用场景</li></ol><ul><li><p>VNC同时共享屏幕给多个电脑</p></li><li><p>迅雷开启多条线程一起下载</p></li><li><p>QQ同时和多个人一起视频</p></li><li><p>服务器同时处理多个客户端请求</p></li></ul><ol start="4"><li>并行和并发</li></ol><ul><li><p>并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)</p></li><li><p>并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于间时间隔较短，使人感觉两个任务都在运行</p></li></ul><ol start="5"><li>Java程序运行原理</li></ol><ul><li><p>Java命令会启动java虚拟机(JVM)，等于启动了一个应用程序，也就是启动了一个进程。</p></li><li><p>该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法</p></li><li><p>一个应用程序有且只有一个主线程,程序员不能New主线程，可以New子线程。</p></li></ul><ol start="6"><li>思考：JVM启动的是多线程吗？</li></ol><ul><li>JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的</li></ul></li></ul><h5 id="2-线程的创建"><a href="#2-线程的创建" class="headerlink" title="2. 线程的创建"></a>2. 线程的创建</h5><p>每个Java程序启动后，虚拟机将自动创建一个主线程,可以通过以下两种(其实有三种)方式自定义线程类：</p><p><strong>方式一:继承Thread类</strong><br>实现步骤：</p><p>1.定义类继承Thread类</p><p>2.重写run方法</p><p>3.把新线程要做的事写在run方法中</p><p>4.创建线程对象</p><p>5.开启新线程, 内部会自动执行run方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*主线程，程序员不能创建，程序员只能创建子线程*/</span>                 <span class="token comment">//1.创建子线程对象</span>        <span class="token class-name">MyThread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.启动子线程</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>方式二:实现Runnable接口</strong><br>实现步骤：</p><p>1.定义类实现Runnable接口</p><p>2.实现run方法</p><p>3.把新线程要做的事写在run方法中</p><p>4.创建自定义的Runnable的子类对象,创建Thread对象传入Runnable</p><p>5.调用start()开启新线程, 内部会自动调用Runnable的run()方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span>  <span class="token class-name">MyThread</span>  <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/*  线程实现的方式 (2) - 定义类实现Runnable接口*/</span>        <span class="token comment">//1.创建runable对象</span>        <span class="token class-name">MyThread</span>  task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span>  <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//2.创建Thread对象</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//3.启动线程</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>两种实现方式的对比分析</p><p>   继承Thread : 由于子类重写了Thread类的run(), 当调用start()时直接找子类的run()方法</p><p>   实现Runnable : 构造函数中传入了Runnable的引用, 有个成员变量记住了它, 调用run()方法时内部判断成员变量Runnable的引用是否为空。</p><p><strong>继承Thread</strong></p><p>好处是:可以直接使用Thread类中的方法,代码简单</p><p>弊端是:如果已经有了父类,就不能用这种方法</p><p><strong>实现Runnable接口</strong></p><p>好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,代码更灵活</p><p>弊端是:不能直接使用Thread中的方法,需要先获取到线程对象后,才能得到Thread的方法,代码复杂</p><h5 id="3-匿名内部类实现线程的两种方式"><a href="#3-匿名内部类实现线程的两种方式" class="headerlink" title="3.匿名内部类实现线程的两种方式"></a>3.匿名内部类实现线程的两种方式</h5><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务1...."</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务2...."</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><h5 id="4-线程的常用方法"><a href="#4-线程的常用方法" class="headerlink" title="4. 线程的常用方法"></a>4. 线程的常用方法</h5><pre><code>  1. 获取当前线程的对象     * currentThread()方法用于获取当前线程对象     * 在不同的方法中，获取的线程对象名称是有可能不一样的     * 在main中获取的是主线程对象     * 在子线程的run方法中获取的是子线程对象</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取当前线程的对象(掌握)</span>        <span class="token class-name">Thread</span> mainThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mainThread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"主线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//打印主线程对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mainThread<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//打印主线程对象类名</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mainThread<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启子线程</span>        <span class="token class-name">MyThread</span> mt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mt<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> subThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//打印子线程对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//打印子线程对象类名</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subThread<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre><code>2. 获取线程名字和设置名字</code></pre><ul><li>通过Thread的getName()方法获取线程对象的名字</li><li>通过setName(String)方法可以设置线程对象的名字</li><li>通过构造函数可以传入String类型的名字</li><li>每个线程系统都会默认分配个名字,主线程：main,子线程thread-0 ….</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/*      获取线程名字和设置名字(掌握)*/</span>        <span class="token comment">//1.获取主线程对象</span>        <span class="token class-name">Thread</span> mainThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mainThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"名称:"</span> <span class="token operator">+</span> mainThread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//2.设置线程的名称</span>        mainThread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"主线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mainThread<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//3.设置子线程的名称</span>        <span class="token class-name">MyThread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"子线程1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>         <span class="token keyword">public</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"银行代发工资任务..."</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre><code>3. 线程休眠</code></pre><ul><li>Thread.sleep(毫秒), 控制当前线程休眠若干毫秒</li><li>1秒&#x3D; 1000毫秒</li><li>1秒 &#x3D; 1000毫秒* 1000微妙 * 1000纳秒（1000000000 ）</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//休眠【暂停】</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//主线程休眠</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AAAAAAAAAAAAAAAAAA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><ol start="4"><li><p>守护线程</p><ul><li><p>setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出.</p></li><li><p>特点：男守护女，女的死，男的也不想活了</p></li></ul></li><li><p>加入线程</p><ul><li>join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续</li></ul></li></ol><ul><li>join(int), 可以等待指定的毫秒之后继续</li></ul><ol start="6"><li><p>线程让出</p><ul><li>yield() 让出cpu</li></ul></li><li><p>线程优先级</p><ul><li><p>setPriority()设置线程的优先级</p></li><li><p>默认优先级是5，最小优先级1，最高优先级10</p></li><li><p>可以设置2，3，4</p></li><li><p>Thread里面有静态常量</p></li></ul></li></ol><h5 id="5-线程的生命周期及状态转换"><a href="#5-线程的生命周期及状态转换" class="headerlink" title="5. 线程的生命周期及状态转换"></a>5. 线程的生命周期及状态转换</h5><p><strong>线程的生命周期</strong></p><ul><li><p>指线程从创建到启动，直至运行结束</p></li><li><p>可以通过调用 Thread 类的相关方法影响线程的运行状态</p></li></ul><p><strong>线程的运行状态</strong></p><ul><li><p>新建（New）</p></li><li><p>可执行（Runnable）</p></li><li><p>运行（Running)</p></li><li><p>阻塞（Blocking)</p></li><li><p>死亡（Dead)<br><img src="http://cdn.leafii.top/img/20220520164813.png" loading="lazy"><br><strong>新建状态（New)</strong></p></li><li><p>当创建了一个Thread对象时，该对象就处于“新建状态”,没有启动，因此无法运行</p></li></ul><p><strong>可执行状态（Runnable）</strong></p><ul><li><p>其他线程调用了处于新建状态线程的start方法，该线程对象将转换到“可执行状态”</p></li><li><p>线程拥有获得CPU控制权的机会，处在等待调度阶段。</p></li></ul><p><strong>运行状态（Running）</strong></p><ul><li><p>处在“可执行状态”的线程对象一旦获得了 CPU 控制权，就会转换到“执行状态”</p></li><li><p>在“执行状态”下，线程状态占用 CPU 时间片段，执行run 方法中的代码</p></li><li><p>处在“执行状态”下的线程可以调用 yield 方法，该方法用于主动出让 CPU 控制权。线程对象出让控制权后回到“可执行状态”，重新等待调度。</p></li></ul><p><strong>阻塞状态（Blocking）</strong></p><ul><li><p>线程在“执行状态”下由于受某种条件的影响会被迫出让CPU控制权，进入“阻塞状态”。</p></li><li><p>进入阻塞状态的三种情况</p></li><li><p>调用sleep方法</p></li><li><p>调用join方法</p></li><li><p>执行I&#x2F;O操作</p></li></ul><p>**死亡状态（Dead）</p><ul><li><p>处于“执行状态”的线程一旦从run方法返回（无论是正常退出还是抛出异常），就会进入“死亡状态”。</p></li><li><p>已经“死亡”的线程不能重新运行，否则会抛出IllegalThreadStateException</p></li><li><p>可以使用 Thread 类的 isAlive 方法判断线程是否活着</p></li></ul><h5 id="6-线程与同步"><a href="#6-线程与同步" class="headerlink" title="6.线程与同步"></a>6.线程与同步</h5><ol><li>什么是同步</li></ol><ul><li><p>是多个线程同时访问同一资源时，需等待某个线程对资源访问结束，下个线程才能进行访问,浪费时间，效率低,但是可以保证数据安全.</p></li><li><p>同步就是加锁，不让其它人访问,synchronized指的就是同步的意思.</p></li></ul><ol start="2"><li>什么情况下需要同步</li></ol><ul><li>当多线程并发, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步,否则会有线程安全问题.</li></ul><ol start="3"><li>同步代码块</li></ol><ul><li><p>使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块</p></li><li><p>多个同步代码块如果使用相同的锁对象, 那么他们就是同步的</p></li><li><p>使用同步锁时，应该尽是让锁的范围小点，才能提高性能</p></li></ul><ol start="4"><li>同步方法</li></ol><ul><li><p>使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的</p></li><li><p>非静态同步方法的锁是:this</p></li><li><p>静态同步方法的锁是:字节码对象(xx.class)</p></li></ul><h5 id="案例：卖火车票"><a href="#案例：卖火车票" class="headerlink" title="案例：卖火车票"></a>案例：卖火车票</h5><p>需求，有A、B、C、D 4个窗口同时间买票，只有100张票可以买</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ticket</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"不好意思票卖完了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"恭喜你买到票，票号："</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>锁的总结:</strong></p><ul><li><p>同步代码块使用的锁可以是任意对象的。因为synchronized中的对象可以我们自己指定。</p></li><li><p>同步函数使用的锁是固定的this。当线程任务只需要一个同步时完全可以使用同步函数。</p></li><li><p>同步代码块使用的锁可以是任意对象。当线程任务中需要多个同步时，必须通过锁来区分，这时必须使用同步代码块。同步代码块较为常用。</p></li><li><p>静态方法是随着类的加载而加载，静态同步函数使用的锁是字节码class文件对象。</p></li></ul><p><strong>回顾线程安全的类:</strong></p><ul><li><p>Vector,StringBuffer,Hashtable</p></li><li><p>Vector是线程安全的,ArrayList是线程不安全的</p></li><li><p>StringBuffer是线程安全的,StringBuilder是线程不安全的</p></li><li><p>Hashtable是线程安全的,HashMap是线程不安全的</p></li></ul><h5 id="7-单例模式"><a href="#7-单例模式" class="headerlink" title="7.单例模式"></a>7.单例模式</h5><p>单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。</p><p>实现步骤:</p><pre><code>第一步:将类的构造函数申明为私有;第二步:在类中初始化一个类;第三步:对外提供访问该类的公开方法,并返回第二步中实例化的类;</code></pre><ol><li>饿汉式</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Single</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Single</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">private</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Single</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="2"><li>懒汉式</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Single</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span>  <span class="token class-name">Single</span> s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token class-name">Single</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>解决单例懒汉式的并发问题</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Single</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span>  <span class="token class-name">Single</span> s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">/*    并发访问会有安全隐患，所以加入同步机制解决安全问题。    但是，同步的出现降低了效率。    可以通过双重判断的方式，解决效率问题，减少判断锁的次数。    */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token class-name">Single</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Single</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>            <span class="token comment">//注意这里synchronized关键字之后的静态同步函数使用的锁是字节码class文件对象。</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span>                    s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>1).死锁的概念</p><p>   死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p>2).死锁的理解</p><p>   在一条河上有一座桥，桥面较窄，只能容纳一辆汽车通过，无法让两辆汽车并行。如果有两辆汽车A和B分别由桥的两端驶上该桥，则对于A车来说，它走过桥面左面的一段路（即占有了桥的一部分资源），要想过桥还须等待B车让出右边的桥面，此时A车不能前进；对于B车来说，它走过桥面右边的一段路（即占有了桥的一部分资源），要想过桥还须等待A车让出左边的桥面，此时B车也不能前进。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那麽上述问题就描述为：进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。</p><p>3).产生死锁的必要条件</p><ul><li><p>〈1〉互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。</p></li><li><p>〈2〉不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。</p></li><li><p>〈3〉占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。</p></li><li><p>〈4〉循环等待条件。存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。</p></li></ul><p>4).死锁演示</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> lockA <span class="token operator">=</span> <span class="token string">"A"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> lockB <span class="token operator">=</span> <span class="token string">"B"</span><span class="token punctuation">;</span>    <span class="token comment">//死锁</span>    <span class="token comment">//当第一个线程拿到lockB，第二个线程拿到lockA，两个线程都不能继续执行 导致死锁</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A-------A-------A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B--------A------------B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B---------B-----------B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A--------B------A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaの集合</title>
      <link href="/2020/04/07/Java%E3%81%AE%E9%9B%86%E5%90%88/"/>
      <url>/2020/04/07/Java%E3%81%AE%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Javaの集合"><a href="#Javaの集合" class="headerlink" title="Javaの集合"></a>Javaの集合</h1><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><img src="http://cdn.leafii.top/img/20220520164533.png" loading="lazy"><br><img src="http://cdn.leafii.top/img/20220520164552.png" loading="lazy"></p><h5 id="1-集合概述"><a href="#1-集合概述" class="headerlink" title="1. 集合概述"></a>1. 集合概述</h5><ul><li>Java 集合就像一种容器，可以把多个对象的引用放入容器中。</li></ul><span id="more"></span><ul><li>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组</li><li>Java 集合可分为 Set、List 和 Map 三种体系</li><li>Set：无序、不可重复的集合</li><li>List：有序，可重复的集合</li><li>Map：具有映射关系的集合</li><li>在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 Java5 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。<br><img src="http://cdn.leafii.top/img/20220520164616.png" loading="lazy"></li></ul><h5 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2. Collection接口"></a>2. Collection接口</h5><ul><li>Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合：</li></ul><p><img src="http://cdn.leafii.top/img/20220520164628.png" loading="lazy"></p><h5 id="3-List接口"><a href="#3-List接口" class="headerlink" title="3. List接口"></a>3. List接口</h5><pre><code>  1. List接口简介</code></pre><ul><li><p>List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，</p></li><li><p>同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><ol start="2"><li>ArrayList集合</li></ol></li><li><p>ArrayList内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。</p></li><li><p>当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高（ArrayList在内存不够时默认是扩展50% + 1个）。因此，它适合随机查找和遍历，不适合插入和删除。</p></li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test3</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span> <span class="token punctuation">></span></span> list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//追加到末尾</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"12311"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"12322"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//1.for</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//2.foreach</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token operator">:</span>list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//3.迭代器</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"============="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*while (true)&#123;            boolean b = it.hasNext();            if(!b)&#123;                break;            &#125;            System.out.println(it.next());        &#125;*/</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre><code>3. LinkedList集合</code></pre><ul><li>LinkedList是用双向链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</li></ul><pre><code>4. Vector集合</code></pre><ul><li>Vector集合底层数据结构是数组实现的，其操作和ArrayList一致，查询快，增删慢，但是其内部是线程安全，效率低。</li></ul><pre><code>5. Itrator接口</code></pre><ul><li><p>Iterator 接口主要用于遍历 Collection 集合中的元素，Iterator 对象也被称为迭代器</p></li><li><p>Iterator 接口隐藏了各种 Collection 实现类的底层细节，向应用程序提供了遍历 Collection 集合元素的统一编程接口</p></li><li><p>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。<img src="http://cdn.leafii.top/img/20220520164653.png" loading="lazy"></p></li></ul><pre><code>6. ArrayList和LinkedList的区别如下:</code></pre><ul><li><p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</p></li><li><p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p></li><li><p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p></li></ul><h4 id="自己写一个集合类"><a href="#自己写一个集合类" class="headerlink" title="自己写一个集合类"></a>自己写一个集合类</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MyArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        arr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            size <span class="token operator">=</span> size <span class="token operator">+</span> size<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newarr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>newarr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            newarr<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            arr <span class="token operator">=</span> newarr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            size <span class="token operator">=</span> size <span class="token operator">+</span> size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newarr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>newarr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        newarr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>index<span class="token punctuation">,</span>newarr<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>count <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        arr <span class="token operator">=</span> newarr<span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        arr <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">;</span>        <span class="token keyword">return</span> newArr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> isContains <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                isContains <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                isContains <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> isContains<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        size <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newarr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>newarr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>newarr<span class="token punctuation">,</span>index<span class="token punctuation">,</span>count<span class="token operator">-</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//            System.arraycopy(arr,index,newarr,index+1,count - index);</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>            arr <span class="token operator">=</span> newarr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未找到元素，删除失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"["</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            size <span class="token operator">=</span> size <span class="token operator">+</span> size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newarr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>newarr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            arr <span class="token operator">=</span> newarr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                s <span class="token operator">=</span> s <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                s <span class="token operator">=</span> s <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        s <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>1).Set接口介绍</p><p>Set是Collection子接口；</p><p>Set和Collection基本上一样，一点除外：Set无法记住添加的顺序，不允许包含重复的元素。</p><p>当试图添加两个相同元素进Set集合，添加操作失败，add()方法返回false。</p><p>Setr如何判断两个对象是否相等？HashSet 集合的add()方法底层依赖于双列集合HashMap, 它依赖于两个方法 equals()和hashCode(); 先比较元素equals(),  再比较hashCoede值.</p><p>也就是说两个对象equals比较返回true，Set集合是不会接受这个两个对象的。</p><p>常用子类：</p><p>HashSet:散列存放</p><p>TreeSet:有序存放</p><p>2).HashSet集合</p><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p><p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。</p><p>HashSet 具有以下特点：</p><p>不能保证元素的排列顺序</p><p>HashSet 不是线程安全的</p><p>集合元素可以是 null</p><p>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值决定该对象在 HashSet 中的存储位置。如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。</p><p>3).TreeSet集合</p><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</p><p>TreeSet 支持两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。</p><p>自然排序</p><p>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列</p><p>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。</p><p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。</p><p>Comparable 的典型实现：</p><p>BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</p><p>Character：按字符的 UNICODE 值来进行比较</p><p>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</p><p>String：按字符串中字符的 UNICODE 值进行比较</p><p>Date、Time：后边的时间、日期比前面的时间、日期大</p><p>自然排序步骤：</p><p>1.让元素自身具备比较性，</p><p>2.实现Compareable接口，覆盖其CompareTo方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"不是学生对象"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>       <span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">"....compareto....."</span><span class="token operator">+</span>s<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">></span>s<span class="token punctuation">.</span>age<span class="token punctuation">)</span>           <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">==</span>s<span class="token punctuation">.</span>age<span class="token punctuation">)</span>       <span class="token punctuation">&#123;</span>           <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><p>定制排序</p><p>如果需要实现定制排序，则需要在创建 TreeSet 集合对象时，提供一个 Comparator 接口的实现类对象。由该 Comparator 对象负责集合元素的排序逻辑</p><p>定制排序步骤：</p><p>   1）创建比较器,实现comparator接口</p><p>   2）复写compare方法</p><p>   3）在创建TreeSet集合对象时,提供一个一个Comparator对象</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token punctuation">&#123;</span><span class="token comment">//第一步：实现Comparator接口</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o1<span class="token punctuation">,</span> <span class="token class-name">Object</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//第二步：实现一个campare方法</span> <span class="token keyword">if</span><span class="token punctuation">(</span>o1 <span class="token keyword">instanceof</span> <span class="token class-name">Student1</span> <span class="token operator">&amp;</span> o2instanceof <span class="token class-name">Student1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token class-name">Student1</span> s1 <span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">Student1</span><span class="token punctuation">)</span>o1<span class="token punctuation">;</span>           <span class="token class-name">Student1</span> s2 <span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">Student1</span><span class="token punctuation">)</span>o2<span class="token punctuation">;</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> s2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student1</span><span class="token punctuation">></span></span> s<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token keyword">new</span>  <span class="token class-name">MyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第三步：创建TreeSet集合对象时,提供一个一个Comparator对象</span></code></pre><p><a href="https://www.cnblogs.com/chenglc/p/8073049.html">集合详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaの异常、断言、泛型、日志</title>
      <link href="/2020/04/03/Java%E3%81%AE%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E6%97%A5%E5%BF%97/"/>
      <url>/2020/04/03/Java%E3%81%AE%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Javaの异常、断言、泛型、日志"><a href="#Javaの异常、断言、泛型、日志" class="headerlink" title="Javaの异常、断言、泛型、日志"></a>Javaの异常、断言、泛型、日志</h1><h4 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h4><ol><li><p>什么是异常</p><ul><li>异常，就是不正常的意思。指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。注意：异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.<span id="more"></span></li></ul></li><li><p>异常体系</p><ul><li>异常机制其实是帮助我们找到程序中的问题，异常的根类是 java.lang.Throwable ，其下有两个子类：java.lang.Error 与 java.lang.Exception ，平常所说的异常指 java.lang.Exception 。</li></ul><p><img src="http://cdn.leafii.top/img/20220520164149.png" loading="lazy"></p><ul><li><p>Throwable体系：</p><p>Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</p><p>Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</p></li><li><p>Throwable中的常用方法：</p><p>public void printStackTrace() :打印异常的详细信息。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</p><p>public String getMessage() :获取发生异常的原因。提示给用户的时候,就提示错误原因。</p><p>public String toString() :获取异常的类型和异常描述信息(不用)。</p></li></ul></li><li><p>异常分类</p><ul><li><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p></li><li><p>异常(Exception)的分类:根据在编译时期还是运行时期去检查异常?</p></li><li><p>编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)；</p></li><li><p>运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)。</p></li></ul><p><img src="http://cdn.leafii.top/img/20220520164209.png" loading="lazy"></p><ul><li>常见异常：</li></ul><p><img src="http://cdn.leafii.top/img/20220520164223.png" loading="lazy"></p></li><li><p>异常处理</p><ol><li>抛出异常throw<br>在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？<ol><li>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</li><li>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</li></ol></li></ol></li></ol><p>代码演示：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThrowDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//创建一个数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">52</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">//根据索引找对应的元素</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> element <span class="token operator">=</span> <span class="token function">getElement</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*     * 根据 索引找到数组中对应的元素     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token comment">//判断  索引是否越界 </span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> index<span class="token operator">></span>arr<span class="token punctuation">.</span>length‐<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token comment">/*             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。              */</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"哥们，角标越界了~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> element <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>  <strong>如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。<br>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</strong></p><p>②声明异常throws<br>声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。<br>关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).<br>声明异常格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }<br>代码演示：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThrowsDemo2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token function">read</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//如果不是 a.txt这个文件</span>            <span class="token comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">(</span><span class="token string">"文件不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"b.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>③捕获异常try…catch</p><p>捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</p><p>捕获异常语法如下：</p><pre><code>    try&#123;         //编写可能会出现异常的代码    &#125;catch(异常类型  e)&#123;         处理异常的代码         //记录日志/打印异常信息/继续抛出异常    &#125;</code></pre><p>代码演示：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TryCatchDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span>            <span class="token function">read</span><span class="token punctuation">(</span><span class="token string">"b.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 括号中需要定义什么呢？</span>           <span class="token comment">//try中抛出的是什么异常，在括号中就定义什么异常类型  </span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*     *     * 我们 当前的这个方法中 有异常  有编译期异常     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//如果不是 a.txt这个文件</span>            <span class="token comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">(</span><span class="token string">"文件不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>④多个异常捕获</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">&#123;</span>     <span class="token comment">//编写可能会出现异常的代码</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token class-name">A</span>  e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  当<span class="token keyword">try</span>中出现<span class="token class-name">A</span>类型异常<span class="token punctuation">,</span>就用该<span class="token keyword">catch</span>来捕获<span class="token punctuation">.</span>     处理异常的代码     <span class="token comment">//记录日志/打印异常信息/继续抛出异常</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token class-name">B</span>  e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  当<span class="token keyword">try</span>中出现<span class="token class-name">B</span>类型异常<span class="token punctuation">,</span>就用该<span class="token keyword">catch</span>来捕获<span class="token punctuation">.</span>     处理异常的代码     <span class="token comment">//记录日志/打印异常信息/继续抛出异常</span><span class="token punctuation">&#125;</span></code></pre><p><strong>多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</strong></p><p>⑤finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。finally不能单独使用，必须和try配套使用。只有在try或者catch中调用退出JVM的相关方法时,finally才不会执行,否则finally绝对会执行。</p><pre><code>  5. 自定义异常1. 自定义一个编译期异常: 自定义类 并继承于 java.lang.Exception 。2. 自定义一个运行时期的异常类:自定义类 并继承于 java.lang.RuntimeException 。       * 演示</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 业务逻辑异常</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 空参构造     */</span>    <span class="token keyword">public</span> <span class="token class-name">LoginException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     *     * @param message 表示异常提示     */</span>    <span class="token keyword">public</span> <span class="token class-name">LoginException</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 模拟数据库中已存在账号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"bill"</span><span class="token punctuation">,</span><span class="token string">"hill"</span><span class="token punctuation">,</span><span class="token string">"jill"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//调用方法</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>              <span class="token comment">// 可能出现异常的代码</span>            <span class="token function">checkUsername</span><span class="token punctuation">(</span><span class="token string">"nill"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"注册成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果没有异常就是注册成功</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">LoginException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//处理异常</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//判断当前注册账号是否存在</span>    <span class="token comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkUsername</span><span class="token punctuation">(</span><span class="token class-name">String</span> uname<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">LoginException</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>uname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果名字在这里面 就抛出登陆异常</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LoginException</span><span class="token punctuation">(</span><span class="token string">"亲"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"已经被注册了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="2-断言"><a href="#2-断言" class="headerlink" title="2. 断言"></a>2. 断言</h4><pre><code>  1. 断言概述编写代码时,我们总是会做出一些假设,断言就是用于在代码中捕捉这些假设。可以将断言看作是异常处理的一种高级形式。断言表示为一些布尔表达式,程序员相信在程序中的某个特定点该表达式值为真。   2. 断言使用格式     1.assert 布尔表达式      2.assert 布尔表达式:消息      使用第一种格式，当布尔类型表达式为false时，抛出AssertionError异常；如果是第二种格式，则输出错误消息。</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> isOk <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">//assert isOk;</span>        <span class="token keyword">assert</span> isOk<span class="token operator">:</span><span class="token string">"1不该大于2"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序正常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre><code>   3. 断言的启用        在默认情况下idea中的断言不起作用，在idea等工具中可以开启和关闭断言功能：Run→Edit Configrations-&gt;在VM栏里输入-ea开启断言，输入-da关闭断言。</code></pre><h4 id="3-日志Logger"><a href="#3-日志Logger" class="headerlink" title="3.日志Logger"></a>3.日志Logger</h4><p>3.1 Logger<br>在Java中实现日志记录的方式有很多种，其中最简单的方式，就是System.out.print，System.err.print 这样直接在控制台打印消息了。接下来我们介绍的：java.util.logging.Logger是在JDK 1.4 版本之后加入的，提供了日志记录的API ，可以往控制台&#x2F;文件中写日志了。</p><p>Logger 对象用来记录特定系统或应用程序组件的日志消息。一般使用圆点分隔的层次名称空间来命名 Logger。Logger 名称可以是任意的字符串，但是它们一般应该基于被记录组件的包名或类名，如 java.net 或 javax.swing。此外，可以创建“匿名”的 Logger，其名称未存储在 Logger 名称空间中。</p><p>可通过调用某个 getLogger 工厂方法来获得 Logger 对象。这些方法要么创建一个新 Logger，要么返回一个合适的现有 Logger。</p><p>日志消息被转发到已注册的 Handler 对象，该对象可以将消息转发到各种目的地，包括控制台、文件、OS 日志等等。</p><p>3.2 创建Logger对象<br>static Logger getLogger(String name)  为指定子系统查找或创建一个 logger。</p><p>Logger logger1 &#x3D; Logger.getLogger(“com.suncaper.lxp.LogDemo”);</p><p><strong>注意：name是Logger的名称，当名称相同时候，同一个名称的Logger只创建一个。</strong></p><p>3.3 Logger的级别</p><table><thead><tr><th>类型</th><th>解释</th></tr></thead><tbody><tr><td>SEVERE</td><td>严重</td></tr><tr><td>WARNING</td><td>警告</td></tr><tr><td>INFO</td><td>信息</td></tr><tr><td>CONFIG</td><td>配置</td></tr><tr><td>FINE</td><td>良好</td></tr><tr><td>FINER</td><td>较好</td></tr><tr><td>FINEST</td><td>最好</td></tr><tr><td>ALL</td><td>开启所有级别的日志记录</td></tr><tr><td>OFF</td><td>关闭所有级别的日志记录</td></tr></tbody></table><p><strong>logger默认的级别是INFO，比INFO更低的日志将不显示。</strong></p><p><strong>Logger的默认级别定义是在jre安装目录的lib下面的logging.properties。</strong></p><p>可通过setLevel(Level.FINEST)方法改变级别。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Logger</span> log <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">"com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span>FINEST<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>3.4 Handler<br>Handler 对象从 Logger 中获取日志信息，并将这些信息导出。例如，它可将这些信息写入控制台或文件中，也可以将这些信息发送到网络日志服务中，或将其转发到操作系统日志中。可通过执行 setLevel(Level.OFF) 来禁用 Handler，并可通过执行适当级别的 setLevel 来重新启用。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//将日志打印至控制台</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">"com.suncaper.test.LogDemo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span>ALL<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ConsoleHandler</span> consoleHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConsoleHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consoleHandler<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span>FINEST<span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>consoleHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>         logger<span class="token punctuation">.</span><span class="token function">severe</span><span class="token punctuation">(</span><span class="token string">"严重"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">"警告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"信息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token string">"配置"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">fine</span><span class="token punctuation">(</span><span class="token string">"良好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">finer</span><span class="token punctuation">(</span><span class="token string">"较好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">finest</span><span class="token punctuation">(</span><span class="token string">"最好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//将日志写入文本</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Logger</span> log <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">"com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Logger</span> log1 <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">"com.suncaper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ConsoleHandler</span> consoleHandler <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConsoleHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consoleHandler<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span>ALL<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>consoleHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileHandler</span> fileHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileHandler</span><span class="token punctuation">(</span><span class="token string">"d://testlog.log"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fileHandler<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>fileHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log1<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log1<span class="token punctuation">.</span><span class="token function">fine</span><span class="token punctuation">(</span><span class="token string">"333"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>默认的日志方式是xml格式，很烂。所以最好自定义下logger的格式。需要用Formatter来定义。</strong></p><p>3.5 Formatter<br>Formatter 为格式化 LogRecords 提供支持。</p><p>一般来说，每个日志记录 Handler 都有关联的 Formatter。Formatter 接受 LogRecord，并将它转换为一个字符串。默认设置即为：fileHandler.setFormatter(new XMLFormatter());可通过fileHandler.setFormatter(new SimpleFormatter())来修改日志记录的信息。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//将日志格式化写入文本</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Logger</span> log <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">"com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Logger</span> log1 <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">"com.suncaper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ConsoleHandler</span> consoleHandler <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConsoleHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consoleHandler<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span>ALL<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>consoleHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileHandler</span> fileHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileHandler</span><span class="token punctuation">(</span><span class="token string">"d://testlog.log"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fileHandler<span class="token punctuation">.</span><span class="token function">setFormatter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fileHandler<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>fileHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log1<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log1<span class="token punctuation">.</span><span class="token function">fine</span><span class="token punctuation">(</span><span class="token string">"333"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4.泛型"></a>4.泛型</h4><ol><li>泛型概述<ul><li>泛型：就是一种不确定的数据类型。</li></ul></li><li>反省的使用<ol><li>定义和使用含有泛型的类<ul><li>格式：修饰符calss 类名&lt;代表泛型的变量&gt; {}</li></ul></li><li>含有泛型的方法<ul><li>格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }</li><li>演示：</li></ul></li></ol></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token comment">//定义泛型类</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setT</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span>  <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span> <span class="token class-name">K</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">K</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//泛型方法1</span>        <span class="token keyword">return</span> k<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span>  <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span> <span class="token keyword">void</span> <span class="token function">hello1</span><span class="token punctuation">(</span><span class="token class-name">K</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//泛型方法2</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"泛型方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">setT</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用方法时，确定泛型的类型</span>        p<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre><code>3. 含有泛型的接口    格式：修饰符 interface 接口名 &lt;代表泛型的变量&gt;&#123;&#125;    1.定义子类时确定泛型的类型</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token comment">//定义泛型接口A</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">implements</span> <span class="token class-name">A</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token comment">//定义子类B实现泛型接口A</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span><span class="token comment">//测试类</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">B</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>   2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token comment">//定义泛型接口A</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">A</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span><span class="token comment">//测试类</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">B</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>泛型通配符<ul><li>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。</li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">setT</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ff2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ff2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">ff2</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> person<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>在泛型中可以指定一个泛型的上限和下限。</p><p>泛型的上限：</p><p>格式： 类型名称 &lt;? extends 类 &gt; 对象名称</p><p>意义： 只能接收该类型及其子类</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">setT</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ff1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ff1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报错</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">ff1</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span>  <span class="token class-name">String</span><span class="token punctuation">></span></span> person<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre><code>泛型的下限：格式： 类型名称 &lt;? super 类 &gt; 对象名称意义： 只能接收该类型及其父类型</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">setT</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ff</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ff</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报错</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">ff</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span>  <span class="token class-name">String</span><span class="token punctuation">></span></span> person<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>1.编写一个泛型方法，实现任意引用类型数组指定位置元素交换。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">T</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><p>2.编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">turnOver</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">T</span> temp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>j <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><p>3.定义方法,遍历传递过来的任意引用类型数组。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><p>练习一：异常的体系<br>问题：</p><ol><li>请描述异常的继承体系<ul><li>Throwable类是所有异常类的根类，所有的异常类都是由它继承<br>Exception类是程序员可以根据问题描述可以处理的<br>在Exception类中可以分为运行时异常和编译时异常，<br>编译时异常必须处理否则无法运行，<br>运行时异常就是编译通过，在运行时发生的异常<br>运行时异常在发生时会退出当前的方法</li></ul></li><li>请描述你对错误(Error)的理解<ul><li>Error：是严重错误，无法通过处理的错误，只能事先避免，不然的话程序无法运行<br>从Java设计的角度来讲，程序基本不可以通过后续代码修复，从而理应终止。当然，<br>从语法上来讲，所有这些都可以被写进catch里面，但是Error因为上述原因，不应该被代码处理。</li></ul></li><li>请描述你对异常(Expection的理解)<ul><li>从本质上来讲，java异常是一个java对象(继承Object)，和一般的java对象一样，封装了一些成员变量和操作，我们可以向操作一般java对象那样去操作java异常对象(我还特地去试了试可不可以使用throw关键字操作一般的java对象，发现编译错误，证明它仅仅是操作异常类的语法)</li><li>从代表的含义上来说：java异常是一种错误情况，是程序不希望出现的现象，但是由于程序本身的设计逻辑和运行的环境等因素，出现异常的情况不可避免，java虚拟机针对不同的异常情况定义了很多异常类，当jvm运行程序发现对应的异常时，将会向外面抛出异常</li></ul></li><li>请描述你对运行时异常(RuntimeException)的理解<ul><li>运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)。<br>该异常在编译通过之后运行程序时产生，运行时异常是不需要捕获的，程序员可以不去处理，当异常出现时，虚拟机会处理。常见的运行时异常有空指针异常。</li></ul></li></ol><p>练习二：throw与throws的区别<br>问题：<br>请描述throw的使用位置,作用是什么?<br>    * throw的使用位置是在方法体内部，用于抛出异常。当方法<br>    在执行过程中遇到异常情况时，将异常信息封装为异常对象，<br>    然后throw</p><p>请描述throws的使用位置,作用是什么?<br>    * throws出现在方法的声明中，表示该方法可能能会抛出的异<br>    常，允许throws后面跟着多个异常类型<br>练习三：异常的处理方式<br>问题：</p><ol><li><p>异常处理方式有几种,分别是什么?<br>共有五种：</p><ul><li><p>抛出异常throw，在方法体内部使用throw关键字抛出指定的异常对象</p></li><li><p>声明异常throws</p><ul><li>在方法头部使用throws告知编译器此方法可能会抛出的异常</li><li>如果方法内通过throw抛出了编译时异常，而没有捕获处理<br>，那么必须通过throws进行声明，让调用者去处理。</li><li>声明异常格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }</li></ul></li><li><p>捕获异常try…catch</p><ul><li>捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul></li><li><p>多个异常捕获</p><ul><li>使用多个try…catch对异常进行捕获</li></ul></li><li><p>finally代码块</p><ul><li>有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些<br>语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。<br>finally不能单独使用，必须和try配套使用。</li><li>只有在try或者catch中调用退出JVM的相关方法时,finally才不会执行,否则finally绝对会执行。</li></ul></li></ul></li><li><p>详细阐述每种方式对异常是如何处理的</p><ul><li>throw方式：<ul><li>如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是<br>将问题返回给该方法的调用者。</li><li>先封装一些提示信息 再将异常告知程序的使用者</li></ul></li></ul><p>例：</p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThrowDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//创建一个数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">52</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">//根据索引找对应的元素</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> element <span class="token operator">=</span> <span class="token function">getElement</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*     * 根据 索引找到数组中对应的元素     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token comment">//判断  索引是否越界</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> index<span class="token operator">></span>arr<span class="token punctuation">.</span>length‐<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token comment">/*             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。              */</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"哥们，角标越界了~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> element <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>throws方式</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThrowsDemo2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token function">read</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//如果不是 a.txt这个文件</span>            <span class="token comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">(</span><span class="token string">"文件不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"b.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>捕获异常语法如下：</li></ul><pre class="language-none"><code class="language-none">try&#123;     &#x2F;&#x2F;编写可能会出现异常的代码&#125;catch(异常类型  e)&#123;     处理异常的代码     &#x2F;&#x2F;记录日志&#x2F;打印异常信息&#x2F;继续抛出异常&#125;</code></pre><p>   例：</p><pre class="language-none"><code class="language-none">public class TryCatchDemo &#123;    public static void main(String[] args) &#123;        try &#123;&#x2F;&#x2F; 当产生异常时，必须有处理方式。要么捕获，要么声明。            read(&quot;b.txt&quot;);        &#125; catch (FileNotFoundException e) &#123;&#x2F;&#x2F; 括号中需要定义什么呢？           &#x2F;&#x2F;try中抛出的是什么异常，在括号中就定义什么异常类型              System.out.println(e);        &#125;        System.out.println(&quot;over&quot;);    &#125;    &#x2F;*     *     * 我们 当前的这个方法中 有异常  有编译期异常     *&#x2F;    public static void read(String path) throws FileNotFoundException &#123;        if (!path.equals(&quot;a.txt&quot;)) &#123;&#x2F;&#x2F;如果不是 a.txt这个文件            &#x2F;&#x2F; 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw            throw new FileNotFoundException(&quot;文件不存在&quot;);        &#125;    &#125;&#125;</code></pre><ul><li>多个异常捕获实例</li></ul><pre class="language-none"><code class="language-none">try&#123;     &#x2F;&#x2F;编写可能会出现异常的代码&#125;catch(异常类型A  e)&#123;  当try中出现A类型异常,就用该catch来捕获.     处理异常的代码     &#x2F;&#x2F;记录日志&#x2F;打印异常信息&#x2F;继续抛出异常&#125;catch(异常类型B  e)&#123;  当try中出现B类型异常,就用该catch来捕获.     处理异常的代码     &#x2F;&#x2F;记录日志&#x2F;打印异常信息&#x2F;继续抛出异常&#125;finally&#123;    &#x2F;&#x2F;最后执行的代码&#125;</code></pre><p>练习四：常见异常，及产生原因<br>问题：请列举常见异常7个，并说明产生原因。<br>答：</p><pre><code>  1. java.lang.nullpointerexception               空指针异常 简单地说就是调用了未经过初始化的对象或     者是不存在的对象，常出现在创建图片，调用数组这些操作中。  2. java.lang.arithmeticexception               这个异常就是数学运算异常，比如程序中出现了除以0的     这种运算  3. java.lang.arrayindexoutofboundsexception       这个异常就是数组下标越界，在调用数组时使用了比数     组本身大小更大的下标。  4. SQLException     操作数据库异常，这个异常是因为操作数据库异常，一般是数据库的操作不当导致的  5. FileNotFoundException     文件未找到异常，一般发生于文件操作时找不到目标路径的文件  6. java.lang.AbstractMethodError     抽象方法错误。当应用试图调用抽象方法时抛出。  7. java.lang.AssertionError     断言错。用来指示一个断言失败的情况</code></pre><p>   具体请见<a href="https://blog.csdn.net/yangzhengjianglove/article/details/81233784">https://blog.csdn.net/yangzhengjianglove/article/details/81233784</a>        </p><p>练习五：自定义异常类<br>问题：<br>请使用代码实现每一个学生(Student)都有学号,姓名和分数,分数永远不能为负数如果老师给学生赋值一个负数,抛出一个自定异常</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo5</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//请使用代码实现</span>    <span class="token comment">//每一个学生(Student)都有学号,姓名和分数,分数永远不能为负数</span>    <span class="token comment">//如果老师给学生赋值一个负数,抛出一个自定异常</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token function">checkStudentScore</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MyFirstException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkStudentScore</span><span class="token punctuation">(</span><span class="token class-name">Student</span> student<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MyFirstException</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请输入学生的姓名"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入学生的学号"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入学生的分数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setScore</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyFirstException</span><span class="token punctuation">(</span><span class="token string">"分数能为负值吗？憨憨？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> score<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setScore</span><span class="token punctuation">(</span><span class="token keyword">int</span> score<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>​<br>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaの部分常用类</title>
      <link href="/2020/04/03/Java%E3%81%AE%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2020/04/03/Java%E3%81%AE%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Javaの部分常用类"><a href="#Javaの部分常用类" class="headerlink" title="Javaの部分常用类"></a>Javaの部分常用类</h1><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ol><li>equals方法在Object对象中的源码就是return(this&#x3D;&#x3D;obj)</li><li>基本数值类型不能调用方法所以不能使用equals进行比较</li><li>没有重写equals方法，&#x3D;&#x3D;与equals方法没有区别</li><li>&#x3D;&#x3D;一般用于基本数据类型比较，如果用于比较引用数据类型，就比较地址值</li><li>多使用ctrl+鼠标左键查看源代码<span id="more"></span></li></ol><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="1-String类"><a href="#1-String类" class="headerlink" title="1. String类"></a>1. String类</h4><ol><li>String看源码 发现String是无法修改的</li><li>String的构造方法<ul><li>无参构造 构造出值为””的字符串 （不是null）</li><li>可以用字节数组构造String</li><li>可以用String的getBytes将String转为字节数组</li><li>可以用字符数组构造String</li><li>可以用String的toCharArray方法将其转换为字符数组</li></ul></li><li>String的常用方法<ol><li>public boolean equals(Object obj):                              比较字符串的内容是否相同,区分大小写</li><li>public boolean equalsIgnoreCase(String str):              比较字符串的内容是否相同,忽略大小写</li><li>public boolean contains(String str):                            判断字符串中是否包含传递进来的字符串</li><li>public boolean startsWith(String str):                         判断字符串是否以传递进来的字符串开头</li><li>public boolean endsWith(String str):                          判断字符串是否以传递进来的字符串结尾</li><li>public boolean isEmpty():                                           判断字符串的内容是否为空。</li><li>public int length():                                                      获取字符串的长度。</li><li>public char charAt(int index):                                      获取指定索引位置的字符</li><li>public int indexOf(int ch):                                            返回指定字符在此字符串中第一次出现处的索引。</li><li>public int indexOf(String str):                                       返回指定字符串在此字符串中第一次出现处的索引。</li><li>public int indexOf(int ch,int fromIndex):                       返回指定字符在此字符串中从指定位置后第一次出现处的索引。</li><li>public int indexOf(String str,int fromIndex):                 返回指定字符串在此字符串中从指定位置后第一次出现处的索引。</li><li>public String substring(int start):                                 从指定位置开始截取字符串,默认到末尾。</li><li>public String substring(int start,int end):                     从指定位置开始到指定位置结束截取字符串。</li><li>public String replace(char old,char new)                      将指定字符进行替换</li><li>public String replace(String old,String new)                 将指定字符串进行替换</li><li>public String trim()                                                     去除两端空格</li><li>public String split(String regex)                                将此字符串分割为给定的 regular expression的匹配。返回String[]</li></ol></li></ol><p> <strong>注意:“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”</strong></p><p><strong>数组有length属性，String有length方法</strong></p><ol start="4"><li>字符串常量池<br>我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。</li><li>String类的深度理解<br>例1：</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 采用字面值的方式赋值 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> str1<span class="token operator">=</span><span class="token string">"aaa"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> str2<span class="token operator">=</span><span class="token string">"aaa"</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===========test1============"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true 可以看出str1跟str2是指向同一个对象</span><span class="token punctuation">&#125;</span></code></pre><ul><li>分析：当执行String str1&#x3D;”aaa”时，JVM首先会去字符串池中查找是否存在”aaa”这个对象，如果不存在，则在字符串池中创建”aaa”这个对象，然后将池中”aaa”这个对象的引用地址返回给字符串常量str1，这样str1会指向池中”aaa”这个字符串对象；如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。当创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象，也就是说str1和str2指向了同一个对象，因此语句System.out.println(str1 &#x3D;&#x3D; str2)输出：true。<br>例2：</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 采用new关键字新建一个字符串对象 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> str3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> str4<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===========test2============"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3<span class="token operator">==</span>str4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false 可以看出用new的方式是生成不同的对象</span><span class="token punctuation">&#125;</span></code></pre><ul><li>分析： 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象，如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象；如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。当执行String str4&#x3D;new String(“aaa”)时， 因为采用new关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str3和str4指向的是两个不同的对象，因此语句System.out.println(str3 &#x3D;&#x3D; str4)输出：false。<br>例3：</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 编译期确定 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> s0<span class="token operator">=</span><span class="token string">"helloworld"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s1<span class="token operator">=</span><span class="token string">"helloworld"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s2<span class="token operator">=</span><span class="token string">"hello"</span><span class="token operator">+</span><span class="token string">"world"</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===========test3============"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s0<span class="token operator">==</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true 可以看出s0跟s1是指向同一个对象</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s0<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true 可以看出s0跟s2是指向同一个对象</span><span class="token punctuation">&#125;</span></code></pre><ul><li>分析：因为例子中的s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以s0&#x3D;&#x3D;s1为true；而”hello”和”world”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用。所以我们得出s0&#x3D;&#x3D;s1&#x3D;&#x3D;s2。<br>例4：</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 编译期无法确定 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> s0<span class="token operator">=</span><span class="token string">"helloworld"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"helloworld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s2<span class="token operator">=</span><span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===========test4============"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s0<span class="token operator">==</span>s1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false </span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s0<span class="token operator">==</span>s2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> s1<span class="token operator">==</span>s2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span><span class="token punctuation">&#125;</span></code></pre><ul><li>分析：用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。s0还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用。<br>例5：</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 继续-编译期无法确定 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> str1<span class="token operator">=</span><span class="token string">"abc"</span><span class="token punctuation">;</span>      <span class="token class-name">String</span> str2<span class="token operator">=</span><span class="token string">"def"</span><span class="token punctuation">;</span>      <span class="token class-name">String</span> str3<span class="token operator">=</span>str1<span class="token operator">+</span>str2<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===========test5============"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3<span class="token operator">==</span><span class="token string">"abcdef"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span><span class="token punctuation">&#125;</span></code></pre><ul><li>分析：因为str3指向堆中的”abcdef”对象，而”abcdef”是字符串池中的对象，所以结果为false。JVM对String str&#x3D;”abc”对象放在常量池中是在编译时做的，而String str3&#x3D;str1+str2是在运行时刻才能知道的。new对象也是在运行时才做的。而这段代码总共创建了5个对象，字符串池中两个、堆中三个。+运算符会在堆中建立来两个String对象，这两个对象的值分别是”abc”和”def”，也就是说从字符串池中复制这两个值，然后在堆中创建两个对象，然后再建立对象str3,然后将”abcdef”的堆地址赋给str3。<br>例6：</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 编译期优化 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> s0 <span class="token operator">=</span> <span class="token string">"a1"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===========test6============"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s0 <span class="token operator">==</span> s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//result = true </span>    <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"atrue"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s3<span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"true"</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s2 <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//result = true </span>    <span class="token class-name">String</span> s4 <span class="token operator">=</span> <span class="token string">"a3.4"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s5 <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token number">3.4</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//result = true</span><span class="token punctuation">&#125;</span></code></pre><ul><li>分析：在程序编译期，JVM就将常量字符串的”+”连接优化为连接后的值，拿”a” + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。<br>例7：</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 编译期无法确定 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> s0 <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> s1<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===========test7============"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s0 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//result = false</span><span class="token punctuation">&#125;</span></code></pre><ul><li>分析：JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即”a” + s1无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给s2。所以上面程序的结果也就为false。<br>例8：</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 比较字符串常量的“+”和字符串引用的“+”的区别 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> test<span class="token operator">=</span><span class="token string">"javalanguagespecification"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">"java"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> str1<span class="token operator">=</span><span class="token string">"language"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> str2<span class="token operator">=</span><span class="token string">"specification"</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===========test8============"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test <span class="token operator">==</span> <span class="token string">"java"</span> <span class="token operator">+</span> <span class="token string">"language"</span> <span class="token operator">+</span> <span class="token string">"specification"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test <span class="token operator">==</span> str <span class="token operator">+</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span class="token punctuation">&#125;</span></code></pre><ul><li>分析：为什么出现上面的结果呢？这是因为，字符串字面量拼接操作是在Java编译器编译期间就执行了，也就是说编译器编译时，直接把”java”、”language”和”specification”这三个字面量进行”+”操作得到一个”javalanguagespecification” 常量，并且直接将这个常量放入字符串池中，这样做实际上是一种优化，将3个字面量合成一个，避免了创建多余的字符串对象。而字符串引用的”+”运算是在Java运行期间执行的，即str + str2 + str3在程序执行期间才会进行计算，它会在堆内存中重新创建一个拼接后的字符串对象。总结来说就是：字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中；而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如”I”+”love”+”java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。</li></ul><h5 id="记录一个字符在字符串中出现的次数"><a href="#记录一个字符在字符串中出现的次数" class="headerlink" title="记录一个字符在字符串中出现的次数"></a>记录一个字符在字符串中出现的次数</h5><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请输入第一个字符串:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> s1 <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请输入第二个字符："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> c2 <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span>chars             <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> c2<span class="token punctuation">)</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c2 <span class="token operator">+</span> <span class="token string">"字符出现了"</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">"次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><h5 id="记录一个子串在整串中出现的次数"><a href="#记录一个子串在整串中出现的次数" class="headerlink" title="记录一个子串在整串中出现的次数"></a>记录一个子串在整串中出现的次数</h5><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//输入一个字符串，并再输入一个字符串，输出该字符串出现的次数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Scanner</span> s<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入1："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> str1<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入2："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> str2<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">find</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>｝<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token class-name">String</span> str1<span class="token punctuation">,</span><span class="token class-name">String</span> str2<span class="token punctuation">,</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> index<span class="token operator">=</span>str1<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//如果能在总字符串里找到子字符串</span>            <span class="token comment">//就进行截取字符串,从查到索引位置起数子字符串长度个开始截取，到最后结束</span>            <span class="token class-name">String</span> news <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>index <span class="token operator">+</span> str2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> str1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">find</span><span class="token punctuation">(</span>news<span class="token punctuation">,</span>str2<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span></code></pre><hr><h4 id="2-StringBuffer类"><a href="#2-StringBuffer类" class="headerlink" title="2.StringBuffer类"></a>2.StringBuffer类</h4><p>   1).StringBuffer类概述<br>    StringBuffer是线程安全的可变字符序列.我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。而StringBuffer就可以解决这个问题.<br>    2).StringBuffer构造方法<br>    public StringBuffer():                                    无参构造方法,构建一个不带字符的字符串缓冲区,大小为16个字符<br>    public StringBuffer(int capacity):                  指定容量的字符串缓冲区对象<br>    public StringBuffer(String str):                     指定字符串内容的字符串缓冲区对象<br>3).StringBuffer常用方法<br>    public int capacity()：                                                   返回当前容量的理论值<br>    public int length():                                                        返回长度（字符数）。 实际值<br>    public StringBuffer append(String str):                          可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身<br>    public StringBuffer insert(int offset,String str):               在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身<br>    public StringBuffer deleteCharAt(int index):                   删除指定位置的字符并返回本身<br>    public StringBuffer delete(int start,int end):                   删除从指定位置开始指定位置结束的内容，并返回本身<br>    public StringBuffer replace(int start,int end,String str):   从start开始到end用str替换<br>    public StringBuffer reverse():                                         字符串反转<br>    public String substring(int start):                                   从指定位置截取到末尾(返回值类型不再是StringBuffer本身)<br>    public String substring(int start,int end):                       截取从指定位置开始到结束位置，包括开始位置，不包括结束位置(返回值类型不再是StringBuffer本身)</p><p>4).String和StringBuffer互相转化<br>    A::String –&gt; StringBuffer<br>        a:通过构造方法<br>        b:通过append()方法<br>    B:StringBuffer – &gt; String<br>        a: 使用substring方法<br>        b:通过构造方法<br>        c:通过toString()方法</p><h4 id="3-StringBuilder方法"><a href="#3-StringBuilder方法" class="headerlink" title="3.StringBuilder方法"></a>3.StringBuilder方法</h4><p><strong>与StringBuffer操作一致,效率更快,但是线程不安全。</strong></p><h4 id="4-包装类"><a href="#4-包装类" class="headerlink" title="4.包装类"></a>4.包装类</h4><ol><li>什么是包装类？<ul><li>Java是一个面向对象的编程语言，但是Java中的八种基本数据类型却是不面向对象的，为了使用方便和解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八种基本数据类型对应的类统称为包装类(Wrapper Class)，包装类均位于java.lang包。</li></ul></li><li>基本数据的包装类<ol><li></li></ol></li></ol><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><ol start="3"><li>包装类的实际使用<ol><li>基本数据和包装类的转换</li></ol></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> n1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"int类型转换为integer类："</span><span class="token operator">+</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> i1 <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"integer类转换为int类型："</span><span class="token operator">+</span>i1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>2. 数值字符串和整型互转</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//parseInt方法： 数字字符串类型转成int类型</span><span class="token class-name">String</span> ss<span class="token operator">=</span><span class="token string">"123"</span><span class="token punctuation">;</span><span class="token keyword">int</span> ii <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"字符类型转成整型："</span><span class="token operator">+</span>ii<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//toString方法：int类型转成数字字符串类型</span><span class="token keyword">int</span> ii2<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span><span class="token class-name">String</span> ss2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>ii2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"int类型转成数字字符串类型:"</span><span class="token operator">+</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="4"><li>拆箱和装箱<ul><li>基本数据类型和对应的包装类可以相互转换，由基本数据类型向包装类转换称为装箱，反之为拆箱！<br>注：* 此特性在jdk1.5之后被逐渐淡化<ul><li>包装类用于集合 集合只能用包装类，不能用基本数据类型</li></ul></li></ul></li></ol><h4 id="5-Date和Calendar类"><a href="#5-Date和Calendar类" class="headerlink" title="5. Date和Calendar类"></a>5. Date和Calendar类</h4><ol><li>Date类<ol><li>使用Date类的无参构造方法创建的对象可以获取本地当前时间</li></ol></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Date</span> date<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>2. 时间戳：指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总毫秒数。3. 获取时间戳</code></pre><pre class="language-java" data-language="java"><code class="language-java">date<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；</code></pre><pre><code>4. 格式化日期    SimpleDateFormat(格式化日期)：日期和时间格式由 日期和时间模式字符串 指定。在 日期和时间模式字符串 中，未加引号的字母 ‘A’ 到 ‘Z’ 和 ‘a’ 到 ‘z’ 被解释为模式字母，用来表示日期或时间字符串元素。    注：在此类中如果想格式化为yyyyyear 需要将year用单引号括起来例子：</code></pre><pre class="language-java" data-language="java"><code class="language-java"> <span class="token comment">//日期类转字符串：</span><span class="token class-name">Date</span> ss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"一般日期输出："</span> <span class="token operator">+</span> ss<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"时间戳："</span> <span class="token operator">+</span> ss<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SimpleDateFormat</span>  format <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span>“yyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd HH<span class="token operator">:</span>mm<span class="token operator">:</span>ss”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将目标格式传入构造方法</span><span class="token class-name">String</span> time <span class="token operator">=</span> format<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>字符串转日期类：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"2019-03-15"</span><span class="token punctuation">;</span><span class="token class-name">SimpleDateFormat</span> format <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Date</span> date <span class="token operator">=</span> format<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>Date类实现了Comparable接口 可以直接进行比较操作 实用compareto方法，返回int 相等为0，第一个大返回整数，否则返回负数</strong></p><p>   5.Calendar<br>        用于代替Date类的绝大多数功能。在实际项目当中，我们经常会涉及到对时间的处理，例如登陆网站，我们会看到网站首页显示XXX，欢迎您！今天是XXXX年。。。。某些网站会记录下用户登陆的时间，比如银行的一些网站，仅需要获取当前时间的某部分，比如年份月份邓，对于这些经常需要处理的问题，Java中提供了Calendar这个专门用于对日期进行操作的类（Date类在jdk1.1中也行，但后来都被淘汰掉了）。<br>        * Calendar为抽象类，得用静态方法      </p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Calendar</span> rightNow <span class="token operator">=</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>* 获取时间</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取年</span> <span class="token keyword">int</span> year <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>YEAR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取月，这里需要需要月份的范围为0~11，因此获取月份的时候需要+1才是当前月份值</span> <span class="token keyword">int</span> month <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>MONTH<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 获取日</span> <span class="token keyword">int</span> day <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>DAY_OF_MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取时</span><span class="token keyword">int</span> hour <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>HOUR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// int hour = calendar.get(Calendar.HOUR_OF_DAY);// 24小时表示</span> <span class="token comment">// 获取分</span><span class="token keyword">int</span> minute <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>MINUTE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取秒</span><span class="token keyword">int</span> second <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>SECOND<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>* 设置时间</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 时</span>calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>HOUR_OF_DAY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分</span>calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>MINUTE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 秒</span>calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>SECOND<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 毫秒</span>calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>MILLISECOND<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Calendar和Data转化</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//Calendar转化为Data</span><span class="token class-name">Calendar</span> calendar <span class="token operator">=</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//日历类的实例化</span>calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置日历时间，月份必须减一</span><span class="token class-name">Date</span> date <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从一个 Calendar 对象中获取 Date 对象</span> <span class="token comment">//Data转化为Calendar</span><span class="token class-name">Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接new对象，获取的是当前时间</span><span class="token class-name">Calendar</span> calendar <span class="token operator">=</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>calendar<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>例：<br>    1. 算算自己活了多少天</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//算算自己活了多少天</span>        <span class="token class-name">Date</span> date<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> now<span class="token operator">=</span>date<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//现在的时间戳</span>        <span class="token class-name">Calendar</span> c<span class="token operator">=</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置出生时间</span>        <span class="token class-name">Date</span> date1<span class="token operator">=</span>c<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取出生时间戳</span>        <span class="token keyword">long</span> birth<span class="token operator">=</span>date1<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>now<span class="token operator">-</span>birth<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000</span><span class="token operator">/</span><span class="token number">60</span><span class="token operator">/</span><span class="token number">60</span><span class="token operator">/</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>｝</code></pre><pre><code>2. 求下个月的今天的倒数3天</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Calendar</span> c<span class="token operator">=</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>MONTH<span class="token punctuation">,</span>c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>MONTH<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>DAY_OF_MONTH<span class="token punctuation">,</span>c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>DAY_OF_MONTH<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>｝</code></pre><h4 id="6-Math类"><a href="#6-Math类" class="headerlink" title="6. Math类"></a>6. Math类</h4><p>   Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。<br>    1).Math类中常用方法<br>        Math类中所有方法都为静态方法.<br>        Math.floor():         向下取整<br>        Math.round():      四舍五入<br>        Math.ceil():          取不小于num的最小整数<br>        Math.abs():         取绝对值<br>        Math.random():  生成[0,1)之间的随机小数<br>        Math.pow(a,b):   a的b次方<br>        Math.sqrt(num): num的平方根<br>        Math.max():        返回参数中的最大值<br>    2).Math类中的成员变量<br>        Math类中所有成员变量都是静态成员变量.<br>        Math.E:    自然对数的底数e<br>        Math.PI:   圆周率π<br>例：猜数字游戏</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//随机生成[1,100]一个数字，由键盘输入数字进行猜测，如果猜测小了则提示小了，猜测7次不中，提示笨蛋并程序结束</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">></span>v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"大了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span>v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"恭喜"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">>=</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"笨蛋"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>｝</code></pre><h4 id="7-Scanner类"><a href="#7-Scanner类" class="headerlink" title="7.Scanner类"></a>7.Scanner类</h4><pre><code>  1. Scanner概述     * 用于获取用户的键盘输入.  2. Scanner常用方法     * hasNextXxx():                          判断下一个是否是某种类型的元素,其中Xxx可以是Int,Double等。            * public int nextInt():                  获取一个int类型的值     * public String nextLine():           获取一个String类型的值</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01_Scanner</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//2. 创建键盘录入数据的对象        </span><span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//3. 接收数据        </span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请录入一个整数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//4. 输出数据        </span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i:"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span></code></pre><p> **注：Scanner的next方法和nextline方法不要一起用 会出bug</p><h4 id="8-System类"><a href="#8-System类" class="headerlink" title="8.System类"></a>8.System类</h4><pre><code>  1. 概述       System 类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。  2. 常用方法     * currentTimeMillis() ：返回以毫秒为单位的当前时间（时间戳）–获取当前系统时间与1970年01月01日00:00点之间的毫秒差值；     * arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：将数组中指定的数据拷贝到另一个数组中     * gc()： 垃圾回收     * exit(int status)   终止当前正在运行的 Java 虚拟机；（int status:状态码,给JVM看，0:正常终止，其他数字:异常终止）</code></pre><p>​<br>​     </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态，内部类，匿名内部类</title>
      <link href="/2020/04/03/%E5%A4%9A%E6%80%81%EF%BC%8C%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/04/03/%E5%A4%9A%E6%80%81%EF%BC%8C%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="多态，内部类，匿名内部类"><a href="#多态，内部类，匿名内部类" class="headerlink" title="多态，内部类，匿名内部类"></a>多态，内部类，匿名内部类</h1><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol><li>多态概述<br>多态是继封装、继承之后，面向对象的第三大特性。<br>生活中，比如跑的动作，小猫、小狗和大象，都有跑的动作，但是跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也 是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。<span id="more"></span><br>父类的引用指向子类对象。</li><li>定义<br>是指同一行为，具有多个不同的表现形式</li><li>多态前提<ul><li>继承或者实现</li><li>方法的重写</li><li>父类引用指向子类对象</li></ul></li><li>多态的体现格式：<br>父类类型 变量名 &#x3D; new 子类对象;<br>变量名.方法名();<br>代码如下</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Fu</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//父类的引用指向子类对象</span>f<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>   <strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//定义父类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//定义子类</span><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃鱼"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃骨头"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//定义测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 多态形式，创建对象</span>        <span class="token class-name">Animal</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 调用的是 Cat 的 eat</span>       a1<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 多态形式，创建对象         </span>            <span class="token class-name">Animal</span> a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用的是 Dog 的 eat</span>        a2<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  </code></pre><hr><ol start="5"><li>多态的好处<br>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展 性与便利。</li><li>引用类型转换-向上转型<br>多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型.</li><li>引用类型转换-向下转型<br>父类类型向子类类型向下转换的过程，这个过程是强制的。<br>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//定义父类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//定义子类</span><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃鱼"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃骨头"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//定义测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 向上转型</span>        <span class="token class-name">Animal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用的是 Cat 的 eat</span>        <span class="token comment">// 向下转型</span>        <span class="token class-name">Cat</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">catchMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用的是 Cat 的 catchMouse                 </span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  </code></pre><ol start="8"><li>instanceof<br>instanceof关键字：判断变量是否属于某个类，返回值为true&#x2F;false</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//定义父类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//定义子类</span><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃鱼"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃骨头"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//定义测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//向上转型</span>        <span class="token class-name">Animal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用的是 Cat 的 eat</span>        <span class="token comment">//向下转型</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token class-name">Cat</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>           c<span class="token punctuation">.</span><span class="token function">catchMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用的是 Cat 的 catchMouse</span>         <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Dog</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token class-name">Dog</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>         d<span class="token punctuation">.</span><span class="token function">watchHouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用的是 Dog 的 watchHouse</span>        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  </code></pre><ul><li>在idea中使用Ctrl+O重写方法。</li><li>要多多研究Code和Refactor菜单</li><li>instanceof 可以来判断是否可以强行转换类型</li><li>instanceof判断一个对象是否是某种类型该对象声明类型和强转的类型有继承关系</li><li>在使用多态这个特性是，主要看对象是被什么样的类new出来的。</li></ul><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol><li>什么是内部类<ul><li>将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类</li></ul></li><li>什么是成员内部类<ul><li>定义在类中方法外的类</li><li>定义格式</li></ul></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> 外部类<span class="token punctuation">&#123;</span>    <span class="token keyword">class</span> 内部类<span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li><p>内部类使用场景</p><ul><li>在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机 类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。</li></ul></li><li><p>内部类访问特点</p><ul><li>内部类可以直接访问外部类的成员，包括私有成员。</li><li>外部类要访问内部类的成员，必须要建立内部类的对象。</li><li>内部类可以声明为static的，但此时就不能再使用外层封装类的非static的成员变量；</li><li>非static的内部类中的成员不能声明为static的，只有在顶层类或static的内部类中才可声明static成员；</li></ul><p>创建内部类对象格式：<br>        外部类名.内部类名 对象名 &#x3D; new 外部类型().new 内部类型()；<br> 代码演示：</p></li></ol> <pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span>  <span class="token keyword">boolean</span> live <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token keyword">class</span> <span class="token class-name">Heart</span> <span class="token punctuation">&#123;</span>               <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">// 直接访问外部类成员           </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>live<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"心脏在跳动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"心脏不跳了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token punctuation">&#125;</span>               <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token keyword">return</span> live<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLive</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> live<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>live <span class="token operator">=</span> live<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerDemo</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// 创建外部类对象        </span>        <span class="token class-name">Person</span> p  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 创建内部类对象       </span>        <span class="token class-name">Heart</span> heart <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Heart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 调用内部类方法       </span>        heart<span class="token punctuation">.</span><span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 调用外部类方法       </span>        p<span class="token punctuation">.</span><span class="token function">setLive</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 调用内部类方法       </span>        heart<span class="token punctuation">.</span><span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名 和$符号 。 比如，Person$Heart.class。</strong></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><ol><li>匿名内部类概述<br>匿名内部类是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作，<br>1. 定义子类<br>2. 重写接口中的方法<br>3. 创建子类对象<br>4. 调用重写后的方法<br>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</li><li>匿名内部类前提<br>匿名内部类必须继承一个父类或者实现一个父接口。<br>格式</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> 父类名或者接口名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 方法重写</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 执行语句</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ol start="3"><li>匿名内部类使用</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//定义接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FlyAble</span><span class="token punctuation">&#123;</span>       <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//创建测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerDemo</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">/*           1.等号右边:是匿名内部类，定义并创建该接口的子类对象           2.等号左边:是多态赋值,接口类型引用指向子类对象          */</span>             <span class="token class-name">FlyAble</span>  f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlyAble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我飞了~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span>             <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">//调用 fly方法,执行重写后的方法     </span>        f<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><ol><li>内部类<ol><li>有的类只给别的类用，因此可以写为内部类</li><li>内部类引用外部类的成员用外部类类名.this</li></ol></li><li>静态内部类<br> 1. 不能访问外部类的一切非静态变量<br> 2. 静态内部类实例化<br>  例子：<code>new Outer.Iner();</code></li><li>局部内部类<br> * 在方法中定义内部类——局部内部类<br> <img src="http://cdn.leafii.top/img/20220520164037.png" loading="lazy"></li><li>局部匿名内部类<br><img src="http://cdn.leafii.top/img/20220520164050.png" loading="lazy"></li><li>局部匿名内部类的方法</li></ol><p><img src="http://cdn.leafii.top/img/20220520164105.png" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的Object类，接口</title>
      <link href="/2020/04/03/Java%E7%9A%84Object%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/04/03/Java%E7%9A%84Object%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的Object类，接口"><a href="#Java的Object类，接口" class="headerlink" title="Java的Object类，接口"></a>Java的Object类，接口</h1><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><pre><code>1. Object类概述   * Object 类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。如果一个类没有特别指定父类， 那么默认则继承自Object类。&lt;!--more--&gt;2. toString方法   *  返回该对象的字符串表示，（类全名+@+hashcode）   *  想打印自己写的类的全部信息，需要重写toString方法(来自Object类的toString方法)</code></pre> <pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token string">"Teacher&#123;"</span> <span class="token operator">+</span>               <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>               <span class="token string">", sex='"</span> <span class="token operator">+</span> sex <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>               <span class="token char">'&#125;'</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre><pre><code>3. equals方法   * 指示其他某个对象是否与此对象“相等”。调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。默认地址比较：如果没有覆盖重写equals方法，那么Object类中默认进行 == 运算符的对象地址比较，只要不是同一个对象，结果必然为false。自定义对象内容比较：如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。   * 两个变量相等分为两种相等，物理相等和逻辑相等   * 物理相等，即值相等，逻辑相等，即两个变量的地址相等，因此如果逻辑相等，那么一定物理相等，反之则不一定。   * 图片在下面   * 物理相等：“==” 逻辑相等：“equals()”,当不重写equals方法时，，equals与==无区别   * equals重写要点：     1. 物理相等的对象 一定要逻辑相等     2. 任何对象和null判断equals都返回false；     3. 类型不同的对象 直接返回false；     4. 强转参数类型后，比较需要的元素/要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</code></pre><p><img src="http://cdn.leafii.top/img/20220520161150.png" loading="lazy"></p>   <pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Objects</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>            <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果对象地址一样，则认为相同</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 如果参数为空，或者类型信息不一样，则认为不同</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 转换为当前类型</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span>        <span class="token keyword">return</span> age <span class="token operator">==</span> person<span class="token punctuation">.</span>age <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">==</span>obj<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token class-name">Teacher</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Teacher</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTeacherNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> t<span class="token punctuation">.</span><span class="token function">getTeacherNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span></code></pre><pre><code>4. hashCode方法   * hashcode就是jdk给每个对象的“身份证”，很大程度上可以体现内存地址。   * 返回该对象的哈希码值。   * 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。   * 一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。   * 如果重写equals方法，不重写hashcode的时候，当我们使用HashSet，HashMap等哈希容器时就会出问题。     自己动手写equals，hashcode</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTeacherNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">31</span><span class="token operator">+</span><span class="token number">31</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre><pre><code>5. finalize()方法   * 对象被回收之前要做的事。   * finalize被重写才能用   * 在日常很少使用，在main中以System.gc进行垃圾回收处理6. 参数传递   * 要理解java的参数传递</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token class-name">A</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">change1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">change2</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">change1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        a<span class="token operator">=</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">change2</span><span class="token punctuation">(</span><span class="token class-name">A</span> aa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        aa<span class="token punctuation">.</span>a<span class="token operator">=</span>aa<span class="token punctuation">.</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>运行结果：<span class="token number">10</span> <span class="token number">11</span>    </code></pre><p><strong>main方法和 change1，change2方法都在栈里，然而A对象以及它的实例在堆里，change1调用之后就直接出栈了，没有对main中的a进行改变，而change2方法将对象中的a值改变了 然后将对象中的a打印出 发现值确实被修改了</strong></p><pre><code>  7. clone()方法</code></pre><ul><li>实现对象的浅克隆。</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectDemo</span>  <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">&#123;</span><span class="token comment">//标志性接口</span>    <span class="token comment">//只能给你看，不能改</span>    <span class="token keyword">int</span> a <span class="token punctuation">;</span>    <span class="token class-name">ObjectDemo</span> objectDemo<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ObjectDemo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span>  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> cloneObject <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            cloneObject <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 默认就是一级浅克隆</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cloneObject<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"ObjectDemo&#123;"</span> <span class="token operator">+</span>                <span class="token string">"a="</span> <span class="token operator">+</span> a <span class="token operator">+</span>                <span class="token char">'&#125;'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">MainClone</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainClone</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//        演示对象的克隆</span>        <span class="token class-name">ObjectDemo</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectDemo</span><span class="token punctuation">(</span><span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        o1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> o1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>clone是一个protected的方法，如果想要使用必须在类的内部定义，就好比你小时候想要零花钱，爸妈不给你但是你找你哥哥让他要了零花钱分你一些，你就可以使用零花钱啦</li><li>需要自己重写clone方法。</li></ul> <pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span>  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> cloneObject <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            cloneObject <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 默认就是一级浅克隆</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cloneObject<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><ul><li>由于java类中可以调用别的类，所以类是不止一级的，但是java默认只支持一级浅克隆，所以java中很少使用clone方法。</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol><li>普通类是一个完善的功能类，可以直接产生实例化对象，并且在普通类中可以包含有构造方法、普通方法、static方法、常量和变量等内容。而抽象类是指在普通类的结构里面增加抽象方法的组成部分。</li></ol><p>那么什么叫抽象方法呢？在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。而抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。</p><p><strong>拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明。</strong></p><ol start="2"><li>定义一个抽象类</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token comment">//定义一个抽象类</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//普通方法</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"存在方法体的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//抽象方法，没有方法体，有abstract关键字做修饰</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>抽象类的特点：<ol><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法);</li><li>抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；</li><li>抽象类要使用必须依靠子类，使用extends继承，一个子类只能继承一个抽象类；</li><li>一个类继承了抽象类,则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；</li><li>抽象类不能用final声明,抽象方法也不能.</li></ol></li></ol><hr><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol><li>概念<br>官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。通俗解释：接口可以理解为一种特殊的抽象类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。</li><li>定义一个接口</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Door</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">Door</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体实现open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体实现close"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>接口的特点<ol><li>接口不能被实例化;</li><li>接口中的成员方法默认修饰为public abstract,成员变量默认修饰为public static final;</li><li>接口没有构造方法;</li><li>一个类可以实现多个接口,格式如: class A implements B,C{ }</li><li>接口不能用final声明.</li></ol></li></ol><h3 id="类与接口的区别"><a href="#类与接口的区别" class="headerlink" title="类与接口的区别"></a>类与接口的区别</h3><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static  final变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li><li>接口体现一种规范，规范：一般都是一些功能的集合</li></ul><h3 id="类，接口，抽象类的总结"><a href="#类，接口，抽象类的总结" class="headerlink" title="类，接口，抽象类的总结"></a>类，接口，抽象类的总结</h3><p> 思想（关键）<br>    1.  类、抽象类、接口都是类<br>            a. 类是完全具体(不能包含抽象成分)<br>            b. 抽象类是半抽象半具体<br>            c. 完全抽象的（不能包含具体的方法）<br>    2.抽象类一般体现一种共性，天生就被继承<br>    3.接口体现一种规范，代表一些能力的集合。<br> 语法<br>    a. 抽象类用abstract修饰，只能单继承<br>    b.抽象类中的方法必须加 abstract 修饰符，访问权限不能是 private<br>    c. 接口的方法默认是就是 public，可以省略 abstract 关键字<br>    d. 接口只能声明常量，接口中的成员变量没人就是 public staic final …..<br>    e. 接口之间允许多继承</p><hr><p>   <strong>普通类    完全具体</strong><br>   <strong>抽象类    半抽象半具体</strong><br>   <strong>接口       完全抽象</strong></p><p>   接口 就好比 指定了 水果 有可以被吃的方法<br>   实现接口 就好比 指定了某一种水果，通过被剥皮&#x2F;直接吃的方式 被吃</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类与对象，Scanner以及编码体系</title>
      <link href="/2020/04/01/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%8CScanner%E4%BB%A5%E5%8F%8A%E7%BC%96%E7%A0%81%E4%BD%93%E7%B3%BB/"/>
      <url>/2020/04/01/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%8CScanner%E4%BB%A5%E5%8F%8A%E7%BC%96%E7%A0%81%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java类与对象，Scanner，编码体系"><a href="#Java类与对象，Scanner，编码体系" class="headerlink" title="Java类与对象，Scanner，编码体系"></a>Java类与对象，Scanner，编码体系</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ol><li>java中有两个地方具有默认初始化，数组，类的成员变量</li><li>java中以包作为默认管理级别，那默认情况下同一个包中都可以访问<span id="more"></span></li><li>public private default辨析：</li></ol><table><thead><tr><th>访问权限</th><th>本类</th><th>本包的类</th><th>子类</th><th>非子类的外包类</th></tr></thead><tbody><tr><td>public</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>protected</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>default</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>private</td><td>是</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>1、public： 所修饰的类、变量、方法，在内外包均具有访问权限；<br>2、protected： 这种权限是为继承而设计的，protected所修饰的成员，对所有子类是可访问的，但只对同包的类是可访问的，对外包的非子类是不可以访问；<br>3、包访问权限（default）： 只对同包的类具有访问的权限，外包的所有类都不能访问；<br>4、private： 私有的权限，只对本类的方法可以使用；</p><hr><p>构造方法：<br>1).构造方法的定义</p><p>它具有与类相同的名称；</p><p>它不含返回值；</p><p>注意：在构造方法里不含返回值的概念是不同于“void”的，在定义构造方法时加了“void”，结果这个方法就不再被自动调了。</p><p>2).构造方法的作用</p><p>当一个类的实例对象刚产生时，这个类的构造方法就会被自动调用，我们可以在这个方法中加入要完成初始化工作的代码。这就好像我们规定每个“人”一出生就必须先洗澡，</p><p>我们就可以在“人”的构造方法中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。</p><p>语法格式：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span> 修饰符<span class="token operator">></span>  <span class="token operator">&lt;</span>类名<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span> 参数表<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token punctuation">[</span><span class="token operator">&lt;</span> 语句<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">int</span> legs<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  legs <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//构造器</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLegs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  legs <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getLegs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> legs<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//创建Animal类的实例：Animal  a=new Animal(); //调用构造器，将legs初始化为4.</span></code></pre><p>3).默认的构造方法</p><p>Java语言中，每个类都至少有一个构造方法；</p><p>如果类的定义者没有显式的定义任何构造方法，系统将自动提供一个默认的构造方法：</p><p>–默认构造方法没有参数</p><p>–默认构造方法没有方法体</p><p>–默认的构造方法：Animal(){ }</p><p> 所以：不编写构造方法就能用new Xxx()创建类的实例。</p><p>Java类中，一旦类的定义者显式定义了一个或多个构造方法，系统将不再提供默认的构造方法；</p><p>4).构造方法重载</p><p>构造方法重载使得对象的创建更加灵活，方便创建各种不同的对象。</p><p>构造方法重载举例：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">Date</span> d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>…<span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Date</span> d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>…<span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>…<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>构造方法重载，参数列表必须不同</strong></p><h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><ol><li>对于新建的类 要封装他 需要在类中的变量的权限改为private 然后对其添加get和set方法</li><li>在写get和set方法时，方法中的参数要顾名思义，不能随便乱写</li><li>bool类型的getter不能用setXXX()，而是要用isXXX()。bool类型取名尽量不要添加is作为开头，因为generator会自动将bool类型的变量的方法命名为isXXX()，容易撞名字。</li><li>对于除了bool类型之外的其他类型，第二个字母最好不要大写。原因同上。</li></ol><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li>构造方法分为无参构造，有参构造，全参构造</li><li>实例化类的时候，就会进行构造方法的调用。</li><li>构造方法是不能写返回值的</li><li>类的构造方法，默认是无参构造，当类中未声明任何构造方法时，才会具备默认的无参构造。</li><li>this关键字<ol><li>引用当前对象</li><li>本类中调用构造方法</li></ol></li><li>普通方法，也叫实例方法，它的执行必须依赖对象。</li><li>可以通过构造方法创建对象，通过关键字new来调用构造方法。</li><li>可以多多使用.var这个小技巧 实例化时会更方便。</li><li>直接用new 例：</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>这是一个匿名对象。不持有对方的引用。</code></pre><ol start="10"><li>构造方法的方法名固定，与类名一致。</li><li>构造方法，不能声明返回值，但是它的本质上是有返回值的，返回类的对象的实例</li><li>任何类都必须具有构造方法。当代码中未声明任何构造方法，则有一个著名的默认无参构造，是public级别的。</li><li>编写类的时候不要吝啬this关键字的使用</li><li>构造方法之间的调用：<ol><li>通过this()来调用本类的构造方法，必须放置首行，而且只能有一个（因为如果有多个，就是相当于实例化了多个类的实例）</li><li>调用有参构造，只能调用一次，只要调用一次就会产生一个新的对象。</li><li>构造方法的调用，类内用this()；，类外用new。<br><img src="http://cdn.leafii.top/img/20220520160935.png" loading="lazy"></li></ol></li></ol><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ol><li>一个类中的不一样的方法，恰好方法名相同，签名不同。</li><li>方法签名： 就是方法名和方法的参数列表。java不允许有相同的方法签名出现。<br>example:</li></ol> <pre class="language-java" data-language="java"><code class="language-java"><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">sout</span><span class="token punctuation">(</span>"<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">sout</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><ol><li>若要直接在类中调用方法，可以给方法添加static关键字，使其变为静态方法，就可以进行直接调用了，不用实例化再调用。</li><li>静态方法与类行管，它的执行只需要类名，不需要对象。</li><li>不加static就是实例方法 实例方法的执行依赖对象。</li><li>就算是初始化为空的类也可以使用静态方法。即null在代码上可以调用静态方法</li><li>比如就算使用了dog.fn1()；，编译之后还是会编译成Dog.fn1()；fn1是Dog中的静态方法</li><li>静态方法和实例方法之间的调用关系：静态方法不允许调用实例方法，反之可以。</li><li>static和this关键字水火不容 因为this代表当前对象</li></ol><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ol><li>初始化对象时，先执行静态代码块，再执行实例代码块，最后执行构造方法。</li><li>代码块：<ol><li>静态代码块：类加载的时候就执行，执行一次。<ol><li>什么时候才会类加载？<ol><li>使用new方法实例化对象时</li><li>使用Class.forName(“类名”)时</li></ol></li></ol></li><li>实例代码块：每创建一个实例执行一次</li><li>代码块的执行都在构造方法之前<br>example:</li></ol></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Demo</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"实例代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//实例代码块： 创建对象才被调用，每创建一个对象执行一次！</span>    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 静态代码块：类加载的时候被调用，只调用一次。</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//实例方法：它的执行必须依赖对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"说话"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayStatic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//静态方法：它的执行不必依赖对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"说话静态方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"实例方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//实例方法允许调用静态方法</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//fn1(); 这样就不ok</span>        <span class="token comment">//这样相当于 this.fn1();</span>        <span class="token comment">//static 和 this 是水火不容的</span>        <span class="token comment">//静态方法不能调用实例方法</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>?</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">DemoTest</span><span class="token punctuation">.</span>java<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Demo</span> demo1<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Demo</span> demo2<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//先执行静态代码块，再执行实例代码块，再执行构造方法</span>        <span class="token class-name">Demo</span> demo3<span class="token punctuation">;</span><span class="token comment">//代码块不执行</span>        <span class="token class-name">Demo</span> demo4 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//代码块不执行</span>        <span class="token comment">//在下列情况 才会执行代码块</span>        <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.yys.Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//限定名，全程 有包有类名</span>        <span class="token class-name">Class</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//限定名</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//类名</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Demo</span> demo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        demo<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Demo</span><span class="token punctuation">.</span><span class="token function">sayStatic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demo<span class="token punctuation">.</span><span class="token function">sayStatic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//一样的 编译后都是Demo.sayStatic();</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><hr><h3 id="类的继承，抽象及接口"><a href="#类的继承，抽象及接口" class="headerlink" title="类的继承，抽象及接口"></a>类的继承，抽象及接口</h3><ol><li>继承的目的:为了扩展<ol><li>向上抽象</li><li>向下具化</li></ol></li><li>例子</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//Student是子类，继承了父类Person</span></code></pre><ol start="3"><li>子类中对父类哪些东西是可见的<br>protected修饰的方法<br>protected修饰的方法或变量在子类中（内部）可以访问。相当于 子类+同包，<br><strong>对象与protected无关！</strong></li><li>子类中写的方法可以用@Override进行检测 检测该方法是不是冲写的，父类是不是有这个方法</li><li>方法的重写：<ol><li>方法修饰符不能低于原来 </li><li>如果父类的方法是void，重写的方法必须是void</li><li>如果父类的方法有返回值，重写的方法不能比父类中原方法的返回类型更抽象（）</li><li>抛异常不能比原来更抽象</li></ol></li><li>super作用<ol><li>在子类中访问父类对象</li><li>如果不存在方法的重写，this.调用父类的方法      </li><li>调用父类构造方法</li></ol></li></ol><p>尽量保留默认的无参数构造 不然的话继承时很麻烦 会报错 因为子类构造方法的参数只能比父类的参数更多</p><hr><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>1).继承的概述<br>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p><p>2).继承格式<br>通过extends关键字可以实现类与类的继承<br>class &lt;子类名&gt; extends &lt;父类名&gt; {方法体}<br>单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。<br>子类只能继承父类所有非私有的成员(成员方法和成员变量),子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法。<br>3).继承的效果<br>扩展功能<br>提高代码复用率<br>让类与类之间产生了关系，是多态的前提<br>增强了类的耦合性<br>4).继承的特点<br>Java只支持单继承，不支持多继承;<br>Java支持多层继承(继承体系).<br>5).super关键字<br>调用父类构造方法<br>调用父类成员方法<br>调用父类成员变量<br>6).使用继承注意事项<br>子类中所有的构造方法默认都会访问父类中空参数的构造方法。<br>子类中要使用父类成员变量, 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。<br>如果父类没有无参构造方法,子类怎么办?<br>在父类中添加一个无参的构造方法<br>子类通过super去显示调用父类其他的带参的构造方法<br>子类通过this去调用本类的其他构造方法,本类其他构造也必须首先访问了父类构造<br>子类中的成员变量和父类中的成员变量名称一样时,在子类中访问一个变量的查找顺序是怎样的?<br>在子类的方法的局部范围找,有就使用<br>在子类的成员范围找,有就使用<br>在父类的成员范围找,有就使用<br>如果还找不到,就报错</p><hr><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>1).什么是方法重写?<br>子类中出现了和父类中一模一样的方法声明(方法名,参数列表,返回值类型)，也被称为方法覆盖，方法复写。</p><p>2).方法重写(Override)和方法重载(Overload)的区别?<br>Override是覆盖的意思，也就是重写，它与返回值类型无关，只看参数列表;</p><p>Overload是重载的意思，表示在同一个类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可;</p><p>两者不同主要体现在：目的不同、范围不同、参数要求不同、返回类型不同。</p><p>同:overload用于增加程序的可读性(做法不同,但是做的同一事情)。 override用于提供其超级类已经提供的方法的特定实现。<br>同:overload 在相同的类范围内内执行。 override发生在两类具有继承（继承）的关系。<br>参数要求不同:overload参数必须不同。 override参数必须相同。<br>返回类型不同:overload中可以相同或不同。 override必须是相同的或协变的。<br>3).方法重写的应用?<br>当子类需要父类的功能，但是父类功能不满足自身的时候,可以重写父类中的方法。</p><p>4).方法重写的注意事项<br>父类中私有方法不能被重写。因为父类私有方法子类根本就无法继承；<br>子类重写父类方法时，访问权限不能更低。 最好就一致<br>子类重写父类方法时，如果父类方法带有异常,则子类异常范围必须一致或更小<br>子类重写父类方法的时候，最好声明一模一样</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>1).final修饰类被修饰类不能被继承.2).final修饰方法被修饰的方法不能被重写.3).final修饰变量①局部变量——基本类型基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalDemo1</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 声明变量，使用final修饰</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>        <span class="token comment">// 第一次赋值</span>        a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment">// 第二次赋值</span>        a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 报错,不可重新赋值</span>        <span class="token comment">// 声明变量，直接赋值，使用final修饰</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment">// 第二次赋值</span>        b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 报错,不可重新赋值</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>② 局部变量——引用类型引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalDemo2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建 User 对象</span>        <span class="token keyword">final</span> <span class="token class-name">User</span> u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建 另一个 User对象</span>        u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错，指向了新的对象，地址值改变。</span>        <span class="token comment">// 调用setName方法</span>        u<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以修改</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>③成员变量成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：显式初始化：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">String</span> USERNAME <span class="token operator">=</span> <span class="token string">"张三"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>构造方法初始化：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">String</span> USERNAME <span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>         <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>USERNAME <span class="token operator">=</span> username<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>被final修饰的常量名称，一般都有书写规范，所有字母都大写，且用下划线式。</strong></p><hr><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><ul><li>创建创建父类对象（父类对象创建也是如此）</li><li>加载类对象 : 静态代码块 </li><li>默认初始化 成员变量 </li><li>显式初始化成员变量 </li><li>实例代码块</li><li>构造方法</li></ul><p>如果想让继承的类构造它的父类的所有参数以及子类独有的参数：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span><span class="token punctuation">.</span>java<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"姓名:"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">Student</span><span class="token punctuation">.</span>java<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setScore</span><span class="token punctuation">(</span><span class="token keyword">int</span> score<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">,</span><span class="token keyword">int</span> score<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"考试得了："</span> <span class="token operator">+</span> score <span class="token operator">+</span> <span class="token string">"分"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">showMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"同学，"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>在写子类的全参数构造方法时要先用super实例化父类。</strong></p><h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h3><p>例子：创建一个工具类，一个MyObject对象，一个MyMy对象继承MyObject：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">MyUtils</span><span class="token punctuation">.</span>java    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyUtils</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">99</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">MyObject</span><span class="token punctuation">.</span>java    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyObject</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token class-name">MyUtils</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"实例代码块： MyObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态代码块： MyObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法： MyObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">MyMy</span><span class="token punctuation">.</span>java    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMy</span> <span class="token keyword">extends</span> <span class="token class-name">MyObject</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token class-name">MyUtils</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"实例代码块： MyMy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态代码块： MyMy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">MyMy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法： MyMy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">Test</span><span class="token punctuation">.</span>java    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">new</span> <span class="token class-name">MyMy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>结果：<br>    静态代码块： MyObject<br>    静态代码块： MyMy<br>    实例代码块： MyObject<br>    构造方法： MyObject<br>    实例代码块： MyMy<br>    构造方法： MyMy</p><p>即：</p><ul><li>创建父类对象（父类对象创建也是如此）</li><li>加载类对象 : 静态代码块</li><li>默认初始化 成员变量</li><li>显式初始化成员变量</li><li>实例代码块</li><li>构造方法</li></ul><hr><pre class="language-none"><code class="language-none">1. 什么叫做类与类的继承，作用是什么？    1）多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。    2）作用：    扩展功能    提高代码复用率    让类与类之间产生了关系，是多态的前提    增强了类的耦合性2. 继承后，父类与子类之间，各成员有什么样的影响？调用子类，先进行父类的参数定义和构造器构造，再进行子类的参数定义和构造器构造；如果子类构造器中没有 super() 语句，或 super() 语句中不含参数；会去寻找父类当中不含参数的构造器；有参数时，寻找有对应参数的父类构造器；父类中的函数 protected 参数声明，尽量少用，可以通过父类构造函数使用父类中 private 参数；3. 子类中，如何调用父类的成员？如何使用本类的成员？    1）直接实例化父类的成员    2）如果继承了父类的成员函数（指没有新写覆盖），则直接写成员函数名+参数来调用。         如果没法继承（指的是父类的私有成员函数）则不能调用。         如果可以继承（父类的保护或公有成员函数），但覆盖了（比如同名重写或虚函数重写）则可用：“ 父类名::成员函数名（参数）； ” 来调用。4. 抽象方法与普通成员方法有什么区别？5. 抽象类与普通类有什么区别？何为抽象类？抽象类是从其他若干个具有相同属性与行为的类中进一步抽象出来的类，可以设计方法，属性，如果把类设计为抽象类，那么这个类是不能被实例化的，只能被继承的子类（子类也可以为抽象类，也可以不是）间接使用，抽象类有构造，是一个完整的类。抽象类不能使用new方法进行实例化，没有具体实例对象。抽象类有点类似“模板”的作用，目的是根据其格式来创建和修改新的类。对象不能由抽象类直接创建，只可以通过抽象类派生出新的子类，再由其子类来创建对象。当一个类被声明为抽象类时，要在这个类前面加上修饰符abstract。在抽象类中的成员方法可以包括一般方法和抽象方法。抽象方法就是以abstract修饰的方法，这种方法只声明返回的数据类型、方法名称和所需的参数，没有方法体，也就是说抽象方法只需要声明而不需要实现。当一个方法为抽象方法时，意味着这个方法必须被子类的方法所重写，否则其子类的该方法仍然是abstract的，而这个子类也必须是抽象的，即声明为abstract.</code></pre><h2 id="编码体系"><a href="#编码体系" class="headerlink" title="###编码体系"></a>###编码体系</h2><p>所有编码无条件兼容ascii码<br>unicode码以\u开头 以一个十六位的数字代替四个二进制数字，unicode可以显示所有语言<br>utf-8是unicode的一种表现形式</p><h2 id="关于Scanner"><a href="#关于Scanner" class="headerlink" title="关于Scanner"></a>关于Scanner</h2><ol><li>Scanner中的nextInt方法和nextDouble方法：如果使用nextInt方法，如果输入了double型的参数，会报错，但是反之不会 因为int和double的精度不同，java为了不让数据丢失 不会让double进入nextInt方法</li><li>如果先写了nextline,后写nextInt，可以正常运行，但是先写了nextInt 后写了nextline 就不行了 因为nextline检测的是你的回车符，你写了int值之后敲回车 会默认也进行nextline方法，并将值赋值为空。<br>若要避免这种情况，可以将代码修改为：</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> ageStr <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token class-name">Integar</span><span class="token punctuation">.</span><span class="token function">parseint</span><span class="token punctuation">(</span>ageStr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> str <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="3"><li>如果输入一串字符 只想得到它的第一个字母：</li></ol><pre class="language-java" data-language="java"><code class="language-java">sc<span class="token punctuation">.</span><span class="token function">nextline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组,堆栈，Arrays工具类</title>
      <link href="/2020/04/01/Java%E6%95%B0%E7%BB%84%EF%BC%8C%E5%A0%86%E6%A0%88%EF%BC%8CArrays%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2020/04/01/Java%E6%95%B0%E7%BB%84%EF%BC%8C%E5%A0%86%E6%A0%88%EF%BC%8CArrays%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java数组-堆栈，Arrays工具类"><a href="#Java数组-堆栈，Arrays工具类" class="headerlink" title="Java数组,堆栈，Arrays工具类"></a>Java数组,堆栈，Arrays<strong>工具类</strong></h1><h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><ol><li>数组的定义<br>概述：数组是多个相同类型数据的组合，实现对这些数据的统一管理，数组属引用类型，数组型数据是对象(Object)，<span id="more"></span>数组中的每个元素相当于该对象的成员变量，数组中的元素可以是任何数据类型，包括基本类型和引用类型。<br>作用：是用来存储固定大小的同类型元素。<br>定义：<br>（1）数据类型[ ]  变量名；例：int[ ]   arr;<br>（2）数据类型 变量名[ ] ；例：int arr[ ];<br>创建：<br>Java语言使用new操作符来创建数组，语法如下：<br>数据类型[ ]  变量名&#x3D;new 数据类型[数组长度] ;<br>例：int[ ]  arr&#x3D;new int[50];&#x2F;&#x2F;定义一个长度为50的int数组。<br>或者直接在创建的时候赋予初值，语法如下：<br>数据类型[ ]  变量名&#x3D;{值1,值2,值3,值4};<br>例：int[ ] arr&#x3D;{1,2,8,98};（不推荐 建议每次声明都声明好数据类型）<br>处理：数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 foreach 循环。<br>数组元素的默认初始化：数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。<br>如果定义了数组：</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>a，b数组的长度是一样的 不会因为末尾的逗号增加长度</p><ol start="2"><li>数组的遍历<br>通常使用常规循环 或者 foreach循环遍历数组<br>foreach：</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token operator">:</span>         a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>for循环省略。如果想通过循环来修改数组的值，只能用常规循环，foreach循环只能遍历输出数组，无法修改或者删除数组，若在foreach中修改了i值，只是修改了临时变量的值，没有对数组进行操作。</p><p><strong>注：新建数组时一定要有类型和大小！</strong></p><hr><p>数组默认初始化的值如下：<br>    1. 数值类的数组初始化默认为0或者0.0<br>        2. bool类的数组初始化默认为false<br>        3. 引用类型数组初始化默认都是null<br>        完整图：<br>        <img src="http://cdn.leafii.top/img/20220520160841.png" loading="lazy"></p><pre><code>**注：null可以赋值给引用类型，但是不可以赋值给基本类型。注：null在sout中无法输出的原因是：null在sout方法中既可以匹配到char[], 也可以匹配到String类型，编译器无法进行输出。**</code></pre><hr><p>例子：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exchangenum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp<span class="token punctuation">;</span>        temp <span class="token operator">=</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>        b <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a:"</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">",b:"</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exchangenumarray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp<span class="token punctuation">;</span>        temp <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a[0]:"</span> <span class="token operator">+</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">",a[1]:"</span> <span class="token operator">+</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token function">exchangenum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exchangenumarray</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>若将自己写的两个方法中的sout写到main函数中，则只有数组交换的方法会起作用<br>因为int是基本数据类型，在java虚拟机中是栈输出，无法交换<br>int[]是引用数据类型，在java虚拟机中直接将数值地址上的值进行交换，因此int[]型的可以直接交换。</p><hr><h2 id="java-jvm-堆-栈"><a href="#java-jvm-堆-栈" class="headerlink" title="java jvm 堆 栈"></a>java jvm 堆 栈</h2><p><a href="https://blog.csdn.net/luzhensmart/article/details/82432921">点击链接查看</a></p><hr><p>##可变参数长度 </p><ol><li>它的本质还是数组,调用时可以用数组或多个实参</li><li>可变参数只能有一个，且必须放置在参数列表的最后</li><li>当我们不传参数时，默认自动封装的数组是长度为0的数组，如果强制打印该数组的值，会发生下标越界的错误<br>例子：<br>若将一个数组中的数字进行寻找最大值<br>可以轻易地写出来方法，但是如果需要在数组中的数字与额外的数字比较呢？ 这个时候就要用可变参数</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> <span class="token punctuation">(</span>temp<span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span>temp<span class="token operator">:</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s3 <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s4 <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s5 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3<span class="token punctuation">,</span>s4<span class="token punctuation">,</span>s5<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><p>从这个方法可以看出 可以使用长度可变的参数进行使用，比数组更加快捷<br>但是也有一些不足<br>比如说如果没有传入值，强制进行打印会出现数组下标越界的异常 应该在代码中添加判断，并且通过异常处理，因为返回值可能影响到其他的模块。<br>还可以添加一个boolean类型的参数，用于判断要求最大值还是最小值，此参数要写在可变长度参数之前。<br>因此 修改后的代码为：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> max<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                temp <span class="token operator">=</span> <span class="token punctuation">(</span>temp<span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span>temp<span class="token operator">:</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                temp <span class="token operator">=</span> <span class="token punctuation">(</span>temp<span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span>temp<span class="token operator">:</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s3 <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s4 <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s5 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3<span class="token punctuation">,</span>s4<span class="token punctuation">,</span>s5<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3<span class="token punctuation">,</span>s4<span class="token punctuation">,</span>s5<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><p>听课的原笔记：<br><img src="http://cdn.leafii.top/img/20220520160859.png" loading="lazy"></p><hr><h2 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h2><ol><li>手写一个数组复制的方法 低效率而且时间长 可以使用System.arraycopy()方法</li><li>数组排序手写方法很麻烦，可以使用Arrays.sort方法</li><li>数组初始化不想全都是0，可以使用Arrays.fill方法<br>代码如下:</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>a<span class="token punctuation">.</span>length<span class="token operator">+</span>a<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a数组排序前："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>            a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a数组排序后："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>               a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//从a数组的第1+1个元素开始复制元素到b数组的第4+1处，共复制4个</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a数组复制后的b数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>            b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//用Arrays.fill初始化数组：</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"初始化后："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>            c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本语法</title>
      <link href="/2020/04/01/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/04/01/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h1><h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><hr><p>1.idea中一个项目中可以包含多个module</p><hr><p>2.建类需要先建包 包的名字是公司域名的反向 </p><span id="more"></span><hr><p>例：</p><pre class="language-none"><code class="language-none">net.suncaper</code></pre><p>3.建立测试类 按ctrl+shift+T alt+Enter下载需要的东西</p><hr><p>在测试类中的方法之前加上@Test注解</p><hr><p>4.在测试类中可以添加@Before注解 使被标记的方法在所有测试方法在测试之前运行</p><hr><p>5.在测试类中可以添加@After注解 使被标记的方法在所有测试方法在测试之后运行</p><hr><h2 id="Java基础知识-1"><a href="#Java基础知识-1" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><p>1.Java中的注释类型：<br>单行注释：  &#x2F;&#x2F;<br>多行注释： &#x2F;<em>xxx</em>&#x2F;<br>文档注释（java 特有）: &#x2F;**  xxx*&#x2F;在开始的 &#x2F;** 之后，第一行或几行是关于类、变量和方法的主要描述。之后，你可以包含一个或多个何种各样的 @ 标签。每一个 @ 标签必须在一个新行的开始或者在一行的开始紧跟星号(*).<br>如：</p><pre class="language-/***" data-language="/***"><code class="language-/***">基础类* @author xx* @version v1.2 *&#x2F;</code></pre><p>注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。</p><p>文档注释：<br>例：</p><pre class="language-none"><code class="language-none">&#x2F;***注释实例*@author yys*@date 2019.9.6*&#x2F;</code></pre><p>例:</p><pre class="language-none"><code class="language-none">&#x2F;***注释实例*@param a 整数a*@param b 整数b@return a与b中的最大值*@author yys*@date 2019.9.6*&#x2F;</code></pre><p>文档注释-&gt;Tools generateJavaDoc<br>可以用这个工具 将自己的文档注释生成网页 在二次开发等都有一定的依赖<br>在Other。。。的那一栏写参数： -encoding UTF-8 -charset UTF-8 不然会因为字符编码报错</p><hr><p>2.Java变量<br>Java中的变量和方法命名的基本规范：</p><p>  变量和方法名首字母小写,驼峰式<br>  类名首字母大写，驼峰式<br>  常量全大写，划线式<br>例子：</p><pre class="language-none"><code class="language-none">public class TestJavaBasic&#123;    public static final String STUDENT_NUMBER &#x3D; &quot;2345&quot;;    public void getMax()&#123;    int myAge &#x3D; 0;    &#x2F;&#x2F;int my_age &#x3D; 0； 不要使用这种划线式 要使用驼峰式     &#x2F;&#x2F;当一门语言如果不支持大小写的情况下，比如VB&#125;&#125;</code></pre><p>Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符，凡是自己可以起名字的地方都叫标识符。</p><p>定义合法标识符规则</p><p>由26个英文字母大小写，数字：0-9 ，_或 $ 组成 </p><p>数字不可以开头。</p><p>不可以使用关键字和保留字，但能包含关键字和保留字。</p><p>Java中严格区分大小写，长度无限制。</p><p>标识符不能包含空格。</p><p>注意：在起名字的时，为了提高阅读性，要尽量有意义，“见名知意”。</p><p>关键字：</p><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）特点：关键字中所有字母都为小写<br>常用关键字：</p><pre class="language-none"><code class="language-none">用于定义数据类型的关键字:class,interface,enum,byte,short,int,long,float,double,char,boolean,void用于定义数据类型值的关键字:true,false,null用于定义流程控制的关键字：if，else，switch，case，default，while，do，for，break，continue，return用于定义访问权限修饰符的关键字：private，protected，public用于定义类，函数，变量修饰符的关键字：abstract，final，static，synchronized用于定义类与类之间关系的关键字：extends，implements用于定义建立实例及引用实例，判断实例的关键字：new，this，super，instanceof用于异常处理的关键字：try，catch，finally，throw，throws用于包的关键字：package，import其他修饰符关键字：native，strictfp，transient，volatile，assert</code></pre><p>注：java中的常量所谓常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</p><h2 id="Java中的变量"><a href="#Java中的变量" class="headerlink" title="Java中的变量"></a>Java中的变量</h2><p>1).变量的定义</p><p>变量的概念：</p><p>内存中的一个存储区域。该区域有自己的名称（变量名）和类型（数据类型）。Java中每个变量必须先声明，后使用。该区域的数据可以在同一类型范围内不断变化。</p><p>定义变量的格式：</p><p>数据类型    变量名  &#x3D;  初始化值</p><p>使用变量注意：</p><p>变量是通过使用变量名来访问这块区域的，变量的作用域：一对{ }之间有效</p><p>2).变量的数据类型</p><p>对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。</p><table><thead><tr><th>类型</th><th>占用存储空间</th><th>表数范围</th></tr></thead><tbody><tr><td>byte</td><td>1字节</td><td>-128~127</td></tr><tr><td>short</td><td>2字节</td><td>-215~215-1</td></tr><tr><td>int</td><td>4字节</td><td>-231~231-1</td></tr><tr><td>long</td><td>8字节</td><td>-263~263-1</td></tr></tbody></table><p>浮点类型：float、double</p><p>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度。</p><p>Java 的浮点型常量默认为 double 型，声明 float 型常量，须后加 ‘f’ 或 ‘F’。</p><p>字符类型：char</p><p>char 型数据用来表示通常意义上”字符”。</p><p>字符型常量的三种表现形式：</p><p>字符常量是用单引号(‘ ’)括起来的单个字符，涵盖世界上所有书面语的字符。例如：char c1 &#x3D; ‘a’;   char c2 &#x3D; ‘中’; char c3 &#x3D;  ‘9’;</p><p>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例如：char c3 &#x3D; ‘\n’;  – ‘\n’表示换行符</p><p>直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个十六进制整数。如：\u000a 表示 \n。</p><p>char 类型是可以进行运算的。因为它都对应有 Unicode 值。</p><p>布尔类型：boolean</p><p>boolean 类型适于逻辑运算，一般用于程序流程控制：</p><p>if条件控制语句；while循环控制语句；do-while循环控制语句；for循环控制语句；</p><p>boolean类型数据只允许取值true和false，不可以0或非 0 的整数替代true和false，这点和C语言不同。</p><hr><p>基本数据类型转换</p><p>自动类型转换</p><p>容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：<br>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double<br>           char-&gt;int</p><hr><p>强制类型转换</p><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符（()），()中写转换的目标类型，但可能造成精度降低或溢出,格外要注意。</p><p>如将3.14转化为int类型：(int)3.14.<br>boolean类型不可以转换为其它的数据类型。 </p><hr><p>结论<br>&#x2F;&#x2F; byte short int long float doubl<br>a . 从左至右称为扩宽类型，把左边类型直接赋值给右边类型，称为自动转换，反之需要强转<br>b. 表达式运算结果的最低级别是int 类型</p><hr><p>变量的作用域<br>变量的作用域：一对{ }之间有效</p><hr><p>double小数取后三位  并四舍五入</p><pre class="language-none"><code class="language-none">@Testpublic void change2()&#123;        double a &#x3D; 3.2343543345;    a &#x3D; (int)(a * 1000 + 0.5)&#x2F;1000.0;      System.out.println(a);    &#125;</code></pre><p>简单的对称加密（使用了^运算符）^-^</p><pre class="language-none"><code class="language-none">@Test    public void testYiHuo()&#123;&#x2F;&#x2F;用于简单的对称加密        int old &#x3D; 5201314;        int pwd &#x3D; 6110;&#x2F;&#x2F;密钥        int b &#x3D; old^pwd;&#x2F;&#x2F;加密后的值        System.out.println(b);        int New &#x3D; b^pwd;        System.out.println(New);&#x2F;&#x2F;解密后的值        System.out.println(New &#x3D;&#x3D; old);    &#125;</code></pre><hr><p> java运算符<br> 算术运算符：a++是先使用a的值 再自增<br>                a–是先自增 再使用a的值<br>                例</p>  <pre class="language-none"><code class="language-none">@Testpublic void change2()&#123;    int a &#x3D; 3;    int b &#x3D; a++   &#x2F;&#x2F;a&#x3D;4 b&#x3D;3            + a++ &#x2F;&#x2F;a&#x3D;5 b&#x3D;3+4            + ++a&#x2F;&#x2F;a&#x3D;6 b&#x3D;7+6            + a++&#x2F;&#x2F;a&#x3D;7 b&#x3D;13+6            + ++a&#x2F;&#x2F;a&#x3D;8 b&#x3D;19+8            + a++;&#x2F;&#x2F;a&#x3D;9 b&#x3D;27+8&#x3D;35    System.out.println(a);&#x2F;&#x2F;9    System.out.println(b);&#x2F;&#x2F;35&#125;</code></pre><p>比较运算符 结果都是boolean型<br>instanceof是检查是否是类的对象<br>实例：</p><pre class="language-none"><code class="language-none">&quot;Hello&quot; instanceof String&#x2F;&#x2F;结果为True</code></pre><p> 逻辑运算符中<br>“&amp;”和“&amp;&amp;”的区别：<br>单&amp;时，左边无论真假，右边都进行运算；<br>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。<br>和“||”的区别同理，双或时，左边为真，右边不参与运算。<br>异或( ^ )与或( | )的不同之处是：对于 ^ 而言，当左右都为true时，结果为false。</p><hr><p>三目运算符<br>格式:     (条件表达式)?表达式1：表达式2；</p><p>如果条件为true，运算后的结果是表达式1；</p><p>如果条件为false，运算后的结果是表达式2；<br>例：</p><pre class="language-none"><code class="language-none">@Test    public int Demo(int a,int b)&#123;        return (a&gt;b)?a:b;    &#125;    </code></pre><hr><h2 id="选择结构语句"><a href="#选择结构语句" class="headerlink" title="选择结构语句"></a>选择结构语句</h2><p>if语句<br>if-else语句<br>if-else if-else语句<br>switch语句<br>例：</p><pre class="language-none"><code class="language-none">switch(expression)&#123;       case value1 : &#x2F;&#x2F;语句                 break; &#x2F;&#x2F;可选       case value2 : &#x2F;&#x2F;语句                 break; &#x2F;&#x2F;可选       case value3 : &#x2F;&#x2F;语句                 break; &#x2F;&#x2F;可选       default : &#x2F;&#x2F;可选 &#x2F;&#x2F;语句&#125;</code></pre><h2 id="逻辑语句结构"><a href="#逻辑语句结构" class="headerlink" title="逻辑语句结构"></a>逻辑语句结构</h2><p>while循环<br>注：要先写i++等语句<br>do while循环 至少执行一次<br>break 语句：<br>break语句用于终止某个语句块的执行</p><p>break循环默认只能跳出属于break自己的内循环<br>再jdk1.6之前 若想跳出循环 需要在原有的循环代码</p><pre class="language-none"><code class="language-none">@Test public void Demo()&#123;     for (int i &#x3D; 1; i &lt;&#x3D;5; i++) &#123;         for (int j &#x3D; 1; j &lt;&#x3D;10 ; j++) &#123;             System.out.println(&quot;你好&quot;);             if(j&#x3D;&#x3D;3)&#123;                 break;             &#125;         &#125;     &#125; &#125;</code></pre><p>修改为</p><pre class="language-none"><code class="language-none">@Test    public void Demo()&#123;        boolean isBr &#x3D; true;        for (int i &#x3D; 1; i &lt;&#x3D;5&amp;&amp;isBr; i++) &#123;            for (int j &#x3D; 1; j &lt;&#x3D;10 ; j++) &#123;                System.out.println(&quot;你好&quot;);                if(j&#x3D;&#x3D;3)&#123;                    isBr&#x3D;false;                    break;                &#125;            &#125;        &#125;    &#125;</code></pre><p> 如果是在jdk1.6之后的版本 可以选择给每一个循环起一个别名</p> <pre class="language-none"><code class="language-none"> @Testpublic void Demo()&#123;    forA:for (int i &#x3D; 1; i &lt;&#x3D;5; i++) &#123;        forB:for (int j &#x3D; 1; j &lt;&#x3D;10 ; j++) &#123;            System.out.println(&quot;你好&quot;);            if(j&#x3D;&#x3D;3)&#123;                break forA;            &#125;        &#125;    &#125;&#125;</code></pre><p> continue语句:<br>continue语句用于跳过某个循环语句块的一次执行<br>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</p><p>–</p><h2 id="函数（方法）"><a href="#函数（方法）" class="headerlink" title="函数（方法）"></a>函数（方法）</h2><p>什么是函数<br>函数声明：<br>访问权限  返回值类型 函数名（参数类型 形式参数1，参数类型 形式参数2，….）｛<br>          程序代码<br>     return 返回值；<br>｝<br>其中：<br>形式参数：在方法被调用时用于接收外部传入的数据的变量。<br>参数类型：就是该形式参数的数据类型。<br>返回值：方法在执行完毕后返还给调用它的程序的数据。<br>返回值类型：函数要返回的结果的数据类型。<br>实参：调用函数时实际传给函数形式参数的数据。<br>2).函数的重载<br>函数的重载就是在同一个类中允许同时存在一个以上的同名函数，只要它们的参数个数或类型不同即可。<br>在同一个类中可以定义多个同名方法—方法名重载(overload)。<br>例子：</p><pre class="language-none"><code class="language-none">public class Test&#123;       public static void main(String [] args)&#123;        int isum;        double fsum;        isum&#x3D;add(3,5);        isum&#x3D;add(3,5,6);        fsum&#x3D;add(3.2,6.5);       &#125;      public static int add(int x,int y)         &#123;  reutrn x+y; &#125;      public static int add(int x,int y,int z)   &#123; return x+y+z; &#125;      public static double add(double x,double y)&#123;  return x+y; &#125;    &#125;</code></pre><p>注：<br>重载方法的参数列表必须不同<br>重载方法的返回值类型可以相同，也可以不同<br>调用时根据方法的参数类型来区别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Java</title>
      <link href="/2020/03/30/%E5%88%9D%E8%AF%86Java/"/>
      <url>/2020/03/30/%E5%88%9D%E8%AF%86Java/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Java"><a href="#初识Java" class="headerlink" title="初识Java"></a>初识Java</h1><h2 id="JDK的下载安装"><a href="#JDK的下载安装" class="headerlink" title="JDK的下载安装"></a>JDK的下载安装</h2><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">jdk下载地址</a> </p><p>点击同意协议，然后点击相应的操作系统进行下载。</p><p><a href="https://jingyan.baidu.com/article/fd8044fa2c22f15031137a2a.html">javajdk的教程</a></p><h2 id="写java的helloworld"><a href="#写java的helloworld" class="headerlink" title="写java的helloworld"></a>写java的helloworld</h2><span id="more"></span><p>A：在任意盘符中创建一个Test.java的文件(这个文件也被称之为Test程序的源文件，我么java程序的源文件都是以.java命名的)。</p><p>B: 定义类(类名必须与源文件前缀名一致)<br>    格式：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre><p>C: 写main方法<br>   在大括号中间添加一个主(main)方法&#x2F;函数<br>   格式：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre><p>D: 写输出语句<br>在主方法的大括号中间添加一行输出语句 格式：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>quot<span class="token punctuation">;</span><span class="token class-name">HelloWorld</span><span class="token operator">&amp;</span>quot<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>quot<span class="token punctuation">;</span><span class="token class-name">HelloWorld</span><span class="token operator">&amp;</span>quot<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>          </code></pre><p>E:编译和运行程序<br>使用javac命令编译Test源文件，生成字节码文件(后缀名为.class)javac：将.java文件编译为.class文件语法格式：javac -d destdir srcFile注意：-d destdir是用来指定存放编译生成的.class文件的路径。（若此选项省略，那么默认在当前目录下生成.class文件，并且没有生成包文件夹；当前目录可以用“.”来表示，即：javac -d . srcFile ），srcFile是用来指定存放要编译的java文件路径。进入jdk的bin目录，执行javac命令，执行完成后会得到一个.class文件!</p><p>使用java命令对class字节码文件进行解释运行语法格式：java -classpath 类路径 全类名下午：讲了一个关于classpath参数的案例 在一个文件夹里建立aa.AA bb.BB两个java类 BB调用AA如果想要编译这两个类 要先编译前一个被调用的类 再编译后一个被调用的类<br>AA.java:</p><pre class="language-package" data-language="package"><div class="caption"><span>aa;</span></div><code class="language-package">public class AA&#123;       public static void main(String[] args)     &#123;            System.out.println(&quot;aaaaaaa&quot;);               &#125;&#125;</code></pre><p>BB.java:</p><pre class="language-none"><code class="language-none">package bb;public class AA&#123;    public static void main(String[] args) &#123;        aa.AA o &#x3D; new aa.AA();        System.out.println(&quot;aaaaaaa&quot;);    &#125;&#125; </code></pre><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>分别编译AA和BB<br>    把AA编译到C盘<br>    把BB编译到D盘</p><p>分别编译两个类</p><pre class="language-javac" data-language="javac"><div class="caption"><span>-encoding UTF-8 -d c:// aa.java</span></div><code class="language-javac">javac -encoding UTF-8 -d d:&#x2F;&#x2F; -classpath c:&#x2F;&#x2F; BB.java</code></pre><p>或者</p><pre class="language-none"><code class="language-none">javac -encoding UTF-8 -d d:&#x2F;&#x2F; -cp c:&#x2F;&#x2F; BB.java</code></pre><p>运行两个类</p><pre class="language-none"><code class="language-none">D:\yys\day01\bb&gt;java -classpath c:&#x2F;&#x2F; aa.AAaaaaaaaD:\yys\day01\bb&gt;java -classpath c:&#x2F;&#x2F;;d:&#x2F;&#x2F; bb.BBbbbbbb</code></pre><hr><h2 id="打jar包操作"><a href="#打jar包操作" class="headerlink" title="打jar包操作"></a>打jar包操作</h2><p>可通过将编译后的class文件压缩为jar包进行使用</p><p> jar 是一种普通的zip 压缩文件，只是后缀名是jar,是Java语言中重要的归档方式 。<br> jar cvf mymy.jar *   &#x2F;&#x2F;把当前路径下的所有东西归档到mymy.jar 中。<br> 可执行jar包<br>       写一个有可视化界面的代码</p><pre class="language-none"><code class="language-none">package net.suncaper;public class MainFrame&#123;   public static void main(String[] args)&#123;               System.out.println(&quot;这是带有图形化界面的程序&quot;);                javax.swing.JOptionPane.showMessageDialog(null,&quot;我是一个白痴，很可爱&quot;,&quot;标题&quot;,javax.swing.JOptionPane.PLAIN_MESSAGE);            &#125; &#125;</code></pre><p>编译写一个清单文件，目的指定运行的主类<br>Main-Class: net.suncaper.MainFrame<br>语法很严格，中间有一个空格，末尾只能换一样<br>例子:  F:\ftproot\class_code\testcode&gt;jar cvfm myfirstrun.jar ..&#x2F;mainf *<br>运行: java -jar myfirstrun.jar<br>可以编写批处理文件，类似实现可执行文件。</p><hr><h2 id="idea的安装使用"><a href="#idea的安装使用" class="headerlink" title="idea的安装使用"></a>idea的安装使用</h2><p>.IDEA常用快捷键<br>ctrl+Y  ：删除行<br>ctrl+&#x2F;   ：单行注释<br>ctrl+shift +&#x2F;   ：多行注释<br>ctrl + D ：复制行<br>ctrl+shift + 上下方向键  ：交换行<br>ctrl + alt + L ：格式化:<br>ctrl+shift +  F12 ：最大最小化编辑窗口<br>按住鼠标滚轮键：列模式编辑<br>alt + Enter：自动纠错，可以用于自动导入包:<br>alt + insert：代码快速插入生成代码<br>ctlr+h:打开类的继承视图<br>ctrl+ alt + o: 清理import<br>ctrl + F12：查看类的结构<br>ctrl + F: 本文件中搜索<br>ctrl + R: 本文件中替换<br>ctrl + shift + T: 快速创建一个单元测试单元测试</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown入门</title>
      <link href="/2020/03/30/MarkDown%E5%85%A5%E9%97%A8/"/>
      <url>/2020/03/30/MarkDown%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="MarkDown入门"><a href="#MarkDown入门" class="headerlink" title="MarkDown入门"></a>MarkDown入门</h2><ol start="0"><li>目录<br>在md文件的最前方添加</li></ol><pre class="language-none"><code class="language-none">[TOC]</code></pre><p>  可以根据标题生成目录 </p><ol><li>斜体和粗体</li></ol> <pre class="language-none"><code class="language-none">*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~</code></pre><p> 显示效果：<br> <em>斜体</em>或_斜体_<br><strong>粗体</strong><br><em><strong>加粗斜体</strong></em><br><del>删除线</del></p><span id="more"></span><ol start="2"><li>分级标题<br>可使用</li></ol><pre class="language-none"><code class="language-none"># 一级标题## 二级标题...###### 六级标题</code></pre><p>或者</p><pre class="language-none"><code class="language-none">这是一个一级标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;这是一个二级标题--------------------------------------------------</code></pre><ol start="3"><li>超链接<br>3.1 行内式<br> 语法说明：</li></ol><ul><li>[]里写链接文字，()里写链接地址, ()中的””中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字]&#x2F;(链接地址 “链接标题”)这样的形式。链接地址与链接标题前有一个空格。(忽略&#x2F;)</li></ul><pre class="language-none"><code class="language-none">欢迎来到[迟道的主页](http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;de4923b06bfc)欢迎来到[迟道的主页](http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;de4923b06bfc &quot;迟道的主页&quot;)</code></pre><p>显示效果：<br>欢迎来到<a href="http://www.jianshu.com/u/de4923b06bfc">迟道的主页</a><br>欢迎来到<a href="http://www.jianshu.com/u/de4923b06bfc" title="迟道的主页">迟道的主页</a></p><p>3.2 参考式</p><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。<br>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。<br>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。<br>code：</p><pre class="language-none"><code class="language-none">我经常去的几个网站[GitHub][1]、[知乎][2]以及[简书][3][简书][3]是一个不错的[写作社区][]。[1]:https:&#x2F;&#x2F;github.com &quot;GitHub&quot;[2]:https:&#x2F;&#x2F;www.zhihu.com &quot;知乎&quot;[3]:http:&#x2F;&#x2F;www.jianshu.com &quot;简书&quot;[写作社区]:http:&#x2F;&#x2F;www.jianshu.com</code></pre><p>显示效果：<br>我经常去的几个网站[GitHub][1]、[知乎][2]以及[简书][3][简书][3]是一个不错的[写作社区][]。<br>[1]:<a href="https://github.com/">https://github.com</a> “GitHub”[2]:<a href="https://www.zhihu.com/">https://www.zhihu.com</a> “知乎”[3]:<a href="http://www.jianshu.com/">http://www.jianshu.com</a> “简书”[写作社区]:<a href="http://www.jianshu.com/">http://www.jianshu.com</a><br>3.3 自动链接<br>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：<br>code：</p><pre class="language-none"><code class="language-none">&lt;http:&#x2F;&#x2F;example.com&#x2F;&gt;&lt;address@example.com&gt;</code></pre><p>显示效果：<br><a href="http://example.com/">http://example.com/</a><br><a href="mailto:&#97;&#100;&#100;&#114;&#101;&#115;&#x73;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#111;&#109;">&#97;&#100;&#100;&#114;&#101;&#115;&#x73;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#111;&#109;</a></p><ol start="4"><li>列表<br>4.1 无序列表<br>使用 *，+，- 表示无序列表。</li></ol><pre class="language-none"><code class="language-none">- 无序列表项 一- 无序列表项 二- 无序列表项 三</code></pre><hr><p>显示效果：</p><ul><li>无序列表项 一</li><li>无序列表项 二</li><li>无序列表项 三<br>5.2 有序列表</li></ul><p>有序列表则使用数字接着一个英文句点。<br>代码：</p><pre class="language-none"><code class="language-none">1. 有序列表项 一2. 有序列表项 二3. 有序列表项 三</code></pre><p>显示效果：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三<br>5.3 定义型列表<br>语法说明：<br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)<br>代码：</li></ol><pre class="language-none"><code class="language-none">Markdown:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）代码块 2:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）        代码块（左侧有八个不可见的空格）</code></pre><dl><dt>显示效果：<br>Markdown</dt><dd>轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><dl><dt>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><pre><code>    代码块（左侧有八个不可见的空格）</code></pre><ol start="6"><li>表格</li></ol><p>语法说明：<br>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br>code：<br>简单方式写表格：</p><pre class="language-none"><code class="language-none">学号|姓名|分数-|-|-小明|男|75小红|女|79小陆|男|92</code></pre><p>原生方式写表格：</p><pre class="language-none"><code class="language-none">|学号|姓名|分数||-|-|-||小明|男|75||小红|女|79||小陆|男|92|</code></pre><p>为表格第二列指定方向：</p><pre class="language-none"><code class="language-none">产品|价格-|-:Leanote 高级账号|60元&#x2F;年Leanote 超级账号|120元&#x2F;年</code></pre><p>显示效果：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><table><thead><tr><th>产品</th><th align="right">价格</th></tr></thead><tbody><tr><td>Leanote 高级账号</td><td align="right">60元&#x2F;年</td></tr><tr><td>Leanote 超级账号</td><td align="right">120元&#x2F;年</td></tr></tbody></table><p>注：合并表格单元格可以使用html原生代码</p><ol start="7"><li>分隔线<br>代码：</li></ol><pre class="language-none"><code class="language-none">* * *********- - ----------------------------------------</code></pre><p>显示效果都一样：</p><ol start="8"><li>插入代码<br>语法说明：<br>插入行内代码，即插入一个单词或者一句代码的情况，使用<code>code</code>这样的形式插入。<br>插入多行代码，可以使用缩进或者<code>code</code>,具体看示例。</li></ol><pre class="language-none"><code class="language-none">在三个引号后面可以添加代码的语言 可以高亮显示所选语言的语法</code></pre><ol start="9"><li>插入图片<br>code：</li></ol><pre class="language-none"><code class="language-none">![图片名称]（链接）</code></pre><ol start="10"><li>任务列表<br>代码：</li></ol><pre class="language-none"><code class="language-none">近期任务安排:- [x] 整理Markdown手册- [ ] 改善项目   - [x] 优化首页显示方式   - [x] 修复闪退问题   - [ ] 修复视频卡顿- [ ] A3项目修复   - [x] 修复数值错误</code></pre><p>效果：</p><p>近期任务安排:</p><ul><li><input checked="" disabled="" type="checkbox"> 整理Markdown手册</li><li><input disabled="" type="checkbox"> 改善项目<ul><li><input checked="" disabled="" type="checkbox"> 优化首页显示方式</li><li><input checked="" disabled="" type="checkbox"> 修复闪退问题</li><li><input disabled="" type="checkbox"> 修复视频卡顿</li></ul></li><li><input disabled="" type="checkbox"> A3项目修复<ul><li><input checked="" disabled="" type="checkbox"> 修复数值错误</li></ul></li></ul><hr><p>附录： [完整markdown笔记](</p>]]></content>
      
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git与Gitee环境配置</title>
      <link href="/2020/03/30/Git%E4%B8%8EGitee%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/30/Git%E4%B8%8EGitee%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>gitee受到不可抗力已无法实现有效开源，建议只作为代码仓库使用</strong></p><span id="more"></span><h2 id="配置git与gitee连接"><a href="#配置git与gitee连接" class="headerlink" title="配置git与gitee连接"></a>配置git与gitee连接</h2><h3 id="1-下载-amp-安装git"><a href="#1-下载-amp-安装git" class="headerlink" title="1.下载&amp;安装git"></a>1.下载&amp;安装git</h3><p>[Git官网](<a href="https://git-scm.com/">Git (git-scm.com)</a>)</p><p>按照自己的操作系统进行下载安装，如Windows就下载Windows版本的安装包，下载速度慢的话可以用bitcomit或者迅雷进行下载，速度海星&#x3D;-&#x3D;</p><p>双击安装包，将安装包安装在自己定义的路径（最好别有中文），新手的话定义完自定义就一直next就可以了吧……（gitee官方教程原文：请注意，如果你不熟悉每个选项的意思，请保持默认的选项）</p><p>安装完毕后 （如果以上一切正常，打开终端(Window下请打开安装git时一并安装的bash) 输入 git –version <strong>应该会显示如下类似的信息</strong>）</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">git version 2.5.0</code></pre><h3 id="2-配置git默认参数"><a href="#2-配置git默认参数" class="headerlink" title="2.配置git默认参数"></a>2.配置git默认参数</h3><p>( 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 <code>C:\Documents and Settings\$USER</code>。此外，Git 还会尝试找寻 &#x2F;etc&#x2F;gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。)</p><p>使用以上代码进行用户名和邮箱的配置</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"John Doe"</span>$ <span class="token function">git</span> config --global user.email johndoe@example.com</code></pre><p>使用以下命令使客户端记住密码以便使用https进行仓库的推拉</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global credential.helper store</code></pre><p>可以使用git config –list命令对当前已有的配置信息进行检查</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --listuser.name<span class="token operator">=</span>Scott Chaconuser.email<span class="token operator">=</span>schacon@gmail.comcolor.status<span class="token operator">=</span>autocolor.branch<span class="token operator">=</span>autocolor.interactive<span class="token operator">=</span>autocolor.diff<span class="token operator">=</span>auto<span class="token punctuation">..</span>.</code></pre><h3 id="3-配置ssh公钥（SSHKey）"><a href="#3-配置ssh公钥（SSHKey）" class="headerlink" title="3.配置ssh公钥（SSHKey）"></a>3.配置ssh公钥（SSHKey）</h3><p>使用以下代码创建一个sshkey：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -C <span class="token string">"youremail@youremail.com"</span>  <span class="token comment"># Generating public/private rsa key pair...</span><span class="token comment"># 三次回车即可生成 ssh key</span></code></pre><p>创建成功后使用cat命令查看公钥（public key)</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> ~/.ssh/id_rsa.pub</code></pre><p>将显示的内容添加到gitee的公钥页面中：</p><p><img src="http://cdn.leafii.top/img/20220520155623.png" loading="lazy"></p><p>添加后，测试一下是否添加成功:</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#Gitee</span>$ <span class="token function">ssh</span> -T git@gitee.com<span class="token comment">#GitHub</span>$ <span class="token function">ssh</span> -T git@github.com</code></pre><p>第一次会询问你是否进行contiune，记得输入yes！</p><p>成功后的一般是这样</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#Gitee</span>Welcome to Gitee.com, YourName<span class="token operator">!</span><span class="token comment">#GitHub</span>You've successfully authenticated, but GitHub does not provide shell access.</code></pre><h2 id="Git常用操作"><a href="#Git常用操作" class="headerlink" title="Git常用操作"></a>Git常用操作</h2><h3 id="在工作目录中初始化新仓库"><a href="#在工作目录中初始化新仓库" class="headerlink" title="在工作目录中初始化新仓库"></a>在工作目录中初始化新仓库</h3><p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> init</code></pre><p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。（在第九章我们会详细说明刚才创建的 .git 目录中究竟有哪些文件，以及都起些什么作用。）</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> *.c$ <span class="token function">git</span> <span class="token function">add</span> README$ <span class="token function">git</span> commit -m <span class="token string">'initial project version'</span></code></pre><p>稍后我们再逐一解释每条命令的意思。不过现在，你已经得到了一个实际维护着若干文件的 Git 仓库。</p><h3 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h3><p>克隆仓库的命令格式为 <strong><code>git clone [url]</code></strong> 。比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone git@gitee.com:oschina/git-osc.git</code></pre><p>这会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。如果进入这个新建的 grit 目录，你会看到仓库中的所有文件已经在里边了，准备好后续的开发和使用。如果希望在克隆的时候，自己定义要新建的仓库目录名称，可以在上面的命令末尾指定新的名字：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone git@gitee.com:oschina/git-osc.git mygrit</code></pre><p>唯一的差别就是，现在新建的目录成了 mygrit，其他的都和上边的一样。</p><h3 id="其他常用基础操作"><a href="#其他常用基础操作" class="headerlink" title="其他常用基础操作"></a>其他常用基础操作</h3><p><a href="https://gitee.com/help/articles/4114#article-header0">Git 仓库基础操作</a></p><hr><p>引用：</p><p><a href="https://www.cnblogs.com/yiven/p/8465054.html">入门级 - 码云（Gitee），GitHub 教程 - Yiven</a></p><p>[Git 知识大全 - Gitee.com](</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用nvm进行Nodejs安装</title>
      <link href="/2020/03/30/%E4%BD%BF%E7%94%A8nvm%E8%BF%9B%E8%A1%8CNodejs%E5%AE%89%E8%A3%85/"/>
      <url>/2020/03/30/%E4%BD%BF%E7%94%A8nvm%E8%BF%9B%E8%A1%8CNodejs%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="nvm的安装和使用"><a href="#nvm的安装和使用" class="headerlink" title="nvm的安装和使用"></a>nvm的安装和使用</h2><h3 id="为什么要使用nvm？"><a href="#为什么要使用nvm？" class="headerlink" title="为什么要使用nvm？"></a>为什么要使用nvm？</h3><p>有时候需要特定版本的nodejs，但是没有必要卸载原有的nodejs，可以使用nvm（全名node.js version management，顾名思义，一个nodejs的版本管理工具）同时在电脑上安装多个版本的nodejs，并且启用合适版本的nodejs。</p><span id="more"></span><h3 id="nvm的下载"><a href="#nvm的下载" class="headerlink" title="nvm的下载"></a>nvm的下载</h3><p>点击此链接进行下载：<a href="https://github.com/coreybutler/nvm-windows/releases">Releases · coreybutler&#x2F;nvm-windows (github.com)</a> （建议下载安装版，不需要复杂的配置）</p><p>下载成功后解压，双击安装包，进行安装，选择合适的非中文路径进行安装，然后选择nodejs的安装路径，确认安装。</p><p>安装成功后打开cmd，输入nvm，如果安装成功，在窗口中会如此显示：</p><p><img src="http://cdn.leafii.top/img/20220520155537.png" loading="lazy"></p><h2 id="安装-x2F-管理nodejs"><a href="#安装-x2F-管理nodejs" class="headerlink" title="安装&#x2F;管理nodejs"></a>安装&#x2F;管理nodejs</h2><h3 id="查看本地所有已经安装的nodejs"><a href="#查看本地所有已经安装的nodejs" class="headerlink" title="查看本地所有已经安装的nodejs"></a>查看本地所有已经安装的nodejs</h3><p>有可选参数available，显示所有可下载的版本。</p><pre class="language-none"><code class="language-none">nvm list [available]</code></pre><p><img src="http://cdn.leafii.top/img/20220520155550.png" loading="lazy"></p><h3 id="安装特定版本的nodejs"><a href="#安装特定版本的nodejs" class="headerlink" title="安装特定版本的nodejs"></a>安装特定版本的nodejs</h3><pre class="language-none"><code class="language-none">nvm install 12.14.0</code></pre><h3 id="使用特定版本的nodejs"><a href="#使用特定版本的nodejs" class="headerlink" title="使用特定版本的nodejs"></a>使用特定版本的nodejs</h3><pre class="language-none"><code class="language-none">nvm use 12.14.0</code></pre><h3 id="卸载特定版本的nodejs"><a href="#卸载特定版本的nodejs" class="headerlink" title="卸载特定版本的nodejs"></a>卸载特定版本的nodejs</h3><pre class="language-none"><code class="language-none">nvm uninstall 12.14.0</code></pre><h2 id="nvm或者npm下载速度低的解决办法"><a href="#nvm或者npm下载速度低的解决办法" class="headerlink" title="nvm或者npm下载速度低的解决办法:"></a>nvm或者npm下载速度低的解决办法:</h2><ol><li><p>打开cmd，输入where nvm 找到nvm的安装路径</p></li><li><p>使用文件资源管理器打开该路径下的settings.txt文件</p></li><li><p>将以下代码复制到settings.txt中，配置淘宝镜像为npm和nvm的默认下载镜像，下载速度就会超级快哦</p></li></ol><pre class="language-none"><code class="language-none">node_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;npm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;</code></pre><hr><p>引用：</p><p><a href="https://www.cnblogs.com/gaozejie/p/10689742.html">nvm安装与使用 - #Empty - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq_32754575/article/details/102412473">nvm下载太慢问题解决_大大的叹号的博客-CSDN博客_nvm下载慢</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置Hexo博客并部署到Gitee</title>
      <link href="/2020/03/30/%E9%85%8D%E7%BD%AEHexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0Gitee/"/>
      <url>/2020/03/30/%E9%85%8D%E7%BD%AEHexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0Gitee/</url>
      
        <content type="html"><![CDATA[<h2 id="部署hexo静态博客到Gitee中"><a href="#部署hexo静态博客到Gitee中" class="headerlink" title="部署hexo静态博客到Gitee中"></a>部署hexo静态博客到Gitee中</h2><p><strong>由于不可抗力，Gitee的pages服务无法自定义域名，因此建议直接部署到Github上而不是Gitee中，并自己做好备份</strong></p><span id="more"></span><p><strong>本文章假定你已经使用了nvm安装了nodejs12.14.0，并且已经配置了git以及gitee上的ssh密钥</strong></p><hr><h3 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1.安装Hexo"></a>1.安装Hexo</h3><p>在gitbash或者cmd中输入命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo   <span class="token comment"># 通过npm安装hexo</span><span class="token comment"># -g 指定全局安装，可以使用hexo命令</span></code></pre><h3 id="2-初始化Hexo"><a href="#2-初始化Hexo" class="headerlink" title="2.初始化Hexo"></a>2.初始化Hexo</h3><p>进入合适的目录（你要存放你hexo博客文件的地方）</p><pre class="language-bash" data-language="bash"><code class="language-bash">hexo init blog  <span class="token comment"># 初始化创建，会再桌面创建blog文件夹</span><span class="token builtin class-name">cd</span> blog    <span class="token comment"># 进入blog目录</span><span class="token function">npm</span> <span class="token function">install</span>   <span class="token comment"># 进一步安装hexo所需文件</span></code></pre><p>初始化后的文件目录及其功能如下：</p><pre class="language-none"><code class="language-none">.├── .deploy       #需要部署的文件├── node_modules  #Hexo插件├── public        #生成的静态网页文件├── scaffolds     #模板├── source        #博客正文和其他源文件等都应该放在这里|   ├── _drafts   #草稿|   └── _posts    #文章├── themes        #主题├── _config.yml   #全局配置文件└── package.json</code></pre><h3 id="3-启动Hexo"><a href="#3-启动Hexo" class="headerlink" title="3.启动Hexo"></a>3.启动Hexo</h3><pre class="language-bash" data-language="bash"><code class="language-bash">hexo clean   <span class="token comment"># 清除所有记录 /hexo c</span>hexo generate  <span class="token comment"># 生成静态网页 /hexo g</span>hexo server    <span class="token comment"># 启动服务 /hexo s</span></code></pre><p>成功启动后应该是有如下界面：</p><pre class="language-none"><code class="language-none">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ATTENTION! &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;WARN   NexT repository is moving here: https:&#x2F;&#x2F;github.com&#x2F;theme-nextWARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;WARN   It&#39;s rebase to v6.0.0 and future maintenance will resume thereWARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.</code></pre><p>此时访问<a href="http://localhost:4000/">http://localhost:4000</a> 即可在本地访问你的博客了</p><p>如果想要在任何可以上网的设备上访问你的博客，那么你就需要将你的本地Hexo博客部署到Gitee了。</p><h3 id="4-部署Hexo博客到码云（Gitee）上"><a href="#4-部署Hexo博客到码云（Gitee）上" class="headerlink" title="4.部署Hexo博客到码云（Gitee）上"></a>4.部署Hexo博客到码云（Gitee）上</h3><p>码云（gitee）：<strong><a href="https://gitee.com/">https://gitee.com/</a></strong></p><h4 id="4-1-注册码云，创建仓库"><a href="#4-1-注册码云，创建仓库" class="headerlink" title="4.1 注册码云，创建仓库"></a>4.1 注册码云，创建仓库</h4><p>输入仓库名称，其他的保持默认即可。</p><h4 id="4-2-生成-x2F-添加SSH公钥"><a href="#4-2-生成-x2F-添加SSH公钥" class="headerlink" title="4.2 生成&#x2F;添加SSH公钥"></a>4.2 生成&#x2F;添加SSH公钥</h4><p>请查看<a href="https://mikutown.gitee.io/blog/2020/12/31/%E9%85%8D%E7%BD%AEgit%E4%B8%8Egitee%E8%BF%9E%E6%8E%A5/#more">我之前的博客</a></p><h4 id="4-3-配置连接Gitee"><a href="#4-3-配置连接Gitee" class="headerlink" title="4.3 配置连接Gitee"></a>4.3 配置连接Gitee</h4><p>复制我们新创建的仓库的项目地址</p><p>复制URL到hexo的配置文件_config.yml中相应的位置</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git                        <span class="token comment"># type为git</span>  <span class="token key atrule">repo</span><span class="token punctuation">:</span> git@gitee.com<span class="token punctuation">:</span>XXXXXX/blog.git  <span class="token comment"># 仓库的 URL</span>  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master</code></pre><p><strong>注意冒号后面一定要有空格</strong></p><h4 id="4-4-部署Hexo博客"><a href="#4-4-部署Hexo博客" class="headerlink" title="4.4 部署Hexo博客"></a>4.4 部署Hexo博客</h4><p>安装自动部署发布工具hexo-deployer-git，不然部署会报错</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save</code></pre><p>在博客根目录新建deployer.sh文件，输入代码（也就是新建了一个bash脚本文件）</p><pre class="language-none"><code class="language-none">hexo cleanhexo g hexo d</code></pre><p>输入之后保存退出，在bash中部署博客就只需要执行以下命令一键部署博客</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> deployer.sh</code></pre><p>这个时候在pages里启动博客，可能会无法显示css样式，这个时候你就需要修改你的_config.yml文件了</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># URL</span><span class="token comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span><span class="token key atrule">url</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//mikutown.gitee.io/blog<span class="token comment"># 在url后面写你的博客地址</span><span class="token key atrule">root</span><span class="token punctuation">:</span> /blog<span class="token key atrule">permalink</span><span class="token punctuation">:</span> <span class="token punctuation">:</span>year/<span class="token punctuation">:</span>month/<span class="token punctuation">:</span>day/<span class="token punctuation">:</span>title/permalink_defaults<span class="token punctuation">:</span></code></pre><h3 id="5-Gitee-Pages设置"><a href="#5-Gitee-Pages设置" class="headerlink" title="5.Gitee Pages设置"></a>5.Gitee Pages设置</h3><p>在项目的服务中选择Pages选项，直接使用默认配置，点击启动即可。如下图所示</p><p><img src="http://cdn.leafii.top/img/20220520155705.png" alt="如何进入Pages服务" loading="lazy"></p><p>点击启动后：</p><p><img src="http://cdn.leafii.top/img/20220520155731.png" alt="Pages服务页面" loading="lazy"></p><p><strong>博客发布成功之后，可以访问博客地址：xxxxxx，就可通过他提供的博客地址进行访问，预览在线博客啦！！</strong></p><p>如果博客的样式不对，则需要在_config.yml中配置下博客地址和路径：</p><pre class="language-none"><code class="language-none">url: “码云提供给您的博客地址”root: &#x2F;</code></pre><p>再执行命令 <code>sh deployer.sh</code> 就可以啦，之后就是美化我们的博客了。</p><h3 id="6-博客的美化"><a href="#6-博客的美化" class="headerlink" title="6.博客的美化"></a>6.博客的美化</h3><p><a href="https://hexo.io/themes/">Hexo博客主题列表</a></p><p>下载自己喜欢的主题，可以去 github 下载压缩包然后<strong>放到博客项目根目录下的 themes 中</strong>。</p><p>然后配置 <strong>_config.yml</strong></p><pre class="language-none"><code class="language-none">theme: “您的主题文件夹完整名称”  # 这里需要注意:后面要有一个空格，名称要和theme下的主题目录名称相同。</code></pre><p>修改完成，本地运行 <code>hexo s</code> 测试成功即可上传部署到 Gitee 然后点击更新即可。</p><h3 id="7-自定义博客域名"><a href="#7-自定义博客域名" class="headerlink" title="7.自定义博客域名"></a>7.自定义博客域名</h3><p>Gitee的Pages服务为每个人的博客都定义了一个地址，在Pages页面有链接，比如我的链接就是<a href="https://mikutown.gitee.io/blog">https://mikutown.gitee.io/blog</a> ，但是有的人拥有自己的域名，希望通过自己的域名访问到自己的博客，怎么办呢？就需要你去配置自定义博客域名了。</p><h4 id="7-1-购买域名"><a href="#7-1-购买域名" class="headerlink" title="7.1 购买域名"></a>7.1 购买域名</h4><p>不做过多解释，自己去买就可以了。</p><h4 id="7-2-域名解析"><a href="#7-2-域名解析" class="headerlink" title="7.2 域名解析"></a>7.2 域名解析</h4><p>因为gitee pages pro功能下线了，无法直接通过年支付99元的方式进行自定义的域名解析，因此在这里我们将自己的域名解析到GitHub，再利用页面跳转实现输入自己的域名进入自己的gitee博客。</p><h5 id="7-2-1-Github相关配置"><a href="#7-2-1-Github相关配置" class="headerlink" title="7.2.1 Github相关配置"></a>7.2.1 Github相关配置</h5><ul><li>注册自己的github账号</li><li>将自己的电脑中的ssh密钥添加到GitHub账号里，并且测试连接ok</li><li><strong>以下操作中你的GitHub用户名均用username代替</strong></li></ul><h5 id="7-2-2-新建Github项目"><a href="#7-2-2-新建Github项目" class="headerlink" title="7.2.2 新建Github项目"></a>7.2.2 新建Github项目</h5><p>新建一个仓库，仓库名称：username.github.io,其他保持默认设置，如图所示：</p><p><img src="http://cdn.leafii.top/img/20220520155803.png" loading="lazy"></p><h5 id="7-2-3-在本地新建index-html"><a href="#7-2-3-在本地新建index-html" class="headerlink" title="7.2.3 在本地新建index.html"></a>7.2.3 在本地新建index.html</h5><p>新建的index.html文件放在文件夹名为username.github.io的文件夹中，index.html的内容为</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<span class="token operator">=</span><span class="token string">"你的Gitee静态博客地址"</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--顾名思义 这是跳转到你的Gitee静态博客地址的script--></span></code></pre><h5 id="7-2-4-将文件上传到自己的github仓库了"><a href="#7-2-4-将文件上传到自己的github仓库了" class="headerlink" title="7.2.4 将文件上传到自己的github仓库了"></a>7.2.4 将文件上传到自己的github仓库了</h5><p>在你的username.github.io文件夹中打开git bash，然后输入如下命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span class="token comment"># 初始化GitHub本地仓库</span><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token comment"># 将本地文件夹中的所有文件加到仓库中</span><span class="token function">git</span> commit -m <span class="token string">"注释语句"</span><span class="token comment"># 此处的注释语句就是对刚才的add操作的注释，此处使用commit命令将刚才add的文件commit到仓库，注释语句啥也能写，就是不能留空 不可以留空知道了吗知道了吗知道了吗知道了吗知道了吗</span></code></pre><h5 id="7-2-5-将Github仓库与本地仓库关联"><a href="#7-2-5-将Github仓库与本地仓库关联" class="headerlink" title="7.2.5 将Github仓库与本地仓库关联"></a>7.2.5 将Github仓库与本地仓库关联</h5><p>复制GitHub的仓库地址，如图：</p><p><img src="http://cdn.leafii.top/img/20220520155818.png" loading="lazy"></p><p>在username.github.io文件夹中启动的gitbash中输入代码</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin https://github.com/username/username.github.io<span class="token comment"># 后面的https链接地址换成你自己的仓库url地址，也就是上面红框中标出来的地址</span></code></pre><h6 id="7-2-6-执行pull与push操作"><a href="#7-2-6-执行pull与push操作" class="headerlink" title="7.2.6 执行pull与push操作"></a>7.2.6 执行pull与push操作</h6><p>执行以下命令</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> pull origin master<span class="token function">git</span> push -u origin master</code></pre><p>执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了。<br><strong>精髓来了：</strong><br><strong>需要注意的是push和pull类似于栈出栈压栈</strong>，而且它必须是一出一压，不能出出压压，为什么要说这个能，就是在多人共享代码的时候，有多个人同时使用或是有人使用了pull忘记了push了，以后的人再用pull就会出错，解决方案是，如果下一步应该是push了，你就敲出来git push，反之则是git pull。<br>好了，你们这些都做完了后，可以回到浏览器刷新看看是不是已经传上去了，那么最麻烦的一步就ok了，git命令的水还很深，我这一个晚上学得都是皮毛嘻嘻。</p><h5 id="7-2-7-在Github仓库中新建CNAME文件"><a href="#7-2-7-在Github仓库中新建CNAME文件" class="headerlink" title="7.2.7 在Github仓库中新建CNAME文件"></a>7.2.7 在Github仓库中新建CNAME文件</h5><p>在仓库中新建一个CNAME文件，如图所示<img src="http://cdn.leafii.top/img/20220520155838.png" loading="lazy"></p><p>文件名为CNAME，文件内容为你购买的域名，你自己的买的域名如果是leafii.top那就输入leafii.top，个人意见是不要加那些http和&#x2F;这些东西。完成这一步后，你的仓库应该有两个文件了。</p><h5 id="7-2-8-进入域名控制台进行域名解析设置"><a href="#7-2-8-进入域名控制台进行域名解析设置" class="headerlink" title="7.2.8 进入域名控制台进行域名解析设置"></a>7.2.8 进入域名控制台进行域名解析设置</h5><p>我的域名是在阿里云购买，因此以下截图来自阿里云域名控制台，在域名控制台中将@和www的域名的解析类型修改为CNAME，然后将解析地址解析为你的Github仓库名，即username.github.io，如图所示：</p><p><img src="http://cdn.leafii.top/img/20220520155855.png" loading="lazy"></p><h5 id="7-2-9-解析设置后的操作"><a href="#7-2-9-解析设置后的操作" class="headerlink" title="7.2.9 解析设置后的操作"></a>7.2.9 解析设置后的操作</h5><p>如果解析设置完毕，等待几分钟再进行是否设置成功的尝试。</p><h5 id="7-2-10-大功告成"><a href="#7-2-10-大功告成" class="headerlink" title="7.2.10 大功告成"></a>7.2.10 大功告成</h5><p>如果你们github上传错了，也可以删除的，这里就不讲了，给你们一个链接<br><a href="https://blog.csdn.net/q420225777/article/details/80697077">https://blog.csdn.net/q420225777/article/details/80697077</a></p><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/yizhixue-hx/p/12638361.html">Hexo + Gitee搭建个人博客</a></p><p><a href="https://blog.csdn.net/weixin_43419816/article/details/106246960">利用Github实现页面跳转</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
