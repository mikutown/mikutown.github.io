{"title":"leetcode60.排列序列","slug":"leetcode60-排列序列","date":"2023-09-08T09:55:28.000Z","updated":"2023-09-08T13:50:45.025Z","comments":true,"path":"api/articles/leetcode60-排列序列.json","excerpt":"题目给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;给定 n 和 k，返回第 k 个排列。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p>\n<p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p>\n<ol>\n<li><code>&quot;123&quot;</code></li>\n<li><code>&quot;132&quot;</code></li>\n<li><code>&quot;213&quot;</code></li>\n<li><code>&quot;231&quot;</code></li>\n<li><code>&quot;312&quot;</code></li>\n<li><code>&quot;321&quot;</code></li>\n</ol>\n<p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3, k &#x3D; 3\n输出：&quot;213&quot;</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 4, k &#x3D; 9\n输出：&quot;2314&quot;</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3, k &#x3D; 1\n输出：&quot;123&quot;</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 9</code></li>\n<li><code>1 &lt;= k &lt;= n!</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>思路<br>首先可以根据全排列树发现，第 iii 层的每个结点有(n - i)!个分支，对于每一层我们只需要找到第 j 个结点使得$j\\times(n - i)! \\ge k$，然后再$k&#x3D;k−(j−1)×(n−i)!$ 再然后迭代下一层以此类推。 对于找第 j 个结点可以使用状态压缩，记录之前哪些点用过了。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    \n    vector&lt;int&gt; fact;  &#x2F;&#x2F; 存储阶乘的数组\n\n    Solution(): fact(10) &#123;  &#x2F;&#x2F; 构造函数，初始化fact数组为长度10的数组\n        fact[0] &#x3D; 1;  &#x2F;&#x2F; 阶乘0的值为1\n        iota(fact.begin() + 1, fact.end(), 1);  &#x2F;&#x2F; 填充fact数组，从1到9\n        partial_sum(fact.begin(), fact.end(), fact.begin(), multiplies&lt;int&gt;());  &#x2F;&#x2F; 计算部分和，得到1!到9!的值\n    &#125;\n\n    string getPermutation(int n, int k) &#123;  &#x2F;&#x2F; 返回第k个排列的字符串\n        string res;  &#x2F;&#x2F; 存储结果的字符串\n        int state &#x3D; 0;  &#x2F;&#x2F; 表示已经使用的数字的状态\n\n        for (int i &#x3D; n - 1; ~i; -- i) &#123;  &#x2F;&#x2F; 从最高位到最低位遍历\n            int pre &#x3D; 0;  &#x2F;&#x2F; 记录前一个状态下的排列数量\n            for (int j &#x3D; 1; j &lt;&#x3D; n; ++ j) &#123;  &#x2F;&#x2F; 遍历1到n\n                if (state &gt;&gt; j &amp; 1) continue;  &#x2F;&#x2F; 如果数字已被使用，跳过\n                if (pre + fact[i] &gt;&#x3D; k) &#123;  &#x2F;&#x2F; 如果前一个状态下的排列数量加上当前位的阶乘大于等于k\n                    res.push_back(j + &#39;0&#39;);  &#x2F;&#x2F; 将当前数字加入结果字符串\n                    k -&#x3D; pre;  &#x2F;&#x2F; 更新k值\n                    state |&#x3D; 1 &lt;&lt; j;  &#x2F;&#x2F; 更新已使用数字的状态\n                    break;  &#x2F;&#x2F; 跳出内层循环\n                &#125;\n                pre +&#x3D; fact[i];  &#x2F;&#x2F; 更新前一个状态下的排列数量\n            &#125;\n        &#125;\n        return res;  &#x2F;&#x2F; 返回结果字符串\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3, k &#x3D; 3\n输出：&quot;213&quot;</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 4, k &#x3D; 9\n输出：&quot;2314&quot;</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3, k &#x3D; 1\n输出：&quot;123&quot;</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 9</code></li>\n<li><code>1 &lt;= k &lt;= n!</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>思路<br>首先可以根据全排列树发现，第 iii 层的每个结点有(n - i)!个分支，对于每一层我们只需要找到第 j 个结点使得$j\\times(n - i)! \\ge k$，然后再$k&#x3D;k−(j−1)×(n−i)!$ 再然后迭代下一层以此类推。 对于找第 j 个结点可以使用状态压缩，记录之前哪些点用过了。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    \n    vector&lt;int&gt; fact;  &#x2F;&#x2F; 存储阶乘的数组\n\n    Solution(): fact(10) &#123;  &#x2F;&#x2F; 构造函数，初始化fact数组为长度10的数组\n        fact[0] &#x3D; 1;  &#x2F;&#x2F; 阶乘0的值为1\n        iota(fact.begin() + 1, fact.end(), 1);  &#x2F;&#x2F; 填充fact数组，从1到9\n        partial_sum(fact.begin(), fact.end(), fact.begin(), multiplies&lt;int&gt;());  &#x2F;&#x2F; 计算部分和，得到1!到9!的值\n    &#125;\n\n    string getPermutation(int n, int k) &#123;  &#x2F;&#x2F; 返回第k个排列的字符串\n        string res;  &#x2F;&#x2F; 存储结果的字符串\n        int state &#x3D; 0;  &#x2F;&#x2F; 表示已经使用的数字的状态\n\n        for (int i &#x3D; n - 1; ~i; -- i) &#123;  &#x2F;&#x2F; 从最高位到最低位遍历\n            int pre &#x3D; 0;  &#x2F;&#x2F; 记录前一个状态下的排列数量\n            for (int j &#x3D; 1; j &lt;&#x3D; n; ++ j) &#123;  &#x2F;&#x2F; 遍历1到n\n                if (state &gt;&gt; j &amp; 1) continue;  &#x2F;&#x2F; 如果数字已被使用，跳过\n                if (pre + fact[i] &gt;&#x3D; k) &#123;  &#x2F;&#x2F; 如果前一个状态下的排列数量加上当前位的阶乘大于等于k\n                    res.push_back(j + &#39;0&#39;);  &#x2F;&#x2F; 将当前数字加入结果字符串\n                    k -&#x3D; pre;  &#x2F;&#x2F; 更新k值\n                    state |&#x3D; 1 &lt;&lt; j;  &#x2F;&#x2F; 更新已使用数字的状态\n                    break;  &#x2F;&#x2F; 跳出内层循环\n                &#125;\n                pre +&#x3D; fact[i];  &#x2F;&#x2F; 更新前一个状态下的排列数量\n            &#125;\n        &#125;\n        return res;  &#x2F;&#x2F; 返回结果字符串\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}