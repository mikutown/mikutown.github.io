{"title":"leetcode987.二叉树的垂序遍历","slug":"leetcode987-二叉树的垂序遍历","date":"2023-06-20T06:47:33.000Z","updated":"2023-06-20T05:52:31.673Z","comments":true,"path":"api/articles/leetcode987-二叉树的垂序遍历.json","excerpt":null,"covers":["http://cdn.leafii.top/img/vtree1.jpg","http://cdn.leafii.top/img/vtree2.jpg","http://cdn.leafii.top/img/vtree3.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你二叉树的根结点 <code>root</code> ，请你设计算法计算二叉树的 <strong>垂序遍历</strong> 序列。</p>\n<p>对位于 <code>(row, col)</code> 的每个结点而言，其左右子结点分别位于 <code>(row + 1, col - 1)</code> 和 <code>(row + 1, col + 1)</code> 。树的根结点位于 <code>(0, 0)</code> 。</p>\n<p>二叉树的 <strong>垂序遍历</strong> 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p>\n<p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/vtree1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：[[9],[3,15],[20],[7]]\n解释：\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/vtree2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,4,5,6,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列  0 ：结点 1 、5 和 6 都在此列中。\n          1 在上面，所以它出现在前面。\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列  1 ：只有结点 3 在此列中。\n列  2 ：只有结点 7 在此列中。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/vtree3.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,4,6,5,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中结点数目总数在范围 <code>[1, 1000]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路如下：</p>\n<ol>\n<li>编写了一个辅助函数 <code>verticalTraversalHelper</code>，用于递归处理二叉树。该函数的参数包括当前结点 <code>root</code>、当前结点所在的列数 <code>x</code>、当前结点所在的行数 <code>y</code>，以及一个用于存储结点值的 <code>map</code> 结构 <code>nodes</code>。在该函数中，首先判断当前结点是否为空，若为空则直接返回；否则，将当前结点的值添加到 <code>nodes</code> 结构中对应的列和行中，并递归调用该函数处理左右子树，列数 <code>x</code> 根据左右移动。</li>\n<li>定义了主函数 <code>verticalTraversal</code>，用于实现按照列的顺序遍历二叉树。在该函数中，首先定义了一个二维数组 <code>result</code>，用于存储最终结果。然后判断根结点是否为空，若为空则直接返回空数组。接下来使用 <code>map</code> 结构 <code>nodes</code> 来存储每一列的结点值，其中 key 为列数，value 为行数和结点值的映射。</li>\n<li>调用辅助函数 <code>verticalTraversalHelper</code> 处理二叉树，将结点按照列的顺序分组，存储在 <code>nodes</code> 结构中。</li>\n<li>使用队列 <code>columns</code> 对列数进行排序，然后按照列数从小到大遍历结点值，并将其添加到结果数组 <code>result</code> 中。在遍历过程中，首先从队列中取出一个列数 <code>col</code>，然后使用优先队列 <code>pq</code> 对该列的行数和结点值进行排序。将当前列的结点值按照行数加入优先队列。</li>\n<li>将优先队列中的结点值按照行数顺序取出，存储在一个临时数组 <code>colValues</code> 中。</li>\n<li>将 <code>colValues</code> 数组添加到结果数组 <code>result</code> 中。</li>\n<li>最后返回结果数组 <code>result</code>。</li>\n<li>在 <code>main</code> 函数中，创建了一个测试二叉树，并调用 <code>verticalTraversal</code> 函数进行遍历，然后打印结果。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F; 辅助函数，用于将二叉树的结点按照列的顺序进行分组\n    void verticalTraversalHelper(TreeNode *root, int x, int y, map&lt;int, map&lt;int, vector&lt;int&gt;&gt;&gt; &amp;nodes) &#123;\n        if (!root)\n            return;\n\n        &#x2F;&#x2F; 在对应的列和行中添加当前结点的值\n        nodes[x][y].push_back(root-&gt;val);\n\n        &#x2F;&#x2F; 递归处理左子树和右子树，列数x根据左右移动\n        verticalTraversalHelper(root-&gt;left, x - 1, y + 1, nodes);\n        verticalTraversalHelper(root-&gt;right, x + 1, y + 1, nodes);\n    &#125;\n    &#x2F;&#x2F; 主函数，返回按照列的顺序遍历的结点值的二维数组\n    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode *root) &#123;\n        &#x2F;&#x2F; 存储结点值的二维数组\n        vector&lt;vector&lt;int&gt;&gt; result;\n\n        &#x2F;&#x2F; 如果根结点为空，直接返回空数组\n        if (!root)\n            return result;\n\n        &#x2F;&#x2F; 使用map来存储每一列的结点值，key为列数，value为行数和结点值的映射\n        map&lt;int, map&lt;int, vector&lt;int&gt;&gt;&gt; nodes;\n\n        &#x2F;&#x2F; 递归处理二叉树，将结点按照列的顺序分组\n        verticalTraversalHelper(root, 0, 0, nodes);\n\n        &#x2F;&#x2F; 使用队列对列数进行排序\n        queue&lt;int&gt; columns;\n        for (auto &amp;node : nodes)\n            columns.push(node.first);\n\n        &#x2F;&#x2F; 按照列数从小到大遍历结点值，并添加到结果数组中\n        while (!columns.empty()) &#123;\n            int col &#x3D; columns.front();\n            columns.pop();\n\n            &#x2F;&#x2F; 使用优先队列对行数和结点值进行排序\n            priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n\n            &#x2F;&#x2F; 将当前列的结点值按照行数加入优先队列\n            for (auto &amp;node : nodes[col]) &#123;\n                int row &#x3D; node.first;\n                for (int val : node.second) &#123;\n                    pq.push(&#123;row, val&#125;);\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 将当前列的结点值按照行数顺序添加到结果数组中\n            vector&lt;int&gt; colValues;\n            while (!pq.empty()) &#123;\n                colValues.push_back(pq.top().second);\n                pq.pop();\n            &#125;\n\n            result.push_back(colValues);\n        &#125;\n\n        return result;\n    &#125;\n\n&#125;;</code></pre>\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你二叉树的根结点 <code>root</code> ，请你设计算法计算二叉树的 <strong>垂序遍历</strong> 序列。</p>\n<p>对位于 <code>(row, col)</code> 的每个结点而言，其左右子结点分别位于 <code>(row + 1, col - 1)</code> 和 <code>(row + 1, col + 1)</code> 。树的根结点位于 <code>(0, 0)</code> 。</p>\n<p>二叉树的 <strong>垂序遍历</strong> 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p>\n<p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/vtree1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：[[9],[3,15],[20],[7]]\n解释：\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/vtree2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,4,5,6,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列  0 ：结点 1 、5 和 6 都在此列中。\n          1 在上面，所以它出现在前面。\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列  1 ：只有结点 3 在此列中。\n列  2 ：只有结点 7 在此列中。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/vtree3.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,4,6,5,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中结点数目总数在范围 <code>[1, 1000]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路如下：</p>\n<ol>\n<li>编写了一个辅助函数 <code>verticalTraversalHelper</code>，用于递归处理二叉树。该函数的参数包括当前结点 <code>root</code>、当前结点所在的列数 <code>x</code>、当前结点所在的行数 <code>y</code>，以及一个用于存储结点值的 <code>map</code> 结构 <code>nodes</code>。在该函数中，首先判断当前结点是否为空，若为空则直接返回；否则，将当前结点的值添加到 <code>nodes</code> 结构中对应的列和行中，并递归调用该函数处理左右子树，列数 <code>x</code> 根据左右移动。</li>\n<li>定义了主函数 <code>verticalTraversal</code>，用于实现按照列的顺序遍历二叉树。在该函数中，首先定义了一个二维数组 <code>result</code>，用于存储最终结果。然后判断根结点是否为空，若为空则直接返回空数组。接下来使用 <code>map</code> 结构 <code>nodes</code> 来存储每一列的结点值，其中 key 为列数，value 为行数和结点值的映射。</li>\n<li>调用辅助函数 <code>verticalTraversalHelper</code> 处理二叉树，将结点按照列的顺序分组，存储在 <code>nodes</code> 结构中。</li>\n<li>使用队列 <code>columns</code> 对列数进行排序，然后按照列数从小到大遍历结点值，并将其添加到结果数组 <code>result</code> 中。在遍历过程中，首先从队列中取出一个列数 <code>col</code>，然后使用优先队列 <code>pq</code> 对该列的行数和结点值进行排序。将当前列的结点值按照行数加入优先队列。</li>\n<li>将优先队列中的结点值按照行数顺序取出，存储在一个临时数组 <code>colValues</code> 中。</li>\n<li>将 <code>colValues</code> 数组添加到结果数组 <code>result</code> 中。</li>\n<li>最后返回结果数组 <code>result</code>。</li>\n<li>在 <code>main</code> 函数中，创建了一个测试二叉树，并调用 <code>verticalTraversal</code> 函数进行遍历，然后打印结果。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F; 辅助函数，用于将二叉树的结点按照列的顺序进行分组\n    void verticalTraversalHelper(TreeNode *root, int x, int y, map&lt;int, map&lt;int, vector&lt;int&gt;&gt;&gt; &amp;nodes) &#123;\n        if (!root)\n            return;\n\n        &#x2F;&#x2F; 在对应的列和行中添加当前结点的值\n        nodes[x][y].push_back(root-&gt;val);\n\n        &#x2F;&#x2F; 递归处理左子树和右子树，列数x根据左右移动\n        verticalTraversalHelper(root-&gt;left, x - 1, y + 1, nodes);\n        verticalTraversalHelper(root-&gt;right, x + 1, y + 1, nodes);\n    &#125;\n    &#x2F;&#x2F; 主函数，返回按照列的顺序遍历的结点值的二维数组\n    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode *root) &#123;\n        &#x2F;&#x2F; 存储结点值的二维数组\n        vector&lt;vector&lt;int&gt;&gt; result;\n\n        &#x2F;&#x2F; 如果根结点为空，直接返回空数组\n        if (!root)\n            return result;\n\n        &#x2F;&#x2F; 使用map来存储每一列的结点值，key为列数，value为行数和结点值的映射\n        map&lt;int, map&lt;int, vector&lt;int&gt;&gt;&gt; nodes;\n\n        &#x2F;&#x2F; 递归处理二叉树，将结点按照列的顺序分组\n        verticalTraversalHelper(root, 0, 0, nodes);\n\n        &#x2F;&#x2F; 使用队列对列数进行排序\n        queue&lt;int&gt; columns;\n        for (auto &amp;node : nodes)\n            columns.push(node.first);\n\n        &#x2F;&#x2F; 按照列数从小到大遍历结点值，并添加到结果数组中\n        while (!columns.empty()) &#123;\n            int col &#x3D; columns.front();\n            columns.pop();\n\n            &#x2F;&#x2F; 使用优先队列对行数和结点值进行排序\n            priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n\n            &#x2F;&#x2F; 将当前列的结点值按照行数加入优先队列\n            for (auto &amp;node : nodes[col]) &#123;\n                int row &#x3D; node.first;\n                for (int val : node.second) &#123;\n                    pq.push(&#123;row, val&#125;);\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 将当前列的结点值按照行数顺序添加到结果数组中\n            vector&lt;int&gt; colValues;\n            while (!pq.empty()) &#123;\n                colValues.push_back(pq.top().second);\n                pq.pop();\n            &#125;\n\n            result.push_back(colValues);\n        &#125;\n\n        return result;\n    &#125;\n\n&#125;;</code></pre>\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}