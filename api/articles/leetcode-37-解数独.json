{"title":"leetcode:37.解数独","slug":"leetcode-37-解数独","date":"2023-02-03T06:58:10.000Z","updated":"2023-02-05T04:47:59.228Z","comments":true,"path":"api/articles/leetcode-37-解数独.json","excerpt":"题目编写一个程序，通过填充空格来解决数独问题。数独的解法需 遵循如下规则：数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。","covers":["http://cdn.leafii.top/img/250px-sudoku-by-l2g-20050714svg.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>编写一个程序，通过填充空格来解决数独问题。</p>\n<p>数独的解法需 <strong>遵循如下规则</strong>：</p>\n<ol>\n<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>\n<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>\n<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>\n</ol>\n<p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/250px-sudoku-by-l2g-20050714svg.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]\n解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>board.length == 9</code></li>\n<li><code>board[i].length == 9</code></li>\n<li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li>\n<li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>我们可以考虑按照「行优先」的顺序依次枚举每一个空白格中填的数字，通过递归 + 回溯的方法枚举所有可能的填法。当递归到最后一个空白格后，如果仍然没有冲突，说明我们找到了答案；在递归的过程中，如果当前的空白格不能填下任何一个数字，那么就进行回溯。</p>\n<p>由于每个数字在同一行、同一列、同一个九宫格中只会出现一次，因此我们可以使用<code>line[i]，column[j]，block[x][y]</code>分别表示第 i 行，第 j 列，第(x,y) 个九宫格中填写数字的情况。在下面给出的三种方法中，我们将会介绍两种不同的表示填写数字情况的方法。</p>\n<blockquote>\n<p>九宫格的范围为 $0 \\leq x \\leq 2$以及 $0 \\leq y \\leq 2$。 具体地，第 i 行第 j 列的格子位于第$(\\lfloor i&#x2F;3 \\rfloor, \\lfloor j&#x2F;3 \\rfloor)$个九宫格中，其中$\\lfloor u \\rfloor$表示对 u 向下取整。</p>\n</blockquote>\n<ol>\n<li>回溯法</li>\n</ol>\n<p><strong>思路</strong>：最容易想到的方法是用一个数组记录每个数字是否出现。由于我们可以填写的数字范围为[1,9]，而数组的下标从 0 开始，因此在存储时，我们使用一个长度为 9 的布尔类型的数组，其中 i 个元素的值为 $\\text{True}$，当且仅当数字i+1 出现过。例如我们用 $\\textit{line}[2][3] &#x3D; \\text{True}$ 表示数字 4 在第 2 行已经出现过，那么当我们在遍历到第 2 行的空白格时，就不能填入数字 4。</p>\n<p><strong>算法</strong>：</p>\n<p>首先对整个数独数组进行遍历，当我们遍历到第i行第j列时：</p>\n<ul>\n<li>若该位置是一个空白格，那么我们将其加入一个用来存储空白格位置的列表中，方便后续的递归操作；</li>\n<li>若该位置是一个数字x，那么我们需要将<code>line[i][x-1],column[j][x-1]</code>以及<code>block[i/3][j/3][x-1]</code>都置为True。</li>\n</ul>\n<p>当我们结束了遍历过程之后，就可以开始递归枚举。当递归到第 $i$ 行第 $j$ 列的位置时，我们枚举填入的数字 $x$。根据题目的要求，数字 $x$ 不能和当前行、列、九宫格中已经填入的数字相同，因此 $line[i][x-1]$，$\\textit{column}[j][x-1]$以及 $\\textit{block}[\\lfloor i&#x2F;3 \\rfloor][\\lfloor j&#x2F;3 \\rfloor][x-1]$ 必须均为 $\\text{False}$。</p>\n<p>当我们填入了数字 $x$ 之后，我们要将上述的三个值都置为 $\\text{True}$，并且继续对下一个空白格位置进行递归。在回溯到当前递归层时，我们还要将上述的三个值重新置为 $\\text{False}$。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    bool line[9][9];\n    bool column[9][9];\n    bool block[3][3][9];\n    bool valid;\n    vector&lt;pair&lt;int, int&gt;&gt; spaces;\n\npublic:\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;\n        if (pos &#x3D;&#x3D; spaces.size()) &#123;\n            valid &#x3D; true;\n            return;\n        &#125;\n\n        auto [i, j] &#x3D; spaces[pos]; &#x2F;&#x2F;获取空位位置\n        for (int digit &#x3D; 0; digit &lt; 9 &amp;&amp; !valid; ++digit) &#123;\n            if (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i &#x2F; 3][j &#x2F; 3][digit]) &#123;\n                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;填符合条件的数字\n                board[i][j] &#x3D; digit + &#39;0&#39; + 1;\n                dfs(board, pos + 1); &#x2F;&#x2F;递归\n                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; false; &#x2F;&#x2F;回溯\n            &#125;\n        &#125;\n    &#125;\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        memset(line, false, sizeof(line));\n        memset(column, false, sizeof(column));\n        memset(block, false, sizeof(block));\n        valid &#x3D; false;\n\n        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;\n                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                    spaces.emplace_back(i, j); &#x2F;&#x2F;initialize\n                &#125;\n                else &#123;\n                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;\n                    line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;initialize\n                &#125;\n            &#125;\n        &#125;\n\n        dfs(board, 0); &#x2F;&#x2F;从头开始求解，最后得到填满数字的board\n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>力扣官方题解：<a href=\"https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/\">https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/</a></p>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/250px-sudoku-by-l2g-20050714svg.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]\n解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>board.length == 9</code></li>\n<li><code>board[i].length == 9</code></li>\n<li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li>\n<li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>我们可以考虑按照「行优先」的顺序依次枚举每一个空白格中填的数字，通过递归 + 回溯的方法枚举所有可能的填法。当递归到最后一个空白格后，如果仍然没有冲突，说明我们找到了答案；在递归的过程中，如果当前的空白格不能填下任何一个数字，那么就进行回溯。</p>\n<p>由于每个数字在同一行、同一列、同一个九宫格中只会出现一次，因此我们可以使用<code>line[i]，column[j]，block[x][y]</code>分别表示第 i 行，第 j 列，第(x,y) 个九宫格中填写数字的情况。在下面给出的三种方法中，我们将会介绍两种不同的表示填写数字情况的方法。</p>\n<blockquote>\n<p>九宫格的范围为 $0 \\leq x \\leq 2$以及 $0 \\leq y \\leq 2$。 具体地，第 i 行第 j 列的格子位于第$(\\lfloor i&#x2F;3 \\rfloor, \\lfloor j&#x2F;3 \\rfloor)$个九宫格中，其中$\\lfloor u \\rfloor$表示对 u 向下取整。</p>\n</blockquote>\n<ol>\n<li>回溯法</li>\n</ol>\n<p><strong>思路</strong>：最容易想到的方法是用一个数组记录每个数字是否出现。由于我们可以填写的数字范围为[1,9]，而数组的下标从 0 开始，因此在存储时，我们使用一个长度为 9 的布尔类型的数组，其中 i 个元素的值为 $\\text{True}$，当且仅当数字i+1 出现过。例如我们用 $\\textit{line}[2][3] &#x3D; \\text{True}$ 表示数字 4 在第 2 行已经出现过，那么当我们在遍历到第 2 行的空白格时，就不能填入数字 4。</p>\n<p><strong>算法</strong>：</p>\n<p>首先对整个数独数组进行遍历，当我们遍历到第i行第j列时：</p>\n<ul>\n<li>若该位置是一个空白格，那么我们将其加入一个用来存储空白格位置的列表中，方便后续的递归操作；</li>\n<li>若该位置是一个数字x，那么我们需要将<code>line[i][x-1],column[j][x-1]</code>以及<code>block[i/3][j/3][x-1]</code>都置为True。</li>\n</ul>\n<p>当我们结束了遍历过程之后，就可以开始递归枚举。当递归到第 $i$ 行第 $j$ 列的位置时，我们枚举填入的数字 $x$。根据题目的要求，数字 $x$ 不能和当前行、列、九宫格中已经填入的数字相同，因此 $line[i][x-1]$，$\\textit{column}[j][x-1]$以及 $\\textit{block}[\\lfloor i&#x2F;3 \\rfloor][\\lfloor j&#x2F;3 \\rfloor][x-1]$ 必须均为 $\\text{False}$。</p>\n<p>当我们填入了数字 $x$ 之后，我们要将上述的三个值都置为 $\\text{True}$，并且继续对下一个空白格位置进行递归。在回溯到当前递归层时，我们还要将上述的三个值重新置为 $\\text{False}$。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    bool line[9][9];\n    bool column[9][9];\n    bool block[3][3][9];\n    bool valid;\n    vector&lt;pair&lt;int, int&gt;&gt; spaces;\n\npublic:\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;\n        if (pos &#x3D;&#x3D; spaces.size()) &#123;\n            valid &#x3D; true;\n            return;\n        &#125;\n\n        auto [i, j] &#x3D; spaces[pos]; &#x2F;&#x2F;获取空位位置\n        for (int digit &#x3D; 0; digit &lt; 9 &amp;&amp; !valid; ++digit) &#123;\n            if (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i &#x2F; 3][j &#x2F; 3][digit]) &#123;\n                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;填符合条件的数字\n                board[i][j] &#x3D; digit + &#39;0&#39; + 1;\n                dfs(board, pos + 1); &#x2F;&#x2F;递归\n                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; false; &#x2F;&#x2F;回溯\n            &#125;\n        &#125;\n    &#125;\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        memset(line, false, sizeof(line));\n        memset(column, false, sizeof(column));\n        memset(block, false, sizeof(block));\n        valid &#x3D; false;\n\n        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;\n                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                    spaces.emplace_back(i, j); &#x2F;&#x2F;initialize\n                &#125;\n                else &#123;\n                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;\n                    line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true; &#x2F;&#x2F;initialize\n                &#125;\n            &#125;\n        &#125;\n\n        dfs(board, 0); &#x2F;&#x2F;从头开始求解，最后得到填满数字的board\n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>力扣官方题解：<a href=\"https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/\">https://leetcode.cn/problems/sudoku-solver/solutions/414120/jie-shu-du-by-leetcode-solution/</a></p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}