{"title":"leetcode:46.全排列","slug":"leetcode-46-全排列","date":"2023-01-29T06:23:57.000Z","updated":"2023-01-29T06:47:10.334Z","comments":true,"path":"api/articles/leetcode-46-全排列.json","excerpt":"题目给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,1]\n输出：[[0,1],[1,0]]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1]\n输出：[[1]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>回溯</li>\n</ol>\n<p>用回溯法模拟全排列的过程。</p>\n<p>定义一个递归函数<code>backtrack(first, output)</code>表示从左往右填到第first个位置，当前排列为output，所以有以下两种情况：</p>\n<ul>\n<li>若<code>first = n</code>，则说明n个位置已经填完了，找到了一个可行的解，此时需要把output放入答案数组中，递归结束。</li>\n<li>如果<code>first &lt; n</code>，我们需要考虑在第first个位置上我们需要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组vis来标记已经填过的数，如果有数未被标记，就尝试填入，并将其标记，然后继续调用<code>backtrack(first + 1, output)</code>，回溯时要撤销之前的标记以及已经填入的数字，但是标记数组增加了算法的空间复杂度。</li>\n</ul>\n<p>我们将题目给定的n个数的数组nums划分为左右两个部分，左边为已经填过的数，右边是待填的数，在回溯时只需要动态维护这个数组即可。</p>\n<p>具体的来说，如果我们已经填到第first个位置，那么nums数组中<code>[0, first - 1]</code>是已经填过的数的集合，<code>[first, n - 1]</code>是待填数的集合。我们肯定是用<code>[first, n - 1]</code>的数去填第first个数，假设待填的数的下标为i，那么填完以后我们将第i个数和第first个数交换，即能使得在第first+1个数的时候nums数组的<code>[0, first]</code>部分为已填过的数，<code>[first + 1, n - 1]</code>为待填的数，回溯的时候交换回来就可以完成撤销操作。</p>\n<p>举个简单的例子，假设我们有 <code>[2,5,8,9,10]</code>这 5 个数要填入，已经填到第 3 个位置，已经填了 <code>[8, 9]</code> 两个数，那么这个数组目前为 <code>[8, 9|2, 5, 10]</code> 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10 这个数，为了维护数组，我们将 2 和 10 交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填 <code>[8, 9, 10|2, 5]</code> 。C++实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len) &#123;\n        &#x2F;&#x2F;所有数都填完了\n        if (first &#x3D;&#x3D; len) &#123;\n            res.emplace_back(output); \n            &#x2F;&#x2F;和push_back()类似，emplace_back() 用来给容器中添加元素。\n            &#x2F;&#x2F;在容器尾部添加一个元素，调用构造函数原地构造，不需要触发拷贝构造和移动构造。因此比push_back()更加高效。\n            return;\n        &#125;\n        for (int i &#x3D; first; i &lt; len; ++i) &#123;\n            &#x2F;&#x2F;动态维护数组\n            swap(output[i], output[first]); &#x2F;&#x2F;swap用于交换两个int型变量的值\n            &#x2F;&#x2F;继续递归填下一个数\n            backtrack(res, output, first + 1, len);\n            &#x2F;&#x2F;撤销操作\n            swap(output[i], output[first]);\n        &#125;\n    &#125;\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt; &gt; res;\n        backtrack(res, nums, 0, (int)nums.size());\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,1]\n输出：[[0,1],[1,0]]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1]\n输出：[[1]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>回溯</li>\n</ol>\n<p>用回溯法模拟全排列的过程。</p>\n<p>定义一个递归函数<code>backtrack(first, output)</code>表示从左往右填到第first个位置，当前排列为output，所以有以下两种情况：</p>\n<ul>\n<li>若<code>first = n</code>，则说明n个位置已经填完了，找到了一个可行的解，此时需要把output放入答案数组中，递归结束。</li>\n<li>如果<code>first &lt; n</code>，我们需要考虑在第first个位置上我们需要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组vis来标记已经填过的数，如果有数未被标记，就尝试填入，并将其标记，然后继续调用<code>backtrack(first + 1, output)</code>，回溯时要撤销之前的标记以及已经填入的数字，但是标记数组增加了算法的空间复杂度。</li>\n</ul>\n<p>我们将题目给定的n个数的数组nums划分为左右两个部分，左边为已经填过的数，右边是待填的数，在回溯时只需要动态维护这个数组即可。</p>\n<p>具体的来说，如果我们已经填到第first个位置，那么nums数组中<code>[0, first - 1]</code>是已经填过的数的集合，<code>[first, n - 1]</code>是待填数的集合。我们肯定是用<code>[first, n - 1]</code>的数去填第first个数，假设待填的数的下标为i，那么填完以后我们将第i个数和第first个数交换，即能使得在第first+1个数的时候nums数组的<code>[0, first]</code>部分为已填过的数，<code>[first + 1, n - 1]</code>为待填的数，回溯的时候交换回来就可以完成撤销操作。</p>\n<p>举个简单的例子，假设我们有 <code>[2,5,8,9,10]</code>这 5 个数要填入，已经填到第 3 个位置，已经填了 <code>[8, 9]</code> 两个数，那么这个数组目前为 <code>[8, 9|2, 5, 10]</code> 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10 这个数，为了维护数组，我们将 2 和 10 交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填 <code>[8, 9, 10|2, 5]</code> 。C++实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len) &#123;\n        &#x2F;&#x2F;所有数都填完了\n        if (first &#x3D;&#x3D; len) &#123;\n            res.emplace_back(output); \n            &#x2F;&#x2F;和push_back()类似，emplace_back() 用来给容器中添加元素。\n            &#x2F;&#x2F;在容器尾部添加一个元素，调用构造函数原地构造，不需要触发拷贝构造和移动构造。因此比push_back()更加高效。\n            return;\n        &#125;\n        for (int i &#x3D; first; i &lt; len; ++i) &#123;\n            &#x2F;&#x2F;动态维护数组\n            swap(output[i], output[first]); &#x2F;&#x2F;swap用于交换两个int型变量的值\n            &#x2F;&#x2F;继续递归填下一个数\n            backtrack(res, output, first + 1, len);\n            &#x2F;&#x2F;撤销操作\n            swap(output[i], output[first]);\n        &#125;\n    &#125;\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt; &gt; res;\n        backtrack(res, nums, 0, (int)nums.size());\n        return res;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}