{"title":"leetcode118.杨辉三角","slug":"leetcode118-杨辉三角","date":"2023-04-23T02:34:59.000Z","updated":"2023-04-23T02:43:51.906Z","comments":true,"path":"api/articles/leetcode118-杨辉三角.json","excerpt":null,"covers":["http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2.gif"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>\n<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>\n<p><img src=\"http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2.gif\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: numRows &#x3D; 5\n输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: numRows &#x3D; 1\n输出: [[1]]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= numRows &lt;= 30</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接模拟</li>\n</ul>\n<p>直接看代码吧 就是直接模拟：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;\n        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组\n        for (int i &#x3D; 0; i &lt; numRows; i++) &#123; &#x2F;&#x2F; 按行进行遍历\n            &#x2F;&#x2F; i是当前行号\n            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字\n            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i\n                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值\n                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行 \n                    continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值\n                &#125;\n                else &#123;\n                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和\n                &#125;\n            &#125;\n            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组\n        &#125;\n        return results;&#x2F;&#x2F; 返回结果数组\n    &#125;\n&#125;;</code></pre>\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>\n<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>\n<p><img src=\"http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2.gif\" alt=\"img\"></p>\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: numRows &#x3D; 5\n输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: numRows &#x3D; 1\n输出: [[1]]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= numRows &lt;= 30</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接模拟</li>\n</ul>\n<p>直接看代码吧 就是直接模拟：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;\n        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组\n        for (int i &#x3D; 0; i &lt; numRows; i++) &#123; &#x2F;&#x2F; 按行进行遍历\n            &#x2F;&#x2F; i是当前行号\n            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字\n            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i\n                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值\n                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行 \n                    continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值\n                &#125;\n                else &#123;\n                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和\n                &#125;\n            &#125;\n            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组\n        &#125;\n        return results;&#x2F;&#x2F; 返回结果数组\n    &#125;\n&#125;;</code></pre>\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}