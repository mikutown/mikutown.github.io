{"title":"leetcode398.随机数索引","slug":"leetcode398-随机数索引","date":"2023-12-20T02:05:57.000Z","updated":"2023-12-20T02:15:53.883Z","comments":true,"path":"api/articles/leetcode398-随机数索引.json","excerpt":"题目给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。实现 Solution 类：Solution(int[] nums) 用数组 nums 初始化对象。int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个可能含有 <strong>重复元素</strong> 的整数数组 <code>nums</code> ，请你随机输出给定的目标数字 <code>target</code> 的索引。你可以假设给定的数字一定存在于数组中。</p>\n<p>实现 <code>Solution</code> 类：</p>\n<ul>\n<li><code>Solution(int[] nums)</code> 用数组 <code>nums</code> 初始化对象。</li>\n<li><code>int pick(int target)</code> 从 <code>nums</code> 中选出一个满足 <code>nums[i] == target</code> 的随机索引 <code>i</code> 。如果存在多个有效的索引，则每个索引的返回概率应当相等。</li>\n</ul>\n <span id=\"more\"></span>\n\n<p><strong>示例：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入\n[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]\n[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n输出\n[null, 4, 0, 2]\n\n解释\nSolution solution &#x3D; new Solution([1, 2, 3, 3, 3]);\nsolution.pick(3); &#x2F;&#x2F; 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。\nsolution.pick(1); &#x2F;&#x2F; 返回 0 。因为只有 nums[0] 等于 1 。\nsolution.pick(3); &#x2F;&#x2F; 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>\n<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>\n<li><code>target</code> 是 <code>nums</code> 中的一个整数</li>\n<li>最多调用 <code>pick</code> 函数 <code>104</code> 次</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>直接实现</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;int&gt; sortNum;\npublic:\n    Solution(vector&lt;int&gt;&amp; nums) &#123;\n        sortNum &#x3D; nums;\n    &#125;\n    int simpleRandom(int min, int max) &#123;\n        static bool first &#x3D; true;\n        if (first) &#123;\n            srand(time(nullptr)); &#x2F;&#x2F; 使用当前时间作为种子\n            first &#x3D; false;\n        &#125;\n        return min + rand() % (max - min + 1);\n    &#125;\n    \n    int pick(int target) &#123;\n        vector&lt;int&gt; result;\n        for (int i &#x3D; 0; i &lt; sortNum.size(); i++) &#123;\n            if (sortNum[i] &#x3D;&#x3D; target) result.push_back(i);\n        &#125;\n        int randomIndex &#x3D; simpleRandom(0, result.size()-1);\n        return result[randomIndex];\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(nums);\n * int param_1 &#x3D; obj-&gt;pick(target);\n *&#x2F;</code></pre>\n\n<ol start=\"2\">\n<li>使用哈希表实现</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\n    &#x2F;&#x2F; 使用哈希表存储每个数字及其在数组中的所有索引\n    unordered_map&lt;int, vector&lt;int&gt;&gt; pos;\n\npublic:\n    &#x2F;&#x2F; 构造函数，接受一个整数数组作为参数\n    Solution(vector&lt;int&gt; &amp;nums) &#123;\n        &#x2F;&#x2F; 遍历数组\n        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;\n            &#x2F;&#x2F; 将每个数字及其索引存入哈希表中\n            &#x2F;&#x2F; 如果数字已存在，它的索引将被添加到对应的向量中\n            pos[nums[i]].push_back(i);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; pick 函数，接受一个目标数字作为参数\n    int pick(int target) &#123;\n        &#x2F;&#x2F; 获取目标数字所有索引的向量的引用\n        auto &amp;indices &#x3D; pos[target];\n        &#x2F;&#x2F; 随机选择并返回一个索引\n        &#x2F;&#x2F; rand() % indices.size() 生成一个在 0 到 indices.size() - 1 范围内的随机数\n        return indices[rand() % indices.size()];\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入\n[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]\n[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n输出\n[null, 4, 0, 2]\n\n解释\nSolution solution &#x3D; new Solution([1, 2, 3, 3, 3]);\nsolution.pick(3); &#x2F;&#x2F; 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。\nsolution.pick(1); &#x2F;&#x2F; 返回 0 。因为只有 nums[0] 等于 1 。\nsolution.pick(3); &#x2F;&#x2F; 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>\n<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>\n<li><code>target</code> 是 <code>nums</code> 中的一个整数</li>\n<li>最多调用 <code>pick</code> 函数 <code>104</code> 次</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>直接实现</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;int&gt; sortNum;\npublic:\n    Solution(vector&lt;int&gt;&amp; nums) &#123;\n        sortNum &#x3D; nums;\n    &#125;\n    int simpleRandom(int min, int max) &#123;\n        static bool first &#x3D; true;\n        if (first) &#123;\n            srand(time(nullptr)); &#x2F;&#x2F; 使用当前时间作为种子\n            first &#x3D; false;\n        &#125;\n        return min + rand() % (max - min + 1);\n    &#125;\n    \n    int pick(int target) &#123;\n        vector&lt;int&gt; result;\n        for (int i &#x3D; 0; i &lt; sortNum.size(); i++) &#123;\n            if (sortNum[i] &#x3D;&#x3D; target) result.push_back(i);\n        &#125;\n        int randomIndex &#x3D; simpleRandom(0, result.size()-1);\n        return result[randomIndex];\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(nums);\n * int param_1 &#x3D; obj-&gt;pick(target);\n *&#x2F;</code></pre>\n\n<ol start=\"2\">\n<li>使用哈希表实现</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\n    &#x2F;&#x2F; 使用哈希表存储每个数字及其在数组中的所有索引\n    unordered_map&lt;int, vector&lt;int&gt;&gt; pos;\n\npublic:\n    &#x2F;&#x2F; 构造函数，接受一个整数数组作为参数\n    Solution(vector&lt;int&gt; &amp;nums) &#123;\n        &#x2F;&#x2F; 遍历数组\n        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;\n            &#x2F;&#x2F; 将每个数字及其索引存入哈希表中\n            &#x2F;&#x2F; 如果数字已存在，它的索引将被添加到对应的向量中\n            pos[nums[i]].push_back(i);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; pick 函数，接受一个目标数字作为参数\n    int pick(int target) &#123;\n        &#x2F;&#x2F; 获取目标数字所有索引的向量的引用\n        auto &amp;indices &#x3D; pos[target];\n        &#x2F;&#x2F; 随机选择并返回一个索引\n        &#x2F;&#x2F; rand() % indices.size() 生成一个在 0 到 indices.size() - 1 范围内的随机数\n        return indices[rand() % indices.size()];\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}