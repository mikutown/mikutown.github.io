{"title":"leetcode1365.有多少小于当前数字的数字","slug":"leetcode1365-有多少小于当前数字的数字","date":"2023-05-20T08:16:48.000Z","updated":"2023-05-20T08:53:08.938Z","comments":true,"path":"api/articles/leetcode1365-有多少小于当前数字的数字.json","excerpt":"题目给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。以数组形式返回答案。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p>\n<p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。</p>\n<p>以数组形式返回答案。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [8,1,2,2,3]\n输出：[4,0,1,1,3]\n解释： \n对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 \n对于 nums[1]&#x3D;1 不存在比它小的数字。\n对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 \n对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 \n对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [6,5,4,8]\n输出：[2,1,0,3]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [7,7,7,7]\n输出：[0,0,0,0]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<p>思路：直接复制一份数组，将复制得到的数组进行排序，然后进行遍历比较，将得到的值添加到答案数组中，最后返回答案数组。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; nums_sorted &#x3D; nums; &#x2F;&#x2F; 复制nums数组\n        sort(nums_sorted.begin(), nums_sorted.end()); &#x2F;&#x2F; 将复制后的数组进行排序\n        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化答案数组\n        int len &#x3D; nums.size(); &#x2F;&#x2F; 得到数组的总长度\n        for (int i &#x3D; 0; i &lt; len; i++) &#123; &#x2F;&#x2F; 进行遍历\n            int result &#x3D; 0; &#x2F;&#x2F; 初始化大于nums[i]的元素的数量为0\n            for (int j &#x3D; 0; j &lt; len; j++) &#123; &#x2F;&#x2F; 在排序后的数组中进行遍历，以便得到精确的答案\n                if (nums_sorted[j] &lt; nums[i]) &#123;\n                    result++; &#x2F;&#x2F; 如果发现数组中有比nums[i]更小的数字，就把result进行++的操作\n                &#125;\n                else&#123;\n                    break; &#x2F;&#x2F; 否则就跳出循环（因为这是已经排序好的数组，这个元素不小于nums[i]那么之后的元素也都大于等于nums[i] 无需继续遍历\n                &#125;\n            &#125;\n            results.push_back(result); &#x2F;&#x2F; 将答案push进答案数组中\n        &#125;\n        return results; &#x2F;&#x2F; 返回答案结果\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>使用计数数组优化</li>\n</ul>\n<p>思路：因为nums数组中元素的大小范围为0到100，所以可以设置一个统计各个数字分别有多少个的计数数组，然后利用计数数组计算整个数组中小于nums[i]的元素的个数。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组，范围为0到100\n        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化结果数组\n        int len &#x3D; nums.size(); &#x2F;&#x2F; 获取数组长度\n        \n        &#x2F;&#x2F; 统计每个数字的出现次数\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            count[nums[i]]++; &#x2F;&#x2F; 统计当前数字出现的次数\n        &#125;\n        \n        &#x2F;&#x2F; 遍历每个数字，计算小于当前数字的元素个数\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            int temp_num &#x3D; nums[i]; &#x2F;&#x2F; 当前数字\n            int result &#x3D; 0; &#x2F;&#x2F; 小于当前数字的元素个数\n            for (int j &#x3D; 0; j &lt; temp_num; j++) &#123; &#x2F;&#x2F; 遍历计数数组\n                result +&#x3D; count[j]; &#x2F;&#x2F; 累加小于当前数字的元素个数\n            &#125;\n            results.push_back(result); &#x2F;&#x2F; 将结果添加到结果数组中\n        &#125;\n        \n        return results; &#x2F;&#x2F; 返回结果数组\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>使用计数排序和前缀和</li>\n</ul>\n<ol>\n<li>使用计数排序：题目中给出了限制条件，数组元素的范围是0到100，因此可以使用计数排序来替代排序函数，以提高效率。创建一个大小为101的计数数组，统计每个数字的出现次数，然后计算小于每个数字的元素个数。</li>\n<li>使用前缀和：通过累加计算计数数组，可以得到每个数字的前缀和数组。前缀和数组的每个元素表示小于等于该数字的元素个数。然后，通过访问前缀和数组即可获取小于每个元素的元素个数。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组\n        int len &#x3D; nums.size();\n\n        &#x2F;&#x2F; 统计每个数字的出现次数\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            count[nums[i]]++;\n        &#125;\n\n        &#x2F;&#x2F; 计算前缀和数组\n        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;\n            count[i] +&#x3D; count[i - 1];\n        &#125;\n\n        vector&lt;int&gt; results;\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            if (nums[i] &#x3D;&#x3D; 0) &#123;\n                results.push_back(0); &#x2F;&#x2F; 对于数字0，直接加入结果数组中\n            &#125; else &#123;\n                results.push_back(count[nums[i] - 1]); &#x2F;&#x2F; 获取小于当前数字的元素个数\n            &#125;\n        &#125;\n\n        return results;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [8,1,2,2,3]\n输出：[4,0,1,1,3]\n解释： \n对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 \n对于 nums[1]&#x3D;1 不存在比它小的数字。\n对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 \n对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 \n对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [6,5,4,8]\n输出：[2,1,0,3]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [7,7,7,7]\n输出：[0,0,0,0]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<p>思路：直接复制一份数组，将复制得到的数组进行排序，然后进行遍历比较，将得到的值添加到答案数组中，最后返回答案数组。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; nums_sorted &#x3D; nums; &#x2F;&#x2F; 复制nums数组\n        sort(nums_sorted.begin(), nums_sorted.end()); &#x2F;&#x2F; 将复制后的数组进行排序\n        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化答案数组\n        int len &#x3D; nums.size(); &#x2F;&#x2F; 得到数组的总长度\n        for (int i &#x3D; 0; i &lt; len; i++) &#123; &#x2F;&#x2F; 进行遍历\n            int result &#x3D; 0; &#x2F;&#x2F; 初始化大于nums[i]的元素的数量为0\n            for (int j &#x3D; 0; j &lt; len; j++) &#123; &#x2F;&#x2F; 在排序后的数组中进行遍历，以便得到精确的答案\n                if (nums_sorted[j] &lt; nums[i]) &#123;\n                    result++; &#x2F;&#x2F; 如果发现数组中有比nums[i]更小的数字，就把result进行++的操作\n                &#125;\n                else&#123;\n                    break; &#x2F;&#x2F; 否则就跳出循环（因为这是已经排序好的数组，这个元素不小于nums[i]那么之后的元素也都大于等于nums[i] 无需继续遍历\n                &#125;\n            &#125;\n            results.push_back(result); &#x2F;&#x2F; 将答案push进答案数组中\n        &#125;\n        return results; &#x2F;&#x2F; 返回答案结果\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>使用计数数组优化</li>\n</ul>\n<p>思路：因为nums数组中元素的大小范围为0到100，所以可以设置一个统计各个数字分别有多少个的计数数组，然后利用计数数组计算整个数组中小于nums[i]的元素的个数。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组，范围为0到100\n        vector&lt;int&gt; results; &#x2F;&#x2F; 初始化结果数组\n        int len &#x3D; nums.size(); &#x2F;&#x2F; 获取数组长度\n        \n        &#x2F;&#x2F; 统计每个数字的出现次数\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            count[nums[i]]++; &#x2F;&#x2F; 统计当前数字出现的次数\n        &#125;\n        \n        &#x2F;&#x2F; 遍历每个数字，计算小于当前数字的元素个数\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            int temp_num &#x3D; nums[i]; &#x2F;&#x2F; 当前数字\n            int result &#x3D; 0; &#x2F;&#x2F; 小于当前数字的元素个数\n            for (int j &#x3D; 0; j &lt; temp_num; j++) &#123; &#x2F;&#x2F; 遍历计数数组\n                result +&#x3D; count[j]; &#x2F;&#x2F; 累加小于当前数字的元素个数\n            &#125;\n            results.push_back(result); &#x2F;&#x2F; 将结果添加到结果数组中\n        &#125;\n        \n        return results; &#x2F;&#x2F; 返回结果数组\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>使用计数排序和前缀和</li>\n</ul>\n<ol>\n<li>使用计数排序：题目中给出了限制条件，数组元素的范围是0到100，因此可以使用计数排序来替代排序函数，以提高效率。创建一个大小为101的计数数组，统计每个数字的出现次数，然后计算小于每个数字的元素个数。</li>\n<li>使用前缀和：通过累加计算计数数组，可以得到每个数字的前缀和数组。前缀和数组的每个元素表示小于等于该数字的元素个数。然后，通过访问前缀和数组即可获取小于每个元素的元素个数。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; count(101, 0); &#x2F;&#x2F; 初始化计数数组\n        int len &#x3D; nums.size();\n\n        &#x2F;&#x2F; 统计每个数字的出现次数\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            count[nums[i]]++;\n        &#125;\n\n        &#x2F;&#x2F; 计算前缀和数组\n        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;\n            count[i] +&#x3D; count[i - 1];\n        &#125;\n\n        vector&lt;int&gt; results;\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            if (nums[i] &#x3D;&#x3D; 0) &#123;\n                results.push_back(0); &#x2F;&#x2F; 对于数字0，直接加入结果数组中\n            &#125; else &#123;\n                results.push_back(count[nums[i] - 1]); &#x2F;&#x2F; 获取小于当前数字的元素个数\n            &#125;\n        &#125;\n\n        return results;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}