{"title":"leetcode72.编辑距离","slug":"leetcode72-编辑距离","date":"2023-04-13T12:06:19.000Z","updated":"2023-04-13T12:19:59.086Z","comments":true,"path":"api/articles/leetcode72-编辑距离.json","excerpt":"题目给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>\n<p>你可以对一个单词进行如下三种操作：</p>\n<ul>\n<li>插入一个字符</li>\n<li>删除一个字符</li>\n<li>替换一个字符</li>\n</ul>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;\n输出：3\n解释：\nhorse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)\nrorse -&gt; rose (删除 &#39;r&#39;)\nrose -&gt; ros (删除 &#39;e&#39;)</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;\n输出：5\n解释：\nintention -&gt; inention (删除 &#39;t&#39;)\ninention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)\nenention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)\nexention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)\nexection -&gt; execution (插入 &#39;u&#39;)</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这道题要求我们找到从 word1 转换到 word2 所需要的最小操作数，其中每个操作都是插入、删除或替换一个字符。这道题可以使用动态规划来解决。我们可以定义一个 dp 数组，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数。</p>\n<p>当 i &#x3D; 0 时，表示 word1 为空，这时要将 word1 转换为 word2 的前 j 个字符，所以最小操作数就是 j。同样地，当 j &#x3D; 0 时，表示 word2 为空，这时要将 word1 转换为空字符串，所以最小操作数就是 i。</p>\n<p>对于任意的 i 和 j，有以下两种情况：</p>\n<ol>\n<li>当 <code>word1[i-1] == word2[j-1] </code>时，不需要进行任何操作，所以 <code>dp[i][j] = dp[i-1][j-1]</code>。</li>\n<li>当 <code>word1[i-1] != word2[j-1] </code>时，有三种操作可以选择，分别为：<ol>\n<li>在 word1 的第 i 个字符后面插入一个和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i][j-1] + 1</code>。</li>\n<li>删除 word1 的第 i 个字符，这样就可以让 word1 的前 i-1 个字符和 word2 的前 j 个字符相等。操作数为<code> dp[i-1][j] + 1</code>。</li>\n<li>将 word1 的第 i 个字符替换成和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i-1][j-1] + 1</code>。</li>\n</ol>\n</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minDistance(string word1, string word2) &#123;\n        int m &#x3D; word1.size();  &#x2F;&#x2F; 获取 word1 的长度\n        int n &#x3D; word2.size();  &#x2F;&#x2F; 获取 word2 的长度\n        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1));  &#x2F;&#x2F; 定义一个二维数组 dp，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数\n        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 当 word2 为空字符串时，需要将 word1 转换为空字符串，所以最小操作数为 i\n            dp[i][0] &#x3D; i;\n        &#125;\n        for (int j &#x3D; 0; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 当 word1 为空字符串时，需要将 word1 转换为 word2 的前 j 个字符，所以最小操作数为 j\n            dp[0][j] &#x3D; j;\n        &#125;\n        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 从 word1 的第一个字符开始遍历\n            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 从 word2 的第一个字符开始遍历\n                if (word1[i-1] &#x3D;&#x3D; word2[j-1]) &#123;  &#x2F;&#x2F; 如果 word1 的第 i 个字符和 word2 的第 j 个字符相等，不需要进行任何操作\n                    dp[i][j] &#x3D; dp[i-1][j-1];\n                &#125; else &#123;  &#x2F;&#x2F; 否则，有三种操作可以选择\n                    dp[i][j] &#x3D; min(dp[i][j-1], min(dp[i-1][j], dp[i-1][j-1])) + 1;  &#x2F;&#x2F; 分别为插入、删除和替换一个字符，选择操作数最小的那个\n                &#125;\n            &#125;\n        &#125;\n        return dp[m][n];  &#x2F;&#x2F; 返回最小操作数\n    &#125;\n&#125;;</code></pre>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;\n输出：3\n解释：\nhorse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)\nrorse -&gt; rose (删除 &#39;r&#39;)\nrose -&gt; ros (删除 &#39;e&#39;)</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;\n输出：5\n解释：\nintention -&gt; inention (删除 &#39;t&#39;)\ninention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)\nenention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)\nexention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)\nexection -&gt; execution (插入 &#39;u&#39;)</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这道题要求我们找到从 word1 转换到 word2 所需要的最小操作数，其中每个操作都是插入、删除或替换一个字符。这道题可以使用动态规划来解决。我们可以定义一个 dp 数组，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数。</p>\n<p>当 i &#x3D; 0 时，表示 word1 为空，这时要将 word1 转换为 word2 的前 j 个字符，所以最小操作数就是 j。同样地，当 j &#x3D; 0 时，表示 word2 为空，这时要将 word1 转换为空字符串，所以最小操作数就是 i。</p>\n<p>对于任意的 i 和 j，有以下两种情况：</p>\n<ol>\n<li>当 <code>word1[i-1] == word2[j-1] </code>时，不需要进行任何操作，所以 <code>dp[i][j] = dp[i-1][j-1]</code>。</li>\n<li>当 <code>word1[i-1] != word2[j-1] </code>时，有三种操作可以选择，分别为：<ol>\n<li>在 word1 的第 i 个字符后面插入一个和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i][j-1] + 1</code>。</li>\n<li>删除 word1 的第 i 个字符，这样就可以让 word1 的前 i-1 个字符和 word2 的前 j 个字符相等。操作数为<code> dp[i-1][j] + 1</code>。</li>\n<li>将 word1 的第 i 个字符替换成和 word2 的第 j 个字符相同的字符，这样就可以让 word1 的前 i 个字符和 word2 的前 j 个字符相等。操作数为 <code>dp[i-1][j-1] + 1</code>。</li>\n</ol>\n</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minDistance(string word1, string word2) &#123;\n        int m &#x3D; word1.size();  &#x2F;&#x2F; 获取 word1 的长度\n        int n &#x3D; word2.size();  &#x2F;&#x2F; 获取 word2 的长度\n        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1));  &#x2F;&#x2F; 定义一个二维数组 dp，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作数\n        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 当 word2 为空字符串时，需要将 word1 转换为空字符串，所以最小操作数为 i\n            dp[i][0] &#x3D; i;\n        &#125;\n        for (int j &#x3D; 0; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 当 word1 为空字符串时，需要将 word1 转换为 word2 的前 j 个字符，所以最小操作数为 j\n            dp[0][j] &#x3D; j;\n        &#125;\n        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;  &#x2F;&#x2F; 从 word1 的第一个字符开始遍历\n            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;  &#x2F;&#x2F; 从 word2 的第一个字符开始遍历\n                if (word1[i-1] &#x3D;&#x3D; word2[j-1]) &#123;  &#x2F;&#x2F; 如果 word1 的第 i 个字符和 word2 的第 j 个字符相等，不需要进行任何操作\n                    dp[i][j] &#x3D; dp[i-1][j-1];\n                &#125; else &#123;  &#x2F;&#x2F; 否则，有三种操作可以选择\n                    dp[i][j] &#x3D; min(dp[i][j-1], min(dp[i-1][j], dp[i-1][j-1])) + 1;  &#x2F;&#x2F; 分别为插入、删除和替换一个字符，选择操作数最小的那个\n                &#125;\n            &#125;\n        &#125;\n        return dp[m][n];  &#x2F;&#x2F; 返回最小操作数\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}