{"title":"leetcode1049.最后一块石头的重量II","slug":"leetcode1049-最后一块石头的重量II","date":"2023-04-26T06:50:18.000Z","updated":"2023-04-26T06:53:13.715Z","comments":true,"path":"api/articles/leetcode1049-最后一块石头的重量II.json","excerpt":"题目有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>\n<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>\n<ul>\n<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>\n<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>\n</ul>\n<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：stones &#x3D; [2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：stones &#x3D; [31,26,33,21,40]\n输出：5</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= stones.length &lt;= 30</code></li>\n<li><code>1 &lt;= stones[i] &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这是一道动态规划问题。我们可以定义一个 dp 数组，其中 dp[i] 表示背包容量为 i 时能够得到的最大价值。这里价值就是石头的重量。</p>\n<p>具体来说，对于每一块石头，我们可以选择将其放入背包中，也可以不放入背包中。如果我们选择将其放入背包中，则可以得到的最大价值为 dp[j-stones[i]]+stones[i]，其中 j-stones[i] 表示剩余背包容量，dp[j-stones[i]] 表示剩余背包容量为 j-stones[i] 时能够得到的最大价值，stones[i] 表示当前石头的重量。</p>\n<p>遍历完所有的石头后，dp[target] 就是能够得到的最大价值，其中 target 是所有石头重量之和的一半（因为我们要得到最终得到的石头的最小可能重量，因此需要将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值）。</p>\n<p>最终得到的石头的重量就是 sum - 2*dp[target]，其中 sum 是所有石头的重量之和。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;\n        int sum &#x3D; accumulate(stones.begin(), stones.end(), 0); &#x2F;&#x2F; 计算所有石头重量之和\n        int target &#x3D; sum &#x2F; 2; &#x2F;&#x2F; 将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值\n        vector&lt;int&gt; dp(target+1, 0); &#x2F;&#x2F; 定义动态规划数组\n        for(int i&#x3D;0; i&lt;stones.size(); i++) &#123; &#x2F;&#x2F; 遍历每一块石头\n            for(int j&#x3D;target; j&gt;&#x3D;stones[i]; j--) &#123; &#x2F;&#x2F; 从后往前更新 dp 数组\n                dp[j] &#x3D; max(dp[j], dp[j-stones[i]]+stones[i]); &#x2F;&#x2F; 更新 dp 数组\n            &#125;\n        &#125;\n        return sum - 2*dp[target]; &#x2F;&#x2F; 返回最终得到的石头的重量\n    &#125;\n&#125;;</code></pre>\n\n<p>在上面的代码中，我们首先使用<code>std::accumulate</code>库函数对石头的重量进行求和，得到所有石头的总重量<code>sum</code>。接着，我们将原问题转化为求解容量为<code>sum/2</code>的背包能够得到的最大价值，因此定义了一个<code>target</code>变量来保存这个值。</p>\n<p>然后，我们定义了一个长度为<code>target+1</code>的<code>dp</code>数组，其中<code>dp[i]</code>表示背包容量为<code>i</code>时能够得到的最大价值。这个数组的初始化值都是0。</p>\n<p>接下来，我们遍历每一块石头，并对每一块石头进行背包问题的动态规划更新。具体来说，对于第<code>i</code>块石头，我们从<code>target</code>向<code>stones[i]</code>遍历，更新所有<code>dp[j]</code>（<code>j&gt;=stones[i]</code>）。更新公式为<code>dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</code></p>\n<p>这里<code>dp[j-stones[i]]</code>表示在放入第<code>i</code>块石头前剩余的背包容量，因此需要从<code>dp[j-stones[i]]</code>中加上当前石头的重量<code>stones[i]</code>才能得到在放入第<code>i</code>块石头后的最大价值。最后，我们返回最终得到的石头的重量，即<code>sum-2*dp[target]</code>。</p>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：stones &#x3D; [2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：stones &#x3D; [31,26,33,21,40]\n输出：5</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= stones.length &lt;= 30</code></li>\n<li><code>1 &lt;= stones[i] &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这是一道动态规划问题。我们可以定义一个 dp 数组，其中 dp[i] 表示背包容量为 i 时能够得到的最大价值。这里价值就是石头的重量。</p>\n<p>具体来说，对于每一块石头，我们可以选择将其放入背包中，也可以不放入背包中。如果我们选择将其放入背包中，则可以得到的最大价值为 dp[j-stones[i]]+stones[i]，其中 j-stones[i] 表示剩余背包容量，dp[j-stones[i]] 表示剩余背包容量为 j-stones[i] 时能够得到的最大价值，stones[i] 表示当前石头的重量。</p>\n<p>遍历完所有的石头后，dp[target] 就是能够得到的最大价值，其中 target 是所有石头重量之和的一半（因为我们要得到最终得到的石头的最小可能重量，因此需要将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值）。</p>\n<p>最终得到的石头的重量就是 sum - 2*dp[target]，其中 sum 是所有石头的重量之和。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;\n        int sum &#x3D; accumulate(stones.begin(), stones.end(), 0); &#x2F;&#x2F; 计算所有石头重量之和\n        int target &#x3D; sum &#x2F; 2; &#x2F;&#x2F; 将原问题转化为求解容量为 sum&#x2F;2 的背包能够得到的最大价值\n        vector&lt;int&gt; dp(target+1, 0); &#x2F;&#x2F; 定义动态规划数组\n        for(int i&#x3D;0; i&lt;stones.size(); i++) &#123; &#x2F;&#x2F; 遍历每一块石头\n            for(int j&#x3D;target; j&gt;&#x3D;stones[i]; j--) &#123; &#x2F;&#x2F; 从后往前更新 dp 数组\n                dp[j] &#x3D; max(dp[j], dp[j-stones[i]]+stones[i]); &#x2F;&#x2F; 更新 dp 数组\n            &#125;\n        &#125;\n        return sum - 2*dp[target]; &#x2F;&#x2F; 返回最终得到的石头的重量\n    &#125;\n&#125;;</code></pre>\n\n<p>在上面的代码中，我们首先使用<code>std::accumulate</code>库函数对石头的重量进行求和，得到所有石头的总重量<code>sum</code>。接着，我们将原问题转化为求解容量为<code>sum/2</code>的背包能够得到的最大价值，因此定义了一个<code>target</code>变量来保存这个值。</p>\n<p>然后，我们定义了一个长度为<code>target+1</code>的<code>dp</code>数组，其中<code>dp[i]</code>表示背包容量为<code>i</code>时能够得到的最大价值。这个数组的初始化值都是0。</p>\n<p>接下来，我们遍历每一块石头，并对每一块石头进行背包问题的动态规划更新。具体来说，对于第<code>i</code>块石头，我们从<code>target</code>向<code>stones[i]</code>遍历，更新所有<code>dp[j]</code>（<code>j&gt;=stones[i]</code>）。更新公式为<code>dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</code></p>\n<p>这里<code>dp[j-stones[i]]</code>表示在放入第<code>i</code>块石头前剩余的背包容量，因此需要从<code>dp[j-stones[i]]</code>中加上当前石头的重量<code>stones[i]</code>才能得到在放入第<code>i</code>块石头后的最大价值。最后，我们返回最终得到的石头的重量，即<code>sum-2*dp[target]</code>。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}