{"title":"leetcode123.买卖股票的最佳时机III","slug":"leetcode123-买卖股票的最佳时机III","date":"2023-04-27T06:13:04.000Z","updated":"2023-04-27T06:16:29.454Z","comments":true,"path":"api/articles/leetcode123-买卖股票的最佳时机III.json","excerpt":"题目给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：prices &#x3D; [3,3,5,0,0,3,1,4]\n输出：6\n解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。\n     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：prices &#x3D; [1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：prices &#x3D; [7,6,4,3,1] \n输出：0 \n解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：prices &#x3D; [1]\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= prices.length &lt;= 105</code></li>\n<li><code>0 &lt;= prices[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>这道题是需要我们计算在最多进行两次买卖的情况下，所能获得的最大利润。我们可以定义四个状态分别为：</p>\n<ul>\n<li><code>buy1</code>表示第一次买入时的最大收益；</li>\n</ul>\n<ul>\n<li><code>sell1</code>表示第一次卖出时的最大收益；</li>\n<li><code>buy2</code>表示第二次买入时的最大收益；</li>\n<li><code>sell2</code>表示第二次卖出时的最大收益。</li>\n</ul>\n<p>对于这四个状态，我们可以使用动态规划算法进行求解。具体地，对于第i天的情况，我们有以下状态转移方程：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">buy1 &#x3D; max(buy1, -prices[i]);    &#x2F;&#x2F;第一次买入的最大收益，可以选择不进行或进行\nsell1 &#x3D; max(sell1, buy1 + prices[i]);  &#x2F;&#x2F;第一次卖出的最大收益，可以选择不进行或进行\nbuy2 &#x3D; max(buy2, sell1 - prices[i]);  &#x2F;&#x2F;第二次买入的最大收益，可以选择不进行或进行\nsell2 &#x3D; max(sell2, buy2 + prices[i]); &#x2F;&#x2F;第二次卖出的最大收益，可以选择不进行或进行</code></pre>\n\n<p>其中，<code>buy1</code>和<code>buy2</code>的更新都使用上一次买入的最大收益减去当前股票价格来更新，因为如果当前的股票价格越低，那么买入的收益也就越大。而对于<code>sell1</code>和<code>sell2</code>的更新则使用上一次的买入收益加上当前股票价格来更新，因为如果当前的股票价格越高，那么卖出的收益也就越大。</p>\n<p>最后，我们的最大收益就是第二次卖出时的最大收益<code>sell2</code>。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int buy1 &#x3D; -prices[0], sell1 &#x3D; 0, buy2 &#x3D; -prices[0], sell2 &#x3D; 0;\n        for(int i &#x3D; 1; i &lt; prices.size(); i++)&#123;\n            &#x2F;&#x2F; 第一次买入的最大收益，可以选择不进行或进行\n            buy1 &#x3D; max(buy1, -prices[i]);\n            &#x2F;&#x2F; 第一次卖出的最大收益，可以选择不进行或进行\n            sell1 &#x3D; max(sell1, buy1 + prices[i]);\n            &#x2F;&#x2F; 第二次买入的最大收益，可以选择不进行或进行\n            buy2 &#x3D; max(buy2, sell1 - prices[i]);\n            &#x2F;&#x2F; 第二次卖出的最大收益，可以选择不进行或进行\n            sell2 &#x3D; max(sell2, buy2 + prices[i]);\n        &#125;\n        &#x2F;&#x2F; 返回第二次卖出时的最大收益\n        return sell2;\n    &#125;\n&#125;;</code></pre>\n\n<p>时间复杂度：O(n)，其中n是股票的天数，只需要遍历一遍数组即可求解。</p>\n<p>空间复杂度：O(1)，使用了常数个变量来存储状态。</p>\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：prices &#x3D; [3,3,5,0,0,3,1,4]\n输出：6\n解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。\n     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：prices &#x3D; [1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：prices &#x3D; [7,6,4,3,1] \n输出：0 \n解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：prices &#x3D; [1]\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= prices.length &lt;= 105</code></li>\n<li><code>0 &lt;= prices[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>这道题是需要我们计算在最多进行两次买卖的情况下，所能获得的最大利润。我们可以定义四个状态分别为：</p>\n<ul>\n<li><code>buy1</code>表示第一次买入时的最大收益；</li>\n</ul>\n<ul>\n<li><code>sell1</code>表示第一次卖出时的最大收益；</li>\n<li><code>buy2</code>表示第二次买入时的最大收益；</li>\n<li><code>sell2</code>表示第二次卖出时的最大收益。</li>\n</ul>\n<p>对于这四个状态，我们可以使用动态规划算法进行求解。具体地，对于第i天的情况，我们有以下状态转移方程：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">buy1 &#x3D; max(buy1, -prices[i]);    &#x2F;&#x2F;第一次买入的最大收益，可以选择不进行或进行\nsell1 &#x3D; max(sell1, buy1 + prices[i]);  &#x2F;&#x2F;第一次卖出的最大收益，可以选择不进行或进行\nbuy2 &#x3D; max(buy2, sell1 - prices[i]);  &#x2F;&#x2F;第二次买入的最大收益，可以选择不进行或进行\nsell2 &#x3D; max(sell2, buy2 + prices[i]); &#x2F;&#x2F;第二次卖出的最大收益，可以选择不进行或进行</code></pre>\n\n<p>其中，<code>buy1</code>和<code>buy2</code>的更新都使用上一次买入的最大收益减去当前股票价格来更新，因为如果当前的股票价格越低，那么买入的收益也就越大。而对于<code>sell1</code>和<code>sell2</code>的更新则使用上一次的买入收益加上当前股票价格来更新，因为如果当前的股票价格越高，那么卖出的收益也就越大。</p>\n<p>最后，我们的最大收益就是第二次卖出时的最大收益<code>sell2</code>。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int buy1 &#x3D; -prices[0], sell1 &#x3D; 0, buy2 &#x3D; -prices[0], sell2 &#x3D; 0;\n        for(int i &#x3D; 1; i &lt; prices.size(); i++)&#123;\n            &#x2F;&#x2F; 第一次买入的最大收益，可以选择不进行或进行\n            buy1 &#x3D; max(buy1, -prices[i]);\n            &#x2F;&#x2F; 第一次卖出的最大收益，可以选择不进行或进行\n            sell1 &#x3D; max(sell1, buy1 + prices[i]);\n            &#x2F;&#x2F; 第二次买入的最大收益，可以选择不进行或进行\n            buy2 &#x3D; max(buy2, sell1 - prices[i]);\n            &#x2F;&#x2F; 第二次卖出的最大收益，可以选择不进行或进行\n            sell2 &#x3D; max(sell2, buy2 + prices[i]);\n        &#125;\n        &#x2F;&#x2F; 返回第二次卖出时的最大收益\n        return sell2;\n    &#125;\n&#125;;</code></pre>\n\n<p>时间复杂度：O(n)，其中n是股票的天数，只需要遍历一遍数组即可求解。</p>\n<p>空间复杂度：O(1)，使用了常数个变量来存储状态。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}