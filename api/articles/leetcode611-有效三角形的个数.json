{"title":"leetcode611.有效三角形的个数","slug":"leetcode611-有效三角形的个数","date":"2023-09-15T10:27:08.000Z","updated":"2023-09-15T10:30:07.945Z","comments":true,"path":"api/articles/leetcode611-有效三角形的个数.json","excerpt":"题目给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [2,2,3,4]\n输出: 3\n解释:有效的组合是: \n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [4,2,3,4]\n输出: 4</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>遍历+双指针优化</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int result &#x3D; 0; &#x2F;&#x2F; 初始化结果\n        sort(nums.begin(), nums.end()); &#x2F;&#x2F; 对数组排序\n        int n &#x3D; nums.size();\n        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;\n            if (nums[i] &#x3D;&#x3D; 0) continue; &#x2F;&#x2F; 跳过为0的状态\n            int k &#x3D; i + 2; &#x2F;&#x2F; 第二个指针的初始化位置\n            for (int j &#x3D; i + 1; j &lt; n - 1; j++) &#123;\n                while (k &lt; n &amp;&amp; nums[i] + nums[j] &gt; nums[k]) &#123;\n                    k++;\n                &#125;\n                result +&#x3D; k - j - 1;&#x2F;&#x2F; k - j - 1 表示的是满足条件的第三个边的数量\n            &#125;\n        &#125;\n        return result; &#x2F;&#x2F; 返回结果\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [2,2,3,4]\n输出: 3\n解释:有效的组合是: \n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [4,2,3,4]\n输出: 4</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>遍历+双指针优化</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int result &#x3D; 0; &#x2F;&#x2F; 初始化结果\n        sort(nums.begin(), nums.end()); &#x2F;&#x2F; 对数组排序\n        int n &#x3D; nums.size();\n        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;\n            if (nums[i] &#x3D;&#x3D; 0) continue; &#x2F;&#x2F; 跳过为0的状态\n            int k &#x3D; i + 2; &#x2F;&#x2F; 第二个指针的初始化位置\n            for (int j &#x3D; i + 1; j &lt; n - 1; j++) &#123;\n                while (k &lt; n &amp;&amp; nums[i] + nums[j] &gt; nums[k]) &#123;\n                    k++;\n                &#125;\n                result +&#x3D; k - j - 1;&#x2F;&#x2F; k - j - 1 表示的是满足条件的第三个边的数量\n            &#125;\n        &#125;\n        return result; &#x2F;&#x2F; 返回结果\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}