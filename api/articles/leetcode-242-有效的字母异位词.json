{"title":"leetcode:242.有效的字母异位词","slug":"leetcode-242-有效的字母异位词","date":"2023-01-08T06:59:51.000Z","updated":"2023-01-10T07:19:01.443Z","comments":true,"path":"api/articles/leetcode-242-有效的字母异位词.json","excerpt":"题目给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p>\n<p><strong>注意：</strong>若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;\n输出: true</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;\n输出: false</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>\n<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>暴力解法，用C++实现</li>\n</ol>\n<p>主要思路：首先对两个字符串的长度进行比较，若不一致则返回false，接下来，因为字符串的字母共有26个，因此遍历统计字符串中每个字母的个数，并用一个大小为26的对应数组进行存储，最后遍历对比两个字符串对应的统计个数的数组是否一致，对比的结果即为最终结果，代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isAnagram(string s, string t) &#123;\n        &#x2F;&#x2F;对每个字符串的字母个数统计数组的初始化\n        int arr_s[26] &#x3D; &#123;0&#125;;\n        int arr_t[26] &#x3D; &#123;0&#125;;\n        &#x2F;&#x2F;计算两个字符串的长度，如果长度不同，那么一定不是字母异位词\n        int len_s &#x3D; s.length();\n        int len_t &#x3D; t.length();\n        if(len_s !&#x3D; len_t)\n        &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F;在遍历中确定每个字母统计的下标，并且+1\n        for(int i &#x3D; 0; i &lt; len_s; i++)&#123;\n            int index_s &#x3D; (int)(s[i] - &#39;a&#39;);\n            int index_t &#x3D; (int)(t[i] - &#39;a&#39;);\n            arr_s[index_s] &#x3D; arr_s[index_s] + 1;\n            arr_t[index_t] &#x3D; arr_t[index_t] + 1;\n        &#125;\n        &#x2F;&#x2F;对比两个字符串的字母的种类和个数是否一致\n        for(int i &#x3D; 0; i &lt; 26; i++)&#123;\n            if(arr_s[i] !&#x3D; arr_t[i])\n                return false;\n        &#125;\n        &#x2F;&#x2F;最终返回结果\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;\n输出: true</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;\n输出: false</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>\n<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>暴力解法，用C++实现</li>\n</ol>\n<p>主要思路：首先对两个字符串的长度进行比较，若不一致则返回false，接下来，因为字符串的字母共有26个，因此遍历统计字符串中每个字母的个数，并用一个大小为26的对应数组进行存储，最后遍历对比两个字符串对应的统计个数的数组是否一致，对比的结果即为最终结果，代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isAnagram(string s, string t) &#123;\n        &#x2F;&#x2F;对每个字符串的字母个数统计数组的初始化\n        int arr_s[26] &#x3D; &#123;0&#125;;\n        int arr_t[26] &#x3D; &#123;0&#125;;\n        &#x2F;&#x2F;计算两个字符串的长度，如果长度不同，那么一定不是字母异位词\n        int len_s &#x3D; s.length();\n        int len_t &#x3D; t.length();\n        if(len_s !&#x3D; len_t)\n        &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F;在遍历中确定每个字母统计的下标，并且+1\n        for(int i &#x3D; 0; i &lt; len_s; i++)&#123;\n            int index_s &#x3D; (int)(s[i] - &#39;a&#39;);\n            int index_t &#x3D; (int)(t[i] - &#39;a&#39;);\n            arr_s[index_s] &#x3D; arr_s[index_s] + 1;\n            arr_t[index_t] &#x3D; arr_t[index_t] + 1;\n        &#125;\n        &#x2F;&#x2F;对比两个字符串的字母的种类和个数是否一致\n        for(int i &#x3D; 0; i &lt; 26; i++)&#123;\n            if(arr_s[i] !&#x3D; arr_t[i])\n                return false;\n        &#125;\n        &#x2F;&#x2F;最终返回结果\n        return true;\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}