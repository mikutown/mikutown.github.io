{"title":"leetcode338.比特位计数","slug":"leetcode338-比特位计数","date":"2023-08-02T00:43:43.000Z","updated":"2023-08-02T00:56:41.933Z","comments":true,"path":"api/articles/leetcode338-比特位计数.json","excerpt":"题目给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2\n输出：[0,1,1]\n解释：\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 5\n输出：[0,1,1,2,1,2]\n解释：\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n3 --&gt; 11\n4 --&gt; 100\n5 --&gt; 101</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= n &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>很容易就能实现时间复杂度为 <code>O(n log n)</code> 的解决方案，你可以在线性时间复杂度 <code>O(n)</code> 内用一趟扫描解决此问题吗？</li>\n<li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 <code>__builtin_popcount</code> ）</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<p>思路：首先新建一个数组用来保存结果，接下来从0开始一直循环到输入的n，用while循环+循环内的数字temp&#x3D;temp&amp;(temp-1)的操作获得每一个数字对应的二进制1的个数，然后把对应的个数保存在数组中，最后返回结果数组。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; countBits(int n) &#123;\n        vector&lt;int&gt; results; &#x2F;&#x2F; 创建一个用于存储结果的向量\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123; &#x2F;&#x2F; 循环从 0 到 n\n            int temp &#x3D; i; &#x2F;&#x2F; 将当前迭代的数值保存到 temp 变量中\n            int count &#x3D; 0; &#x2F;&#x2F; 初始化计数器为 0\n            while (temp) &#123; &#x2F;&#x2F; 进行求解二进制中 1 的个数的操作\n                temp &#x3D; temp &amp; (temp - 1); &#x2F;&#x2F; 通过该操作，每次能将 temp 中最右边的 1 变为 0，并统计操作次数，即为 1 的个数\n                count++; &#x2F;&#x2F; 统计 1 的个数\n            &#125;\n            results.push_back(count); &#x2F;&#x2F; 将统计得到的 1 的个数添加到结果向量中\n        &#125;\n        return results; &#x2F;&#x2F; 返回结果向量\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>动态规划</li>\n</ul>\n<p>在这个问题中，我们可以利用已经计算过的结果来求解新的结果。思路如下：对于任意的非负整数 i，其二进制表示中 1 的个数可以通过以下方式求得：</p>\n<ol>\n<li>如果 i 是偶数，那么 i 的二进制表示中 1 的个数等于 i&#x2F;2 的二进制表示中 1 的个数，因为 i 相当于将 i&#x2F;2 左移一位并在末尾补上一个 0。</li>\n<li>如果 i 是奇数，那么 i 的二进制表示中 1 的个数等于 i-1 的二进制表示中 1 的个数再加 1，因为 i 相当于将 i-1 的二进制表示中最右边的 1 变为 0。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; countBits(int n) &#123;\n        vector&lt;int&gt; results(n + 1, 0); &#x2F;&#x2F; 创建一个长度为 n+1 的向量，并初始化所有元素为 0\n        \n        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            if (i % 2 &#x3D;&#x3D; 0) &#123;\n                &#x2F;&#x2F; 对于偶数 i，其二进制表示中 1 的个数等于 i&#x2F;2 的二进制表示中 1 的个数\n                results[i] &#x3D; results[i &#x2F; 2];\n            &#125; else &#123;\n                &#x2F;&#x2F; 对于奇数 i，其二进制表示中 1 的个数等于 i-1 的二进制表示中 1 的个数再加 1\n                results[i] &#x3D; results[i - 1] + 1;\n            &#125;\n        &#125;\n        \n        return results;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2\n输出：[0,1,1]\n解释：\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 5\n输出：[0,1,1,2,1,2]\n解释：\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n3 --&gt; 11\n4 --&gt; 100\n5 --&gt; 101</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= n &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>很容易就能实现时间复杂度为 <code>O(n log n)</code> 的解决方案，你可以在线性时间复杂度 <code>O(n)</code> 内用一趟扫描解决此问题吗？</li>\n<li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 <code>__builtin_popcount</code> ）</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<p>思路：首先新建一个数组用来保存结果，接下来从0开始一直循环到输入的n，用while循环+循环内的数字temp&#x3D;temp&amp;(temp-1)的操作获得每一个数字对应的二进制1的个数，然后把对应的个数保存在数组中，最后返回结果数组。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; countBits(int n) &#123;\n        vector&lt;int&gt; results; &#x2F;&#x2F; 创建一个用于存储结果的向量\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123; &#x2F;&#x2F; 循环从 0 到 n\n            int temp &#x3D; i; &#x2F;&#x2F; 将当前迭代的数值保存到 temp 变量中\n            int count &#x3D; 0; &#x2F;&#x2F; 初始化计数器为 0\n            while (temp) &#123; &#x2F;&#x2F; 进行求解二进制中 1 的个数的操作\n                temp &#x3D; temp &amp; (temp - 1); &#x2F;&#x2F; 通过该操作，每次能将 temp 中最右边的 1 变为 0，并统计操作次数，即为 1 的个数\n                count++; &#x2F;&#x2F; 统计 1 的个数\n            &#125;\n            results.push_back(count); &#x2F;&#x2F; 将统计得到的 1 的个数添加到结果向量中\n        &#125;\n        return results; &#x2F;&#x2F; 返回结果向量\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>动态规划</li>\n</ul>\n<p>在这个问题中，我们可以利用已经计算过的结果来求解新的结果。思路如下：对于任意的非负整数 i，其二进制表示中 1 的个数可以通过以下方式求得：</p>\n<ol>\n<li>如果 i 是偶数，那么 i 的二进制表示中 1 的个数等于 i&#x2F;2 的二进制表示中 1 的个数，因为 i 相当于将 i&#x2F;2 左移一位并在末尾补上一个 0。</li>\n<li>如果 i 是奇数，那么 i 的二进制表示中 1 的个数等于 i-1 的二进制表示中 1 的个数再加 1，因为 i 相当于将 i-1 的二进制表示中最右边的 1 变为 0。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; countBits(int n) &#123;\n        vector&lt;int&gt; results(n + 1, 0); &#x2F;&#x2F; 创建一个长度为 n+1 的向量，并初始化所有元素为 0\n        \n        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            if (i % 2 &#x3D;&#x3D; 0) &#123;\n                &#x2F;&#x2F; 对于偶数 i，其二进制表示中 1 的个数等于 i&#x2F;2 的二进制表示中 1 的个数\n                results[i] &#x3D; results[i &#x2F; 2];\n            &#125; else &#123;\n                &#x2F;&#x2F; 对于奇数 i，其二进制表示中 1 的个数等于 i-1 的二进制表示中 1 的个数再加 1\n                results[i] &#x3D; results[i - 1] + 1;\n            &#125;\n        &#125;\n        \n        return results;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}