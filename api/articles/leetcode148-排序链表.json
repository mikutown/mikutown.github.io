{"title":"leetcode148.排序链表","slug":"leetcode148-排序链表","date":"2023-03-08T05:42:24.000Z","updated":"2023-03-08T06:48:29.188Z","comments":true,"path":"api/articles/leetcode148-排序链表.json","excerpt":null,"covers":["https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg","https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [4,2,1,3]\n输出：[1,2,3,4]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [-1,5,3,4,0]\n输出：[-1,0,3,4,5]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>为了解题而解题的解法</li>\n</ol>\n<p>建立一个动态数组nodes，将链表中的每个元素放入动态数组中，然后使用sort排序，接着将动态数组进行遍历，将每个数字新建一个节点放入结果链表中，C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* sortList(ListNode* head) &#123;\n        vector&lt;int&gt; nodes;\n        while (head !&#x3D; nullptr) &#123;\n            nodes.push_back(head-&gt;val); &#x2F;&#x2F; 将链表的每个节点的值放入动态数组中\n            head &#x3D; head-&gt;next;\n        &#125;\n        sort(nodes.begin(), nodes.end()); &#x2F;&#x2F; 对动态数组中的元素进行排序\n        ListNode* sortedList &#x3D; nullptr;\n        ListNode** cur &#x3D; &amp;sortedList; &#x2F;&#x2F; 定义一个指向指针的指针 cur \n       \n        for (auto node_num: nodes) &#123;\n            *cur &#x3D; new ListNode(node_num); &#x2F;&#x2F; 将排序好的数字加入新链表中\n            cur &#x3D; &amp;((*cur)-&gt;next);\n        &#125;\n        return sortedList; &#x2F;&#x2F; 返回链表头节点\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>这段代码涉及了指针和地址的操作，可以解读为：</p>\n<p>​        ListNode** cur：定义一个指向指针的指针 cur</p>\n<p>​        &amp;sortedList：获取 sortedList 的地址，也就是一个指向指针 sortedList 的指针</p>\n<p>​        cur &#x3D; &amp;sortedList：将 sortedList 的地址赋值给 cur，此时 cur 指向 sortedList 的指针</p>\n<p> 这样做的目的是为了可以更改 sortedList 的指针，从而修改链表结构。在 for 循环中，*cur 表示指针 cur 所指向的指针，即 sortedList 的指针，将新的节点插入到 sortedList 后，cur 需要指向插入节点的 next 指针，因此使用了 cur &#x3D; &amp;((*cur)-&gt;next) 的写法。</p>\n</blockquote>\n<ol start=\"2\">\n<li>归并排序</li>\n</ol>\n<p>归并排序的思路如下：利用快慢指针将链表分为左链表和右链表，分而治之，将分得的两个链表进行再一次分割和归并，最终归并得到结果。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; 归并排序\n    ListNode* sortList(ListNode* head) &#123;\n        &#x2F;&#x2F; 如果链表为空或只有一个节点，直接返回\n        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) return head;\n        &#x2F;&#x2F; 找到链表的中点，用快慢指针法\n        ListNode* slow &#x3D; head; &#x2F;&#x2F; 慢指针，每次走一步\n        ListNode* fast &#x3D; head-&gt;next; &#x2F;&#x2F; 快指针，每次走两步\n        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;\n            slow &#x3D; slow-&gt;next; &#x2F;&#x2F; 慢指针走到中点\n            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走到末尾或者null\n        &#125;\n        &#x2F;&#x2F; 将链表从中点断开为两个子链表\n        ListNode* mid &#x3D; slow-&gt;next; \n        slow-&gt;next &#x3D; nullptr;\n        &#x2F;&#x2F; 对左右子链表分别进行排序\n        ListNode* left &#x3D; sortList(head); \n        ListNode* right &#x3D; sortList(mid);\n        &#x2F;&#x2F; 合并两个有序的子链表为一个有序的链表\n        return mergeTwoLists(left, right);\n    &#125;\n\n    &#x2F;&#x2F; 合并两个有序的链表为一个有序的链表\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;\n        &#x2F;&#x2F; 创建一个哑节点作为合并后链表的头结点\n        ListNode dummy(0);\n        &#x2F;&#x2F; 创建一个指针cur指向当前合并后链表的最后一个节点，初始为哑节点\n        ListNode* cur &#x3D; &amp;dummy;\n        \n\t\t&#x2F;&#x2F; 当l1和l2都不为空时，比较它们的值，将较小的值接在cur后面，并更新对应的指针\n\t\twhile (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;\n\t\t\tif (l1-&gt;val &lt; l2-&gt;val) &#123; \n\t\t\t\tcur-&gt;next &#x3D; l1; \n\t\t\t\tl1 &#x3D; l1-&gt;next;\n\t\t\t&#125; else &#123; \n\t\t\t\tcur-&gt;next &#x3D; l2; \n\t\t\t\tl2 &#x3D; l2-&gt;next;\n\t\t\t&#125;\n\t\t\tcur &#x3D; cur-&gt;next; \n\t\t&#125;\n\t\t\n\t\t&#x2F;&#x2F; 当l1或l2有一个为空时，直接将另一个非空的链表接在cur后面即可\n\t\tif (l1 !&#x3D; nullptr) cur-&gt;next &#x3D; l1;\n\t\tif (l2 !&#x3D; nullptr) cur-&gt;next &#x3D; l2;\n\n\t\treturn dummy.next;  &#x2F;&#x2F; 返回哑节点的下一个节点，即合并后链表的头结点\n\n    &#125;\n&#125;;</code></pre>\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [4,2,1,3]\n输出：[1,2,3,4]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [-1,5,3,4,0]\n输出：[-1,0,3,4,5]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>为了解题而解题的解法</li>\n</ol>\n<p>建立一个动态数组nodes，将链表中的每个元素放入动态数组中，然后使用sort排序，接着将动态数组进行遍历，将每个数字新建一个节点放入结果链表中，C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* sortList(ListNode* head) &#123;\n        vector&lt;int&gt; nodes;\n        while (head !&#x3D; nullptr) &#123;\n            nodes.push_back(head-&gt;val); &#x2F;&#x2F; 将链表的每个节点的值放入动态数组中\n            head &#x3D; head-&gt;next;\n        &#125;\n        sort(nodes.begin(), nodes.end()); &#x2F;&#x2F; 对动态数组中的元素进行排序\n        ListNode* sortedList &#x3D; nullptr;\n        ListNode** cur &#x3D; &amp;sortedList; &#x2F;&#x2F; 定义一个指向指针的指针 cur \n       \n        for (auto node_num: nodes) &#123;\n            *cur &#x3D; new ListNode(node_num); &#x2F;&#x2F; 将排序好的数字加入新链表中\n            cur &#x3D; &amp;((*cur)-&gt;next);\n        &#125;\n        return sortedList; &#x2F;&#x2F; 返回链表头节点\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>这段代码涉及了指针和地址的操作，可以解读为：</p>\n<p>​        ListNode** cur：定义一个指向指针的指针 cur</p>\n<p>​        &amp;sortedList：获取 sortedList 的地址，也就是一个指向指针 sortedList 的指针</p>\n<p>​        cur &#x3D; &amp;sortedList：将 sortedList 的地址赋值给 cur，此时 cur 指向 sortedList 的指针</p>\n<p> 这样做的目的是为了可以更改 sortedList 的指针，从而修改链表结构。在 for 循环中，*cur 表示指针 cur 所指向的指针，即 sortedList 的指针，将新的节点插入到 sortedList 后，cur 需要指向插入节点的 next 指针，因此使用了 cur &#x3D; &amp;((*cur)-&gt;next) 的写法。</p>\n</blockquote>\n<ol start=\"2\">\n<li>归并排序</li>\n</ol>\n<p>归并排序的思路如下：利用快慢指针将链表分为左链表和右链表，分而治之，将分得的两个链表进行再一次分割和归并，最终归并得到结果。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; 归并排序\n    ListNode* sortList(ListNode* head) &#123;\n        &#x2F;&#x2F; 如果链表为空或只有一个节点，直接返回\n        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) return head;\n        &#x2F;&#x2F; 找到链表的中点，用快慢指针法\n        ListNode* slow &#x3D; head; &#x2F;&#x2F; 慢指针，每次走一步\n        ListNode* fast &#x3D; head-&gt;next; &#x2F;&#x2F; 快指针，每次走两步\n        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;\n            slow &#x3D; slow-&gt;next; &#x2F;&#x2F; 慢指针走到中点\n            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走到末尾或者null\n        &#125;\n        &#x2F;&#x2F; 将链表从中点断开为两个子链表\n        ListNode* mid &#x3D; slow-&gt;next; \n        slow-&gt;next &#x3D; nullptr;\n        &#x2F;&#x2F; 对左右子链表分别进行排序\n        ListNode* left &#x3D; sortList(head); \n        ListNode* right &#x3D; sortList(mid);\n        &#x2F;&#x2F; 合并两个有序的子链表为一个有序的链表\n        return mergeTwoLists(left, right);\n    &#125;\n\n    &#x2F;&#x2F; 合并两个有序的链表为一个有序的链表\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;\n        &#x2F;&#x2F; 创建一个哑节点作为合并后链表的头结点\n        ListNode dummy(0);\n        &#x2F;&#x2F; 创建一个指针cur指向当前合并后链表的最后一个节点，初始为哑节点\n        ListNode* cur &#x3D; &amp;dummy;\n        \n\t\t&#x2F;&#x2F; 当l1和l2都不为空时，比较它们的值，将较小的值接在cur后面，并更新对应的指针\n\t\twhile (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;\n\t\t\tif (l1-&gt;val &lt; l2-&gt;val) &#123; \n\t\t\t\tcur-&gt;next &#x3D; l1; \n\t\t\t\tl1 &#x3D; l1-&gt;next;\n\t\t\t&#125; else &#123; \n\t\t\t\tcur-&gt;next &#x3D; l2; \n\t\t\t\tl2 &#x3D; l2-&gt;next;\n\t\t\t&#125;\n\t\t\tcur &#x3D; cur-&gt;next; \n\t\t&#125;\n\t\t\n\t\t&#x2F;&#x2F; 当l1或l2有一个为空时，直接将另一个非空的链表接在cur后面即可\n\t\tif (l1 !&#x3D; nullptr) cur-&gt;next &#x3D; l1;\n\t\tif (l2 !&#x3D; nullptr) cur-&gt;next &#x3D; l2;\n\n\t\treturn dummy.next;  &#x2F;&#x2F; 返回哑节点的下一个节点，即合并后链表的头结点\n\n    &#125;\n&#125;;</code></pre>\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}