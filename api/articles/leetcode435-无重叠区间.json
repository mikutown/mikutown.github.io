{"title":"leetcode435.无重叠区间","slug":"leetcode435-无重叠区间","date":"2023-02-22T02:43:40.000Z","updated":"2023-02-22T02:52:22.690Z","comments":true,"path":"api/articles/leetcode435-无重叠区间.json","excerpt":"题目给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]\n输出: 1\n解释: 移除 [1,3] 后，剩下的区间没有重叠。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]\n输出: 2\n解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: intervals &#x3D; [ [1,2], [2,3] ]\n输出: 0\n解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= intervals.length &lt;= 105</code></li>\n<li><code>intervals[i].length == 2</code></li>\n<li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路：</p>\n<p>首先按照区间的结束位置从小到大排序，然后从前往后遍历所有区间，若当前区间和前面的区间不重叠，则保留当前区间，继续向后遍历；否则就舍弃当前区间，再继续向后遍历。最后返回被舍弃的区间数即可。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;\n        int n &#x3D; intervals.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n\n        &#x2F;&#x2F; 按照区间的结束位置从小到大排序\n        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;\n            return a[1] &lt; b[1];\n        &#125;);\n\n        int cnt &#x3D; 1;  &#x2F;&#x2F; 不重叠区间的个数，初始值为1\n        int end &#x3D; intervals[0][1];  &#x2F;&#x2F; 当前不重叠区间的结束位置，初始值为第一个区间的结束位置\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            if (intervals[i][0] &gt;&#x3D; end) &#123;  &#x2F;&#x2F; 如果当前区间的起始位置大于等于当前不重叠区间的结束位置\n                cnt++;  &#x2F;&#x2F; 将不重叠区间的个数加1\n                end &#x3D; intervals[i][1];  &#x2F;&#x2F; 更新当前不重叠区间的结束位置\n            &#125;\n            &#x2F;&#x2F; 如果当前区间的起始位置小于当前不重叠区间的结束位置，说明当前区间与前面的区间重叠了，不能选\n            &#x2F;&#x2F; 不需要执行任何操作，直接跳过\n        &#125;\n\n        return n - cnt;  &#x2F;&#x2F; 总区间个数减去不重叠区间的个数，即为需要去除的重叠区间的最小个数\n    &#125;\n&#125;;</code></pre>\n\n\n\n<p>注：在sort函数中第三个参数为匿名函数，其中的参数是数组，因此：</p>\n<blockquote>\n<p>在排序算法中，通常需要交换数组或容器中的元素位置来实现排序的目的。如果直接将数组或容器作为参数传递给比较函数，那么在函数内部交换元素位置时，就需要复制整个数组或容器，这样会造成不必要的开销。</p>\n<p>因此，通常使用指向数组或容器中元素的指针或引用类型作为比较函数的参数，这样在交换元素位置时只需要交换指针或引用，而不需要复制整个数组或容器。这样可以减小开销，提高效率。</p>\n<p>在本题中，使用 <code>vector&lt;int&gt;&amp;</code> 类型的引用作为比较函数的参数，可以避免复制整个二维向量，同时也可以保证比较函数的参数类型与 STL 中的排序算法所需的参数类型相同，方便函数间的传递和调用。</p>\n</blockquote>\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]\n输出: 1\n解释: 移除 [1,3] 后，剩下的区间没有重叠。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]\n输出: 2\n解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: intervals &#x3D; [ [1,2], [2,3] ]\n输出: 0\n解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= intervals.length &lt;= 105</code></li>\n<li><code>intervals[i].length == 2</code></li>\n<li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路：</p>\n<p>首先按照区间的结束位置从小到大排序，然后从前往后遍历所有区间，若当前区间和前面的区间不重叠，则保留当前区间，继续向后遍历；否则就舍弃当前区间，再继续向后遍历。最后返回被舍弃的区间数即可。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;\n        int n &#x3D; intervals.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n\n        &#x2F;&#x2F; 按照区间的结束位置从小到大排序\n        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;\n            return a[1] &lt; b[1];\n        &#125;);\n\n        int cnt &#x3D; 1;  &#x2F;&#x2F; 不重叠区间的个数，初始值为1\n        int end &#x3D; intervals[0][1];  &#x2F;&#x2F; 当前不重叠区间的结束位置，初始值为第一个区间的结束位置\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            if (intervals[i][0] &gt;&#x3D; end) &#123;  &#x2F;&#x2F; 如果当前区间的起始位置大于等于当前不重叠区间的结束位置\n                cnt++;  &#x2F;&#x2F; 将不重叠区间的个数加1\n                end &#x3D; intervals[i][1];  &#x2F;&#x2F; 更新当前不重叠区间的结束位置\n            &#125;\n            &#x2F;&#x2F; 如果当前区间的起始位置小于当前不重叠区间的结束位置，说明当前区间与前面的区间重叠了，不能选\n            &#x2F;&#x2F; 不需要执行任何操作，直接跳过\n        &#125;\n\n        return n - cnt;  &#x2F;&#x2F; 总区间个数减去不重叠区间的个数，即为需要去除的重叠区间的最小个数\n    &#125;\n&#125;;</code></pre>\n\n\n\n<p>注：在sort函数中第三个参数为匿名函数，其中的参数是数组，因此：</p>\n<blockquote>\n<p>在排序算法中，通常需要交换数组或容器中的元素位置来实现排序的目的。如果直接将数组或容器作为参数传递给比较函数，那么在函数内部交换元素位置时，就需要复制整个数组或容器，这样会造成不必要的开销。</p>\n<p>因此，通常使用指向数组或容器中元素的指针或引用类型作为比较函数的参数，这样在交换元素位置时只需要交换指针或引用，而不需要复制整个数组或容器。这样可以减小开销，提高效率。</p>\n<p>在本题中，使用 <code>vector&lt;int&gt;&amp;</code> 类型的引用作为比较函数的参数，可以避免复制整个二维向量，同时也可以保证比较函数的参数类型与 STL 中的排序算法所需的参数类型相同，方便函数间的传递和调用。</p>\n</blockquote>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}