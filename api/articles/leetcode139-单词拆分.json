{"title":"leetcode139.单词拆分","slug":"leetcode139-单词拆分","date":"2023-08-02T01:25:01.000Z","updated":"2023-08-02T01:27:05.328Z","comments":true,"path":"api/articles/leetcode139-单词拆分.json","excerpt":"题目给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p>\n<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]\n输出: true\n解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]\n输出: true\n解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。\n     注意，你可以重复使用字典中的单词。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\n输出: false</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 300</code></li>\n<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n<li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li>\n<li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>思路： 这个问题可以使用动态规划来解决。我们定义一个布尔数组 dp，其中 dp[i] 表示字符串 s 的前 i 个字符能否被空格拆分成字典中出现的单词。初始时，dp[0] &#x3D; true，表示空字符串可以被拆分。</p>\n<p>然后，我们从字符串 s 的第一个字符开始，依次遍历每个字符。对于每个字符，我们将其与前面的字符组成的子串依次与字典中的单词进行匹配。如果找到了匹配的单词，且前面的子串也可以被拆分成字典中的单词，那么 dp[i] 就为 true。具体的匹配过程可以通过在字典中使用哈希表进行优化，从而避免不必要的字符串匹配。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n        &#x2F;&#x2F; 将字典中的单词存储到哈希表中，方便进行快速查找\n        unordered_set&lt;string&gt; dictSet(wordDict.begin(), wordDict.end());\n\n        int n &#x3D; s.length();\n        &#x2F;&#x2F; 创建一个布尔数组 dp，初始时 dp[0] &#x3D; true，表示空字符串可以被拆分\n        vector&lt;bool&gt; dp(n + 1, false);\n        dp[0] &#x3D; true;\n\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            for (int j &#x3D; 0; j &lt; i; j++) &#123;\n                &#x2F;&#x2F; 如果前面的子串 dp[j] 可以被拆分，并且剩余的子串 s[j:i] 在字典中存在，更新 dp[i] 为 true\n                if (dp[j] &amp;&amp; dictSet.count(s.substr(j, i - j)) &gt; 0) &#123;\n                    dp[i] &#x3D; true;\n                    break; &#x2F;&#x2F; 找到一种拆分方式即可，无需继续循环\n                &#125;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 返回 dp[n]，表示整个字符串是否可以被拆分为字典中的单词\n        return dp[n];\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]\n输出: true\n解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]\n输出: true\n解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。\n     注意，你可以重复使用字典中的单词。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\n输出: false</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 300</code></li>\n<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n<li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li>\n<li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>思路： 这个问题可以使用动态规划来解决。我们定义一个布尔数组 dp，其中 dp[i] 表示字符串 s 的前 i 个字符能否被空格拆分成字典中出现的单词。初始时，dp[0] &#x3D; true，表示空字符串可以被拆分。</p>\n<p>然后，我们从字符串 s 的第一个字符开始，依次遍历每个字符。对于每个字符，我们将其与前面的字符组成的子串依次与字典中的单词进行匹配。如果找到了匹配的单词，且前面的子串也可以被拆分成字典中的单词，那么 dp[i] 就为 true。具体的匹配过程可以通过在字典中使用哈希表进行优化，从而避免不必要的字符串匹配。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n        &#x2F;&#x2F; 将字典中的单词存储到哈希表中，方便进行快速查找\n        unordered_set&lt;string&gt; dictSet(wordDict.begin(), wordDict.end());\n\n        int n &#x3D; s.length();\n        &#x2F;&#x2F; 创建一个布尔数组 dp，初始时 dp[0] &#x3D; true，表示空字符串可以被拆分\n        vector&lt;bool&gt; dp(n + 1, false);\n        dp[0] &#x3D; true;\n\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            for (int j &#x3D; 0; j &lt; i; j++) &#123;\n                &#x2F;&#x2F; 如果前面的子串 dp[j] 可以被拆分，并且剩余的子串 s[j:i] 在字典中存在，更新 dp[i] 为 true\n                if (dp[j] &amp;&amp; dictSet.count(s.substr(j, i - j)) &gt; 0) &#123;\n                    dp[i] &#x3D; true;\n                    break; &#x2F;&#x2F; 找到一种拆分方式即可，无需继续循环\n                &#125;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 返回 dp[n]，表示整个字符串是否可以被拆分为字典中的单词\n        return dp[n];\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}