{"title":"leetcode1356.根据数字二进制下1的数目排序","slug":"leetcode1356-根据数字二进制下1的数目排序","date":"2023-05-09T12:00:40.000Z","updated":"2023-05-09T12:17:09.838Z","comments":true,"path":"api/articles/leetcode1356-根据数字二进制下1的数目排序.json","excerpt":"题目给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。请你返回排序后的数组。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>\n<p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p>\n<p>请你返回排序后的数组。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [0,1,2,3,4,5,6,7,8]\n输出：[0,1,2,4,8,3,5,6,7]\n解释：[0] 是唯一一个有 0 个 1 的数。\n[1,2,4,8] 都有 1 个 1 。\n[3,5,6] 有 2 个 1 。\n[7] 有 3 个 1 。\n按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]\n输出：[1,2,4,8,16,32,64,128,256,512,1024]\n解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [10000,10000]\n输出：[10000,10000]</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [2,3,5,7,11,13,17,19]\n输出：[2,3,5,17,7,11,13,19]</code></pre>\n\n<p><strong>示例 5：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [10,100,1000,10000]\n输出：[10,100,10000,1000]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路如下：</p>\n<ol>\n<li>首先定义一个辅助函数<code>countBits</code>，用于计算一个数的二进制表示中1的个数。该函数使用位运算技巧，通过不断将数字与其自身减1的结果进行按位与运算，可以统计出二进制中1的个数。</li>\n<li>接下来定义一个自定义的比较函数<code>compare</code>，用于在排序时比较两个数的大小。该函数首先分别计算两个数的二进制中1的个数，然后比较它们的个数。如果个数相等，则按照原始数值的大小进行比较。</li>\n<li>然后定义<code>sortByBits</code>函数，该函数接受一个整数数组作为参数，并使用STL的<code>sort</code>函数对数组进行排序。在排序过程中，使用自定义的比较函数<code>compare</code>进行比较。</li>\n<li>在主函数<code>main</code>中，创建一个测试数组<code>arr</code>，并调用<code>sortByBits</code>函数对数组进行排序。排序后的结果保存在<code>sortedArr</code>中。</li>\n<li>最后，通过循环遍历<code>sortedArr</code>，将排序后的数组打印输出。</li>\n</ol>\n<p>整体思路是先计算每个数字的二进制中1的个数，然后根据这个个数进行排序，当个数相同时按照原始数值的大小进行排序。通过自定义比较函数和使用STL的<code>sort</code>函数，可以方便地完成这个排序任务。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int get(int x)&#123;\n        int res &#x3D; 0;\n        while (x) &#123;\n            res +&#x3D; (x % 2);\n            x &#x2F;&#x3D; 2;\n        &#125;\n        return res;\n    &#125;\n    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123;\n        vector&lt;int&gt; bit(10001, 0);\n        for (auto x: arr) &#123;\n            bit[x] &#x3D; get(x);\n        &#125;\n        sort(arr.begin(), arr.end(), [&amp;](int x, int y)&#123; &#x2F;&#x2F; Lambda表达式语法\n            if (bit[x] &lt; bit[y]) &#123;\n                return true;\n            &#125;\n            if (bit[x] &gt; bit[y]) &#123;\n                return false;\n            &#125;\n            return x &lt; y;\n        &#125;);\n        return arr;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [0,1,2,3,4,5,6,7,8]\n输出：[0,1,2,4,8,3,5,6,7]\n解释：[0] 是唯一一个有 0 个 1 的数。\n[1,2,4,8] 都有 1 个 1 。\n[3,5,6] 有 2 个 1 。\n[7] 有 3 个 1 。\n按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]\n输出：[1,2,4,8,16,32,64,128,256,512,1024]\n解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [10000,10000]\n输出：[10000,10000]</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [2,3,5,7,11,13,17,19]\n输出：[2,3,5,17,7,11,13,19]</code></pre>\n\n<p><strong>示例 5：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [10,100,1000,10000]\n输出：[10,100,10000,1000]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路如下：</p>\n<ol>\n<li>首先定义一个辅助函数<code>countBits</code>，用于计算一个数的二进制表示中1的个数。该函数使用位运算技巧，通过不断将数字与其自身减1的结果进行按位与运算，可以统计出二进制中1的个数。</li>\n<li>接下来定义一个自定义的比较函数<code>compare</code>，用于在排序时比较两个数的大小。该函数首先分别计算两个数的二进制中1的个数，然后比较它们的个数。如果个数相等，则按照原始数值的大小进行比较。</li>\n<li>然后定义<code>sortByBits</code>函数，该函数接受一个整数数组作为参数，并使用STL的<code>sort</code>函数对数组进行排序。在排序过程中，使用自定义的比较函数<code>compare</code>进行比较。</li>\n<li>在主函数<code>main</code>中，创建一个测试数组<code>arr</code>，并调用<code>sortByBits</code>函数对数组进行排序。排序后的结果保存在<code>sortedArr</code>中。</li>\n<li>最后，通过循环遍历<code>sortedArr</code>，将排序后的数组打印输出。</li>\n</ol>\n<p>整体思路是先计算每个数字的二进制中1的个数，然后根据这个个数进行排序，当个数相同时按照原始数值的大小进行排序。通过自定义比较函数和使用STL的<code>sort</code>函数，可以方便地完成这个排序任务。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int get(int x)&#123;\n        int res &#x3D; 0;\n        while (x) &#123;\n            res +&#x3D; (x % 2);\n            x &#x2F;&#x3D; 2;\n        &#125;\n        return res;\n    &#125;\n    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123;\n        vector&lt;int&gt; bit(10001, 0);\n        for (auto x: arr) &#123;\n            bit[x] &#x3D; get(x);\n        &#125;\n        sort(arr.begin(), arr.end(), [&amp;](int x, int y)&#123; &#x2F;&#x2F; Lambda表达式语法\n            if (bit[x] &lt; bit[y]) &#123;\n                return true;\n            &#125;\n            if (bit[x] &gt; bit[y]) &#123;\n                return false;\n            &#125;\n            return x &lt; y;\n        &#125;);\n        return arr;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}