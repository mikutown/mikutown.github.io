{"title":"二叉搜索树的操作（pta题目）","slug":"二叉搜索树的操作（pta题目）","date":"2022-03-29T05:29:17.000Z","updated":"2022-03-29T05:33:08.387Z","comments":true,"path":"api/articles/二叉搜索树的操作（pta题目）.json","excerpt":null,"covers":null,"content":"<p>本题要求实现给定二叉搜索树的5种常用操作。</p>\n<p>函数接口定义：</p>\n<pre class=\"language-C\" data-language=\"C\"><code class=\"language-C\">BinTree Insert( BinTree BST, ElementType X );\nBinTree Delete( BinTree BST, ElementType X );\nPosition Find( BinTree BST, ElementType X );\nPosition FindMin( BinTree BST );\nPosition FindMax( BinTree BST );</code></pre>\n<p>其中BinTree结构定义如下：</p>\n<pre class=\"language-C\" data-language=\"C\"><code class=\"language-C\">typedef struct TNode *Position;\ntypedef Position BinTree;\nstruct TNode&#123;\n    ElementType Data;\n    BinTree Left;\n    BinTree Right;\n&#125;;</code></pre>\n<ul>\n<li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li>\n<li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li>\n<li>函数<code>Find</code>在二叉搜索树<code>BST</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li>\n<li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li>\n<li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li>\n</ul>\n<h2 id=\"裁判测试程序样例：\"><a href=\"#裁判测试程序样例：\" class=\"headerlink\" title=\"裁判测试程序样例：\"></a>裁判测试程序样例：</h2><pre class=\"language-C\" data-language=\"C\"><code class=\"language-C\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef int ElementType;\ntypedef struct TNode *Position;\ntypedef Position BinTree;\nstruct TNode&#123;\n    ElementType Data;\n    BinTree Left;\n    BinTree Right;\n&#125;;\n\nvoid PreorderTraversal( BinTree BT ); &#x2F;* 先序遍历，由裁判实现，细节不表 *&#x2F;\nvoid InorderTraversal( BinTree BT );  &#x2F;* 中序遍历，由裁判实现，细节不表 *&#x2F;\n\nBinTree Insert( BinTree BST, ElementType X );\nBinTree Delete( BinTree BST, ElementType X );\nPosition Find( BinTree BST, ElementType X );\nPosition FindMin( BinTree BST );\nPosition FindMax( BinTree BST );\n\nint main()\n&#123;\n    BinTree BST, MinP, MaxP, Tmp;\n    ElementType X;\n    int N, i;\n\n    BST &#x3D; NULL;\n    scanf(&quot;%d&quot;, &amp;N);\n    for ( i&#x3D;0; i&lt;N; i++ ) &#123;\n        scanf(&quot;%d&quot;, &amp;X);\n        BST &#x3D; Insert(BST, X);\n    &#125;\n    printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\\n&quot;);\n    MinP &#x3D; FindMin(BST);\n    MaxP &#x3D; FindMax(BST);\n    scanf(&quot;%d&quot;, &amp;N);\n    for( i&#x3D;0; i&lt;N; i++ ) &#123;\n        scanf(&quot;%d&quot;, &amp;X);\n        Tmp &#x3D; Find(BST, X);\n        if (Tmp &#x3D;&#x3D; NULL) printf(&quot;%d is not found\\n&quot;, X);\n        else &#123;\n            printf(&quot;%d is found\\n&quot;, Tmp-&gt;Data);\n            if (Tmp&#x3D;&#x3D;MinP) printf(&quot;%d is the smallest key\\n&quot;, Tmp-&gt;Data);\n            if (Tmp&#x3D;&#x3D;MaxP) printf(&quot;%d is the largest key\\n&quot;, Tmp-&gt;Data);\n        &#125;\n    &#125;\n    scanf(&quot;%d&quot;, &amp;N);\n    for( i&#x3D;0; i&lt;N; i++ ) &#123;\n        scanf(&quot;%d&quot;, &amp;X);\n        BST &#x3D; Delete(BST, X);\n    &#125;\n    printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\\n&quot;);\n\n    return 0;\n&#125;\n&#x2F;* 你的代码将被嵌在这里 *&#x2F;</code></pre>\n<h2 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h2><pre class=\"language-none\"><code class=\"language-none\">10\n5 8 6 2 4 1 0 10 9 7\n5\n6 3 10 0 5\n5\n5 7 0 10 3</code></pre>\n<h2 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h2><pre class=\"language-none\"><code class=\"language-none\">Preorder: 5 2 1 0 4 8 6 7 10 9\n6 is found\n3 is not found\n10 is found\n10 is the largest key\n0 is found\n0 is the smallest key\n5 is found\nNot Found\nInorder: 1 2 4 6 8 9</code></pre>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><pre class=\"language-C\" data-language=\"C\"><code class=\"language-C\">BinTree Insert( BinTree BST, ElementType X )&#123;\n    &#x2F;&#x2F;如果是一个空节点\n    if(!BST)&#123;\n        BST &#x3D; (BinTree)malloc(sizeof(struct TNode));&#x2F;&#x2F;既然为空所以要生成一个\n        BST-&gt;Data &#x3D; X;\n        BST-&gt;Left &#x3D; NULL;\n        BST-&gt;Right &#x3D; NULL;\n    &#125;\n    else&#123;&#x2F;&#x2F;一般情况\n        if(X &lt; BST-&gt;Data)&#123;&#x2F;&#x2F;插入值小于节点，应该往左子树中找位置\n            BST-&gt;Left &#x3D; Insert(BST-&gt;Left,X);&#x2F;&#x2F;递归插入左子树\n        &#125;\n        else if(X &gt; BST-&gt;Data)&#123;&#x2F;&#x2F;插入值大于节点，应该往右子树中找\n            BST-&gt;Right &#x3D; Insert(BST-&gt;Right,X);&#x2F;&#x2F;递归插入右子树\n        &#125;\n        &#x2F;&#x2F;如果相等说明X已经存在，什么也不做\n    &#125;\n    return BST;\n&#125;\nPosition Find( BinTree BST, ElementType X )&#123;\n    while(BST)&#123;&#x2F;&#x2F;直接循环查找，类似链表\n        if(X &lt; BST-&gt;Data)&#123;\n            BST &#x3D; BST-&gt;Left;&#x2F;&#x2F;小于节点，找左子树\n        &#125;\n        else if(X &gt; BST-&gt;Data)&#123;&#x2F;&#x2F;大于节点，找右子树\n            BST &#x3D; BST-&gt;Right;\n        &#125;\n        else&#123;&#x2F;&#x2F;相等则找到\n            return BST;\n        &#125;\n    &#125;\n    return NULL;\n&#125;\nPosition FindMin( BinTree BST )&#123;\n    if(!BST)&#123;\n        return NULL;\n    &#125;\n    else if(!BST-&gt;Left)\n        return BST;\n    else return FindMin(BST-&gt;Left);\n&#125;\nPosition FindMax( BinTree BST )&#123;\n    if(!BST)return NULL;\n    else if(!BST-&gt;Right)return BST;\n    else return FindMax(BST-&gt;Right);\n&#125;\nBinTree Delete( BinTree BST, ElementType X )&#123;\n    Position temp;\n    if(!BST)&#123;\n        printf(&quot;Not Found\\n&quot;);&#x2F;&#x2F;如果最终树为空，说明没有\n    &#125;\n    else&#123;&#x2F;&#x2F;这里类似于插入重点在于找到后怎么办\n        if(X &lt; BST-&gt;Data)&#123;\n            BST-&gt;Left &#x3D; Delete(BST-&gt;Left,X);&#x2F;&#x2F;从左子树递归删除\n        &#125;\n        else if(X &gt; BST-&gt;Data)&#123;\n            BST-&gt;Right &#x3D; Delete(BST-&gt;Right,X);&#x2F;&#x2F;从右子树递归删除\n        &#125;\n        else&#123;&#x2F;&#x2F;当前BST就是要删除的节点\n              if(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;&#x2F;&#x2F;要被删除的节点有左右两个孩子，就从右子树中找最小的数填充删除的节点\n                temp &#x3D; FindMin(BST-&gt;Right);&#x2F;&#x2F;找最小\n                BST-&gt;Data &#x3D; temp-&gt;Data;&#x2F;&#x2F;填充删除的节点\n                BST-&gt;Right &#x3D; Delete(BST-&gt;Right,temp-&gt;Data);&#x2F;&#x2F;删除拿来填充的那个节点\n              &#125;\n              else&#123;&#x2F;&#x2F;只有一个子节点\n                temp &#x3D; BST;\n                if(!BST-&gt;Left)&#123;&#x2F;&#x2F;只有右节点\n                    BST &#x3D; BST-&gt;Right;&#x2F;&#x2F;直接赋值就可以\n                &#125;\n                else if(!BST-&gt;Right)&#123;&#x2F;&#x2F;只有左节点\n                    BST &#x3D; BST-&gt;Left;&#x2F;&#x2F;直接赋值就可以\n                &#125;\n                free(temp);&#x2F;&#x2F;如果啥也没有直接删除就可以，当然上面两种情况赋值后也要删除\n              &#125;\n        &#125;\n    &#125;\n    return BST;\n&#125;</code></pre>\n","more":"<p>本题要求实现给定二叉搜索树的5种常用操作。</p>\n<p>函数接口定义：</p>\n<pre class=\"language-C\" data-language=\"C\"><code class=\"language-C\">BinTree Insert( BinTree BST, ElementType X );\nBinTree Delete( BinTree BST, ElementType X );\nPosition Find( BinTree BST, ElementType X );\nPosition FindMin( BinTree BST );\nPosition FindMax( BinTree BST );</code></pre>\n<p>其中BinTree结构定义如下：</p>\n<pre class=\"language-C\" data-language=\"C\"><code class=\"language-C\">typedef struct TNode *Position;\ntypedef Position BinTree;\nstruct TNode&#123;\n    ElementType Data;\n    BinTree Left;\n    BinTree Right;\n&#125;;</code></pre>\n<ul>\n<li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li>\n<li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li>\n<li>函数<code>Find</code>在二叉搜索树<code>BST</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li>\n<li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li>\n<li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li>\n</ul>\n<h2 id=\"裁判测试程序样例：\"><a href=\"#裁判测试程序样例：\" class=\"headerlink\" title=\"裁判测试程序样例：\"></a>裁判测试程序样例：</h2><pre class=\"language-C\" data-language=\"C\"><code class=\"language-C\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef int ElementType;\ntypedef struct TNode *Position;\ntypedef Position BinTree;\nstruct TNode&#123;\n    ElementType Data;\n    BinTree Left;\n    BinTree Right;\n&#125;;\n\nvoid PreorderTraversal( BinTree BT ); &#x2F;* 先序遍历，由裁判实现，细节不表 *&#x2F;\nvoid InorderTraversal( BinTree BT );  &#x2F;* 中序遍历，由裁判实现，细节不表 *&#x2F;\n\nBinTree Insert( BinTree BST, ElementType X );\nBinTree Delete( BinTree BST, ElementType X );\nPosition Find( BinTree BST, ElementType X );\nPosition FindMin( BinTree BST );\nPosition FindMax( BinTree BST );\n\nint main()\n&#123;\n    BinTree BST, MinP, MaxP, Tmp;\n    ElementType X;\n    int N, i;\n\n    BST &#x3D; NULL;\n    scanf(&quot;%d&quot;, &amp;N);\n    for ( i&#x3D;0; i&lt;N; i++ ) &#123;\n        scanf(&quot;%d&quot;, &amp;X);\n        BST &#x3D; Insert(BST, X);\n    &#125;\n    printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\\n&quot;);\n    MinP &#x3D; FindMin(BST);\n    MaxP &#x3D; FindMax(BST);\n    scanf(&quot;%d&quot;, &amp;N);\n    for( i&#x3D;0; i&lt;N; i++ ) &#123;\n        scanf(&quot;%d&quot;, &amp;X);\n        Tmp &#x3D; Find(BST, X);\n        if (Tmp &#x3D;&#x3D; NULL) printf(&quot;%d is not found\\n&quot;, X);\n        else &#123;\n            printf(&quot;%d is found\\n&quot;, Tmp-&gt;Data);\n            if (Tmp&#x3D;&#x3D;MinP) printf(&quot;%d is the smallest key\\n&quot;, Tmp-&gt;Data);\n            if (Tmp&#x3D;&#x3D;MaxP) printf(&quot;%d is the largest key\\n&quot;, Tmp-&gt;Data);\n        &#125;\n    &#125;\n    scanf(&quot;%d&quot;, &amp;N);\n    for( i&#x3D;0; i&lt;N; i++ ) &#123;\n        scanf(&quot;%d&quot;, &amp;X);\n        BST &#x3D; Delete(BST, X);\n    &#125;\n    printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\\n&quot;);\n\n    return 0;\n&#125;\n&#x2F;* 你的代码将被嵌在这里 *&#x2F;</code></pre>\n<h2 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h2><pre class=\"language-none\"><code class=\"language-none\">10\n5 8 6 2 4 1 0 10 9 7\n5\n6 3 10 0 5\n5\n5 7 0 10 3</code></pre>\n<h2 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h2><pre class=\"language-none\"><code class=\"language-none\">Preorder: 5 2 1 0 4 8 6 7 10 9\n6 is found\n3 is not found\n10 is found\n10 is the largest key\n0 is found\n0 is the smallest key\n5 is found\nNot Found\nInorder: 1 2 4 6 8 9</code></pre>\n<h2 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h2><pre class=\"language-C\" data-language=\"C\"><code class=\"language-C\">BinTree Insert( BinTree BST, ElementType X )&#123;\n    &#x2F;&#x2F;如果是一个空节点\n    if(!BST)&#123;\n        BST &#x3D; (BinTree)malloc(sizeof(struct TNode));&#x2F;&#x2F;既然为空所以要生成一个\n        BST-&gt;Data &#x3D; X;\n        BST-&gt;Left &#x3D; NULL;\n        BST-&gt;Right &#x3D; NULL;\n    &#125;\n    else&#123;&#x2F;&#x2F;一般情况\n        if(X &lt; BST-&gt;Data)&#123;&#x2F;&#x2F;插入值小于节点，应该往左子树中找位置\n            BST-&gt;Left &#x3D; Insert(BST-&gt;Left,X);&#x2F;&#x2F;递归插入左子树\n        &#125;\n        else if(X &gt; BST-&gt;Data)&#123;&#x2F;&#x2F;插入值大于节点，应该往右子树中找\n            BST-&gt;Right &#x3D; Insert(BST-&gt;Right,X);&#x2F;&#x2F;递归插入右子树\n        &#125;\n        &#x2F;&#x2F;如果相等说明X已经存在，什么也不做\n    &#125;\n    return BST;\n&#125;\nPosition Find( BinTree BST, ElementType X )&#123;\n    while(BST)&#123;&#x2F;&#x2F;直接循环查找，类似链表\n        if(X &lt; BST-&gt;Data)&#123;\n            BST &#x3D; BST-&gt;Left;&#x2F;&#x2F;小于节点，找左子树\n        &#125;\n        else if(X &gt; BST-&gt;Data)&#123;&#x2F;&#x2F;大于节点，找右子树\n            BST &#x3D; BST-&gt;Right;\n        &#125;\n        else&#123;&#x2F;&#x2F;相等则找到\n            return BST;\n        &#125;\n    &#125;\n    return NULL;\n&#125;\nPosition FindMin( BinTree BST )&#123;\n    if(!BST)&#123;\n        return NULL;\n    &#125;\n    else if(!BST-&gt;Left)\n        return BST;\n    else return FindMin(BST-&gt;Left);\n&#125;\nPosition FindMax( BinTree BST )&#123;\n    if(!BST)return NULL;\n    else if(!BST-&gt;Right)return BST;\n    else return FindMax(BST-&gt;Right);\n&#125;\nBinTree Delete( BinTree BST, ElementType X )&#123;\n    Position temp;\n    if(!BST)&#123;\n        printf(&quot;Not Found\\n&quot;);&#x2F;&#x2F;如果最终树为空，说明没有\n    &#125;\n    else&#123;&#x2F;&#x2F;这里类似于插入重点在于找到后怎么办\n        if(X &lt; BST-&gt;Data)&#123;\n            BST-&gt;Left &#x3D; Delete(BST-&gt;Left,X);&#x2F;&#x2F;从左子树递归删除\n        &#125;\n        else if(X &gt; BST-&gt;Data)&#123;\n            BST-&gt;Right &#x3D; Delete(BST-&gt;Right,X);&#x2F;&#x2F;从右子树递归删除\n        &#125;\n        else&#123;&#x2F;&#x2F;当前BST就是要删除的节点\n              if(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;&#x2F;&#x2F;要被删除的节点有左右两个孩子，就从右子树中找最小的数填充删除的节点\n                temp &#x3D; FindMin(BST-&gt;Right);&#x2F;&#x2F;找最小\n                BST-&gt;Data &#x3D; temp-&gt;Data;&#x2F;&#x2F;填充删除的节点\n                BST-&gt;Right &#x3D; Delete(BST-&gt;Right,temp-&gt;Data);&#x2F;&#x2F;删除拿来填充的那个节点\n              &#125;\n              else&#123;&#x2F;&#x2F;只有一个子节点\n                temp &#x3D; BST;\n                if(!BST-&gt;Left)&#123;&#x2F;&#x2F;只有右节点\n                    BST &#x3D; BST-&gt;Right;&#x2F;&#x2F;直接赋值就可以\n                &#125;\n                else if(!BST-&gt;Right)&#123;&#x2F;&#x2F;只有左节点\n                    BST &#x3D; BST-&gt;Left;&#x2F;&#x2F;直接赋值就可以\n                &#125;\n                free(temp);&#x2F;&#x2F;如果啥也没有直接删除就可以，当然上面两种情况赋值后也要删除\n              &#125;\n        &#125;\n    &#125;\n    return BST;\n&#125;</code></pre>\n","categories":[],"tags":[{"name":"数据结构","path":"api/tags/数据结构.json"}]}