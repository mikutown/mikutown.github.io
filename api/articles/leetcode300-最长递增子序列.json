{"title":"leetcode300.最长递增子序列","slug":"leetcode300-最长递增子序列","date":"2023-08-30T08:26:25.000Z","updated":"2023-08-30T09:44:59.511Z","comments":true,"path":"api/articles/leetcode300-最长递增子序列.json","excerpt":null,"covers":["http://cdn.leafii.top/img/image-20230830164100634.png","http://cdn.leafii.top/img/image-20230830172521363.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,1,0,3,2,3]\n输出：4</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [7,7,7,7,7,7,7]\n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>n2复杂度动态规划</li>\n</ul>\n<p>解题思路：</p>\n<ol>\n<li>dp[i]:以nums[i]为结尾的最长递增子序列的长度</li>\n<li>递推公式：max(dp[i],dp[j]+1),</li>\n<li>dp[i]至少为1（初始化条件）</li>\n<li>遍历顺序：i从小到大 j从大到小，从小到大都可以（0到i之间的每一个元素）</li>\n<li>最终返回dp数组中的最大值</li>\n</ol>\n<p><img src=\"http://cdn.leafii.top/img/image-20230830164100634.png\" alt=\"image-20230830164100634\" loading=\"lazy\"></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; dp(n, 1); &#x2F;&#x2F; 初始化dp数组，每个元素默认长度为1\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            for (int j &#x3D; 0; j &lt; i; j++) &#123;\n                if (nums[i] &gt; nums[j]) &#123;\n                    dp[i] &#x3D; max(dp[i], dp[j] + 1); &#x2F;&#x2F; dp数组的更新\n                &#125;\n            &#125;\n        &#125;\n        return *max_element(dp.begin(), dp.end());\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>n log(n)复杂度贪心</li>\n</ul>\n<p>交换状态与状态值</p>\n<p>令g[i]表示长度为i+1的IS的末尾元素的最小值 </p>\n<p><img src=\"http://cdn.leafii.top/img/image-20230830172521363.png\" alt=\"image-20230830172521363\" loading=\"lazy\"></p>\n<p>g是严格递增的。</p>\n<p>推论1:一次只能更新一个位置，单调递增序列不能有相同元素。</p>\n<p>推论2:更新的位置是第一个大于等于nums[i]的数的下标。</p>\n<p>算法：在g上用二分查找快速找到第一个大于等于nums[i]的下标j。如果j不存在，那么nums[i]直接加到g末尾;否则修改g[j]为nums[i].</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; tails; &#x2F;&#x2F; 用于存储递增子序列的末尾元素\n        for (int num : nums) &#123;\n            &#x2F;&#x2F; lower_bound 返回一个迭代器，指向容器中第一个大于等于给定值的元素。\n            auto it &#x3D; lower_bound(tails.begin(), tails.end(), num); &#x2F;&#x2F; 在 tails 中寻找第一个大于等于 num 的元素\n            if (it &#x3D;&#x3D; tails.end()) &#123;\n                tails.push_back(num); &#x2F;&#x2F; 如果找不到，则将 num 添加到末尾\n            &#125; else &#123;\n                *it &#x3D; num; &#x2F;&#x2F; 否则，更新找到的元素，因为它可以作为更长递增子序列的末尾元素\n            &#125;\n        &#125;\n        return tails.size(); &#x2F;&#x2F; 返回 tails 数组的长度，即为结果\n    &#125;\n&#125;;</code></pre>\n\n\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,1,0,3,2,3]\n输出：4</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [7,7,7,7,7,7,7]\n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>n2复杂度动态规划</li>\n</ul>\n<p>解题思路：</p>\n<ol>\n<li>dp[i]:以nums[i]为结尾的最长递增子序列的长度</li>\n<li>递推公式：max(dp[i],dp[j]+1),</li>\n<li>dp[i]至少为1（初始化条件）</li>\n<li>遍历顺序：i从小到大 j从大到小，从小到大都可以（0到i之间的每一个元素）</li>\n<li>最终返回dp数组中的最大值</li>\n</ol>\n<p><img src=\"http://cdn.leafii.top/img/image-20230830164100634.png\" alt=\"image-20230830164100634\"></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; dp(n, 1); &#x2F;&#x2F; 初始化dp数组，每个元素默认长度为1\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            for (int j &#x3D; 0; j &lt; i; j++) &#123;\n                if (nums[i] &gt; nums[j]) &#123;\n                    dp[i] &#x3D; max(dp[i], dp[j] + 1); &#x2F;&#x2F; dp数组的更新\n                &#125;\n            &#125;\n        &#125;\n        return *max_element(dp.begin(), dp.end());\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>n log(n)复杂度贪心</li>\n</ul>\n<p>交换状态与状态值</p>\n<p>令g[i]表示长度为i+1的IS的末尾元素的最小值 </p>\n<p><img src=\"http://cdn.leafii.top/img/image-20230830172521363.png\" alt=\"image-20230830172521363\"></p>\n<p>g是严格递增的。</p>\n<p>推论1:一次只能更新一个位置，单调递增序列不能有相同元素。</p>\n<p>推论2:更新的位置是第一个大于等于nums[i]的数的下标。</p>\n<p>算法：在g上用二分查找快速找到第一个大于等于nums[i]的下标j。如果j不存在，那么nums[i]直接加到g末尾;否则修改g[j]为nums[i].</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; tails; &#x2F;&#x2F; 用于存储递增子序列的末尾元素\n        for (int num : nums) &#123;\n            &#x2F;&#x2F; lower_bound 返回一个迭代器，指向容器中第一个大于等于给定值的元素。\n            auto it &#x3D; lower_bound(tails.begin(), tails.end(), num); &#x2F;&#x2F; 在 tails 中寻找第一个大于等于 num 的元素\n            if (it &#x3D;&#x3D; tails.end()) &#123;\n                tails.push_back(num); &#x2F;&#x2F; 如果找不到，则将 num 添加到末尾\n            &#125; else &#123;\n                *it &#x3D; num; &#x2F;&#x2F; 否则，更新找到的元素，因为它可以作为更长递增子序列的末尾元素\n            &#125;\n        &#125;\n        return tails.size(); &#x2F;&#x2F; 返回 tails 数组的长度，即为结果\n    &#125;\n&#125;;</code></pre>\n\n\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"序列","path":"api/tags/序列.json"}]}