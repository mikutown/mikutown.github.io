{"title":"leetcode:94.二叉树的中序遍历","slug":"leetcode-94-二叉树的中序遍历","date":"2023-01-27T06:59:43.000Z","updated":"2023-01-27T08:22:12.502Z","comments":true,"path":"api/articles/leetcode-94-二叉树的中序遍历.json","excerpt":"题目给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。","covers":["http://cdn.leafii.top/img/inorder_1.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/inorder_1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,2,3]\n输出：[1,3,2]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>递归算法</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123;\n      \t&#x2F;&#x2F;原函数没办法对vector数组的内容进行添加\n        if(!root) &#123;\n            return;\n        &#125;\n      \t&#x2F;&#x2F;中 左 右\n        inorder(root-&gt;left, res);\n        res.push_back(root -&gt; val);\n        inorder(root-&gt;right, res);\n    &#125;\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; result;\n        inorder(root, result);\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>迭代</li>\n</ol>\n<p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;TreeNode*&gt; stk;\n        while (root !&#x3D; nullptr || !stk.empty()) &#123;\n            &#x2F;&#x2F;结点非空时，将root结点push进去， root迭代至左结点\n            while(root !&#x3D; nullptr) &#123;\n                stk.push(root);\n                root &#x3D; root -&gt; left;\n            &#125;\n            &#x2F;&#x2F;符合条件的结点都push进去之后，出栈，然后将root结点的值push进res数组中，\n            root &#x3D; stk.top();\n            stk.pop();\n            res.push_back(root -&gt; val);\n            &#x2F;&#x2F; 将root结点迭代至右结点\n            root &#x3D; root -&gt; right; \n        &#125;\n        return res;\n    &#125;\n    \n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li>Morris遍历算法</li>\n</ol>\n<p>思路与算法</p>\n<p>Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 $O(1)$。</p>\n<p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 $x$）：</p>\n<p>如果 $x$ 无左孩子，先将 $x$ 的值加入答案数组，再访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>如果 $x$ 有左孩子，则找到 $x$ 左子树上最右的节点（即左子树中序遍历的最后一个节点，$x$ 在中序遍历中的前驱节点），我们记为 $predecessor $。根据 $predecessor $ 的右孩子是否为空，进行如下操作。<br>如果 $predecessor $ 的右孩子为空，则将其右孩子指向 $x$，然后访问 $x$ 的左孩子，即 $x &#x3D; x.left $。<br>如果 $predecessor $ 的右孩子不为空，则此时其右孩子指向 $x$，说明我们已经遍历完 $x$ 的左子树，我们将 $predecessor $ 的右孩子置空，将 $x$ 的值加入答案数组，然后访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>重复上述操作，直至访问完整棵树。</p>\n<p>其实整个过程我们就多做一步：假设当前遍历到的节点为 xxx，将 xxx 的左子树中最右边的节点的右孩子指向 xxx，这样在左子树遍历完成后我们通过这个指向走回了 xxx，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        TreeNode *predecessor &#x3D; nullptr;\n\n        while (root !&#x3D; nullptr) &#123;\n            if(root -&gt; left !&#x3D; nullptr) &#123;\n                &#x2F;&#x2F;predecessor就是当前root节点向左走一步，再一直向右走到无法走为止\n                predecessor &#x3D; root -&gt; left;\n                while(predecessor -&gt; right !&#x3D; nullptr &amp;&amp; predecessor -&gt; right !&#x3D; root) &#123;\n                    predecessor &#x3D; predecessor -&gt; right;\n                &#125;\n\n            &#x2F;&#x2F;让predecessor的右指针指向root，继续遍历左子树\n            if (predecessor -&gt; right &#x3D;&#x3D; nullptr) &#123;\n                predecessor -&gt; right &#x3D; root;\n                root &#x3D; root -&gt; left;\n            &#125;\n\n            &#x2F;&#x2F;说明左子树已经访问完了， 需要断开连接\n            else &#123;\n                res.push_back(root -&gt; val);\n                predecessor -&gt; right &#x3D; nullptr;\n                root &#x3D; root -&gt; right;\n                &#125;\n            &#125;\n            &#x2F;&#x2F;如果没有左孩子，则直接访问右孩子\n            else &#123;\n                res.push_back(root -&gt; val);\n                root &#x3D; root -&gt; right;\n\n            &#125;\n            \n        &#125;\n        return res;\n        \n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>力扣官方题解：<a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/\">https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</a></li>\n</ul>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/inorder_1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,2,3]\n输出：[1,3,2]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>递归算法</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123;\n      \t&#x2F;&#x2F;原函数没办法对vector数组的内容进行添加\n        if(!root) &#123;\n            return;\n        &#125;\n      \t&#x2F;&#x2F;中 左 右\n        inorder(root-&gt;left, res);\n        res.push_back(root -&gt; val);\n        inorder(root-&gt;right, res);\n    &#125;\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; result;\n        inorder(root, result);\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>迭代</li>\n</ol>\n<p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;TreeNode*&gt; stk;\n        while (root !&#x3D; nullptr || !stk.empty()) &#123;\n            &#x2F;&#x2F;结点非空时，将root结点push进去， root迭代至左结点\n            while(root !&#x3D; nullptr) &#123;\n                stk.push(root);\n                root &#x3D; root -&gt; left;\n            &#125;\n            &#x2F;&#x2F;符合条件的结点都push进去之后，出栈，然后将root结点的值push进res数组中，\n            root &#x3D; stk.top();\n            stk.pop();\n            res.push_back(root -&gt; val);\n            &#x2F;&#x2F; 将root结点迭代至右结点\n            root &#x3D; root -&gt; right; \n        &#125;\n        return res;\n    &#125;\n    \n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li>Morris遍历算法</li>\n</ol>\n<p>思路与算法</p>\n<p>Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 $O(1)$。</p>\n<p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 $x$）：</p>\n<p>如果 $x$ 无左孩子，先将 $x$ 的值加入答案数组，再访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>如果 $x$ 有左孩子，则找到 $x$ 左子树上最右的节点（即左子树中序遍历的最后一个节点，$x$ 在中序遍历中的前驱节点），我们记为 $predecessor $。根据 $predecessor $ 的右孩子是否为空，进行如下操作。<br>如果 $predecessor $ 的右孩子为空，则将其右孩子指向 $x$，然后访问 $x$ 的左孩子，即 $x &#x3D; x.left $。<br>如果 $predecessor $ 的右孩子不为空，则此时其右孩子指向 $x$，说明我们已经遍历完 $x$ 的左子树，我们将 $predecessor $ 的右孩子置空，将 $x$ 的值加入答案数组，然后访问 $x$ 的右孩子，即 $x &#x3D; x.right $。<br>重复上述操作，直至访问完整棵树。</p>\n<p>其实整个过程我们就多做一步：假设当前遍历到的节点为 xxx，将 xxx 的左子树中最右边的节点的右孩子指向 xxx，这样在左子树遍历完成后我们通过这个指向走回了 xxx，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        TreeNode *predecessor &#x3D; nullptr;\n\n        while (root !&#x3D; nullptr) &#123;\n            if(root -&gt; left !&#x3D; nullptr) &#123;\n                &#x2F;&#x2F;predecessor就是当前root节点向左走一步，再一直向右走到无法走为止\n                predecessor &#x3D; root -&gt; left;\n                while(predecessor -&gt; right !&#x3D; nullptr &amp;&amp; predecessor -&gt; right !&#x3D; root) &#123;\n                    predecessor &#x3D; predecessor -&gt; right;\n                &#125;\n\n            &#x2F;&#x2F;让predecessor的右指针指向root，继续遍历左子树\n            if (predecessor -&gt; right &#x3D;&#x3D; nullptr) &#123;\n                predecessor -&gt; right &#x3D; root;\n                root &#x3D; root -&gt; left;\n            &#125;\n\n            &#x2F;&#x2F;说明左子树已经访问完了， 需要断开连接\n            else &#123;\n                res.push_back(root -&gt; val);\n                predecessor -&gt; right &#x3D; nullptr;\n                root &#x3D; root -&gt; right;\n                &#125;\n            &#125;\n            &#x2F;&#x2F;如果没有左孩子，则直接访问右孩子\n            else &#123;\n                res.push_back(root -&gt; val);\n                root &#x3D; root -&gt; right;\n\n            &#125;\n            \n        &#125;\n        return res;\n        \n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>力扣官方题解：<a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/\">https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/412886/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/</a></li>\n</ul>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}