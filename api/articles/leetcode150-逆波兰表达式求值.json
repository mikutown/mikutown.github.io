{"title":"leetcode150.逆波兰表达式求值","slug":"leetcode150-逆波兰表达式求值","date":"2023-12-14T12:01:17.000Z","updated":"2023-12-14T12:25:27.046Z","comments":true,"path":"api/articles/leetcode150-逆波兰表达式求值.json","excerpt":"题目给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\">逆波兰表示法</a> 表示的算术表达式。</p>\n<p>请你计算该表达式。返回一个表示表达式值的整数。</p>\n<span id=\"more\"></span>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>\n<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>\n<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>\n<li>表达式中不含除零运算。</li>\n<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>\n<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]\n输出：6\n解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n输出：22\n解释：该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5\n&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5\n&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5\n&#x3D; ((10 * 0) + 17) + 5\n&#x3D; (0 + 17) + 5\n&#x3D; 17 + 5\n&#x3D; 22</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= tokens.length &lt;= 104</code></li>\n<li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>\n</ul>\n<p><strong>逆波兰表达式：</strong></p>\n<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>\n<ul>\n<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>\n<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>\n</ul>\n<p>逆波兰表达式主要有以下两个优点：</p>\n<ul>\n<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>\n<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>使用栈辅助遍历</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; 计算逆波兰表达式的值\n    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;\n        &#x2F;&#x2F; 使用栈来辅助计算\n        stack&lt;int&gt; numStack;\n        \n        &#x2F;&#x2F; 遍历表达式中的每个元素\n        for (string temp : tokens) &#123;\n            &#x2F;&#x2F; 如果是操作数，将其转换为整数并压入栈中\n            if (temp !&#x3D; &quot;+&quot; &amp;&amp; temp !&#x3D; &quot;-&quot; &amp;&amp; temp !&#x3D; &quot;*&quot; &amp;&amp; temp !&#x3D; &quot;&#x2F;&quot;) &#123;\n                numStack.push(stoi(temp));\n            &#125; else &#123;\n                &#x2F;&#x2F; 如果是操作符，从栈中弹出两个操作数进行计算\n                int num2 &#x3D; numStack.top();\n                numStack.pop();\n                int num1 &#x3D; numStack.top();\n                numStack.pop();\n                int num &#x3D; 0;\n                \n                &#x2F;&#x2F; 根据操作符进行相应的计算，并将结果压入栈中\n                if (temp &#x3D;&#x3D; &quot;+&quot;) &#123;\n                    num &#x3D; num1 + num2;\n                &#125; else if (temp &#x3D;&#x3D; &quot;-&quot;) &#123;\n                    num &#x3D; num1 - num2;\n                &#125; else if (temp &#x3D;&#x3D; &quot;*&quot;) &#123;\n                    num &#x3D; num1 * num2;\n                &#125; else if (temp &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n                    num &#x3D; num1 &#x2F; num2;\n                &#125;\n                numStack.push(num);\n            &#125;\n        &#125;\n        \n        &#x2F;&#x2F; 最终栈中的唯一元素即为表达式的值\n        return numStack.top();\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>注意：</strong></p>\n<ul>\n<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>\n<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>\n<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>\n<li>表达式中不含除零运算。</li>\n<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>\n<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]\n输出：6\n解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n输出：22\n解释：该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5\n&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5\n&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5\n&#x3D; ((10 * 0) + 17) + 5\n&#x3D; (0 + 17) + 5\n&#x3D; 17 + 5\n&#x3D; 22</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= tokens.length &lt;= 104</code></li>\n<li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>\n</ul>\n<p><strong>逆波兰表达式：</strong></p>\n<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>\n<ul>\n<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>\n<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>\n</ul>\n<p>逆波兰表达式主要有以下两个优点：</p>\n<ul>\n<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>\n<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>使用栈辅助遍历</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; 计算逆波兰表达式的值\n    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;\n        &#x2F;&#x2F; 使用栈来辅助计算\n        stack&lt;int&gt; numStack;\n        \n        &#x2F;&#x2F; 遍历表达式中的每个元素\n        for (string temp : tokens) &#123;\n            &#x2F;&#x2F; 如果是操作数，将其转换为整数并压入栈中\n            if (temp !&#x3D; &quot;+&quot; &amp;&amp; temp !&#x3D; &quot;-&quot; &amp;&amp; temp !&#x3D; &quot;*&quot; &amp;&amp; temp !&#x3D; &quot;&#x2F;&quot;) &#123;\n                numStack.push(stoi(temp));\n            &#125; else &#123;\n                &#x2F;&#x2F; 如果是操作符，从栈中弹出两个操作数进行计算\n                int num2 &#x3D; numStack.top();\n                numStack.pop();\n                int num1 &#x3D; numStack.top();\n                numStack.pop();\n                int num &#x3D; 0;\n                \n                &#x2F;&#x2F; 根据操作符进行相应的计算，并将结果压入栈中\n                if (temp &#x3D;&#x3D; &quot;+&quot;) &#123;\n                    num &#x3D; num1 + num2;\n                &#125; else if (temp &#x3D;&#x3D; &quot;-&quot;) &#123;\n                    num &#x3D; num1 - num2;\n                &#125; else if (temp &#x3D;&#x3D; &quot;*&quot;) &#123;\n                    num &#x3D; num1 * num2;\n                &#125; else if (temp &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n                    num &#x3D; num1 &#x2F; num2;\n                &#125;\n                numStack.push(num);\n            &#125;\n        &#125;\n        \n        &#x2F;&#x2F; 最终栈中的唯一元素即为表达式的值\n        return numStack.top();\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}