{"title":"leetcode1534.统计好三元组","slug":"leetcode1534-统计好三元组","date":"2023-05-14T06:52:41.000Z","updated":"2023-05-14T06:56:17.370Z","comments":true,"path":"api/articles/leetcode1534-统计好三元组.json","excerpt":"题目给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。0 &lt;= i &lt; j &lt; k &lt; arr.length|arr[i] - arr[j]| &lt;= a|arr[j] - arr[k]| &lt;= b|arr[i] - arr[k]| &lt;= c其中 |x| 表示 x 的绝对值。返回 好三元组的数量 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p>\n<p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p>\n<ul>\n<li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li>\n<li><code>|arr[i] - arr[j]| &lt;= a</code></li>\n<li><code>|arr[j] - arr[k]| &lt;= b</code></li>\n<li><code>|arr[i] - arr[k]| &lt;= c</code></li>\n</ul>\n<p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p>\n<p>返回 <strong>好三元组的数量</strong> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [3,0,1,1,9,7], a &#x3D; 7, b &#x3D; 2, c &#x3D; 3\n输出：4\n解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [1,1,2,2,3], a &#x3D; 0, b &#x3D; 0, c &#x3D; 1\n输出：0\n解释：不存在满足所有条件的三元组。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= arr.length &lt;= 100</code></li>\n<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>\n<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力枚举</li>\n</ul>\n<p>直接模拟暴力枚举即可，代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123;\n        int len &#x3D; arr.size();  &#x2F;&#x2F; 获取数组的长度\n        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，记录符合条件的三元组数量\n        for (int i &#x3D; 0; i &lt; len - 2; i++) &#123;  &#x2F;&#x2F; 第一个数的索引范围是 [0, len - 3]\n            for (int j &#x3D; i + 1; j &lt; len - 1; j++) &#123;  &#x2F;&#x2F; 第二个数的索引范围是 [i+1, len - 2]\n                for (int k &#x3D; j + 1; k &lt; len; k++) &#123;  &#x2F;&#x2F; 第三个数的索引范围是 [j+1, len - 1]\n                    if (abs(arr[i] - arr[j]) &lt;&#x3D; a &amp;&amp; abs(arr[j] - arr[k]) &lt;&#x3D; b &amp;&amp; abs(arr[i] - arr[k]) &lt;&#x3D; c) &#123;\n                        &#x2F;&#x2F; 检查三元组的条件：两个数之间的差值都不超过给定的限制\n                        cnt++;  &#x2F;&#x2F; 符合条件的三元组数量加一\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return cnt;  &#x2F;&#x2F; 返回符合条件的三元组数量\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [3,0,1,1,9,7], a &#x3D; 7, b &#x3D; 2, c &#x3D; 3\n输出：4\n解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [1,1,2,2,3], a &#x3D; 0, b &#x3D; 0, c &#x3D; 1\n输出：0\n解释：不存在满足所有条件的三元组。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= arr.length &lt;= 100</code></li>\n<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>\n<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力枚举</li>\n</ul>\n<p>直接模拟暴力枚举即可，代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123;\n        int len &#x3D; arr.size();  &#x2F;&#x2F; 获取数组的长度\n        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，记录符合条件的三元组数量\n        for (int i &#x3D; 0; i &lt; len - 2; i++) &#123;  &#x2F;&#x2F; 第一个数的索引范围是 [0, len - 3]\n            for (int j &#x3D; i + 1; j &lt; len - 1; j++) &#123;  &#x2F;&#x2F; 第二个数的索引范围是 [i+1, len - 2]\n                for (int k &#x3D; j + 1; k &lt; len; k++) &#123;  &#x2F;&#x2F; 第三个数的索引范围是 [j+1, len - 1]\n                    if (abs(arr[i] - arr[j]) &lt;&#x3D; a &amp;&amp; abs(arr[j] - arr[k]) &lt;&#x3D; b &amp;&amp; abs(arr[i] - arr[k]) &lt;&#x3D; c) &#123;\n                        &#x2F;&#x2F; 检查三元组的条件：两个数之间的差值都不超过给定的限制\n                        cnt++;  &#x2F;&#x2F; 符合条件的三元组数量加一\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return cnt;  &#x2F;&#x2F; 返回符合条件的三元组数量\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}