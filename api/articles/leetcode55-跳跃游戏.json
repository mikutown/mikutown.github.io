{"title":"leetcode55.跳跃游戏","slug":"leetcode55-跳跃游戏","date":"2023-02-15T10:21:20.000Z","updated":"2023-02-15T10:45:13.616Z","comments":true,"path":"api/articles/leetcode55-跳跃游戏.json","excerpt":"题目给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个下标。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [2,3,1,1,4]\n输出：true\n解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [3,2,1,0,4]\n输出：false\n解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>利用栈（<strong>超时</strong>）</li>\n</ol>\n<p>将能到达的数组元素推进栈，模拟树的操作，但是会超时。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canJump(vector&lt;int&gt;&amp; nums) &#123;\n        int len &#x3D; nums.size();\n        if (len &gt; 1 &amp;&amp; nums[0] &#x3D;&#x3D; 0) return false;\n        if (len &#x3D;&#x3D; 1) return true;\n        stack&lt;int&gt; s; &#x2F;&#x2F; 定义一个栈\n        int index &#x3D; 0;\n        if (nums[index] &gt; len) return true;\n        s.push(index);\n        while(!s.empty()) &#123;\n            int temp_index &#x3D; s.top();\n            int temp_num &#x3D; nums[temp_index];\n            s.pop();\n            for (int i &#x3D; 1; i &lt;&#x3D; temp_num; i++) &#123;\n                if (temp_index + i &#x3D;&#x3D; len - 1) return true;\n                if (nums[temp_index + i] &gt;&#x3D; (len - (temp_index + i))) return true;\n                if (nums[temp_index + i] !&#x3D; 0) s.push(temp_index + i);\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n<p>用chatGPT分析超时的原因：</p>\n<blockquote>\n<p>您的代码的时间复杂度为 O(2^n)，其中 n 是数组的长度，因为在每个位置都可以有两个选择：跳或不跳，总共有 2^n 种可能的路径。这样的时间复杂度是无法通过本题的。</p>\n<p>此外，您使用了栈来存储待搜索的位置，但这样的做法并不高效。因为每个位置最多只需要被遍历一次，而使用栈会重复遍历一些位置，导致时间复杂度进一步增加。</p>\n</blockquote>\n<ol start=\"2\">\n<li>使用贪心算法</li>\n</ol>\n<p>使用贪心算法，从左到右遍历数组，用一个变量来维护能够到达的最远距离，如果当前位置在这个最远距离之内，那么更新最远距离。如果遍历结束后最远距离大于等于数组的最后一个位置，那么就说明可以到达最后一个位置，否则就无法到达。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canJump(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int maxPos &#x3D; 0; &#x2F;&#x2F; 当前能到达的最远距离\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            if (i &gt; maxPos) return false; &#x2F;&#x2F; 如果当前位置无法到达，则返回false\n            maxPos &#x3D; max(maxPos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远距离\n            if (maxPos &gt;&#x3D; n - 1) return true; &#x2F;&#x2F; 如果能够到达最后一个位置，返回true\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [2,3,1,1,4]\n输出：true\n解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [3,2,1,0,4]\n输出：false\n解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>利用栈（<strong>超时</strong>）</li>\n</ol>\n<p>将能到达的数组元素推进栈，模拟树的操作，但是会超时。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canJump(vector&lt;int&gt;&amp; nums) &#123;\n        int len &#x3D; nums.size();\n        if (len &gt; 1 &amp;&amp; nums[0] &#x3D;&#x3D; 0) return false;\n        if (len &#x3D;&#x3D; 1) return true;\n        stack&lt;int&gt; s; &#x2F;&#x2F; 定义一个栈\n        int index &#x3D; 0;\n        if (nums[index] &gt; len) return true;\n        s.push(index);\n        while(!s.empty()) &#123;\n            int temp_index &#x3D; s.top();\n            int temp_num &#x3D; nums[temp_index];\n            s.pop();\n            for (int i &#x3D; 1; i &lt;&#x3D; temp_num; i++) &#123;\n                if (temp_index + i &#x3D;&#x3D; len - 1) return true;\n                if (nums[temp_index + i] &gt;&#x3D; (len - (temp_index + i))) return true;\n                if (nums[temp_index + i] !&#x3D; 0) s.push(temp_index + i);\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n<p>用chatGPT分析超时的原因：</p>\n<blockquote>\n<p>您的代码的时间复杂度为 O(2^n)，其中 n 是数组的长度，因为在每个位置都可以有两个选择：跳或不跳，总共有 2^n 种可能的路径。这样的时间复杂度是无法通过本题的。</p>\n<p>此外，您使用了栈来存储待搜索的位置，但这样的做法并不高效。因为每个位置最多只需要被遍历一次，而使用栈会重复遍历一些位置，导致时间复杂度进一步增加。</p>\n</blockquote>\n<ol start=\"2\">\n<li>使用贪心算法</li>\n</ol>\n<p>使用贪心算法，从左到右遍历数组，用一个变量来维护能够到达的最远距离，如果当前位置在这个最远距离之内，那么更新最远距离。如果遍历结束后最远距离大于等于数组的最后一个位置，那么就说明可以到达最后一个位置，否则就无法到达。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canJump(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int maxPos &#x3D; 0; &#x2F;&#x2F; 当前能到达的最远距离\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            if (i &gt; maxPos) return false; &#x2F;&#x2F; 如果当前位置无法到达，则返回false\n            maxPos &#x3D; max(maxPos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远距离\n            if (maxPos &gt;&#x3D; n - 1) return true; &#x2F;&#x2F; 如果能够到达最后一个位置，返回true\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}