{"title":"leetcode454.四数相加II","slug":"leetcode454-四数相加II","date":"2023-10-18T01:18:10.000Z","updated":"2023-10-18T01:36:18.279Z","comments":true,"path":"api/articles/leetcode454-四数相加II.json","excerpt":"题目给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：0 &lt;= i, j, k, l &lt; nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>\n<ul>\n<li><code>0 &lt;= i, j, k, l &lt; n</code></li>\n<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>\n</ul>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]\n输出：2\n解释：\n两个元组如下：\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]\n输出：1</code></pre>\n\n<p> <strong>提示：</strong></p>\n<ul>\n<li><code>n == nums1.length</code></li>\n<li><code>n == nums2.length</code></li>\n<li><code>n == nums3.length</code></li>\n<li><code>n == nums4.length</code></li>\n<li><code>1 &lt;= n &lt;= 200</code></li>\n<li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>哈希表</li>\n</ul>\n<p>直接上4个for循环铁定要超时，因为时间复杂度高达<code>O(n^4)</code>，在这里利用哈希表查找操作接近O(1)的特性将整体的查找操作的时间复杂度降低到<code>O(n^2)</code>。整体的代码思路如下：</p>\n<ol>\n<li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li>\n<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li>\n<li>定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数。</li>\n<li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li>\n<li>最后返回统计值 count 就可以了</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;\n        int result &#x3D; 0; &#x2F;&#x2F; 定义结果，类型为int\n        unordered_map&lt;int, int&gt; cnt; &#x2F;&#x2F; 哈希表cnt 用于统计nums1和nums2数组元素和的次数\n        for (int i &#x3D; 0; i &lt; nums1.size(); i++) &#123;\n            for (int j &#x3D; 0; j &lt; nums2.size(); j++) &#123;\n                int temp &#x3D; nums1[i] + nums2[j];\n                cnt[temp] &#x3D; cnt[temp]&#x3D;&#x3D;0?1:cnt[temp]+1; &#x2F;&#x2F; 统计过程\n            &#125;\n        &#125;\n        for (int i &#x3D; 0; i &lt; nums3.size(); i++) &#123;\n            for (int j &#x3D; 0; j &lt; nums4.size(); j++) &#123;\n                int temp &#x3D; -1 * (nums3[i] + nums4[j]);\n                &#x2F;&#x2F; 判断如果nums3和nums4中单个元素的和乘以-1在名为cnt的哈希表中非0，就更新result的值\n                if (cnt[temp] !&#x3D; 0) result +&#x3D; cnt[temp]; \n            &#125;\n        &#125;\n        return result; &#x2F;&#x2F; 返回结果\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]\n输出：2\n解释：\n两个元组如下：\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]\n输出：1</code></pre>\n\n<p> <strong>提示：</strong></p>\n<ul>\n<li><code>n == nums1.length</code></li>\n<li><code>n == nums2.length</code></li>\n<li><code>n == nums3.length</code></li>\n<li><code>n == nums4.length</code></li>\n<li><code>1 &lt;= n &lt;= 200</code></li>\n<li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>哈希表</li>\n</ul>\n<p>直接上4个for循环铁定要超时，因为时间复杂度高达<code>O(n^4)</code>，在这里利用哈希表查找操作接近O(1)的特性将整体的查找操作的时间复杂度降低到<code>O(n^2)</code>。整体的代码思路如下：</p>\n<ol>\n<li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li>\n<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li>\n<li>定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数。</li>\n<li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li>\n<li>最后返回统计值 count 就可以了</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;\n        int result &#x3D; 0; &#x2F;&#x2F; 定义结果，类型为int\n        unordered_map&lt;int, int&gt; cnt; &#x2F;&#x2F; 哈希表cnt 用于统计nums1和nums2数组元素和的次数\n        for (int i &#x3D; 0; i &lt; nums1.size(); i++) &#123;\n            for (int j &#x3D; 0; j &lt; nums2.size(); j++) &#123;\n                int temp &#x3D; nums1[i] + nums2[j];\n                cnt[temp] &#x3D; cnt[temp]&#x3D;&#x3D;0?1:cnt[temp]+1; &#x2F;&#x2F; 统计过程\n            &#125;\n        &#125;\n        for (int i &#x3D; 0; i &lt; nums3.size(); i++) &#123;\n            for (int j &#x3D; 0; j &lt; nums4.size(); j++) &#123;\n                int temp &#x3D; -1 * (nums3[i] + nums4[j]);\n                &#x2F;&#x2F; 判断如果nums3和nums4中单个元素的和乘以-1在名为cnt的哈希表中非0，就更新result的值\n                if (cnt[temp] !&#x3D; 0) result +&#x3D; cnt[temp]; \n            &#125;\n        &#125;\n        return result; &#x2F;&#x2F; 返回结果\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}