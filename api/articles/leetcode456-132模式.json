{"title":"leetcode456.132模式","slug":"leetcode456-132模式","date":"2023-07-26T13:04:37.000Z","updated":"2023-07-26T13:09:20.048Z","comments":true,"path":"api/articles/leetcode456-132模式.json","excerpt":"题目给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成，并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code> 。</p>\n<p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,2,3,4]\n输出：false\n解释：序列中不存在 132 模式的子序列。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [3,1,4,2]\n输出：true\n解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [-1,3,2,0]\n输出：true\n解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == nums.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 105</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>单调栈</li>\n</ul>\n<p>要解决这个问题，我们可以使用单调栈。我们需要寻找132模式的形式，即[i,j,k]，其中nums[i]&lt;nums[k]&lt;nums[j]。对于每个元素nums[j]，我们需要找到最小的nums[i]和nums[k]。我们可以从右到左遍历数组，维护一个单调递减的栈，栈中存放的是可能作为nums[k]的候选元素，然后我们在栈中寻找比nums[j]小的元素来充当nums[i]。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nbool find132pattern(vector&lt;int&gt;&amp; nums) &#123;\n    int n &#x3D; nums.size();\n    if (n &lt; 3)\n        return false;\n\n    int third &#x3D; INT_MIN; &#x2F;&#x2F; 初始化为负无穷，用于存放nums[k]\n    stack&lt;int&gt; st; &#x2F;&#x2F; 用于存放nums[k]的单调递减栈\n\n    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;\n        if (nums[i] &lt; third)\n            return true; &#x2F;&#x2F; 如果存在满足条件的nums[i]、nums[j]和nums[k]，则返回true\n\n        while (!st.empty() &amp;&amp; nums[i] &gt; st.top()) &#123;\n            third &#x3D; st.top();\n            st.pop();\n        &#125;\n\n        st.push(nums[i]);\n    &#125;\n\n    return false;\n&#125;</code></pre>\n\n<p>这样，我们就可以使用单调栈在O(n)的时间复杂度内解决这个问题。注意，由于我们使用了额外的栈，空间复杂度为O(n)。</p>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,2,3,4]\n输出：false\n解释：序列中不存在 132 模式的子序列。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [3,1,4,2]\n输出：true\n解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [-1,3,2,0]\n输出：true\n解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == nums.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 105</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>单调栈</li>\n</ul>\n<p>要解决这个问题，我们可以使用单调栈。我们需要寻找132模式的形式，即[i,j,k]，其中nums[i]&lt;nums[k]&lt;nums[j]。对于每个元素nums[j]，我们需要找到最小的nums[i]和nums[k]。我们可以从右到左遍历数组，维护一个单调递减的栈，栈中存放的是可能作为nums[k]的候选元素，然后我们在栈中寻找比nums[j]小的元素来充当nums[i]。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nbool find132pattern(vector&lt;int&gt;&amp; nums) &#123;\n    int n &#x3D; nums.size();\n    if (n &lt; 3)\n        return false;\n\n    int third &#x3D; INT_MIN; &#x2F;&#x2F; 初始化为负无穷，用于存放nums[k]\n    stack&lt;int&gt; st; &#x2F;&#x2F; 用于存放nums[k]的单调递减栈\n\n    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;\n        if (nums[i] &lt; third)\n            return true; &#x2F;&#x2F; 如果存在满足条件的nums[i]、nums[j]和nums[k]，则返回true\n\n        while (!st.empty() &amp;&amp; nums[i] &gt; st.top()) &#123;\n            third &#x3D; st.top();\n            st.pop();\n        &#125;\n\n        st.push(nums[i]);\n    &#125;\n\n    return false;\n&#125;</code></pre>\n\n<p>这样，我们就可以使用单调栈在O(n)的时间复杂度内解决这个问题。注意，由于我们使用了额外的栈，空间复杂度为O(n)。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}