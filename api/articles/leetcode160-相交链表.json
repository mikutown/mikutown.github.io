{"title":"leetcode160.相交链表","slug":"leetcode160-相交链表","date":"2023-03-06T07:18:58.000Z","updated":"2023-03-06T07:20:59.431Z","comments":true,"path":"api/articles/leetcode160-相交链表.json","excerpt":"题目给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。","covers":["http://cdn.leafii.top/img/160_statement.png","http://cdn.leafii.top/img/160_example_1_1.png","http://cdn.leafii.top/img/160_example_2.png","http://cdn.leafii.top/img/160_example_3.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>\n<span id=\"more\"></span>\n\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/160_statement.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n<p><strong>自定义评测：</strong></p>\n<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>\n<ul>\n<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>\n<li><code>listA</code> - 第一个链表</li>\n<li><code>listB</code> - 第二个链表</li>\n<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>\n<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>\n</ul>\n<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/160_example_1_1.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3\n输出：Intersected at &#39;8&#39;\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/160_example_2.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1\n输出：Intersected at &#39;2&#39;\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/160_example_3.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>listA</code> 中节点数目为 <code>m</code></li>\n<li><code>listB</code> 中节点数目为 <code>n</code></li>\n<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>\n<li><code>1 &lt;= Node.val &lt;= 105</code></li>\n<li><code>0 &lt;= skipA &lt;= m</code></li>\n<li><code>0 &lt;= skipB &lt;= n</code></li>\n<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>\n</ul>\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>尾部对齐法</li>\n</ol>\n<p>因为当两链表相交时，它们从相交的节点开始到尾节点都是重叠的，因此首先依次遍历两个链表，获取两个链表的长度，然后将长度更长的链表进行对齐操作，之后分别比较对齐后的两链表的元素，若不相等，则分别迭代为next指针指向的元素，若两元素相等，则返回任意一个元素，若不相等，则遍历结束后返回<code>null</code>.</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        &#x2F;&#x2F; 分别计算两个链表的长度\n        int lenA &#x3D; 0, lenB &#x3D; 0;\n        ListNode* curA &#x3D; headA;\n        ListNode* curB &#x3D; headB;\n        while (curA) &#123;\n            lenA++;\n            curA &#x3D; curA-&gt;next;\n        &#125;\n        while (curB) &#123;\n            lenB++;\n            curB &#x3D; curB-&gt;next;\n        &#125;\n        &#x2F;&#x2F; 将较长的链表向后移动，使它们的尾部对齐\n        curA &#x3D; headA;\n        curB &#x3D; headB;\n        if (lenA &gt; lenB) &#123;\n            for (int i &#x3D; 0; i &lt; (lenA - lenB); i++) &#123;\n                curA &#x3D; curA-&gt;next;\n            &#125;\n        &#125;\n        else &#123;\n            for (int i &#x3D; 0; i &lt; (lenB - lenA); i++) &#123;\n                curB &#x3D; curB-&gt;next;\n            &#125;\n        &#125;\n        while (curA !&#x3D; curB) &#123;\n            curA &#x3D; curA-&gt;next;\n            curB &#x3D; curB-&gt;next;\n        &#125;\n        if (curA !&#x3D; nullptr) return curA;\n        \n        return nullptr;\n\n    &#125;\n    \n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>使用哈希表</li>\n</ol>\n<p>使用一个哈希表存储一个链表的所有元素的地址，接着对另一个链表进行遍历，若另一个链表中有元素的地址和哈希表中的链表地址相等，则返回该元素，否则遍历结束后返回<code>null</code></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        unordered_set&lt;ListNode*&gt; nodes; &#x2F;&#x2F;使用unordered_set存储链表A的各个元素的地址\n        while (headA) &#123;\n            nodes.insert(headA);\n            headA &#x3D; headA-&gt;next;\n        &#125;\n        while (headB) &#123;\n            if (nodes.count(headB)) &#123; &#x2F;&#x2F; 判断headB的元素地址是否在unordered_set中\n                return headB;\n            &#125;\n            headB &#x3D; headB-&gt;next;\n        &#125;\n        return nullptr;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>需要注意的是在C++中因为<code>ListNode</code>没有定义比较方法，所以在这里使用的是 <code>unordered_set&lt;ListNode*&gt;</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>”快慢指针“法</li>\n</ol>\n<p>使用两个指针分别指向两个链表的头结点，分别进行遍历，若指针在遍历时遍历到了尾节点，则令指向尾节点的指针指向另一个链表的头结点，若两个链表有相交，即有重叠部分时，这两个指针终究会相遇，此时返回相遇的指针即可，若不能相遇，则返回<code>null</code>。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        &#x2F;&#x2F; &quot;快慢指针&quot;\n        ListNode* pointA &#x3D; headA;\n        ListNode* pointB &#x3D; headB;\n        while (pointA !&#x3D; pointB) &#123;\n            pointA &#x3D; pointA !&#x3D; nullptr? pointA-&gt;next: pointA &#x3D; headB;\n            pointB &#x3D; pointB !&#x3D; nullptr? pointB-&gt;next: pointB &#x3D; headA;\n        &#125;\n        if (pointA !&#x3D; nullptr) return pointA; &#x2F;&#x2F; 需要注意在遍历结束后判断pointA（或pointB)是否为null\n\n        return nullptr;\n    &#125;\n&#125;;</code></pre>\n","more":"<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/160_statement.png\" alt=\"img\"></p>\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n<p><strong>自定义评测：</strong></p>\n<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>\n<ul>\n<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>\n<li><code>listA</code> - 第一个链表</li>\n<li><code>listB</code> - 第二个链表</li>\n<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>\n<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>\n</ul>\n<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/160_example_1_1.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3\n输出：Intersected at &#39;8&#39;\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/160_example_2.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1\n输出：Intersected at &#39;2&#39;\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/160_example_3.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>listA</code> 中节点数目为 <code>m</code></li>\n<li><code>listB</code> 中节点数目为 <code>n</code></li>\n<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>\n<li><code>1 &lt;= Node.val &lt;= 105</code></li>\n<li><code>0 &lt;= skipA &lt;= m</code></li>\n<li><code>0 &lt;= skipB &lt;= n</code></li>\n<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>\n</ul>\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>尾部对齐法</li>\n</ol>\n<p>因为当两链表相交时，它们从相交的节点开始到尾节点都是重叠的，因此首先依次遍历两个链表，获取两个链表的长度，然后将长度更长的链表进行对齐操作，之后分别比较对齐后的两链表的元素，若不相等，则分别迭代为next指针指向的元素，若两元素相等，则返回任意一个元素，若不相等，则遍历结束后返回<code>null</code>.</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        &#x2F;&#x2F; 分别计算两个链表的长度\n        int lenA &#x3D; 0, lenB &#x3D; 0;\n        ListNode* curA &#x3D; headA;\n        ListNode* curB &#x3D; headB;\n        while (curA) &#123;\n            lenA++;\n            curA &#x3D; curA-&gt;next;\n        &#125;\n        while (curB) &#123;\n            lenB++;\n            curB &#x3D; curB-&gt;next;\n        &#125;\n        &#x2F;&#x2F; 将较长的链表向后移动，使它们的尾部对齐\n        curA &#x3D; headA;\n        curB &#x3D; headB;\n        if (lenA &gt; lenB) &#123;\n            for (int i &#x3D; 0; i &lt; (lenA - lenB); i++) &#123;\n                curA &#x3D; curA-&gt;next;\n            &#125;\n        &#125;\n        else &#123;\n            for (int i &#x3D; 0; i &lt; (lenB - lenA); i++) &#123;\n                curB &#x3D; curB-&gt;next;\n            &#125;\n        &#125;\n        while (curA !&#x3D; curB) &#123;\n            curA &#x3D; curA-&gt;next;\n            curB &#x3D; curB-&gt;next;\n        &#125;\n        if (curA !&#x3D; nullptr) return curA;\n        \n        return nullptr;\n\n    &#125;\n    \n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>使用哈希表</li>\n</ol>\n<p>使用一个哈希表存储一个链表的所有元素的地址，接着对另一个链表进行遍历，若另一个链表中有元素的地址和哈希表中的链表地址相等，则返回该元素，否则遍历结束后返回<code>null</code></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        unordered_set&lt;ListNode*&gt; nodes; &#x2F;&#x2F;使用unordered_set存储链表A的各个元素的地址\n        while (headA) &#123;\n            nodes.insert(headA);\n            headA &#x3D; headA-&gt;next;\n        &#125;\n        while (headB) &#123;\n            if (nodes.count(headB)) &#123; &#x2F;&#x2F; 判断headB的元素地址是否在unordered_set中\n                return headB;\n            &#125;\n            headB &#x3D; headB-&gt;next;\n        &#125;\n        return nullptr;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>需要注意的是在C++中因为<code>ListNode</code>没有定义比较方法，所以在这里使用的是 <code>unordered_set&lt;ListNode*&gt;</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>”快慢指针“法</li>\n</ol>\n<p>使用两个指针分别指向两个链表的头结点，分别进行遍历，若指针在遍历时遍历到了尾节点，则令指向尾节点的指针指向另一个链表的头结点，若两个链表有相交，即有重叠部分时，这两个指针终究会相遇，此时返回相遇的指针即可，若不能相遇，则返回<code>null</code>。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        &#x2F;&#x2F; &quot;快慢指针&quot;\n        ListNode* pointA &#x3D; headA;\n        ListNode* pointB &#x3D; headB;\n        while (pointA !&#x3D; pointB) &#123;\n            pointA &#x3D; pointA !&#x3D; nullptr? pointA-&gt;next: pointA &#x3D; headB;\n            pointB &#x3D; pointB !&#x3D; nullptr? pointB-&gt;next: pointB &#x3D; headA;\n        &#125;\n        if (pointA !&#x3D; nullptr) return pointA; &#x2F;&#x2F; 需要注意在遍历结束后判断pointA（或pointB)是否为null\n\n        return nullptr;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}