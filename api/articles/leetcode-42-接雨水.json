{"title":"leetcode:42.接雨水","slug":"leetcode-42-接雨水","date":"2023-01-29T19:14:51.000Z","updated":"2023-01-29T19:31:57.722Z","comments":true,"path":"api/articles/leetcode-42-接雨水.json","excerpt":"题目给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。","covers":["http://cdn.leafii.top/img/rainwatertrap.png","http://cdn.leafii.top/img/1.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/rainwatertrap.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：height &#x3D; [4,2,0,3,2,5]\n输出：9</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == height.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 104</code></li>\n<li><code>0 &lt;= height[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>创建两个长度为n的数组leftMax和rightMax.leftMax[i]表示下标i以及其左边的位置中，height的最大高度，rightMax[i]表示下标i及其右边的位置中，height的最大高度。其中leftMax[0] &#x3D; height[0], rightMax[n - 1] &#x3D; height[n - 1].</p>\n<ul>\n<li>当1 &lt;&#x3D; i &lt;&#x3D; n - 1时， leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);</li>\n<li>当0 &lt;&#x3D; i &lt;&#x3D; n - 2时，rightMax[i] &#x3D; max(rightMax[i + 1], height[i]).</li>\n</ul>\n<p>因此可以正向遍历数组height得到leftMax的每个元素值，反向遍历数组height得到rightMax的每个元素值。</p>\n<p>在得到数组leftMax和rightMax的每个元素值后，对于0&lt;&#x3D;i&lt;n，下标i处能接的雨水量等于min(leftMax[i], rightMax[i]) - height[i].对每个下标i进行遍历，将结果进行累加。</p>\n<p><img src=\"http://cdn.leafii.top/img/1.png\" alt=\"fig1\" loading=\"lazy\"></p>\n<p>C++代码实现如下： </p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        int n &#x3D; height.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        vector&lt;int&gt; leftMax(n);\n        leftMax[0] &#x3D; height[0];\n        for (int i &#x3D; 1; i &lt; n; ++i) &#123;\n            leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);\n        &#125;\n\n        vector&lt;int&gt; rightMax(n);\n        rightMax[n - 1] &#x3D; height[n - 1];\n        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; --i) &#123;\n            rightMax[i] &#x3D; max(rightMax[i + 1], height[i]);\n        &#125;\n\n        int ans &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n            ans +&#x3D; min(leftMax[i], rightMax[i]) - height[i];\n        &#125;\n        return ans;\n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>力扣官方题解：<a href=\"https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/\">https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/</a></p>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/rainwatertrap.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：height &#x3D; [4,2,0,3,2,5]\n输出：9</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == height.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 104</code></li>\n<li><code>0 &lt;= height[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>创建两个长度为n的数组leftMax和rightMax.leftMax[i]表示下标i以及其左边的位置中，height的最大高度，rightMax[i]表示下标i及其右边的位置中，height的最大高度。其中leftMax[0] &#x3D; height[0], rightMax[n - 1] &#x3D; height[n - 1].</p>\n<ul>\n<li>当1 &lt;&#x3D; i &lt;&#x3D; n - 1时， leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);</li>\n<li>当0 &lt;&#x3D; i &lt;&#x3D; n - 2时，rightMax[i] &#x3D; max(rightMax[i + 1], height[i]).</li>\n</ul>\n<p>因此可以正向遍历数组height得到leftMax的每个元素值，反向遍历数组height得到rightMax的每个元素值。</p>\n<p>在得到数组leftMax和rightMax的每个元素值后，对于0&lt;&#x3D;i&lt;n，下标i处能接的雨水量等于min(leftMax[i], rightMax[i]) - height[i].对每个下标i进行遍历，将结果进行累加。</p>\n<p><img src=\"http://cdn.leafii.top/img/1.png\" alt=\"fig1\"></p>\n<p>C++代码实现如下： </p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        int n &#x3D; height.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        vector&lt;int&gt; leftMax(n);\n        leftMax[0] &#x3D; height[0];\n        for (int i &#x3D; 1; i &lt; n; ++i) &#123;\n            leftMax[i] &#x3D; max(leftMax[i - 1], height[i]);\n        &#125;\n\n        vector&lt;int&gt; rightMax(n);\n        rightMax[n - 1] &#x3D; height[n - 1];\n        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; --i) &#123;\n            rightMax[i] &#x3D; max(rightMax[i + 1], height[i]);\n        &#125;\n\n        int ans &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n            ans +&#x3D; min(leftMax[i], rightMax[i]) - height[i];\n        &#125;\n        return ans;\n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>力扣官方题解：<a href=\"https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/\">https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/</a></p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}