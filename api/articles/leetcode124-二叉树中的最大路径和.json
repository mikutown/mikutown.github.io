{"title":"leetcode124.二叉树中的最大路径和","slug":"leetcode124-二叉树中的最大路径和","date":"2023-03-16T07:56:05.000Z","updated":"2023-03-16T08:00:27.245Z","comments":true,"path":"api/articles/leetcode124-二叉树中的最大路径和.json","excerpt":"题目路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其 最大路径和 。","covers":["http://cdn.leafii.top/img/exx1.jpg","http://cdn.leafii.top/img/exx2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>\n<p><strong>路径和</strong> 是路径中各节点值的总和。</p>\n<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/exx1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3]\n输出：6\n解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/exx2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>树形DP<ol>\n<li>首先判断当前节点是否为 null，若为 null 则返回 0。</li>\n<li>递归计算当前节点的左子树和右子树的最大路径和，分别为 <code>left</code> 和 <code>right</code>。</li>\n<li>计算当前子树中包含当前节点的最大路径和 <code>curMax</code>，公式为 <code>node-&gt;val + max(0, max(left, right))</code>，其中 <code>node-&gt;val</code> 表示当前节点的值，<code>max(left, right)</code> 表示当前子树中不包含当前节点的最大路径和，<code>max(0, ...)</code> 的作用是保证当前子树中的路径和一定是非负数。</li>\n<li>更新全局最大路径和 <code>res</code>，公式为 <code>max(res, left+right+node-&gt;val)</code>，其中 <code>left+right+node-&gt;val</code> 表示当前子树中包含当前节点的路径和。</li>\n<li>返回当前子树的最大路径和 <code>curMax</code>。</li>\n</ol>\n</li>\n</ol>\n<p>在递归计算时，每个节点都会计算自己为根节点的最大路径和，并更新全局最大路径和。最终返回的是整棵树中的最大路径和。</p>\n<p>这种递归思路在处理树形结构的问题时非常常见，被称为树形 DP（动态规划）。通过递归计算子树的最大路径和，并将结果传递给父节点，最终得到整棵树的最大路径和。C++代码实现如下:</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int maxPathSum(TreeNode* root) &#123;\n        int res &#x3D; INT_MIN;\n        dfs(root, res);\n        return res;\n    &#125;\n\n    int dfs(TreeNode* root, int&amp; res) &#123;\n        if (!root) return 0;\n        int left &#x3D; max(0, dfs(root-&gt;left, res)); &#x2F;&#x2F; 左子树的最大贡献值\n        int right &#x3D; max(0, dfs(root-&gt;right, res)); &#x2F;&#x2F; 右子树的最大贡献值\n        res &#x3D; max(res, root-&gt;val + left + right); &#x2F;&#x2F; 更新最大路径和\n        return root-&gt;val + max(left, right); &#x2F;&#x2F; 返回当前子树的最大路径和\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/exx1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3]\n输出：6\n解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/exx2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>树形DP<ol>\n<li>首先判断当前节点是否为 null，若为 null 则返回 0。</li>\n<li>递归计算当前节点的左子树和右子树的最大路径和，分别为 <code>left</code> 和 <code>right</code>。</li>\n<li>计算当前子树中包含当前节点的最大路径和 <code>curMax</code>，公式为 <code>node-&gt;val + max(0, max(left, right))</code>，其中 <code>node-&gt;val</code> 表示当前节点的值，<code>max(left, right)</code> 表示当前子树中不包含当前节点的最大路径和，<code>max(0, ...)</code> 的作用是保证当前子树中的路径和一定是非负数。</li>\n<li>更新全局最大路径和 <code>res</code>，公式为 <code>max(res, left+right+node-&gt;val)</code>，其中 <code>left+right+node-&gt;val</code> 表示当前子树中包含当前节点的路径和。</li>\n<li>返回当前子树的最大路径和 <code>curMax</code>。</li>\n</ol>\n</li>\n</ol>\n<p>在递归计算时，每个节点都会计算自己为根节点的最大路径和，并更新全局最大路径和。最终返回的是整棵树中的最大路径和。</p>\n<p>这种递归思路在处理树形结构的问题时非常常见，被称为树形 DP（动态规划）。通过递归计算子树的最大路径和，并将结果传递给父节点，最终得到整棵树的最大路径和。C++代码实现如下:</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int maxPathSum(TreeNode* root) &#123;\n        int res &#x3D; INT_MIN;\n        dfs(root, res);\n        return res;\n    &#125;\n\n    int dfs(TreeNode* root, int&amp; res) &#123;\n        if (!root) return 0;\n        int left &#x3D; max(0, dfs(root-&gt;left, res)); &#x2F;&#x2F; 左子树的最大贡献值\n        int right &#x3D; max(0, dfs(root-&gt;right, res)); &#x2F;&#x2F; 右子树的最大贡献值\n        res &#x3D; max(res, root-&gt;val + left + right); &#x2F;&#x2F; 更新最大路径和\n        return root-&gt;val + max(left, right); &#x2F;&#x2F; 返回当前子树的最大路径和\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}