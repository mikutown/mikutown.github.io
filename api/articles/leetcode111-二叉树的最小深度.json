{"title":"leetcode111.二叉树的最小深度","slug":"leetcode111-二叉树的最小深度","date":"2023-03-12T11:56:24.000Z","updated":"2023-03-13T07:50:42.345Z","comments":true,"path":"api/articles/leetcode111-二叉树的最小深度.json","excerpt":"题目给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。","covers":["http://cdn.leafii.top/img/ex_depth.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，找出其最小深度。</p>\n<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>\n<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/ex_depth.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：2</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]\n输出：5</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>DFS（深度优先遍历）</li>\n</ol>\n<p>使用了递归的方式。首先判断根节点是否为空，如果为空，则返回深度为0；如果根节点没有左右子节点，返回深度为1；如果有左右子节点，则分别递归计算左子树和右子树的深度，取两者的较小值再加1，即为该树的最小深度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int minDepth(TreeNode* root) &#123;\n        &#x2F;&#x2F; 如果当前节点为空，则返回0\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1\n        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;\n            return 1;\n        &#125;\n        int left_depth &#x3D; INT_MAX, right_depth &#x3D; INT_MAX;\n        &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度\n        if (root-&gt;left !&#x3D; nullptr) &#123;\n            left_depth &#x3D; minDepth(root-&gt;left);\n        &#125;\n        &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度\n        if (root-&gt;right !&#x3D; nullptr) &#123;\n            right_depth &#x3D; minDepth(root-&gt;right);\n        &#125;\n        &#x2F;&#x2F; 返回左右子树深度的较小值加1\n        return min(left_depth, right_depth) + 1;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>BFS（广度优先遍历）</li>\n</ol>\n<p>该代码使用了队列来实现广度优先搜索，从根节点开始，逐层访问该节点的左右子节点，并将子节点及其所在的层数入队，直到找到叶子节点，即没有左右子节点的节点，此时返回该节点所在的层数即可。如果整个二叉树中没有叶子节点，则返回0。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int minDepth(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F; 创建队列， 存储节点以及其所在的层数\n        queue&lt;pair&lt;TreeNode*, int&gt;&gt; q;\n        &#x2F;&#x2F; 将根节点和所在的层数入队\n        q.push(make_pair(root, 1));\n        while (!q.empty()) &#123;\n            &#x2F;&#x2F; 取出队首节点和所在的层数\n            TreeNode* node &#x3D; q.front().first;\n            int depth &#x3D; q.front().second;\n            q.pop();\n            &#x2F;&#x2F; 如果该节点为叶子节点， 直接返回其所在的层数\n            if (node-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; node-&gt;right &#x3D;&#x3D; nullptr) &#123;\n                return depth;\n            &#125;\n            &#x2F;&#x2F; 如果该节点有左子节点，则将其左子节点和所在的层数入队\n            if (node-&gt;left !&#x3D; nullptr) &#123;\n                q.push(make_pair(node-&gt;left, depth+1));    \n            &#125;\n            &#x2F;&#x2F; 如果该节点有右子节点，则将其右子节点和所在的层数入队\n            if (node-&gt;right !&#x3D; nullptr) &#123;\n                q.push(make_pair(node-&gt;right, depth+1));    \n            &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>一般来说，DFS和BFS的效率取决于二叉树的结构和分布。如果二叉树比较平衡，那么BFS可能更快，因为它可以更早地找到最小深度的叶子节点。如果二叉树比较不平衡，那么DFS可能更快，因为它可以避免访问很多不必要的节点。</p>\n</blockquote>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/ex_depth.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：2</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]\n输出：5</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>DFS（深度优先遍历）</li>\n</ol>\n<p>使用了递归的方式。首先判断根节点是否为空，如果为空，则返回深度为0；如果根节点没有左右子节点，返回深度为1；如果有左右子节点，则分别递归计算左子树和右子树的深度，取两者的较小值再加1，即为该树的最小深度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int minDepth(TreeNode* root) &#123;\n        &#x2F;&#x2F; 如果当前节点为空，则返回0\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1\n        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;\n            return 1;\n        &#125;\n        int left_depth &#x3D; INT_MAX, right_depth &#x3D; INT_MAX;\n        &#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度\n        if (root-&gt;left !&#x3D; nullptr) &#123;\n            left_depth &#x3D; minDepth(root-&gt;left);\n        &#125;\n        &#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度\n        if (root-&gt;right !&#x3D; nullptr) &#123;\n            right_depth &#x3D; minDepth(root-&gt;right);\n        &#125;\n        &#x2F;&#x2F; 返回左右子树深度的较小值加1\n        return min(left_depth, right_depth) + 1;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>BFS（广度优先遍历）</li>\n</ol>\n<p>该代码使用了队列来实现广度优先搜索，从根节点开始，逐层访问该节点的左右子节点，并将子节点及其所在的层数入队，直到找到叶子节点，即没有左右子节点的节点，此时返回该节点所在的层数即可。如果整个二叉树中没有叶子节点，则返回0。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int minDepth(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F; 创建队列， 存储节点以及其所在的层数\n        queue&lt;pair&lt;TreeNode*, int&gt;&gt; q;\n        &#x2F;&#x2F; 将根节点和所在的层数入队\n        q.push(make_pair(root, 1));\n        while (!q.empty()) &#123;\n            &#x2F;&#x2F; 取出队首节点和所在的层数\n            TreeNode* node &#x3D; q.front().first;\n            int depth &#x3D; q.front().second;\n            q.pop();\n            &#x2F;&#x2F; 如果该节点为叶子节点， 直接返回其所在的层数\n            if (node-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; node-&gt;right &#x3D;&#x3D; nullptr) &#123;\n                return depth;\n            &#125;\n            &#x2F;&#x2F; 如果该节点有左子节点，则将其左子节点和所在的层数入队\n            if (node-&gt;left !&#x3D; nullptr) &#123;\n                q.push(make_pair(node-&gt;left, depth+1));    \n            &#125;\n            &#x2F;&#x2F; 如果该节点有右子节点，则将其右子节点和所在的层数入队\n            if (node-&gt;right !&#x3D; nullptr) &#123;\n                q.push(make_pair(node-&gt;right, depth+1));    \n            &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>一般来说，DFS和BFS的效率取决于二叉树的结构和分布。如果二叉树比较平衡，那么BFS可能更快，因为它可以更早地找到最小深度的叶子节点。如果二叉树比较不平衡，那么DFS可能更快，因为它可以避免访问很多不必要的节点。</p>\n</blockquote>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}