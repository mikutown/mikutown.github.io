{"title":"leetcode:19.删除链表的倒数第N个结点","slug":"leetcode-19-删除链表的倒数第N个结点","date":"2023-01-11T07:20:46.000Z","updated":"2023-01-11T07:39:19.425Z","comments":true,"path":"api/articles/leetcode-19-删除链表的倒数第N个结点.json","excerpt":"题目给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。","covers":["http://cdn.leafii.top/img/remove_ex1.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/remove_ex1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2\n输出：[1,2,3,5]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1], n &#x3D; 1\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2], n &#x3D; 1\n输出：[1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中结点的数目为 <code>sz</code></li>\n<li><code>1 &lt;= sz &lt;= 30</code></li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>双指针遍历一次链表，思路如下：</li>\n</ol>\n<p>设置两个指针p，q，分别初始为头结点，然后p指针向后移动n次，接着p和q指针同时移动直到p指针指向链表的最后一个元素，此时q指针指向的是被删除元素的前一个元素，因此将需要被删除的元素进行删除，最终返回头结点即可，需要注意<strong>删除头结点的情况</strong>。实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;\n        ListNode *q &#x3D; head, *p &#x3D; head, *t &#x3D; head -&gt; next;\n        if(head &#x3D;&#x3D; NULL)\n        &#123;\n            return head;\n        &#125;\n        while(n-- &amp;&amp; p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;p指针向后移动n位\n        &#123;\n            p &#x3D; p -&gt; next;\n        &#125;\n        if(n !&#x3D; -1) &#x2F;&#x2F;删除头结点\n        &#123;\n            t &#x3D; head;\n            head &#x3D; head -&gt; next;\n            delete t;\n            return head;\n        &#125;\n        while(p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;此时p和q指针一起向后移动，直到p指向最后一个结点\n        &#123;\n            q &#x3D; q -&gt; next;\n            p &#x3D; p -&gt; next;\n\n        &#125;\n        t &#x3D; q -&gt; next;\n        q -&gt; next &#x3D; t -&gt; next;\n        delete t;\n        return head;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/remove_ex1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2\n输出：[1,2,3,5]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1], n &#x3D; 1\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2], n &#x3D; 1\n输出：[1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中结点的数目为 <code>sz</code></li>\n<li><code>1 &lt;= sz &lt;= 30</code></li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>双指针遍历一次链表，思路如下：</li>\n</ol>\n<p>设置两个指针p，q，分别初始为头结点，然后p指针向后移动n次，接着p和q指针同时移动直到p指针指向链表的最后一个元素，此时q指针指向的是被删除元素的前一个元素，因此将需要被删除的元素进行删除，最终返回头结点即可，需要注意<strong>删除头结点的情况</strong>。实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;\n        ListNode *q &#x3D; head, *p &#x3D; head, *t &#x3D; head -&gt; next;\n        if(head &#x3D;&#x3D; NULL)\n        &#123;\n            return head;\n        &#125;\n        while(n-- &amp;&amp; p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;p指针向后移动n位\n        &#123;\n            p &#x3D; p -&gt; next;\n        &#125;\n        if(n !&#x3D; -1) &#x2F;&#x2F;删除头结点\n        &#123;\n            t &#x3D; head;\n            head &#x3D; head -&gt; next;\n            delete t;\n            return head;\n        &#125;\n        while(p -&gt; next !&#x3D; NULL) &#x2F;&#x2F;此时p和q指针一起向后移动，直到p指向最后一个结点\n        &#123;\n            q &#x3D; q -&gt; next;\n            p &#x3D; p -&gt; next;\n\n        &#125;\n        t &#x3D; q -&gt; next;\n        q -&gt; next &#x3D; t -&gt; next;\n        delete t;\n        return head;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}