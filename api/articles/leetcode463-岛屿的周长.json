{"title":"leetcode463.岛屿的周长","slug":"leetcode463-岛屿的周长","date":"2023-09-05T08:26:04.000Z","updated":"2023-09-05T09:43:45.352Z","comments":true,"path":"api/articles/leetcode463-岛屿的周长.json","excerpt":"题目给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。","covers":["http://cdn.leafii.top/img/island.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p>\n<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>\n<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/island.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：grid &#x3D; [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n输出：16\n解释：它的周长是上面图片中的 16 个黄色的边</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：grid &#x3D; [[1]]\n输出：4</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：grid &#x3D; [[1,0]]\n输出：4</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>row == grid.length</code></li>\n<li><code>col == grid[i].length</code></li>\n<li><code>1 &lt;= row, col &lt;= 100</code></li>\n<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力遍历</li>\n</ul>\n<p>思路：对每一个方格进行遍历，在当前方格为1时，将result的值增加4，接下来判断当前的方格周围的方格是否为1，如果它的下方或右方有同样是1的方格时，将res减少2（分别在当前方格和相邻方格方面的边长减去）。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int res &#x3D; 0; &#x2F;&#x2F; 初始化结果\n        int rows &#x3D; grid.size(); &#x2F;&#x2F; 获取行数\n        int cols &#x3D; grid[0].size(); &#x2F;&#x2F; 获取列数\n        &#x2F;&#x2F; 开始遍历\n        for (int i &#x3D; 0; i &lt; rows; ++i) &#123; \n            for (int j &#x3D; 0; j &lt; cols; ++j) &#123;\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果当前被遍历的方格值为1\n                    res +&#x3D; 4; &#x2F;&#x2F; 结果增加4\n                    if (i &lt; rows - 1 &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) res -&#x3D; 2; &#x2F;&#x2F; 判断当前遍历的方格的下方的方格是否也是1\n                    if (j &lt; cols - 1 &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) res -&#x3D; 2;&#x2F;&#x2F; 判断当前遍历的方格的右方的方格是否也是1\n                &#125;\n            &#125;\n        &#125;\n        return res; &#x2F;&#x2F; 返回结果\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>数学方法</li>\n</ul>\n<p>思路：一块土地原则上会带来 4 个周长，但岛上的土地存在接壤，每一条接壤，会减掉 2 个边长。</p>\n<p>所以，总周长 &#x3D; 4 * 土地个数 - 2 * 接壤边的条数。</p>\n<p>遍历矩阵，遍历到土地，就 land++，如果它的右&#x2F;下边也是土地，则 border++，遍历结束后代入公式。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int land &#x3D; 0;&#x2F;&#x2F;土地数量\n        int border &#x3D; 0;&#x2F;&#x2F;接壤边的条数\n\n        for (int i &#x3D; 0; i &lt; grid.size(); ++i) &#123;\n            for (int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123;\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123;\n                    ++land;\n                    if (i &lt; grid.size() - 1 &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;该土地的下方有土地就说明下面这条边就是接壤边\n                        ++border;\n                    &#125;\n                    if (j &lt; grid[0].size() - 1 &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;该土地的右方有土地就说明右面这条边就是接壤边\n                        ++border;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return 4 * land - 2 * border;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>DFS</li>\n</ul>\n<p>思路：岛就一个，我们从第一个遇到的土地开始深搜。</p>\n<p>对于每个土地节点，做一些事情，基于它，递归上下左右四个点，做同样的事情。做什么事情呢？</p>\n<p>从土地到土地，之间不会产生周长，但从土地迈入海洋，之间会产生 1 个周长，从土地迈出矩阵边界，也会产生 1 个周长。</p>\n<p>dfs 的过程中，对当前点的上下左右递归，下一个递归的点又对上下左右递归，就会造成重复访问，造成周长的重复计算。</p>\n<p>遍历过的土地节点，将值改为 2，区分于 1 和 0，代表访问过了。</p>\n<p>总结：DFS 从一个点，向四周扩散，目标是遇到矩阵边界或海水，它们是答案已知的 base case，是位于递归树底部的 case，是递归的终止条件。</p>\n<p>从上而下递归调用，随着递归的出栈，子问题的解自下而上地返回，最后得出大问题的解。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        for (int i &#x3D; 0; i &lt; grid.size(); ++i) &#123;\n            for (int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123;\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123;\n                    return dfsHelper(grid, i, j);\n                &#125;\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n\n    int dfsHelper(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j) &#123;\n        int rows &#x3D; grid.size();\n        int cols &#x3D; grid[0].size();\n        if (i &lt; 0 || i &gt;&#x3D; rows || j &lt; 0 || j &gt;&#x3D; cols) &#123;\n            &#x2F;&#x2F;越界的情况，直接返回1\n            return 1;\n        &#125;\n        if (grid[i][j] &#x3D;&#x3D; 0) &#123;\n            &#x2F;&#x2F; 从土地到达海水\n            return 1;\n        &#125;\n        if (grid[i][j] &#x3D;&#x3D; 2) &#123;\n            &#x2F;&#x2F; 之前已经访问过这块方格了，直接返回0\n            return 0;\n        &#125;\n        &#x2F;&#x2F; 修改方格的值为2，说明已经来过了\n        grid[i][j] &#x3D; 2;\n        return dfsHelper(grid, i - 1, j) + dfsHelper(grid, i + 1, j) + dfsHelper(grid, i, j - 1) + dfsHelper(grid, i, j + 1);\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/island.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：grid &#x3D; [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n输出：16\n解释：它的周长是上面图片中的 16 个黄色的边</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：grid &#x3D; [[1]]\n输出：4</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：grid &#x3D; [[1,0]]\n输出：4</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>row == grid.length</code></li>\n<li><code>col == grid[i].length</code></li>\n<li><code>1 &lt;= row, col &lt;= 100</code></li>\n<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力遍历</li>\n</ul>\n<p>思路：对每一个方格进行遍历，在当前方格为1时，将result的值增加4，接下来判断当前的方格周围的方格是否为1，如果它的下方或右方有同样是1的方格时，将res减少2（分别在当前方格和相邻方格方面的边长减去）。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int res &#x3D; 0; &#x2F;&#x2F; 初始化结果\n        int rows &#x3D; grid.size(); &#x2F;&#x2F; 获取行数\n        int cols &#x3D; grid[0].size(); &#x2F;&#x2F; 获取列数\n        &#x2F;&#x2F; 开始遍历\n        for (int i &#x3D; 0; i &lt; rows; ++i) &#123; \n            for (int j &#x3D; 0; j &lt; cols; ++j) &#123;\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果当前被遍历的方格值为1\n                    res +&#x3D; 4; &#x2F;&#x2F; 结果增加4\n                    if (i &lt; rows - 1 &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) res -&#x3D; 2; &#x2F;&#x2F; 判断当前遍历的方格的下方的方格是否也是1\n                    if (j &lt; cols - 1 &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) res -&#x3D; 2;&#x2F;&#x2F; 判断当前遍历的方格的右方的方格是否也是1\n                &#125;\n            &#125;\n        &#125;\n        return res; &#x2F;&#x2F; 返回结果\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>数学方法</li>\n</ul>\n<p>思路：一块土地原则上会带来 4 个周长，但岛上的土地存在接壤，每一条接壤，会减掉 2 个边长。</p>\n<p>所以，总周长 &#x3D; 4 * 土地个数 - 2 * 接壤边的条数。</p>\n<p>遍历矩阵，遍历到土地，就 land++，如果它的右&#x2F;下边也是土地，则 border++，遍历结束后代入公式。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int land &#x3D; 0;&#x2F;&#x2F;土地数量\n        int border &#x3D; 0;&#x2F;&#x2F;接壤边的条数\n\n        for (int i &#x3D; 0; i &lt; grid.size(); ++i) &#123;\n            for (int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123;\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123;\n                    ++land;\n                    if (i &lt; grid.size() - 1 &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;该土地的下方有土地就说明下面这条边就是接壤边\n                        ++border;\n                    &#125;\n                    if (j &lt; grid[0].size() - 1 &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;该土地的右方有土地就说明右面这条边就是接壤边\n                        ++border;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return 4 * land - 2 * border;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>DFS</li>\n</ul>\n<p>思路：岛就一个，我们从第一个遇到的土地开始深搜。</p>\n<p>对于每个土地节点，做一些事情，基于它，递归上下左右四个点，做同样的事情。做什么事情呢？</p>\n<p>从土地到土地，之间不会产生周长，但从土地迈入海洋，之间会产生 1 个周长，从土地迈出矩阵边界，也会产生 1 个周长。</p>\n<p>dfs 的过程中，对当前点的上下左右递归，下一个递归的点又对上下左右递归，就会造成重复访问，造成周长的重复计算。</p>\n<p>遍历过的土地节点，将值改为 2，区分于 1 和 0，代表访问过了。</p>\n<p>总结：DFS 从一个点，向四周扩散，目标是遇到矩阵边界或海水，它们是答案已知的 base case，是位于递归树底部的 case，是递归的终止条件。</p>\n<p>从上而下递归调用，随着递归的出栈，子问题的解自下而上地返回，最后得出大问题的解。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        for (int i &#x3D; 0; i &lt; grid.size(); ++i) &#123;\n            for (int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123;\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123;\n                    return dfsHelper(grid, i, j);\n                &#125;\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n\n    int dfsHelper(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j) &#123;\n        int rows &#x3D; grid.size();\n        int cols &#x3D; grid[0].size();\n        if (i &lt; 0 || i &gt;&#x3D; rows || j &lt; 0 || j &gt;&#x3D; cols) &#123;\n            &#x2F;&#x2F;越界的情况，直接返回1\n            return 1;\n        &#125;\n        if (grid[i][j] &#x3D;&#x3D; 0) &#123;\n            &#x2F;&#x2F; 从土地到达海水\n            return 1;\n        &#125;\n        if (grid[i][j] &#x3D;&#x3D; 2) &#123;\n            &#x2F;&#x2F; 之前已经访问过这块方格了，直接返回0\n            return 0;\n        &#125;\n        &#x2F;&#x2F; 修改方格的值为2，说明已经来过了\n        grid[i][j] &#x3D; 2;\n        return dfsHelper(grid, i - 1, j) + dfsHelper(grid, i + 1, j) + dfsHelper(grid, i, j - 1) + dfsHelper(grid, i, j + 1);\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}