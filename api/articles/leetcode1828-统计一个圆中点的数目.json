{"title":"leetcode1828.统计一个圆中点的数目","slug":"leetcode1828-统计一个圆中点的数目","date":"2023-09-07T07:54:16.000Z","updated":"2023-09-07T08:04:02.618Z","comments":true,"path":"api/articles/leetcode1828-统计一个圆中点的数目.json","excerpt":"题目给你一个数组 points ，其中 points[i] = [xi, yi] ，表示第 i 个点在二维平面上的坐标。多个点可能会有 相同 的坐标。同时给你一个数组 queries ，其中 queries[j] = [xj, yj, rj] ，表示一个圆心在 (xj, yj) 且半径为 rj 的圆。对于每一个查询 queries[j] ，计算在第 j 个圆 内 点的数目。如果一个点在圆的 边界上 ，我们同样认为它在圆 内 。请你返回一个数组 answer ，其中 answer[j]是第 j 个查询的答案。","covers":["http://cdn.leafii.top/img/chrome_2021-03-25_22-34-16.png","http://cdn.leafii.top/img/chrome_2021-03-25_22-42-07.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> ，表示第 <code>i</code> 个点在二维平面上的坐标。多个点可能会有 <strong>相同</strong> 的坐标。</p>\n<p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [xj, yj, rj]</code> ，表示一个圆心在 <code>(xj, yj)</code> 且半径为 <code>rj</code> 的圆。</p>\n<p>对于每一个查询 <code>queries[j]</code> ，计算在第 <code>j</code> 个圆 <strong>内</strong> 点的数目。如果一个点在圆的 <strong>边界上</strong> ，我们同样认为它在圆 <strong>内</strong> 。</p>\n<p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/chrome_2021-03-25_22-34-16.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：points &#x3D; [[1,3],[3,3],[5,3],[2,2]], queries &#x3D; [[2,3,1],[4,3,1],[1,1,2]]\n输出：[3,2,2]\n解释：所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/chrome_2021-03-25_22-42-07.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：points &#x3D; [[1,1],[2,2],[3,3],[4,4],[5,5]], queries &#x3D; [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\n输出：[2,3,2,4]\n解释：所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= points.length &lt;= 500</code></li>\n<li><code>points[i].length == 2</code></li>\n<li><code>0 &lt;= xi, yi &lt;= 500</code></li>\n<li><code>1 &lt;= queries.length &lt;= 500</code></li>\n<li><code>queries[j].length == 3</code></li>\n<li><code>0 &lt;= xj, yj &lt;= 500</code></li>\n<li><code>1 &lt;= rj &lt;= 500</code></li>\n<li>所有的坐标都是整数。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接模拟</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;\n        int pointNum &#x3D; points.size(); &#x2F;&#x2F; 点的数目\n        int queriesNum &#x3D; queries.size(); &#x2F;&#x2F; 圆的数目\n        vector&lt;int&gt; ans(queriesNum, 0);\n        for (int i &#x3D; 0; i &lt; queriesNum; i++) &#123;\n            &#x2F;&#x2F; 获取当前遍历的圆的圆心和半径\n            int round_x &#x3D; queries[i][0];\n            int round_y &#x3D; queries[i][1];\n            int round_r &#x3D; queries[i][2];\n            for (int j &#x3D; 0; j &lt; pointNum; j++) &#123;\n                int point_x &#x3D; points[j][0]; &#x2F;&#x2F; 获取点的坐标\n                int point_y &#x3D; points[j][1];\n                &#x2F;&#x2F; 开始判断点是否在圆内\n                double dx &#x3D; round_x - point_x;\n                double dy &#x3D; round_y - point_y;\n                double dis &#x3D; sqrt(dx * dx + dy * dy);\n                if (dis &lt;&#x3D; round_r) ++ans[i]; &#x2F;&#x2F; 如果确实在圆内，ans数组对应元素增加！\n            &#125;\n        &#125;\n        return ans; &#x2F;&#x2F; 返回结果数组\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/chrome_2021-03-25_22-34-16.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：points &#x3D; [[1,3],[3,3],[5,3],[2,2]], queries &#x3D; [[2,3,1],[4,3,1],[1,1,2]]\n输出：[3,2,2]\n解释：所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/chrome_2021-03-25_22-42-07.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：points &#x3D; [[1,1],[2,2],[3,3],[4,4],[5,5]], queries &#x3D; [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\n输出：[2,3,2,4]\n解释：所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= points.length &lt;= 500</code></li>\n<li><code>points[i].length == 2</code></li>\n<li><code>0 &lt;= xi, yi &lt;= 500</code></li>\n<li><code>1 &lt;= queries.length &lt;= 500</code></li>\n<li><code>queries[j].length == 3</code></li>\n<li><code>0 &lt;= xj, yj &lt;= 500</code></li>\n<li><code>1 &lt;= rj &lt;= 500</code></li>\n<li>所有的坐标都是整数。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接模拟</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;\n        int pointNum &#x3D; points.size(); &#x2F;&#x2F; 点的数目\n        int queriesNum &#x3D; queries.size(); &#x2F;&#x2F; 圆的数目\n        vector&lt;int&gt; ans(queriesNum, 0);\n        for (int i &#x3D; 0; i &lt; queriesNum; i++) &#123;\n            &#x2F;&#x2F; 获取当前遍历的圆的圆心和半径\n            int round_x &#x3D; queries[i][0];\n            int round_y &#x3D; queries[i][1];\n            int round_r &#x3D; queries[i][2];\n            for (int j &#x3D; 0; j &lt; pointNum; j++) &#123;\n                int point_x &#x3D; points[j][0]; &#x2F;&#x2F; 获取点的坐标\n                int point_y &#x3D; points[j][1];\n                &#x2F;&#x2F; 开始判断点是否在圆内\n                double dx &#x3D; round_x - point_x;\n                double dy &#x3D; round_y - point_y;\n                double dis &#x3D; sqrt(dx * dx + dy * dy);\n                if (dis &lt;&#x3D; round_r) ++ans[i]; &#x2F;&#x2F; 如果确实在圆内，ans数组对应元素增加！\n            &#125;\n        &#125;\n        return ans; &#x2F;&#x2F; 返回结果数组\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}