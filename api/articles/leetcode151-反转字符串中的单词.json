{"title":"leetcode151.反转字符串中的单词","slug":"leetcode151-反转字符串中的单词","date":"2023-03-22T02:01:36.000Z","updated":"2023-03-22T02:31:09.124Z","comments":true,"path":"api/articles/leetcode151-反转字符串中的单词.json","excerpt":"题目给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>\n<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>\n<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>\n<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;the sky is blue&quot;\n输出：&quot;blue is sky the&quot;</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;  hello world  &quot;\n输出：&quot;world hello&quot;\n解释：反转后的字符串中不能存在前导空格和尾随空格。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;a good   example&quot;\n输出：&quot;example good a&quot;\n解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 104</code></li>\n<li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li>\n<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>\n</ul>\n<p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<p>大致思路：将字符串中的每个单词放入动态数组中，然后将动态数组倒序遍历得到结果字符串，最后返回结果字符串，C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string reverseWords(string s) &#123;\n        &#x2F;&#x2F; 特判：如果s的长度为1，则只包含一个单词，此时直接返回s即可\n        if (s.length() &#x3D;&#x3D; 1) return s;\n\n        &#x2F;&#x2F; 新建s_vec动态数组，元素类型为string\n        vector&lt;string&gt; s_vec;\n        &#x2F;&#x2F; 定义left，它是指向字符串里第一个单词的第一个字母的指针\n        int left &#x3D; 0; &#x2F;&#x2F; left的初始化\n        while (s[left] &#x3D;&#x3D; &#39; &#39;) &#123;\n            left++;  &#x2F;&#x2F; 防止字符串一开始就是空格\n        &#125;\n        &#x2F;&#x2F; 开始循环\n        for (int i &#x3D; left; i &lt; s.length(); i++) &#123;\n            &#x2F;&#x2F; 当i指向一个单词右边的第一个空格或者字符串的最后一个元素时\n            if (s[i] &#x3D;&#x3D; &#39; &#39; || i &#x3D;&#x3D; s.length() - 1) &#123;\n                if (i &#x3D;&#x3D; s.length()-1) i++; &#x2F;&#x2F; 当i指向字符串的最后一个字母时，需要自增1，否则无法通过substr获得子串\n\n                string temp &#x3D; s.substr(left, i - left); &#x2F;&#x2F; 使用substr获得子串\n                s_vec.push_back(temp); &#x2F;&#x2F; 将子串push进动态数组s_vec中\n                while (s[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; i &lt; s.length()) &#123;\n                    i++; &#x2F;&#x2F; 令i从其之后的第一个非空字母开始遍历\n                &#125;\n                left &#x3D; i; &#x2F;&#x2F; 更新left的值\n            &#125;\n        &#125;\n        if (s[s.length()-1] !&#x3D; &#39; &#39; &amp;&amp; s[s.length()-2] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 针对字符串最后的一个单词只有一个字母的特判\n            string temp &#x3D; s.substr(s.length()-1);\n            s_vec.push_back(temp);\n        &#125;\n        int n &#x3D; s_vec.size(); &#x2F;&#x2F; 获取动态数组的大小（也就是总的单词个数）\n        string result; &#x2F;&#x2F; 定义结果字符串\n        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123; &#x2F;&#x2F; 反向遍历，将结果同result相加\n            if (i &#x3D;&#x3D; n - 1) &#123; &#x2F;&#x2F; 第一个单词前无需加空格\n                result &#x3D; result + s_vec[i];\n            &#125;\n            else &#123; &#x2F;&#x2F; 其他单词在同result合并前需要先加一个空格\n                result &#x3D; result + &quot; &quot; + s_vec[i]; \n            &#125;\n        &#125;\n        return result; &#x2F;&#x2F; 返回result字符串\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>空间复杂度为O(1)的解法</li>\n</ul>\n<ol>\n<li>将整个字符串进行反转</li>\n<li>将反转后的字符串的每个单词进行反转</li>\n<li>去除字符串中多余的空格</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string reverseWords(string s) &#123;\n        reverse(s.begin(), s.end()); &#x2F;&#x2F; 翻转整个字符串\n        int n &#x3D; s.size();\n        int idx &#x3D; 0;\n        for (int start &#x3D; 0; start &lt; n; ++start) &#123;\n            if (s[start] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 找到单词的起始位置\n                if (idx !&#x3D; 0) s[idx++] &#x3D; &#39; &#39;; &#x2F;&#x2F; 添加单词间空格\n                int end &#x3D; start;\n                while (end &lt; n &amp;&amp; s[end] !&#x3D; &#39; &#39;) s[idx++] &#x3D; s[end++]; &#x2F;&#x2F; 翻转单词\n                reverse(s.begin() + idx - (end - start), s.begin() + idx); &#x2F;&#x2F; 翻转单词\n                start &#x3D; end;\n            &#125;\n        &#125;\n        s.erase(s.begin() + idx, s.end()); &#x2F;&#x2F; 删除多余的空格\n        return s;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>当我们调用reverse函数时，它会将字符串中的字符进行翻转。例如，如果我们有一个字符串”hello”，那么调用reverse函数后，它会变成”olleh”。在这个题目中，我们需要将整个字符串进行翻转，所以我们调用了reverse(s.begin(), s.end())函数来实现这个功能。</p>\n</blockquote>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;the sky is blue&quot;\n输出：&quot;blue is sky the&quot;</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;  hello world  &quot;\n输出：&quot;world hello&quot;\n解释：反转后的字符串中不能存在前导空格和尾随空格。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;a good   example&quot;\n输出：&quot;example good a&quot;\n解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 104</code></li>\n<li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li>\n<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>\n</ul>\n<p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<p>大致思路：将字符串中的每个单词放入动态数组中，然后将动态数组倒序遍历得到结果字符串，最后返回结果字符串，C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string reverseWords(string s) &#123;\n        &#x2F;&#x2F; 特判：如果s的长度为1，则只包含一个单词，此时直接返回s即可\n        if (s.length() &#x3D;&#x3D; 1) return s;\n\n        &#x2F;&#x2F; 新建s_vec动态数组，元素类型为string\n        vector&lt;string&gt; s_vec;\n        &#x2F;&#x2F; 定义left，它是指向字符串里第一个单词的第一个字母的指针\n        int left &#x3D; 0; &#x2F;&#x2F; left的初始化\n        while (s[left] &#x3D;&#x3D; &#39; &#39;) &#123;\n            left++;  &#x2F;&#x2F; 防止字符串一开始就是空格\n        &#125;\n        &#x2F;&#x2F; 开始循环\n        for (int i &#x3D; left; i &lt; s.length(); i++) &#123;\n            &#x2F;&#x2F; 当i指向一个单词右边的第一个空格或者字符串的最后一个元素时\n            if (s[i] &#x3D;&#x3D; &#39; &#39; || i &#x3D;&#x3D; s.length() - 1) &#123;\n                if (i &#x3D;&#x3D; s.length()-1) i++; &#x2F;&#x2F; 当i指向字符串的最后一个字母时，需要自增1，否则无法通过substr获得子串\n\n                string temp &#x3D; s.substr(left, i - left); &#x2F;&#x2F; 使用substr获得子串\n                s_vec.push_back(temp); &#x2F;&#x2F; 将子串push进动态数组s_vec中\n                while (s[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; i &lt; s.length()) &#123;\n                    i++; &#x2F;&#x2F; 令i从其之后的第一个非空字母开始遍历\n                &#125;\n                left &#x3D; i; &#x2F;&#x2F; 更新left的值\n            &#125;\n        &#125;\n        if (s[s.length()-1] !&#x3D; &#39; &#39; &amp;&amp; s[s.length()-2] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 针对字符串最后的一个单词只有一个字母的特判\n            string temp &#x3D; s.substr(s.length()-1);\n            s_vec.push_back(temp);\n        &#125;\n        int n &#x3D; s_vec.size(); &#x2F;&#x2F; 获取动态数组的大小（也就是总的单词个数）\n        string result; &#x2F;&#x2F; 定义结果字符串\n        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123; &#x2F;&#x2F; 反向遍历，将结果同result相加\n            if (i &#x3D;&#x3D; n - 1) &#123; &#x2F;&#x2F; 第一个单词前无需加空格\n                result &#x3D; result + s_vec[i];\n            &#125;\n            else &#123; &#x2F;&#x2F; 其他单词在同result合并前需要先加一个空格\n                result &#x3D; result + &quot; &quot; + s_vec[i]; \n            &#125;\n        &#125;\n        return result; &#x2F;&#x2F; 返回result字符串\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>空间复杂度为O(1)的解法</li>\n</ul>\n<ol>\n<li>将整个字符串进行反转</li>\n<li>将反转后的字符串的每个单词进行反转</li>\n<li>去除字符串中多余的空格</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string reverseWords(string s) &#123;\n        reverse(s.begin(), s.end()); &#x2F;&#x2F; 翻转整个字符串\n        int n &#x3D; s.size();\n        int idx &#x3D; 0;\n        for (int start &#x3D; 0; start &lt; n; ++start) &#123;\n            if (s[start] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 找到单词的起始位置\n                if (idx !&#x3D; 0) s[idx++] &#x3D; &#39; &#39;; &#x2F;&#x2F; 添加单词间空格\n                int end &#x3D; start;\n                while (end &lt; n &amp;&amp; s[end] !&#x3D; &#39; &#39;) s[idx++] &#x3D; s[end++]; &#x2F;&#x2F; 翻转单词\n                reverse(s.begin() + idx - (end - start), s.begin() + idx); &#x2F;&#x2F; 翻转单词\n                start &#x3D; end;\n            &#125;\n        &#125;\n        s.erase(s.begin() + idx, s.end()); &#x2F;&#x2F; 删除多余的空格\n        return s;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>当我们调用reverse函数时，它会将字符串中的字符进行翻转。例如，如果我们有一个字符串”hello”，那么调用reverse函数后，它会变成”olleh”。在这个题目中，我们需要将整个字符串进行翻转，所以我们调用了reverse(s.begin(), s.end())函数来实现这个功能。</p>\n</blockquote>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}