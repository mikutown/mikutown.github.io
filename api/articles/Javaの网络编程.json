{"title":"Javaの网络编程","slug":"Javaの网络编程","date":"2020-04-10T17:35:55.000Z","updated":"2021-01-02T19:15:52.000Z","comments":true,"path":"api/articles/Javaの网络编程.json","excerpt":"Javaの网络编程网络编程概述1.1      网络协议<br>       通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。","covers":["https://gitee.com/mikutown/pic/raw/master/img/20200411013004.png","https://gitee.com/mikutown/pic/raw/master/img/20200411013100.png","https://www.leafii.top/upload/2019/11/image-3e8ac860d4a942f88fa97e4da58a4a7e.png","https://gitee.com/mikutown/pic/raw/master/img/20200411013306.png"],"content":"<h1 id=\"Javaの网络编程\"><a href=\"#Javaの网络编程\" class=\"headerlink\" title=\"Javaの网络编程\"></a>Javaの网络编程</h1><h3 id=\"网络编程概述\"><a href=\"#网络编程概述\" class=\"headerlink\" title=\"网络编程概述\"></a>网络编程概述</h3><p>1.1      网络协议<br>       通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p>\n<a id=\"more\"></a>\n\n<p>​      网络通信协议有很多种，目前应用最广泛的是TCP&#x2F;IP协议(Transmission Control Protocal&#x2F;Internet Protoal传输控制协议&#x2F;英特网互联协议)，它是一个包括TCP协议和IP协议，UDP（User Datagram Protocol）协议和其它一些协议的协议组，在学习具体协议之前首先了解一下TCP&#x2F;IP协议组的层次结构。<br>​       在进行数据传输时，要求发送的数据与收到的数据完全一样，这时，就需要在原有的数据上添加很多信息，以保证数据在传输过程中数据格式完全一致。TCP&#x2F;IP协议的层次结构比较简单，共分为四层，如图所示。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013004.png\" loading=\"lazy\"><br> 上图中，TCP&#x2F;IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP&#x2F;IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。<br>1.2      IP地址和端口号<br>​       要想使网络中的计算机能够进行通信，必须为每台计算机指定一个标识号，通过这个标识号来指定接受数据的计算机或者发送数据的计算机。<br>​       在TCP&#x2F;IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机，目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”。<br>​       随着计算机网络规模的不断扩大，对IP地址的需求也越来越多，IPV4这种用4个字节表示的IP地址面临枯竭，因此IPv6 便应运而生了，IPv6使用16个字节表示IP地址，它所拥有的地址容量约是IPv4的8×1028倍，达到2128个（算上全零的），这样就解决了网络地址资源数量不够的问题。<br>​      通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0<del>65535，其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。<br>​      接下来通过一个图例来描述IP地址和端口号的作用，如下图所示:<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013023.png\" loading=\"lazy\"><br>从上图中可以清楚地看到，位于网络中一台计算机可以通过IP地址去访问另一台计算机，并通过端口号访问目标计算机中的某个应用程序。<br>1.3      InetAddress<br>​      了解了IP地址的作用，我们看学习下JDK中提供了一个InetAdderss类，该类用于封装一个IP地址，并提供了一系列与IP地址相关的方法，下表中列出了InetAddress类的一些常用方法。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013039.png\" loading=\"lazy\"></p>\n<pre class=\"language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InetAddress</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">UnknownHostException</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">/*\n * InetAddress:此类表示互联网协议 (IP) 地址。\n *\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InetAddressDemo</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">UnknownHostException</span>   <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//static InetAddress getByName(String host)</span>\n         <span class=\"token comment\">//InetAddress address = InetAddress.getByName(\"itheima\");</span>\n        <span class=\"token class-name\">InetAddress</span> address <span class=\"token operator\">=</span> <span class=\"token class-name\">InetAddress</span><span class=\"token punctuation\">.</span><span class=\"token function\">getByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"192.168.1.107\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//ip地址是唯一的</span>\n     \n        <span class=\"token comment\">//System.out.println(address);//itheima/192.168.1.107 ipconfig</span>\n         \n        <span class=\"token class-name\">String</span> hostAddress <span class=\"token operator\">=</span> address<span class=\"token punctuation\">.</span><span class=\"token function\">getHostAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//192.168.1.107 返回IP地址</span>\n        <span class=\"token class-name\">String</span> hostName <span class=\"token operator\">=</span> address<span class=\"token punctuation\">.</span><span class=\"token function\">getHostName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//itheima   返回主机名</span>\n         \n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>hostAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>hostName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n \n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n<p>第2章 UDP协议<br>      UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。<br>2.1      DatagramPacket<br>       前面介绍了UDP是一种面向无连接的协议，因此，在通信时发送端和接收端不用建立连接。UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“集装箱”进行打包，为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。<br>       想要创建一个DatagramPacket对象，首先需要了解一下它的构造方法。在创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端IP地址和端口号。<br>        接下来根据API文档的内容，对DatagramPacket的构造方法进行逐一详细地讲解。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013100.png\" loading=\"lazy\"><br>   使用该构造方法在创建DatagramPacket对象时，指定了封装数据的字节数组和数据的大小，没有指定IP地址和端口号。很明显，这样的对象只能用于接收端，不能用于发送端。因为发送端一定要明确指出数据的目的地(ip地址和端口号)，而接收端不需要明确知道数据的来源，只需要接收到数据即可。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013116.png\" loading=\"lazy\"><br>     使用该构造方法在创建DatagramPacket对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标IP地址（address）和端口号（port）。该对象通常用于发送端，因为在发送数据时必须指定接收端的IP地址和端口号，就好像发送货物的集装箱上面必须标明接收人的地址一样。<br>       上面我们讲解了DatagramPacket的构造方法，接下来对DatagramPacket类中的常用方法进行详细地讲解，如下表所示。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013136.png\" loading=\"lazy\"></p>\n<p>2.2      DatagramSocket<br>       DatagramPacket数据包的作用就如同是“集装箱”，可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包。<br><img src=\"https://www.leafii.top/upload/2019/11/image-3e8ac860d4a942f88fa97e4da58a4a7e.png\" alt=\"image.png\" loading=\"lazy\"><br>该构造方法用于创建发送端的DatagramSocket对象，在创建DatagramSocket对象时，并没有指定端口号，此时，系统会分配一个没有被其它网络程序所使用的端口号。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013151.png\" loading=\"lazy\"><br>该构造方法既可用于创建接收端的DatagramSocket对象，又可以创建发送端的DatagramSocket对象，在创建接收端的DatagramSocket对象时，必须要指定一个端口号，这样就可以监听指定的端口。<br>      上面我们讲解了DatagramSocket的构造方法，接下来对DatagramSocket类中的常用方法进行介绍。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013209.png\" loading=\"lazy\"><br>2.3      UDP实现<br>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;<br>import java.net.SocketException;</p>\n<p>&#x2F;*</p>\n<ul>\n<li><p>使用UDP协议发送数据<br>   创建发送端Socket对象<br>   创建数据并打包<br>   发送数据<br>   释放资源</p>\n<ul>\n<li></li>\n</ul>\n</li>\n<li><p>DatagramSocket:此类表示用来发送和接收数据,基于UDP协议的</p>\n<ul>\n<li></li>\n</ul>\n</li>\n<li><p>DatagramSocket() ：创建Socket对象并随机分配端口号</p>\n</li>\n<li><p>DatagramSocket(int port) ：创建Socket对象并指定端口号<br><em>&#x2F;<br>public class SendDemo {<br>public static void main(String[] args) throws IOException  {<br>&#x2F;&#x2F;创建发送端Socket对象<br>DatagramSocket ds &#x3D; new DatagramSocket();<br>&#x2F;&#x2F;创建数据并打包<br>&#x2F;</em><br> * DatagramPacket :此类表示数据报包<br> * 数据 byte[]<br> * 设备的地址 ip<br> * 进程的地址  端口号<br>   DatagramPacket(byte[] buf, int length, InetAddress address, int port)<br> *&#x2F;<br><br><br>String s &#x3D; “hello udp,im comming!”;<br>byte[] bys &#x3D; s.getBytes();<br>int length &#x3D; bys.length;<br>InetAddress address &#x3D; InetAddress.getByName(“127.0.0.1”);&#x2F;&#x2F;发送给当前设备<br>int port &#x3D; 8888;<br>&#x2F;&#x2F;打包<br>DatagramPacket dp &#x3D; new DatagramPacket(bys,length,address,port);<br>&#x2F;&#x2F;发送数据<br>ds.send(dp);<br>&#x2F;&#x2F;释放资源<br>ds.close();<br>}<br>}</p>\n</li>\n</ul>\n<p>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;</p>\n<p>&#x2F;*</p>\n<ul>\n<li>使用UDP协议接收数据<br>   创建接收端Socket对象<br>   接收数据<br>   解析数据<br>   输出数据<br>   释放资源</li>\n</ul>\n<p> *&#x2F;<br>public class ReceiveDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建接收端Socket对象<br>        DatagramSocket ds &#x3D; new DatagramSocket(8888);<br>        &#x2F;&#x2F;接收数据<br>        &#x2F;&#x2F;DatagramPacket(byte[] buf, int length)<br>        byte[] bys &#x3D; new byte[1024];<br>        DatagramPacket dp &#x3D; new DatagramPacket(bys,bys.length);</p>\n<pre><code>    System.out.println(1);\n    ds.receive(dp);//阻塞\n    System.out.println(2);\n     \n    //解析数据\n    //InetAddress getAddress() : 获取发送端的IP对象\n    InetAddress address = dp.getAddress();\n    //byte[] getData()  ：获取接收到的数据，也可以直接使用创建包对象时的数组\n    byte[] data = dp.getData();\n    //int getLength()  ：获取具体收到数据的长度\n    int length = dp.getLength();\n</code></pre>\n<p>​<br>​<br>​        &#x2F;&#x2F;输出数据<br>​        System.out.println(“sender —&gt; “ + address.getHostAddress());<br>​        &#x2F;&#x2F;System.out.println(new String(data,0,length));<br>​        System.out.println(new String(bys,0,length));<br>​        &#x2F;&#x2F;释放资源<br>​        ds.close();<br>​    }<br>}<br>第3章     TCP协议<br>​       TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。<br>​       在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。<br>3.1      ServerSocket<br>JDK的java.net包中提供了一个ServerSocket类，该类的实例对象可以实现一个服务器段的程序。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013306.png\" loading=\"lazy\"><br>使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上（参数port就是端口号）。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013248.png\" loading=\"lazy\"><br> ServerSocket对象负责监听某台计算机的某个端口号，在创建ServerSocket对象后，需要继续调用该对象的accept()方法，接收来自客户端的请求。当执行了accept()方法之后，服务器端程序会发生阻塞，直到客户端发出连接请求，accept()方法才会返回一个Scoket对象用于和客户端实现通信，程序才能继续向下执行。<br>3.2      Socket<br>ServerSocket对象可以实现服务端程序，但只实现服务器端程序还不能完成通信，此时还需要一个客户端程序与之交互，为此JDK提供了一个Socket类，用于实现TCP客户端程序。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013326.png\" loading=\"lazy\"><br>使用该构造方法在创建Socket对象时，会根据参数去连接在指定地址和端口上运行的服务器程序，其中参数host接收的是一个字符串类型的IP地址。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013349.png\" loading=\"lazy\"><br>该方法在使用上与第二个构造方法类似，参数address用于接收一个InetAddress类型的对象，该对象用于封装一个IP地址。<br>方法声明<br>功能描述<br>int getPort()<br>该方法返回一个int类型对象，该对象是Socket对象与服务器端连接的端口号<br>InetAddress getLocalAddress()<br>该方法用于获取Socket对象绑定的本地IP地址，并将IP地址封装成InetAddress类型的对象返回<br>void close()<br>该方法用于关闭Socket连接，结束本次通信。在关闭socket之前，应将与socket相关的所有的输入&#x2F;输出流全部关闭，这是因为一个良好的程序应该在执行完毕时释放所有的资源<br>InputStream getInputStream()<br>该方法返回一个InputStream类型的输入流对象，如果该对象是由服务器端的Socket返回，就用于读取客户端发送的数据，反之，用于读取服务器端发送的数据<br>OutputStream getOutputStream()<br>该方法返回一个OutputStream类型的输出流对象，如果该对象是由服务器端的Socket返回，就用于向客户端发送数据，反之，用于向服务器端发送数据</p>\n<p>在Socket类的常用方法中，getInputStream()和getOutStream()方法分别用于获取输入流和输出流。当客户端和服务端建立连接后，数据是以IO流的形式进行交互的，从而实现通信。<br>3.3      TCP协议实现<br>import java.io.IOException;<br>import java.io.OutputStream;<br>import java.net.InetAddress;<br>import java.net.Socket;</p>\n<p>&#x2F;*</p>\n<ul>\n<li><p>使用TCP协议发送数据<br>   创建发送端Socket对象（创建连接）<br>   获取输出流对象<br>   发送数据<br>   释放资源</p>\n<p>Socket(InetAddress address, int port)<br>Exception in thread “main” java.net.ConnectException: Connection refused: connect</p>\n</li>\n</ul>\n<p> *&#x2F;<br>public class ClientDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建发送端Socket对象（创建连接）<br>        Socket s &#x3D; new Socket(InetAddress.getByName(“127.0.0.1”),10086);<br>        &#x2F;&#x2F;获取输出流对象<br>        OutputStream os &#x3D; s.getOutputStream();<br>        &#x2F;&#x2F;发送数据<br>        String str &#x3D; “hello tcp,im comming!!!”;<br>        os.write(str.getBytes());<br>        &#x2F;&#x2F;释放资源<br>        &#x2F;&#x2F;os.close();<br>        s.close();<br>    }<br>}</p>\n<p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.net.InetAddress;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>\n<p>&#x2F;*</p>\n<ul>\n<li><p>使用TCP协议接收数据<br>   创建接收端Socket对象<br>   监听（阻塞）<br>   获取输入流对象<br>   获取数据<br>   输出数据<br>   释放资源</p>\n<p>ServerSocket：接收端，服务端Socket<br>ServerSocket(int port)<br>Socket accept()</p>\n</li>\n</ul>\n<p> *&#x2F;<br>public class ServerDemo {<br>    public static void main(String[] args) throws IOException  {<br>        &#x2F;&#x2F;创建接收端Socket对象<br>        ServerSocket ss &#x3D; new ServerSocket(10086);<br>        &#x2F;&#x2F;监听（阻塞）<br>        Socket s &#x3D; ss.accept();<br>        &#x2F;&#x2F;获取输入流对象<br>        InputStream is &#x3D; s.getInputStream();<br>        &#x2F;&#x2F;获取数据<br>        byte[] bys &#x3D; new byte[1024];<br>        int len;&#x2F;&#x2F;用于存储读到的字节个数<br>        len &#x3D; is.read(bys);<br>        &#x2F;&#x2F;输出数据<br>        InetAddress address &#x3D; s.getInetAddress();<br>        System.out.println(“client —&gt; “ + address.getHostName());<br>        System.out.println(new String(bys,0,len));<br>        &#x2F;&#x2F;释放资源<br>        s.close();<br>        &#x2F;&#x2F;ss.close();<br>    }<br>}<br>3.4  TCP练习：服务端将接收到的数据转换成大写返回给客户端<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.InetAddress;<br>import java.net.Socket;</p>\n<p>&#x2F;*<br>    需求：使用TCP协议发送数据，并将接收到的数据转换成大写返回</p>\n<pre><code>客户端发出数据\n服务端接收数据\n服务端转换数据\n服务端发出数据\n客户端接收数据\n</code></pre>\n<p> *&#x2F;<br>public class ClientDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建客户端Socket对象<br>        Socket s &#x3D; new Socket(InetAddress.getByName(“127.0.0.1”),10010);<br>        &#x2F;&#x2F;获取输出流对象<br>        OutputStream os &#x3D; s.getOutputStream();<br>        &#x2F;&#x2F;发出数据<br>        os.write(“tcp,im comming again!!!”.getBytes());</p>\n<pre><code>    //获取输入流对象\n    InputStream is = s.getInputStream();\n    byte[] bys = new byte[1024];\n    int len;//用于存储读取到的字节个数\n    //接收数据\n    len = is.read(bys);\n    //输出数据\n    System.out.println(new String(bys,0,len));\n     \n    //释放资源\n    s.close();\n     \n&#125;\n</code></pre>\n<p>}</p>\n<p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>\n<p>public class ServerDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建服务端Socket对象<br>        ServerSocket ss &#x3D; new ServerSocket(10010);<br>        &#x2F;&#x2F;监听<br>        Socket s &#x3D; ss.accept();<br>        &#x2F;&#x2F;获取输入流对象<br>        InputStream is &#x3D; s.getInputStream();<br>        &#x2F;&#x2F;获取数据<br>        byte[] bys &#x3D; new byte[1024];<br>        int len;&#x2F;&#x2F;用于存储读取到的字节个数<br>        len &#x3D; is.read(bys);<br>        String str &#x3D; new String(bys,0,len);<br>        &#x2F;&#x2F;输出数据<br>        System.out.println(str);<br>        &#x2F;&#x2F;转换数据<br>        String upperStr &#x3D; str.toUpperCase();<br>        &#x2F;&#x2F;获取输出流对象<br>        OutputStream os &#x3D; s.getOutputStream();<br>        &#x2F;&#x2F;返回数据（发出数据）<br>        os.write(upperStr.getBytes());</p>\n<pre><code>    //释放资源\n    s.close();\n    //ss.close();//服务端一般不关闭\n&#125;\n</code></pre>\n<p>}<br>3.5  TCP练习：聊天程序设计<br>&#x2F;&#x2F;创建服务端，并在其中启动读写线程并一直接收客户端连接信息<br>public class ServerDemo {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F;服务端<br>        try {<br>            ServerSocket serverSocket&#x3D;new ServerSocket(8888);<br>            System.out.println(“等待客户端连接。。。”);<br>            while (true){<br>                Socket accept &#x3D; serverSocket.accept();<br>                &#x2F;&#x2F;开启不断写的线程<br>                new Thread(new WriteThread(accept),”服务端”).start();<br>                &#x2F;&#x2F;开启不断读的线程<br>                new Thread(new ReadThread(accept),”服务端”).start();<br>            }<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p>\n<p>&#x2F;&#x2F;创建客户端，并开启读写线程<br>public class ClientDemo {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F;客户端<br>        try {<br>            Socket socket&#x3D;new Socket(“192.168.102.16”,8888);<br>            InputStream is &#x3D; socket.getInputStream();<br>            byte[] b&#x3D;new byte[1024];<br>            new Thread(new WriteThread(socket),”客户端1”).start();<br>            while (true){<br>                int read &#x3D; is.read(b);<br>                System.out.println(new String(b,0,read));<br>            }<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p>\n<p>&#x2F;&#x2F;创建读线程<br>public class ReadThread implements Runnable{<br>    private Socket socket;<br>    private InputStream is;</p>\n<pre><code>public ReadThread(Socket socket) &#123;\n    this.socket = socket;\n    try &#123;\n        is=this.socket.getInputStream();\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n  \n@Override\npublic void run() &#123;\n    byte[] b=new byte[1024];\n    while (true)&#123;\n        int read = 0;\n        try &#123;\n            read = is.read(b);\n            System.out.println(new String(b,0,read));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n<p>&#x2F;&#x2F;创建写线程<br>public class WriteThread implements Runnable {<br>    private Socket socket;<br>    private OutputStream os;</p>\n<pre><code>public WriteThread(Socket socket) &#123;\n    this.socket = socket;\n    try &#123;\n        os=socket.getOutputStream();\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n  \n@Override\npublic void run() &#123;\n    //不断的写\n    Scanner scan=new Scanner(System.in);\n    while (true)&#123;\n        String msg=scan.nextLine();\n        msg=Thread.currentThread().getName()+&quot;:&quot;+msg;\n        try  &#123;\n            os.write(msg.getBytes());\n            os.flush();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n","more":"<p>​      网络通信协议有很多种，目前应用最广泛的是TCP&#x2F;IP协议(Transmission Control Protocal&#x2F;Internet Protoal传输控制协议&#x2F;英特网互联协议)，它是一个包括TCP协议和IP协议，UDP（User Datagram Protocol）协议和其它一些协议的协议组，在学习具体协议之前首先了解一下TCP&#x2F;IP协议组的层次结构。<br>​       在进行数据传输时，要求发送的数据与收到的数据完全一样，这时，就需要在原有的数据上添加很多信息，以保证数据在传输过程中数据格式完全一致。TCP&#x2F;IP协议的层次结构比较简单，共分为四层，如图所示。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013004.png\"><br> 上图中，TCP&#x2F;IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP&#x2F;IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。<br>1.2      IP地址和端口号<br>​       要想使网络中的计算机能够进行通信，必须为每台计算机指定一个标识号，通过这个标识号来指定接受数据的计算机或者发送数据的计算机。<br>​       在TCP&#x2F;IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机，目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”。<br>​       随着计算机网络规模的不断扩大，对IP地址的需求也越来越多，IPV4这种用4个字节表示的IP地址面临枯竭，因此IPv6 便应运而生了，IPv6使用16个字节表示IP地址，它所拥有的地址容量约是IPv4的8×1028倍，达到2128个（算上全零的），这样就解决了网络地址资源数量不够的问题。<br>​      通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0<del>65535，其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。<br>​      接下来通过一个图例来描述IP地址和端口号的作用，如下图所示:<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013023.png\"><br>从上图中可以清楚地看到，位于网络中一台计算机可以通过IP地址去访问另一台计算机，并通过端口号访问目标计算机中的某个应用程序。<br>1.3      InetAddress<br>​      了解了IP地址的作用，我们看学习下JDK中提供了一个InetAdderss类，该类用于封装一个IP地址，并提供了一系列与IP地址相关的方法，下表中列出了InetAddress类的一些常用方法。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013039.png\"></p>\n<pre class=\"language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InetAddress</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">UnknownHostException</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">/*\n * InetAddress:此类表示互联网协议 (IP) 地址。\n *\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InetAddressDemo</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">UnknownHostException</span>   <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//static InetAddress getByName(String host)</span>\n         <span class=\"token comment\">//InetAddress address = InetAddress.getByName(\"itheima\");</span>\n        <span class=\"token class-name\">InetAddress</span> address <span class=\"token operator\">=</span> <span class=\"token class-name\">InetAddress</span><span class=\"token punctuation\">.</span><span class=\"token function\">getByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"192.168.1.107\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//ip地址是唯一的</span>\n     \n        <span class=\"token comment\">//System.out.println(address);//itheima/192.168.1.107 ipconfig</span>\n         \n        <span class=\"token class-name\">String</span> hostAddress <span class=\"token operator\">=</span> address<span class=\"token punctuation\">.</span><span class=\"token function\">getHostAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//192.168.1.107 返回IP地址</span>\n        <span class=\"token class-name\">String</span> hostName <span class=\"token operator\">=</span> address<span class=\"token punctuation\">.</span><span class=\"token function\">getHostName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//itheima   返回主机名</span>\n         \n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>hostAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>hostName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n \n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n<p>第2章 UDP协议<br>      UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。<br>2.1      DatagramPacket<br>       前面介绍了UDP是一种面向无连接的协议，因此，在通信时发送端和接收端不用建立连接。UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“集装箱”进行打包，为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。<br>       想要创建一个DatagramPacket对象，首先需要了解一下它的构造方法。在创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端IP地址和端口号。<br>        接下来根据API文档的内容，对DatagramPacket的构造方法进行逐一详细地讲解。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013100.png\"><br>   使用该构造方法在创建DatagramPacket对象时，指定了封装数据的字节数组和数据的大小，没有指定IP地址和端口号。很明显，这样的对象只能用于接收端，不能用于发送端。因为发送端一定要明确指出数据的目的地(ip地址和端口号)，而接收端不需要明确知道数据的来源，只需要接收到数据即可。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013116.png\"><br>     使用该构造方法在创建DatagramPacket对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标IP地址（address）和端口号（port）。该对象通常用于发送端，因为在发送数据时必须指定接收端的IP地址和端口号，就好像发送货物的集装箱上面必须标明接收人的地址一样。<br>       上面我们讲解了DatagramPacket的构造方法，接下来对DatagramPacket类中的常用方法进行详细地讲解，如下表所示。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013136.png\"></p>\n<p>2.2      DatagramSocket<br>       DatagramPacket数据包的作用就如同是“集装箱”，可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包。<br><img src=\"https://www.leafii.top/upload/2019/11/image-3e8ac860d4a942f88fa97e4da58a4a7e.png\" alt=\"image.png\"><br>该构造方法用于创建发送端的DatagramSocket对象，在创建DatagramSocket对象时，并没有指定端口号，此时，系统会分配一个没有被其它网络程序所使用的端口号。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013151.png\"><br>该构造方法既可用于创建接收端的DatagramSocket对象，又可以创建发送端的DatagramSocket对象，在创建接收端的DatagramSocket对象时，必须要指定一个端口号，这样就可以监听指定的端口。<br>      上面我们讲解了DatagramSocket的构造方法，接下来对DatagramSocket类中的常用方法进行介绍。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013209.png\"><br>2.3      UDP实现<br>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;<br>import java.net.SocketException;</p>\n<p>&#x2F;*</p>\n<ul>\n<li><p>使用UDP协议发送数据<br>   创建发送端Socket对象<br>   创建数据并打包<br>   发送数据<br>   释放资源</p>\n<ul>\n<li></li>\n</ul>\n</li>\n<li><p>DatagramSocket:此类表示用来发送和接收数据,基于UDP协议的</p>\n<ul>\n<li></li>\n</ul>\n</li>\n<li><p>DatagramSocket() ：创建Socket对象并随机分配端口号</p>\n</li>\n<li><p>DatagramSocket(int port) ：创建Socket对象并指定端口号<br><em>&#x2F;<br>public class SendDemo {<br>public static void main(String[] args) throws IOException  {<br>&#x2F;&#x2F;创建发送端Socket对象<br>DatagramSocket ds &#x3D; new DatagramSocket();<br>&#x2F;&#x2F;创建数据并打包<br>&#x2F;</em><br> * DatagramPacket :此类表示数据报包<br> * 数据 byte[]<br> * 设备的地址 ip<br> * 进程的地址  端口号<br>   DatagramPacket(byte[] buf, int length, InetAddress address, int port)<br> *&#x2F;<br><br><br>String s &#x3D; “hello udp,im comming!”;<br>byte[] bys &#x3D; s.getBytes();<br>int length &#x3D; bys.length;<br>InetAddress address &#x3D; InetAddress.getByName(“127.0.0.1”);&#x2F;&#x2F;发送给当前设备<br>int port &#x3D; 8888;<br>&#x2F;&#x2F;打包<br>DatagramPacket dp &#x3D; new DatagramPacket(bys,length,address,port);<br>&#x2F;&#x2F;发送数据<br>ds.send(dp);<br>&#x2F;&#x2F;释放资源<br>ds.close();<br>}<br>}</p>\n</li>\n</ul>\n<p>import java.io.IOException;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;</p>\n<p>&#x2F;*</p>\n<ul>\n<li>使用UDP协议接收数据<br>   创建接收端Socket对象<br>   接收数据<br>   解析数据<br>   输出数据<br>   释放资源</li>\n</ul>\n<p> *&#x2F;<br>public class ReceiveDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建接收端Socket对象<br>        DatagramSocket ds &#x3D; new DatagramSocket(8888);<br>        &#x2F;&#x2F;接收数据<br>        &#x2F;&#x2F;DatagramPacket(byte[] buf, int length)<br>        byte[] bys &#x3D; new byte[1024];<br>        DatagramPacket dp &#x3D; new DatagramPacket(bys,bys.length);</p>\n<pre><code>    System.out.println(1);\n    ds.receive(dp);//阻塞\n    System.out.println(2);\n     \n    //解析数据\n    //InetAddress getAddress() : 获取发送端的IP对象\n    InetAddress address = dp.getAddress();\n    //byte[] getData()  ：获取接收到的数据，也可以直接使用创建包对象时的数组\n    byte[] data = dp.getData();\n    //int getLength()  ：获取具体收到数据的长度\n    int length = dp.getLength();\n</code></pre>\n<p>​<br>​<br>​        &#x2F;&#x2F;输出数据<br>​        System.out.println(“sender —&gt; “ + address.getHostAddress());<br>​        &#x2F;&#x2F;System.out.println(new String(data,0,length));<br>​        System.out.println(new String(bys,0,length));<br>​        &#x2F;&#x2F;释放资源<br>​        ds.close();<br>​    }<br>}<br>第3章     TCP协议<br>​       TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。<br>​       在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。<br>3.1      ServerSocket<br>JDK的java.net包中提供了一个ServerSocket类，该类的实例对象可以实现一个服务器段的程序。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013306.png\"><br>使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上（参数port就是端口号）。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013248.png\"><br> ServerSocket对象负责监听某台计算机的某个端口号，在创建ServerSocket对象后，需要继续调用该对象的accept()方法，接收来自客户端的请求。当执行了accept()方法之后，服务器端程序会发生阻塞，直到客户端发出连接请求，accept()方法才会返回一个Scoket对象用于和客户端实现通信，程序才能继续向下执行。<br>3.2      Socket<br>ServerSocket对象可以实现服务端程序，但只实现服务器端程序还不能完成通信，此时还需要一个客户端程序与之交互，为此JDK提供了一个Socket类，用于实现TCP客户端程序。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013326.png\"><br>使用该构造方法在创建Socket对象时，会根据参数去连接在指定地址和端口上运行的服务器程序，其中参数host接收的是一个字符串类型的IP地址。<br><img src=\"https://gitee.com/mikutown/pic/raw/master/img/20200411013349.png\"><br>该方法在使用上与第二个构造方法类似，参数address用于接收一个InetAddress类型的对象，该对象用于封装一个IP地址。<br>方法声明<br>功能描述<br>int getPort()<br>该方法返回一个int类型对象，该对象是Socket对象与服务器端连接的端口号<br>InetAddress getLocalAddress()<br>该方法用于获取Socket对象绑定的本地IP地址，并将IP地址封装成InetAddress类型的对象返回<br>void close()<br>该方法用于关闭Socket连接，结束本次通信。在关闭socket之前，应将与socket相关的所有的输入&#x2F;输出流全部关闭，这是因为一个良好的程序应该在执行完毕时释放所有的资源<br>InputStream getInputStream()<br>该方法返回一个InputStream类型的输入流对象，如果该对象是由服务器端的Socket返回，就用于读取客户端发送的数据，反之，用于读取服务器端发送的数据<br>OutputStream getOutputStream()<br>该方法返回一个OutputStream类型的输出流对象，如果该对象是由服务器端的Socket返回，就用于向客户端发送数据，反之，用于向服务器端发送数据</p>\n<p>在Socket类的常用方法中，getInputStream()和getOutStream()方法分别用于获取输入流和输出流。当客户端和服务端建立连接后，数据是以IO流的形式进行交互的，从而实现通信。<br>3.3      TCP协议实现<br>import java.io.IOException;<br>import java.io.OutputStream;<br>import java.net.InetAddress;<br>import java.net.Socket;</p>\n<p>&#x2F;*</p>\n<ul>\n<li><p>使用TCP协议发送数据<br>   创建发送端Socket对象（创建连接）<br>   获取输出流对象<br>   发送数据<br>   释放资源</p>\n<p>Socket(InetAddress address, int port)<br>Exception in thread “main” java.net.ConnectException: Connection refused: connect</p>\n</li>\n</ul>\n<p> *&#x2F;<br>public class ClientDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建发送端Socket对象（创建连接）<br>        Socket s &#x3D; new Socket(InetAddress.getByName(“127.0.0.1”),10086);<br>        &#x2F;&#x2F;获取输出流对象<br>        OutputStream os &#x3D; s.getOutputStream();<br>        &#x2F;&#x2F;发送数据<br>        String str &#x3D; “hello tcp,im comming!!!”;<br>        os.write(str.getBytes());<br>        &#x2F;&#x2F;释放资源<br>        &#x2F;&#x2F;os.close();<br>        s.close();<br>    }<br>}</p>\n<p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.net.InetAddress;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>\n<p>&#x2F;*</p>\n<ul>\n<li><p>使用TCP协议接收数据<br>   创建接收端Socket对象<br>   监听（阻塞）<br>   获取输入流对象<br>   获取数据<br>   输出数据<br>   释放资源</p>\n<p>ServerSocket：接收端，服务端Socket<br>ServerSocket(int port)<br>Socket accept()</p>\n</li>\n</ul>\n<p> *&#x2F;<br>public class ServerDemo {<br>    public static void main(String[] args) throws IOException  {<br>        &#x2F;&#x2F;创建接收端Socket对象<br>        ServerSocket ss &#x3D; new ServerSocket(10086);<br>        &#x2F;&#x2F;监听（阻塞）<br>        Socket s &#x3D; ss.accept();<br>        &#x2F;&#x2F;获取输入流对象<br>        InputStream is &#x3D; s.getInputStream();<br>        &#x2F;&#x2F;获取数据<br>        byte[] bys &#x3D; new byte[1024];<br>        int len;&#x2F;&#x2F;用于存储读到的字节个数<br>        len &#x3D; is.read(bys);<br>        &#x2F;&#x2F;输出数据<br>        InetAddress address &#x3D; s.getInetAddress();<br>        System.out.println(“client —&gt; “ + address.getHostName());<br>        System.out.println(new String(bys,0,len));<br>        &#x2F;&#x2F;释放资源<br>        s.close();<br>        &#x2F;&#x2F;ss.close();<br>    }<br>}<br>3.4  TCP练习：服务端将接收到的数据转换成大写返回给客户端<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.InetAddress;<br>import java.net.Socket;</p>\n<p>&#x2F;*<br>    需求：使用TCP协议发送数据，并将接收到的数据转换成大写返回</p>\n<pre><code>客户端发出数据\n服务端接收数据\n服务端转换数据\n服务端发出数据\n客户端接收数据\n</code></pre>\n<p> *&#x2F;<br>public class ClientDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建客户端Socket对象<br>        Socket s &#x3D; new Socket(InetAddress.getByName(“127.0.0.1”),10010);<br>        &#x2F;&#x2F;获取输出流对象<br>        OutputStream os &#x3D; s.getOutputStream();<br>        &#x2F;&#x2F;发出数据<br>        os.write(“tcp,im comming again!!!”.getBytes());</p>\n<pre><code>    //获取输入流对象\n    InputStream is = s.getInputStream();\n    byte[] bys = new byte[1024];\n    int len;//用于存储读取到的字节个数\n    //接收数据\n    len = is.read(bys);\n    //输出数据\n    System.out.println(new String(bys,0,len));\n     \n    //释放资源\n    s.close();\n     \n&#125;\n</code></pre>\n<p>}</p>\n<p>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>\n<p>public class ServerDemo {<br>    public static void main(String[] args) throws IOException {<br>        &#x2F;&#x2F;创建服务端Socket对象<br>        ServerSocket ss &#x3D; new ServerSocket(10010);<br>        &#x2F;&#x2F;监听<br>        Socket s &#x3D; ss.accept();<br>        &#x2F;&#x2F;获取输入流对象<br>        InputStream is &#x3D; s.getInputStream();<br>        &#x2F;&#x2F;获取数据<br>        byte[] bys &#x3D; new byte[1024];<br>        int len;&#x2F;&#x2F;用于存储读取到的字节个数<br>        len &#x3D; is.read(bys);<br>        String str &#x3D; new String(bys,0,len);<br>        &#x2F;&#x2F;输出数据<br>        System.out.println(str);<br>        &#x2F;&#x2F;转换数据<br>        String upperStr &#x3D; str.toUpperCase();<br>        &#x2F;&#x2F;获取输出流对象<br>        OutputStream os &#x3D; s.getOutputStream();<br>        &#x2F;&#x2F;返回数据（发出数据）<br>        os.write(upperStr.getBytes());</p>\n<pre><code>    //释放资源\n    s.close();\n    //ss.close();//服务端一般不关闭\n&#125;\n</code></pre>\n<p>}<br>3.5  TCP练习：聊天程序设计<br>&#x2F;&#x2F;创建服务端，并在其中启动读写线程并一直接收客户端连接信息<br>public class ServerDemo {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F;服务端<br>        try {<br>            ServerSocket serverSocket&#x3D;new ServerSocket(8888);<br>            System.out.println(“等待客户端连接。。。”);<br>            while (true){<br>                Socket accept &#x3D; serverSocket.accept();<br>                &#x2F;&#x2F;开启不断写的线程<br>                new Thread(new WriteThread(accept),”服务端”).start();<br>                &#x2F;&#x2F;开启不断读的线程<br>                new Thread(new ReadThread(accept),”服务端”).start();<br>            }<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p>\n<p>&#x2F;&#x2F;创建客户端，并开启读写线程<br>public class ClientDemo {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F;客户端<br>        try {<br>            Socket socket&#x3D;new Socket(“192.168.102.16”,8888);<br>            InputStream is &#x3D; socket.getInputStream();<br>            byte[] b&#x3D;new byte[1024];<br>            new Thread(new WriteThread(socket),”客户端1”).start();<br>            while (true){<br>                int read &#x3D; is.read(b);<br>                System.out.println(new String(b,0,read));<br>            }<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p>\n<p>&#x2F;&#x2F;创建读线程<br>public class ReadThread implements Runnable{<br>    private Socket socket;<br>    private InputStream is;</p>\n<pre><code>public ReadThread(Socket socket) &#123;\n    this.socket = socket;\n    try &#123;\n        is=this.socket.getInputStream();\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n  \n@Override\npublic void run() &#123;\n    byte[] b=new byte[1024];\n    while (true)&#123;\n        int read = 0;\n        try &#123;\n            read = is.read(b);\n            System.out.println(new String(b,0,read));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n<p>&#x2F;&#x2F;创建写线程<br>public class WriteThread implements Runnable {<br>    private Socket socket;<br>    private OutputStream os;</p>\n<pre><code>public WriteThread(Socket socket) &#123;\n    this.socket = socket;\n    try &#123;\n        os=socket.getOutputStream();\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n  \n@Override\npublic void run() &#123;\n    //不断的写\n    Scanner scan=new Scanner(System.in);\n    while (true)&#123;\n        String msg=scan.nextLine();\n        msg=Thread.currentThread().getName()+&quot;:&quot;+msg;\n        try  &#123;\n            os.write(msg.getBytes());\n            os.flush();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>}</p>","categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"}]}