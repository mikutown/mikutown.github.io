{"title":"leetcode522.最长特殊序列II","slug":"leetcode522-最长特殊序列II","date":"2023-08-31T01:22:21.000Z","updated":"2023-08-31T01:28:34.393Z","comments":true,"path":"api/articles/leetcode522-最长特殊序列II.json","excerpt":"题目给定字符串列表 strs ，返回其中 最长的特殊序列 的长度。如果最长特殊序列不存在，返回 -1 。特殊序列 定义如下：该序列为某字符串 独有的子序列（即不能是其他字符串的子序列）。 s 的 子序列可以通过删去字符串 s 中的某些字符实现。例如，&quot;abc&quot; 是 &quot;aebdc&quot; 的子序列，因为您可以删除&quot;aebdc&quot;中的下划线字符来得到 &quot;abc&quot; 。&quot;aebdc&quot;的子序列还包括&quot;aebdc&quot;、 &quot;aeb&quot; 和 “” (空字符串)。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定字符串列表 <code>strs</code> ，返回其中 <strong>最长的特殊序列</strong> 的长度。如果最长特殊序列不存在，返回 <code>-1</code> 。</p>\n<p><strong>特殊序列</strong> 定义如下：该序列为某字符串 <strong>独有的子序列（即不能是其他字符串的子序列）</strong>。</p>\n<p> <code>s</code> 的 <strong>子序列</strong>可以通过删去字符串 <code>s</code> 中的某些字符实现。</p>\n<ul>\n<li>例如，<code>&quot;abc&quot;</code> 是 <code>&quot;aebdc&quot;</code> 的子序列，因为您可以删除<code>&quot;aebdc&quot;</code>中的下划线字符来得到 <code>&quot;abc&quot;</code> 。<code>&quot;aebdc&quot;</code>的子序列还包括<code>&quot;aebdc&quot;</code>、 <code>&quot;aeb&quot;</code> 和 “” (空字符串)。</li>\n</ul>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: strs &#x3D; [&quot;aba&quot;,&quot;cdc&quot;,&quot;eae&quot;]\n输出: 3</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: strs &#x3D; [&quot;aaa&quot;,&quot;aaa&quot;,&quot;aa&quot;]\n输出: -1</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>2 &lt;= strs.length &lt;= 50</code></li>\n<li><code>1 &lt;= strs[i].length &lt;= 10</code></li>\n<li><code>strs[i]</code> 只包含小写英文字母</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路：</p>\n<ol>\n<li>首先，我们需要对字符串数组进行排序，将较长的字符串排在前面。这是因为如果一个字符串是另一个字符串的子序列，那么较长的字符串必定不能成为特殊序列。</li>\n<li>排序之后，我们遍历每个字符串，判断它是否是特殊序列。我们需要检查当前字符串是否在剩余的字符串中存在子序列。</li>\n<li>对于每个字符串，我们逐个比较它与剩余字符串的关系。如果当前字符串不是任何其他字符串的子序列，那么它就是一个特殊序列。</li>\n<li>我们只需要返回最长的特殊序列的长度即可。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; 判断字符串a是否是字符串b的子序列\n    bool isSubsequence(const string&amp; a, const string&amp; b) &#123;\n        int i &#x3D; 0, j &#x3D; 0;\n        while (i &lt; a.size() &amp;&amp; j &lt; b.size()) &#123;\n            if (a[i] &#x3D;&#x3D; b[j]) &#123;\n                i++;\n            &#125;\n            j++;\n        &#125;\n        return i &#x3D;&#x3D; a.size();\n    &#125;\n\n    &#x2F;&#x2F; 找到最长特殊序列的长度\n    int findLUSlength(vector&lt;string&gt;&amp; strs) &#123;\n        &#x2F;&#x2F; 根据字符串长度排序，较长的字符串排在前面\n        sort(strs.begin(), strs.end(), [](const string&amp; a, const string&amp; b) &#123;\n            return a.size() &gt; b.size();\n        &#125;);\n\n        for (int i &#x3D; 0; i &lt; strs.size(); ++i) &#123;\n            bool is_special &#x3D; true;\n            for (int j &#x3D; 0; j &lt; strs.size(); ++j) &#123;\n                if (i !&#x3D; j &amp;&amp; isSubsequence(strs[i], strs[j])) &#123;\n                    is_special &#x3D; false;\n                    break;\n                &#125;\n            &#125;\n            if (is_special) &#123;\n                return strs[i].size();\n            &#125;\n        &#125;\n        \n        return -1;\n    &#125;\n\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: strs &#x3D; [&quot;aba&quot;,&quot;cdc&quot;,&quot;eae&quot;]\n输出: 3</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: strs &#x3D; [&quot;aaa&quot;,&quot;aaa&quot;,&quot;aa&quot;]\n输出: -1</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>2 &lt;= strs.length &lt;= 50</code></li>\n<li><code>1 &lt;= strs[i].length &lt;= 10</code></li>\n<li><code>strs[i]</code> 只包含小写英文字母</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路：</p>\n<ol>\n<li>首先，我们需要对字符串数组进行排序，将较长的字符串排在前面。这是因为如果一个字符串是另一个字符串的子序列，那么较长的字符串必定不能成为特殊序列。</li>\n<li>排序之后，我们遍历每个字符串，判断它是否是特殊序列。我们需要检查当前字符串是否在剩余的字符串中存在子序列。</li>\n<li>对于每个字符串，我们逐个比较它与剩余字符串的关系。如果当前字符串不是任何其他字符串的子序列，那么它就是一个特殊序列。</li>\n<li>我们只需要返回最长的特殊序列的长度即可。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; 判断字符串a是否是字符串b的子序列\n    bool isSubsequence(const string&amp; a, const string&amp; b) &#123;\n        int i &#x3D; 0, j &#x3D; 0;\n        while (i &lt; a.size() &amp;&amp; j &lt; b.size()) &#123;\n            if (a[i] &#x3D;&#x3D; b[j]) &#123;\n                i++;\n            &#125;\n            j++;\n        &#125;\n        return i &#x3D;&#x3D; a.size();\n    &#125;\n\n    &#x2F;&#x2F; 找到最长特殊序列的长度\n    int findLUSlength(vector&lt;string&gt;&amp; strs) &#123;\n        &#x2F;&#x2F; 根据字符串长度排序，较长的字符串排在前面\n        sort(strs.begin(), strs.end(), [](const string&amp; a, const string&amp; b) &#123;\n            return a.size() &gt; b.size();\n        &#125;);\n\n        for (int i &#x3D; 0; i &lt; strs.size(); ++i) &#123;\n            bool is_special &#x3D; true;\n            for (int j &#x3D; 0; j &lt; strs.size(); ++j) &#123;\n                if (i !&#x3D; j &amp;&amp; isSubsequence(strs[i], strs[j])) &#123;\n                    is_special &#x3D; false;\n                    break;\n                &#125;\n            &#125;\n            if (is_special) &#123;\n                return strs[i].size();\n            &#125;\n        &#125;\n        \n        return -1;\n    &#125;\n\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"序列","path":"api/tags/序列.json"}]}