{"title":"leetcode40.组合总和II","slug":"leetcode40-组合总和II","date":"2023-10-12T10:59:31.000Z","updated":"2023-10-12T11:10:39.787Z","comments":true,"path":"api/articles/leetcode40-组合总和II.json","excerpt":"题目给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用 一次 。注意：解集不能包含重复的组合。 ","covers":["http://cdn.leafii.top/img/20230310000918.png","http://cdn.leafii.top/img/20230310000954.png","http://cdn.leafii.top/img/20221021163812.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>\n<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>\n<p><strong>注意：</strong>解集不能包含重复的组合。 </p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,\n输出:\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,\n输出:\n[\n[1,2,2],\n[5]\n]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= candidates.length &lt;= 100</code></li>\n<li><code>1 &lt;= candidates[i] &lt;= 50</code></li>\n<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>这道题目和39.组合总和有如下区别：</p>\n<ol>\n<li>本题candidates 中的每个数字在每个组合中只能使用一次。</li>\n<li>本题数组candidates的元素是有重复的，而39是无重复元素的数组candidates</li>\n</ol>\n<p>最后本题和39要求一样，解集不能包含重复的组合。</p>\n<p><strong>本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p>\n<p><img src=\"http://cdn.leafii.top/img/20230310000918.png\" alt=\"40.组合总和II\" loading=\"lazy\"></p>\n<p>同一树层上的两个重复元素不可以重新选取，使用used数组用来记录同一树枝上的元素是否使用过。</p>\n<ul>\n<li>递归函数参数</li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> result<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 存放组合集合</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> path<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 符合条件的组合</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> candidates<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> sum<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> startIndex<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> used<span class=\"token punctuation\">)</span></code></pre>\n\n<ul>\n<li>递归终止条件</li>\n</ul>\n<p><code>sum &gt; target</code> 和 <code>sum == target</code></p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 这个条件其实可以省略</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<ul>\n<li>单层搜索的逻辑</li>\n</ul>\n<p>要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。</p>\n<p>**如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。</p>\n<p>此时for循环里就应该做continue的操作。</p>\n<p><img src=\"http://cdn.leafii.top/img/20230310000954.png\" alt=\"40.组合总和II1\" loading=\"lazy\"></p>\n<p>我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</p>\n<ul>\n<li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li>\n<li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li>\n</ul>\n<p><img src=\"http://cdn.leafii.top/img/20221021163812.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>那么单层搜索的逻辑代码如下：</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> startIndex<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> candidates<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> sum <span class=\"token operator\">+</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> target<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span>\n    <span class=\"token comment\">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span>\n    <span class=\"token comment\">// 要对同一树层使用过的元素进行跳过</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> candidates<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> used<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    sum <span class=\"token operator\">+=</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    used<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">,</span> sum<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> used<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span>\n    used<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    sum <span class=\"token operator\">-=</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">pop_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>最终得到的整体代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; result;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) &#123;\n        if (sum &#x3D;&#x3D; target) &#123;\n            result.push_back(path);\n            return;\n        &#125;\n        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target; i++) &#123;\n            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过\n            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过\n            &#x2F;&#x2F; 要对同一树层使用过的元素进行跳过\n            if (i &gt; 0 &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;\n                continue;\n            &#125;\n            sum +&#x3D; candidates[i];\n            path.push_back(candidates[i]);\n            used[i] &#x3D; true;\n            backtracking(candidates, target, sum, i + 1, used); &#x2F;&#x2F; 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次\n            used[i] &#x3D; false;\n            sum -&#x3D; candidates[i];\n            path.pop_back();\n        &#125;\n    &#125;\n\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        vector&lt;bool&gt; used(candidates.size(), false);\n        path.clear();\n        result.clear();\n        &#x2F;&#x2F; 首先把给candidates排序，让其相同的元素都挨在一起。\n        sort(candidates.begin(), candidates.end());\n        backtracking(candidates, target, 0, 0, used);\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,\n输出:\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,\n输出:\n[\n[1,2,2],\n[5]\n]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= candidates.length &lt;= 100</code></li>\n<li><code>1 &lt;= candidates[i] &lt;= 50</code></li>\n<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>这道题目和39.组合总和有如下区别：</p>\n<ol>\n<li>本题candidates 中的每个数字在每个组合中只能使用一次。</li>\n<li>本题数组candidates的元素是有重复的，而39是无重复元素的数组candidates</li>\n</ol>\n<p>最后本题和39要求一样，解集不能包含重复的组合。</p>\n<p><strong>本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p>\n<p><img src=\"http://cdn.leafii.top/img/20230310000918.png\" alt=\"40.组合总和II\"></p>\n<p>同一树层上的两个重复元素不可以重新选取，使用used数组用来记录同一树枝上的元素是否使用过。</p>\n<ul>\n<li>递归函数参数</li>\n</ul>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> result<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 存放组合集合</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> path<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 符合条件的组合</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> candidates<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> sum<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> startIndex<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> used<span class=\"token punctuation\">)</span></code></pre>\n\n<ul>\n<li>递归终止条件</li>\n</ul>\n<p><code>sum &gt; target</code> 和 <code>sum == target</code></p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 这个条件其实可以省略</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<ul>\n<li>单层搜索的逻辑</li>\n</ul>\n<p>要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。</p>\n<p>**如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。</p>\n<p>此时for循环里就应该做continue的操作。</p>\n<p><img src=\"http://cdn.leafii.top/img/20230310000954.png\" alt=\"40.组合总和II1\"></p>\n<p>我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</p>\n<ul>\n<li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li>\n<li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li>\n</ul>\n<p><img src=\"http://cdn.leafii.top/img/20221021163812.png\" alt=\"img\"></p>\n<p>那么单层搜索的逻辑代码如下：</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> startIndex<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> candidates<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> sum <span class=\"token operator\">+</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> target<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span>\n    <span class=\"token comment\">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span>\n    <span class=\"token comment\">// 要对同一树层使用过的元素进行跳过</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> candidates<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> used<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    sum <span class=\"token operator\">+=</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    used<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">,</span> sum<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> used<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span>\n    used<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    sum <span class=\"token operator\">-=</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">pop_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>最终得到的整体代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; result;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) &#123;\n        if (sum &#x3D;&#x3D; target) &#123;\n            result.push_back(path);\n            return;\n        &#125;\n        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target; i++) &#123;\n            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过\n            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过\n            &#x2F;&#x2F; 要对同一树层使用过的元素进行跳过\n            if (i &gt; 0 &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;\n                continue;\n            &#125;\n            sum +&#x3D; candidates[i];\n            path.push_back(candidates[i]);\n            used[i] &#x3D; true;\n            backtracking(candidates, target, sum, i + 1, used); &#x2F;&#x2F; 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次\n            used[i] &#x3D; false;\n            sum -&#x3D; candidates[i];\n            path.pop_back();\n        &#125;\n    &#125;\n\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        vector&lt;bool&gt; used(candidates.size(), false);\n        path.clear();\n        result.clear();\n        &#x2F;&#x2F; 首先把给candidates排序，让其相同的元素都挨在一起。\n        sort(candidates.begin(), candidates.end());\n        backtracking(candidates, target, 0, 0, used);\n        return result;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}