{"title":"leetcode84.柱状图中最大的矩形","slug":"leetcode84-柱状图中最大的矩形","date":"2023-05-12T09:43:04.000Z","updated":"2023-05-12T09:46:16.438Z","comments":true,"path":"api/articles/leetcode84-柱状图中最大的矩形.json","excerpt":"题目给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。","covers":["http://cdn.leafii.top/img/histogram.jpg","http://cdn.leafii.top/img/histogram-1.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/histogram.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：heights &#x3D; [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/histogram-1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入： heights &#x3D; [2,4]\n输出： 4</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= heights.length &lt;=105</code></li>\n<li><code>0 &lt;= heights[i] &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路：</p>\n<ol>\n<li>遍历给定的柱状图高度数组 <code>heights</code>，依次处理每个柱子。</li>\n<li>使用一个栈来保存递增序列的索引。栈中的索引对应的柱子高度是递增的。</li>\n<li>对于每个柱子，如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界。</li>\n<li>弹出栈顶元素，并计算以栈顶元素为高度的矩形的面积。面积的宽度可以通过当前索引和新的栈顶元素索引之间的距离计算得到。</li>\n<li>更新最大面积值。</li>\n<li>将当前索引入栈，继续下一个柱子的处理。</li>\n<li>遍历完所有柱子后，栈中剩余的索引对应的柱子高度没有右边界，因此以这些柱子高度计算的矩形面积可以直接得到。</li>\n<li>返回最大面积值。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;stack&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;\n    int n &#x3D; heights.size();\n    stack&lt;int&gt; st; &#x2F;&#x2F; 使用栈来保存递增序列的索引\n    int maxArea &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n        &#x2F;&#x2F; 如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界\n        &#x2F;&#x2F; 计算以栈顶元素为高度的矩形的面积，并更新最大面积\n        while (!st.empty() &amp;&amp; (i &#x3D;&#x3D; n || heights[i] &lt; heights[st.top()])) &#123;\n            int h &#x3D; heights[st.top()];\n            st.pop();\n            int w &#x3D; st.empty() ? i : (i - st.top() - 1);\n            maxArea &#x3D; max(maxArea, h * w);\n        &#125;\n\n        &#x2F;&#x2F; 将当前索引入栈\n        st.push(i);\n    &#125;\n\n    return maxArea;\n&#125;\n\nint main() &#123;\n    vector&lt;int&gt; heights &#x3D; &#123;2, 1, 5, 6, 2, 3&#125;;\n    int maxArea &#x3D; largestRectangleArea(heights);\n    cout &lt;&lt; &quot;最大矩形的面积为：&quot; &lt;&lt; maxArea &lt;&lt; endl;\n    return 0;\n&#125;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/histogram.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：heights &#x3D; [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/histogram-1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入： heights &#x3D; [2,4]\n输出： 4</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= heights.length &lt;=105</code></li>\n<li><code>0 &lt;= heights[i] &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路：</p>\n<ol>\n<li>遍历给定的柱状图高度数组 <code>heights</code>，依次处理每个柱子。</li>\n<li>使用一个栈来保存递增序列的索引。栈中的索引对应的柱子高度是递增的。</li>\n<li>对于每个柱子，如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界。</li>\n<li>弹出栈顶元素，并计算以栈顶元素为高度的矩形的面积。面积的宽度可以通过当前索引和新的栈顶元素索引之间的距离计算得到。</li>\n<li>更新最大面积值。</li>\n<li>将当前索引入栈，继续下一个柱子的处理。</li>\n<li>遍历完所有柱子后，栈中剩余的索引对应的柱子高度没有右边界，因此以这些柱子高度计算的矩形面积可以直接得到。</li>\n<li>返回最大面积值。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;stack&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;\n    int n &#x3D; heights.size();\n    stack&lt;int&gt; st; &#x2F;&#x2F; 使用栈来保存递增序列的索引\n    int maxArea &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n        &#x2F;&#x2F; 如果当前高度小于栈顶元素对应的高度，说明找到了栈顶元素的右边界\n        &#x2F;&#x2F; 计算以栈顶元素为高度的矩形的面积，并更新最大面积\n        while (!st.empty() &amp;&amp; (i &#x3D;&#x3D; n || heights[i] &lt; heights[st.top()])) &#123;\n            int h &#x3D; heights[st.top()];\n            st.pop();\n            int w &#x3D; st.empty() ? i : (i - st.top() - 1);\n            maxArea &#x3D; max(maxArea, h * w);\n        &#125;\n\n        &#x2F;&#x2F; 将当前索引入栈\n        st.push(i);\n    &#125;\n\n    return maxArea;\n&#125;\n\nint main() &#123;\n    vector&lt;int&gt; heights &#x3D; &#123;2, 1, 5, 6, 2, 3&#125;;\n    int maxArea &#x3D; largestRectangleArea(heights);\n    cout &lt;&lt; &quot;最大矩形的面积为：&quot; &lt;&lt; maxArea &lt;&lt; endl;\n    return 0;\n&#125;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}