{"title":"leetcode:70.爬楼梯","slug":"leetcode-70-爬楼梯","date":"2023-02-01T06:48:43.000Z","updated":"2023-02-01T07:19:51.622Z","comments":true,"path":"api/articles/leetcode-70-爬楼梯.json","excerpt":null,"covers":["http://cdn.leafii.top/img/70_fig1.gif"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>递归</li>\n</ol>\n<p>很明显，该问题可以用$f(x) &#x3D; f(x - 1) + f(x - 2)$并且很容易得知$f(0) &#x3D; 1;f(1) &#x3D; 1;f(2) &#x3D; 2$,但是直接写递归(<code>return climbStairs(n - 1) + climbStairs(n - 2)</code>)会导致时间超限，在这里使用「滚动数组思想」把空间复杂度优化成 $O(1)$。</p>\n<p><img src=\"http://cdn.leafii.top/img/70_fig1.gif\" alt=\"fig1\" loading=\"lazy\"></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int climbStairs(int n) &#123;\n        int p &#x3D; 0, q &#x3D; 0, r &#x3D; 1;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;\n            p &#x3D; q; \n            q &#x3D; r; \n            r &#x3D; p + q;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>力扣官方题解：<a href=\"https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/\">https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/</a> </p>\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>递归</li>\n</ol>\n<p>很明显，该问题可以用$f(x) &#x3D; f(x - 1) + f(x - 2)$并且很容易得知$f(0) &#x3D; 1;f(1) &#x3D; 1;f(2) &#x3D; 2$,但是直接写递归(<code>return climbStairs(n - 1) + climbStairs(n - 2)</code>)会导致时间超限，在这里使用「滚动数组思想」把空间复杂度优化成 $O(1)$。</p>\n<p><img src=\"http://cdn.leafii.top/img/70_fig1.gif\" alt=\"fig1\"></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int climbStairs(int n) &#123;\n        int p &#x3D; 0, q &#x3D; 0, r &#x3D; 1;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;\n            p &#x3D; q; \n            q &#x3D; r; \n            r &#x3D; p + q;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>力扣官方题解：<a href=\"https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/\">https://leetcode.cn/problems/climbing-stairs/solutions/286022/pa-lou-ti-by-leetcode-solution/</a> </p>\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}