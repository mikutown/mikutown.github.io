{"title":"leetcode:23.合并K个升序链表","slug":"leetcode-23-合并K个升序链表","date":"2023-01-12T09:23:49.000Z","updated":"2023-01-12T09:25:45.046Z","comments":true,"path":"api/articles/leetcode-23-合并K个升序链表.json","excerpt":"题目给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p>\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; [[]]\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>k == lists.length</code></li>\n<li><code>0 &lt;= k &lt;= 10^4</code></li>\n<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>写一个可以合并两个有序链表的函数，然后对传入的list进行遍历，将list的两个元素两两合并，最后返回头结点。实现代码如下：</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;合并两个有序链表\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)\n    &#123;\n        ListNode* head &#x3D; nullptr;\n        ListNode* curNode &#x3D; nullptr;\n        ListNode** temp &#x3D; nullptr;\n        bool isFirst &#x3D; true;\n\n        while(list1 !&#x3D; nullptr &amp;&amp; list2 !&#x3D; nullptr)\n        &#123;\n            temp &#x3D; (list1 -&gt; val &lt; list2 -&gt; val)? &amp;list1:&amp;list2; &#x2F;&#x2F;使用二级指针，因为temp如果是一级指针，那么temp &#x3D; temp-&gt;next;是无法改变list1和list2的值的，而二级指针可以间接改变list1和list2的地址。\n            if(isFirst)\n            &#123;\n                head &#x3D; *temp;\n                curNode &#x3D; *temp;\n                isFirst &#x3D; false;\n            &#125;\n            else\n            &#123;\n                curNode -&gt; next &#x3D; *temp;\n                curNode &#x3D; curNode -&gt; next;\n            &#125;\n\n            *temp &#x3D; (*temp) -&gt; next;\n        &#125;\n\n        if(nullptr !&#x3D; list1)\n        &#123;\n            if(isFirst)  &#x2F;&#x2F;有一方链表为空\n            &#123;\n                head &#x3D; list1;\n            &#125;\n            else         &#x2F;&#x2F;剩下结点直接补齐\n            &#123;\n                curNode -&gt; next &#x3D; list1;\n            &#125;\n        &#125;\n\n        if(nullptr !&#x3D; list2)\n        &#123;\n            if(isFirst)\n            &#123;\n                head &#x3D; list2;\n            &#125;\n            else\n            &#123;\n                curNode-&gt;next &#x3D; list2;\n            &#125;\n        &#125;\n\n        return head;\n    &#125;\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        ListNode* head &#x3D; nullptr;\n        for(int i &#x3D; 0; i &lt; lists.size(); i++)\n        &#123;\n            head &#x3D; mergeTwoLists(head, lists[i]);\n        &#125;\n\n        return head;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; [[]]\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>k == lists.length</code></li>\n<li><code>0 &lt;= k &lt;= 10^4</code></li>\n<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>写一个可以合并两个有序链表的函数，然后对传入的list进行遍历，将list的两个元素两两合并，最后返回头结点。实现代码如下：</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;合并两个有序链表\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)\n    &#123;\n        ListNode* head &#x3D; nullptr;\n        ListNode* curNode &#x3D; nullptr;\n        ListNode** temp &#x3D; nullptr;\n        bool isFirst &#x3D; true;\n\n        while(list1 !&#x3D; nullptr &amp;&amp; list2 !&#x3D; nullptr)\n        &#123;\n            temp &#x3D; (list1 -&gt; val &lt; list2 -&gt; val)? &amp;list1:&amp;list2; &#x2F;&#x2F;使用二级指针，因为temp如果是一级指针，那么temp &#x3D; temp-&gt;next;是无法改变list1和list2的值的，而二级指针可以间接改变list1和list2的地址。\n            if(isFirst)\n            &#123;\n                head &#x3D; *temp;\n                curNode &#x3D; *temp;\n                isFirst &#x3D; false;\n            &#125;\n            else\n            &#123;\n                curNode -&gt; next &#x3D; *temp;\n                curNode &#x3D; curNode -&gt; next;\n            &#125;\n\n            *temp &#x3D; (*temp) -&gt; next;\n        &#125;\n\n        if(nullptr !&#x3D; list1)\n        &#123;\n            if(isFirst)  &#x2F;&#x2F;有一方链表为空\n            &#123;\n                head &#x3D; list1;\n            &#125;\n            else         &#x2F;&#x2F;剩下结点直接补齐\n            &#123;\n                curNode -&gt; next &#x3D; list1;\n            &#125;\n        &#125;\n\n        if(nullptr !&#x3D; list2)\n        &#123;\n            if(isFirst)\n            &#123;\n                head &#x3D; list2;\n            &#125;\n            else\n            &#123;\n                curNode-&gt;next &#x3D; list2;\n            &#125;\n        &#125;\n\n        return head;\n    &#125;\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        ListNode* head &#x3D; nullptr;\n        for(int i &#x3D; 0; i &lt; lists.size(); i++)\n        &#123;\n            head &#x3D; mergeTwoLists(head, lists[i]);\n        &#125;\n\n        return head;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}