{"title":"leetcode:23.合并K个升序链表","slug":"leetcode-23-合并K个升序链表","date":"2023-01-12T09:23:49.000Z","updated":"2023-03-06T07:18:16.153Z","comments":true,"path":"api/articles/leetcode-23-合并K个升序链表.json","excerpt":"题目给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p>\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; [[]]\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>k == lists.length</code></li>\n<li><code>0 &lt;= k &lt;= 10^4</code></li>\n<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>归并排序(使用单指针)</li>\n</ol>\n<p>在mergeTwoLists函数中，使用了一个虚拟头节点，将其next指向合并后的链表头节点，然后不断更新cur指针的值，使其指向合并后的链表的最后一个节点，最后返回虚拟头节点的next即可。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F; 合并 两个有序链表\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;\n        ListNode* temp1 &#x3D; list1;\n        ListNode* temp2 &#x3D; list2;\n        ListNode* newHead &#x3D; new ListNode(); &#x2F;&#x2F; 虚拟头节点\n        ListNode* cur &#x3D; newHead;\n        while (temp1 !&#x3D; NULL &amp;&amp; temp2 !&#x3D; NULL) &#123;\n            if (temp1-&gt;val &lt; temp2-&gt;val) &#123;\n                cur-&gt;next &#x3D; temp1;\n                temp1 &#x3D; temp1-&gt;next;\n            &#125;\n            else &#123;\n                cur-&gt;next &#x3D; temp2;\n                temp2 &#x3D; temp2-&gt;next;\n            &#125;\n            cur &#x3D; cur-&gt;next; &#x2F;&#x2F; 更新cur指针的值\n        &#125;\n        if (temp1 !&#x3D; NULL) &#123;\n            cur-&gt;next &#x3D; temp1;\n            \n        &#125;\n        if (temp2 !&#x3D; NULL) &#123;\n            cur-&gt;next &#x3D; temp2;\n            \n        &#125;\n        return newHead-&gt;next;\n    &#125;\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        ListNode* head &#x3D; nullptr;\n        for (int i &#x3D; 0; i &lt; lists.size(); i++) &#123;\n            head &#x3D; mergeTwoLists(head, lists[i]);\n        &#125;\n        return head;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>归并排序（使用二级指针实现）</li>\n</ol>\n<p>在mergeTwoLists函数中，使用了一个curNode指针指向合并后的链表，使用了一个二级指针temp，根据list1和list2的值大小，让temp指向较小的那个节点，然后将其插入到curNode之后，并更新curNode指向插入后的链表最后一个节点。最后，如果还有剩余节点，将其直接补充到合并后的链表尾部。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;合并两个有序链表\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)\n    &#123;\n        ListNode* head &#x3D; nullptr;\n        ListNode* curNode &#x3D; nullptr;\n        ListNode** temp &#x3D; nullptr;\n        bool isFirst &#x3D; true;\n\n        while(list1 !&#x3D; nullptr &amp;&amp; list2 !&#x3D; nullptr)\n        &#123;\n            temp &#x3D; (list1 -&gt; val &lt; list2 -&gt; val)? &amp;list1:&amp;list2; &#x2F;&#x2F;使用二级指针，因为temp如果是一级指针，那么temp &#x3D; temp-&gt;next;是无法改变list1和list2的值的，而二级指针可以间接改变list1和list2的地址。\n            if(isFirst)\n            &#123;\n                head &#x3D; *temp;\n                curNode &#x3D; *temp;\n                isFirst &#x3D; false;\n            &#125;\n            else\n            &#123;\n                curNode -&gt; next &#x3D; *temp;\n                curNode &#x3D; curNode -&gt; next;\n            &#125;\n\n            *temp &#x3D; (*temp) -&gt; next;\n        &#125;\n\n        if(nullptr !&#x3D; list1)\n        &#123;\n            if(isFirst)  &#x2F;&#x2F;有一方链表为空\n            &#123;\n                head &#x3D; list1;\n            &#125;\n            else         &#x2F;&#x2F;剩下结点直接补齐\n            &#123;\n                curNode -&gt; next &#x3D; list1;\n            &#125;\n        &#125;\n\n        if(nullptr !&#x3D; list2)\n        &#123;\n            if(isFirst)\n            &#123;\n                head &#x3D; list2;\n            &#125;\n            else\n            &#123;\n                curNode-&gt;next &#x3D; list2;\n            &#125;\n        &#125;\n\n        return head;\n    &#125;\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        ListNode* head &#x3D; nullptr;\n        for(int i &#x3D; 0; i &lt; lists.size(); i++)\n        &#123;\n            head &#x3D; mergeTwoLists(head, lists[i]);\n        &#125;\n\n        return head;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li>使用优先队列</li>\n</ol>\n<p>可以将所有的链表的首节点放入一个小根堆中，每次从堆中取出最小节点，将该节点接入最终链表，并将该节点的下一个节点加入堆中。重复该过程直到堆为空。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        &#x2F;&#x2F;如果传进来的链表为空，直接返回空指针。\n        if(lists.empty()) &#123;\n            return nullptr;\n        &#125;\n\n        &#x2F;&#x2F;定义一个优先队列，该队列将所有链表的头结点按照节点的值从小到大排列。\n        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq;\n        &#x2F;&#x2F;定义一个虚拟头结点和一个当前节点cur。\n        ListNode dummy(0);\n        ListNode* cur &#x3D; &amp;dummy;\n\n        &#x2F;&#x2F;将所有链表的头结点加入到优先队列中。\n        for(auto&amp; node: lists) &#123;\n            if(node) &#123;\n                pq.push(node);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;每次取出队列中的最小值，将该节点加入到合并后的链表中，并将该节点的下一个节点加入到队列中。\n        while(!pq.empty()) &#123;\n            auto temp &#x3D; pq.top();\n            pq.pop();\n\n            cur-&gt;next &#x3D; temp;\n            cur &#x3D; cur-&gt;next;\n\n            if(temp-&gt;next) &#123;\n                pq.push(temp-&gt;next);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;返回合并后的链表。\n        return dummy.next;\n    &#125;\n\nprivate:\n    &#x2F;&#x2F;自定义比较函数，用于优先队列。 保证队尾元素最大\n    struct cmp &#123;\n        bool operator() (const ListNode* a, const ListNode* b) &#123;\n            return a-&gt;val &gt; b-&gt;val;\n        &#125;\n    &#125;;\n&#125;;\n</code></pre>\n\n<p>请注意优先队列的定义方式：</p>\n<blockquote>\n<p><code>priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq</code> 是一个定义了一个<code>priority_queue</code>对象<code>pq</code>，其中包含三个参数：</p>\n<ol>\n<li><code>ListNode*</code> 是存储在堆中的元素的类型，即堆元素的指针类型为<code>ListNode*</code>；</li>\n<li><code>vector&lt;ListNode*&gt;</code> 是底层容器类型，即使用<code>vector</code>来实现堆；</li>\n<li><code>cmp</code> 是比较函数，用于堆中元素的排序方式。</li>\n</ol>\n<p>根据这个定义，我们可以理解<code>priority_queue</code>的工作原理：它是一个基于堆的数据结构，其中的元素按照指定的比较函数<code>cmp</code>进行排序。<code>priority_queue</code>是一个可以高效获取最大（或最小）元素的容器，因此常常被用来实现一些需要对元素进行优先级处理的算法。</p>\n</blockquote>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：lists &#x3D; [[]]\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>k == lists.length</code></li>\n<li><code>0 &lt;= k &lt;= 10^4</code></li>\n<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>归并排序(使用单指针)</li>\n</ol>\n<p>在mergeTwoLists函数中，使用了一个虚拟头节点，将其next指向合并后的链表头节点，然后不断更新cur指针的值，使其指向合并后的链表的最后一个节点，最后返回虚拟头节点的next即可。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F; 合并 两个有序链表\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;\n        ListNode* temp1 &#x3D; list1;\n        ListNode* temp2 &#x3D; list2;\n        ListNode* newHead &#x3D; new ListNode(); &#x2F;&#x2F; 虚拟头节点\n        ListNode* cur &#x3D; newHead;\n        while (temp1 !&#x3D; NULL &amp;&amp; temp2 !&#x3D; NULL) &#123;\n            if (temp1-&gt;val &lt; temp2-&gt;val) &#123;\n                cur-&gt;next &#x3D; temp1;\n                temp1 &#x3D; temp1-&gt;next;\n            &#125;\n            else &#123;\n                cur-&gt;next &#x3D; temp2;\n                temp2 &#x3D; temp2-&gt;next;\n            &#125;\n            cur &#x3D; cur-&gt;next; &#x2F;&#x2F; 更新cur指针的值\n        &#125;\n        if (temp1 !&#x3D; NULL) &#123;\n            cur-&gt;next &#x3D; temp1;\n            \n        &#125;\n        if (temp2 !&#x3D; NULL) &#123;\n            cur-&gt;next &#x3D; temp2;\n            \n        &#125;\n        return newHead-&gt;next;\n    &#125;\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        ListNode* head &#x3D; nullptr;\n        for (int i &#x3D; 0; i &lt; lists.size(); i++) &#123;\n            head &#x3D; mergeTwoLists(head, lists[i]);\n        &#125;\n        return head;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>归并排序（使用二级指针实现）</li>\n</ol>\n<p>在mergeTwoLists函数中，使用了一个curNode指针指向合并后的链表，使用了一个二级指针temp，根据list1和list2的值大小，让temp指向较小的那个节点，然后将其插入到curNode之后，并更新curNode指向插入后的链表最后一个节点。最后，如果还有剩余节点，将其直接补充到合并后的链表尾部。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;合并两个有序链表\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2)\n    &#123;\n        ListNode* head &#x3D; nullptr;\n        ListNode* curNode &#x3D; nullptr;\n        ListNode** temp &#x3D; nullptr;\n        bool isFirst &#x3D; true;\n\n        while(list1 !&#x3D; nullptr &amp;&amp; list2 !&#x3D; nullptr)\n        &#123;\n            temp &#x3D; (list1 -&gt; val &lt; list2 -&gt; val)? &amp;list1:&amp;list2; &#x2F;&#x2F;使用二级指针，因为temp如果是一级指针，那么temp &#x3D; temp-&gt;next;是无法改变list1和list2的值的，而二级指针可以间接改变list1和list2的地址。\n            if(isFirst)\n            &#123;\n                head &#x3D; *temp;\n                curNode &#x3D; *temp;\n                isFirst &#x3D; false;\n            &#125;\n            else\n            &#123;\n                curNode -&gt; next &#x3D; *temp;\n                curNode &#x3D; curNode -&gt; next;\n            &#125;\n\n            *temp &#x3D; (*temp) -&gt; next;\n        &#125;\n\n        if(nullptr !&#x3D; list1)\n        &#123;\n            if(isFirst)  &#x2F;&#x2F;有一方链表为空\n            &#123;\n                head &#x3D; list1;\n            &#125;\n            else         &#x2F;&#x2F;剩下结点直接补齐\n            &#123;\n                curNode -&gt; next &#x3D; list1;\n            &#125;\n        &#125;\n\n        if(nullptr !&#x3D; list2)\n        &#123;\n            if(isFirst)\n            &#123;\n                head &#x3D; list2;\n            &#125;\n            else\n            &#123;\n                curNode-&gt;next &#x3D; list2;\n            &#125;\n        &#125;\n\n        return head;\n    &#125;\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        ListNode* head &#x3D; nullptr;\n        for(int i &#x3D; 0; i &lt; lists.size(); i++)\n        &#123;\n            head &#x3D; mergeTwoLists(head, lists[i]);\n        &#125;\n\n        return head;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li>使用优先队列</li>\n</ol>\n<p>可以将所有的链表的首节点放入一个小根堆中，每次从堆中取出最小节点，将该节点接入最终链表，并将该节点的下一个节点加入堆中。重复该过程直到堆为空。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        &#x2F;&#x2F;如果传进来的链表为空，直接返回空指针。\n        if(lists.empty()) &#123;\n            return nullptr;\n        &#125;\n\n        &#x2F;&#x2F;定义一个优先队列，该队列将所有链表的头结点按照节点的值从小到大排列。\n        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq;\n        &#x2F;&#x2F;定义一个虚拟头结点和一个当前节点cur。\n        ListNode dummy(0);\n        ListNode* cur &#x3D; &amp;dummy;\n\n        &#x2F;&#x2F;将所有链表的头结点加入到优先队列中。\n        for(auto&amp; node: lists) &#123;\n            if(node) &#123;\n                pq.push(node);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;每次取出队列中的最小值，将该节点加入到合并后的链表中，并将该节点的下一个节点加入到队列中。\n        while(!pq.empty()) &#123;\n            auto temp &#x3D; pq.top();\n            pq.pop();\n\n            cur-&gt;next &#x3D; temp;\n            cur &#x3D; cur-&gt;next;\n\n            if(temp-&gt;next) &#123;\n                pq.push(temp-&gt;next);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;返回合并后的链表。\n        return dummy.next;\n    &#125;\n\nprivate:\n    &#x2F;&#x2F;自定义比较函数，用于优先队列。 保证队尾元素最大\n    struct cmp &#123;\n        bool operator() (const ListNode* a, const ListNode* b) &#123;\n            return a-&gt;val &gt; b-&gt;val;\n        &#125;\n    &#125;;\n&#125;;\n</code></pre>\n\n<p>请注意优先队列的定义方式：</p>\n<blockquote>\n<p><code>priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq</code> 是一个定义了一个<code>priority_queue</code>对象<code>pq</code>，其中包含三个参数：</p>\n<ol>\n<li><code>ListNode*</code> 是存储在堆中的元素的类型，即堆元素的指针类型为<code>ListNode*</code>；</li>\n<li><code>vector&lt;ListNode*&gt;</code> 是底层容器类型，即使用<code>vector</code>来实现堆；</li>\n<li><code>cmp</code> 是比较函数，用于堆中元素的排序方式。</li>\n</ol>\n<p>根据这个定义，我们可以理解<code>priority_queue</code>的工作原理：它是一个基于堆的数据结构，其中的元素按照指定的比较函数<code>cmp</code>进行排序。<code>priority_queue</code>是一个可以高效获取最大（或最小）元素的容器，因此常常被用来实现一些需要对元素进行优先级处理的算法。</p>\n</blockquote>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}