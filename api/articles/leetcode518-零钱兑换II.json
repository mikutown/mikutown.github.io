{"title":"leetcode518.零钱兑换II","slug":"leetcode518-零钱兑换II","date":"2023-05-23T11:02:09.000Z","updated":"2023-05-23T11:04:16.584Z","comments":true,"path":"api/articles/leetcode518-零钱兑换II.json","excerpt":"题目给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>\n<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>\n<p>假设每一种面额的硬币有无限个。 </p>\n<p>题目数据保证结果符合 32 位带符号整数。</p>\n <span id=\"more\"></span>\n\n\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：amount &#x3D; 5, coins &#x3D; [1, 2, 5]\n输出：4\n解释：有四种方式可以凑成总金额：\n5&#x3D;5\n5&#x3D;2+2+1\n5&#x3D;2+1+1+1\n5&#x3D;1+1+1+1+1</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：amount &#x3D; 3, coins &#x3D; [2]\n输出：0\n解释：只用面额 2 的硬币不能凑成总金额 3 。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：amount &#x3D; 10, coins &#x3D; [10] \n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= coins.length &lt;= 300</code></li>\n<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>\n<li><code>coins</code> 中的所有值 <strong>互不相同</strong></li>\n<li><code>0 &lt;= amount &lt;= 5000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>在这个解答中，我们使用动态规划来解决问题。我们定义一个长度为amount+1的dp数组，其中dp[i]表示凑成金额i所需的硬币组合数。</p>\n<p>我们初始化dp[0]为1，表示凑成金额0的组合数为1（不选择任何硬币）。然后，我们遍历硬币数组coins，对于每个硬币coin，我们从coin遍历到amount，更新dp数组的值。对于每个金额i，我们考虑是否选择硬币coin，如果选择，则组合数增加dp[i-coin]，因为我们只需要找出剩余金额i-coin的组合数即可。</p>\n<p>最终，dp[amount]即为所需的结果，即凑成金额amount的组合数。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;\n        vector&lt;int&gt; dp(amount + 1, 0); &#x2F;&#x2F; 创建长度为amount+1的dp数组，初始值为0\n        dp[0] &#x3D; 1; &#x2F;&#x2F; 凑成金额0的组合数为1（不选择任何硬币）\n        \n        for (int coin : coins) &#123; &#x2F;&#x2F; 遍历硬币数组\n            for (int i &#x3D; coin; i &lt;&#x3D; amount; i++) &#123; &#x2F;&#x2F; 从硬币coin遍历到amount\n                dp[i] +&#x3D; dp[i - coin]; &#x2F;&#x2F; 更新组合数\n            &#125;\n        &#125;\n        \n        return dp[amount]; &#x2F;&#x2F; 返回凑成金额amount的组合数\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：amount &#x3D; 5, coins &#x3D; [1, 2, 5]\n输出：4\n解释：有四种方式可以凑成总金额：\n5&#x3D;5\n5&#x3D;2+2+1\n5&#x3D;2+1+1+1\n5&#x3D;1+1+1+1+1</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：amount &#x3D; 3, coins &#x3D; [2]\n输出：0\n解释：只用面额 2 的硬币不能凑成总金额 3 。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：amount &#x3D; 10, coins &#x3D; [10] \n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= coins.length &lt;= 300</code></li>\n<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>\n<li><code>coins</code> 中的所有值 <strong>互不相同</strong></li>\n<li><code>0 &lt;= amount &lt;= 5000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>在这个解答中，我们使用动态规划来解决问题。我们定义一个长度为amount+1的dp数组，其中dp[i]表示凑成金额i所需的硬币组合数。</p>\n<p>我们初始化dp[0]为1，表示凑成金额0的组合数为1（不选择任何硬币）。然后，我们遍历硬币数组coins，对于每个硬币coin，我们从coin遍历到amount，更新dp数组的值。对于每个金额i，我们考虑是否选择硬币coin，如果选择，则组合数增加dp[i-coin]，因为我们只需要找出剩余金额i-coin的组合数即可。</p>\n<p>最终，dp[amount]即为所需的结果，即凑成金额amount的组合数。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;\n        vector&lt;int&gt; dp(amount + 1, 0); &#x2F;&#x2F; 创建长度为amount+1的dp数组，初始值为0\n        dp[0] &#x3D; 1; &#x2F;&#x2F; 凑成金额0的组合数为1（不选择任何硬币）\n        \n        for (int coin : coins) &#123; &#x2F;&#x2F; 遍历硬币数组\n            for (int i &#x3D; coin; i &lt;&#x3D; amount; i++) &#123; &#x2F;&#x2F; 从硬币coin遍历到amount\n                dp[i] +&#x3D; dp[i - coin]; &#x2F;&#x2F; 更新组合数\n            &#125;\n        &#125;\n        \n        return dp[amount]; &#x2F;&#x2F; 返回凑成金额amount的组合数\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]}