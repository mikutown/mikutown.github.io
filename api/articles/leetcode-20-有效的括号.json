{"title":"leetcode:20.有效的括号","slug":"leetcode-20-有效的括号","date":"2023-01-15T05:24:30.000Z","updated":"2023-01-15T08:01:36.793Z","comments":true,"path":"api/articles/leetcode-20-有效的括号.json","excerpt":"题目给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。每个右括号都有一个对应的相同类型的左括号。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n<li>每个右括号都有一个对应的相同类型的左括号。</li>\n</ol>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;()&quot;\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;\n输出：true</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;(]&quot;\n输出：false</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 104</code></li>\n<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用栈进行左半边括号的存储，遍历字符串，当遇到右半边括号时进行匹配，若是相匹配的括号则继续遍历字符串直到最后一个字符，否则返回false。实现代码如下：</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isValid(string s) &#123;\n        stack&lt;char&gt; sc; &#x2F;&#x2F;创建栈\n        for(char a:s)&#123; &#x2F;&#x2F;遍历并判断，首先判断栈是否为空，\n                       &#x2F;&#x2F;接下来判断两个括号是否匹配。\n            if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;)&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;(&#39;)\n                sc.pop(); &#x2F;&#x2F;匹配成功后将栈内的左括号弹出\n            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;]&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;[&#39;)\n                sc.pop();\n            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;&#125;&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;&#123;&#39;)\n                sc.pop();\n            else \n                sc.push(a); &#x2F;&#x2F;若是左括号，则压入栈内\n        &#125;\n        return sc.empty(); &#x2F;&#x2F;遍历结束后，若栈为空，则返回true\n    &#125;\n&#125;;\n</code></pre>\n\n<ol start=\"2\">\n<li>官方解答</li>\n</ol>\n<p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p>\n<p>我们遍历给定的字符串 sss。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p>\n<p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 sss 无效，返回 False\\text{False}False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p>\n<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 sss 中的所有左括号闭合，返回<code>True</code>，否则返回 <code>False</code>。</p>\n<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 <code>False</code>，省去后续的遍历判断过程。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isValid(string s) &#123;\n        int n &#x3D; s.size();\n        if (n % 2 &#x3D;&#x3D; 1) &#123;\n            return false;\n        &#125;\n\n        unordered_map&lt;char, char&gt; pairs &#x3D; &#123;\n            &#123;&#39;)&#39;, &#39;(&#39;&#125;,\n            &#123;&#39;]&#39;, &#39;[&#39;&#125;,\n            &#123;&#39;&#125;&#39;, &#39;&#123;&#39;&#125;\n        &#125;;\n        stack&lt;char&gt; stk;\n        for (char ch: s) &#123;\n            if (pairs.count(ch)) &#123;\n                if (stk.empty() || stk.top() !&#x3D; pairs[ch]) &#123;\n                    return false;\n                &#125;\n                stk.pop();\n            &#125;\n            else &#123;\n                stk.push(ch);\n            &#125;\n        &#125;\n        return stk.empty();\n    &#125;\n&#125;;</code></pre>\n\n\n\n<p>作者：力扣官方题解<br>链接：<a href=\"https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/\">https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;()&quot;\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;\n输出：true</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;(]&quot;\n输出：false</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 104</code></li>\n<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用栈进行左半边括号的存储，遍历字符串，当遇到右半边括号时进行匹配，若是相匹配的括号则继续遍历字符串直到最后一个字符，否则返回false。实现代码如下：</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isValid(string s) &#123;\n        stack&lt;char&gt; sc; &#x2F;&#x2F;创建栈\n        for(char a:s)&#123; &#x2F;&#x2F;遍历并判断，首先判断栈是否为空，\n                       &#x2F;&#x2F;接下来判断两个括号是否匹配。\n            if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;)&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;(&#39;)\n                sc.pop(); &#x2F;&#x2F;匹配成功后将栈内的左括号弹出\n            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;]&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;[&#39;)\n                sc.pop();\n            else if(sc.size() &amp;&amp; a&#x3D;&#x3D;&#39;&#125;&#39; &amp;&amp; sc.top()&#x3D;&#x3D;&#39;&#123;&#39;)\n                sc.pop();\n            else \n                sc.push(a); &#x2F;&#x2F;若是左括号，则压入栈内\n        &#125;\n        return sc.empty(); &#x2F;&#x2F;遍历结束后，若栈为空，则返回true\n    &#125;\n&#125;;\n</code></pre>\n\n<ol start=\"2\">\n<li>官方解答</li>\n</ol>\n<p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p>\n<p>我们遍历给定的字符串 sss。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p>\n<p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 sss 无效，返回 False\\text{False}False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p>\n<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 sss 中的所有左括号闭合，返回<code>True</code>，否则返回 <code>False</code>。</p>\n<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 <code>False</code>，省去后续的遍历判断过程。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isValid(string s) &#123;\n        int n &#x3D; s.size();\n        if (n % 2 &#x3D;&#x3D; 1) &#123;\n            return false;\n        &#125;\n\n        unordered_map&lt;char, char&gt; pairs &#x3D; &#123;\n            &#123;&#39;)&#39;, &#39;(&#39;&#125;,\n            &#123;&#39;]&#39;, &#39;[&#39;&#125;,\n            &#123;&#39;&#125;&#39;, &#39;&#123;&#39;&#125;\n        &#125;;\n        stack&lt;char&gt; stk;\n        for (char ch: s) &#123;\n            if (pairs.count(ch)) &#123;\n                if (stk.empty() || stk.top() !&#x3D; pairs[ch]) &#123;\n                    return false;\n                &#125;\n                stk.pop();\n            &#125;\n            else &#123;\n                stk.push(ch);\n            &#125;\n        &#125;\n        return stk.empty();\n    &#125;\n&#125;;</code></pre>\n\n\n\n<p>作者：力扣官方题解<br>链接：<a href=\"https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/\">https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}