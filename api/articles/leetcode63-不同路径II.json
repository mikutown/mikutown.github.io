{"title":"leetcode63.不同路径II","slug":"leetcode63-不同路径II","date":"2023-04-12T01:18:23.000Z","updated":"2023-04-12T01:21:48.654Z","comments":true,"path":"api/articles/leetcode63-不同路径II.json","excerpt":"题目一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。","covers":["http://cdn.leafii.top/img/robot1.jpg","http://cdn.leafii.top/img/robot2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/robot1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]\n输出：2\n解释：3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/robot2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：obstacleGrid &#x3D; [[0,1],[0,0]]\n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == obstacleGrid.length</code></li>\n<li><code>n == obstacleGrid[i].length</code></li>\n<li><code>1 &lt;= m, n &lt;= 100</code></li>\n<li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这是一道典型的动态规划问题。定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p>\n<p>在定义dp数组时，需要特别注意：如果某个格子为障碍物，则不能通过该格子，路径数为0；如果第一列某个格子为障碍物，则其下方的所有格子均无法到达，路径数为0；如果第一行某个格子为障碍物，则其右方的所有格子均无法到达，路径数为0。</p>\n<p>在状态转移方程中，如果某个格子为障碍物，则其路径数为0；否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p>\n<p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>\n<p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;\n        int m &#x3D; obstacleGrid.size();\n        int n &#x3D; obstacleGrid[0].size();\n        &#x2F;&#x2F; 定义二维数组dp\n        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));\n        &#x2F;&#x2F; 初始化第一列\n        for (int i &#x3D; 0; i &lt; m; i++) &#123;\n            if (obstacleGrid[i][0] &#x3D;&#x3D; 1) &#123;\n                break;\n            &#125;\n            dp[i][0] &#x3D; 1;\n        &#125;\n        &#x2F;&#x2F; 初始化第一行\n        for (int j &#x3D; 0; j &lt; n; j++) &#123;\n            if (obstacleGrid[0][j] &#x3D;&#x3D; 1) &#123;\n                break;\n            &#125;\n            dp[0][j] &#x3D; 1;\n        &#125;\n        &#x2F;&#x2F; 对于其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和\n        for (int i &#x3D; 1; i &lt; m; i++) &#123;\n            for (int j &#x3D; 1; j &lt; n; j++) &#123;\n                if (obstacleGrid[i][j] &#x3D;&#x3D; 1) &#123;  &#x2F;&#x2F; 如果当前格子为障碍物，则不可到达，路径数为0\n                    dp[i][j] &#x3D; 0;\n                &#125; else &#123;  &#x2F;&#x2F; 否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达\n                    dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 返回右下角格子的不同路径数目\n        return dp[m-1][n-1];\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/robot1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]\n输出：2\n解释：3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/robot2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：obstacleGrid &#x3D; [[0,1],[0,0]]\n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == obstacleGrid.length</code></li>\n<li><code>n == obstacleGrid[i].length</code></li>\n<li><code>1 &lt;= m, n &lt;= 100</code></li>\n<li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这是一道典型的动态规划问题。定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p>\n<p>在定义dp数组时，需要特别注意：如果某个格子为障碍物，则不能通过该格子，路径数为0；如果第一列某个格子为障碍物，则其下方的所有格子均无法到达，路径数为0；如果第一行某个格子为障碍物，则其右方的所有格子均无法到达，路径数为0。</p>\n<p>在状态转移方程中，如果某个格子为障碍物，则其路径数为0；否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p>\n<p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>\n<p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;\n        int m &#x3D; obstacleGrid.size();\n        int n &#x3D; obstacleGrid[0].size();\n        &#x2F;&#x2F; 定义二维数组dp\n        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));\n        &#x2F;&#x2F; 初始化第一列\n        for (int i &#x3D; 0; i &lt; m; i++) &#123;\n            if (obstacleGrid[i][0] &#x3D;&#x3D; 1) &#123;\n                break;\n            &#125;\n            dp[i][0] &#x3D; 1;\n        &#125;\n        &#x2F;&#x2F; 初始化第一行\n        for (int j &#x3D; 0; j &lt; n; j++) &#123;\n            if (obstacleGrid[0][j] &#x3D;&#x3D; 1) &#123;\n                break;\n            &#125;\n            dp[0][j] &#x3D; 1;\n        &#125;\n        &#x2F;&#x2F; 对于其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和\n        for (int i &#x3D; 1; i &lt; m; i++) &#123;\n            for (int j &#x3D; 1; j &lt; n; j++) &#123;\n                if (obstacleGrid[i][j] &#x3D;&#x3D; 1) &#123;  &#x2F;&#x2F; 如果当前格子为障碍物，则不可到达，路径数为0\n                    dp[i][j] &#x3D; 0;\n                &#125; else &#123;  &#x2F;&#x2F; 否则，其到达的路径有两种：从上方的格子到达和从左边的格子到达\n                    dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 返回右下角格子的不同路径数目\n        return dp[m-1][n-1];\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}