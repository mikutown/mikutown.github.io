{"title":"剑指Offer64.求1+2+…+n","slug":"剑指Offer64-求1-2-…-n","date":"2023-01-17T05:17:16.000Z","updated":"2023-01-17T06:10:05.987Z","comments":true,"path":"api/articles/剑指Offer64-求1-2-…-n.json","excerpt":"题目求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>\n <span id=\"more\"></span>\n\n\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: n &#x3D; 3\n输出: 6</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: n &#x3D; 9\n输出: 45</code></pre>\n\n<p><strong>限制：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 10000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>错误解法（使用了if）,虽然通过了但是不符合题意。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int sumNums(int n) &#123;\n        if(n &#x3D;&#x3D; 1)\n        &#123;\n            return 1;\n        &#125;\n        else\n        &#123;\n            return n + sumNums(n - 1);\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>由于不能使用乘除法，<code>for</code>，<code>while</code>等关键字以及条件判断语句，因此我们能用的挚友加减法，赋值，位运算符和逻辑运算符。</li>\n</ol>\n<p>但是如果使用递归方法，那么递归的结束条件很难不用条件判断语句，那么怎么解决？答案是使用逻辑运算符<code>&amp;&amp;</code>或者<code>||</code>，利用它的短路性质，对于<code> A &amp;&amp; B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>False</code> ，那么 <code>A &amp;&amp; B</code> 已经确定为 <code>False</code>，此时不会去执行表达式 <code>B</code>。同理，对于逻辑运算符 <code>||</code>， 对于 <code>A || B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>True</code> ，那么<code> A || B</code> 已经确定为<code> True</code> ，此时不会去执行表达式<code> B</code>。</p>\n<p>因此我们可以将判断是否为递归的出口看作<code>A&amp;B</code>表达式中的<code>A</code>部分，递归的主体函数看作<code>B</code>部分。如果不是递归出口，就返回<code>True</code>，并继续执行表达式<code>B</code>的部分，否则递归结束。结合逻辑运算符<code>&amp;&amp;</code>的递归实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int sumNums(int n) &#123;\n        n &amp;&amp; (n +&#x3D; sumNums(n-1));\n        return n;\n    &#125;\n&#125;;</code></pre>\n\n<p>用逻辑运算符<code>||</code>的递归实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int sumNums(int n) &#123;\n        n&#x3D;&#x3D;1 || (n +&#x3D; sumNums(n-1));\n        return n;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ol start=\"3\">\n<li>使用C++的sizeof函数进行$\\frac{1}{2}(n \\times (n+1))$的模拟：</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int sumNums(int n) &#123;\n        bool a[n][n+1]; &#x2F;&#x2F;bool一个元素占一bit\n        return sizeof(a) &gt;&gt; 1; &#x2F;&#x2F;sizeof(a) 计算了n*(n+1)\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: n &#x3D; 3\n输出: 6</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: n &#x3D; 9\n输出: 45</code></pre>\n\n<p><strong>限制：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 10000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>错误解法（使用了if）,虽然通过了但是不符合题意。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int sumNums(int n) &#123;\n        if(n &#x3D;&#x3D; 1)\n        &#123;\n            return 1;\n        &#125;\n        else\n        &#123;\n            return n + sumNums(n - 1);\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>由于不能使用乘除法，<code>for</code>，<code>while</code>等关键字以及条件判断语句，因此我们能用的挚友加减法，赋值，位运算符和逻辑运算符。</li>\n</ol>\n<p>但是如果使用递归方法，那么递归的结束条件很难不用条件判断语句，那么怎么解决？答案是使用逻辑运算符<code>&amp;&amp;</code>或者<code>||</code>，利用它的短路性质，对于<code> A &amp;&amp; B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>False</code> ，那么 <code>A &amp;&amp; B</code> 已经确定为 <code>False</code>，此时不会去执行表达式 <code>B</code>。同理，对于逻辑运算符 <code>||</code>， 对于 <code>A || B</code> 这个表达式，如果 <code>A</code> 表达式返回 <code>True</code> ，那么<code> A || B</code> 已经确定为<code> True</code> ，此时不会去执行表达式<code> B</code>。</p>\n<p>因此我们可以将判断是否为递归的出口看作<code>A&amp;B</code>表达式中的<code>A</code>部分，递归的主体函数看作<code>B</code>部分。如果不是递归出口，就返回<code>True</code>，并继续执行表达式<code>B</code>的部分，否则递归结束。结合逻辑运算符<code>&amp;&amp;</code>的递归实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int sumNums(int n) &#123;\n        n &amp;&amp; (n +&#x3D; sumNums(n-1));\n        return n;\n    &#125;\n&#125;;</code></pre>\n\n<p>用逻辑运算符<code>||</code>的递归实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int sumNums(int n) &#123;\n        n&#x3D;&#x3D;1 || (n +&#x3D; sumNums(n-1));\n        return n;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ol start=\"3\">\n<li>使用C++的sizeof函数进行$\\frac{1}{2}(n \\times (n+1))$的模拟：</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int sumNums(int n) &#123;\n        bool a[n][n+1]; &#x2F;&#x2F;bool一个元素占一bit\n        return sizeof(a) &gt;&gt; 1; &#x2F;&#x2F;sizeof(a) 计算了n*(n+1)\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}