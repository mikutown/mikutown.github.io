{"title":"leetcode636.函数的独占时间","slug":"leetcode636-函数的独占时间","date":"2023-07-27T02:22:56.000Z","updated":"2023-07-27T02:25:30.235Z","comments":true,"path":"api/articles/leetcode636-函数的独占时间.json","excerpt":"题目有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于 0 和 n-1 之间的唯一标识符。函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 &quot;&#123;function_id&#125;:&#123;&quot;start&quot; | &quot;end&quot;&#125;:&#123;timestamp&#125;&quot; 进行格式化的字符串。例如，&quot;0:start:3&quot; 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 &quot;1:end:2&quot; 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。","covers":["http://cdn.leafii.top/img/diag1b.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>有一个 <strong>单线程</strong> CPU 正在运行一个含有 <code>n</code> 道函数的程序。每道函数都有一个位于 <code>0</code> 和 <code>n-1</code> 之间的唯一标识符。</p>\n<p>函数调用 <strong>存储在一个 <a href=\"https://baike.baidu.com/item/%E8%B0%83%E7%94%A8%E6%A0%88/22718047?fr=aladdin\">调用栈</a> 上</strong> ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 <strong>当前正在执行的函数</strong> 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。</p>\n<p>给你一个由日志组成的列表 <code>logs</code> ，其中 <code>logs[i]</code> 表示第 <code>i</code> 条日志消息，该消息是一个按 <code>&quot;&#123;function_id&#125;:&#123;&quot;start&quot; | &quot;end&quot;&#125;:&#123;timestamp&#125;&quot;</code> 进行格式化的字符串。例如，<code>&quot;0:start:3&quot;</code> 意味着标识符为 <code>0</code> 的函数调用在时间戳 <code>3</code> 的 <strong>起始开始执行</strong> ；而 <code>&quot;1:end:2&quot;</code> 意味着标识符为 <code>1</code> 的函数调用在时间戳 <code>2</code> 的 <strong>末尾结束执行</strong>。注意，函数可以 <strong>调用多次，可能存在递归调用</strong> 。</p>\n<p>函数的 <strong>独占时间</strong> 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 <code>2</code> 单位时间，另一次调用执行 <code>1</code> 单位时间，那么该函数的 <strong>独占时间</strong> 为 <code>2 + 1 = 3</code> 。</p>\n<p>以数组形式返回每个函数的 <strong>独占时间</strong> ，其中第 <code>i</code> 个下标对应的值表示标识符 <code>i</code> 的函数的独占时间。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/diag1b.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2, logs &#x3D; [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]\n输出：[3,4]\n解释：\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 \n函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 \n函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 \n所以函数 0 总共执行 2 + 1 &#x3D; 3 个单位时间，函数 1 总共执行 4 个单位时间。 </code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;0:start:6&quot;,&quot;0:end:6&quot;,&quot;0:end:7&quot;]\n输出：[8]\n解释：\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻再次调用它自身。\n函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。\n所以函数 0 总共执行 2 + 4 + 1 + 1 &#x3D; 8 个单位时间。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:6&quot;,&quot;1:end:6&quot;,&quot;0:end:7&quot;]\n输出：[7,1]\n解释：\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻调用函数 1 。\n函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。\n所以函数 0 总共执行 2 + 4 + 1 &#x3D; 7 个单位时间，函数 1 总共执行 1 个单位时间。 </code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:7&quot;,&quot;1:end:7&quot;,&quot;0:end:8&quot;]\n输出：[8,1]</code></pre>\n\n<p><strong>示例 5：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:end:0&quot;]\n输出：[1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 100</code></li>\n<li><code>1 &lt;= logs.length &lt;= 500</code></li>\n<li><code>0 &lt;= function_id &lt; n</code></li>\n<li><code>0 &lt;= timestamp &lt;= 109</code></li>\n<li>两个开始事件不会在同一时间戳发生</li>\n<li>两个结束事件不会在同一时间戳发生</li>\n<li>每道函数都有一个对应 <code>&quot;start&quot;</code> 日志的 <code>&quot;end&quot;</code> 日志</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>题目要求计算多个函数在单线程CPU上的独占执行时间。给定一个由字符串日志组成的数组，每条日志包含函数的ID、开始或结束标志以及时间戳。函数可能嵌套调用，但始终是先开始再结束。要求计算每个函数的独占执行时间，返回一个长度为n的数组，其中n是函数的数量。</p>\n<p>解题思路如下：</p>\n<ol>\n<li>定义一个结构体<code>FunctionCall</code>来保存函数的ID、时间戳、开始或结束标志以及执行时长。</li>\n<li>创建一个长度为n的结果数组<code>result</code>，用于保存每个函数的独占执行时间，并初始化为0。</li>\n<li>创建一个栈<code>callStack</code>用于保存当前正在执行的函数调用。</li>\n<li>遍历给定的日志数组，对每条日志进行解析：<ul>\n<li>提取函数的ID、开始或结束标志和时间戳。</li>\n<li>若为函数开始日志：<ul>\n<li>若栈非空，则更新栈顶函数的执行时间（上一个函数的执行时间）：当前时间戳减去栈顶函数的时间戳。</li>\n<li>将当前函数加入调用栈。</li>\n</ul>\n</li>\n<li>若为函数结束日志：<ul>\n<li>弹出当前函数，并计算当前函数的执行时间：当前时间戳减去栈顶函数的时间戳加1。</li>\n<li>更新栈顶函数的时间戳为当前时间戳加1（因为当前函数执行完毕后，接下来执行的代码时间戳从当前时间戳的下一时刻开始）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>返回结果数组<code>result</code>。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    struct FunctionCall &#123;\n    int id;       &#x2F;&#x2F; 函数ID\n    int timestamp; &#x2F;&#x2F; 时间戳\n    bool isStart; &#x2F;&#x2F; 是否是函数开始\n    int duration; &#x2F;&#x2F; 函数执行时长\n    &#125;;\n\n    vector&lt;int&gt; exclusiveTime(int n, vector&lt;string&gt;&amp; logs) &#123;\n        vector&lt;int&gt; result(n, 0);\n        stack&lt;FunctionCall&gt; callStack;\n\n        for (const string&amp; log : logs) &#123;\n            stringstream ss(log);\n            string token;\n\n            &#x2F;&#x2F; 提取日志信息并解析\n            getline(ss, token, &#39;:&#39;);\n            int functionId &#x3D; stoi(token);\n\n            getline(ss, token, &#39;:&#39;);\n            string startOrEnd &#x3D; token &#x3D;&#x3D; &quot;start&quot; ? &quot;start&quot; : &quot;end&quot;;\n            bool isStart &#x3D; (startOrEnd &#x3D;&#x3D; &quot;start&quot;);\n\n            getline(ss, token, &#39;:&#39;);\n            int timestamp &#x3D; stoi(token);\n\n            &#x2F;&#x2F; 处理函数调用\n            if (isStart) &#123;\n                if (!callStack.empty()) &#123;\n                    &#x2F;&#x2F; 更新上一个函数的执行时长\n                    FunctionCall&amp; prevCall &#x3D; callStack.top();\n                    result[prevCall.id] +&#x3D; timestamp - prevCall.timestamp;\n                &#125;\n\n                &#x2F;&#x2F; 将当前函数加入调用栈\n                callStack.push(&#123; functionId, timestamp, true, 0 &#125;);\n            &#125; else &#123;\n                &#x2F;&#x2F; 弹出当前函数，并计算执行时长\n                FunctionCall currentCall &#x3D; callStack.top();\n                callStack.pop();\n\n                int currentDuration &#x3D; timestamp - currentCall.timestamp + 1;\n                result[currentCall.id] +&#x3D; currentDuration;\n\n                &#x2F;&#x2F; 若栈非空，更新上一个函数的执行时长\n                if (!callStack.empty()) &#123;\n                    FunctionCall&amp; prevCall &#x3D; callStack.top();\n                    prevCall.timestamp &#x3D; timestamp + 1;\n                &#125;\n            &#125;\n        &#125;\n\n        return result;\n    &#125;\n\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/diag1b.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2, logs &#x3D; [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]\n输出：[3,4]\n解释：\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 \n函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 \n函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 \n所以函数 0 总共执行 2 + 1 &#x3D; 3 个单位时间，函数 1 总共执行 4 个单位时间。 </code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;0:start:6&quot;,&quot;0:end:6&quot;,&quot;0:end:7&quot;]\n输出：[8]\n解释：\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻再次调用它自身。\n函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。\n所以函数 0 总共执行 2 + 4 + 1 + 1 &#x3D; 8 个单位时间。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:6&quot;,&quot;1:end:6&quot;,&quot;0:end:7&quot;]\n输出：[7,1]\n解释：\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻调用函数 1 。\n函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。\n所以函数 0 总共执行 2 + 4 + 1 &#x3D; 7 个单位时间，函数 1 总共执行 1 个单位时间。 </code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:7&quot;,&quot;1:end:7&quot;,&quot;0:end:8&quot;]\n输出：[8,1]</code></pre>\n\n<p><strong>示例 5：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1, logs &#x3D; [&quot;0:start:0&quot;,&quot;0:end:0&quot;]\n输出：[1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 100</code></li>\n<li><code>1 &lt;= logs.length &lt;= 500</code></li>\n<li><code>0 &lt;= function_id &lt; n</code></li>\n<li><code>0 &lt;= timestamp &lt;= 109</code></li>\n<li>两个开始事件不会在同一时间戳发生</li>\n<li>两个结束事件不会在同一时间戳发生</li>\n<li>每道函数都有一个对应 <code>&quot;start&quot;</code> 日志的 <code>&quot;end&quot;</code> 日志</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>题目要求计算多个函数在单线程CPU上的独占执行时间。给定一个由字符串日志组成的数组，每条日志包含函数的ID、开始或结束标志以及时间戳。函数可能嵌套调用，但始终是先开始再结束。要求计算每个函数的独占执行时间，返回一个长度为n的数组，其中n是函数的数量。</p>\n<p>解题思路如下：</p>\n<ol>\n<li>定义一个结构体<code>FunctionCall</code>来保存函数的ID、时间戳、开始或结束标志以及执行时长。</li>\n<li>创建一个长度为n的结果数组<code>result</code>，用于保存每个函数的独占执行时间，并初始化为0。</li>\n<li>创建一个栈<code>callStack</code>用于保存当前正在执行的函数调用。</li>\n<li>遍历给定的日志数组，对每条日志进行解析：<ul>\n<li>提取函数的ID、开始或结束标志和时间戳。</li>\n<li>若为函数开始日志：<ul>\n<li>若栈非空，则更新栈顶函数的执行时间（上一个函数的执行时间）：当前时间戳减去栈顶函数的时间戳。</li>\n<li>将当前函数加入调用栈。</li>\n</ul>\n</li>\n<li>若为函数结束日志：<ul>\n<li>弹出当前函数，并计算当前函数的执行时间：当前时间戳减去栈顶函数的时间戳加1。</li>\n<li>更新栈顶函数的时间戳为当前时间戳加1（因为当前函数执行完毕后，接下来执行的代码时间戳从当前时间戳的下一时刻开始）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>返回结果数组<code>result</code>。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    struct FunctionCall &#123;\n    int id;       &#x2F;&#x2F; 函数ID\n    int timestamp; &#x2F;&#x2F; 时间戳\n    bool isStart; &#x2F;&#x2F; 是否是函数开始\n    int duration; &#x2F;&#x2F; 函数执行时长\n    &#125;;\n\n    vector&lt;int&gt; exclusiveTime(int n, vector&lt;string&gt;&amp; logs) &#123;\n        vector&lt;int&gt; result(n, 0);\n        stack&lt;FunctionCall&gt; callStack;\n\n        for (const string&amp; log : logs) &#123;\n            stringstream ss(log);\n            string token;\n\n            &#x2F;&#x2F; 提取日志信息并解析\n            getline(ss, token, &#39;:&#39;);\n            int functionId &#x3D; stoi(token);\n\n            getline(ss, token, &#39;:&#39;);\n            string startOrEnd &#x3D; token &#x3D;&#x3D; &quot;start&quot; ? &quot;start&quot; : &quot;end&quot;;\n            bool isStart &#x3D; (startOrEnd &#x3D;&#x3D; &quot;start&quot;);\n\n            getline(ss, token, &#39;:&#39;);\n            int timestamp &#x3D; stoi(token);\n\n            &#x2F;&#x2F; 处理函数调用\n            if (isStart) &#123;\n                if (!callStack.empty()) &#123;\n                    &#x2F;&#x2F; 更新上一个函数的执行时长\n                    FunctionCall&amp; prevCall &#x3D; callStack.top();\n                    result[prevCall.id] +&#x3D; timestamp - prevCall.timestamp;\n                &#125;\n\n                &#x2F;&#x2F; 将当前函数加入调用栈\n                callStack.push(&#123; functionId, timestamp, true, 0 &#125;);\n            &#125; else &#123;\n                &#x2F;&#x2F; 弹出当前函数，并计算执行时长\n                FunctionCall currentCall &#x3D; callStack.top();\n                callStack.pop();\n\n                int currentDuration &#x3D; timestamp - currentCall.timestamp + 1;\n                result[currentCall.id] +&#x3D; currentDuration;\n\n                &#x2F;&#x2F; 若栈非空，更新上一个函数的执行时长\n                if (!callStack.empty()) &#123;\n                    FunctionCall&amp; prevCall &#x3D; callStack.top();\n                    prevCall.timestamp &#x3D; timestamp + 1;\n                &#125;\n            &#125;\n        &#125;\n\n        return result;\n    &#125;\n\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}