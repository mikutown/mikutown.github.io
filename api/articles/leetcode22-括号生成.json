{"title":"leetcode22.括号生成","slug":"leetcode22-括号生成","date":"2023-09-07T07:55:19.000Z","updated":"2023-09-07T08:22:23.617Z","comments":true,"path":"api/articles/leetcode22-括号生成.json","excerpt":"题目数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3\n输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1\n输出：[&quot;()&quot;]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;string&gt; generateParenthesis(int n) &#123;\n        vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储最终结果的向量\n\n        &#x2F;&#x2F; 调用递归函数开始生成括号\n        generate(result, &quot;&quot;, 0, 0, n);\n\n        return result;\n    &#125;\n\nprivate:\n    &#x2F;&#x2F; 递归生成括号的辅助函数\n    void generate(vector&lt;string&gt;&amp; result, string current, int open, int close, int max) &#123;\n        &#x2F;&#x2F; 当前生成的括号串长度等于2 * n时，将其加入结果向量\n        if (current.length() &#x3D;&#x3D; 2 * max) &#123;\n            result.push_back(current);\n            return;\n        &#125;\n\n        &#x2F;&#x2F; 如果左括号的数量小于n，可以添加左括号\n        if (open &lt; max) &#123;\n            generate(result, current + &quot;(&quot;, open + 1, close, max);\n        &#125;\n\n        &#x2F;&#x2F; 如果右括号的数量小于左括号，可以添加右括号\n        if (close &lt; open) &#123;\n            generate(result, current + &quot;)&quot;, open, close + 1, max);\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3\n输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1\n输出：[&quot;()&quot;]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;string&gt; generateParenthesis(int n) &#123;\n        vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储最终结果的向量\n\n        &#x2F;&#x2F; 调用递归函数开始生成括号\n        generate(result, &quot;&quot;, 0, 0, n);\n\n        return result;\n    &#125;\n\nprivate:\n    &#x2F;&#x2F; 递归生成括号的辅助函数\n    void generate(vector&lt;string&gt;&amp; result, string current, int open, int close, int max) &#123;\n        &#x2F;&#x2F; 当前生成的括号串长度等于2 * n时，将其加入结果向量\n        if (current.length() &#x3D;&#x3D; 2 * max) &#123;\n            result.push_back(current);\n            return;\n        &#125;\n\n        &#x2F;&#x2F; 如果左括号的数量小于n，可以添加左括号\n        if (open &lt; max) &#123;\n            generate(result, current + &quot;(&quot;, open + 1, close, max);\n        &#125;\n\n        &#x2F;&#x2F; 如果右括号的数量小于左括号，可以添加右括号\n        if (close &lt; open) &#123;\n            generate(result, current + &quot;)&quot;, open, close + 1, max);\n        &#125;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}