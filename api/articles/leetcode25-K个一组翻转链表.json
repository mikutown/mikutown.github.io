{"title":"leetcode25.K个一组翻转链表","slug":"leetcode25-K个一组翻转链表","date":"2023-03-09T09:07:29.000Z","updated":"2023-03-09T09:22:48.238Z","comments":true,"path":"api/articles/leetcode25-K个一组翻转链表.json","excerpt":"题目给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。","covers":["http://cdn.leafii.top/img/reverse_ex1.jpg","http://cdn.leafii.top/img/reverse_ex2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>\n<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/reverse_ex1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2\n输出：[2,1,4,3,5]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/reverse_ex2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3\n输出：[3,2,1,4,5]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中的节点数目为 <code>n</code></li>\n<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>\n<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>编写一个函数，用于实现反转链表的核心逻辑，思路如下：</p>\n<ul>\n<li><p>初始化一个前驱节点prev和一个当前节点curr，分别指向空和头节点。</p>\n</li>\n<li><p>循环k次，每次做以下操作：</p>\n<ul>\n<li><p>保存当前节点的下一个节点next，以免丢失。</p>\n</li>\n<li><p>将当前节点的next指针指向前驱节点prev，实现反转。</p>\n</li>\n<li><p>将前驱节点prev更新为当前节点curr，为下一次反转做准备。</p>\n</li>\n<li><p>将当前节点curr更新为下一个节点next，继续遍历链表。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>这样就可以将链表中的k个节点反转，并返回反转后的头尾指针。</p>\n<blockquote>\n<p>对以上函数进行一个图示说明：</p>\n<p>假设链表为1-&gt;2-&gt;3-&gt;4-&gt;5，k为3，那么反转后的链表应该为3-&gt;2-&gt;1-&gt;4-&gt;5。</p>\n<p>初始状态：</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">prev: null\ncurr: 1\nnext: 2\n\nnull &lt;- prev   curr -> next -> 3 -> 4 -> 5</code></pre>\n\n<p>第一次循环：</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">prev: 1\ncurr: 2\nnext: 3\n\nnull &lt;- prev &lt;- curr   next -> 4 -> 5</code></pre>\n\n<p>第二次循环：</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">prev: 2\ncurr: 3\nnext: 4\n\nnull &lt;- prev &lt;- curr   next -> 5</code></pre>\n\n<p>第三次循环：</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">prev: 3\ncurr: 4\nnext: 5\n\nnull &lt;- prev &lt;- curr   next </code></pre>\n\n<p>结束循环，返回{prev, head}即{3,1}。</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\"> prev        head \n  |           |\n  v           v \nnull&lt;-3&lt;-2&lt;-1    4->5 </code></pre>\n</blockquote>\n<p>代码的整体思路是：</p>\n<ul>\n<li>定义一个虚拟头节点dummy，指向原链表的头节点head，这样可以方便处理边界情况。</li>\n<li>定义一个前驱节点prev，初始指向dummy，用来连接反转后的链表段。</li>\n<li>用一个while循环遍历整个链表，每次循环做以下操作：<ul>\n<li>定义一个尾部指针tail，初始指向头部指针head，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回dummy-&gt;next即可。</li>\n<li>保存下一段链表的头部指针nextHead，并断开与当前段的连接。</li>\n<li>调用反转函数reverseList，输入当前段的头部指针head和长度k，返回反转后的新头部和新尾部，并将其连接到前驱和下一段上。</li>\n<li>更新前驱为新尾部，更新头部为下一段头部。</li>\n</ul>\n</li>\n</ul>\n<p>这样就可以将整个链表按照每k个节点进行反转，并返回dummy-&gt;next作为新链表的头节点。</p>\n<p>代码的时间复杂度是O(n)，因为我们只需要遍历一次链表，每个节点最多被访问两次。 代码的空间复杂度是O(1)，因为我们只使用了常数个额外变量，没有使用递归或栈。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F; 定义反转链表的函数，输入一个链表头节点和一个长度k，返回反转后的头节点和尾节点\n    pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, int k) &#123;\n        &#x2F;&#x2F; 初始化前驱节点和当前节点\n        ListNode* prev &#x3D; nullptr;\n        ListNode* curr &#x3D; head;\n        &#x2F;&#x2F; 遍历k次，每次将当前节点指向前驱节点，并更新前驱和当前节点\n        for (int i &#x3D; 0; i &lt; k; i++) &#123;\n            ListNode* next &#x3D; curr-&gt;next; &#x2F;&#x2F; 保存下一个节点\n            curr-&gt;next &#x3D; prev; &#x2F;&#x2F; 反转指针\n            prev &#x3D; curr; &#x2F;&#x2F; 更新前驱\n            curr &#x3D; next; &#x2F;&#x2F; 更新当前\n        &#125;\n        &#x2F;&#x2F; 返回反转后的头节点和尾节点，即原来的尾节点和头节点\n        return &#123;prev, head&#125;;\n    &#125;\n\n    &#x2F;&#x2F; 定义leetcode 25的主函数，输入一个链表头节点和一个整数k，返回反转后的链表头节点\n    ListNode* reverseKGroup(ListNode* head, int k) &#123;\n        &#x2F;&#x2F; 初始化虚拟头节点和前驱节点\n        ListNode* dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n        ListNode* prev &#x3D; dummy;\n        \n        while (head !&#x3D; nullptr) &#123; &#x2F;&#x2F; 遍历链表直到为空\n            &#x2F;&#x2F; 初始化尾部指针为头部指针，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回虚拟头节点的下一个即可\n            ListNode* tail &#x3D; head;\n            for (int i &#x3D; 0; i &lt; k - 1; i++) &#123;\n                tail &#x3D; tail-&gt;next;\n                if (tail &#x3D;&#x3D; nullptr) return dummy-&gt;next;\n            &#125;\n            \n            &#x2F;&#x2F; 保存下一段链表的头部指针，并断开与当前段的连接\n            ListNode* nextHead &#x3D; tail-&gt;next;\n            tail-&gt;next &#x3D; nullptr;\n\n            &#x2F;&#x2F; 调用反转函数，得到反转后的新头部和新尾部，并将其连接到前驱和下一段上\n            auto reversedPair &#x3D; reverseList(head, k);\n            prev-&gt;next &#x3D; reversedPair.first;\n            reversedPair.second-&gt;next &#x3D; nextHead;\n\n            &#x2F;&#x2F; 更新前驱为新尾部，更新头部为下一段头部\n            prev &#x3D; reversedPair.second;\n            head &#x3D; nextHead;\n\n            \n        &#125;\n        \n    return dummy-&gt;next; \n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/reverse_ex1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2\n输出：[2,1,4,3,5]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/reverse_ex2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3\n输出：[3,2,1,4,5]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中的节点数目为 <code>n</code></li>\n<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>\n<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>编写一个函数，用于实现反转链表的核心逻辑，思路如下：</p>\n<ul>\n<li><p>初始化一个前驱节点prev和一个当前节点curr，分别指向空和头节点。</p>\n</li>\n<li><p>循环k次，每次做以下操作：</p>\n<ul>\n<li><p>保存当前节点的下一个节点next，以免丢失。</p>\n</li>\n<li><p>将当前节点的next指针指向前驱节点prev，实现反转。</p>\n</li>\n<li><p>将前驱节点prev更新为当前节点curr，为下一次反转做准备。</p>\n</li>\n<li><p>将当前节点curr更新为下一个节点next，继续遍历链表。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>这样就可以将链表中的k个节点反转，并返回反转后的头尾指针。</p>\n<blockquote>\n<p>对以上函数进行一个图示说明：</p>\n<p>假设链表为1-&gt;2-&gt;3-&gt;4-&gt;5，k为3，那么反转后的链表应该为3-&gt;2-&gt;1-&gt;4-&gt;5。</p>\n<p>初始状态：</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">prev: null\ncurr: 1\nnext: 2\n\nnull &lt;- prev   curr -> next -> 3 -> 4 -> 5</code></pre>\n\n<p>第一次循环：</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">prev: 1\ncurr: 2\nnext: 3\n\nnull &lt;- prev &lt;- curr   next -> 4 -> 5</code></pre>\n\n<p>第二次循环：</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">prev: 2\ncurr: 3\nnext: 4\n\nnull &lt;- prev &lt;- curr   next -> 5</code></pre>\n\n<p>第三次循环：</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\">prev: 3\ncurr: 4\nnext: 5\n\nnull &lt;- prev &lt;- curr   next </code></pre>\n\n<p>结束循环，返回{prev, head}即{3,1}。</p>\n<pre class=\"language-text\" data-language=\"text\"><code class=\"language-text\"> prev        head \n  |           |\n  v           v \nnull&lt;-3&lt;-2&lt;-1    4->5 </code></pre>\n</blockquote>\n<p>代码的整体思路是：</p>\n<ul>\n<li>定义一个虚拟头节点dummy，指向原链表的头节点head，这样可以方便处理边界情况。</li>\n<li>定义一个前驱节点prev，初始指向dummy，用来连接反转后的链表段。</li>\n<li>用一个while循环遍历整个链表，每次循环做以下操作：<ul>\n<li>定义一个尾部指针tail，初始指向头部指针head，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回dummy-&gt;next即可。</li>\n<li>保存下一段链表的头部指针nextHead，并断开与当前段的连接。</li>\n<li>调用反转函数reverseList，输入当前段的头部指针head和长度k，返回反转后的新头部和新尾部，并将其连接到前驱和下一段上。</li>\n<li>更新前驱为新尾部，更新头部为下一段头部。</li>\n</ul>\n</li>\n</ul>\n<p>这样就可以将整个链表按照每k个节点进行反转，并返回dummy-&gt;next作为新链表的头节点。</p>\n<p>代码的时间复杂度是O(n)，因为我们只需要遍历一次链表，每个节点最多被访问两次。 代码的空间复杂度是O(1)，因为我们只使用了常数个额外变量，没有使用递归或栈。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F; 定义反转链表的函数，输入一个链表头节点和一个长度k，返回反转后的头节点和尾节点\n    pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, int k) &#123;\n        &#x2F;&#x2F; 初始化前驱节点和当前节点\n        ListNode* prev &#x3D; nullptr;\n        ListNode* curr &#x3D; head;\n        &#x2F;&#x2F; 遍历k次，每次将当前节点指向前驱节点，并更新前驱和当前节点\n        for (int i &#x3D; 0; i &lt; k; i++) &#123;\n            ListNode* next &#x3D; curr-&gt;next; &#x2F;&#x2F; 保存下一个节点\n            curr-&gt;next &#x3D; prev; &#x2F;&#x2F; 反转指针\n            prev &#x3D; curr; &#x2F;&#x2F; 更新前驱\n            curr &#x3D; next; &#x2F;&#x2F; 更新当前\n        &#125;\n        &#x2F;&#x2F; 返回反转后的头节点和尾节点，即原来的尾节点和头节点\n        return &#123;prev, head&#125;;\n    &#125;\n\n    &#x2F;&#x2F; 定义leetcode 25的主函数，输入一个链表头节点和一个整数k，返回反转后的链表头节点\n    ListNode* reverseKGroup(ListNode* head, int k) &#123;\n        &#x2F;&#x2F; 初始化虚拟头节点和前驱节点\n        ListNode* dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n        ListNode* prev &#x3D; dummy;\n        \n        while (head !&#x3D; nullptr) &#123; &#x2F;&#x2F; 遍历链表直到为空\n            &#x2F;&#x2F; 初始化尾部指针为头部指针，并向后移动k-1次，如果为空则说明剩余长度不足k，直接返回虚拟头节点的下一个即可\n            ListNode* tail &#x3D; head;\n            for (int i &#x3D; 0; i &lt; k - 1; i++) &#123;\n                tail &#x3D; tail-&gt;next;\n                if (tail &#x3D;&#x3D; nullptr) return dummy-&gt;next;\n            &#125;\n            \n            &#x2F;&#x2F; 保存下一段链表的头部指针，并断开与当前段的连接\n            ListNode* nextHead &#x3D; tail-&gt;next;\n            tail-&gt;next &#x3D; nullptr;\n\n            &#x2F;&#x2F; 调用反转函数，得到反转后的新头部和新尾部，并将其连接到前驱和下一段上\n            auto reversedPair &#x3D; reverseList(head, k);\n            prev-&gt;next &#x3D; reversedPair.first;\n            reversedPair.second-&gt;next &#x3D; nextHead;\n\n            &#x2F;&#x2F; 更新前驱为新尾部，更新头部为下一段头部\n            prev &#x3D; reversedPair.second;\n            head &#x3D; nextHead;\n\n            \n        &#125;\n        \n    return dummy-&gt;next; \n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}