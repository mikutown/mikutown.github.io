{"title":"leetcode330.按要求补齐数组","slug":"leetcode330-按要求补齐数组","date":"2023-02-23T07:09:33.000Z","updated":"2023-02-23T07:26:01.908Z","comments":true,"path":"api/articles/leetcode330-按要求补齐数组.json","excerpt":"题目给定一个已排序的正整数数组 nums ，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请返回 满足上述要求的最少需要补充的数字个数 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个已排序的正整数数组 <code>nums</code> <em>，</em>和一个正整数 <code>n</code> <em>。</em>从 <code>[1, n]</code> 区间内选取任意个数字补充到 nums 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 nums 中某几个数字的和来表示。</p>\n<p>请返回 <em>满足上述要求的最少需要补充的数字个数</em> 。</p>\n <span id=\"more\"></span>\n\n\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,3], n &#x3D; 6\n输出: 1 \n解释:\n根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。\n现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。\n其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。\n所以我们最少需要添加一个数字。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,5,10], n &#x3D; 20\n输出: 2\n解释: 我们需要添加 [2,4]。</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,2,2], n &#x3D; 5\n输出: 0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 按 <strong>升序排列</strong></li>\n<li><code>1 &lt;= n &lt;= 231 - 1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>贪心算法</li>\n</ol>\n<p>题目使用的是贪心算法。贪心算法的基本思想是，在每一步选择中都选择当前状态下最优的选择，以求得最终的全局最优解。</p>\n<p>对于这道题，我们的贪心策略是在已经被覆盖的区间内，选择尽可能靠右的数字来扩展区间，这样可以让被覆盖的区间尽可能的大，从而让需要添加的数字的数量尽可能的少。</p>\n<p>当遍历到一个数时，如果这个数小于等于 <code>covered + 1</code>，那么它可以被当前的区间所覆盖，因此可以将它加入到被覆盖的区间内，更新 <code>covered</code> 的值(<code>covered += nums[i]</code>)。如果这个数大于 <code>covered + 1</code>，那么当前的区间无法覆盖它，因此需要添加一个新的数字，使得被覆盖的区间能够扩展到这个数，更新 <code>covered</code> 的值(<code>covered += covered + 1</code>)。</p>\n<p>这个贪心策略的正确性可以通过反证法来证明：假设存在一个更优的解，使得需要添加的数字的数量比当前算法得到的解更少。那么这个更优的解必然包含一个数字 x，它是我们在当前算法中添加的数字。如果将 x 从更优的解中删除，那么这个解就会变成一个覆盖范围更小、需要添加的数字数量相同的解，与我们的假设矛盾。因此，当前算法得到的解就是最优解，贪心策略是正确的。</p>\n<p>可以先求解所有需要被插入的数字，再返回拥有所有被插入数字的数组的长度，实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;\n        vector&lt;int&gt; patches; &#x2F;&#x2F; 用于保存需要插入的数字\n        long long int covered &#x3D; 0; &#x2F;&#x2F;用longlong类型存储当前已经被覆盖的数的范围\n        int i &#x3D; 0; &#x2F;&#x2F;nums数组的下标\n        while (covered &lt; n) &#123; &#x2F;&#x2F; 只要还没有覆盖到n，就需要添加数字\n            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;\n                &#x2F;&#x2F; 如果nums[i]小于等于当前已经被覆盖的数的下一个数(covered + 1)\n                &#x2F;&#x2F; 那么就可以将nums[i]加入到被覆盖的范围内\n                covered +&#x3D; nums[i];\n                i++;\n            &#125; else &#123;\n                &#x2F;&#x2F; 如果nums[i]大于covered + 1, 那么就需要添加一个新的数字\n                int patch &#x3D; covered + 1;\n                covered +&#x3D; patch;\n                patches.push_back(patch);\n            &#125;\n        &#125;\n        return patches.size();\n    &#125;\n&#125;;</code></pre>\n\n<p>因为题目并没有要求存储被插入的数组，为了更低的空间占用，可以不存储要插入的数字，直接对计数器<code>count</code>自加一：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;\n        long long int covered &#x3D; 0;  &#x2F;&#x2F; 用 long long 类型存储当前已经被覆盖的数的范围\n        int count &#x3D; 0;  &#x2F;&#x2F; 记录需要添加的数字的数量\n        int i &#x3D; 0;  &#x2F;&#x2F; nums 数组的下标\n        while (covered &lt; n) &#123;  &#x2F;&#x2F; 只要还没有覆盖到 n，就需要添加数字\n            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;\n                &#x2F;&#x2F; 如果 nums[i] 小于等于当前已经被覆盖的数的下一个数（covered + 1）\n                &#x2F;&#x2F; 那么就可以将 nums[i] 加入到被覆盖的范围内\n                covered +&#x3D; nums[i];\n                i++;\n            &#125; else &#123;\n                &#x2F;&#x2F; 如果 nums[i] 大于 covered + 1，那么就需要添加一个新的数字\n                covered +&#x3D; covered + 1;\n                count++;\n            &#125;\n        &#125;\n        return count;\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,3], n &#x3D; 6\n输出: 1 \n解释:\n根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。\n现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。\n其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。\n所以我们最少需要添加一个数字。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,5,10], n &#x3D; 20\n输出: 2\n解释: 我们需要添加 [2,4]。</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,2,2], n &#x3D; 5\n输出: 0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 按 <strong>升序排列</strong></li>\n<li><code>1 &lt;= n &lt;= 231 - 1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>贪心算法</li>\n</ol>\n<p>题目使用的是贪心算法。贪心算法的基本思想是，在每一步选择中都选择当前状态下最优的选择，以求得最终的全局最优解。</p>\n<p>对于这道题，我们的贪心策略是在已经被覆盖的区间内，选择尽可能靠右的数字来扩展区间，这样可以让被覆盖的区间尽可能的大，从而让需要添加的数字的数量尽可能的少。</p>\n<p>当遍历到一个数时，如果这个数小于等于 <code>covered + 1</code>，那么它可以被当前的区间所覆盖，因此可以将它加入到被覆盖的区间内，更新 <code>covered</code> 的值(<code>covered += nums[i]</code>)。如果这个数大于 <code>covered + 1</code>，那么当前的区间无法覆盖它，因此需要添加一个新的数字，使得被覆盖的区间能够扩展到这个数，更新 <code>covered</code> 的值(<code>covered += covered + 1</code>)。</p>\n<p>这个贪心策略的正确性可以通过反证法来证明：假设存在一个更优的解，使得需要添加的数字的数量比当前算法得到的解更少。那么这个更优的解必然包含一个数字 x，它是我们在当前算法中添加的数字。如果将 x 从更优的解中删除，那么这个解就会变成一个覆盖范围更小、需要添加的数字数量相同的解，与我们的假设矛盾。因此，当前算法得到的解就是最优解，贪心策略是正确的。</p>\n<p>可以先求解所有需要被插入的数字，再返回拥有所有被插入数字的数组的长度，实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;\n        vector&lt;int&gt; patches; &#x2F;&#x2F; 用于保存需要插入的数字\n        long long int covered &#x3D; 0; &#x2F;&#x2F;用longlong类型存储当前已经被覆盖的数的范围\n        int i &#x3D; 0; &#x2F;&#x2F;nums数组的下标\n        while (covered &lt; n) &#123; &#x2F;&#x2F; 只要还没有覆盖到n，就需要添加数字\n            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;\n                &#x2F;&#x2F; 如果nums[i]小于等于当前已经被覆盖的数的下一个数(covered + 1)\n                &#x2F;&#x2F; 那么就可以将nums[i]加入到被覆盖的范围内\n                covered +&#x3D; nums[i];\n                i++;\n            &#125; else &#123;\n                &#x2F;&#x2F; 如果nums[i]大于covered + 1, 那么就需要添加一个新的数字\n                int patch &#x3D; covered + 1;\n                covered +&#x3D; patch;\n                patches.push_back(patch);\n            &#125;\n        &#125;\n        return patches.size();\n    &#125;\n&#125;;</code></pre>\n\n<p>因为题目并没有要求存储被插入的数组，为了更低的空间占用，可以不存储要插入的数字，直接对计数器<code>count</code>自加一：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;\n        long long int covered &#x3D; 0;  &#x2F;&#x2F; 用 long long 类型存储当前已经被覆盖的数的范围\n        int count &#x3D; 0;  &#x2F;&#x2F; 记录需要添加的数字的数量\n        int i &#x3D; 0;  &#x2F;&#x2F; nums 数组的下标\n        while (covered &lt; n) &#123;  &#x2F;&#x2F; 只要还没有覆盖到 n，就需要添加数字\n            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; covered + 1) &#123;\n                &#x2F;&#x2F; 如果 nums[i] 小于等于当前已经被覆盖的数的下一个数（covered + 1）\n                &#x2F;&#x2F; 那么就可以将 nums[i] 加入到被覆盖的范围内\n                covered +&#x3D; nums[i];\n                i++;\n            &#125; else &#123;\n                &#x2F;&#x2F; 如果 nums[i] 大于 covered + 1，那么就需要添加一个新的数字\n                covered +&#x3D; covered + 1;\n                count++;\n            &#125;\n        &#125;\n        return count;\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}