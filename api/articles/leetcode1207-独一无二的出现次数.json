{"title":"leetcode1207.独一无二的出现次数","slug":"leetcode1207-独一无二的出现次数","date":"2023-05-21T07:23:35.000Z","updated":"2023-05-21T07:26:06.451Z","comments":true,"path":"api/articles/leetcode1207-独一无二的出现次数.json","excerpt":"题目给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p>\n<p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [1,2,2,1,1,3]\n输出：true\n解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [1,2]\n输出：false</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]\n输出：true</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路： 该问题要求判断给定数组中各个元素出现的频率是否唯一。</p>\n<p>我们可以使用两个数据结构来解决这个问题：</p>\n<ol>\n<li><code>unordered_map&lt;int, int&gt;</code>：用于记录每个元素出现的频率。</li>\n<li><code>unordered_set&lt;int&gt;</code>：用于记录已经出现过的频率。</li>\n</ol>\n<p>我们首先遍历数组，统计每个元素出现的频率并存储在<code>frequencyMap</code>中。然后，我们遍历<code>frequencyMap</code>，对于每个出现的频率，如果该频率已经在<code>occurrenceSet</code>中存在，则说明出现的频率不是唯一的，我们返回false。否则，将该频率添加到<code>occurrenceSet</code>中。最后，如果所有频率都是唯一的，则返回true。</p>\n<p>在示例代码中，我们使用了一个测试用例<code>arr = &#123;1, 2, 2, 1, 1, 3&#125;</code>进行验证，输出结果为<code>true</code>，说明给定数组中各个元素的频率是唯一的。</p>\n<p>请注意，示例代码中使用了C++标准库中的<code>unordered_map</code>和<code>unordered_set</code>来实现哈希表和哈希集合的功能。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123;\n        unordered_map&lt;int, int&gt; frequencyMap; &#x2F;&#x2F; 存储每个元素出现的频率\n        unordered_set&lt;int&gt; occurrenceSet; &#x2F;&#x2F; 存储出现的频率值\n\n        &#x2F;&#x2F; 计算每个元素出现的频率\n        for (int num : arr) &#123;\n            frequencyMap[num]++;\n        &#125;\n\n        &#x2F;&#x2F; 检查频率是否是唯一的\n        for (auto it &#x3D; frequencyMap.begin(); it !&#x3D; frequencyMap.end(); ++it) &#123;\n            int occurrence &#x3D; it-&gt;second;\n\n            &#x2F;&#x2F; 如果出现的频率已经存在，返回false\n            if (occurrenceSet.count(occurrence) &gt; 0) &#123;\n                return false;\n            &#125;\n\n            &#x2F;&#x2F; 将出现的频率添加到集合中\n            occurrenceSet.insert(occurrence);\n        &#125;\n\n        &#x2F;&#x2F; 所有频率都是唯一的，返回true\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [1,2,2,1,1,3]\n输出：true\n解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [1,2]\n输出：false</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]\n输出：true</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>解题思路： 该问题要求判断给定数组中各个元素出现的频率是否唯一。</p>\n<p>我们可以使用两个数据结构来解决这个问题：</p>\n<ol>\n<li><code>unordered_map&lt;int, int&gt;</code>：用于记录每个元素出现的频率。</li>\n<li><code>unordered_set&lt;int&gt;</code>：用于记录已经出现过的频率。</li>\n</ol>\n<p>我们首先遍历数组，统计每个元素出现的频率并存储在<code>frequencyMap</code>中。然后，我们遍历<code>frequencyMap</code>，对于每个出现的频率，如果该频率已经在<code>occurrenceSet</code>中存在，则说明出现的频率不是唯一的，我们返回false。否则，将该频率添加到<code>occurrenceSet</code>中。最后，如果所有频率都是唯一的，则返回true。</p>\n<p>在示例代码中，我们使用了一个测试用例<code>arr = &#123;1, 2, 2, 1, 1, 3&#125;</code>进行验证，输出结果为<code>true</code>，说明给定数组中各个元素的频率是唯一的。</p>\n<p>请注意，示例代码中使用了C++标准库中的<code>unordered_map</code>和<code>unordered_set</code>来实现哈希表和哈希集合的功能。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123;\n        unordered_map&lt;int, int&gt; frequencyMap; &#x2F;&#x2F; 存储每个元素出现的频率\n        unordered_set&lt;int&gt; occurrenceSet; &#x2F;&#x2F; 存储出现的频率值\n\n        &#x2F;&#x2F; 计算每个元素出现的频率\n        for (int num : arr) &#123;\n            frequencyMap[num]++;\n        &#125;\n\n        &#x2F;&#x2F; 检查频率是否是唯一的\n        for (auto it &#x3D; frequencyMap.begin(); it !&#x3D; frequencyMap.end(); ++it) &#123;\n            int occurrence &#x3D; it-&gt;second;\n\n            &#x2F;&#x2F; 如果出现的频率已经存在，返回false\n            if (occurrenceSet.count(occurrence) &gt; 0) &#123;\n                return false;\n            &#125;\n\n            &#x2F;&#x2F; 将出现的频率添加到集合中\n            occurrenceSet.insert(occurrence);\n        &#125;\n\n        &#x2F;&#x2F; 所有频率都是唯一的，返回true\n        return true;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}