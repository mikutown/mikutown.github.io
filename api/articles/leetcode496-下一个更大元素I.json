{"title":"leetcode496.下一个更大元素I","slug":"leetcode496-下一个更大元素I","date":"2023-05-09T12:35:51.000Z","updated":"2023-05-09T12:41:44.848Z","comments":true,"path":"api/articles/leetcode496-下一个更大元素I.json","excerpt":"题目nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p>\n<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>\n<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>\n<p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].\n输出：[3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 2 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。下一个更大元素是 3 。\n- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>\n<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>\n<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>\n</ul>\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力实现</li>\n</ul>\n<p>直接模拟实现</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        vector&lt;int&gt; answers;\n        map&lt;int,int&gt; m;&#x2F;&#x2F; m用于存储nums2数组中每个元素的下标值\n        for (int i &#x3D; 0; i &lt; nums2.size(); i++) &#123;\n            m[nums2[i]] &#x3D; i;\n        &#125;\n        for (int i &#x3D; 0; i &lt; nums1.size(); i++)&#123;\n            int index &#x3D; m[nums1[i]]; &#x2F;&#x2F; 获取nums1的元素在nums2的下标值\n            int answer &#x3D; -1;\n            int temp &#x3D; nums1[i];\n            if (index &#x3D;&#x3D; nums2.size() - 1) answer &#x3D; -1;\n            else &#123;\n                while (index &lt; nums2.size()) &#123;\n                    if(index+1 &lt; nums2.size() &amp;&amp; nums2[index+1] &gt; temp) &#123;\n                        answer &#x3D; nums2[index+1];\n                        break;\n                    &#125;\n                    else &#123;\n                        index++;\n                    &#125;\n                &#125;\n            &#125;\n            answers.push_back(answer);\n        &#125;\n        return answers;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].\n输出：[3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 2 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。下一个更大元素是 3 。\n- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>\n<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>\n<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>\n</ul>\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力实现</li>\n</ul>\n<p>直接模拟实现</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        vector&lt;int&gt; answers;\n        map&lt;int,int&gt; m;&#x2F;&#x2F; m用于存储nums2数组中每个元素的下标值\n        for (int i &#x3D; 0; i &lt; nums2.size(); i++) &#123;\n            m[nums2[i]] &#x3D; i;\n        &#125;\n        for (int i &#x3D; 0; i &lt; nums1.size(); i++)&#123;\n            int index &#x3D; m[nums1[i]]; &#x2F;&#x2F; 获取nums1的元素在nums2的下标值\n            int answer &#x3D; -1;\n            int temp &#x3D; nums1[i];\n            if (index &#x3D;&#x3D; nums2.size() - 1) answer &#x3D; -1;\n            else &#123;\n                while (index &lt; nums2.size()) &#123;\n                    if(index+1 &lt; nums2.size() &amp;&amp; nums2[index+1] &gt; temp) &#123;\n                        answer &#x3D; nums2[index+1];\n                        break;\n                    &#125;\n                    else &#123;\n                        index++;\n                    &#125;\n                &#125;\n            &#125;\n            answers.push_back(answer);\n        &#125;\n        return answers;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}