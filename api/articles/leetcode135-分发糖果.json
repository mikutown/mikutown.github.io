{"title":"leetcode135.分发糖果","slug":"leetcode135-分发糖果","date":"2023-02-17T06:45:58.000Z","updated":"2023-02-17T06:49:29.485Z","comments":true,"path":"api/articles/leetcode135-分发糖果.json","excerpt":"题目n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：每个孩子至少分配到 1 个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>\n<p>你需要按照以下要求，给这些孩子分发糖果：</p>\n<ul>\n<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>\n<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>\n</ul>\n<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ratings &#x3D; [1,0,2]\n输出：5\n解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ratings &#x3D; [1,2,2]\n输出：4\n解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。\n     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == ratings.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 104</code></li>\n<li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>常规思路</li>\n</ol>\n<p>首先新建一个数组candies，它代表每个人能分得的糖果数，接下来进行两次遍历：第一次从左向右遍历，确保右边评分较高的小孩获得更多的糖果，第二次从右向左遍历，确保左边评分较高的小孩获得更多的糖果。代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int candy(vector&lt;int&gt;&amp; ratings) &#123;\n        int n &#x3D; ratings.size();\n        vector&lt;int&gt; candies(n, 1);\n      \n        &#x2F;&#x2F; 从左往右扫描，保证右边评分高的孩子分到更多的糖果\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            if (ratings[i] &gt; ratings[i - 1]) &#123;\n                candies[i] &#x3D; candies[i - 1] + 1;\n            &#125;\n        &#125;\n      \n        &#x2F;&#x2F; 从右往左扫描，保证左边评分高的孩子分到更多的糖果\n        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;\n            if (ratings[i] &gt; ratings[i + 1]) &#123;\n                candies[i] &#x3D; max(candies[i], candies[i + 1] + 1);\n            &#125;\n            \n        &#125;\n        &#x2F;&#x2F; 计算糖果总数\n        int result &#x3D; 0;\n        for (int item: candies) &#123;\n            result +&#x3D; item;\n        &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ratings &#x3D; [1,0,2]\n输出：5\n解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ratings &#x3D; [1,2,2]\n输出：4\n解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。\n     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == ratings.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 104</code></li>\n<li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>常规思路</li>\n</ol>\n<p>首先新建一个数组candies，它代表每个人能分得的糖果数，接下来进行两次遍历：第一次从左向右遍历，确保右边评分较高的小孩获得更多的糖果，第二次从右向左遍历，确保左边评分较高的小孩获得更多的糖果。代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int candy(vector&lt;int&gt;&amp; ratings) &#123;\n        int n &#x3D; ratings.size();\n        vector&lt;int&gt; candies(n, 1);\n      \n        &#x2F;&#x2F; 从左往右扫描，保证右边评分高的孩子分到更多的糖果\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            if (ratings[i] &gt; ratings[i - 1]) &#123;\n                candies[i] &#x3D; candies[i - 1] + 1;\n            &#125;\n        &#125;\n      \n        &#x2F;&#x2F; 从右往左扫描，保证左边评分高的孩子分到更多的糖果\n        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;\n            if (ratings[i] &gt; ratings[i + 1]) &#123;\n                candies[i] &#x3D; max(candies[i], candies[i + 1] + 1);\n            &#125;\n            \n        &#125;\n        &#x2F;&#x2F; 计算糖果总数\n        int result &#x3D; 0;\n        for (int item: candies) &#123;\n            result +&#x3D; item;\n        &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}