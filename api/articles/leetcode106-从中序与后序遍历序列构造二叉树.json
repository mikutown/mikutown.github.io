{"title":"leetcode106.从中序与后序遍历序列构造二叉树","slug":"leetcode106-从中序与后序遍历序列构造二叉树","date":"2023-03-15T09:27:14.000Z","updated":"2023-03-16T06:23:59.405Z","comments":true,"path":"api/articles/leetcode106-从中序与后序遍历序列构造二叉树.json","excerpt":"题目给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。","covers":["http://cdn.leafii.top/img/tree.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]\n输出：[3,9,20,null,null,15,7]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：inorder &#x3D; [-1], postorder &#x3D; [-1]\n输出：[-1]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n<li><code>postorder.length == inorder.length</code></li>\n<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n<li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li>\n<li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li>\n<li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li>\n<li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归构造</li>\n</ul>\n<p>根据题意，可以得知后序遍历的最后一个元素一定是树的根节点。然后可以在中序遍历中找到该根节点，以此将树分为左子树和右子树。对于左子树和右子树，可以再分别在中序遍历和后序遍历中找到其根节点，以此类推。</p>\n<p>所以该问题可以使用递归的方式解决，每次递归时，先找到后序遍历的最后一个元素作为根节点，在中序遍历中找到该根节点，以此将树分为左子树和右子树。再分别递归左子树和右子树构建二叉树。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;\n        &#x2F;&#x2F; 创建根节点\n        TreeNode* root &#x3D; build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);\n        return root;\n    &#125;\n\n    TreeNode* build(vector&lt;int&gt;&amp; inorder, int inStart, int inEnd, vector&lt;int&gt;&amp; postorder, int postStart, int postEnd) &#123;\n      \t&#x2F;*\n            inorder：中序遍历序列；\n            postorder：后序遍历序列；\n            inStart：当前子树在中序遍历序列中的起始位置；\n            inEnd：当前子树在中序遍历序列中的结束位置；\n            postStart：当前子树在后序遍历序列中的起始位置；\n            postEnd：当前子树在后序遍历序列中的结束位置。\n        *&#x2F;\n        &#x2F;&#x2F; 特判： 若postStart &gt; postEnd时， 无节点需要处理，返回NULL\n        if (postStart &gt; postEnd) &#123;\n            return nullptr;\n        &#125;\n\n        &#x2F;&#x2F; 创建新的子树根节点\n        TreeNode* root &#x3D; new TreeNode(postorder[postEnd]); &#x2F;&#x2F; 后续遍历的最后一个元素一定是根节点\n\n        &#x2F;&#x2F; 在中序遍历中寻找当前子树根节点的位置\n        int inRootIndex &#x3D; inStart;\n        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;\n            inRootIndex++;\n        &#125;\n\n        &#x2F;&#x2F; 计算当前子树左子树的大小\n        int leftTreeSize &#x3D; inRootIndex - inStart;\n        \n        &#x2F;&#x2F; 根据根节点的位置， 分别递归构建左子树和右子树 \n        root-&gt;left &#x3D; build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);\n        root-&gt;right &#x3D; build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1); \n\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n<p>关于<code>root-&gt;left = build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);</code>和<code>root-&gt;right = build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1); </code>的解释：</p>\n<blockquote>\n<p>在中序遍历中找到了根节点的位置后，在中序遍历中根节点的左边就是左子树的中序遍历，根节点的右边就是右子树的中序遍历，在递归调用时，左子树的中序遍历的右边界指针指向根节点索引-1，同理右子树的中序遍历的左边界指针指向根节点索引+1；计算了左子树的大小之后，可以发现在后序遍历中，从最开始到左子树的大小-1的元素即为左子树对应的后序遍历，因此从最开始索引+左子树大小到最右边索引-1的后序遍历即为右子树的后序遍历，这样一直递归即可得到完整的左右子树，将子树同根节点连接，返回根节点即可得到完整的树。</p>\n</blockquote>\n<p>在整个递归的过程中，我们都不需要额外的空间来存储子数组，而是通过起始和结束下标来表示子数组。这种方式使得我们可以使用较少的空间来解决问题，并且在递归过程中也不需要频繁地拷贝数组，提高了算法的效率。</p>\n","more":"<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]\n输出：[3,9,20,null,null,15,7]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：inorder &#x3D; [-1], postorder &#x3D; [-1]\n输出：[-1]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n<li><code>postorder.length == inorder.length</code></li>\n<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n<li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li>\n<li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li>\n<li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li>\n<li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归构造</li>\n</ul>\n<p>根据题意，可以得知后序遍历的最后一个元素一定是树的根节点。然后可以在中序遍历中找到该根节点，以此将树分为左子树和右子树。对于左子树和右子树，可以再分别在中序遍历和后序遍历中找到其根节点，以此类推。</p>\n<p>所以该问题可以使用递归的方式解决，每次递归时，先找到后序遍历的最后一个元素作为根节点，在中序遍历中找到该根节点，以此将树分为左子树和右子树。再分别递归左子树和右子树构建二叉树。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;\n        &#x2F;&#x2F; 创建根节点\n        TreeNode* root &#x3D; build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);\n        return root;\n    &#125;\n\n    TreeNode* build(vector&lt;int&gt;&amp; inorder, int inStart, int inEnd, vector&lt;int&gt;&amp; postorder, int postStart, int postEnd) &#123;\n      \t&#x2F;*\n            inorder：中序遍历序列；\n            postorder：后序遍历序列；\n            inStart：当前子树在中序遍历序列中的起始位置；\n            inEnd：当前子树在中序遍历序列中的结束位置；\n            postStart：当前子树在后序遍历序列中的起始位置；\n            postEnd：当前子树在后序遍历序列中的结束位置。\n        *&#x2F;\n        &#x2F;&#x2F; 特判： 若postStart &gt; postEnd时， 无节点需要处理，返回NULL\n        if (postStart &gt; postEnd) &#123;\n            return nullptr;\n        &#125;\n\n        &#x2F;&#x2F; 创建新的子树根节点\n        TreeNode* root &#x3D; new TreeNode(postorder[postEnd]); &#x2F;&#x2F; 后续遍历的最后一个元素一定是根节点\n\n        &#x2F;&#x2F; 在中序遍历中寻找当前子树根节点的位置\n        int inRootIndex &#x3D; inStart;\n        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;\n            inRootIndex++;\n        &#125;\n\n        &#x2F;&#x2F; 计算当前子树左子树的大小\n        int leftTreeSize &#x3D; inRootIndex - inStart;\n        \n        &#x2F;&#x2F; 根据根节点的位置， 分别递归构建左子树和右子树 \n        root-&gt;left &#x3D; build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);\n        root-&gt;right &#x3D; build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1); \n\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n<p>关于<code>root-&gt;left = build(inorder, inStart, inRootIndex - 1, postorder, postStart, postStart + leftTreeSize - 1);</code>和<code>root-&gt;right = build(inorder, inRootIndex + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1); </code>的解释：</p>\n<blockquote>\n<p>在中序遍历中找到了根节点的位置后，在中序遍历中根节点的左边就是左子树的中序遍历，根节点的右边就是右子树的中序遍历，在递归调用时，左子树的中序遍历的右边界指针指向根节点索引-1，同理右子树的中序遍历的左边界指针指向根节点索引+1；计算了左子树的大小之后，可以发现在后序遍历中，从最开始到左子树的大小-1的元素即为左子树对应的后序遍历，因此从最开始索引+左子树大小到最右边索引-1的后序遍历即为右子树的后序遍历，这样一直递归即可得到完整的左右子树，将子树同根节点连接，返回根节点即可得到完整的树。</p>\n</blockquote>\n<p>在整个递归的过程中，我们都不需要额外的空间来存储子数组，而是通过起始和结束下标来表示子数组。这种方式使得我们可以使用较少的空间来解决问题，并且在递归过程中也不需要频繁地拷贝数组，提高了算法的效率。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}