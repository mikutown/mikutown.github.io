{"title":"leetcode106.从中序与后序遍历序列构造二叉树","slug":"leetcode106-从中序与后序遍历序列构造二叉树","date":"2023-03-15T09:27:14.000Z","updated":"2023-03-15T09:41:07.494Z","comments":true,"path":"api/articles/leetcode106-从中序与后序遍历序列构造二叉树.json","excerpt":"题目给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。","covers":["http://cdn.leafii.top/img/tree.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]\n输出：[3,9,20,null,null,15,7]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：inorder &#x3D; [-1], postorder &#x3D; [-1]\n输出：[-1]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n<li><code>postorder.length == inorder.length</code></li>\n<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n<li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li>\n<li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li>\n<li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li>\n<li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归构造</li>\n</ul>\n<p>根据题意，可以得知后序遍历的最后一个元素一定是树的根节点。然后可以在中序遍历中找到该根节点，以此将树分为左子树和右子树。对于左子树和右子树，可以再分别在中序遍历和后序遍历中找到其根节点，以此类推。</p>\n<p>所以该问题可以使用递归的方式解决，每次递归时，先找到后序遍历的最后一个元素作为根节点，在中序遍历中找到该根节点，以此将树分为左子树和右子树。再分别递归左子树和右子树构建二叉树。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;\n        return buildTreeHelper(inorder, postorder, 0, inorder.size()-1, 0, postorder.size()-1);\n    &#125;\n\n    TreeNode* buildTreeHelper(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int in_start, int in_end, int post_start, int post_end) &#123;\n        &#x2F;*\n            inorder：中序遍历序列；\n            postorder：后序遍历序列；\n            in_start：当前子树在中序遍历序列中的起始位置；\n            in_end：当前子树在中序遍历序列中的结束位置；\n            post_start：当前子树在后序遍历序列中的起始位置；\n            post_end：当前子树在后序遍历序列中的结束位置。\n        *&#x2F;\n        if (in_start &gt; in_end || post_start &gt; post_end) &#123;\n            &#x2F;&#x2F; base case: 树为空\n            return nullptr;\n        &#125;\n\n        int root_val &#x3D; postorder[post_end]; &#x2F;&#x2F; 后续遍历的最后一个元素一定是根节点\n        TreeNode* root &#x3D; new TreeNode(root_val);\n\n        &#x2F;&#x2F; 在中序遍历中找到根节点的位置\n        int root_pos &#x3D; 0;\n        for (int i &#x3D; in_start; i &lt;&#x3D; in_end; i++) &#123;\n            if (inorder[i] &#x3D;&#x3D; root_val) &#123;\n                root_pos &#x3D; i;\n                break;\n            &#125;\n        &#125;\n        \n        &#x2F;&#x2F; 根据根节点的位置， 分别递归构建左子树和右子树 \n        root-&gt;left &#x3D; buildTreeHelper(inorder, postorder, in_start, root_pos-1, post_start, post_start + root_pos - in_start - 1);\n        root-&gt;right &#x3D; buildTreeHelper(inorder, postorder, root_pos + 1, in_end, post_start + root_pos - in_start, post_end - 1);\n\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n<p>以 <code>inorder = [9,3,15,20,7]</code>，<code>postorder = [9,15,7,20,3]</code> 为例，来描述一下各个值的迭代过程。假设我们在第一次递归中，需要构建整棵二叉树。</p>\n<ol>\n<li><p>在 <code>buildTreeHelper</code> 函数中，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=0</code>，<code>in_end=4</code>，<code>post_start=0</code>，<code>post_end=4</code>。</p>\n</li>\n<li><p>因为 <code>postorder</code> 的最后一个元素是当前子树的根节点，所以我们可以根据 <code>postorder[post_end-1]</code> 得到根节点的值，即 <code>root_val=3</code>。</p>\n</li>\n<li><p>我们在 <code>inorder</code> 数组中查找根节点的位置，得到 <code>root_pos=1</code>。由此，我们可以确定当前子树的左子树和右子树在 <code>inorder</code> 数组中的范围，即左子树为 <code>inorder[in_start, root_pos-1]</code>，右子树为 <code>inorder[root_pos+1, in_end]</code>。</p>\n</li>\n<li><p>接下来，我们需要递归构建当前子树的左子树和右子树。对于左子树，我们需要在 <code>postorder</code> 数组中找到它的后序遍历序列，即从 <code>post_start</code> 开始，长度为左子树在中序遍历序列中节点个数的那段子数组。因此，左子树的后序遍历序列为 <code>postorder[post_start, post_start+root_pos-in_start-1]</code>。</p>\n</li>\n<li><p>对于右子树，我们同样需要在 <code>postorder</code> 数组中找到它的后序遍历序列，即从左子树后面一个位置 <code>post_start+root_pos-in_start</code> 开始，长度为右子树在中序遍历序列中节点个数的那段子数组。因此，右子树的后序遍历序列为 <code>postorder[post_start+root_pos-in_start, post_end-1]</code>。</p>\n</li>\n<li><p>接下来，我们递归构建当前子树的左子树和右子树。对于左子树，我们调用 <code>buildTreeHelper</code> 函数，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=0</code>，<code>in_end=0+1-1=0</code>，<code>post_start=0</code>，<code>post_end=0+1-1=0</code>。由于 <code>in_start</code> 大于 <code>in_end</code>，说明左子树为空，因此我们返回 <code>nullptr</code>，表示当前子树的左子树为空。</p>\n</li>\n<li><p>对于右子树，我们同样调用 <code>buildTreeHelper</code> 函数，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=1+1=2</code>，<code>in_end=4</code>，<code>post_start=0+1=1</code>，<code>post_end=4-1=3</code>。在右子树的递归中，我们同样可以先找到根节点的值 <code>root_val=20</code>，然后在 <code>inorder</code> 数组中查找根节点的位置，得到 <code>root_pos=3</code>。因此，右子树的左子树在 <code>inorder</code> 数组中的范围为 <code>inorder[2,2]</code>，右子树的右子树在 <code>inorder</code> 数组中的范围为 <code>inorder[4,4]</code>。</p>\n</li>\n<li><p>对于右子树的左子树，我们可以先计算出它在 <code>postorder</code> 数组中的后序遍历序列，即从 <code>post_start</code> 开始，长度为左子树在中序遍历序列中节点个数的那段子数组。因此，右子树的左子树的后序遍历序列为 <code>postorder[post_start, post_start+root_pos-in_start-1]</code>，即 <code>postorder[1,2]</code>。在右子树的递归中，我们调用 <code>buildTreeHelper</code> 函数，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=2</code>，<code>in_end=2</code>，<code>post_start=1</code>，<code>post_end=1+2-2=1</code>。由于 <code>in_start</code> 等于 <code>in_end</code>，说明当前子树只有一个节点，即叶子节点，因此我们创建一个节点，将其值赋为 <code>9</code>，并返回。</p>\n</li>\n<li><p>对于右子树的右子树，我们同样可以计算出它在 <code>postorder</code> 数组中的后序遍历序列，即从左子树后面一个位置 <code>post_start+root_pos-in_start</code> 开始，长度为右子树在中序遍历序列中节点个数的那段子数组。因此，右子树的右子树的后序遍历序列为 <code>postorder[post_start+root_pos-in_start, post_end-1]</code>，即 <code>postorder[3,3]</code>。在右子树的递归中，我们调用 <code>buildTreeHelper</code> 函数，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=4</code>，<code>in_end=4</code>，<code>post_start=3</code>，<code>post_end=3</code>。由于 <code>in_start</code> 等于 <code>in_end</code>，说明当前子树只有一个节点，即叶子节点，因此我们创建一个节点，将其值赋为 <code>7</code>，并返回。</p>\n</li>\n<li><p>接下来，我们回到右子树的递归中，将返回的左子树和右子树节点挂到当前根节点的左右节点上，最终返回根节点 <code>root</code>。整个过程结束。</p>\n<p>在整个递归的过程中，我们都不需要额外的空间来存储子数组，而是通过起始和结束下标来表示子数组。这种方式使得我们可以使用较少的空间来解决问题，并且在递归过程中也不需要频繁地拷贝数组，提高了算法的效率。</p>\n</li>\n</ol>\n","more":"<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]\n输出：[3,9,20,null,null,15,7]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：inorder &#x3D; [-1], postorder &#x3D; [-1]\n输出：[-1]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n<li><code>postorder.length == inorder.length</code></li>\n<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n<li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li>\n<li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li>\n<li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li>\n<li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归构造</li>\n</ul>\n<p>根据题意，可以得知后序遍历的最后一个元素一定是树的根节点。然后可以在中序遍历中找到该根节点，以此将树分为左子树和右子树。对于左子树和右子树，可以再分别在中序遍历和后序遍历中找到其根节点，以此类推。</p>\n<p>所以该问题可以使用递归的方式解决，每次递归时，先找到后序遍历的最后一个元素作为根节点，在中序遍历中找到该根节点，以此将树分为左子树和右子树。再分别递归左子树和右子树构建二叉树。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;\n        return buildTreeHelper(inorder, postorder, 0, inorder.size()-1, 0, postorder.size()-1);\n    &#125;\n\n    TreeNode* buildTreeHelper(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int in_start, int in_end, int post_start, int post_end) &#123;\n        &#x2F;*\n            inorder：中序遍历序列；\n            postorder：后序遍历序列；\n            in_start：当前子树在中序遍历序列中的起始位置；\n            in_end：当前子树在中序遍历序列中的结束位置；\n            post_start：当前子树在后序遍历序列中的起始位置；\n            post_end：当前子树在后序遍历序列中的结束位置。\n        *&#x2F;\n        if (in_start &gt; in_end || post_start &gt; post_end) &#123;\n            &#x2F;&#x2F; base case: 树为空\n            return nullptr;\n        &#125;\n\n        int root_val &#x3D; postorder[post_end]; &#x2F;&#x2F; 后续遍历的最后一个元素一定是根节点\n        TreeNode* root &#x3D; new TreeNode(root_val);\n\n        &#x2F;&#x2F; 在中序遍历中找到根节点的位置\n        int root_pos &#x3D; 0;\n        for (int i &#x3D; in_start; i &lt;&#x3D; in_end; i++) &#123;\n            if (inorder[i] &#x3D;&#x3D; root_val) &#123;\n                root_pos &#x3D; i;\n                break;\n            &#125;\n        &#125;\n        \n        &#x2F;&#x2F; 根据根节点的位置， 分别递归构建左子树和右子树 \n        root-&gt;left &#x3D; buildTreeHelper(inorder, postorder, in_start, root_pos-1, post_start, post_start + root_pos - in_start - 1);\n        root-&gt;right &#x3D; buildTreeHelper(inorder, postorder, root_pos + 1, in_end, post_start + root_pos - in_start, post_end - 1);\n\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n<p>以 <code>inorder = [9,3,15,20,7]</code>，<code>postorder = [9,15,7,20,3]</code> 为例，来描述一下各个值的迭代过程。假设我们在第一次递归中，需要构建整棵二叉树。</p>\n<ol>\n<li><p>在 <code>buildTreeHelper</code> 函数中，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=0</code>，<code>in_end=4</code>，<code>post_start=0</code>，<code>post_end=4</code>。</p>\n</li>\n<li><p>因为 <code>postorder</code> 的最后一个元素是当前子树的根节点，所以我们可以根据 <code>postorder[post_end-1]</code> 得到根节点的值，即 <code>root_val=3</code>。</p>\n</li>\n<li><p>我们在 <code>inorder</code> 数组中查找根节点的位置，得到 <code>root_pos=1</code>。由此，我们可以确定当前子树的左子树和右子树在 <code>inorder</code> 数组中的范围，即左子树为 <code>inorder[in_start, root_pos-1]</code>，右子树为 <code>inorder[root_pos+1, in_end]</code>。</p>\n</li>\n<li><p>接下来，我们需要递归构建当前子树的左子树和右子树。对于左子树，我们需要在 <code>postorder</code> 数组中找到它的后序遍历序列，即从 <code>post_start</code> 开始，长度为左子树在中序遍历序列中节点个数的那段子数组。因此，左子树的后序遍历序列为 <code>postorder[post_start, post_start+root_pos-in_start-1]</code>。</p>\n</li>\n<li><p>对于右子树，我们同样需要在 <code>postorder</code> 数组中找到它的后序遍历序列，即从左子树后面一个位置 <code>post_start+root_pos-in_start</code> 开始，长度为右子树在中序遍历序列中节点个数的那段子数组。因此，右子树的后序遍历序列为 <code>postorder[post_start+root_pos-in_start, post_end-1]</code>。</p>\n</li>\n<li><p>接下来，我们递归构建当前子树的左子树和右子树。对于左子树，我们调用 <code>buildTreeHelper</code> 函数，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=0</code>，<code>in_end=0+1-1=0</code>，<code>post_start=0</code>，<code>post_end=0+1-1=0</code>。由于 <code>in_start</code> 大于 <code>in_end</code>，说明左子树为空，因此我们返回 <code>nullptr</code>，表示当前子树的左子树为空。</p>\n</li>\n<li><p>对于右子树，我们同样调用 <code>buildTreeHelper</code> 函数，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=1+1=2</code>，<code>in_end=4</code>，<code>post_start=0+1=1</code>，<code>post_end=4-1=3</code>。在右子树的递归中，我们同样可以先找到根节点的值 <code>root_val=20</code>，然后在 <code>inorder</code> 数组中查找根节点的位置，得到 <code>root_pos=3</code>。因此，右子树的左子树在 <code>inorder</code> 数组中的范围为 <code>inorder[2,2]</code>，右子树的右子树在 <code>inorder</code> 数组中的范围为 <code>inorder[4,4]</code>。</p>\n</li>\n<li><p>对于右子树的左子树，我们可以先计算出它在 <code>postorder</code> 数组中的后序遍历序列，即从 <code>post_start</code> 开始，长度为左子树在中序遍历序列中节点个数的那段子数组。因此，右子树的左子树的后序遍历序列为 <code>postorder[post_start, post_start+root_pos-in_start-1]</code>，即 <code>postorder[1,2]</code>。在右子树的递归中，我们调用 <code>buildTreeHelper</code> 函数，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=2</code>，<code>in_end=2</code>，<code>post_start=1</code>，<code>post_end=1+2-2=1</code>。由于 <code>in_start</code> 等于 <code>in_end</code>，说明当前子树只有一个节点，即叶子节点，因此我们创建一个节点，将其值赋为 <code>9</code>，并返回。</p>\n</li>\n<li><p>对于右子树的右子树，我们同样可以计算出它在 <code>postorder</code> 数组中的后序遍历序列，即从左子树后面一个位置 <code>post_start+root_pos-in_start</code> 开始，长度为右子树在中序遍历序列中节点个数的那段子数组。因此，右子树的右子树的后序遍历序列为 <code>postorder[post_start+root_pos-in_start, post_end-1]</code>，即 <code>postorder[3,3]</code>。在右子树的递归中，我们调用 <code>buildTreeHelper</code> 函数，传入 <code>inorder</code> 和 <code>postorder</code> 数组的起始和结束下标，即 <code>in_start=4</code>，<code>in_end=4</code>，<code>post_start=3</code>，<code>post_end=3</code>。由于 <code>in_start</code> 等于 <code>in_end</code>，说明当前子树只有一个节点，即叶子节点，因此我们创建一个节点，将其值赋为 <code>7</code>，并返回。</p>\n</li>\n<li><p>接下来，我们回到右子树的递归中，将返回的左子树和右子树节点挂到当前根节点的左右节点上，最终返回根节点 <code>root</code>。整个过程结束。</p>\n<p>在整个递归的过程中，我们都不需要额外的空间来存储子数组，而是通过起始和结束下标来表示子数组。这种方式使得我们可以使用较少的空间来解决问题，并且在递归过程中也不需要频繁地拷贝数组，提高了算法的效率。</p>\n</li>\n</ol>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}