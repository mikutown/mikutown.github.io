{"title":"leetcode347.前K个高频元素","slug":"leetcode347-前K个高频元素","date":"2023-12-14T12:01:34.000Z","updated":"2023-12-14T12:52:17.169Z","comments":true,"path":"api/articles/leetcode347-前K个高频元素.json","excerpt":"题目给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\n输出: [1,2]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1], k &#x3D; 1\n输出: [1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>\n<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>\n</ul>\n<p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用hashmap辅助</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;\n        map&lt;int, int&gt; m; &#x2F;&#x2F; 创建一个用于存储数字频率的映射（键为数字，值为出现的次数）\n        for (int num : nums) &#123;\n            m[num] &#x3D; m[num] &#x3D;&#x3D; 0 ? 1 : m[num] + 1; &#x2F;&#x2F; 统计每个数字的出现次数\n        &#125;\n        vector&lt;std::pair&lt;int, int&gt;&gt; vec(m.begin(), m.end()); &#x2F;&#x2F; 将映射转换为包含键值对的向量\n        sort(vec.begin(), vec.end(), [](const std::pair&lt;int, int&gt;&amp; a, const std::pair&lt;int, int&gt;&amp; b) &#123;\n            return a.second &gt; b.second; &#x2F;&#x2F; 按值（出现次数）降序排序\n        &#125;);\n        vector&lt;int&gt; results;\n        for (int i &#x3D; 0; i &lt; k; i++) &#123;\n            results.push_back(vec[i].first); &#x2F;&#x2F; 获取前k个频率最高的数字\n        &#125;\n        return results;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>代码优化</li>\n</ol>\n<blockquote>\n<ol>\n<li>**使用 <code>unordered_map</code> 而不是 <code>map</code>**：<code>unordered_map</code> 通常比 <code>map</code> 更快，因为 <code>unordered_map</code> 使用哈希表实现，而 <code>map</code> 使用平衡树。这在频繁插入和查找时尤其有用。</li>\n<li><strong>简化元素计数</strong>：你可以直接使用 <code>++m[num]</code> 来增加计数，无需检查元素是否存在。</li>\n<li><strong>使用优先队列（最小堆）</strong>：使用优先队列而不是对整个向量排序可以减少时间复杂度。只保留前 k 个最频繁的元素，这样不需要对所有元素进行排序。</li>\n</ol>\n</blockquote>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;\n        &#x2F;&#x2F; 使用 unordered_map 来计数\n        unordered_map&lt;int, int&gt; count_map;\n        for (int num : nums) &#123;\n            ++count_map[num];\n        &#125;\n\n        &#x2F;&#x2F; 定义一个最小堆\n        auto comp &#x3D; [&amp;count_map](int n1, int n2) &#123;\n            return count_map[n1] &gt; count_map[n2];\n        &#125;;\n        priority_queue&lt;int, vector&lt;int&gt;, decltype(comp)&gt; heap(comp);\n\n        &#x2F;&#x2F; 保持堆的大小为 k\n        for (auto &amp;p : count_map) &#123;\n            heap.push(p.first);\n            if (heap.size() &gt; k) &#123;\n                heap.pop();\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 从堆中提取元素\n        vector&lt;int&gt; results;\n        while (!heap.empty()) &#123;\n            results.push_back(heap.top());\n            heap.pop();\n        &#125;\n        reverse(results.begin(), results.end()); &#x2F;&#x2F; 将结果反转为正确的顺序\n        return results;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\n输出: [1,2]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1], k &#x3D; 1\n输出: [1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>\n<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>\n</ul>\n<p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用hashmap辅助</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;\n        map&lt;int, int&gt; m; &#x2F;&#x2F; 创建一个用于存储数字频率的映射（键为数字，值为出现的次数）\n        for (int num : nums) &#123;\n            m[num] &#x3D; m[num] &#x3D;&#x3D; 0 ? 1 : m[num] + 1; &#x2F;&#x2F; 统计每个数字的出现次数\n        &#125;\n        vector&lt;std::pair&lt;int, int&gt;&gt; vec(m.begin(), m.end()); &#x2F;&#x2F; 将映射转换为包含键值对的向量\n        sort(vec.begin(), vec.end(), [](const std::pair&lt;int, int&gt;&amp; a, const std::pair&lt;int, int&gt;&amp; b) &#123;\n            return a.second &gt; b.second; &#x2F;&#x2F; 按值（出现次数）降序排序\n        &#125;);\n        vector&lt;int&gt; results;\n        for (int i &#x3D; 0; i &lt; k; i++) &#123;\n            results.push_back(vec[i].first); &#x2F;&#x2F; 获取前k个频率最高的数字\n        &#125;\n        return results;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>代码优化</li>\n</ol>\n<blockquote>\n<ol>\n<li>**使用 <code>unordered_map</code> 而不是 <code>map</code>**：<code>unordered_map</code> 通常比 <code>map</code> 更快，因为 <code>unordered_map</code> 使用哈希表实现，而 <code>map</code> 使用平衡树。这在频繁插入和查找时尤其有用。</li>\n<li><strong>简化元素计数</strong>：你可以直接使用 <code>++m[num]</code> 来增加计数，无需检查元素是否存在。</li>\n<li><strong>使用优先队列（最小堆）</strong>：使用优先队列而不是对整个向量排序可以减少时间复杂度。只保留前 k 个最频繁的元素，这样不需要对所有元素进行排序。</li>\n</ol>\n</blockquote>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;\n        &#x2F;&#x2F; 使用 unordered_map 来计数\n        unordered_map&lt;int, int&gt; count_map;\n        for (int num : nums) &#123;\n            ++count_map[num];\n        &#125;\n\n        &#x2F;&#x2F; 定义一个最小堆\n        auto comp &#x3D; [&amp;count_map](int n1, int n2) &#123;\n            return count_map[n1] &gt; count_map[n2];\n        &#125;;\n        priority_queue&lt;int, vector&lt;int&gt;, decltype(comp)&gt; heap(comp);\n\n        &#x2F;&#x2F; 保持堆的大小为 k\n        for (auto &amp;p : count_map) &#123;\n            heap.push(p.first);\n            if (heap.size() &gt; k) &#123;\n                heap.pop();\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 从堆中提取元素\n        vector&lt;int&gt; results;\n        while (!heap.empty()) &#123;\n            results.push_back(heap.top());\n            heap.pop();\n        &#125;\n        reverse(results.begin(), results.end()); &#x2F;&#x2F; 将结果反转为正确的顺序\n        return results;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}