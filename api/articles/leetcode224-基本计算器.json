{"title":"leetcode224.基本计算器","slug":"leetcode224-基本计算器","date":"2023-04-19T14:40:16.000Z","updated":"2023-04-20T02:08:21.251Z","comments":true,"path":"api/articles/leetcode224-基本计算器.json","excerpt":"题目给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>\n<p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;1 + 1&quot;\n输出：2</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot; 2-1 + 2 &quot;\n输出：3</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;\n输出：23</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>\n<li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li>\n<li><code>s</code> 表示一个有效的表达式</li>\n<li>‘+’ 不能用作一元运算(例如， “+1” 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</li>\n<li>‘-‘ 可以用作一元运算(即 “-1” 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</li>\n<li>输入中不存在两个连续的操作符</li>\n<li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>题目要求实现一个计算器，计算一个字符串表达式的值。因为表达式中可能会存在括号，为了方便计算，可以使用递归的方法来实现。当遇到左括号时，递归调用自身来计算括号内的表达式值，当遇到右括号时，返回计算结果。当遇到加号或减号时，记录当前的操作符。当遇到数字时，记录当前的数值，并根据之前的操作符进行相应的计算。</p>\n<p>具体步骤如下：</p>\n<ol>\n<li>定义一个辅助栈，用于存储之前的操作符和数字；</li>\n<li>遍历表达式字符串，遇到数字时记录下来，遇到左括号时递归调用自身，遇到右括号时返回计算结果；</li>\n<li>遇到加号或减号时，记录当前的操作符，遇到其他字符时忽略；</li>\n<li>当遇到表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，并返回最终结果。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int calculate(string s) &#123;\n        stack&lt;int&gt; st;  &#x2F;&#x2F; 定义一个辅助栈，用于存储之前的操作符和数字\n        int num &#x3D; 0;  &#x2F;&#x2F; 用于记录当前的数值\n        int res &#x3D; 0;  &#x2F;&#x2F; 用于记录最终结果\n        int sign &#x3D; 1;  &#x2F;&#x2F; 用于记录当前的操作符，1表示加号，-1表示减号\n        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if (isdigit(s[i])) &#123;  &#x2F;&#x2F; 如果当前字符是数字\n                num &#x3D; num * 10 + (s[i] - &#39;0&#39;);  &#x2F;&#x2F; 记录当前的数值\n            &#125; else if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;  &#x2F;&#x2F; 如果当前字符是左括号\n                int j &#x3D; i, cnt &#x3D; 0;\n                for (; i &lt; s.size(); i++) &#123;\n                    if (s[i] &#x3D;&#x3D; &#39;(&#39;) cnt++;\n                    if (s[i] &#x3D;&#x3D; &#39;)&#39;) cnt--;\n                    if (cnt &#x3D;&#x3D; 0) break;\n                &#125;\n                num &#x3D; calculate(s.substr(j + 1, i - j - 1));  &#x2F;&#x2F; 递归调用自身计算括号内的表达式值\n            &#125;\n            if (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;  &#x2F;&#x2F; 如果当前字符是加号或减号，或者已经遍历到表达式字符串的末尾\n                if (s[i] &#x3D;&#x3D; &#39;+&#39;) &#123;\n                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中\n                    sign &#x3D; 1;  &#x2F;&#x2F; 更新操作符为加号\n                &#125; else if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123;\n                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中\n                    sign &#x3D; -1;  &#x2F;&#x2F; 更新操作符为减号\n                &#125; else if (s[i] &#x3D;&#x3D; &#39;)&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;\n                    st.push(sign * num);  &#x2F;&#x2F; 将最后一个数值乘上当前的操作符，并压入栈中\n                    int tmp &#x3D; 0;\n                    while (!st.empty()) &#123;  &#x2F;&#x2F; 从栈中取出数字和操作符进行计算，直到栈为空\n                        tmp +&#x3D; st.top();\n                        st.pop();\n                    &#125;\n                    res &#x3D; tmp;  &#x2F;&#x2F; 更新最终结果\n                &#125;\n                num &#x3D; 0;  &#x2F;&#x2F; 清空当前的数值\n            &#125;\n        &#125;\n        return res;  &#x2F;&#x2F; 返回最终结果\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>上述代码使用了一个栈来存储之前的数字和操作符，用于最后的计算。遇到左括号时，递归调用自身计算括号内的表达式值。遇到加号或减号时，记录当前的操作符和数字，当遇到右括号或表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，得到最终结果。</p>\n</blockquote>\n<p>需要注意的是，在遇到左括号时，需要找到对应的右括号位置，才能正确地计算括号内的表达式值。这里使用了一个变量cnt来记录遍历到的左括号数量和右括号数量的差值，当cnt为0时，说明找到了对应的右括号。</p>\n<p>另外，需要注意的是，当遍历到表达式字符串的末尾时，也需要将之前记录的数字和操作符进行计算，得到最终结果。因此，在遍历完表达式字符串后，还需要进行一次栈中剩余数字和操作符的计算，以得到最终结果。</p>\n<p>最后，需要注意对于操作数可能有多个位数的情况，需要在遍历字符串时将多位数字组合成一个完整的数值。这里使用了一个变量num来记录当前的数值，每次遍历到数字时，将其乘以10并加上当前位的数值即可。</p>\n<p>综上所述，上述代码实现了一个简单的基本计算器，可以计算表达式中的加减法和括号，并返回最终结果。</p>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;1 + 1&quot;\n输出：2</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot; 2-1 + 2 &quot;\n输出：3</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;\n输出：23</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>\n<li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li>\n<li><code>s</code> 表示一个有效的表达式</li>\n<li>‘+’ 不能用作一元运算(例如， “+1” 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</li>\n<li>‘-‘ 可以用作一元运算(即 “-1” 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</li>\n<li>输入中不存在两个连续的操作符</li>\n<li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>题目要求实现一个计算器，计算一个字符串表达式的值。因为表达式中可能会存在括号，为了方便计算，可以使用递归的方法来实现。当遇到左括号时，递归调用自身来计算括号内的表达式值，当遇到右括号时，返回计算结果。当遇到加号或减号时，记录当前的操作符。当遇到数字时，记录当前的数值，并根据之前的操作符进行相应的计算。</p>\n<p>具体步骤如下：</p>\n<ol>\n<li>定义一个辅助栈，用于存储之前的操作符和数字；</li>\n<li>遍历表达式字符串，遇到数字时记录下来，遇到左括号时递归调用自身，遇到右括号时返回计算结果；</li>\n<li>遇到加号或减号时，记录当前的操作符，遇到其他字符时忽略；</li>\n<li>当遇到表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，并返回最终结果。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int calculate(string s) &#123;\n        stack&lt;int&gt; st;  &#x2F;&#x2F; 定义一个辅助栈，用于存储之前的操作符和数字\n        int num &#x3D; 0;  &#x2F;&#x2F; 用于记录当前的数值\n        int res &#x3D; 0;  &#x2F;&#x2F; 用于记录最终结果\n        int sign &#x3D; 1;  &#x2F;&#x2F; 用于记录当前的操作符，1表示加号，-1表示减号\n        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if (isdigit(s[i])) &#123;  &#x2F;&#x2F; 如果当前字符是数字\n                num &#x3D; num * 10 + (s[i] - &#39;0&#39;);  &#x2F;&#x2F; 记录当前的数值\n            &#125; else if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;  &#x2F;&#x2F; 如果当前字符是左括号\n                int j &#x3D; i, cnt &#x3D; 0;\n                for (; i &lt; s.size(); i++) &#123;\n                    if (s[i] &#x3D;&#x3D; &#39;(&#39;) cnt++;\n                    if (s[i] &#x3D;&#x3D; &#39;)&#39;) cnt--;\n                    if (cnt &#x3D;&#x3D; 0) break;\n                &#125;\n                num &#x3D; calculate(s.substr(j + 1, i - j - 1));  &#x2F;&#x2F; 递归调用自身计算括号内的表达式值\n            &#125;\n            if (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;  &#x2F;&#x2F; 如果当前字符是加号或减号，或者已经遍历到表达式字符串的末尾\n                if (s[i] &#x3D;&#x3D; &#39;+&#39;) &#123;\n                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中\n                    sign &#x3D; 1;  &#x2F;&#x2F; 更新操作符为加号\n                &#125; else if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123;\n                    st.push(sign * num);  &#x2F;&#x2F; 将之前记录的数值乘上当前的操作符，并压入栈中\n                    sign &#x3D; -1;  &#x2F;&#x2F; 更新操作符为减号\n                &#125; else if (s[i] &#x3D;&#x3D; &#39;)&#39; || i &#x3D;&#x3D; s.size() - 1) &#123;\n                    st.push(sign * num);  &#x2F;&#x2F; 将最后一个数值乘上当前的操作符，并压入栈中\n                    int tmp &#x3D; 0;\n                    while (!st.empty()) &#123;  &#x2F;&#x2F; 从栈中取出数字和操作符进行计算，直到栈为空\n                        tmp +&#x3D; st.top();\n                        st.pop();\n                    &#125;\n                    res &#x3D; tmp;  &#x2F;&#x2F; 更新最终结果\n                &#125;\n                num &#x3D; 0;  &#x2F;&#x2F; 清空当前的数值\n            &#125;\n        &#125;\n        return res;  &#x2F;&#x2F; 返回最终结果\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>上述代码使用了一个栈来存储之前的数字和操作符，用于最后的计算。遇到左括号时，递归调用自身计算括号内的表达式值。遇到加号或减号时，记录当前的操作符和数字，当遇到右括号或表达式字符串的末尾时，将栈中剩余的数字和操作符进行计算，得到最终结果。</p>\n</blockquote>\n<p>需要注意的是，在遇到左括号时，需要找到对应的右括号位置，才能正确地计算括号内的表达式值。这里使用了一个变量cnt来记录遍历到的左括号数量和右括号数量的差值，当cnt为0时，说明找到了对应的右括号。</p>\n<p>另外，需要注意的是，当遍历到表达式字符串的末尾时，也需要将之前记录的数字和操作符进行计算，得到最终结果。因此，在遍历完表达式字符串后，还需要进行一次栈中剩余数字和操作符的计算，以得到最终结果。</p>\n<p>最后，需要注意对于操作数可能有多个位数的情况，需要在遍历字符串时将多位数字组合成一个完整的数值。这里使用了一个变量num来记录当前的数值，每次遍历到数字时，将其乘以10并加上当前位的数值即可。</p>\n<p>综上所述，上述代码实现了一个简单的基本计算器，可以计算表达式中的加减法和括号，并返回最终结果。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}