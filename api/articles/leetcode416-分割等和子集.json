{"title":"leetcode416.分割等和子集","slug":"leetcode416-分割等和子集","date":"2023-04-25T02:19:47.000Z","updated":"2023-04-25T02:27:22.334Z","comments":true,"path":"api/articles/leetcode416-分割等和子集.json","excerpt":"题目给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>\n <span id=\"more\"></span>\n\n<p>示例 1：</p>\n<p>输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br>示例 2：</p>\n<p>输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p>\n<p>提示：</p>\n<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这个解法使用了动态规划。具体来说，我们首先计算数组中所有数字的总和。如果总和是奇数，那么无法分成等和子集，直接返回 false。否则，我们就要找到一个子集，使得它的和等于总和的一半，也就是说，我们要在数组中选择一些数字，使得它们的和等于 target。</p>\n<p>我们使用 dp 数组来记录 target 是否可以被分成等和子集。dp[i] 表示 target 为 i 时的情况，dp[i] &#x3D; true 表示 target 可以被分成等和子集，否则为 false。</p>\n<p>对于每一个数字 num，我们遍历 dp 数组的范围是 [target, num]，并且更新状态。具体来说，如果 dp[i - num] 为 true，那么 dp[i] 也为 true，因为我们可以在 dp[i - num] 的基础上加上 num 得到 dp[i]。最后，我们返回 dp[target]，判断是否可以分成等和子集。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int sum &#x3D; 0;\n        for (int num : nums) &#123;\n            sum +&#x3D; num;\n        &#125;\n        if (sum % 2 !&#x3D; 0) &#123;  &#x2F;&#x2F; 如果总和是奇数，无法分成等和子集\n            return false;\n        &#125;\n        int target &#x3D; sum &#x2F; 2;\n        vector&lt;bool&gt; dp(target + 1, false);  &#x2F;&#x2F; 创建一个长度为target+1的vector\n        dp[0] &#x3D; true;  &#x2F;&#x2F; target为0的情况是可以满足的\n        for (int num : nums) &#123;\n            for (int i &#x3D; target; i &gt;&#x3D; num; i--) &#123;  &#x2F;&#x2F; 遍历可选数字的范围是[target, num]\n                dp[i] &#x3D; dp[i] || dp[i - num];  &#x2F;&#x2F; 状态转移方程\n            &#125;\n        &#125;\n        return dp[target];  &#x2F;&#x2F; 返回target是否可以被分成等和子集\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p><code> dp[i] = dp[i] || dp[i - num];</code>是一个状态转移方程，表示当前状态 dp[i] 是否可以被满足。dp[i] 初始值为 false，如果 dp[i - num] 为 true，也就是说前面已经找到了一组数字使得它们的和等于 i - num，那么我们只需要在这个基础上再加上 num，就可以得到一组数字使得它们的和等于 i，于是我们可以将 dp[i] 设置为 true。</p>\n<p>这里使用了逻辑或运算符（<code>||</code>），如果 dp[i] 本来就是 true，那么 dp[i] 的值不会改变，因为或运算符的两个操作数有一个为 true，结果就是 true。如果 dp[i - num] 为 false，那么 dp[i] 仍然是 false。</p>\n</blockquote>\n","more":"<p>示例 1：</p>\n<p>输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br>示例 2：</p>\n<p>输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p>\n<p>提示：</p>\n<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这个解法使用了动态规划。具体来说，我们首先计算数组中所有数字的总和。如果总和是奇数，那么无法分成等和子集，直接返回 false。否则，我们就要找到一个子集，使得它的和等于总和的一半，也就是说，我们要在数组中选择一些数字，使得它们的和等于 target。</p>\n<p>我们使用 dp 数组来记录 target 是否可以被分成等和子集。dp[i] 表示 target 为 i 时的情况，dp[i] &#x3D; true 表示 target 可以被分成等和子集，否则为 false。</p>\n<p>对于每一个数字 num，我们遍历 dp 数组的范围是 [target, num]，并且更新状态。具体来说，如果 dp[i - num] 为 true，那么 dp[i] 也为 true，因为我们可以在 dp[i - num] 的基础上加上 num 得到 dp[i]。最后，我们返回 dp[target]，判断是否可以分成等和子集。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int sum &#x3D; 0;\n        for (int num : nums) &#123;\n            sum +&#x3D; num;\n        &#125;\n        if (sum % 2 !&#x3D; 0) &#123;  &#x2F;&#x2F; 如果总和是奇数，无法分成等和子集\n            return false;\n        &#125;\n        int target &#x3D; sum &#x2F; 2;\n        vector&lt;bool&gt; dp(target + 1, false);  &#x2F;&#x2F; 创建一个长度为target+1的vector\n        dp[0] &#x3D; true;  &#x2F;&#x2F; target为0的情况是可以满足的\n        for (int num : nums) &#123;\n            for (int i &#x3D; target; i &gt;&#x3D; num; i--) &#123;  &#x2F;&#x2F; 遍历可选数字的范围是[target, num]\n                dp[i] &#x3D; dp[i] || dp[i - num];  &#x2F;&#x2F; 状态转移方程\n            &#125;\n        &#125;\n        return dp[target];  &#x2F;&#x2F; 返回target是否可以被分成等和子集\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p><code> dp[i] = dp[i] || dp[i - num];</code>是一个状态转移方程，表示当前状态 dp[i] 是否可以被满足。dp[i] 初始值为 false，如果 dp[i - num] 为 true，也就是说前面已经找到了一组数字使得它们的和等于 i - num，那么我们只需要在这个基础上再加上 num，就可以得到一组数字使得它们的和等于 i，于是我们可以将 dp[i] 设置为 true。</p>\n<p>这里使用了逻辑或运算符（<code>||</code>），如果 dp[i] 本来就是 true，那么 dp[i] 的值不会改变，因为或运算符的两个操作数有一个为 true，结果就是 true。如果 dp[i - num] 为 false，那么 dp[i] 仍然是 false。</p>\n</blockquote>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}