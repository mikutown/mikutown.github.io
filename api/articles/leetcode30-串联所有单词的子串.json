{"title":"leetcode30.串联所有单词的子串","slug":"leetcode30-串联所有单词的子串","date":"2023-10-20T01:56:52.000Z","updated":"2023-10-20T02:28:14.763Z","comments":true,"path":"api/articles/leetcode30-串联所有单词的子串.json","excerpt":"题目给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。 s 中的 串联子串 是指一个包含 words 中所有字符串以任意顺序排列连接起来的子串。例如，如果 words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]， 那么 &quot;abcdef&quot;， &quot;abefcd&quot;，&quot;cdabef&quot;， &quot;cdefab&quot;，&quot;efabcd&quot;， 和 &quot;efcdab&quot; 都是串联子串。 &quot;acdbef&quot; 不是串联子串，因为他不是任何 words 排列的连接。返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p>\n<p> <code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p>\n<ul>\n<li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li>\n</ul>\n<p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;barfoothefoobarman&quot;, words &#x3D; [&quot;foo&quot;,&quot;bar&quot;]\n输出：[0,9]\n解释：因为 words.length &#x3D;&#x3D; 2 同时 words[i].length &#x3D;&#x3D; 3，连接的子字符串的长度必须为 6。\n子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。\n子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;wordgoodgoodgoodbestword&quot;, words &#x3D; [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]\n输出：[]\n解释：因为 words.length &#x3D;&#x3D; 4 并且 words[i].length &#x3D;&#x3D; 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;barfoofoobarthefoobarman&quot;, words &#x3D; [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]\n输出：[6,9,12]\n解释：因为 words.length &#x3D;&#x3D; 3 并且 words[i].length &#x3D;&#x3D; 3，所以串联子串的长度必须为 9。\n子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。\n子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。\n子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 104</code></li>\n<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n<li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>滑动窗口</li>\n</ul>\n<p>此题是438.找到字符串中所有字母异位词的进阶版。不同的是第 438 题的元素是字母，而此题的元素是单词。可以用类似438.找到字符串中所有字母异位词的官方题解的方法二的滑动窗口来解这题。<br>记 words 的长度为 m，words 中每个单词的长度为n，s 的长度为 ls。首先需要将  s划分为单词组，每个单词的大小均为 n(首尾除外) 。这样的划分方法有 n 种，即先删去前  i(i&#x3D;0~n-1)个字后，将剩下字母进行划分，如果未尾有不到 n 个字母也删去。对这 n 种划分得到的单词数组分别使用滑动窗口对 words行类似于字母异位词的搜寻。<br>划分成单词组后，一个窗口包含 s 中前 m 个单词，用一个哈希表 dier 表示窗口中单词频次和 ords 中单词频次之差。初始化 differ 时，出现在窗口中的单词，每出现一次，相应的值增加 1，出现在 ords 中的单词,每出现一次，相应的值减少 1。然后将窗口右移，右侧会加入一个单词，左侧会移出一个单词，并对 differ 做应的更新。窗口移动时，若出现 differ 中值不为 0 的键的数量为 0，则表示这个窗口中的单词频次和 words 中单词频次相同，窗口的左端点是一个待求的起始位置。划分的方法有n种，做n次滑动窗口后，即可找到所有的起始位置。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; findSubstring(string &amp;s, vector&lt;string&gt; &amp;words) &#123;\n        vector&lt;int&gt; res;  &#x2F;&#x2F; 存储最终结果的向量\n\n        int m &#x3D; words.size();  &#x2F;&#x2F; words中单词的数量\n        int n &#x3D; words[0].size();  &#x2F;&#x2F; 单个单词的长度\n        int ls &#x3D; s.size();  &#x2F;&#x2F; 字符串s的总长度\n\n        &#x2F;&#x2F; 遍历s中的所有可能的起始位置，确保不越界\n        for (int i &#x3D; 0; i &lt; n &amp;&amp; i + m * n &lt;&#x3D; ls; ++i) &#123;\n            unordered_map&lt;string, int&gt; differ;  &#x2F;&#x2F; 存储与words中单词的不同之处\n\n            &#x2F;&#x2F; 遍历words中的单词，统计它们在当前窗口中的出现次数\n            for (int j &#x3D; 0; j &lt; m; ++j) &#123;\n                ++differ[s.substr(i + j * n, n)]; \n            &#125;\n\n            &#x2F;&#x2F; 对于每个单词，减少其在differ中的计数，如果计数减为0则从differ中移除\n            for (string &amp;word: words) &#123;\n                if (--differ[word] &#x3D;&#x3D; 0) &#123;\n                    differ.erase(word);\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 移动窗口，开始查找可能的匹配\n            for (int start &#x3D; i; start &lt; ls - m * n + 1; start +&#x3D; n) &#123;\n                if (start !&#x3D; i) &#123;\n                    &#x2F;&#x2F; 更新differ，添加新单词并移除旧单词\n                    string word &#x3D; s.substr(start + (m - 1) * n, n);\n                    if (++differ[word] &#x3D;&#x3D; 0) &#123;\n                        differ.erase(word);\n                    &#125;\n                    word &#x3D; s.substr(start - n, n);\n                    if (--differ[word] &#x3D;&#x3D; 0) &#123;\n                        differ.erase(word);\n                    &#125;\n                &#125;\n\n                &#x2F;&#x2F; 如果differ为空，说明当前窗口中的单词与words中的单词匹配\n                if (differ.empty()) &#123;\n                    res.emplace_back(start);  &#x2F;&#x2F; 将匹配的起始位置添加到结果中\n                &#125;\n            &#125;\n        &#125;\n\n        return res;  &#x2F;&#x2F; 返回最终结果\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;barfoothefoobarman&quot;, words &#x3D; [&quot;foo&quot;,&quot;bar&quot;]\n输出：[0,9]\n解释：因为 words.length &#x3D;&#x3D; 2 同时 words[i].length &#x3D;&#x3D; 3，连接的子字符串的长度必须为 6。\n子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。\n子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;wordgoodgoodgoodbestword&quot;, words &#x3D; [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]\n输出：[]\n解释：因为 words.length &#x3D;&#x3D; 4 并且 words[i].length &#x3D;&#x3D; 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;barfoofoobarthefoobarman&quot;, words &#x3D; [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]\n输出：[6,9,12]\n解释：因为 words.length &#x3D;&#x3D; 3 并且 words[i].length &#x3D;&#x3D; 3，所以串联子串的长度必须为 9。\n子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。\n子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。\n子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 104</code></li>\n<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n<li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>滑动窗口</li>\n</ul>\n<p>此题是438.找到字符串中所有字母异位词的进阶版。不同的是第 438 题的元素是字母，而此题的元素是单词。可以用类似438.找到字符串中所有字母异位词的官方题解的方法二的滑动窗口来解这题。<br>记 words 的长度为 m，words 中每个单词的长度为n，s 的长度为 ls。首先需要将  s划分为单词组，每个单词的大小均为 n(首尾除外) 。这样的划分方法有 n 种，即先删去前  i(i&#x3D;0~n-1)个字后，将剩下字母进行划分，如果未尾有不到 n 个字母也删去。对这 n 种划分得到的单词数组分别使用滑动窗口对 words行类似于字母异位词的搜寻。<br>划分成单词组后，一个窗口包含 s 中前 m 个单词，用一个哈希表 dier 表示窗口中单词频次和 ords 中单词频次之差。初始化 differ 时，出现在窗口中的单词，每出现一次，相应的值增加 1，出现在 ords 中的单词,每出现一次，相应的值减少 1。然后将窗口右移，右侧会加入一个单词，左侧会移出一个单词，并对 differ 做应的更新。窗口移动时，若出现 differ 中值不为 0 的键的数量为 0，则表示这个窗口中的单词频次和 words 中单词频次相同，窗口的左端点是一个待求的起始位置。划分的方法有n种，做n次滑动窗口后，即可找到所有的起始位置。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; findSubstring(string &amp;s, vector&lt;string&gt; &amp;words) &#123;\n        vector&lt;int&gt; res;  &#x2F;&#x2F; 存储最终结果的向量\n\n        int m &#x3D; words.size();  &#x2F;&#x2F; words中单词的数量\n        int n &#x3D; words[0].size();  &#x2F;&#x2F; 单个单词的长度\n        int ls &#x3D; s.size();  &#x2F;&#x2F; 字符串s的总长度\n\n        &#x2F;&#x2F; 遍历s中的所有可能的起始位置，确保不越界\n        for (int i &#x3D; 0; i &lt; n &amp;&amp; i + m * n &lt;&#x3D; ls; ++i) &#123;\n            unordered_map&lt;string, int&gt; differ;  &#x2F;&#x2F; 存储与words中单词的不同之处\n\n            &#x2F;&#x2F; 遍历words中的单词，统计它们在当前窗口中的出现次数\n            for (int j &#x3D; 0; j &lt; m; ++j) &#123;\n                ++differ[s.substr(i + j * n, n)]; \n            &#125;\n\n            &#x2F;&#x2F; 对于每个单词，减少其在differ中的计数，如果计数减为0则从differ中移除\n            for (string &amp;word: words) &#123;\n                if (--differ[word] &#x3D;&#x3D; 0) &#123;\n                    differ.erase(word);\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 移动窗口，开始查找可能的匹配\n            for (int start &#x3D; i; start &lt; ls - m * n + 1; start +&#x3D; n) &#123;\n                if (start !&#x3D; i) &#123;\n                    &#x2F;&#x2F; 更新differ，添加新单词并移除旧单词\n                    string word &#x3D; s.substr(start + (m - 1) * n, n);\n                    if (++differ[word] &#x3D;&#x3D; 0) &#123;\n                        differ.erase(word);\n                    &#125;\n                    word &#x3D; s.substr(start - n, n);\n                    if (--differ[word] &#x3D;&#x3D; 0) &#123;\n                        differ.erase(word);\n                    &#125;\n                &#125;\n\n                &#x2F;&#x2F; 如果differ为空，说明当前窗口中的单词与words中的单词匹配\n                if (differ.empty()) &#123;\n                    res.emplace_back(start);  &#x2F;&#x2F; 将匹配的起始位置添加到结果中\n                &#125;\n            &#125;\n        &#125;\n\n        return res;  &#x2F;&#x2F; 返回最终结果\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[]}