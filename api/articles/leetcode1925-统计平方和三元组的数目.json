{"title":"leetcode1925.统计平方和三元组的数目","slug":"leetcode1925-统计平方和三元组的数目","date":"2023-05-15T10:10:26.000Z","updated":"2023-05-15T10:41:13.437Z","comments":true,"path":"api/articles/leetcode1925-统计平方和三元组的数目.json","excerpt":"题目一个 平方和三元组 (a,b,c) 指的是满足 a2 + b2 = c2 的 整数 三元组 a，b 和 c 。给你一个整数 n ，请你返回满足 1 &lt;= a, b, c &lt;= n 的 平方和三元组 的数目。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>一个 <strong>平方和三元组</strong> <code>(a,b,c)</code> 指的是满足 <code>a2 + b2 = c2</code> 的 <strong>整数</strong> 三元组 <code>a</code>，<code>b</code> 和 <code>c</code> 。</p>\n<p>给你一个整数 <code>n</code> ，请你返回满足 <code>1 &lt;= a, b, c &lt;= n</code> 的 <strong>平方和三元组</strong> 的数目。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 5\n输出：2\n解释：平方和三元组为 (3,4,5) 和 (4,3,5) 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 10\n输出：4\n解释：平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 250</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力枚举</li>\n</ul>\n<p>直接进行枚举即可。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int countTriples(int n) &#123;\n        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量\n        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n\n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n\n                for (int c &#x3D; b + 1; c &lt;&#x3D; n; c++) &#123;  &#x2F;&#x2F; 遍历c的范围从b+1到n\n                    if (a * a + b * b &#x3D;&#x3D; c * c) &#123;  &#x2F;&#x2F; 检查是否满足勾股定理\n                        cnt +&#x3D; 2;  &#x2F;&#x2F; 满足条件的三元组数量加2\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>通过固定C降低时间复杂度</li>\n</ul>\n<p>暴力枚举法的复杂度为O(n^3)，我们可以对其进行一些优化，比如固定c，只保留a和b的循环。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int countTriples(int n) &#123;\n        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量\n        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n\n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n\n                int c_square &#x3D; a * a + b * b; &#x2F;&#x2F;  定义c_square&#x3D;a*a+b*b\n                int c &#x3D; sqrt(c_square); &#x2F;&#x2F; 得到整型的变量c，其值为c_square的平方根 \n                if (c &lt;&#x3D; n &amp;&amp; c * c &#x3D;&#x3D; c_square) &#123; &#x2F;&#x2F; 因为c是被强制转换成int类型进行存储的，所以不仅要判断c是否小于n还要确定c的平方确实等于c_square\n                    cnt +&#x3D; 2; &#x2F;&#x2F; 若符合要求，则cnt+&#x3D;2 比如（3，4，5）和（4，3，5）只判断一次，但cnt+&#x3D;2；\n                &#125;\n            &#125;\n        &#125;\n        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 5\n输出：2\n解释：平方和三元组为 (3,4,5) 和 (4,3,5) 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 10\n输出：4\n解释：平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 250</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力枚举</li>\n</ul>\n<p>直接进行枚举即可。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int countTriples(int n) &#123;\n        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量\n        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n\n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n\n                for (int c &#x3D; b + 1; c &lt;&#x3D; n; c++) &#123;  &#x2F;&#x2F; 遍历c的范围从b+1到n\n                    if (a * a + b * b &#x3D;&#x3D; c * c) &#123;  &#x2F;&#x2F; 检查是否满足勾股定理\n                        cnt +&#x3D; 2;  &#x2F;&#x2F; 满足条件的三元组数量加2\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>通过固定C降低时间复杂度</li>\n</ul>\n<p>暴力枚举法的复杂度为O(n^3)，我们可以对其进行一些优化，比如固定c，只保留a和b的循环。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int countTriples(int n) &#123;\n        int cnt &#x3D; 0;  &#x2F;&#x2F; 计数器，用于记录满足条件的三元组数量\n        for (int a &#x3D; 1; a &lt;&#x3D; n; a++) &#123;  &#x2F;&#x2F; 遍历a的范围从1到n\n            for (int b &#x3D; a + 1; b &lt;&#x3D; n; b++) &#123;  &#x2F;&#x2F; 遍历b的范围从a+1到n\n                int c_square &#x3D; a * a + b * b; &#x2F;&#x2F;  定义c_square&#x3D;a*a+b*b\n                int c &#x3D; sqrt(c_square); &#x2F;&#x2F; 得到整型的变量c，其值为c_square的平方根 \n                if (c &lt;&#x3D; n &amp;&amp; c * c &#x3D;&#x3D; c_square) &#123; &#x2F;&#x2F; 因为c是被强制转换成int类型进行存储的，所以不仅要判断c是否小于n还要确定c的平方确实等于c_square\n                    cnt +&#x3D; 2; &#x2F;&#x2F; 若符合要求，则cnt+&#x3D;2 比如（3，4，5）和（4，3，5）只判断一次，但cnt+&#x3D;2；\n                &#125;\n            &#125;\n        &#125;\n        return cnt;  &#x2F;&#x2F; 返回满足条件的三元组数量\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}