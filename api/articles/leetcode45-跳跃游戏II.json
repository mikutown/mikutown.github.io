{"title":"leetcode45.跳跃游戏II","slug":"leetcode45-跳跃游戏II","date":"2023-02-21T06:38:37.000Z","updated":"2023-02-21T06:43:08.348Z","comments":true,"path":"api/articles/leetcode45-跳跃游戏II.json","excerpt":"题目给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:0 &lt;= j &lt;= nums[i] i + j &lt; n返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>\n<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>\n<ul>\n<li><code>0 &lt;= j &lt;= nums[i]</code> </li>\n<li><code>i + j &lt; n</code></li>\n</ul>\n<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [2,3,1,1,4]\n输出: 2\n解释: 跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [2,3,0,1,4]\n输出: 2</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n<li>题目保证可以到达 <code>nums[n-1]</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>贪心算法</li>\n</ol>\n<p>算法思路是：遍历数组，用变量 <code>max_pos</code> 记录当前能够到达的最远位置，用变量 <code>end_pos</code> 记录当前步数下能够到达的最远位置，如果遍历到 <code>end_pos</code>，则更新 <code>end_pos</code> 为 <code>max_pos</code>，并将步数加 1。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (n &#x3D;&#x3D; 1) return 0; &#x2F;&#x2F; 如果数组只有一个元素，返回 0\n        int steps &#x3D; 0, max_pos &#x3D; 0, end_pos &#x3D; 0;\n        &#x2F;&#x2F; steps：跳跃的步数，max_pos：当前能够到达的最远位置，end_pos：当前步数下能够到达的最远位置\n        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;\n            &#x2F;&#x2F; 遍历数组，到达 n - 1 时不需要再跳跃，因为已经到达了终点\n            max_pos &#x3D; max(max_pos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远位置\n            if (i &#x3D;&#x3D; end_pos) &#123; &#x2F;&#x2F; 如果到达了当前步数下能够到达的最远位置，需要增加步数\n                end_pos &#x3D; max_pos; &#x2F;&#x2F; 更新当前步数下能够到达的最远位置\n                steps++; &#x2F;&#x2F; 增加步数\n            &#125;\n        &#125;\n        return steps; &#x2F;&#x2F; 返回跳跃的步数\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [2,3,1,1,4]\n输出: 2\n解释: 跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [2,3,0,1,4]\n输出: 2</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n<li>题目保证可以到达 <code>nums[n-1]</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>贪心算法</li>\n</ol>\n<p>算法思路是：遍历数组，用变量 <code>max_pos</code> 记录当前能够到达的最远位置，用变量 <code>end_pos</code> 记录当前步数下能够到达的最远位置，如果遍历到 <code>end_pos</code>，则更新 <code>end_pos</code> 为 <code>max_pos</code>，并将步数加 1。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (n &#x3D;&#x3D; 1) return 0; &#x2F;&#x2F; 如果数组只有一个元素，返回 0\n        int steps &#x3D; 0, max_pos &#x3D; 0, end_pos &#x3D; 0;\n        &#x2F;&#x2F; steps：跳跃的步数，max_pos：当前能够到达的最远位置，end_pos：当前步数下能够到达的最远位置\n        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;\n            &#x2F;&#x2F; 遍历数组，到达 n - 1 时不需要再跳跃，因为已经到达了终点\n            max_pos &#x3D; max(max_pos, i + nums[i]); &#x2F;&#x2F; 更新能够到达的最远位置\n            if (i &#x3D;&#x3D; end_pos) &#123; &#x2F;&#x2F; 如果到达了当前步数下能够到达的最远位置，需要增加步数\n                end_pos &#x3D; max_pos; &#x2F;&#x2F; 更新当前步数下能够到达的最远位置\n                steps++; &#x2F;&#x2F; 增加步数\n            &#125;\n        &#125;\n        return steps; &#x2F;&#x2F; 返回跳跃的步数\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}