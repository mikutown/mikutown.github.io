{"title":"leetcode968.监控二叉树","slug":"leetcode968-监控二叉树","date":"2023-03-29T06:23:53.000Z","updated":"2023-03-29T06:43:47.729Z","comments":true,"path":"api/articles/leetcode968-监控二叉树.json","excerpt":"题目给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。","covers":["http://cdn.leafii.top/img/bst_cameras_01.png","http://cdn.leafii.top/img/bst_cameras_02.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p>\n<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>\n<p>计算监控树的所有节点所需的最小摄像头数量。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/bst_cameras_01.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：[0,0,null,0,0]\n输出：1\n解释：如图所示，一台摄像头足以监控所有节点。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/bst_cameras_02.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：[0,0,null,0,null,0,null,null,0]\n输出：2\n解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre>\n\n\n<p><strong>提示：</strong></p>\n<ol>\n<li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li>\n<li>每个节点的值都是 0。</li>\n</ol>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>贪心算法</li>\n</ul>\n<p>本题是一道贪心算法的题目。通过对题目进行分析，我们可以发现有以下几种情况：</p>\n<p>1.如果一个节点没有被监控，那么它必须要安装一个摄像头。</p>\n<p>2.如果一个节点安装了摄像头，那么它的父节点就可以被监控了。</p>\n<p>3.如果一个节点的子节点被监控了，那么这个节点也可以被监控。</p>\n<p>因此，我们可以采用自下而上的方式进行处理，从叶子节点开始向根节点进行处理。对于每个节点，我们可以有三种状态：</p>\n<p>0：该节点没有装摄像头，且它的子节点中也没有装摄像头的节点，此时应该给他装一个摄像头。</p>\n<p>1：该节点没有装摄像头，但是它的子节点中至少有一个装摄像头的节点，此时应该给他的父节点装一个摄像头。</p>\n<p>2：该节点装摄像头了，因此它无需再安装一个摄像头。</p>\n<p>对于每个节点，我们可以采用递归的方式进行处理。当节点为叶子节点时，它的状态为0。对于其他节点，如果它的子节点中存在状态为0的节点，那么该节点的状态为1，表示需要安装摄像头。如果它的子节点中都存在状态为1或2的节点，那么该节点的状态为0，表示不需要安装摄像头，但是它的父节点需要安装摄像头。如果它的子节点中存在状态为2的节点，那么该节点的状态为1，表示不需要安装摄像头，因为它的子节点已经可以覆盖它了。</p>\n<p>最后，根据根节点的状态来判断是否需要安装摄像头。如果根节点的状态为0或1，那么需要安装一个摄像头。如果根节点的状态为2，那么不需要安装摄像头。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int minCameraCover(TreeNode* root) &#123;\n        int res &#x3D; 0;\n        if (dfs(root, res) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 根节点未被监控\n            res++;\n        &#125;\n        return res;\n    &#125;\n\n    int dfs(TreeNode* node, int&amp; res) &#123;\n        if (node &#x3D;&#x3D; nullptr) &#123;\n            return 2; &#x2F;&#x2F; 空节点不需要监控，返回2\n        &#125;\n        int left &#x3D; dfs(node-&gt;left, res);\n        int right &#x3D; dfs(node-&gt;right, res);\n        if (left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 左右子节点有未被监控的节点，该节点需要安装摄像头\n            res++; &#x2F;&#x2F; 安装了摄像头\n            return 1; &#x2F;&#x2F; return 1是指该节点没有被监控，但是它的子节点中至少有一个被监控的节点。\n        &#125; else if (left &#x3D;&#x3D; 1 || right &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 左右子节点中至少有一个节点被监控\n            return 2; &#x2F;&#x2F; return 2是指该节点被监控了。\n        &#125; else &#123; &#x2F;&#x2F; 左右子节点均被监控\n            return 0; &#x2F;&#x2F; return 0是指该节点没有装摄像头\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>其中，dfs函数的返回值为当前节点的状态。如果返回值为0，表示当前节点需要安装摄像头；如果返回值为1，表示当前节点不需要安装摄像头，但是它的父节点需要安装摄像头；如果返回值为2，表示当前节点不需要安装摄像头。res为引用类型，表示安装摄像头的数量。</p>\n</blockquote>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/bst_cameras_01.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：[0,0,null,0,0]\n输出：1\n解释：如图所示，一台摄像头足以监控所有节点。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/bst_cameras_02.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：[0,0,null,0,null,0,null,null,0]\n输出：2\n解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre>\n\n\n<p><strong>提示：</strong></p>\n<ol>\n<li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li>\n<li>每个节点的值都是 0。</li>\n</ol>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>贪心算法</li>\n</ul>\n<p>本题是一道贪心算法的题目。通过对题目进行分析，我们可以发现有以下几种情况：</p>\n<p>1.如果一个节点没有被监控，那么它必须要安装一个摄像头。</p>\n<p>2.如果一个节点安装了摄像头，那么它的父节点就可以被监控了。</p>\n<p>3.如果一个节点的子节点被监控了，那么这个节点也可以被监控。</p>\n<p>因此，我们可以采用自下而上的方式进行处理，从叶子节点开始向根节点进行处理。对于每个节点，我们可以有三种状态：</p>\n<p>0：该节点没有装摄像头，且它的子节点中也没有装摄像头的节点，此时应该给他装一个摄像头。</p>\n<p>1：该节点没有装摄像头，但是它的子节点中至少有一个装摄像头的节点，此时应该给他的父节点装一个摄像头。</p>\n<p>2：该节点装摄像头了，因此它无需再安装一个摄像头。</p>\n<p>对于每个节点，我们可以采用递归的方式进行处理。当节点为叶子节点时，它的状态为0。对于其他节点，如果它的子节点中存在状态为0的节点，那么该节点的状态为1，表示需要安装摄像头。如果它的子节点中都存在状态为1或2的节点，那么该节点的状态为0，表示不需要安装摄像头，但是它的父节点需要安装摄像头。如果它的子节点中存在状态为2的节点，那么该节点的状态为1，表示不需要安装摄像头，因为它的子节点已经可以覆盖它了。</p>\n<p>最后，根据根节点的状态来判断是否需要安装摄像头。如果根节点的状态为0或1，那么需要安装一个摄像头。如果根节点的状态为2，那么不需要安装摄像头。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int minCameraCover(TreeNode* root) &#123;\n        int res &#x3D; 0;\n        if (dfs(root, res) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 根节点未被监控\n            res++;\n        &#125;\n        return res;\n    &#125;\n\n    int dfs(TreeNode* node, int&amp; res) &#123;\n        if (node &#x3D;&#x3D; nullptr) &#123;\n            return 2; &#x2F;&#x2F; 空节点不需要监控，返回2\n        &#125;\n        int left &#x3D; dfs(node-&gt;left, res);\n        int right &#x3D; dfs(node-&gt;right, res);\n        if (left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 左右子节点有未被监控的节点，该节点需要安装摄像头\n            res++; &#x2F;&#x2F; 安装了摄像头\n            return 1; &#x2F;&#x2F; return 1是指该节点没有被监控，但是它的子节点中至少有一个被监控的节点。\n        &#125; else if (left &#x3D;&#x3D; 1 || right &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 左右子节点中至少有一个节点被监控\n            return 2; &#x2F;&#x2F; return 2是指该节点被监控了。\n        &#125; else &#123; &#x2F;&#x2F; 左右子节点均被监控\n            return 0; &#x2F;&#x2F; return 0是指该节点没有装摄像头\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>其中，dfs函数的返回值为当前节点的状态。如果返回值为0，表示当前节点需要安装摄像头；如果返回值为1，表示当前节点不需要安装摄像头，但是它的父节点需要安装摄像头；如果返回值为2，表示当前节点不需要安装摄像头。res为引用类型，表示安装摄像头的数量。</p>\n</blockquote>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}