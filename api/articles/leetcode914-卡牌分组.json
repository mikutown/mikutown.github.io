{"title":"leetcode914.卡牌分组","slug":"leetcode914-卡牌分组","date":"2023-10-30T08:57:10.000Z","updated":"2023-10-30T08:58:48.058Z","comments":true,"path":"api/articles/leetcode914-卡牌分组.json","excerpt":"题目给定一副牌，每张牌上都写着一个整数。此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：每组都有 X 张牌。组内所有的牌上都写着相同的整数。仅当你可选的 X &gt;= 2 时返回 true。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一副牌，每张牌上都写着一个整数。</p>\n<p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>\n<ul>\n<li>每组都有 <code>X</code> 张牌。</li>\n<li>组内所有的牌上都写着相同的整数。</li>\n</ul>\n<p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：deck &#x3D; [1,2,3,4,4,3,2,1]\n输出：true\n解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：deck &#x3D; [1,1,1,2,2,2,3,3]\n输出：false\n解释：没有满足要求的分组。</code></pre>\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= deck.length &lt;= 104</code></li>\n<li><code>0 &lt;= deck[i] &lt; 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>使用哈希表+最小公约数解决</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) &#123;\n        unordered_map&lt;int, int&gt; deck_map; &#x2F;&#x2F; 用于统计牌的数量\n        int n &#x3D; deck.size();\n        for(int num:deck) &#123;\n            deck_map[num]++; &#x2F;&#x2F; 统计牌的数量\n        &#125;\n        int gcd &#x3D; 0; &#x2F;&#x2F; 初始化最大公约数\n        for (const auto&amp; entry : deck_map) &#123;\n            gcd &#x3D; __gcd(gcd, entry.second); &#x2F;&#x2F; 最大公约数更新\n        &#125;\n        return gcd &gt;&#x3D; 2; &#x2F;&#x2F; 符合题目条件时才返回true\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：deck &#x3D; [1,2,3,4,4,3,2,1]\n输出：true\n解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：deck &#x3D; [1,1,1,2,2,2,3,3]\n输出：false\n解释：没有满足要求的分组。</code></pre>\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= deck.length &lt;= 104</code></li>\n<li><code>0 &lt;= deck[i] &lt; 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>使用哈希表+最小公约数解决</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) &#123;\n        unordered_map&lt;int, int&gt; deck_map; &#x2F;&#x2F; 用于统计牌的数量\n        int n &#x3D; deck.size();\n        for(int num:deck) &#123;\n            deck_map[num]++; &#x2F;&#x2F; 统计牌的数量\n        &#125;\n        int gcd &#x3D; 0; &#x2F;&#x2F; 初始化最大公约数\n        for (const auto&amp; entry : deck_map) &#123;\n            gcd &#x3D; __gcd(gcd, entry.second); &#x2F;&#x2F; 最大公约数更新\n        &#125;\n        return gcd &gt;&#x3D; 2; &#x2F;&#x2F; 符合题目条件时才返回true\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[]}