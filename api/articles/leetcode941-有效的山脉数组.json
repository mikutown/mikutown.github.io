{"title":"leetcode941.有效的山脉数组","slug":"leetcode941-有效的山脉数组","date":"2023-08-07T03:18:14.000Z","updated":"2023-08-07T03:52:55.709Z","comments":true,"path":"api/articles/leetcode941-有效的山脉数组.json","excerpt":"题目给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。","covers":["http://cdn.leafii.top/img/hint_valid_mountain_array.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个整数数组 <code>arr</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<span id=\"more\"></span>\n\n<p>让我们回顾一下，如果 <code>arr</code> 满足下述条件，那么它是一个山脉数组：</p>\n<ul>\n<li><p><code>arr.length &gt;= 3</code></p>\n</li>\n<li><p>在 </p>\n<pre class=\"language-none\"><code class=\"language-none\">0 &lt; i &lt; arr.length - 1</code></pre>\n\n<p> 条件下，存在 </p>\n<pre class=\"language-none\"><code class=\"language-none\">i</code></pre>\n\n<p> 使得：</p>\n<ul>\n<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://cdn.leafii.top/img/hint_valid_mountain_array.png\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [2,1]\n输出：false</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [3,5,5]\n输出：false</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [0,3,2,1]\n输出：true</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= arr.length &lt;= 104</code></li>\n<li><code>0 &lt;= arr[i] &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<p>首先获取数组中最大的数字以及下标，然后对下标进行判断，符合条件（数组大小超过2并且最大值不是数组的第一个元素或者最后一个元素）时进行第二次循环，循环时判断相邻元素是否满足递增或者递减的关系。C++实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool validMountainArray(vector&lt;int&gt;&amp; arr) &#123;\n        &#x2F;&#x2F; 得到最大值\n        int maxNum &#x3D; -1;\n        int maxIndex &#x3D; -1;\n        int n &#x3D; arr.size();\n        if (n &lt; 3) return false;\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            if (arr[i] &gt; maxNum) &#123;\n                maxNum &#x3D; arr[i];\n                maxIndex &#x3D; i;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 得到最大值后进行一部分判断然后进行循环\n        if (maxIndex &#x3D;&#x3D; n-1 || maxIndex &#x3D;&#x3D; 0) return false;\n\n        for (int i &#x3D; 0; i &lt; maxIndex; i++) &#123;\n            if (arr[i] &gt;&#x3D; arr[i + 1]) return false;\n        &#125;\n        for (int i &#x3D; maxIndex; i &lt; n - 1; i++) &#123;\n            if (arr[i] &lt;&#x3D; arr[i + 1]) return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>只扫描一次的解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool validMountainArray(vector&lt;int&gt;&amp; A) &#123;\n        int n &#x3D; A.size();\n        \n        &#x2F;&#x2F; 山脉数组必须至少有3个元素\n        if (n &lt; 3) &#123;\n            return false;\n        &#125;\n        \n        int i &#x3D; 0;\n        \n        &#x2F;&#x2F; 从左侧递增部分开始扫描\n        while (i &lt; n - 1 &amp;&amp; A[i] &lt; A[i + 1]) &#123;\n            i++;\n        &#125;\n        \n        &#x2F;&#x2F; 如果i是数组的第一个元素或者最后一个元素，说明没有递增或递减的足够元素\n        if (i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) &#123;\n            return false;\n        &#125;\n        \n        &#x2F;&#x2F; 扫描递减部分\n        while (i &lt; n - 1 &amp;&amp; A[i] &gt; A[i + 1]) &#123;\n            i++;\n        &#125;\n        \n        &#x2F;&#x2F; 如果i已经到达数组的末尾，说明是有效的山脉数组\n        return i &#x3D;&#x3D; n - 1;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p>让我们回顾一下，如果 <code>arr</code> 满足下述条件，那么它是一个山脉数组：</p>\n<ul>\n<li><p><code>arr.length &gt;= 3</code></p>\n</li>\n<li><p>在 </p>\n<pre class=\"language-none\"><code class=\"language-none\">0 &lt; i &lt; arr.length - 1</code></pre>\n\n<p> 条件下，存在 </p>\n<pre class=\"language-none\"><code class=\"language-none\">i</code></pre>\n\n<p> 使得：</p>\n<ul>\n<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://cdn.leafii.top/img/hint_valid_mountain_array.png\" alt=\"img\"></p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [2,1]\n输出：false</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [3,5,5]\n输出：false</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [0,3,2,1]\n输出：true</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= arr.length &lt;= 104</code></li>\n<li><code>0 &lt;= arr[i] &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<p>首先获取数组中最大的数字以及下标，然后对下标进行判断，符合条件（数组大小超过2并且最大值不是数组的第一个元素或者最后一个元素）时进行第二次循环，循环时判断相邻元素是否满足递增或者递减的关系。C++实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool validMountainArray(vector&lt;int&gt;&amp; arr) &#123;\n        &#x2F;&#x2F; 得到最大值\n        int maxNum &#x3D; -1;\n        int maxIndex &#x3D; -1;\n        int n &#x3D; arr.size();\n        if (n &lt; 3) return false;\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            if (arr[i] &gt; maxNum) &#123;\n                maxNum &#x3D; arr[i];\n                maxIndex &#x3D; i;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 得到最大值后进行一部分判断然后进行循环\n        if (maxIndex &#x3D;&#x3D; n-1 || maxIndex &#x3D;&#x3D; 0) return false;\n\n        for (int i &#x3D; 0; i &lt; maxIndex; i++) &#123;\n            if (arr[i] &gt;&#x3D; arr[i + 1]) return false;\n        &#125;\n        for (int i &#x3D; maxIndex; i &lt; n - 1; i++) &#123;\n            if (arr[i] &lt;&#x3D; arr[i + 1]) return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>只扫描一次的解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool validMountainArray(vector&lt;int&gt;&amp; A) &#123;\n        int n &#x3D; A.size();\n        \n        &#x2F;&#x2F; 山脉数组必须至少有3个元素\n        if (n &lt; 3) &#123;\n            return false;\n        &#125;\n        \n        int i &#x3D; 0;\n        \n        &#x2F;&#x2F; 从左侧递增部分开始扫描\n        while (i &lt; n - 1 &amp;&amp; A[i] &lt; A[i + 1]) &#123;\n            i++;\n        &#125;\n        \n        &#x2F;&#x2F; 如果i是数组的第一个元素或者最后一个元素，说明没有递增或递减的足够元素\n        if (i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) &#123;\n            return false;\n        &#125;\n        \n        &#x2F;&#x2F; 扫描递减部分\n        while (i &lt; n - 1 &amp;&amp; A[i] &gt; A[i + 1]) &#123;\n            i++;\n        &#125;\n        \n        &#x2F;&#x2F; 如果i已经到达数组的末尾，说明是有效的山脉数组\n        return i &#x3D;&#x3D; n - 1;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}