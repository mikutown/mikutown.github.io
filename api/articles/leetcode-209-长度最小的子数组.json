{"title":"leetcode:209.长度最小的子数组","slug":"leetcode-209-长度最小的子数组","date":"2023-02-07T11:43:53.000Z","updated":"2023-02-07T11:49:11.488Z","comments":true,"path":"api/articles/leetcode-209-长度最小的子数组.json","excerpt":"题目给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>\n<p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：target &#x3D; 4, nums &#x3D; [1,4,4]\n输出：1</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= target &lt;= 109</code></li>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>滑动窗口法</li>\n</ol>\n<p>直接使用双重for循环会超时，因此在这里使用滑动窗口的思想，在一个for循环中解决问题，在for循环中索引值为窗口的右边界。当<code>sum &gt;= target</code>时，窗口左边的指针进行右移，同时<code>sum -= nums[i++]</code>，最终遍历结束就得到了左指针和右指针的最终位置。结果为右指针-左指针+1.</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;\n        int sum &#x3D; 0;\n        int n &#x3D; nums.size();\n        for (int num : nums) &#123;\n            if (num &#x3D;&#x3D; target) &#123;\n                return 1; &#x2F;&#x2F;若数组中有包含target的值，直接返回1\n            &#125;\n            sum +&#x3D; num;\n        &#125;\n        if (sum &lt; target) &#123;\n            return 0; &#x2F;&#x2F;若数组所有正数之和均小于target，则直接返回0\n        &#125;else if (sum &#x3D;&#x3D; target) &#123;\n            return nums.size();&#x2F;&#x2F;若数组所有正数之和刚好等于target，则直接返回数组的长度\n        &#125;else &#123;\n            int result &#x3D; INT32_MAX;&#x2F;&#x2F;初始化为int的最大值\n            int sum &#x3D; 0;\n            int i &#x3D; 0;\n            int subLength &#x3D; 0;\n            for(int j &#x3D; 0; j &lt; nums.size(); j++) &#123; &#x2F;&#x2F;窗口右边界\n                sum +&#x3D; nums[j];\n                while (sum &gt;&#x3D; target) &#123;\n                    subLength &#x3D; j - i + 1;\n                    result &#x3D; result &lt; subLength? result:subLength;\n                    sum -&#x3D; nums[i++]; &#x2F;&#x2F;滑动窗口\n                &#125;\n            &#125;\n            return result;\n        &#125;\n        return 0;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：target &#x3D; 4, nums &#x3D; [1,4,4]\n输出：1</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= target &lt;= 109</code></li>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>滑动窗口法</li>\n</ol>\n<p>直接使用双重for循环会超时，因此在这里使用滑动窗口的思想，在一个for循环中解决问题，在for循环中索引值为窗口的右边界。当<code>sum &gt;= target</code>时，窗口左边的指针进行右移，同时<code>sum -= nums[i++]</code>，最终遍历结束就得到了左指针和右指针的最终位置。结果为右指针-左指针+1.</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;\n        int sum &#x3D; 0;\n        int n &#x3D; nums.size();\n        for (int num : nums) &#123;\n            if (num &#x3D;&#x3D; target) &#123;\n                return 1; &#x2F;&#x2F;若数组中有包含target的值，直接返回1\n            &#125;\n            sum +&#x3D; num;\n        &#125;\n        if (sum &lt; target) &#123;\n            return 0; &#x2F;&#x2F;若数组所有正数之和均小于target，则直接返回0\n        &#125;else if (sum &#x3D;&#x3D; target) &#123;\n            return nums.size();&#x2F;&#x2F;若数组所有正数之和刚好等于target，则直接返回数组的长度\n        &#125;else &#123;\n            int result &#x3D; INT32_MAX;&#x2F;&#x2F;初始化为int的最大值\n            int sum &#x3D; 0;\n            int i &#x3D; 0;\n            int subLength &#x3D; 0;\n            for(int j &#x3D; 0; j &lt; nums.size(); j++) &#123; &#x2F;&#x2F;窗口右边界\n                sum +&#x3D; nums[j];\n                while (sum &gt;&#x3D; target) &#123;\n                    subLength &#x3D; j - i + 1;\n                    result &#x3D; result &lt; subLength? result:subLength;\n                    sum -&#x3D; nums[i++]; &#x2F;&#x2F;滑动窗口\n                &#125;\n            &#125;\n            return result;\n        &#125;\n        return 0;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}