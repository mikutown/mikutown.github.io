{"title":"leetcode617.合并二叉树","slug":"leetcode617-合并二叉树","date":"2023-05-29T23:49:07.000Z","updated":"2023-05-29T23:55:24.400Z","comments":true,"path":"api/articles/leetcode617-合并二叉树.json","excerpt":"题目给你两棵二叉树： root1 和 root2 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。注意: 合并过程必须从两个树的根节点开始。","covers":["http://cdn.leafii.top/img/merge.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>\n<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>\n<p>返回合并后的二叉树。</p>\n<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/merge.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]\n输出：[3,4,5,5,4,null,7]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root1 &#x3D; [1], root2 &#x3D; [1,2]\n输出：[2,2]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>\n<li><code>-104 &lt;= Node.val &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>通过深度优先遍历进行合并</li>\n</ol>\n<p>如果有树为空，则直接返回另一个树；若两树都不为空，则新建一个节点，将对应的结点的值进行求和，递归调用函数，最终返回根结点。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;\n        &#x2F;&#x2F; 如果其中一个树为空，我们可以直接返回另一个树作为合并后的结果\n        if (root1 &#x3D;&#x3D; nullptr) &#123;\n            return root2;\n        &#125;\n        if (root2 &#x3D;&#x3D; nullptr) &#123;\n            return root1;\n        &#125;\n        \n        &#x2F;&#x2F; 创建一个新节点，值为两个树当前节点值的和\n        TreeNode *merged &#x3D; new TreeNode(root1-&gt;val + root2-&gt;val);\n        \n        &#x2F;&#x2F; 递归地合并左子树和右子树\n        merged-&gt;left &#x3D; mergeTrees(root1-&gt;left, root2-&gt;left);\n        merged-&gt;right &#x3D; mergeTrees(root1-&gt;right, root2-&gt;right);\n        \n        &#x2F;&#x2F; 返回合并后的树\n        return merged;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>通过广度优先遍历实现合并</li>\n</ol>\n<p>我们使用三个队列，<code>q</code>用于存储合并后的树节点，<code>q1</code>和<code>q2</code>分别用于存储两棵输入树的节点。</p>\n<p>在每一轮循环中，我们弹出<code>q</code>、<code>q1</code>和<code>q2</code>的队首元素，分别表示合并后的树的当前节点、第一棵树的当前节点和第二棵树的当前节点。</p>\n<p>然后，我们获取当前节点的左子节点和右子节点，并根据情况进行处理。</p>\n<ul>\n<li>如果两棵树的左子节点都存在，我们创建一个合并后的左子节点，值为两个树的左子节点值之和，并将其连接到合并后的树的当前节点的左侧。同时，我们将合并后的左子节点、第一棵树的左子节点和第二棵树的左子节点分别入队列<code>q</code>、<code>q1</code>和<code>q2</code>中。</li>\n<li>如果只有第一棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li>\n<li>如果只有第二棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li>\n</ul>\n<p>对于右子节点，我们执行类似的逻辑。</p>\n<p>最终，当队列<code>q1</code>和<code>q2</code>都为空时，表示已经遍历完两棵树的所有节点，此时合并过程完成，我们返回合并后的树的根节点。</p>\n<p>这样，使用广度优先遍历的方式，我们可以合并两棵二叉树并返回合并后的结果。</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    TreeNode<span class=\"token operator\">*</span> <span class=\"token function\">mergeTrees</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> t1<span class=\"token punctuation\">,</span> TreeNode<span class=\"token operator\">*</span> t2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      \t<span class=\"token comment\">// 如果其中一个树为空，直接返回另一个树</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> t2<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t2 <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> t1<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">// 创建一个新的节点，值为两个树当前节点值的和</span>\n        TreeNode<span class=\"token operator\">*</span> merged <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span>t1<span class=\"token operator\">-></span>val <span class=\"token operator\">+</span> t2<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      \t<span class=\"token comment\">// 使用队列存储节点，初始时将根节点入队列</span>\n        std<span class=\"token double-colon punctuation\">::</span>queue<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span>\n        q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>merged<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span>queue<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">></span> q1<span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span>queue<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">></span> q2<span class=\"token punctuation\">;</span>\n        q1<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        q2<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>q1<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>q2<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n          \t<span class=\"token comment\">// 弹出当前节点以及对应的两个输入树的节点</span>\n            TreeNode<span class=\"token operator\">*</span> node <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            q<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> node1 <span class=\"token operator\">=</span> q1<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            q1<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> node2 <span class=\"token operator\">=</span> q2<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            q2<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            \n          \t<span class=\"token comment\">// 获取当前节点的左子节点和右子节点</span>\n            TreeNode<span class=\"token operator\">*</span> left1 <span class=\"token operator\">=</span> node1<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> left2 <span class=\"token operator\">=</span> node2<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> right1 <span class=\"token operator\">=</span> node1<span class=\"token operator\">-></span>right<span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> right2 <span class=\"token operator\">=</span> node2<span class=\"token operator\">-></span>right<span class=\"token punctuation\">;</span>\n            \n          \t<span class=\"token comment\">// 处理左子节点</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token operator\">||</span> left2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token operator\">&amp;&amp;</span> left2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果两棵树的左子节点都存在，创建合并后的左子节点，并入队列</span>\n                    TreeNode<span class=\"token operator\">*</span> leftMerged <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span>left1<span class=\"token operator\">-></span>val <span class=\"token operator\">+</span> left2<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    node<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> leftMerged<span class=\"token punctuation\">;</span>\n                    q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>leftMerged<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    q1<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>left1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    q2<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>left2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果只有第一棵树的左子节点存在，直接使用该节点</span>\n                    node<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> left1<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果只有第二棵树的左子节点存在，直接使用该节点</span>\n                    node<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> left2<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            \n          \t<span class=\"token comment\">// 处理右子节点</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token operator\">||</span> right2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token operator\">&amp;&amp;</span> right2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果两棵树的右子节点都存在，创建合并后的右子节点，并入队列</span>\n                    TreeNode<span class=\"token operator\">*</span> rightMerged <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span>right1<span class=\"token operator\">-></span>val <span class=\"token operator\">+</span> right2<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    node<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> rightMerged<span class=\"token punctuation\">;</span>\n                    q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>rightMerged<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    q1<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>right1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    q2<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>right2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果只有第一棵树的右子节点存在，直接使用该节点</span>\n                    node<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> right1<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果只有第二棵树的右子节点存在</span>\n                    node<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> right2<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n      \t\n        <span class=\"token comment\">// 返回合并后的树</span>\n        <span class=\"token keyword\">return</span> merged<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></code></pre>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/merge.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]\n输出：[3,4,5,5,4,null,7]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root1 &#x3D; [1], root2 &#x3D; [1,2]\n输出：[2,2]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>\n<li><code>-104 &lt;= Node.val &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>通过深度优先遍历进行合并</li>\n</ol>\n<p>如果有树为空，则直接返回另一个树；若两树都不为空，则新建一个节点，将对应的结点的值进行求和，递归调用函数，最终返回根结点。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;\n        &#x2F;&#x2F; 如果其中一个树为空，我们可以直接返回另一个树作为合并后的结果\n        if (root1 &#x3D;&#x3D; nullptr) &#123;\n            return root2;\n        &#125;\n        if (root2 &#x3D;&#x3D; nullptr) &#123;\n            return root1;\n        &#125;\n        \n        &#x2F;&#x2F; 创建一个新节点，值为两个树当前节点值的和\n        TreeNode *merged &#x3D; new TreeNode(root1-&gt;val + root2-&gt;val);\n        \n        &#x2F;&#x2F; 递归地合并左子树和右子树\n        merged-&gt;left &#x3D; mergeTrees(root1-&gt;left, root2-&gt;left);\n        merged-&gt;right &#x3D; mergeTrees(root1-&gt;right, root2-&gt;right);\n        \n        &#x2F;&#x2F; 返回合并后的树\n        return merged;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>通过广度优先遍历实现合并</li>\n</ol>\n<p>我们使用三个队列，<code>q</code>用于存储合并后的树节点，<code>q1</code>和<code>q2</code>分别用于存储两棵输入树的节点。</p>\n<p>在每一轮循环中，我们弹出<code>q</code>、<code>q1</code>和<code>q2</code>的队首元素，分别表示合并后的树的当前节点、第一棵树的当前节点和第二棵树的当前节点。</p>\n<p>然后，我们获取当前节点的左子节点和右子节点，并根据情况进行处理。</p>\n<ul>\n<li>如果两棵树的左子节点都存在，我们创建一个合并后的左子节点，值为两个树的左子节点值之和，并将其连接到合并后的树的当前节点的左侧。同时，我们将合并后的左子节点、第一棵树的左子节点和第二棵树的左子节点分别入队列<code>q</code>、<code>q1</code>和<code>q2</code>中。</li>\n<li>如果只有第一棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li>\n<li>如果只有第二棵树的左子节点存在，我们直接使用该节点，并将其连接到合并后的树的当前节点的左侧。</li>\n</ul>\n<p>对于右子节点，我们执行类似的逻辑。</p>\n<p>最终，当队列<code>q1</code>和<code>q2</code>都为空时，表示已经遍历完两棵树的所有节点，此时合并过程完成，我们返回合并后的树的根节点。</p>\n<p>这样，使用广度优先遍历的方式，我们可以合并两棵二叉树并返回合并后的结果。</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    TreeNode<span class=\"token operator\">*</span> <span class=\"token function\">mergeTrees</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> t1<span class=\"token punctuation\">,</span> TreeNode<span class=\"token operator\">*</span> t2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      \t<span class=\"token comment\">// 如果其中一个树为空，直接返回另一个树</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> t2<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t2 <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> t1<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">// 创建一个新的节点，值为两个树当前节点值的和</span>\n        TreeNode<span class=\"token operator\">*</span> merged <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span>t1<span class=\"token operator\">-></span>val <span class=\"token operator\">+</span> t2<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      \t<span class=\"token comment\">// 使用队列存储节点，初始时将根节点入队列</span>\n        std<span class=\"token double-colon punctuation\">::</span>queue<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span>\n        q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>merged<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span>queue<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">></span> q1<span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span>queue<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">></span> q2<span class=\"token punctuation\">;</span>\n        q1<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        q2<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>q1<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>q2<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n          \t<span class=\"token comment\">// 弹出当前节点以及对应的两个输入树的节点</span>\n            TreeNode<span class=\"token operator\">*</span> node <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            q<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> node1 <span class=\"token operator\">=</span> q1<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            q1<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> node2 <span class=\"token operator\">=</span> q2<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            q2<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            \n          \t<span class=\"token comment\">// 获取当前节点的左子节点和右子节点</span>\n            TreeNode<span class=\"token operator\">*</span> left1 <span class=\"token operator\">=</span> node1<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> left2 <span class=\"token operator\">=</span> node2<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> right1 <span class=\"token operator\">=</span> node1<span class=\"token operator\">-></span>right<span class=\"token punctuation\">;</span>\n            TreeNode<span class=\"token operator\">*</span> right2 <span class=\"token operator\">=</span> node2<span class=\"token operator\">-></span>right<span class=\"token punctuation\">;</span>\n            \n          \t<span class=\"token comment\">// 处理左子节点</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token operator\">||</span> left2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token operator\">&amp;&amp;</span> left2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果两棵树的左子节点都存在，创建合并后的左子节点，并入队列</span>\n                    TreeNode<span class=\"token operator\">*</span> leftMerged <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span>left1<span class=\"token operator\">-></span>val <span class=\"token operator\">+</span> left2<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    node<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> leftMerged<span class=\"token punctuation\">;</span>\n                    q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>leftMerged<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    q1<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>left1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    q2<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>left2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果只有第一棵树的左子节点存在，直接使用该节点</span>\n                    node<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> left1<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果只有第二棵树的左子节点存在，直接使用该节点</span>\n                    node<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> left2<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            \n          \t<span class=\"token comment\">// 处理右子节点</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token operator\">||</span> right2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token operator\">&amp;&amp;</span> right2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果两棵树的右子节点都存在，创建合并后的右子节点，并入队列</span>\n                    TreeNode<span class=\"token operator\">*</span> rightMerged <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">TreeNode</span><span class=\"token punctuation\">(</span>right1<span class=\"token operator\">-></span>val <span class=\"token operator\">+</span> right2<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    node<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> rightMerged<span class=\"token punctuation\">;</span>\n                    q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>rightMerged<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    q1<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>right1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    q2<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>right2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right1 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果只有第一棵树的右子节点存在，直接使用该节点</span>\n                    node<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> right1<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right2 <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                  \t<span class=\"token comment\">// 如果只有第二棵树的右子节点存在</span>\n                    node<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> right2<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n      \t\n        <span class=\"token comment\">// 返回合并后的树</span>\n        <span class=\"token keyword\">return</span> merged<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}