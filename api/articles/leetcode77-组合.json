{"title":"leetcode77.组合","slug":"leetcode77-组合","date":"2023-07-21T00:58:17.000Z","updated":"2023-07-21T01:01:23.544Z","comments":true,"path":"api/articles/leetcode77-组合.json","excerpt":"题目给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>\n<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 4, k &#x3D; 2\n输出：\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1, k &#x3D; 1\n输出：[[1]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 20</code></li>\n<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接采用回溯法</li>\n</ul>\n<p>回溯法的统一伪代码：</p>\n<pre class=\"language-none\"><code class=\"language-none\">void backtracking(参数) &#123;\n    if (终止条件) &#123;\n        存放结果;\n        return;\n    &#125;\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;\n        处理节点;\n        backtracking(路径，选择列表); &#x2F;&#x2F; 递归\n        回溯，撤销处理结果\n    &#125;\n&#125;</code></pre>\n\n<p>因此本题的C++代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; result; &#x2F;&#x2F; 存放符合条件结果的集合\n    vector&lt;int&gt; path; &#x2F;&#x2F; 用来存放符合条件结果\n    void backtracking(int n, int k, int startIndex) &#123;\n        if (path.size() &#x3D;&#x3D; k) &#123;\n            result.push_back(path);\n            return;\n        &#125;\n        for (int i &#x3D; startIndex; i &lt;&#x3D; n - (k - path.size()) + 1; i++) &#123;\n            path.push_back(i); &#x2F;&#x2F; 处理节点\n            backtracking(n, k, i + 1); &#x2F;&#x2F; 递归\n            path.pop_back(); &#x2F;&#x2F; 回溯，撤销处理的节点\n        &#125;\n    &#125;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;\n        result.clear(); &#x2F;&#x2F; 可以不写\n        path.clear();   &#x2F;&#x2F; 可以不写\n        backtracking(n, k, 1); &#x2F;&#x2F; 递归\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 4, k &#x3D; 2\n输出：\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1, k &#x3D; 1\n输出：[[1]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 20</code></li>\n<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接采用回溯法</li>\n</ul>\n<p>回溯法的统一伪代码：</p>\n<pre class=\"language-none\"><code class=\"language-none\">void backtracking(参数) &#123;\n    if (终止条件) &#123;\n        存放结果;\n        return;\n    &#125;\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;\n        处理节点;\n        backtracking(路径，选择列表); &#x2F;&#x2F; 递归\n        回溯，撤销处理结果\n    &#125;\n&#125;</code></pre>\n\n<p>因此本题的C++代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; result; &#x2F;&#x2F; 存放符合条件结果的集合\n    vector&lt;int&gt; path; &#x2F;&#x2F; 用来存放符合条件结果\n    void backtracking(int n, int k, int startIndex) &#123;\n        if (path.size() &#x3D;&#x3D; k) &#123;\n            result.push_back(path);\n            return;\n        &#125;\n        for (int i &#x3D; startIndex; i &lt;&#x3D; n - (k - path.size()) + 1; i++) &#123;\n            path.push_back(i); &#x2F;&#x2F; 处理节点\n            backtracking(n, k, i + 1); &#x2F;&#x2F; 递归\n            path.pop_back(); &#x2F;&#x2F; 回溯，撤销处理的节点\n        &#125;\n    &#125;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;\n        result.clear(); &#x2F;&#x2F; 可以不写\n        path.clear();   &#x2F;&#x2F; 可以不写\n        backtracking(n, k, 1); &#x2F;&#x2F; 递归\n        return result;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}