{"title":"leetcode739.每日温度","slug":"leetcode739-每日温度","date":"2023-05-11T01:07:07.000Z","updated":"2023-05-11T02:57:25.237Z","comments":true,"path":"api/articles/leetcode739-每日温度.json","excerpt":"题目给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: temperatures &#x3D; [30,40,50,60]\n输出: [1,1,1,0]</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: temperatures &#x3D; [30,60,90]\n输出: [1,1,0]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= temperatures.length &lt;= 105</code></li>\n<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>单调栈</li>\n</ul>\n<p>解本题的第一种解题思路是直接进行暴力模拟。但是本文的样例中，若数组的长度很长而且元素都是同一个值，会导致超出时间限制，因此我们必须考虑使用其他的数据结构帮助我们进行解题。本体可以使用栈的数据结构帮助我们解题，思路如下：首先初始化答案数组为全0，数组的长度为temperatures数组的长度，栈中的元素是尚未找到下一个更高温度的索引。遍历温度列表时，如果当前温度大于栈顶索引对应的温度，说明栈顶索引对应的温度已经找到了下一个更高温度，可以计算出答案并更新结果数组。通过这种方法，可以在一次遍历中完成计算，时间复杂度为 O(n)，满足时间限制。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;\n        int len &#x3D; temperatures.size();\n        vector&lt;int&gt; answers(len, 0); &#x2F;&#x2F; 储存答案数组\n        stack&lt;int&gt; stk; &#x2F;&#x2F; 单调栈\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            while (!stk.empty() &amp;&amp; temperatures[stk.top()] &lt; temperatures[i]) &#123; &#x2F;&#x2F; 当当前温度高于栈顶索引的温度时\n                answers[stk.top()] &#x3D; i - stk.top(); &#x2F;&#x2F; 更新对应索引的answer\n                stk.pop(); &#x2F;&#x2F; 较低的温度的索引出栈\n            &#125;\n            stk.push(i); &#x2F;&#x2F; 较高的温度索引入栈\n        &#125;\n        return answers; &#x2F;&#x2F; 返回答案数组\n    &#125;\n&#125;;</code></pre>\n\n<p>当给定输入 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，我们可以逐步执行优化后的代码来帮助您理解它的工作原理：</p>\n<ol>\n<li>初始化空栈和答案数组：stk &#x3D; []，answers &#x3D; [0, 0, 0, 0, 0, 0, 0, 0]。</li>\n<li>遍历温度列表：<ul>\n<li>对于第一个温度 73：<ul>\n<li>栈为空，将索引 0 压入栈。</li>\n</ul>\n</li>\n<li>对于第二个温度 74：<ul>\n<li>栈顶索引对应的温度是 73，74 &gt; 73，可以计算答案 answers[0] &#x3D; 1。</li>\n<li>弹出栈顶索引 0，将索引 1 压入栈。</li>\n</ul>\n</li>\n<li>对于第三个温度 75：<ul>\n<li>栈顶索引对应的温度是 74，75 &gt; 74，可以计算答案 answers[1] &#x3D; 1。</li>\n<li>弹出栈顶索引 1，将索引 2 压入栈。</li>\n</ul>\n</li>\n<li>对于第四个温度 71：<ul>\n<li>栈顶索引对应的温度是 75，71 &lt; 75，将索引 3 压入栈。</li>\n</ul>\n</li>\n<li>对于第五个温度 69：<ul>\n<li>栈顶索引对应的温度是 71，69 &lt; 71，将索引 4 压入栈。</li>\n</ul>\n</li>\n<li>对于第六个温度 72：<ul>\n<li>栈顶索引对应的温度是 69，72 &gt; 69，可以计算答案 answers[4] &#x3D; 2。</li>\n<li>弹出栈顶索引 4，将索引 5 压入栈。</li>\n</ul>\n</li>\n<li>对于第七个温度 76：<ul>\n<li>栈顶索引对应的温度是 72，76 &gt; 72，可以计算答案 answers[5] &#x3D; 1。</li>\n<li>弹出栈顶索引 5，将索引 6 压入栈。</li>\n</ul>\n</li>\n<li>对于最后一个温度 73：<ul>\n<li>栈顶索引对应的温度是 76，73 &lt; 76，将索引 7 压入栈。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>完成遍历后，栈中剩余的索引对应的答案无法计算，因为它们没有找到下一个更高温度。因此，答案数组中仍然为0。</li>\n</ol>\n<p>最终的答案数组为 [1, 1, 4, 2, 1, 1, 0, 0]，它表示每个温度需要等待的天数，直到出现更高的温度。</p>\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: temperatures &#x3D; [30,40,50,60]\n输出: [1,1,1,0]</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: temperatures &#x3D; [30,60,90]\n输出: [1,1,0]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= temperatures.length &lt;= 105</code></li>\n<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>单调栈</li>\n</ul>\n<p>解本题的第一种解题思路是直接进行暴力模拟。但是本文的样例中，若数组的长度很长而且元素都是同一个值，会导致超出时间限制，因此我们必须考虑使用其他的数据结构帮助我们进行解题。本体可以使用栈的数据结构帮助我们解题，思路如下：首先初始化答案数组为全0，数组的长度为temperatures数组的长度，栈中的元素是尚未找到下一个更高温度的索引。遍历温度列表时，如果当前温度大于栈顶索引对应的温度，说明栈顶索引对应的温度已经找到了下一个更高温度，可以计算出答案并更新结果数组。通过这种方法，可以在一次遍历中完成计算，时间复杂度为 O(n)，满足时间限制。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;\n        int len &#x3D; temperatures.size();\n        vector&lt;int&gt; answers(len, 0); &#x2F;&#x2F; 储存答案数组\n        stack&lt;int&gt; stk; &#x2F;&#x2F; 单调栈\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            while (!stk.empty() &amp;&amp; temperatures[stk.top()] &lt; temperatures[i]) &#123; &#x2F;&#x2F; 当当前温度高于栈顶索引的温度时\n                answers[stk.top()] &#x3D; i - stk.top(); &#x2F;&#x2F; 更新对应索引的answer\n                stk.pop(); &#x2F;&#x2F; 较低的温度的索引出栈\n            &#125;\n            stk.push(i); &#x2F;&#x2F; 较高的温度索引入栈\n        &#125;\n        return answers; &#x2F;&#x2F; 返回答案数组\n    &#125;\n&#125;;</code></pre>\n\n<p>当给定输入 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，我们可以逐步执行优化后的代码来帮助您理解它的工作原理：</p>\n<ol>\n<li>初始化空栈和答案数组：stk &#x3D; []，answers &#x3D; [0, 0, 0, 0, 0, 0, 0, 0]。</li>\n<li>遍历温度列表：<ul>\n<li>对于第一个温度 73：<ul>\n<li>栈为空，将索引 0 压入栈。</li>\n</ul>\n</li>\n<li>对于第二个温度 74：<ul>\n<li>栈顶索引对应的温度是 73，74 &gt; 73，可以计算答案 answers[0] &#x3D; 1。</li>\n<li>弹出栈顶索引 0，将索引 1 压入栈。</li>\n</ul>\n</li>\n<li>对于第三个温度 75：<ul>\n<li>栈顶索引对应的温度是 74，75 &gt; 74，可以计算答案 answers[1] &#x3D; 1。</li>\n<li>弹出栈顶索引 1，将索引 2 压入栈。</li>\n</ul>\n</li>\n<li>对于第四个温度 71：<ul>\n<li>栈顶索引对应的温度是 75，71 &lt; 75，将索引 3 压入栈。</li>\n</ul>\n</li>\n<li>对于第五个温度 69：<ul>\n<li>栈顶索引对应的温度是 71，69 &lt; 71，将索引 4 压入栈。</li>\n</ul>\n</li>\n<li>对于第六个温度 72：<ul>\n<li>栈顶索引对应的温度是 69，72 &gt; 69，可以计算答案 answers[4] &#x3D; 2。</li>\n<li>弹出栈顶索引 4，将索引 5 压入栈。</li>\n</ul>\n</li>\n<li>对于第七个温度 76：<ul>\n<li>栈顶索引对应的温度是 72，76 &gt; 72，可以计算答案 answers[5] &#x3D; 1。</li>\n<li>弹出栈顶索引 5，将索引 6 压入栈。</li>\n</ul>\n</li>\n<li>对于最后一个温度 73：<ul>\n<li>栈顶索引对应的温度是 76，73 &lt; 76，将索引 7 压入栈。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>完成遍历后，栈中剩余的索引对应的答案无法计算，因为它们没有找到下一个更高温度。因此，答案数组中仍然为0。</li>\n</ol>\n<p>最终的答案数组为 [1, 1, 4, 2, 1, 1, 0, 0]，它表示每个温度需要等待的天数，直到出现更高的温度。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}