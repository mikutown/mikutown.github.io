{"title":"leetcode701.二叉搜索树中的插入操作","slug":"leetcode701-二叉搜索树中的插入操作","date":"2023-06-29T09:06:58.000Z","updated":"2023-06-29T09:16:54.172Z","comments":true,"path":"api/articles/leetcode701-二叉搜索树中的插入操作.json","excerpt":"题目给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。","covers":["https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5\n输出：[4,2,7,1,3,5]\n解释：另一个满足题目要求可以通过的树是：</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25\n输出：[40,20,60,10,30,50,70,null,null,25]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5\n输出：[4,2,7,1,3,5]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li>\n<li><code>-108 &lt;= Node.val &lt;= 108</code></li>\n<li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li>\n<li><code>-108 &lt;= val &lt;= 108</code></li>\n<li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>见代码</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            &#x2F;&#x2F; 当前节点为空，创建一个新节点并赋值\n            return new TreeNode(val);\n        &#125;\n\n        if (val &lt; root-&gt;val) &#123;\n            &#x2F;&#x2F; 要插入的值小于当前节点的值，向左子树递归插入\n            root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val);\n        &#125; else &#123;\n            &#x2F;&#x2F; 要插入的值大于等于当前节点的值，向右子树递归插入\n            root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val);\n        &#125;\n\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5\n输出：[4,2,7,1,3,5]\n解释：另一个满足题目要求可以通过的树是：</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25\n输出：[40,20,60,10,30,50,70,null,null,25]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5\n输出：[4,2,7,1,3,5]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li>\n<li><code>-108 &lt;= Node.val &lt;= 108</code></li>\n<li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li>\n<li><code>-108 &lt;= val &lt;= 108</code></li>\n<li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>见代码</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            &#x2F;&#x2F; 当前节点为空，创建一个新节点并赋值\n            return new TreeNode(val);\n        &#125;\n\n        if (val &lt; root-&gt;val) &#123;\n            &#x2F;&#x2F; 要插入的值小于当前节点的值，向左子树递归插入\n            root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val);\n        &#125; else &#123;\n            &#x2F;&#x2F; 要插入的值大于等于当前节点的值，向右子树递归插入\n            root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val);\n        &#125;\n\n        return root;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}