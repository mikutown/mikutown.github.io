{"title":"leetcode104.二叉树的最大深度","slug":"leetcode104-二叉树的最大深度","date":"2023-03-13T07:17:04.000Z","updated":"2023-03-14T02:20:19.405Z","comments":true,"path":"api/articles/leetcode104-二叉树的最大深度.json","excerpt":"题目给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n<pre class=\"language-none\"><code class=\"language-none\">  3\n &#x2F; \\\n9  20\n  &#x2F;  \\\n 15   7</code></pre>\n\n<p>返回它的最大深度 3 。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>DFS（深度优先遍历）</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int maxDepth(TreeNode* root) &#123;\n      \t&#x2F;&#x2F; 如果当前节点为空，则返回0\n        if (root &#x3D;&#x3D; nullptr) return 0;\n      \t&#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1\n        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) return 1;\n        int left_depth &#x3D; -1, right_depth &#x3D; -1;\n      \t&#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度\n        if (root-&gt;left !&#x3D; nullptr) &#123;\n            left_depth &#x3D; maxDepth(root-&gt;left);\n        &#125;\n      \t&#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度\n        if (root-&gt;right !&#x3D; nullptr) &#123;\n            right_depth &#x3D; maxDepth(root-&gt;right);\n        &#125;\n      \t&#x2F;&#x2F; 返回左右子树深度的较大值加1\n        return max(left_depth, right_depth) + 1;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ol start=\"2\">\n<li>BFS（广度优先遍历）</li>\n</ol>\n<p>主要思路是使用一个队列来遍历整个二叉树。我们首先将根节点加入队列中，然后在每次循环中取出队列中的一层节点，将该层节点的左右子节点加入队列中。当遍历完所有节点时，队列中存储的即为最后一层节点，此时的深度即为树的深度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int maxDepth(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; NULL) &#123;\n            return 0;\n        &#125;\n        queue&lt;TreeNode*&gt; q;  &#x2F;&#x2F; 创建一个队列，用于BFS遍历\n        q.push(root);        &#x2F;&#x2F; 将根节点加入队列\n        int depth &#x3D; 0;       &#x2F;&#x2F; 初始化深度为0\n        while (!q.empty()) &#123; &#x2F;&#x2F; 当队列不为空时，继续遍历\n            int size &#x3D; q.size(); &#x2F;&#x2F; 记录队列中当前层的节点数量\n            for (int i &#x3D; 0; i &lt; size; i++) &#123; &#x2F;&#x2F; 遍历当前层的所有节点\n                TreeNode* node &#x3D; q.front();  &#x2F;&#x2F; 取出队列头部的节点\n                q.pop();                     &#x2F;&#x2F; 将该节点从队列中移除\n                if (node-&gt;left !&#x3D; NULL) &#123;    &#x2F;&#x2F; 如果该节点有左子节点，将其加入队列中\n                    q.push(node-&gt;left);\n                &#125;\n                if (node-&gt;right !&#x3D; NULL) &#123;   &#x2F;&#x2F; 如果该节点有右子节点，将其加入队列中\n                    q.push(node-&gt;right);\n                &#125;\n            &#125;\n            depth++;  &#x2F;&#x2F; 当前层遍历结束后，深度加1\n        &#125;\n        return depth; &#x2F;&#x2F; 返回树的深度\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n<pre class=\"language-none\"><code class=\"language-none\">  3\n &#x2F; \\\n9  20\n  &#x2F;  \\\n 15   7</code></pre>\n\n<p>返回它的最大深度 3 。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>DFS（深度优先遍历）</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int maxDepth(TreeNode* root) &#123;\n      \t&#x2F;&#x2F; 如果当前节点为空，则返回0\n        if (root &#x3D;&#x3D; nullptr) return 0;\n      \t&#x2F;&#x2F; 如果当前节点没有左右子节点，则返回1\n        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) return 1;\n        int left_depth &#x3D; -1, right_depth &#x3D; -1;\n      \t&#x2F;&#x2F; 如果当前节点有左子节点，则计算左子树的深度\n        if (root-&gt;left !&#x3D; nullptr) &#123;\n            left_depth &#x3D; maxDepth(root-&gt;left);\n        &#125;\n      \t&#x2F;&#x2F; 如果当前节点有右子节点，则计算右子树的深度\n        if (root-&gt;right !&#x3D; nullptr) &#123;\n            right_depth &#x3D; maxDepth(root-&gt;right);\n        &#125;\n      \t&#x2F;&#x2F; 返回左右子树深度的较大值加1\n        return max(left_depth, right_depth) + 1;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ol start=\"2\">\n<li>BFS（广度优先遍历）</li>\n</ol>\n<p>主要思路是使用一个队列来遍历整个二叉树。我们首先将根节点加入队列中，然后在每次循环中取出队列中的一层节点，将该层节点的左右子节点加入队列中。当遍历完所有节点时，队列中存储的即为最后一层节点，此时的深度即为树的深度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int maxDepth(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; NULL) &#123;\n            return 0;\n        &#125;\n        queue&lt;TreeNode*&gt; q;  &#x2F;&#x2F; 创建一个队列，用于BFS遍历\n        q.push(root);        &#x2F;&#x2F; 将根节点加入队列\n        int depth &#x3D; 0;       &#x2F;&#x2F; 初始化深度为0\n        while (!q.empty()) &#123; &#x2F;&#x2F; 当队列不为空时，继续遍历\n            int size &#x3D; q.size(); &#x2F;&#x2F; 记录队列中当前层的节点数量\n            for (int i &#x3D; 0; i &lt; size; i++) &#123; &#x2F;&#x2F; 遍历当前层的所有节点\n                TreeNode* node &#x3D; q.front();  &#x2F;&#x2F; 取出队列头部的节点\n                q.pop();                     &#x2F;&#x2F; 将该节点从队列中移除\n                if (node-&gt;left !&#x3D; NULL) &#123;    &#x2F;&#x2F; 如果该节点有左子节点，将其加入队列中\n                    q.push(node-&gt;left);\n                &#125;\n                if (node-&gt;right !&#x3D; NULL) &#123;   &#x2F;&#x2F; 如果该节点有右子节点，将其加入队列中\n                    q.push(node-&gt;right);\n                &#125;\n            &#125;\n            depth++;  &#x2F;&#x2F; 当前层遍历结束后，深度加1\n        &#125;\n        return depth; &#x2F;&#x2F; 返回树的深度\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}