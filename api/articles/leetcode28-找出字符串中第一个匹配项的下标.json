{"title":"leetcode28.找出字符串中第一个匹配项的下标","slug":"leetcode28-找出字符串中第一个匹配项的下标","date":"2023-03-21T08:03:49.000Z","updated":"2023-03-21T08:55:29.612Z","comments":true,"path":"api/articles/leetcode28-找出字符串中第一个匹配项的下标.json","excerpt":"题目给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：haystack &#x3D; &quot;sadbutsad&quot;, needle &#x3D; &quot;sad&quot;\n输出：0\n解释：&quot;sad&quot; 在下标 0 和 6 处匹配。\n第一个匹配项的下标是 0 ，所以返回 0 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：haystack &#x3D; &quot;leetcode&quot;, needle &#x3D; &quot;leeto&quot;\n输出：-1\n解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li>\n<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>暴力解法</li>\n</ol>\n<p>首先判断haystack的长度是否小于needle，若小于则直接返回-1.然后对haystack进行遍历，若haystack[i]&#x3D;&#x3D;needle[0]，则说明haystack同needle的第一个字符匹配了，此时直接求haystack在i上长度为needle长度的子串并比较他们是否相等，若相等则直接返回i即可，否则继续遍历haystack。C++解法如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int strStr(string haystack, string needle) &#123;\n        int m &#x3D; haystack.length(); \n        int n &#x3D; needle.length(); &#x2F;&#x2F; 分别求两个字符串的长度\n        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; 此判断符合strStr函数的原始定义\n        if (m &lt; n) return -1; &#x2F;&#x2F; 若haystack长度小于needle长度，则直接返回-1\n        for (int i &#x3D; 0; i &lt; m; i++) &#123; &#x2F;&#x2F; 遍历匹配第一个字母\n            if (haystack[i] &#x3D;&#x3D; needle[0]) &#123; &#x2F;&#x2F; 若第一个字母成功匹配\n                string temp &#x3D; haystack.substr(i, n); &#x2F;&#x2F; 直接求下标为i，长度同needle相等的子串temp\n                if (temp &#x3D;&#x3D; needle) &#123; &#x2F;&#x2F; 判断temp与needle是否相等\n                    return i; &#x2F;&#x2F; 若相等，则直接返回i\n                &#125;\n            &#125;\n        &#125;\n        return -1; &#x2F;&#x2F; 否则返回-1\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>KMP算法</li>\n</ol>\n<p>KMP的详细介绍：<a href=\"https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html\">https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html</a></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    void getNext(int* next, const string&amp; s) &#123;\n        int j &#x3D; -1;\n        next[0] &#x3D; j;\n        for(int i &#x3D; 1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 注意i从1开始\n            while (j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; s[j+1]) &#123; &#x2F;&#x2F;前后缀不相同了\n                j &#x3D; next[j];\n            &#125;\n            if (s[i] &#x3D;&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 找到相同的前后缀\n                j++;\n            &#125;\n            next[i] &#x3D; j; &#x2F;&#x2F; 将j（前缀的长度）赋给next[i]\n        &#125;\n    &#125;\n    int strStr(string haystack, string needle) &#123;\n        if (needle.size() &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int next[needle.size()];\n        getNext(next, needle);\n        int j &#x3D; -1;\n        for (int i &#x3D; 0; i &lt; haystack.size(); i++) &#123; &#x2F;&#x2F; 注意i从0开始\n            while(j &gt;&#x3D; 0 &amp;&amp; haystack[i] !&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 不匹配\n                j &#x3D; next[j]; &#x2F;&#x2F; j寻找之前匹配的位置\n            &#125;\n            if (haystack[i] &#x3D;&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 匹配，j和i同时向后移动\n                j++;\n            &#125;\n            if (j &#x3D;&#x3D;(needle.size() - 1))  &#123; &#x2F;&#x2F; 文本串s里出现了模式串t\n                return (i - needle.size() + 1);\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：haystack &#x3D; &quot;sadbutsad&quot;, needle &#x3D; &quot;sad&quot;\n输出：0\n解释：&quot;sad&quot; 在下标 0 和 6 处匹配。\n第一个匹配项的下标是 0 ，所以返回 0 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：haystack &#x3D; &quot;leetcode&quot;, needle &#x3D; &quot;leeto&quot;\n输出：-1\n解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li>\n<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>暴力解法</li>\n</ol>\n<p>首先判断haystack的长度是否小于needle，若小于则直接返回-1.然后对haystack进行遍历，若haystack[i]&#x3D;&#x3D;needle[0]，则说明haystack同needle的第一个字符匹配了，此时直接求haystack在i上长度为needle长度的子串并比较他们是否相等，若相等则直接返回i即可，否则继续遍历haystack。C++解法如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int strStr(string haystack, string needle) &#123;\n        int m &#x3D; haystack.length(); \n        int n &#x3D; needle.length(); &#x2F;&#x2F; 分别求两个字符串的长度\n        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; 此判断符合strStr函数的原始定义\n        if (m &lt; n) return -1; &#x2F;&#x2F; 若haystack长度小于needle长度，则直接返回-1\n        for (int i &#x3D; 0; i &lt; m; i++) &#123; &#x2F;&#x2F; 遍历匹配第一个字母\n            if (haystack[i] &#x3D;&#x3D; needle[0]) &#123; &#x2F;&#x2F; 若第一个字母成功匹配\n                string temp &#x3D; haystack.substr(i, n); &#x2F;&#x2F; 直接求下标为i，长度同needle相等的子串temp\n                if (temp &#x3D;&#x3D; needle) &#123; &#x2F;&#x2F; 判断temp与needle是否相等\n                    return i; &#x2F;&#x2F; 若相等，则直接返回i\n                &#125;\n            &#125;\n        &#125;\n        return -1; &#x2F;&#x2F; 否则返回-1\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>KMP算法</li>\n</ol>\n<p>KMP的详细介绍：<a href=\"https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html\">https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html</a></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    void getNext(int* next, const string&amp; s) &#123;\n        int j &#x3D; -1;\n        next[0] &#x3D; j;\n        for(int i &#x3D; 1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 注意i从1开始\n            while (j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; s[j+1]) &#123; &#x2F;&#x2F;前后缀不相同了\n                j &#x3D; next[j];\n            &#125;\n            if (s[i] &#x3D;&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 找到相同的前后缀\n                j++;\n            &#125;\n            next[i] &#x3D; j; &#x2F;&#x2F; 将j（前缀的长度）赋给next[i]\n        &#125;\n    &#125;\n    int strStr(string haystack, string needle) &#123;\n        if (needle.size() &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int next[needle.size()];\n        getNext(next, needle);\n        int j &#x3D; -1;\n        for (int i &#x3D; 0; i &lt; haystack.size(); i++) &#123; &#x2F;&#x2F; 注意i从0开始\n            while(j &gt;&#x3D; 0 &amp;&amp; haystack[i] !&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 不匹配\n                j &#x3D; next[j]; &#x2F;&#x2F; j寻找之前匹配的位置\n            &#125;\n            if (haystack[i] &#x3D;&#x3D; needle[j + 1]) &#123; &#x2F;&#x2F; 匹配，j和i同时向后移动\n                j++;\n            &#125;\n            if (j &#x3D;&#x3D;(needle.size() - 1))  &#123; &#x2F;&#x2F; 文本串s里出现了模式串t\n                return (i - needle.size() + 1);\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}