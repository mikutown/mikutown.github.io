{"title":"leetcode349.两个数组的交集","slug":"leetcode349-两个数组的交集","date":"2023-10-17T00:38:12.000Z","updated":"2023-10-17T00:52:36.371Z","comments":true,"path":"api/articles/leetcode349-两个数组的交集.json","excerpt":"题目给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]\n输出：[2]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]\n输出：[9,4]\n解释：[4,9] 也是可通过的</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; deduplicate(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; 手动去重\n        int n &#x3D; nums.size();\n        if (n &lt;&#x3D; 1) return nums;\n        int p &#x3D; 0,q &#x3D; 1;\n        while (q &lt; n) &#123;\n            &#x2F;&#x2F; 0 0 1 2 2 3 4\n            if (nums[p] &#x3D;&#x3D; nums[q])&#123;\n                ++q;\n            &#125;\n            else &#123;\n                nums[p+1] &#x3D; nums[q];\n                ++p;\n                ++q;\n            &#125;\n        &#125;\n        vector&lt;int&gt; newNums(nums.begin(), nums.begin() + p + 1);\n        return newNums;\n    &#125;\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        &#x2F;&#x2F; 排序\n        sort(nums1.begin(), nums1.end());\n        sort(nums2.begin(), nums2.end());\n        &#x2F;&#x2F; 对两个数组进行去重\n        vector&lt;int&gt; newNums1 &#x3D; deduplicate(nums1);\n        vector&lt;int&gt; newNums2 &#x3D; deduplicate(nums2);\n        &#x2F;&#x2F; 初始化结果数组\n        vector&lt;int&gt; results;\n        int n1 &#x3D; newNums1.size();\n        int n2 &#x3D; newNums2.size();\n        &#x2F;&#x2F; 暴力便利\n        for (int i &#x3D; 0; i &lt; n1; i++) &#123;\n            for (int j &#x3D; 0; j &lt; n2; j++) &#123;\n                if (newNums1[i] &#x3D;&#x3D; newNums2[j]) &#123;\n                    results.push_back(newNums1[i]);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 返回结果数组\n        return results;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>使用哈希表</li>\n</ul>\n<p>C++中，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        unordered_set&lt;int&gt; result_set;\n        unordered_set&lt;int&gt; nums1set(nums1.begin(), nums1.end());\n        for (int num:nums2) &#123;\n            &#x2F;&#x2F; 发现nums2的元素 在nums_set里又出现过\n            if (nums1set.find(num) !&#x3D; nums1set.end()) &#123;\n                result_set.insert(num);\n            &#125;\n        &#125;\n        return vector&lt;int&gt;(result_set.begin(), result_set.end());\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]\n输出：[2]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]\n输出：[9,4]\n解释：[4,9] 也是可通过的</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; deduplicate(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; 手动去重\n        int n &#x3D; nums.size();\n        if (n &lt;&#x3D; 1) return nums;\n        int p &#x3D; 0,q &#x3D; 1;\n        while (q &lt; n) &#123;\n            &#x2F;&#x2F; 0 0 1 2 2 3 4\n            if (nums[p] &#x3D;&#x3D; nums[q])&#123;\n                ++q;\n            &#125;\n            else &#123;\n                nums[p+1] &#x3D; nums[q];\n                ++p;\n                ++q;\n            &#125;\n        &#125;\n        vector&lt;int&gt; newNums(nums.begin(), nums.begin() + p + 1);\n        return newNums;\n    &#125;\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        &#x2F;&#x2F; 排序\n        sort(nums1.begin(), nums1.end());\n        sort(nums2.begin(), nums2.end());\n        &#x2F;&#x2F; 对两个数组进行去重\n        vector&lt;int&gt; newNums1 &#x3D; deduplicate(nums1);\n        vector&lt;int&gt; newNums2 &#x3D; deduplicate(nums2);\n        &#x2F;&#x2F; 初始化结果数组\n        vector&lt;int&gt; results;\n        int n1 &#x3D; newNums1.size();\n        int n2 &#x3D; newNums2.size();\n        &#x2F;&#x2F; 暴力便利\n        for (int i &#x3D; 0; i &lt; n1; i++) &#123;\n            for (int j &#x3D; 0; j &lt; n2; j++) &#123;\n                if (newNums1[i] &#x3D;&#x3D; newNums2[j]) &#123;\n                    results.push_back(newNums1[i]);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 返回结果数组\n        return results;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>使用哈希表</li>\n</ul>\n<p>C++中，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        unordered_set&lt;int&gt; result_set;\n        unordered_set&lt;int&gt; nums1set(nums1.begin(), nums1.end());\n        for (int num:nums2) &#123;\n            &#x2F;&#x2F; 发现nums2的元素 在nums_set里又出现过\n            if (nums1set.find(num) !&#x3D; nums1set.end()) &#123;\n                result_set.insert(num);\n            &#125;\n        &#125;\n        return vector&lt;int&gt;(result_set.begin(), result_set.end());\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}