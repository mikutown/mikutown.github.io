{"title":"leetcode142.环形链表II","slug":"leetcode142-环形链表II","date":"2023-03-06T12:44:53.000Z","updated":"2023-03-06T14:19:40.504Z","comments":true,"path":"api/articles/leetcode142-环形链表II.json","excerpt":"题目给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改 链表。","covers":["http://cdn.leafii.top/img/circularlinkedlist-20230306204553902.png","http://cdn.leafii.top/img/circularlinkedlist_test2-20230306204600878.png","http://cdn.leafii.top/img/circularlinkedlist_test3-20230306204608161.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n<p><strong>不允许修改</strong> 链表。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/circularlinkedlist-20230306204553902.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/circularlinkedlist_test2-20230306204600878.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2], pos &#x3D; 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/circularlinkedlist_test3-20230306204608161.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1], pos &#x3D; -1\n输出：返回 null\n解释：链表中没有环。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>\n</ul>\n<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用hashset存储链表元素的地址，当使用快慢指针确定环形链表存在时，返回相应的环形节点。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#x2F;&#x2F; 如果链表为空或者只有一个元素，则返回null\n            return nullptr; \n        ListNode* slow &#x3D; head;\n        ListNode* fast &#x3D; head-&gt;next;\n        while (slow !&#x3D; fast) &#123;\n            if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) return nullptr;\n            fast &#x3D; fast-&gt;next-&gt;next;\n            slow &#x3D; slow-&gt;next;\n        &#125;\n        &#x2F;&#x2F;此时已经发现有环了，使用hashset存储链表元素地址，若有相同地址的元素就返回该元素\n        unordered_set&lt;ListNode*&gt; nodes;\n        ListNode* cur &#x3D; head;\n        while (cur !&#x3D; nullptr) &#123;\n            if (nodes.count(cur)) &#123;\n                return cur;\n            &#125;\n            else &#123;\n                nodes.insert(cur);\n                cur &#x3D; cur-&gt;next;\n            &#125;\n        &#125;\n\n        return nullptr;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>快慢指针法</li>\n</ol>\n<p>利用快慢指针，找到链表中是否存在环。若存在环，则将快指针重新指向链表的头结点，并将快慢指针以相同的速度向前移动，直到两个指针相遇，即为环的入口节点。</p>\n<p>假设链表的长度为L，环的长度为C，环的入口节点距离头节点的距离为A，快慢指针相遇的节点距离环的入口节点的距离为B。</p>\n<p>当快慢指针相遇时，快指针走过的距离是慢指针的两倍，即：</p>\n<p>$2 \\times (A + B) &#x3D; A + B + n \\times C$</p>\n<p>其中n是快指针在环中走过的圈数。</p>\n<p>化简得：</p>\n<p>$A &#x3D; (n - 1) \\times C + (C - B)$</p>\n<p>这个式子的意义是，从头节点到环的入口节点的距离等于从相遇点到环的入口节点的距离加上(n - 1)圈的环的长度。</p>\n<p>因此，如果让一个新的指针cur从头节点开始走，同时让slow从相遇点开始走，每次都走一步，那么它们会在环的入口节点相遇，因为它们走过的距离都是A。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\n\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        &#x2F;&#x2F; 判断链表是否为空或只有一个元素\n        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) &#123;\n            return NULL;\n        &#125;\n        &#x2F;&#x2F; 定义快慢指针，初始值指向头结点\n        ListNode* fast &#x3D; head;\n        ListNode* slow &#x3D; head;\n        &#x2F;&#x2F; 判断是否存在环\n        while (fast !&#x3D; NULL &amp;&amp; fast-&gt;next !&#x3D; NULL) &#123;\n            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走两步\n            slow &#x3D; slow-&gt;next;       &#x2F;&#x2F; 慢指针走一步\n            if (fast &#x3D;&#x3D; slow) &#123;      &#x2F;&#x2F; 快慢指针相遇\n                ListNode* start &#x3D; head; &#x2F;&#x2F; 从头结点开始，与慢指针同时前进，相遇点即为环的起点\n                while (start !&#x3D; slow) &#123;\n                    start &#x3D; start-&gt;next;\n                    slow &#x3D; slow-&gt;next;\n                &#125;\n                return start;\n            &#125;\n        &#125;\n        return NULL; &#x2F;&#x2F; 遍历完链表，仍未找到环，返回NULL\n    &#125;\n&#125;;\n</code></pre>\n\n<blockquote>\n<p>注：在 while 循环中，因为 fast 比 slow 快，所以应该先判断 fast 是否为 NULL 或 fast-&gt;next 是否为 NULL，以保证程序的正确性。</p>\n</blockquote>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/circularlinkedlist-20230306204553902.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/circularlinkedlist_test2-20230306204600878.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2], pos &#x3D; 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/circularlinkedlist_test3-20230306204608161.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1], pos &#x3D; -1\n输出：返回 null\n解释：链表中没有环。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>\n</ul>\n<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用hashset存储链表元素的地址，当使用快慢指针确定环形链表存在时，返回相应的环形节点。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#x2F;&#x2F; 如果链表为空或者只有一个元素，则返回null\n            return nullptr; \n        ListNode* slow &#x3D; head;\n        ListNode* fast &#x3D; head-&gt;next;\n        while (slow !&#x3D; fast) &#123;\n            if (fast &#x3D;&#x3D; NULL || fast-&gt;next &#x3D;&#x3D; NULL) return nullptr;\n            fast &#x3D; fast-&gt;next-&gt;next;\n            slow &#x3D; slow-&gt;next;\n        &#125;\n        &#x2F;&#x2F;此时已经发现有环了，使用hashset存储链表元素地址，若有相同地址的元素就返回该元素\n        unordered_set&lt;ListNode*&gt; nodes;\n        ListNode* cur &#x3D; head;\n        while (cur !&#x3D; nullptr) &#123;\n            if (nodes.count(cur)) &#123;\n                return cur;\n            &#125;\n            else &#123;\n                nodes.insert(cur);\n                cur &#x3D; cur-&gt;next;\n            &#125;\n        &#125;\n\n        return nullptr;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>快慢指针法</li>\n</ol>\n<p>利用快慢指针，找到链表中是否存在环。若存在环，则将快指针重新指向链表的头结点，并将快慢指针以相同的速度向前移动，直到两个指针相遇，即为环的入口节点。</p>\n<p>假设链表的长度为L，环的长度为C，环的入口节点距离头节点的距离为A，快慢指针相遇的节点距离环的入口节点的距离为B。</p>\n<p>当快慢指针相遇时，快指针走过的距离是慢指针的两倍，即：</p>\n<p>$2 \\times (A + B) &#x3D; A + B + n \\times C$</p>\n<p>其中n是快指针在环中走过的圈数。</p>\n<p>化简得：</p>\n<p>$A &#x3D; (n - 1) \\times C + (C - B)$</p>\n<p>这个式子的意义是，从头节点到环的入口节点的距离等于从相遇点到环的入口节点的距离加上(n - 1)圈的环的长度。</p>\n<p>因此，如果让一个新的指针cur从头节点开始走，同时让slow从相遇点开始走，每次都走一步，那么它们会在环的入口节点相遇，因为它们走过的距离都是A。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\n\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        &#x2F;&#x2F; 判断链表是否为空或只有一个元素\n        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) &#123;\n            return NULL;\n        &#125;\n        &#x2F;&#x2F; 定义快慢指针，初始值指向头结点\n        ListNode* fast &#x3D; head;\n        ListNode* slow &#x3D; head;\n        &#x2F;&#x2F; 判断是否存在环\n        while (fast !&#x3D; NULL &amp;&amp; fast-&gt;next !&#x3D; NULL) &#123;\n            fast &#x3D; fast-&gt;next-&gt;next; &#x2F;&#x2F; 快指针走两步\n            slow &#x3D; slow-&gt;next;       &#x2F;&#x2F; 慢指针走一步\n            if (fast &#x3D;&#x3D; slow) &#123;      &#x2F;&#x2F; 快慢指针相遇\n                ListNode* start &#x3D; head; &#x2F;&#x2F; 从头结点开始，与慢指针同时前进，相遇点即为环的起点\n                while (start !&#x3D; slow) &#123;\n                    start &#x3D; start-&gt;next;\n                    slow &#x3D; slow-&gt;next;\n                &#125;\n                return start;\n            &#125;\n        &#125;\n        return NULL; &#x2F;&#x2F; 遍历完链表，仍未找到环，返回NULL\n    &#125;\n&#125;;\n</code></pre>\n\n<blockquote>\n<p>注：在 while 循环中，因为 fast 比 slow 快，所以应该先判断 fast 是否为 NULL 或 fast-&gt;next 是否为 NULL，以保证程序的正确性。</p>\n</blockquote>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}