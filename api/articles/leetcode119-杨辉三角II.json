{"title":"leetcode119.杨辉三角II","slug":"leetcode119-杨辉三角II","date":"2023-04-24T05:27:41.000Z","updated":"2023-04-24T05:38:24.759Z","comments":true,"path":"api/articles/leetcode119-杨辉三角II.json","excerpt":"题目给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。","covers":["http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2-20230424132835008.gif"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p>\n<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2-20230424132835008.gif\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: rowIndex &#x3D; 3\n输出: [1,3,3,1]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: rowIndex &#x3D; 0\n输出: [1]</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: rowIndex &#x3D; 1\n输出: [1,1]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>0 &lt;= rowIndex &lt;= 33</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<p>你可以优化你的算法到 <code>*O*(*rowIndex*)</code> 空间复杂度吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>得到33行的所有结果，再按照要求返回对应的行的数组</li>\n</ul>\n<p>得到33行的结果的代码可以直接从leetcode118里复制粘贴，最后只需要修改一下return的值就行，需要返回的是result数组里需要的那一行的结果数组。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; getRow(int rowIndex) &#123;\n        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组\n        for (int i &#x3D; 0; i &lt; 34; i++) &#123; &#x2F;&#x2F; 按行进行遍历\n            &#x2F;&#x2F; i是当前行号\n            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字\n            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i\n                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值\n                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行 \n                    continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值\n                &#125;\n                else &#123;\n                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和\n                &#125;\n            &#125;\n            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组\n        &#125;\n        return results[rowIndex];&#x2F;&#x2F; 返回结果数组\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>空间复杂度优化</li>\n</ul>\n<p>本题要求生成杨辉三角的第 <code>rowIndex</code> 行，其中第 <code>i</code> 行有 <code>i+1</code> 个数，即第一行有 1 个数，第二行有 2 个数，第三行有 3 个数，以此类推。</p>\n<p>因为杨辉三角的每一行只依赖于上一行的值，所以我们可以只存储上一行的值，不断地更新，直到得到第 <code>rowIndex</code> 行为止。</p>\n<p>我们可以用一个一维数组来存储上一行的值，并不断地更新数组中的值，最终得到第 <code>rowIndex</code> 行的值。在更新的过程中，我们需要注意到数组的下标从 0 开始，而杨辉三角每一行的第一个数和最后一个数都是 1，所以我们需要在数组的第一个位置和最后一个位置都赋值为 1。</p>\n<p>由于本题要求空间复杂度为 <code>O(rowIndex)</code>，因此我们不能开辟二维数组。在更新数组中的值时，我们需要用到上一行中前面的数和当前行中前面的数，因此我们需要用一个变量 <code>pre</code> 来存储上一行中前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。</p>\n<p>时间复杂度为 <code>O(rowIndex^2)</code>，空间复杂度为 <code>O(rowIndex)</code>。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; getRow(int rowIndex) &#123;\n        vector&lt;int&gt; res(rowIndex + 1, 1);  &#x2F;&#x2F; 初始化结果数组为全 1\n        for (int i &#x3D; 2; i &lt;&#x3D; rowIndex; ++i) &#123;  &#x2F;&#x2F; 从第 2 行开始更新\n            int pre &#x3D; res[0];  &#x2F;&#x2F; 存储上一行前面的数\n            for (int j &#x3D; 1; j &lt; i; ++j) &#123;\n                int temp &#x3D; res[j];  &#x2F;&#x2F; 保存当前位置的值\n                res[j] +&#x3D; pre;  &#x2F;&#x2F; 更新当前位置的值\n                pre &#x3D; temp;  &#x2F;&#x2F; 更新 pre\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n<p>在上述代码中，我们用 <code>res</code> 数组存储上一行的值，并初始化为全 1。然后从第 2 行开始更新，用变量 <code>pre</code> 存储上一行前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。最终返回更新后的结果数组即可。</p>\n<p>由于题目要求返回的是第 <code>rowIndex</code> 行，因此数组的大小应该为 <code>rowIndex + 1</code>。</p>\n","more":"<p><img src=\"http://cdn.leafii.top/img/1626927345-DZmfxB-PascalTriangleAnimated2-20230424132835008.gif\" alt=\"img\"></p>\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: rowIndex &#x3D; 3\n输出: [1,3,3,1]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: rowIndex &#x3D; 0\n输出: [1]</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: rowIndex &#x3D; 1\n输出: [1,1]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>0 &lt;= rowIndex &lt;= 33</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<p>你可以优化你的算法到 <code>*O*(*rowIndex*)</code> 空间复杂度吗？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>得到33行的所有结果，再按照要求返回对应的行的数组</li>\n</ul>\n<p>得到33行的结果的代码可以直接从leetcode118里复制粘贴，最后只需要修改一下return的值就行，需要返回的是result数组里需要的那一行的结果数组。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; getRow(int rowIndex) &#123;\n        vector&lt;vector&lt;int&gt;&gt; results; &#x2F;&#x2F; 初始化结果数组\n        for (int i &#x3D; 0; i &lt; 34; i++) &#123; &#x2F;&#x2F; 按行进行遍历\n            &#x2F;&#x2F; i是当前行号\n            vector&lt;int &gt; temp_arr(i+1, 1); &#x2F;&#x2F; 初始化temp_arr数组用于暂时存储每行的数字\n            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123; &#x2F;&#x2F; 每行的元素等于每行的行号，行号从0开始，所以j &lt;&#x3D; i\n                int temp &#x3D; -1; &#x2F;&#x2F; 用temp存储一行里单个元素的临时值\n                if (j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; i || i &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果遍历到了这一行的第一个元素或者最后一个元素，或者现在在遍历第一行 \n                    continue; &#x2F;&#x2F; 此时无需赋值，因为temp_arr在初始化的时候给所有元素都是1的值\n                &#125;\n                else &#123;\n                    temp_arr[j] &#x3D; results[i-1][j-1] + results[i-1][j]; &#x2F;&#x2F; 否则该行元素就是它左上方和右上方的数的和\n                &#125;\n            &#125;\n            results.push_back(temp_arr); &#x2F;&#x2F; 将遍历完这一行的结果push进最终的结果数组\n        &#125;\n        return results[rowIndex];&#x2F;&#x2F; 返回结果数组\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>空间复杂度优化</li>\n</ul>\n<p>本题要求生成杨辉三角的第 <code>rowIndex</code> 行，其中第 <code>i</code> 行有 <code>i+1</code> 个数，即第一行有 1 个数，第二行有 2 个数，第三行有 3 个数，以此类推。</p>\n<p>因为杨辉三角的每一行只依赖于上一行的值，所以我们可以只存储上一行的值，不断地更新，直到得到第 <code>rowIndex</code> 行为止。</p>\n<p>我们可以用一个一维数组来存储上一行的值，并不断地更新数组中的值，最终得到第 <code>rowIndex</code> 行的值。在更新的过程中，我们需要注意到数组的下标从 0 开始，而杨辉三角每一行的第一个数和最后一个数都是 1，所以我们需要在数组的第一个位置和最后一个位置都赋值为 1。</p>\n<p>由于本题要求空间复杂度为 <code>O(rowIndex)</code>，因此我们不能开辟二维数组。在更新数组中的值时，我们需要用到上一行中前面的数和当前行中前面的数，因此我们需要用一个变量 <code>pre</code> 来存储上一行中前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。</p>\n<p>时间复杂度为 <code>O(rowIndex^2)</code>，空间复杂度为 <code>O(rowIndex)</code>。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; getRow(int rowIndex) &#123;\n        vector&lt;int&gt; res(rowIndex + 1, 1);  &#x2F;&#x2F; 初始化结果数组为全 1\n        for (int i &#x3D; 2; i &lt;&#x3D; rowIndex; ++i) &#123;  &#x2F;&#x2F; 从第 2 行开始更新\n            int pre &#x3D; res[0];  &#x2F;&#x2F; 存储上一行前面的数\n            for (int j &#x3D; 1; j &lt; i; ++j) &#123;\n                int temp &#x3D; res[j];  &#x2F;&#x2F; 保存当前位置的值\n                res[j] +&#x3D; pre;  &#x2F;&#x2F; 更新当前位置的值\n                pre &#x3D; temp;  &#x2F;&#x2F; 更新 pre\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n<p>在上述代码中，我们用 <code>res</code> 数组存储上一行的值，并初始化为全 1。然后从第 2 行开始更新，用变量 <code>pre</code> 存储上一行前面的数，并在更新数组中的值时更新 <code>pre</code> 的值。最终返回更新后的结果数组即可。</p>\n<p>由于题目要求返回的是第 <code>rowIndex</code> 行，因此数组的大小应该为 <code>rowIndex + 1</code>。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}