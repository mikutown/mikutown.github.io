{"title":"leetcode906.超级回文数","slug":"leetcode906-超级回文数","date":"2023-05-19T09:43:18.000Z","updated":"2023-05-19T09:45:56.607Z","comments":true,"path":"api/articles/leetcode906-超级回文数.json","excerpt":"题目如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。现在，给定两个正整数 L 和 R （以字符串形式表示），返回包含在范围 [L, R] 中的超级回文数的数目。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</p>\n<p>现在，给定两个正整数 <code>L</code> 和 <code>R</code> （以字符串形式表示），返回包含在范围 <code>[L, R]</code> 中的超级回文数的数目。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：L &#x3D; &quot;4&quot;, R &#x3D; &quot;1000&quot;\n输出：4\n解释：\n4，9，121，以及 484 是超级回文数。\n注意 676 不是一个超级回文数： 26 * 26 &#x3D; 676，但是 26 不是回文数。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li><code>1 &lt;= len(L) &lt;= 18</code></li>\n<li><code>1 &lt;= len(R) &lt;= 18</code></li>\n<li><code>L</code> 和 <code>R</code> 是表示 <code>[1, 10^18)</code> 范围的整数的字符串。</li>\n<li><code>int(L) &lt;= int(R)</code></li>\n</ol>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接求解</li>\n</ul>\n<ol>\n<li>首先，将输入的左右边界转换为长整型。</li>\n<li>然后，利用两个循环来生成所有可能的回文数：<ul>\n<li>第一个循环从1到9，将每个数字作为回文数的中心，生成回文数。</li>\n<li>第二个循环从1到9999，将每个数字作为回文数的前半部分，并生成回文数的后半部分。</li>\n</ul>\n</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int superpalindromesInRange(string left, string right) &#123;\n        long long leftVal &#x3D; stoll(left); &#x2F;&#x2F; 将左边界转换为长整型\n        long long rightVal &#x3D; stoll(right); &#x2F;&#x2F; 将右边界转换为长整型\n\n        int count &#x3D; 0;\n        &#x2F;&#x2F; 第一部分：生成所有可能的回文数的前半部分\n        for (int i &#x3D; 1; i &lt;&#x3D; 9; ++i) &#123;\n            generatePalindromes(to_string(i), leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数\n        &#125;\n        \n        &#x2F;&#x2F; 第二部分：生成所有可能的回文数的中间部分\n        for (int i &#x3D; 1; i &lt;&#x3D; 9999; ++i) &#123;\n            string leftPart &#x3D; to_string(i);\n            string rightPart &#x3D; to_string(i);\n            reverse(rightPart.begin(), rightPart.end()); &#x2F;&#x2F; 反转右半部分\n            \n            generatePalindromes(leftPart + rightPart, leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数\n            for (int j &#x3D; 0; j &lt;&#x3D; 9; ++j) &#123;\n                generatePalindromes(leftPart + to_string(j) + rightPart, leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数\n            &#125;\n        &#125;\n        \n        return count;\n    &#125;\n    \nprivate:\n    &#x2F;&#x2F; 生成回文数并判断是否为超级回文数\n    void generatePalindromes(string str, long long leftVal, long long rightVal, int&amp; count) &#123;\n        long long num &#x3D; stoll(str);\n        num *&#x3D; num; &#x2F;&#x2F; 平方得到回文数\n        \n        if (num &gt; rightVal) &#123;\n            return;\n        &#125;\n        \n        if (num &gt;&#x3D; leftVal &amp;&amp; isPalindrome(to_string(num))) &#123;\n            ++count;\n        &#125;\n    &#125;\n    \n    &#x2F;&#x2F; 判断是否为回文数\n    bool isPalindrome(string str) &#123;\n        int left &#x3D; 0;\n        int right &#x3D; str.length() - 1;\n        \n        while (left &lt; right) &#123;\n            if (str[left] !&#x3D; str[right]) &#123;\n                return false;\n            &#125;\n            \n            ++left;\n            --right;\n        &#125;\n        \n        return true;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：L &#x3D; &quot;4&quot;, R &#x3D; &quot;1000&quot;\n输出：4\n解释：\n4，9，121，以及 484 是超级回文数。\n注意 676 不是一个超级回文数： 26 * 26 &#x3D; 676，但是 26 不是回文数。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li><code>1 &lt;= len(L) &lt;= 18</code></li>\n<li><code>1 &lt;= len(R) &lt;= 18</code></li>\n<li><code>L</code> 和 <code>R</code> 是表示 <code>[1, 10^18)</code> 范围的整数的字符串。</li>\n<li><code>int(L) &lt;= int(R)</code></li>\n</ol>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接求解</li>\n</ul>\n<ol>\n<li>首先，将输入的左右边界转换为长整型。</li>\n<li>然后，利用两个循环来生成所有可能的回文数：<ul>\n<li>第一个循环从1到9，将每个数字作为回文数的中心，生成回文数。</li>\n<li>第二个循环从1到9999，将每个数字作为回文数的前半部分，并生成回文数的后半部分。</li>\n</ul>\n</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int superpalindromesInRange(string left, string right) &#123;\n        long long leftVal &#x3D; stoll(left); &#x2F;&#x2F; 将左边界转换为长整型\n        long long rightVal &#x3D; stoll(right); &#x2F;&#x2F; 将右边界转换为长整型\n\n        int count &#x3D; 0;\n        &#x2F;&#x2F; 第一部分：生成所有可能的回文数的前半部分\n        for (int i &#x3D; 1; i &lt;&#x3D; 9; ++i) &#123;\n            generatePalindromes(to_string(i), leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数\n        &#125;\n        \n        &#x2F;&#x2F; 第二部分：生成所有可能的回文数的中间部分\n        for (int i &#x3D; 1; i &lt;&#x3D; 9999; ++i) &#123;\n            string leftPart &#x3D; to_string(i);\n            string rightPart &#x3D; to_string(i);\n            reverse(rightPart.begin(), rightPart.end()); &#x2F;&#x2F; 反转右半部分\n            \n            generatePalindromes(leftPart + rightPart, leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数\n            for (int j &#x3D; 0; j &lt;&#x3D; 9; ++j) &#123;\n                generatePalindromes(leftPart + to_string(j) + rightPart, leftVal, rightVal, count); &#x2F;&#x2F; 以i为中心，生成回文数\n            &#125;\n        &#125;\n        \n        return count;\n    &#125;\n    \nprivate:\n    &#x2F;&#x2F; 生成回文数并判断是否为超级回文数\n    void generatePalindromes(string str, long long leftVal, long long rightVal, int&amp; count) &#123;\n        long long num &#x3D; stoll(str);\n        num *&#x3D; num; &#x2F;&#x2F; 平方得到回文数\n        \n        if (num &gt; rightVal) &#123;\n            return;\n        &#125;\n        \n        if (num &gt;&#x3D; leftVal &amp;&amp; isPalindrome(to_string(num))) &#123;\n            ++count;\n        &#125;\n    &#125;\n    \n    &#x2F;&#x2F; 判断是否为回文数\n    bool isPalindrome(string str) &#123;\n        int left &#x3D; 0;\n        int right &#x3D; str.length() - 1;\n        \n        while (left &lt; right) &#123;\n            if (str[left] !&#x3D; str[right]) &#123;\n                return false;\n            &#125;\n            \n            ++left;\n            --right;\n        &#125;\n        \n        return true;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}