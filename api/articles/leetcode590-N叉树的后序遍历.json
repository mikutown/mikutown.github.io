{"title":"leetcode590.N叉树的后序遍历","slug":"leetcode590-N叉树的后序遍历","date":"2023-07-24T03:22:59.000Z","updated":"2023-07-24T03:39:27.990Z","comments":true,"path":"api/articles/leetcode590-N叉树的后序遍历.json","excerpt":null,"covers":["http://cdn.leafii.top/img/narytreeexample.png","http://cdn.leafii.top/img/sample_4_964.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个 n 叉树的根节点 <code>root</code> ，返回 <em>其节点值的 <strong>后序遍历</strong></em> 。</p>\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/narytreeexample.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,3,2,4,null,5,6]\n输出：[5,6,3,2,4,1]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/sample_4_964.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>节点总数在范围 <code>[0, 104]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 104</code></li>\n<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归法</li>\n</ul>\n<p>直接上代码。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() &#123;&#125;\n\n    Node(int _val) &#123;\n        val &#x3D; _val;\n    &#125;\n\n    Node(int _val, vector&lt;Node*&gt; _children) &#123;\n        val &#x3D; _val;\n        children &#x3D; _children;\n    &#125;\n&#125;;\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; postorder(Node* root) &#123;\n        vector&lt;int&gt; result;\n        if (!root) return result;\n        \n        postorderHelper(root, result);\n        return result;\n    &#125;\n    \n    &#x2F;&#x2F; 后序遍历辅助函数\n    void postorderHelper(Node* node, vector&lt;int&gt;&amp; result) &#123;\n        if (!node) return;\n        \n        for (Node* child : node-&gt;children) &#123;\n            postorderHelper(child, result);\n        &#125;\n        \n        result.push_back(node-&gt;val);\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>迭代法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() &#123;&#125;\n\n    Node(int _val) &#123;\n        val &#x3D; _val;\n    &#125;\n\n    Node(int _val, vector&lt;Node*&gt; _children) &#123;\n        val &#x3D; _val;\n        children &#x3D; _children;\n    &#125;\n&#125;;\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; postorder(Node* root) &#123;\n        vector&lt;int&gt; result;\n        if (root &#x3D;&#x3D; NULL) return result;\n        stack&lt;Node*&gt; st;\n        st.push(root);\n        while (!st.empty()) &#123;\n            Node* node &#x3D; st.top();\n            st.pop();\n            result.push_back(node-&gt;val);\n            for (int i &#x3D; 0; i &lt; node-&gt;children.size(); i++) &#123; &#x2F;&#x2F; 相对于前序遍历，这里反过来\n                if (node-&gt;children[i] !&#x3D; NULL) &#123;\n                    st.push(node-&gt;children[i]);\n                &#125;\n            &#125;\n        &#125;\n        reverse(result.begin(), result.end()); &#x2F;&#x2F; 反转数组\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个 n 叉树的根节点 <code>root</code> ，返回 <em>其节点值的 <strong>后序遍历</strong></em> 。</p>\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/narytreeexample.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,3,2,4,null,5,6]\n输出：[5,6,3,2,4,1]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/sample_4_964.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>节点总数在范围 <code>[0, 104]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 104</code></li>\n<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归法</li>\n</ul>\n<p>直接上代码。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() &#123;&#125;\n\n    Node(int _val) &#123;\n        val &#x3D; _val;\n    &#125;\n\n    Node(int _val, vector&lt;Node*&gt; _children) &#123;\n        val &#x3D; _val;\n        children &#x3D; _children;\n    &#125;\n&#125;;\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; postorder(Node* root) &#123;\n        vector&lt;int&gt; result;\n        if (!root) return result;\n        \n        postorderHelper(root, result);\n        return result;\n    &#125;\n    \n    &#x2F;&#x2F; 后序遍历辅助函数\n    void postorderHelper(Node* node, vector&lt;int&gt;&amp; result) &#123;\n        if (!node) return;\n        \n        for (Node* child : node-&gt;children) &#123;\n            postorderHelper(child, result);\n        &#125;\n        \n        result.push_back(node-&gt;val);\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>迭代法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() &#123;&#125;\n\n    Node(int _val) &#123;\n        val &#x3D; _val;\n    &#125;\n\n    Node(int _val, vector&lt;Node*&gt; _children) &#123;\n        val &#x3D; _val;\n        children &#x3D; _children;\n    &#125;\n&#125;;\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; postorder(Node* root) &#123;\n        vector&lt;int&gt; result;\n        if (root &#x3D;&#x3D; NULL) return result;\n        stack&lt;Node*&gt; st;\n        st.push(root);\n        while (!st.empty()) &#123;\n            Node* node &#x3D; st.top();\n            st.pop();\n            result.push_back(node-&gt;val);\n            for (int i &#x3D; 0; i &lt; node-&gt;children.size(); i++) &#123; &#x2F;&#x2F; 相对于前序遍历，这里反过来\n                if (node-&gt;children[i] !&#x3D; NULL) &#123;\n                    st.push(node-&gt;children[i]);\n                &#125;\n            &#125;\n        &#125;\n        reverse(result.begin(), result.end()); &#x2F;&#x2F; 反转数组\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}