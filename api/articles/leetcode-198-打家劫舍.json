{"title":"leetcode:198.打家劫舍","slug":"leetcode-198-打家劫舍","date":"2023-02-03T06:32:26.000Z","updated":"2023-02-05T04:48:09.411Z","comments":true,"path":"api/articles/leetcode-198-打家劫舍.json","excerpt":"题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。\n     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。\n     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</code></pre>\n\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>动态规划分析如下：</p>\n<ol>\n<li>确定dp数组(dp table)以及它的下标的含义：</li>\n</ol>\n<p>dp[i]:考虑下标i以内的房屋，最多可以偷窃的金额为dp[i];</p>\n<ol start=\"2\">\n<li>确定递推公式</li>\n</ol>\n<p>决定是否偷第i个房间:</p>\n<ul>\n<li>如果偷第i个房间，dp[i] &#x3D; dp[i - 2] + nums[i];</li>\n</ul>\n<p>也就是不偷第i-1，而是找到i-2以内最多的房屋，然后再加上第i间房偷到的钱。</p>\n<ul>\n<li>如果不偷第i个房间，那么dp[i] &#x3D; dp[i - 1];也就是要考虑i-1房（<strong>注意这里是考虑而不是真的要偷i-1房</strong>）</li>\n</ul>\n<p>完成分析后取dp[i]的最大值，也就是dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);</p>\n<ol start=\"3\">\n<li>dp数组如何初始化</li>\n</ol>\n<p>因为dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);所以基础就是dp[0]和dp[1];</p>\n<p>因此dp[0] &#x3D; nums[0],dp[1] &#x3D; max(nums[0], nums[1]);</p>\n<ol start=\"4\">\n<li>确定遍历顺序</li>\n</ol>\n<p>dp[i]是根据dp[i-2]和dp[i-1]推导出来的，那么一定是从前到后遍历。</p>\n<ol start=\"5\">\n<li>举例推导dp数组</li>\n</ol>\n<p>C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.empty()) &#123;\n            return 0;\n        &#125;\n        int size &#x3D; nums.size();\n        if(size &#x3D;&#x3D; 1) &#123;\n            return nums[0];\n        &#125;\n\n        vector&lt;int&gt; dp &#x3D; vector&lt;int&gt;(size, 0); &#x2F;&#x2F;3. initialize\n        dp[0] &#x3D; nums[0];\n        dp[1] &#x3D; max(nums[0], nums[1]);\n        &#x2F;&#x2F;4. 遍历\n        for(int i &#x3D; 2; i &lt; size; i++) &#123;\n            dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);\n        &#125;\n        return dp[size - 1];\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。\n     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。\n     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</code></pre>\n\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>动态规划分析如下：</p>\n<ol>\n<li>确定dp数组(dp table)以及它的下标的含义：</li>\n</ol>\n<p>dp[i]:考虑下标i以内的房屋，最多可以偷窃的金额为dp[i];</p>\n<ol start=\"2\">\n<li>确定递推公式</li>\n</ol>\n<p>决定是否偷第i个房间:</p>\n<ul>\n<li>如果偷第i个房间，dp[i] &#x3D; dp[i - 2] + nums[i];</li>\n</ul>\n<p>也就是不偷第i-1，而是找到i-2以内最多的房屋，然后再加上第i间房偷到的钱。</p>\n<ul>\n<li>如果不偷第i个房间，那么dp[i] &#x3D; dp[i - 1];也就是要考虑i-1房（<strong>注意这里是考虑而不是真的要偷i-1房</strong>）</li>\n</ul>\n<p>完成分析后取dp[i]的最大值，也就是dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);</p>\n<ol start=\"3\">\n<li>dp数组如何初始化</li>\n</ol>\n<p>因为dp[i] &#x3D; max(dp[i-2] + nums[i], dp[i-1]);所以基础就是dp[0]和dp[1];</p>\n<p>因此dp[0] &#x3D; nums[0],dp[1] &#x3D; max(nums[0], nums[1]);</p>\n<ol start=\"4\">\n<li>确定遍历顺序</li>\n</ol>\n<p>dp[i]是根据dp[i-2]和dp[i-1]推导出来的，那么一定是从前到后遍历。</p>\n<ol start=\"5\">\n<li>举例推导dp数组</li>\n</ol>\n<p>C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.empty()) &#123;\n            return 0;\n        &#125;\n        int size &#x3D; nums.size();\n        if(size &#x3D;&#x3D; 1) &#123;\n            return nums[0];\n        &#125;\n\n        vector&lt;int&gt; dp &#x3D; vector&lt;int&gt;(size, 0); &#x2F;&#x2F;3. initialize\n        dp[0] &#x3D; nums[0];\n        dp[1] &#x3D; max(nums[0], nums[1]);\n        &#x2F;&#x2F;4. 遍历\n        for(int i &#x3D; 2; i &lt; size; i++) &#123;\n            dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);\n        &#125;\n        return dp[size - 1];\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}