{"title":"leetcode383.赎金信","slug":"leetcode383-赎金信","date":"2023-10-17T00:53:04.000Z","updated":"2023-10-17T01:10:07.495Z","comments":true,"path":"api/articles/leetcode383-赎金信.json","excerpt":"题目给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p>\n<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>\n<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;\n输出：false</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;\n输出：false</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;\n输出：true</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li>\n<li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力枚举</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canConstruct(string ransomNote, string magazine) &#123;\n        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;\n            for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;\n                &#x2F;&#x2F; 在ransomNote中找到和magazine相同的字符\n                if (magazine[i] &#x3D;&#x3D; ransomNote[j]) &#123;\n                    ransomNote.erase(ransomNote.begin() + j); &#x2F;&#x2F; ransomNote删除这个字符\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 如果ransomNote为空，则说明magazine的字符可以组成ransomNote\n        if (ransomNote.length() &#x3D;&#x3D; 0) &#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>哈希表</li>\n</ul>\n<p>使用哈希表分别统计两个字符串中字母的个数，然后对比两个哈希表的结果，如果前者的字母统计个数大于后者，直接返回false，否则最终返回true</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canConstruct(string ransomNote, string magazine) &#123;\n        &#x2F;&#x2F; 初始化哈希表用于统计字符数\n        unordered_map&lt;char, int&gt; ransomNoteCnt;\n        unordered_map&lt;char, int&gt; magezineCnt;\n        for (char c:ransomNote) &#123;\n            ransomNoteCnt[c] &#x3D; ransomNoteCnt[c]&#x3D;&#x3D;0?1:ransomNoteCnt[c]+1;\n        &#125;\n        for (char c:magazine) &#123;\n            magezineCnt[c] &#x3D; magezineCnt[c]&#x3D;&#x3D;0?1:magezineCnt[c]+1;\n        &#125;\n        for (char c &#x3D; &#39;a&#39;; c &lt;&#x3D; &#39;z&#39;; c++) &#123;\n            if (ransomNoteCnt[c] &lt;&#x3D; magezineCnt[c]) continue;\n            else return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ul>\n<li>更省空间的哈希表解法</li>\n</ul>\n<p>因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个长度为26的数组来记录magazine里字母出现的次数。</p>\n<p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p>\n<p>依然是数组在哈希法中的应用。</p>\n<p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canConstruct(string ransomNote, string magazine) &#123;\n        int record[26] &#x3D; &#123;0&#125;;\n        &#x2F;&#x2F;add\n        if (ransomNote.size() &gt; magazine.size()) &#123;\n            return false;\n        &#125;\n        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;\n            &#x2F;&#x2F; 通过record数据记录 magazine里各个字符出现次数\n            record[magazine[i]-&#39;a&#39;] ++;\n        &#125;\n        for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;\n            &#x2F;&#x2F; 遍历ransomNote，在record里对应的字符个数做--操作\n            record[ransomNote[j]-&#39;a&#39;]--;\n            &#x2F;&#x2F; 如果小于零说明ransomNote里出现的字符，magazine没有\n            if(record[ransomNote[j]-&#39;a&#39;] &lt; 0) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;\n输出：false</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;\n输出：false</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;\n输出：true</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li>\n<li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力枚举</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canConstruct(string ransomNote, string magazine) &#123;\n        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;\n            for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;\n                &#x2F;&#x2F; 在ransomNote中找到和magazine相同的字符\n                if (magazine[i] &#x3D;&#x3D; ransomNote[j]) &#123;\n                    ransomNote.erase(ransomNote.begin() + j); &#x2F;&#x2F; ransomNote删除这个字符\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 如果ransomNote为空，则说明magazine的字符可以组成ransomNote\n        if (ransomNote.length() &#x3D;&#x3D; 0) &#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>哈希表</li>\n</ul>\n<p>使用哈希表分别统计两个字符串中字母的个数，然后对比两个哈希表的结果，如果前者的字母统计个数大于后者，直接返回false，否则最终返回true</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canConstruct(string ransomNote, string magazine) &#123;\n        &#x2F;&#x2F; 初始化哈希表用于统计字符数\n        unordered_map&lt;char, int&gt; ransomNoteCnt;\n        unordered_map&lt;char, int&gt; magezineCnt;\n        for (char c:ransomNote) &#123;\n            ransomNoteCnt[c] &#x3D; ransomNoteCnt[c]&#x3D;&#x3D;0?1:ransomNoteCnt[c]+1;\n        &#125;\n        for (char c:magazine) &#123;\n            magezineCnt[c] &#x3D; magezineCnt[c]&#x3D;&#x3D;0?1:magezineCnt[c]+1;\n        &#125;\n        for (char c &#x3D; &#39;a&#39;; c &lt;&#x3D; &#39;z&#39;; c++) &#123;\n            if (ransomNoteCnt[c] &lt;&#x3D; magezineCnt[c]) continue;\n            else return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ul>\n<li>更省空间的哈希表解法</li>\n</ul>\n<p>因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个长度为26的数组来记录magazine里字母出现的次数。</p>\n<p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p>\n<p>依然是数组在哈希法中的应用。</p>\n<p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool canConstruct(string ransomNote, string magazine) &#123;\n        int record[26] &#x3D; &#123;0&#125;;\n        &#x2F;&#x2F;add\n        if (ransomNote.size() &gt; magazine.size()) &#123;\n            return false;\n        &#125;\n        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;\n            &#x2F;&#x2F; 通过record数据记录 magazine里各个字符出现次数\n            record[magazine[i]-&#39;a&#39;] ++;\n        &#125;\n        for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;\n            &#x2F;&#x2F; 遍历ransomNote，在record里对应的字符个数做--操作\n            record[ransomNote[j]-&#39;a&#39;]--;\n            &#x2F;&#x2F; 如果小于零说明ransomNote里出现的字符，magazine没有\n            if(record[ransomNote[j]-&#39;a&#39;] &lt; 0) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}