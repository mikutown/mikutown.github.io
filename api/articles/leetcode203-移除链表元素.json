{"title":"leetcode203.移除链表元素","slug":"leetcode203-移除链表元素","date":"2023-02-26T05:43:26.000Z","updated":"2023-02-26T05:56:06.765Z","comments":true,"path":"api/articles/leetcode203-移除链表元素.json","excerpt":"题目给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。","covers":["http://cdn.leafii.top/img/removelinked-list.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/removelinked-list.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6\n输出：[1,2,3,4,5]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [], val &#x3D; 1\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [7,7,7,7], val &#x3D; 7\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>\n<li><code>1 &lt;= Node.val &lt;= 50</code></li>\n<li><code>0 &lt;= val &lt;= 50</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>虚拟头节点法：</li>\n</ol>\n<p>若使用常规思路，在移除节点有两种情况：</p>\n<ul>\n<li><p>非头节点的移除：直接讲被删除节点的前一个节点同被删除节点的后一个节点连接，然后删除当前的被删除节点；</p>\n</li>\n<li><p>头节点的移除：新建一个节点指向头节点，令头节点等于头节点的后继节点，然后删除刚才指向头节点的新建节点。</p>\n</li>\n</ul>\n<p>为了防止需要写两个逻辑判断到底怎么删除节点，在这里直接使用一个虚拟节点，他的后继节点指向头节点，此时本来需要被特殊处理的头节点也可以按照非头节点的移除方法进行移除了，在循环的最后删除虚拟头节点，返回虚拟头节点的后继节点（即真实头节点）。C++代码实现思路如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* removeElements(ListNode* head, int val) &#123;\n        ListNode* visualHead &#x3D; new ListNode(0); &#x2F;&#x2F; 新建虚拟头节点\n        visualHead-&gt;next &#x3D; head;\n        ListNode* cur &#x3D; visualHead; &#x2F;&#x2F; cur指现在要处理的节点，默认指向虚拟头节点\n        while (cur-&gt;next!&#x3D;NULL) &#123; &#x2F;&#x2F; 开始循环\n            if (cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123; &#x2F;&#x2F; 如果值匹配，则进行删除\n                ListNode* tmp &#x3D; cur-&gt;next;\n                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;\n                delete tmp;\n            &#125; else &#123; &#x2F;&#x2F; 否则当前指针更新为它的next指针指向的元素\n                cur &#x3D; cur-&gt;next;\n            &#125;\n        &#125;\n        head &#x3D; visualHead-&gt;next; &#x2F;&#x2F; 得到删除对应元素之后的头节点\n        delete visualHead; &#x2F;&#x2F; 删除虚拟头节点，以降低空间复杂度\n        return head; &#x2F;&#x2F; 返回头节点，算法结束\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/removelinked-list.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6\n输出：[1,2,3,4,5]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [], val &#x3D; 1\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [7,7,7,7], val &#x3D; 7\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>\n<li><code>1 &lt;= Node.val &lt;= 50</code></li>\n<li><code>0 &lt;= val &lt;= 50</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>虚拟头节点法：</li>\n</ol>\n<p>若使用常规思路，在移除节点有两种情况：</p>\n<ul>\n<li><p>非头节点的移除：直接讲被删除节点的前一个节点同被删除节点的后一个节点连接，然后删除当前的被删除节点；</p>\n</li>\n<li><p>头节点的移除：新建一个节点指向头节点，令头节点等于头节点的后继节点，然后删除刚才指向头节点的新建节点。</p>\n</li>\n</ul>\n<p>为了防止需要写两个逻辑判断到底怎么删除节点，在这里直接使用一个虚拟节点，他的后继节点指向头节点，此时本来需要被特殊处理的头节点也可以按照非头节点的移除方法进行移除了，在循环的最后删除虚拟头节点，返回虚拟头节点的后继节点（即真实头节点）。C++代码实现思路如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* removeElements(ListNode* head, int val) &#123;\n        ListNode* visualHead &#x3D; new ListNode(0); &#x2F;&#x2F; 新建虚拟头节点\n        visualHead-&gt;next &#x3D; head;\n        ListNode* cur &#x3D; visualHead; &#x2F;&#x2F; cur指现在要处理的节点，默认指向虚拟头节点\n        while (cur-&gt;next!&#x3D;NULL) &#123; &#x2F;&#x2F; 开始循环\n            if (cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123; &#x2F;&#x2F; 如果值匹配，则进行删除\n                ListNode* tmp &#x3D; cur-&gt;next;\n                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;\n                delete tmp;\n            &#125; else &#123; &#x2F;&#x2F; 否则当前指针更新为它的next指针指向的元素\n                cur &#x3D; cur-&gt;next;\n            &#125;\n        &#125;\n        head &#x3D; visualHead-&gt;next; &#x2F;&#x2F; 得到删除对应元素之后的头节点\n        delete visualHead; &#x2F;&#x2F; 删除虚拟头节点，以降低空间复杂度\n        return head; &#x2F;&#x2F; 返回头节点，算法结束\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}