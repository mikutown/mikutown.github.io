{"title":"leetcode322.零钱兑换","slug":"leetcode322-零钱兑换","date":"2023-05-22T08:09:17.000Z","updated":"2023-05-22T08:11:34.895Z","comments":true,"path":"api/articles/leetcode322-零钱兑换.json","excerpt":"题目给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>\n<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11\n输出：3 \n解释：11 &#x3D; 5 + 5 + 1</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：coins &#x3D; [2], amount &#x3D; 3\n输出：-1</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：coins &#x3D; [1], amount &#x3D; 0\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= coins.length &lt;= 12</code></li>\n<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>\n<li><code>0 &lt;= amount &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>解题思路：</p>\n<ul>\n<li>创建一个长度为 amount + 1 的数组 <code>dp</code>，用于保存每个金额对应的最小硬币数量。初始时，将数组中所有元素的值设置为一个较大的值，表示无穷大。</li>\n<li>将金额为 0 的最小硬币数量设为 0。</li>\n<li>通过动态规划的方式，遍历每个金额，计算最小硬币数量。</li>\n<li>对于当前金额 i，遍历每个硬币的面值，如果当前硬币面值小于等于当前金额 i，则计算使用当前硬币后的剩余金额 remainder。</li>\n<li>检查剩余金额的最小硬币数量是否为有效值，如果是，则更新当前金额 i 的最小硬币数量为 <code>dp[remainder] + 1</code>（加 1 表示使用了当前硬币）。</li>\n<li>最终，如果最终金额的最小硬币数量仍为无效值（即未被更新），则返回 -1，否则返回最小硬币数量。</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;vector&gt;\n#include &lt;climits&gt;\n\nclass Solution &#123;\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;\n        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量\n        vector&lt;int&gt; dp(amount + 1, INT_MAX);\n        \n        &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0\n        dp[0] &#x3D; 0;\n        \n        &#x2F;&#x2F; 遍历每个金额，计算最小硬币数量\n        for (int i &#x3D; 1; i &lt;&#x3D; amount; ++i) &#123;\n            &#x2F;&#x2F; 遍历每个硬币的面值\n            for (int j &#x3D; 0; j &lt; coins.size(); ++j) &#123;\n                &#x2F;&#x2F; 如果当前硬币面值小于等于当前金额 i\n                if (coins[j] &lt;&#x3D; i) &#123;\n                    &#x2F;&#x2F; 计算使用当前硬币后的剩余金额\n                    int remainder &#x3D; i - coins[j];\n                    \n                    &#x2F;&#x2F; 检查剩余金额的最小硬币数量是否为有效值\n                    if (dp[remainder] !&#x3D; INT_MAX) &#123;\n                        &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量\n                        dp[i] &#x3D; min(dp[i], dp[remainder] + 1);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        \n        &#x2F;&#x2F; 如果最终金额的最小硬币数量为无效值，则返回 -1，否则返回最小硬币数量\n        return dp[amount] &#x3D;&#x3D; INT_MAX ? -1 : dp[amount];\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>动态规划（优化）</li>\n</ol>\n<ul>\n<li>通过使用范围-based for 循环遍历硬币面值，可以简化代码并提高可读性。</li>\n<li>内层循环从硬币面值开始，而不是从 1 开始，这样可以避免重复计算和无效的更新。</li>\n<li>这种优化利用了动态规划的特性，逐步计算每个金额的最小硬币数量。</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;vector&gt;\n#include &lt;climits&gt;\n#include &lt;algorithm&gt;\n\nclass Solution &#123;\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;\n        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量\n        vector&lt;int&gt; dp(amount + 1, amount + 1);\n        &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0\n        dp[0] &#x3D; 0;\n\n        &#x2F;&#x2F; 动态规划，遍历每个金额，计算最小硬币数量\n        for (int coin : coins) &#123;\n            for (int i &#x3D; coin; i &lt;&#x3D; amount; ++i) &#123;\n                &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量\n                dp[i] &#x3D; min(dp[i], dp[i - coin] + 1);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 如果最终金额的最小硬币数量仍然大于 amount，则表示无法凑出该金额，返回 -1\n        if (dp[amount] &gt; amount) &#123;\n            return -1;\n        &#125; else &#123;\n            &#x2F;&#x2F; 返回最小硬币数量\n            return dp[amount];\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11\n输出：3 \n解释：11 &#x3D; 5 + 5 + 1</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：coins &#x3D; [2], amount &#x3D; 3\n输出：-1</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：coins &#x3D; [1], amount &#x3D; 0\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= coins.length &lt;= 12</code></li>\n<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>\n<li><code>0 &lt;= amount &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>动态规划</li>\n</ol>\n<p>解题思路：</p>\n<ul>\n<li>创建一个长度为 amount + 1 的数组 <code>dp</code>，用于保存每个金额对应的最小硬币数量。初始时，将数组中所有元素的值设置为一个较大的值，表示无穷大。</li>\n<li>将金额为 0 的最小硬币数量设为 0。</li>\n<li>通过动态规划的方式，遍历每个金额，计算最小硬币数量。</li>\n<li>对于当前金额 i，遍历每个硬币的面值，如果当前硬币面值小于等于当前金额 i，则计算使用当前硬币后的剩余金额 remainder。</li>\n<li>检查剩余金额的最小硬币数量是否为有效值，如果是，则更新当前金额 i 的最小硬币数量为 <code>dp[remainder] + 1</code>（加 1 表示使用了当前硬币）。</li>\n<li>最终，如果最终金额的最小硬币数量仍为无效值（即未被更新），则返回 -1，否则返回最小硬币数量。</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;vector&gt;\n#include &lt;climits&gt;\n\nclass Solution &#123;\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;\n        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量\n        vector&lt;int&gt; dp(amount + 1, INT_MAX);\n        \n        &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0\n        dp[0] &#x3D; 0;\n        \n        &#x2F;&#x2F; 遍历每个金额，计算最小硬币数量\n        for (int i &#x3D; 1; i &lt;&#x3D; amount; ++i) &#123;\n            &#x2F;&#x2F; 遍历每个硬币的面值\n            for (int j &#x3D; 0; j &lt; coins.size(); ++j) &#123;\n                &#x2F;&#x2F; 如果当前硬币面值小于等于当前金额 i\n                if (coins[j] &lt;&#x3D; i) &#123;\n                    &#x2F;&#x2F; 计算使用当前硬币后的剩余金额\n                    int remainder &#x3D; i - coins[j];\n                    \n                    &#x2F;&#x2F; 检查剩余金额的最小硬币数量是否为有效值\n                    if (dp[remainder] !&#x3D; INT_MAX) &#123;\n                        &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量\n                        dp[i] &#x3D; min(dp[i], dp[remainder] + 1);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        \n        &#x2F;&#x2F; 如果最终金额的最小硬币数量为无效值，则返回 -1，否则返回最小硬币数量\n        return dp[amount] &#x3D;&#x3D; INT_MAX ? -1 : dp[amount];\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>动态规划（优化）</li>\n</ol>\n<ul>\n<li>通过使用范围-based for 循环遍历硬币面值，可以简化代码并提高可读性。</li>\n<li>内层循环从硬币面值开始，而不是从 1 开始，这样可以避免重复计算和无效的更新。</li>\n<li>这种优化利用了动态规划的特性，逐步计算每个金额的最小硬币数量。</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;vector&gt;\n#include &lt;climits&gt;\n#include &lt;algorithm&gt;\n\nclass Solution &#123;\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;\n        &#x2F;&#x2F; 创建一个长度为 amount + 1 的数组，用于保存每个金额对应的最小硬币数量\n        vector&lt;int&gt; dp(amount + 1, amount + 1);\n        &#x2F;&#x2F; 初始化金额为 0 的最小硬币数量为 0\n        dp[0] &#x3D; 0;\n\n        &#x2F;&#x2F; 动态规划，遍历每个金额，计算最小硬币数量\n        for (int coin : coins) &#123;\n            for (int i &#x3D; coin; i &lt;&#x3D; amount; ++i) &#123;\n                &#x2F;&#x2F; 更新当前金额 i 的最小硬币数量\n                dp[i] &#x3D; min(dp[i], dp[i - coin] + 1);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 如果最终金额的最小硬币数量仍然大于 amount，则表示无法凑出该金额，返回 -1\n        if (dp[amount] &gt; amount) &#123;\n            return -1;\n        &#125; else &#123;\n            &#x2F;&#x2F; 返回最小硬币数量\n            return dp[amount];\n        &#125;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]}