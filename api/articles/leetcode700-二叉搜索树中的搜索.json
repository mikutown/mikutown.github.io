{"title":"leetcode700.二叉搜索树中的搜索","slug":"leetcode700-二叉搜索树中的搜索","date":"2023-05-29T07:09:15.000Z","updated":"2023-05-29T07:13:35.122Z","comments":true,"path":"api/articles/leetcode700-二叉搜索树中的搜索.json","excerpt":"题目给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。","covers":["http://cdn.leafii.top/img/tree1.jpg","http://cdn.leafii.top/img/tree2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p>\n<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2\n输出：[2,1,3]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>数中节点数在 <code>[1, 5000]</code> 范围内</li>\n<li><code>1 &lt;= Node.val &lt;= 107</code></li>\n<li><code>root</code> 是二叉搜索树</li>\n<li><code>1 &lt;= val &lt;= 107</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接搜索</li>\n</ul>\n<p>在二叉搜索树中，每个节点的值大于其左子树中的所有节点的值，小于其右子树中的所有节点的值，因此可以利用这个性质进行查找操作。你的方法通过迭代方式在二叉搜索树中查找给定值，并返回匹配的节点指针。这种查找方式通常称为”二叉搜索树的查找”或”BST查找”。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) &#123;\n        while (root !&#x3D; nullptr) &#123; &#x2F;&#x2F; 在root非空的情况下进行循环\n            if (val &#x3D;&#x3D; root-&gt;val) &#123;\n                return root; &#x2F;&#x2F; 如果值匹配就直接返回root\n            &#125;\n            else if (val &gt; root-&gt;val) &#123;\n                root &#x3D; root-&gt;right; &#x2F;&#x2F; 如果值大于root现有的值，它的目标节点只有可能在他的右子树\n            &#125;\n            else &#123;\n                root &#x3D; root-&gt;left; &#x2F;&#x2F; 如果值小于root现有的值，它的目标节点只有可能在他的左子树\n            &#125;\n        &#125;\n        return nullptr; &#x2F;&#x2F; 如果root为空（不管是现有的root还是迭代后的root） 就直接返回nullptr\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2\n输出：[2,1,3]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>数中节点数在 <code>[1, 5000]</code> 范围内</li>\n<li><code>1 &lt;= Node.val &lt;= 107</code></li>\n<li><code>root</code> 是二叉搜索树</li>\n<li><code>1 &lt;= val &lt;= 107</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>直接搜索</li>\n</ul>\n<p>在二叉搜索树中，每个节点的值大于其左子树中的所有节点的值，小于其右子树中的所有节点的值，因此可以利用这个性质进行查找操作。你的方法通过迭代方式在二叉搜索树中查找给定值，并返回匹配的节点指针。这种查找方式通常称为”二叉搜索树的查找”或”BST查找”。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) &#123;\n        while (root !&#x3D; nullptr) &#123; &#x2F;&#x2F; 在root非空的情况下进行循环\n            if (val &#x3D;&#x3D; root-&gt;val) &#123;\n                return root; &#x2F;&#x2F; 如果值匹配就直接返回root\n            &#125;\n            else if (val &gt; root-&gt;val) &#123;\n                root &#x3D; root-&gt;right; &#x2F;&#x2F; 如果值大于root现有的值，它的目标节点只有可能在他的右子树\n            &#125;\n            else &#123;\n                root &#x3D; root-&gt;left; &#x2F;&#x2F; 如果值小于root现有的值，它的目标节点只有可能在他的左子树\n            &#125;\n        &#125;\n        return nullptr; &#x2F;&#x2F; 如果root为空（不管是现有的root还是迭代后的root） 就直接返回nullptr\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}