{"title":"leetcode96.不同的二叉搜索树","slug":"leetcode96-不同的二叉搜索树","date":"2023-08-03T00:39:28.000Z","updated":"2023-08-03T00:44:33.655Z","comments":true,"path":"api/articles/leetcode96-不同的二叉搜索树.json","excerpt":null,"covers":["http://cdn.leafii.top/img/uniquebstn3.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/uniquebstn3.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3\n输出：5</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1\n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 19</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>解题思路： 这个问题可以用动态规划来解决。我们创建一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以 <code>i</code> 个节点构建的二叉搜索树的数量。我们可以观察到，对于每个 <code>i</code>，我们可以将每个节点依次作为根节点，将问题划分为子问题。例如，以节点 <code>j</code> 作为根节点，它的左子树将有 <code>j - 1</code> 个节点，右子树将有 <code>i - j</code> 个节点。所以，以节点 <code>j</code> 作为根节点的二叉搜索树数量为 <code>dp[j - 1] * dp[i - j]</code>。我们将所有以不同节点作为根节点的情况累加起来，就得到了 <code>dp[i]</code> 的值。</p>\n<p>在循环计算 <code>dp</code> 数组时，外层循环遍历节点数量 <code>i</code>，内层循环遍历以不同节点为根节点的情况 <code>j</code>。最终，<code>dp[n]</code> 就是我们所求的以 <code>n</code> 个节点构建的不同二叉搜索树的数量。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int numTrees(int n) &#123;\n        &#x2F;&#x2F; 创建一个数组来存储以1到n为节点的二叉搜索树的数量\n        vector&lt;int&gt; dp(n + 1, 0);\n        &#x2F;&#x2F; 空树也算一种情况，初始化dp[0]为1\n        dp[0] &#x3D; 1;\n        \n        &#x2F;&#x2F; 外层循环遍历节点数量\n        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;\n            &#x2F;&#x2F; 内层循环遍历以不同节点为根节点的情况\n            for (int j &#x3D; 1; j &lt;&#x3D; i; ++j) &#123;\n                &#x2F;&#x2F; 左子树的节点数量为j-1，右子树的节点数量为i-j\n                &#x2F;&#x2F; 以第j个节点为根节点的BST数量等于左子树数量乘以右子树数量\n                dp[i] +&#x3D; dp[j - 1] * dp[i - j];\n            &#125;\n        &#125;\n        \n        return dp[n];\n    &#125;\n&#125;;</code></pre>\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/uniquebstn3.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3\n输出：5</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1\n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 19</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>解题思路： 这个问题可以用动态规划来解决。我们创建一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以 <code>i</code> 个节点构建的二叉搜索树的数量。我们可以观察到，对于每个 <code>i</code>，我们可以将每个节点依次作为根节点，将问题划分为子问题。例如，以节点 <code>j</code> 作为根节点，它的左子树将有 <code>j - 1</code> 个节点，右子树将有 <code>i - j</code> 个节点。所以，以节点 <code>j</code> 作为根节点的二叉搜索树数量为 <code>dp[j - 1] * dp[i - j]</code>。我们将所有以不同节点作为根节点的情况累加起来，就得到了 <code>dp[i]</code> 的值。</p>\n<p>在循环计算 <code>dp</code> 数组时，外层循环遍历节点数量 <code>i</code>，内层循环遍历以不同节点为根节点的情况 <code>j</code>。最终，<code>dp[n]</code> 就是我们所求的以 <code>n</code> 个节点构建的不同二叉搜索树的数量。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int numTrees(int n) &#123;\n        &#x2F;&#x2F; 创建一个数组来存储以1到n为节点的二叉搜索树的数量\n        vector&lt;int&gt; dp(n + 1, 0);\n        &#x2F;&#x2F; 空树也算一种情况，初始化dp[0]为1\n        dp[0] &#x3D; 1;\n        \n        &#x2F;&#x2F; 外层循环遍历节点数量\n        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;\n            &#x2F;&#x2F; 内层循环遍历以不同节点为根节点的情况\n            for (int j &#x3D; 1; j &lt;&#x3D; i; ++j) &#123;\n                &#x2F;&#x2F; 左子树的节点数量为j-1，右子树的节点数量为i-j\n                &#x2F;&#x2F; 以第j个节点为根节点的BST数量等于左子树数量乘以右子树数量\n                dp[i] +&#x3D; dp[j - 1] * dp[i - j];\n            &#125;\n        &#125;\n        \n        return dp[n];\n    &#125;\n&#125;;</code></pre>\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}