{"title":"leetcode2511.最多可以摧毁的敌人城堡数目","slug":"leetcode2511-最多可以摧毁的敌人城堡数目","date":"2023-09-04T12:31:04.000Z","updated":"2023-09-04T12:34:17.722Z","comments":true,"path":"api/articles/leetcode2511-最多可以摧毁的敌人城堡数目.json","excerpt":"题目给你一个长度为 n ，下标从 0 开始的整数数组 forts ，表示一些城堡。forts[i] 可以是 -1 ，0 或者 1 ，其中：-1 表示第 i 个位置 没有 城堡。0 表示第 i 个位置有一个 敌人 的城堡。1 表示第 i 个位置有一个你控制的城堡。现在，你需要决定，将你的军队从某个你控制的城堡位置 i 移动到一个空的位置 j ，满足：0 &lt;= i, j &lt;= n - 1军队经过的位置 只有 敌人的城堡。正式的，对于所有 min(i,j) &lt; k &lt; max(i,j) 的 k ，都满足 forts[k] == 0 。当军队移动时，所有途中经过的敌人城堡都会被 摧毁 。请你返回 最多 可以摧毁的敌人城堡数目。如果 无法 移动你的军队，或者没有你控制的城堡，请返回 0 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个长度为 <code>n</code> ，下标从 <strong>0</strong> 开始的整数数组 <code>forts</code> ，表示一些城堡。<code>forts[i]</code> 可以是 <code>-1</code> ，<code>0</code> 或者 <code>1</code> ，其中：</p>\n<ul>\n<li><code>-1</code> 表示第 <code>i</code> 个位置 <strong>没有</strong> 城堡。</li>\n<li><code>0</code> 表示第 <code>i</code> 个位置有一个 <strong>敌人</strong> 的城堡。</li>\n<li><code>1</code> 表示第 <code>i</code> 个位置有一个你控制的城堡。</li>\n</ul>\n<p>现在，你需要决定，将你的军队从某个你控制的城堡位置 <code>i</code> 移动到一个空的位置 <code>j</code> ，满足：</p>\n<ul>\n<li><code>0 &lt;= i, j &lt;= n - 1</code></li>\n<li>军队经过的位置 <strong>只有</strong> 敌人的城堡。正式的，对于所有 <code>min(i,j) &lt; k &lt; max(i,j)</code> 的 <code>k</code> ，都满足 <code>forts[k] == 0</code> 。</li>\n</ul>\n<p>当军队移动时，所有途中经过的敌人城堡都会被 <strong>摧毁</strong> 。</p>\n<p>请你返回 <strong>最多</strong> 可以摧毁的敌人城堡数目。如果 <strong>无法</strong> 移动你的军队，或者没有你控制的城堡，请返回 <code>0</code> 。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：forts &#x3D; [1,0,0,-1,0,0,0,0,1]\n输出：4\n解释：\n- 将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2 。\n- 将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。\n4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：forts &#x3D; [0,0,1,-1]\n输出：0\n解释：由于无法摧毁敌人的城堡，所以返回 0 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= forts.length &lt;= 1000</code></li>\n<li><code>-1 &lt;= forts[i] &lt;= 1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>双指针法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int captureForts(vector&lt;int&gt;&amp; forts) &#123;\n        int ans &#x3D; 0, pre &#x3D; -1; &#x2F;&#x2F; 双指针\n        for (int i &#x3D; 0; i &lt; forts.size(); i++) &#123;\n            if (forts[i] &#x3D;&#x3D; 1 || forts[i] &#x3D;&#x3D; -1) &#123;\n                if (pre &gt;&#x3D; 0 &amp;&amp; forts[i] !&#x3D; forts[pre]) &#123; &#x2F;&#x2F; 保证i与pre指着的元素不是同一个数字\n                    ans &#x3D; max(ans, i - pre - 1); &#x2F;&#x2F; 更新ans\n                &#125;\n                pre &#x3D; i; &#x2F;&#x2F; 更新pre，保证i和pre之间无其他1或者-1；\n            &#125;\n        &#125;\n        return ans; &#x2F;&#x2F; 返回最终结果\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：forts &#x3D; [1,0,0,-1,0,0,0,0,1]\n输出：4\n解释：\n- 将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2 。\n- 将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。\n4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：forts &#x3D; [0,0,1,-1]\n输出：0\n解释：由于无法摧毁敌人的城堡，所以返回 0 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= forts.length &lt;= 1000</code></li>\n<li><code>-1 &lt;= forts[i] &lt;= 1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>双指针法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int captureForts(vector&lt;int&gt;&amp; forts) &#123;\n        int ans &#x3D; 0, pre &#x3D; -1; &#x2F;&#x2F; 双指针\n        for (int i &#x3D; 0; i &lt; forts.size(); i++) &#123;\n            if (forts[i] &#x3D;&#x3D; 1 || forts[i] &#x3D;&#x3D; -1) &#123;\n                if (pre &gt;&#x3D; 0 &amp;&amp; forts[i] !&#x3D; forts[pre]) &#123; &#x2F;&#x2F; 保证i与pre指着的元素不是同一个数字\n                    ans &#x3D; max(ans, i - pre - 1); &#x2F;&#x2F; 更新ans\n                &#125;\n                pre &#x3D; i; &#x2F;&#x2F; 更新pre，保证i和pre之间无其他1或者-1；\n            &#125;\n        &#125;\n        return ans; &#x2F;&#x2F; 返回最终结果\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"双指针","path":"api/tags/双指针.json"}]}