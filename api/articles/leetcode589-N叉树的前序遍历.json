{"title":"leetcode589.N叉树的前序遍历","slug":"leetcode589-N叉树的前序遍历","date":"2023-07-25T02:50:29.000Z","updated":"2023-07-25T03:29:56.206Z","comments":true,"path":"api/articles/leetcode589-N叉树的前序遍历.json","excerpt":null,"covers":["http://cdn.leafii.top/img/narytreeexample-20230725105312155.png","http://cdn.leafii.top/img/sample_4_964-20230725105314652.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个 n 叉树的根节点 <code>root</code> ，返回 <em>其节点值的 <strong>前序遍历</strong></em> 。</p>\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/narytreeexample-20230725105312155.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,3,2,4,null,5,6]\n输出：[1,3,5,6,2,4]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/sample_4_964-20230725105314652.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>节点总数在范围 <code>[0, 104]</code>内</li>\n<li><code>0 &lt;= Node.val &lt;= 104</code></li>\n<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() &#123;&#125;\n\n    Node(int _val) &#123;\n        val &#x3D; _val;\n    &#125;\n\n    Node(int _val, vector&lt;Node*&gt; _children) &#123;\n        val &#x3D; _val;\n        children &#x3D; _children;\n    &#125;\n&#125;;\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; preorder(Node* root) &#123;\n        &#x2F;&#x2F; 结果数组result的定义\n        vector&lt;int&gt; result;\n        &#x2F;&#x2F; 如果root为空，则直接返回空数组\n        if (!root) return result;\n        &#x2F;&#x2F; 如果root不为空，则开始前序遍历\n        preorderHelper(root, result);\n        &#x2F;&#x2F; 遍历结束返回结果数组\n        return result;\n    &#125;\n\n    void preorderHelper(Node* node, vector&lt;int&gt;&amp; finalResult) &#123;\n        if (!node) return; &#x2F;&#x2F; 递归的终止条件：结点为空\n        finalResult.push_back(node-&gt;val); &#x2F;&#x2F; 前序遍历\n        for (Node* child: node-&gt;children) &#123; &#x2F;&#x2F; 获取当前结点的子结点\n            &#x2F;&#x2F; 然后分别每一个子结点进行前序遍历\n            preorderHelper(child, finalResult); \n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>迭代法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() &#123;&#125;\n\n    Node(int _val) &#123;\n        val &#x3D; _val;\n    &#125;\n\n    Node(int _val, vector&lt;Node*&gt; _children) &#123;\n        val &#x3D; _val;\n        children &#x3D; _children;\n    &#125;\n&#125;;\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; preorder(Node* root) &#123;\n        stack&lt;Node*&gt; st; &#x2F;&#x2F; 使用栈，先进后出\n        vector&lt;int&gt; result; &#x2F;&#x2F; 结果数组的定义\n        if (!root) return result;\n        st.push(root); &#x2F;&#x2F; 将根节点入栈\n        while (!st.empty()) &#123; &#x2F;&#x2F; 当栈非空时\n            Node* node &#x3D; st.top(); &#x2F;&#x2F; 将栈顶的元素赋值给node\n            st.pop(); &#x2F;&#x2F; 出栈\n            result.push_back(node-&gt;val); &#x2F;&#x2F; 前序遍历\n            for (int i &#x3D; node-&gt;children.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n                if (node-&gt;children[i] !&#x3D; NULL) &#123;\n                    st.push(node-&gt;children[i]); &#x2F;&#x2F; 从右往左进行入栈操作\n                &#125;\n            &#125;\n        &#125;\n        return result; &#x2F;&#x2F; 返回结果数组\n\n    &#125;\n&#125;;</code></pre>\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个 n 叉树的根节点 <code>root</code> ，返回 <em>其节点值的 <strong>前序遍历</strong></em> 。</p>\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/narytreeexample-20230725105312155.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,3,2,4,null,5,6]\n输出：[1,3,5,6,2,4]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/sample_4_964-20230725105314652.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>节点总数在范围 <code>[0, 104]</code>内</li>\n<li><code>0 &lt;= Node.val &lt;= 104</code></li>\n<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() &#123;&#125;\n\n    Node(int _val) &#123;\n        val &#x3D; _val;\n    &#125;\n\n    Node(int _val, vector&lt;Node*&gt; _children) &#123;\n        val &#x3D; _val;\n        children &#x3D; _children;\n    &#125;\n&#125;;\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; preorder(Node* root) &#123;\n        &#x2F;&#x2F; 结果数组result的定义\n        vector&lt;int&gt; result;\n        &#x2F;&#x2F; 如果root为空，则直接返回空数组\n        if (!root) return result;\n        &#x2F;&#x2F; 如果root不为空，则开始前序遍历\n        preorderHelper(root, result);\n        &#x2F;&#x2F; 遍历结束返回结果数组\n        return result;\n    &#125;\n\n    void preorderHelper(Node* node, vector&lt;int&gt;&amp; finalResult) &#123;\n        if (!node) return; &#x2F;&#x2F; 递归的终止条件：结点为空\n        finalResult.push_back(node-&gt;val); &#x2F;&#x2F; 前序遍历\n        for (Node* child: node-&gt;children) &#123; &#x2F;&#x2F; 获取当前结点的子结点\n            &#x2F;&#x2F; 然后分别每一个子结点进行前序遍历\n            preorderHelper(child, finalResult); \n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>迭代法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() &#123;&#125;\n\n    Node(int _val) &#123;\n        val &#x3D; _val;\n    &#125;\n\n    Node(int _val, vector&lt;Node*&gt; _children) &#123;\n        val &#x3D; _val;\n        children &#x3D; _children;\n    &#125;\n&#125;;\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; preorder(Node* root) &#123;\n        stack&lt;Node*&gt; st; &#x2F;&#x2F; 使用栈，先进后出\n        vector&lt;int&gt; result; &#x2F;&#x2F; 结果数组的定义\n        if (!root) return result;\n        st.push(root); &#x2F;&#x2F; 将根节点入栈\n        while (!st.empty()) &#123; &#x2F;&#x2F; 当栈非空时\n            Node* node &#x3D; st.top(); &#x2F;&#x2F; 将栈顶的元素赋值给node\n            st.pop(); &#x2F;&#x2F; 出栈\n            result.push_back(node-&gt;val); &#x2F;&#x2F; 前序遍历\n            for (int i &#x3D; node-&gt;children.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n                if (node-&gt;children[i] !&#x3D; NULL) &#123;\n                    st.push(node-&gt;children[i]); &#x2F;&#x2F; 从右往左进行入栈操作\n                &#125;\n            &#125;\n        &#125;\n        return result; &#x2F;&#x2F; 返回结果数组\n\n    &#125;\n&#125;;</code></pre>\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}