{"title":"leetcode113.路径总和II","slug":"leetcode113-路径总和II","date":"2023-03-28T06:05:24.000Z","updated":"2023-03-28T06:24:39.637Z","comments":true,"path":"api/articles/leetcode113-路径总和II.json","excerpt":"题目给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。","covers":["http://cdn.leafii.top/img/pathsumii1.jpg","http://cdn.leafii.top/img/pathsum2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/pathsumii1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22\n输出：[[5,4,11,2],[5,8,4,5]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/pathsum2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2], targetSum &#x3D; 0\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>本题可以使用深度优先搜索（DFS）求解。从根节点开始，依次搜索左子树和右子树，直到找到符合条件的路径。具体来说，我们可以使用递归的方式，每次遍历到一个节点时，将该节点加入路径中，并更新目标值。如果该节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径，将该路径加入结果数组中。否则，继续搜索左子树和右子树。在搜索之后，需要将当前节点从路径中删除，以便回溯到之前的状态。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        vector&lt;int&gt; path;\n        dfs(root, targetSum, res, path);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* node, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;\n        if (!node) return;  &#x2F;&#x2F; 如果当前节点为空，则直接返回\n\n        path.push_back(node-&gt;val);  &#x2F;&#x2F; 将当前节点的值加入路径中\n        targetSum -&#x3D; node-&gt;val;     &#x2F;&#x2F; 更新目标值\n\n        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 如果当前节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径\n            res.push_back(path);    &#x2F;&#x2F; 将该路径加入结果数组\n        &#125; else &#123;\n            dfs(node-&gt;left, targetSum, res, path);   &#x2F;&#x2F; 搜索左子树\n            dfs(node-&gt;right, targetSum, res, path);  &#x2F;&#x2F; 搜索右子树\n        &#125;\n\n        path.pop_back();  &#x2F;&#x2F; 回溯：将当前节点从路径中删除，恢复到搜索之前的状态\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p><code>path.pop_back()</code> 是 C++ 中 vector 容器的成员函数，用于删除 vector 容器中的最后一个元素。在本题中，由于我们在搜索过程中需要记录搜索路径，因此使用了一个 <code>path</code> 数组来保存路径。在每次搜索到一个新节点时，我们将该节点的值加入 <code>path</code> 数组中，如果搜索结束后未找到符合条件的路径，需要将该节点从 <code>path</code> 数组中删除，回溯到之前的状态，继续搜索其他节点。因此，在代码中，<code>path.pop_back()</code> 的作用是删除 <code>path</code> 数组中最后一个元素，以便回溯到之前的状态。</p>\n</blockquote>\n<p>时间复杂度分析：</p>\n<p>本题的时间复杂度为$ O(N^2)$，其中 N 表示二叉树的节点数。在最坏情况下，二叉树的形态类似于一个单链表，此时需要遍历所有节点，时间复杂度为 $O(N)$。对于每个节点，由于需要将该节点加入路径中，时间复杂度为$ O(N)$，因此总时间复杂度为 $O(N^2)$。</p>\n<p>空间复杂度分析：</p>\n<p>本题的空间复杂度为 $O(N)$，其中 N 表示二叉树的节点数。递归调用的栈空间最多为 $O(N)$，路径数组的空间为 $O(N)$，因此总空间复杂度为 $O(N)$。</p>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/pathsumii1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22\n输出：[[5,4,11,2],[5,8,4,5]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/pathsum2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2], targetSum &#x3D; 0\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>本题可以使用深度优先搜索（DFS）求解。从根节点开始，依次搜索左子树和右子树，直到找到符合条件的路径。具体来说，我们可以使用递归的方式，每次遍历到一个节点时，将该节点加入路径中，并更新目标值。如果该节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径，将该路径加入结果数组中。否则，继续搜索左子树和右子树。在搜索之后，需要将当前节点从路径中删除，以便回溯到之前的状态。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        vector&lt;int&gt; path;\n        dfs(root, targetSum, res, path);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* node, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;\n        if (!node) return;  &#x2F;&#x2F; 如果当前节点为空，则直接返回\n\n        path.push_back(node-&gt;val);  &#x2F;&#x2F; 将当前节点的值加入路径中\n        targetSum -&#x3D; node-&gt;val;     &#x2F;&#x2F; 更新目标值\n\n        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 如果当前节点是叶子节点，且目标值为 0，则说明找到了一条符合条件的路径\n            res.push_back(path);    &#x2F;&#x2F; 将该路径加入结果数组\n        &#125; else &#123;\n            dfs(node-&gt;left, targetSum, res, path);   &#x2F;&#x2F; 搜索左子树\n            dfs(node-&gt;right, targetSum, res, path);  &#x2F;&#x2F; 搜索右子树\n        &#125;\n\n        path.pop_back();  &#x2F;&#x2F; 回溯：将当前节点从路径中删除，恢复到搜索之前的状态\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p><code>path.pop_back()</code> 是 C++ 中 vector 容器的成员函数，用于删除 vector 容器中的最后一个元素。在本题中，由于我们在搜索过程中需要记录搜索路径，因此使用了一个 <code>path</code> 数组来保存路径。在每次搜索到一个新节点时，我们将该节点的值加入 <code>path</code> 数组中，如果搜索结束后未找到符合条件的路径，需要将该节点从 <code>path</code> 数组中删除，回溯到之前的状态，继续搜索其他节点。因此，在代码中，<code>path.pop_back()</code> 的作用是删除 <code>path</code> 数组中最后一个元素，以便回溯到之前的状态。</p>\n</blockquote>\n<p>时间复杂度分析：</p>\n<p>本题的时间复杂度为$ O(N^2)$，其中 N 表示二叉树的节点数。在最坏情况下，二叉树的形态类似于一个单链表，此时需要遍历所有节点，时间复杂度为 $O(N)$。对于每个节点，由于需要将该节点加入路径中，时间复杂度为$ O(N)$，因此总时间复杂度为 $O(N^2)$。</p>\n<p>空间复杂度分析：</p>\n<p>本题的空间复杂度为 $O(N)$，其中 N 表示二叉树的节点数。递归调用的栈空间最多为 $O(N)$，路径数组的空间为 $O(N)$，因此总空间复杂度为 $O(N)$。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}