{"title":"leetcode236.二叉树的最近公共祖先","slug":"leetcode236-二叉树的最近公共祖先","date":"2023-06-01T01:57:12.000Z","updated":"2023-06-01T01:59:02.178Z","comments":true,"path":"api/articles/leetcode236-二叉树的最近公共祖先.json","excerpt":"题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”","covers":["http://cdn.leafii.top/img/binarytree.png","http://cdn.leafii.top/img/binarytree-20230601095804160.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/binarytree.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/binarytree-20230601095804160.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2\n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[2, 105]</code> 内。</li>\n<li><code>-109 &lt;= Node.val &lt;= 109</code></li>\n<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>\n<li><code>p != q</code></li>\n<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归遍历求解</li>\n</ul>\n<p>解题思路如下：</p>\n<ol>\n<li>首先，我们需要明确最近公共祖先的定义。在二叉树中，节点A是节点B和节点C的最近公共祖先，意味着节点A是同时包含节点B和节点C的子树中最深的节点。</li>\n<li>从根节点开始遍历二叉树。如果当前节点是p或q中的一个，我们可以返回该节点，因为我们已经找到了一个目标节点。</li>\n<li>递归地在左子树和右子树中寻找p和q。如果在左子树中找到了p或q的最近公共祖先，或者在右子树中找到了p或q的最近公共祖先，那么返回该节点。</li>\n<li>如果左子树和右子树都没有找到p和q的最近公共祖先，那么返回根节点。</li>\n</ol>\n<p>这个思路的关键在于理解最近公共祖先的定义，并通过递归的方式遍历二叉树。通过在左右子树中的递归调用，我们可以找到p和q的最近公共祖先，或者在当前节点返回p或q其中的一个节点，从而实现最近公共祖先的查找。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        &#x2F;&#x2F; 如果当前节点是p或q或者为空，直接返回该节点\n        if (root &#x3D;&#x3D; nullptr || root &#x3D;&#x3D; p || root &#x3D;&#x3D; q) return root;\n        \n        TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q); &#x2F;&#x2F; 得到root左子树拥有p或者q的最近祖先\n        TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q); &#x2F;&#x2F; 得到root右子树拥有p或者q的最近祖先\n        \n        if (left &amp;&amp; right) return root; &#x2F;&#x2F; 如果左子树和右子树得到的结果都不为空，那么它们的最近公共祖先就是根节点\n\n        return left ? left : right; &#x2F;&#x2F; 返回left和right中不为空的那个，如果都为空，那么返回哪个都一样咯\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/binarytree.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/binarytree-20230601095804160.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2\n输出：1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[2, 105]</code> 内。</li>\n<li><code>-109 &lt;= Node.val &lt;= 109</code></li>\n<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>\n<li><code>p != q</code></li>\n<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归遍历求解</li>\n</ul>\n<p>解题思路如下：</p>\n<ol>\n<li>首先，我们需要明确最近公共祖先的定义。在二叉树中，节点A是节点B和节点C的最近公共祖先，意味着节点A是同时包含节点B和节点C的子树中最深的节点。</li>\n<li>从根节点开始遍历二叉树。如果当前节点是p或q中的一个，我们可以返回该节点，因为我们已经找到了一个目标节点。</li>\n<li>递归地在左子树和右子树中寻找p和q。如果在左子树中找到了p或q的最近公共祖先，或者在右子树中找到了p或q的最近公共祖先，那么返回该节点。</li>\n<li>如果左子树和右子树都没有找到p和q的最近公共祖先，那么返回根节点。</li>\n</ol>\n<p>这个思路的关键在于理解最近公共祖先的定义，并通过递归的方式遍历二叉树。通过在左右子树中的递归调用，我们可以找到p和q的最近公共祖先，或者在当前节点返回p或q其中的一个节点，从而实现最近公共祖先的查找。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        &#x2F;&#x2F; 如果当前节点是p或q或者为空，直接返回该节点\n        if (root &#x3D;&#x3D; nullptr || root &#x3D;&#x3D; p || root &#x3D;&#x3D; q) return root;\n        \n        TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q); &#x2F;&#x2F; 得到root左子树拥有p或者q的最近祖先\n        TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q); &#x2F;&#x2F; 得到root右子树拥有p或者q的最近祖先\n        \n        if (left &amp;&amp; right) return root; &#x2F;&#x2F; 如果左子树和右子树得到的结果都不为空，那么它们的最近公共祖先就是根节点\n\n        return left ? left : right; &#x2F;&#x2F; 返回left和right中不为空的那个，如果都为空，那么返回哪个都一样咯\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}