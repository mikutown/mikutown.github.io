{"title":"leetcode17.电话号码的字母组合","slug":"leetcode17-电话号码的字母组合","date":"2023-07-18T00:56:06.000Z","updated":"2023-07-18T01:01:57.214Z","comments":true,"path":"api/articles/leetcode17-电话号码的字母组合.json","excerpt":"题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。","covers":["http://cdn.leafii.top/img/200px-telephone-keypad2svg.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"http://cdn.leafii.top/img/200px-telephone-keypad2svg.png\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：digits &#x3D; &quot;23&quot;\n输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：digits &#x3D; &quot;&quot;\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：digits &#x3D; &quot;2&quot;\n输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= digits.length &lt;= 4</code></li>\n<li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>回溯法</li>\n</ul>\n<p>理解本题后，要解决如下三个问题：</p>\n<ol>\n<li>数字和字母如何映射？使用二维数组即可。</li>\n<li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来，此时的思路就是使用增加了遍历深度的参数的辅助函数进行辅助，得到一种符合要求的结果后进行回溯继续遍历。</li>\n<li>输入1 * #按键等等异常情况（异常情况在leetcode样例中不存在，所以不考虑也没关系）</li>\n</ol>\n<p>C++代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    &#x2F;&#x2F; 字母和数字的映射\n    const string letterMap[10] &#x3D; &#123;\n        &quot;&quot;, &#x2F;&#x2F; 0\n        &quot;&quot;, &#x2F;&#x2F; 1\n        &quot;abc&quot;, &#x2F;&#x2F; 2\n        &quot;def&quot;, &#x2F;&#x2F; 3\n        &quot;ghi&quot;, &#x2F;&#x2F; 4\n        &quot;jkl&quot;, &#x2F;&#x2F; 5\n        &quot;mno&quot;, &#x2F;&#x2F; 6\n        &quot;pqrs&quot;, &#x2F;&#x2F; 7\n        &quot;tuv&quot;, &#x2F;&#x2F; 8\n        &quot;wxyz&quot;, &#x2F;&#x2F; 9\n    &#125;;\npublic:\n    vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储最终结果的全局变量动态数组result\n    string s; &#x2F;&#x2F; 用于临时存储一个组合的字符串s\n    void backtracking(const string&amp; digits, int index) &#123;\n        &#x2F;&#x2F; 辅助函数，增加了一个index用于辅助遍历的过程，index表示遍历到digits的第几位\n        if (index &#x3D;&#x3D; digits.size()) &#123;\n            &#x2F;&#x2F; 判断index是否和digits的大小相等，如果相等则说明当前已经遍历完了最后一位\n            result.push_back(s); &#x2F;&#x2F; 此时直接把保存的字符串s放进结果数组result中即可\n            return; &#x2F;&#x2F; 遍历结束直接return\n        &#125;\n        int digit &#x3D; digits[index] - &#39;0&#39;; &#x2F;&#x2F; 把字符串中的单个数字转为int类型\n        string letters &#x3D; letterMap[digit]; &#x2F;&#x2F; 通过获得的int类型数字得到对应的字符串映射\n        for (int i &#x3D; 0; i &lt; letters.size(); i++) &#123;\n            s.push_back(letters[i]); &#x2F;&#x2F; 将第i个字母进行push\n            backtracking(digits, index + 1); &#x2F;&#x2F; 递归进一步遍历\n            s.pop_back(); &#x2F;&#x2F; 回溯\n        &#125;\n\n    &#125;\n    vector&lt;string&gt; letterCombinations(string digits) &#123;\n        s.clear(); &#x2F;&#x2F; 初始化参数\n        result.clear(); &#x2F;&#x2F; 初始化参数\n        if (digits.size() &#x3D;&#x3D; 0) return result; &#x2F;&#x2F; 如果digits数组的长度为0 直接返回空结果数组\n        backtracking(digits, 0); &#x2F;&#x2F; 递归调用，从0开始遍历\n        return result; &#x2F;&#x2F; 返回最终的结果数组\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><img src=\"http://cdn.leafii.top/img/200px-telephone-keypad2svg.png\" alt=\"img\"></p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：digits &#x3D; &quot;23&quot;\n输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：digits &#x3D; &quot;&quot;\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：digits &#x3D; &quot;2&quot;\n输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= digits.length &lt;= 4</code></li>\n<li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>回溯法</li>\n</ul>\n<p>理解本题后，要解决如下三个问题：</p>\n<ol>\n<li>数字和字母如何映射？使用二维数组即可。</li>\n<li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来，此时的思路就是使用增加了遍历深度的参数的辅助函数进行辅助，得到一种符合要求的结果后进行回溯继续遍历。</li>\n<li>输入1 * #按键等等异常情况（异常情况在leetcode样例中不存在，所以不考虑也没关系）</li>\n</ol>\n<p>C++代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    &#x2F;&#x2F; 字母和数字的映射\n    const string letterMap[10] &#x3D; &#123;\n        &quot;&quot;, &#x2F;&#x2F; 0\n        &quot;&quot;, &#x2F;&#x2F; 1\n        &quot;abc&quot;, &#x2F;&#x2F; 2\n        &quot;def&quot;, &#x2F;&#x2F; 3\n        &quot;ghi&quot;, &#x2F;&#x2F; 4\n        &quot;jkl&quot;, &#x2F;&#x2F; 5\n        &quot;mno&quot;, &#x2F;&#x2F; 6\n        &quot;pqrs&quot;, &#x2F;&#x2F; 7\n        &quot;tuv&quot;, &#x2F;&#x2F; 8\n        &quot;wxyz&quot;, &#x2F;&#x2F; 9\n    &#125;;\npublic:\n    vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储最终结果的全局变量动态数组result\n    string s; &#x2F;&#x2F; 用于临时存储一个组合的字符串s\n    void backtracking(const string&amp; digits, int index) &#123;\n        &#x2F;&#x2F; 辅助函数，增加了一个index用于辅助遍历的过程，index表示遍历到digits的第几位\n        if (index &#x3D;&#x3D; digits.size()) &#123;\n            &#x2F;&#x2F; 判断index是否和digits的大小相等，如果相等则说明当前已经遍历完了最后一位\n            result.push_back(s); &#x2F;&#x2F; 此时直接把保存的字符串s放进结果数组result中即可\n            return; &#x2F;&#x2F; 遍历结束直接return\n        &#125;\n        int digit &#x3D; digits[index] - &#39;0&#39;; &#x2F;&#x2F; 把字符串中的单个数字转为int类型\n        string letters &#x3D; letterMap[digit]; &#x2F;&#x2F; 通过获得的int类型数字得到对应的字符串映射\n        for (int i &#x3D; 0; i &lt; letters.size(); i++) &#123;\n            s.push_back(letters[i]); &#x2F;&#x2F; 将第i个字母进行push\n            backtracking(digits, index + 1); &#x2F;&#x2F; 递归进一步遍历\n            s.pop_back(); &#x2F;&#x2F; 回溯\n        &#125;\n\n    &#125;\n    vector&lt;string&gt; letterCombinations(string digits) &#123;\n        s.clear(); &#x2F;&#x2F; 初始化参数\n        result.clear(); &#x2F;&#x2F; 初始化参数\n        if (digits.size() &#x3D;&#x3D; 0) return result; &#x2F;&#x2F; 如果digits数组的长度为0 直接返回空结果数组\n        backtracking(digits, 0); &#x2F;&#x2F; 递归调用，从0开始遍历\n        return result; &#x2F;&#x2F; 返回最终的结果数组\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}