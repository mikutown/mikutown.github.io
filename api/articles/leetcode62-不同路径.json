{"title":"leetcode62.不同路径","slug":"leetcode62-不同路径","date":"2023-04-12T00:57:03.000Z","updated":"2023-04-12T01:21:20.348Z","comments":true,"path":"api/articles/leetcode62-不同路径.json","excerpt":"题目一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？","covers":["http://cdn.leafii.top/img/robot_maze.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n<p>问总共有多少条不同的路径？</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/robot_maze.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：m &#x3D; 3, n &#x3D; 7\n输出：28</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：m &#x3D; 3, n &#x3D; 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向下</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：m &#x3D; 7, n &#x3D; 3\n输出：28</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：m &#x3D; 3, n &#x3D; 3\n输出：6</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= m, n &lt;= 100</code></li>\n<li>题目数据保证答案小于等于 <code>2 * 109</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这是一道比较典型的动态规划问题。我们定义一个二维数组<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p>\n<p>根据题目要求，从第一行第一列出发只能向下或向右移动一步，因此<code>dp[0][j]</code>和<code>dp[i][0]</code>的值都为1。</p>\n<p>对于其他的格子，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p>\n<p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>\n<p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int uniquePaths(int m, int n) &#123;\n        &#x2F;&#x2F; 定义二维数组dp\n        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));\n        &#x2F;&#x2F; 对于除第一行第一列外的其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和\n        for (int i &#x3D; 1; i &lt; m; i++) &#123;\n            for (int j &#x3D; 1; j &lt; n; j++) &#123;\n                dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 返回右下角格子的不同路径数目\n        return dp[m-1][n-1];\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/robot_maze.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：m &#x3D; 3, n &#x3D; 7\n输出：28</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：m &#x3D; 3, n &#x3D; 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向下</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：m &#x3D; 7, n &#x3D; 3\n输出：28</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：m &#x3D; 3, n &#x3D; 3\n输出：6</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= m, n &lt;= 100</code></li>\n<li>题目数据保证答案小于等于 <code>2 * 109</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>这是一道比较典型的动态规划问题。我们定义一个二维数组<code>dp[i][j]</code>表示从左上角出发到第i行第j列的格子的不同路径数目。</p>\n<p>根据题目要求，从第一行第一列出发只能向下或向右移动一步，因此<code>dp[0][j]</code>和<code>dp[i][0]</code>的值都为1。</p>\n<p>对于其他的格子，其到达的路径有两种：从上方的格子到达和从左边的格子到达。因此，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和，即：</p>\n<p><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>\n<p>最终答案为<code>dp[m-1][n-1]</code>，即到达右下角的不同路径数目。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int uniquePaths(int m, int n) &#123;\n        &#x2F;&#x2F; 定义二维数组dp\n        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));\n        &#x2F;&#x2F; 对于除第一行第一列外的其他格子，其不同路径数目为到达其上方格子的路径数目加上到达其左边格子的路径数目之和\n        for (int i &#x3D; 1; i &lt; m; i++) &#123;\n            for (int j &#x3D; 1; j &lt; n; j++) &#123;\n                dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 返回右下角格子的不同路径数目\n        return dp[m-1][n-1];\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}