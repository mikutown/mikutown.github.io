{"title":"leetcode257.二叉树的所有路径","slug":"leetcode257-二叉树的所有路径","date":"2023-06-28T01:43:38.000Z","updated":"2023-06-28T01:58:54.939Z","comments":true,"path":"api/articles/leetcode257-二叉树的所有路径.json","excerpt":"题目给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。叶子节点 是指没有子节点的节点。","covers":["http://cdn.leafii.top/img/paths-tree.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/paths-tree.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,null,5]\n输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[&quot;1&quot;]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>深度优先搜索</li>\n</ul>\n<p>思路：直接深度优先搜索，设置一个dfs辅助函数。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;\n        vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储所有路径的结果集\n        if (root &#x3D;&#x3D; NULL) &#123;\n            return result;\n        &#125; \n        string path; &#x2F;&#x2F; 当前的路径的字符串表示\n        &#x2F;&#x2F; 从根节点开始深度优先搜索\n        dfs(root, path, result);\n        return result;\n    &#125;\n\n    void dfs(TreeNode* node, string path, vector&lt;string&gt;&amp; result) &#123;\n        path +&#x3D; to_string(node-&gt;val); &#x2F;&#x2F; 将当前结点的值加入到当前路径\n        \n        &#x2F;&#x2F; 如果是叶子结点，将当前路径加入结果集\n        if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123;\n            result.push_back(path);\n            return;\n        &#125;\n        &#x2F;&#x2F; 如果存在左子树\n        if (node-&gt;left !&#x3D; NULL) &#123;\n            dfs(node-&gt;left, path + &quot;-&gt;&quot;, result);\n        &#125;\n        &#x2F;&#x2F; 如果存在右子树\n        if (node-&gt;right !&#x3D; NULL) &#123;\n            dfs(node-&gt;right, path + &quot;-&gt;&quot;, result);\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/paths-tree.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,null,5]\n输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[&quot;1&quot;]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>深度优先搜索</li>\n</ul>\n<p>思路：直接深度优先搜索，设置一个dfs辅助函数。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;\n        vector&lt;string&gt; result; &#x2F;&#x2F; 用于存储所有路径的结果集\n        if (root &#x3D;&#x3D; NULL) &#123;\n            return result;\n        &#125; \n        string path; &#x2F;&#x2F; 当前的路径的字符串表示\n        &#x2F;&#x2F; 从根节点开始深度优先搜索\n        dfs(root, path, result);\n        return result;\n    &#125;\n\n    void dfs(TreeNode* node, string path, vector&lt;string&gt;&amp; result) &#123;\n        path +&#x3D; to_string(node-&gt;val); &#x2F;&#x2F; 将当前结点的值加入到当前路径\n        \n        &#x2F;&#x2F; 如果是叶子结点，将当前路径加入结果集\n        if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123;\n            result.push_back(path);\n            return;\n        &#125;\n        &#x2F;&#x2F; 如果存在左子树\n        if (node-&gt;left !&#x3D; NULL) &#123;\n            dfs(node-&gt;left, path + &quot;-&gt;&quot;, result);\n        &#125;\n        &#x2F;&#x2F; 如果存在右子树\n        if (node-&gt;right !&#x3D; NULL) &#123;\n            dfs(node-&gt;right, path + &quot;-&gt;&quot;, result);\n        &#125;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}