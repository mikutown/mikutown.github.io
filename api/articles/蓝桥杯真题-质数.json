{"title":"蓝桥杯真题-质数","slug":"蓝桥杯真题-质数","date":"2023-04-02T06:29:27.000Z","updated":"2023-04-02T07:44:59.636Z","comments":true,"path":"api/articles/蓝桥杯真题-质数.json","excerpt":"题目我们知道第一个质数是 22、第二个质数是 33、第三个质数是 55……请你计算第 20192019 个质数是多少？运行限制最大运行时间：1s最大运行内存: 128M","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>我们知道第一个质数是 22、第二个质数是 33、第三个质数是 55……</p>\n<p>请你计算第 20192019 个质数是多少？</p>\n<p><strong>运行限制</strong></p>\n<ul>\n<li>最大运行时间：1s</li>\n<li>最大运行内存: 128M</li>\n</ul>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\nint isPrime(int num) &#123;\n    &#x2F;&#x2F; 判断一个数字是不是质数，return 0代表不是质数， return 1 代表是质数\n    for (int i &#x3D; 2; i &lt; num; i++) &#123;\n        &#x2F;&#x2F; 循环中判断是否能被1或者它本身之外的数字整除，若能则不是质数，直接return 0\n        if (num % i &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 循环结束都没发现能整除的其他数字，可以返回1\n    return 1;\n&#125;\nint main()\n&#123;\n    int count &#x3D; 0; &#x2F;&#x2F; 定义计数器，默认为0\n    int answer &#x3D; 0;\n    for (int i &#x3D; 2; count !&#x3D; 2019; i++) &#123; &#x2F;&#x2F; 从2开始循环是因为2是第一个质数，不要从1开始循环\n        if (isPrime(i) &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 若判断为是质数\n            count++; &#x2F;&#x2F; 计数器++；\n            answer &#x3D; i; &#x2F;&#x2F; 迭代更新answer\n        &#125;\n    &#125;\n    cout &lt;&lt; answer &lt;&lt; endl; &#x2F;&#x2F; 输出答案\n    return 0;\n&#125;</code></pre>\n\n<ul>\n<li>优化解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main() &#123;\n    int n &#x3D; 2019; &#x2F;&#x2F; 要计算的质数的位置\n    int num &#x3D; 3; &#x2F;&#x2F; 初始为3，因为第一个质数是2\n    int count &#x3D; 1; &#x2F;&#x2F; 已经找到了一个质数2，所以从1开始计数\n\n    while (count &lt; n) &#123;\n        num +&#x3D; 2; &#x2F;&#x2F; 只需要判断奇数是否为质数\n        bool isPrime &#x3D; true; &#x2F;&#x2F; 假设当前数是质数\n        for (int i &#x3D; 3; i &lt;&#x3D; sqrt(num); i +&#x3D; 2) &#123;\n            if (num % i &#x3D;&#x3D; 0) &#123;\n                isPrime &#x3D; false; &#x2F;&#x2F; 如果能被整除，则不是质数\n                break;\n            &#125;\n        &#125;\n        if (isPrime) &#123;\n            count++; &#x2F;&#x2F; 找到一个质数\n        &#125;\n    &#125;\n    cout &lt;&lt; num &lt;&lt; endl; &#x2F;&#x2F; 输出第2019个质数\n    return 0;\n&#125;</code></pre>\n\n<ul>\n<li>线性筛法（Linear Sieve）</li>\n</ul>\n<p>线性筛法是一种求解质数的算法，可以在$O(n)$的时间复杂度内预处理出小于等于$n$的所有质数。</p>\n<p>线性筛法的基本思想是从小到大遍历每个正整数，如果它是质数，就将它加入质数数组中，并用它来筛掉它的倍数。在遍历过程中，对于每个数只会被它的最小质因子筛去，因此每个合数只会被筛一次，从而保证了线性时间复杂度。</p>\n<p>下面是线性筛法的伪代码：</p>\n<pre class=\"language-none\"><code class=\"language-none\">primes &#x3D; [] # 质数数组\nis_prime &#x3D; [True] * (n+1) # 标记是否为质数\nfor i in range(2, n+1):\n    if is_prime[i]:\n        primes.append(i) # 将i加入质数数组\n    for j in range(len(primes)):\n        if i * primes[j] &gt; n:\n            break\n        is_prime[i * primes[j]] &#x3D; False # 将i*primes[j]标记为非质数\n        if i % primes[j] &#x3D;&#x3D; 0:\n            break # 如果i是primes[j]的倍数，就跳出循环</code></pre>\n\n<blockquote>\n<p>如果在内层循环中，$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</p>\n<p>例如，当$i$为$2 \\times 3&#x3D;6$时，在内层循环中，$i$会被$2$筛一次，被$3$筛一次，之后就不需要再被其他数筛了。因此，如果$i$是$primes[j]$的倍数，就可以跳出循环，不需要继续遍历$primes$数组中的其他质数。这样可以减少重复的筛选，提高算法的效率。</p>\n</blockquote>\n<p>C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int MAXN &#x3D; 20000; &#x2F;&#x2F; 估计2019个质数的上限\nvector&lt;int&gt; primes; &#x2F;&#x2F; 存储质数\nbool isPrime[MAXN]; &#x2F;&#x2F; 标记是否为质数\n\nint main() &#123;\n    fill(isPrime, isPrime+MAXN, true); &#x2F;&#x2F; 初始化标记数组，全部设置为true\n\n    for (int i&#x3D;2; i&lt;MAXN; i++) &#123;\n        if (isPrime[i]) &#123; &#x2F;&#x2F; i是质数\n            primes.push_back(i); &#x2F;&#x2F; 将i加入质数数组\n            if (primes.size() &#x3D;&#x3D; 2019) &#123;\n                cout &lt;&lt; primes.back() &lt;&lt; endl;\n                break;\n            &#125;\n        &#125;\n        for (int j&#x3D;0; j&lt;primes.size() &amp;&amp; i*primes[j]&lt;MAXN; j++) &#123;\n            isPrime[i*primes[j]] &#x3D; false; &#x2F;&#x2F; 将i*primes[j]标记为非质数\n            if (i % primes[j] &#x3D;&#x3D; 0) break; &#x2F;&#x2F; 如果i是primes[j]的倍数，就跳出循环\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n\n<blockquote>\n<p>可以看到，线性筛法的实现相对简单，但需要注意以下几点：</p>\n<ol>\n<li>对于每个数只需要用它的最小质因子来筛去它的倍数，因此内层循环的终止条件为$i \\times primes[j] &gt; n$。</li>\n<li>在内层循环中，如果$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</li>\n<li>在初始化标记数组时，除0和1外都初始化为True。</li>\n</ol>\n</blockquote>\n","more":"<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\nint isPrime(int num) &#123;\n    &#x2F;&#x2F; 判断一个数字是不是质数，return 0代表不是质数， return 1 代表是质数\n    for (int i &#x3D; 2; i &lt; num; i++) &#123;\n        &#x2F;&#x2F; 循环中判断是否能被1或者它本身之外的数字整除，若能则不是质数，直接return 0\n        if (num % i &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 循环结束都没发现能整除的其他数字，可以返回1\n    return 1;\n&#125;\nint main()\n&#123;\n    int count &#x3D; 0; &#x2F;&#x2F; 定义计数器，默认为0\n    int answer &#x3D; 0;\n    for (int i &#x3D; 2; count !&#x3D; 2019; i++) &#123; &#x2F;&#x2F; 从2开始循环是因为2是第一个质数，不要从1开始循环\n        if (isPrime(i) &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 若判断为是质数\n            count++; &#x2F;&#x2F; 计数器++；\n            answer &#x3D; i; &#x2F;&#x2F; 迭代更新answer\n        &#125;\n    &#125;\n    cout &lt;&lt; answer &lt;&lt; endl; &#x2F;&#x2F; 输出答案\n    return 0;\n&#125;</code></pre>\n\n<ul>\n<li>优化解法</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main() &#123;\n    int n &#x3D; 2019; &#x2F;&#x2F; 要计算的质数的位置\n    int num &#x3D; 3; &#x2F;&#x2F; 初始为3，因为第一个质数是2\n    int count &#x3D; 1; &#x2F;&#x2F; 已经找到了一个质数2，所以从1开始计数\n\n    while (count &lt; n) &#123;\n        num +&#x3D; 2; &#x2F;&#x2F; 只需要判断奇数是否为质数\n        bool isPrime &#x3D; true; &#x2F;&#x2F; 假设当前数是质数\n        for (int i &#x3D; 3; i &lt;&#x3D; sqrt(num); i +&#x3D; 2) &#123;\n            if (num % i &#x3D;&#x3D; 0) &#123;\n                isPrime &#x3D; false; &#x2F;&#x2F; 如果能被整除，则不是质数\n                break;\n            &#125;\n        &#125;\n        if (isPrime) &#123;\n            count++; &#x2F;&#x2F; 找到一个质数\n        &#125;\n    &#125;\n    cout &lt;&lt; num &lt;&lt; endl; &#x2F;&#x2F; 输出第2019个质数\n    return 0;\n&#125;</code></pre>\n\n<ul>\n<li>线性筛法（Linear Sieve）</li>\n</ul>\n<p>线性筛法是一种求解质数的算法，可以在$O(n)$的时间复杂度内预处理出小于等于$n$的所有质数。</p>\n<p>线性筛法的基本思想是从小到大遍历每个正整数，如果它是质数，就将它加入质数数组中，并用它来筛掉它的倍数。在遍历过程中，对于每个数只会被它的最小质因子筛去，因此每个合数只会被筛一次，从而保证了线性时间复杂度。</p>\n<p>下面是线性筛法的伪代码：</p>\n<pre class=\"language-none\"><code class=\"language-none\">primes &#x3D; [] # 质数数组\nis_prime &#x3D; [True] * (n+1) # 标记是否为质数\nfor i in range(2, n+1):\n    if is_prime[i]:\n        primes.append(i) # 将i加入质数数组\n    for j in range(len(primes)):\n        if i * primes[j] &gt; n:\n            break\n        is_prime[i * primes[j]] &#x3D; False # 将i*primes[j]标记为非质数\n        if i % primes[j] &#x3D;&#x3D; 0:\n            break # 如果i是primes[j]的倍数，就跳出循环</code></pre>\n\n<blockquote>\n<p>如果在内层循环中，$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</p>\n<p>例如，当$i$为$2 \\times 3&#x3D;6$时，在内层循环中，$i$会被$2$筛一次，被$3$筛一次，之后就不需要再被其他数筛了。因此，如果$i$是$primes[j]$的倍数，就可以跳出循环，不需要继续遍历$primes$数组中的其他质数。这样可以减少重复的筛选，提高算法的效率。</p>\n</blockquote>\n<p>C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int MAXN &#x3D; 20000; &#x2F;&#x2F; 估计2019个质数的上限\nvector&lt;int&gt; primes; &#x2F;&#x2F; 存储质数\nbool isPrime[MAXN]; &#x2F;&#x2F; 标记是否为质数\n\nint main() &#123;\n    fill(isPrime, isPrime+MAXN, true); &#x2F;&#x2F; 初始化标记数组，全部设置为true\n\n    for (int i&#x3D;2; i&lt;MAXN; i++) &#123;\n        if (isPrime[i]) &#123; &#x2F;&#x2F; i是质数\n            primes.push_back(i); &#x2F;&#x2F; 将i加入质数数组\n            if (primes.size() &#x3D;&#x3D; 2019) &#123;\n                cout &lt;&lt; primes.back() &lt;&lt; endl;\n                break;\n            &#125;\n        &#125;\n        for (int j&#x3D;0; j&lt;primes.size() &amp;&amp; i*primes[j]&lt;MAXN; j++) &#123;\n            isPrime[i*primes[j]] &#x3D; false; &#x2F;&#x2F; 将i*primes[j]标记为非质数\n            if (i % primes[j] &#x3D;&#x3D; 0) break; &#x2F;&#x2F; 如果i是primes[j]的倍数，就跳出循环\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n\n<blockquote>\n<p>可以看到，线性筛法的实现相对简单，但需要注意以下几点：</p>\n<ol>\n<li>对于每个数只需要用它的最小质因子来筛去它的倍数，因此内层循环的终止条件为$i \\times primes[j] &gt; n$。</li>\n<li>在内层循环中，如果$i$是$primes[j]$的倍数，就跳出循环，这是因为$i$已经被$primes[j]$的其他倍数筛过了，不需要重复筛。</li>\n<li>在初始化标记数组时，除0和1外都初始化为True。</li>\n</ol>\n</blockquote>","categories":[],"tags":[{"name":"算法","path":"api/tags/算法.json"},{"name":"蓝桥杯","path":"api/tags/蓝桥杯.json"}]}