{"title":"leetcode110.平衡二叉树","slug":"leetcode110-平衡二叉树","date":"2023-03-27T07:36:41.000Z","updated":"2023-03-27T07:46:40.781Z","comments":true,"path":"api/articles/leetcode110-平衡二叉树.json","excerpt":"题目给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。","covers":["http://cdn.leafii.top/img/balance_1.jpg","http://cdn.leafii.top/img/balance_2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n<blockquote>\n<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>\n</blockquote>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/balance_1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/balance_2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]\n输出：false</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：true</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>\n<li><code>-104 &lt;= Node.val &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归但空间复杂度较高的解法</li>\n</ul>\n<p>本题可以使用递归的方法来解决。对于每一个节点，我们需要先递归遍历它的左右子树，计算它们的高度差。如果左右子树的高度差超过了1，那么这棵树就不是平衡二叉树。如果左右子树都是平衡二叉树，那么我们可以判断当前节点是不是平衡二叉树：如果左右子树的高度差不超过1，那么当前节点就是平衡二叉树。最后递归返回整棵树的平衡情况。</p>\n<p>在递归函数中，我们需要同时返回当前节点的高度和平衡情况，因此可以使用pair&lt;int, bool&gt;来表示。其中，pair的第一个元素表示高度，第二个元素表示当前节点是否是平衡二叉树。同时，我们需要处理一些边界情况，例如空节点的高度为0，空节点也是平衡二叉树。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isBalanced(TreeNode* root) &#123;\n        return checkBalance(root).second;\n    &#125;\n    \n    pair&lt;int, bool&gt; checkBalance(TreeNode* node) &#123;\n        if (!node) &#123;\n            &#x2F;&#x2F; 空节点为平衡二叉树\n            return make_pair(0, true);\n        &#125;\n        auto left &#x3D; checkBalance(node-&gt;left);\n        auto right &#x3D; checkBalance(node-&gt;right);\n        if (left.second &amp;&amp; right.second &amp;&amp; abs(left.first - right.first) &lt;&#x3D; 1) &#123;\n            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1\n            return make_pair(max(left.first, right.first) + 1, true);\n        &#125;\n        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡\n        return make_pair(0, false);\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p><code>pair</code>是C++ STL中的一个模板类，用于存储两个不同类型的变量。它将两个变量打包成一个整体，方便传递和使用。</p>\n</blockquote>\n<p>但是它的内存占用过高，因为对于每个节点，它都要单独存一个bool变量用于表示节点是否为二叉树的平衡结点。因此需要进行优化。</p>\n<ul>\n<li>递归，但优化内存占用</li>\n</ul>\n<p>在题目中，我们使用了<code>pair&lt;int, bool&gt;</code>来表示每个节点的高度和平衡情况，但是这种方法会浪费一定的空间，因为每个节点都需要存储一个<code>bool</code>类型的变量。实际上，我们只需要判断每个节点是否平衡，因此可以使用一个<code>int</code>类型的变量来表示平衡情况：-1表示不平衡，非0表示平衡并且代表节点的高度。这样就可以减少空间的使用。</p>\n<p>同时，我们可以将返回值从<code>pair&lt;int, bool&gt;</code>改为<code>int</code>，表示当前节点的高度。如果当前节点不是平衡二叉树，那么直接返回-1，否则返回节点的高度。</p>\n<p>C++代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isBalanced(TreeNode* root) &#123;\n        return checkBalance(root) !&#x3D; -1;\n    &#125;\n\n    int checkBalance(TreeNode* node) &#123;\n        if (!node) &#123;\n            &#x2F;&#x2F; 空节点为平衡二叉树\n            return 0;\n        &#125;\n        int left &#x3D; checkBalance(node-&gt;left);\n        int right &#x3D; checkBalance(node-&gt;right);\n        if (left !&#x3D; -1 &amp;&amp; right !&#x3D; -1 &amp;&amp; abs(left - right) &lt;&#x3D; 1) &#123;\n            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1\n            return max(left, right) + 1;\n        &#125;\n        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡\n        return -1;\n    &#125;\n&#125;;</code></pre>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/balance_1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/balance_2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]\n输出：false</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：true</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>\n<li><code>-104 &lt;= Node.val &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归但空间复杂度较高的解法</li>\n</ul>\n<p>本题可以使用递归的方法来解决。对于每一个节点，我们需要先递归遍历它的左右子树，计算它们的高度差。如果左右子树的高度差超过了1，那么这棵树就不是平衡二叉树。如果左右子树都是平衡二叉树，那么我们可以判断当前节点是不是平衡二叉树：如果左右子树的高度差不超过1，那么当前节点就是平衡二叉树。最后递归返回整棵树的平衡情况。</p>\n<p>在递归函数中，我们需要同时返回当前节点的高度和平衡情况，因此可以使用pair&lt;int, bool&gt;来表示。其中，pair的第一个元素表示高度，第二个元素表示当前节点是否是平衡二叉树。同时，我们需要处理一些边界情况，例如空节点的高度为0，空节点也是平衡二叉树。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isBalanced(TreeNode* root) &#123;\n        return checkBalance(root).second;\n    &#125;\n    \n    pair&lt;int, bool&gt; checkBalance(TreeNode* node) &#123;\n        if (!node) &#123;\n            &#x2F;&#x2F; 空节点为平衡二叉树\n            return make_pair(0, true);\n        &#125;\n        auto left &#x3D; checkBalance(node-&gt;left);\n        auto right &#x3D; checkBalance(node-&gt;right);\n        if (left.second &amp;&amp; right.second &amp;&amp; abs(left.first - right.first) &lt;&#x3D; 1) &#123;\n            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1\n            return make_pair(max(left.first, right.first) + 1, true);\n        &#125;\n        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡\n        return make_pair(0, false);\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p><code>pair</code>是C++ STL中的一个模板类，用于存储两个不同类型的变量。它将两个变量打包成一个整体，方便传递和使用。</p>\n</blockquote>\n<p>但是它的内存占用过高，因为对于每个节点，它都要单独存一个bool变量用于表示节点是否为二叉树的平衡结点。因此需要进行优化。</p>\n<ul>\n<li>递归，但优化内存占用</li>\n</ul>\n<p>在题目中，我们使用了<code>pair&lt;int, bool&gt;</code>来表示每个节点的高度和平衡情况，但是这种方法会浪费一定的空间，因为每个节点都需要存储一个<code>bool</code>类型的变量。实际上，我们只需要判断每个节点是否平衡，因此可以使用一个<code>int</code>类型的变量来表示平衡情况：-1表示不平衡，非0表示平衡并且代表节点的高度。这样就可以减少空间的使用。</p>\n<p>同时，我们可以将返回值从<code>pair&lt;int, bool&gt;</code>改为<code>int</code>，表示当前节点的高度。如果当前节点不是平衡二叉树，那么直接返回-1，否则返回节点的高度。</p>\n<p>C++代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isBalanced(TreeNode* root) &#123;\n        return checkBalance(root) !&#x3D; -1;\n    &#125;\n\n    int checkBalance(TreeNode* node) &#123;\n        if (!node) &#123;\n            &#x2F;&#x2F; 空节点为平衡二叉树\n            return 0;\n        &#125;\n        int left &#x3D; checkBalance(node-&gt;left);\n        int right &#x3D; checkBalance(node-&gt;right);\n        if (left !&#x3D; -1 &amp;&amp; right !&#x3D; -1 &amp;&amp; abs(left - right) &lt;&#x3D; 1) &#123;\n            &#x2F;&#x2F; 左右子树都是平衡二叉树，且高度差不超过1\n            return max(left, right) + 1;\n        &#125;\n        &#x2F;&#x2F; 左右子树不平衡，或者当前节点不平衡\n        return -1;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[]}