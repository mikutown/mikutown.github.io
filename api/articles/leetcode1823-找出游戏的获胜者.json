{"title":"leetcode1823.找出游戏的获胜者","slug":"leetcode1823-找出游戏的获胜者","date":"2023-04-18T03:49:15.000Z","updated":"2023-04-18T04:12:22.999Z","comments":true,"path":"api/articles/leetcode1823-找出游戏的获胜者.json","excerpt":"题目共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;= i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。游戏遵循如下规则：从第 1 名小伙伴所在位置 开始 。沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。否则，圈子中最后一名小伙伴赢得游戏。给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。","covers":["http://cdn.leafii.top/img/ic234-q2-ex11.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 <strong>顺时针顺序</strong> 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 <code>i</code> 名小伙伴顺时针移动一位会到达第 <code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code> ，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 <code>1</code> 名小伙伴的位置。</p>\n<p>游戏遵循如下规则：</p>\n<ol>\n<li>从第 <code>1</code> 名小伙伴所在位置 <strong>开始</strong> 。</li>\n<li>沿着顺时针方向数 <code>k</code> 名小伙伴，计数时需要 <strong>包含</strong> 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li>\n<li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li>\n<li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 <strong>顺时针下一位</strong> 小伙伴 <strong>开始</strong>，回到步骤 <code>2</code> 继续执行。</li>\n<li>否则，圈子中最后一名小伙伴赢得游戏。</li>\n</ol>\n<p>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/ic234-q2-ex11.png\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 5, k &#x3D; 2\n输出：3\n解释：游戏运行步骤如下：\n1) 从小伙伴 1 开始。\n2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。\n3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。\n4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。\n5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。\n6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。\n7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。\n8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。\n9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 6, k &#x3D; 5\n输出：1\n解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= k &lt;= n &lt;= 500</code></li>\n</ul>\n<p><strong>进阶：</strong>你能否使用线性时间复杂度和常数空间复杂度解决此问题？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>约瑟夫问题求解</li>\n</ul>\n<p>首先我们需要确定递推公式，假设上一轮淘汰的是第 m 个人，那么本轮淘汰的是第 $(m+k)% n$ 个人，所以我们可以得到递推公式：$f(n, k) &#x3D; (f(n-1, k)+k) % n$，其中$ f(n, k) $表示 n 个人中最后剩下的人的编号。</p>\n<p>当只有一个人的时候，那么这个人一定是胜者，因此我们可以得到初始值：f(1, k) &#x3D; 0。</p>\n<p>最后，我们可以通过递推得到 f(n, k) 的值，即为最后的胜者的编号。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int findTheWinner(int n, int k) &#123;\n        int ans &#x3D; 0;  &#x2F;&#x2F; 最后胜者的编号\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;  &#x2F;&#x2F; 从第二个人开始进行游戏\n            ans &#x3D; (ans + k) % i;  &#x2F;&#x2F; 计算本轮淘汰的人的编号\n        &#125;\n        return ans + 1;  &#x2F;&#x2F; 将编号从 0-based 转换为 1-based 并返回\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/ic234-q2-ex11.png\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 5, k &#x3D; 2\n输出：3\n解释：游戏运行步骤如下：\n1) 从小伙伴 1 开始。\n2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。\n3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。\n4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。\n5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。\n6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。\n7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。\n8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。\n9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 6, k &#x3D; 5\n输出：1\n解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= k &lt;= n &lt;= 500</code></li>\n</ul>\n<p><strong>进阶：</strong>你能否使用线性时间复杂度和常数空间复杂度解决此问题？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>约瑟夫问题求解</li>\n</ul>\n<p>首先我们需要确定递推公式，假设上一轮淘汰的是第 m 个人，那么本轮淘汰的是第 $(m+k)% n$ 个人，所以我们可以得到递推公式：$f(n, k) &#x3D; (f(n-1, k)+k) % n$，其中$ f(n, k) $表示 n 个人中最后剩下的人的编号。</p>\n<p>当只有一个人的时候，那么这个人一定是胜者，因此我们可以得到初始值：f(1, k) &#x3D; 0。</p>\n<p>最后，我们可以通过递推得到 f(n, k) 的值，即为最后的胜者的编号。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int findTheWinner(int n, int k) &#123;\n        int ans &#x3D; 0;  &#x2F;&#x2F; 最后胜者的编号\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;  &#x2F;&#x2F; 从第二个人开始进行游戏\n            ans &#x3D; (ans + k) % i;  &#x2F;&#x2F; 计算本轮淘汰的人的编号\n        &#125;\n        return ans + 1;  &#x2F;&#x2F; 将编号从 0-based 转换为 1-based 并返回\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}