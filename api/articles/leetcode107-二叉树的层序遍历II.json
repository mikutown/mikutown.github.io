{"title":"leetcode107.二叉树的层序遍历II","slug":"leetcode107-二叉树的层序遍历II","date":"2023-06-20T08:22:14.000Z","updated":"2023-06-20T05:52:16.453Z","comments":true,"path":"api/articles/leetcode107-二叉树的层序遍历II.json","excerpt":"题目给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）","covers":["http://cdn.leafii.top/img/tree1.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：[[15,7],[9,20],[3]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[[1]]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>使用了层次遍历的思想，利用队列实现。具体解题思路如下：</p>\n<ol>\n<li>首先定义树的节点结构 <code>TreeNode</code>，包含节点值 <code>val</code>、左子节点指针 <code>left</code> 和右子节点指针 <code>right</code>。</li>\n<li>定义一个函数 <code>levelOrderBottom</code>，该函数接受树的根节点 <code>root</code>，并返回层次遍历的结果。</li>\n<li>在 <code>levelOrderBottom</code> 函数中，首先创建一个空的二维向量 <code>result</code>，用于保存最终的结果。</li>\n<li>若根节点为空，直接返回空的结果向量 <code>result</code>。</li>\n<li>创建一个队列 <code>q</code>，将根节点 <code>root</code> 入队。</li>\n<li>进入循环，直到队列为空：<ul>\n<li>获取当前层的节点数量 <code>levelSize</code>，这是为了在遍历当前层时，仅遍历当前层的节点。</li>\n<li>创建一个空的向量 <code>level</code>，用于保存当前层的节点值。</li>\n<li>进入内层循环，遍历当前层的节点：<ul>\n<li>取出队首节点 <code>node</code>。</li>\n<li>弹出队首节点。</li>\n<li>将节点值 <code>node-&gt;val</code> 添加到当前层的结果向量 <code>level</code> 中。</li>\n<li>若节点的左子节点不为空，将左子节点入队。</li>\n<li>若节点的右子节点不为空，将右子节点入队。</li>\n</ul>\n</li>\n<li>将当前层的结果向量 <code>level</code> 插入到结果向量 <code>result</code> 的开头，这是为了保持结果的逆序。</li>\n</ul>\n</li>\n<li>循环结束后，返回结果向量 <code>result</code>。</li>\n<li>在 <code>main</code> 函数中，创建一个测试用例 <code>[3,9,20,null,null,15,7]</code> 的树。</li>\n<li>调用 <code>levelOrderBottom</code> 函数，获取层次遍历的结果，并输出结果。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;\n        vector&lt;vector&lt;int&gt;&gt; result; &#x2F;&#x2F; 保存最终的结果\n        if (root &#x3D;&#x3D; NULL) &#123;\n            return result;\n        &#125;\n\n        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 创建一个队列，用于层次遍历\n        q.push(root); &#x2F;&#x2F; 将根节点入队\n\n        while (!q.empty()) &#123;\n            int levelSize &#x3D; q.size(); &#x2F;&#x2F; 当前层的节点数量\n            vector&lt;int&gt; level; &#x2F;&#x2F; 保存当前层的节点值\n\n            for (int i &#x3D; 0; i &lt; levelSize; i++) &#123;\n                TreeNode* node &#x3D; q.front(); &#x2F;&#x2F; 取出队首节点\n                q.pop(); &#x2F;&#x2F; 弹出队首节点\n                level.push_back(node-&gt;val); &#x2F;&#x2F; 将节点值保存到当前层的结果中\n\n                if (node-&gt;left !&#x3D; NULL) &#123;\n                    q.push(node-&gt;left); &#x2F;&#x2F; 将左子节点入队\n                &#125;\n                if (node-&gt;right !&#x3D; NULL) &#123;\n                    q.push(node-&gt;right); &#x2F;&#x2F; 将右子节点入队\n                &#125;\n            &#125;\n\n            result.insert(result.begin(), level); &#x2F;&#x2F; 将当前层的结果插入到结果向量的开头\n        &#125;\n\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：[[15,7],[9,20],[3]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[[1]]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>使用了层次遍历的思想，利用队列实现。具体解题思路如下：</p>\n<ol>\n<li>首先定义树的节点结构 <code>TreeNode</code>，包含节点值 <code>val</code>、左子节点指针 <code>left</code> 和右子节点指针 <code>right</code>。</li>\n<li>定义一个函数 <code>levelOrderBottom</code>，该函数接受树的根节点 <code>root</code>，并返回层次遍历的结果。</li>\n<li>在 <code>levelOrderBottom</code> 函数中，首先创建一个空的二维向量 <code>result</code>，用于保存最终的结果。</li>\n<li>若根节点为空，直接返回空的结果向量 <code>result</code>。</li>\n<li>创建一个队列 <code>q</code>，将根节点 <code>root</code> 入队。</li>\n<li>进入循环，直到队列为空：<ul>\n<li>获取当前层的节点数量 <code>levelSize</code>，这是为了在遍历当前层时，仅遍历当前层的节点。</li>\n<li>创建一个空的向量 <code>level</code>，用于保存当前层的节点值。</li>\n<li>进入内层循环，遍历当前层的节点：<ul>\n<li>取出队首节点 <code>node</code>。</li>\n<li>弹出队首节点。</li>\n<li>将节点值 <code>node-&gt;val</code> 添加到当前层的结果向量 <code>level</code> 中。</li>\n<li>若节点的左子节点不为空，将左子节点入队。</li>\n<li>若节点的右子节点不为空，将右子节点入队。</li>\n</ul>\n</li>\n<li>将当前层的结果向量 <code>level</code> 插入到结果向量 <code>result</code> 的开头，这是为了保持结果的逆序。</li>\n</ul>\n</li>\n<li>循环结束后，返回结果向量 <code>result</code>。</li>\n<li>在 <code>main</code> 函数中，创建一个测试用例 <code>[3,9,20,null,null,15,7]</code> 的树。</li>\n<li>调用 <code>levelOrderBottom</code> 函数，获取层次遍历的结果，并输出结果。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;\n        vector&lt;vector&lt;int&gt;&gt; result; &#x2F;&#x2F; 保存最终的结果\n        if (root &#x3D;&#x3D; NULL) &#123;\n            return result;\n        &#125;\n\n        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 创建一个队列，用于层次遍历\n        q.push(root); &#x2F;&#x2F; 将根节点入队\n\n        while (!q.empty()) &#123;\n            int levelSize &#x3D; q.size(); &#x2F;&#x2F; 当前层的节点数量\n            vector&lt;int&gt; level; &#x2F;&#x2F; 保存当前层的节点值\n\n            for (int i &#x3D; 0; i &lt; levelSize; i++) &#123;\n                TreeNode* node &#x3D; q.front(); &#x2F;&#x2F; 取出队首节点\n                q.pop(); &#x2F;&#x2F; 弹出队首节点\n                level.push_back(node-&gt;val); &#x2F;&#x2F; 将节点值保存到当前层的结果中\n\n                if (node-&gt;left !&#x3D; NULL) &#123;\n                    q.push(node-&gt;left); &#x2F;&#x2F; 将左子节点入队\n                &#125;\n                if (node-&gt;right !&#x3D; NULL) &#123;\n                    q.push(node-&gt;right); &#x2F;&#x2F; 将右子节点入队\n                &#125;\n            &#125;\n\n            result.insert(result.begin(), level); &#x2F;&#x2F; 将当前层的结果插入到结果向量的开头\n        &#125;\n\n        return result;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}