{"title":"leetcode98.验证二叉搜索树","slug":"leetcode98-验证二叉搜索树","date":"2023-05-31T06:11:21.000Z","updated":"2023-05-31T06:28:58.366Z","comments":true,"path":"api/articles/leetcode98-验证二叉搜索树.json","excerpt":"题目给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效 二叉搜索树定义如下：节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。","covers":["http://cdn.leafii.top/img/tree1-20230531141156695.jpg","http://cdn.leafii.top/img/tree2-20230531141159669.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>\n<p><strong>有效</strong> 二叉搜索树定义如下：</p>\n<ul>\n<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>\n<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>\n<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree1-20230531141156695.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [2,1,3]\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree2-20230531141159669.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [5,1,4,null,null,3,6]\n输出：false\n解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目范围在<code>[1, 104]</code> 内</li>\n<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>基于限定值的递归判断</li>\n</ul>\n<p>思路如下：对每一个需要被判断的节点，都为他设置一个最大值和最小值（防止子树的子树不符合搜索树条件），根节点的最大最小值是C++ longlong类型的最大最小值，之后判断左子树时，最大值变更为根节点的值，判断右子树时，最小值变为根节点的值，在判断节点时，若节点为空，则该子树是有效的二叉搜索树，否则就检查当前节点的值是否在minVal到maxVal的范围内。最后递归的验证左子树和右子树。C++实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F; 辅助函数，用于验证给定的子树是否为有效的二叉搜索树\n    bool isValidBSTHelper(TreeNode* node, long long minVal, long long maxVal) &#123;\n        &#x2F;&#x2F; 如果节点为空，则表示该子树是有效的二叉搜索树\n        if (node &#x3D;&#x3D; NULL)\n            return true;\n        \n        &#x2F;&#x2F; 检查当前节点的值是否在[minVal, maxVal]的范围内\n        if (node-&gt;val &lt;&#x3D; minVal || node-&gt;val &gt;&#x3D; maxVal)\n            return false;\n        \n        &#x2F;&#x2F; 递归验证左子树和右子树\n        return isValidBSTHelper(node-&gt;left, minVal, node-&gt;val) &amp;&amp;\n            isValidBSTHelper(node-&gt;right, node-&gt;val, maxVal);\n    &#125;\n    bool isValidBST(TreeNode* root) &#123;\n        &#x2F;&#x2F; 由于题目中未指定树节点的值的范围，所以我们使用长整型的最小值和最大值作为初始范围\n        long long minVal &#x3D; LLONG_MIN;\n        long long maxVal &#x3D; LLONG_MAX;\n        \n        &#x2F;&#x2F; 调用辅助函数进行验证\n        return isValidBSTHelper(root, minVal, maxVal);\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree1-20230531141156695.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [2,1,3]\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree2-20230531141159669.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [5,1,4,null,null,3,6]\n输出：false\n解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目范围在<code>[1, 104]</code> 内</li>\n<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>基于限定值的递归判断</li>\n</ul>\n<p>思路如下：对每一个需要被判断的节点，都为他设置一个最大值和最小值（防止子树的子树不符合搜索树条件），根节点的最大最小值是C++ longlong类型的最大最小值，之后判断左子树时，最大值变更为根节点的值，判断右子树时，最小值变为根节点的值，在判断节点时，若节点为空，则该子树是有效的二叉搜索树，否则就检查当前节点的值是否在minVal到maxVal的范围内。最后递归的验证左子树和右子树。C++实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F; 辅助函数，用于验证给定的子树是否为有效的二叉搜索树\n    bool isValidBSTHelper(TreeNode* node, long long minVal, long long maxVal) &#123;\n        &#x2F;&#x2F; 如果节点为空，则表示该子树是有效的二叉搜索树\n        if (node &#x3D;&#x3D; NULL)\n            return true;\n        \n        &#x2F;&#x2F; 检查当前节点的值是否在[minVal, maxVal]的范围内\n        if (node-&gt;val &lt;&#x3D; minVal || node-&gt;val &gt;&#x3D; maxVal)\n            return false;\n        \n        &#x2F;&#x2F; 递归验证左子树和右子树\n        return isValidBSTHelper(node-&gt;left, minVal, node-&gt;val) &amp;&amp;\n            isValidBSTHelper(node-&gt;right, node-&gt;val, maxVal);\n    &#125;\n    bool isValidBST(TreeNode* root) &#123;\n        &#x2F;&#x2F; 由于题目中未指定树节点的值的范围，所以我们使用长整型的最小值和最大值作为初始范围\n        long long minVal &#x3D; LLONG_MIN;\n        long long maxVal &#x3D; LLONG_MAX;\n        \n        &#x2F;&#x2F; 调用辅助函数进行验证\n        return isValidBSTHelper(root, minVal, maxVal);\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}