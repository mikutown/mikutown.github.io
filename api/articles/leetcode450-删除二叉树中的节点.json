{"title":"leetcode450.删除二叉树中的节点","slug":"leetcode450-删除二叉树中的节点","date":"2023-06-29T09:06:41.000Z","updated":"2023-06-29T09:11:20.477Z","comments":true,"path":"api/articles/leetcode450-删除二叉树中的节点.json","excerpt":"题目给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。","covers":["https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n<p>一般来说，删除节点可分为两个步骤：</p>\n<ol>\n<li>首先找到需要删除的节点；</li>\n<li>如果找到了，删除它。</li>\n</ol>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3\n输出：[5,4,6,2,null,null,7]\n解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n另一个正确答案是 [5,2,6,null,4,null,7]。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0\n输出: [5,3,6,2,4,null,7]\n解释: 二叉树不包含值为 0 的节点</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: root &#x3D; [], key &#x3D; 0\n输出: []</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li>节点数的范围 <code>[0, 104]</code>.</li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n<li>节点值唯一</li>\n<li><code>root</code> 是合法的二叉搜索树</li>\n<li><code>-105 &lt;= key &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>直接上代码：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) &#123;\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            return nullptr;\n        &#125;\n\n        if (root-&gt;val &#x3D;&#x3D; key) &#123;\n            &#x2F;&#x2F; 当前节点需要删除\n            if (root-&gt;left &#x3D;&#x3D; nullptr) &#123;\n                &#x2F;&#x2F; 没有左子树，返回右子树\n                return root-&gt;right;\n            &#125; else if (root-&gt;right &#x3D;&#x3D; nullptr) &#123;\n                &#x2F;&#x2F; 没有右子树，返回左子树\n                return root-&gt;left;\n            &#125; else &#123;\n                &#x2F;&#x2F; 左右子树都存在，找到右子树中的最小节点\n                TreeNode* minNode &#x3D; findMin(root-&gt;right);\n                &#x2F;&#x2F; 将最小节点的值赋给当前节点\n                root-&gt;val &#x3D; minNode-&gt;val;\n                &#x2F;&#x2F; 在右子树中递归删除最小节点\n                root-&gt;right &#x3D; deleteNode(root-&gt;right, minNode-&gt;val);\n            &#125;\n        &#125; else if (root-&gt;val &gt; key) &#123;\n            &#x2F;&#x2F; 要删除的值小于当前节点的值，递归在左子树中删除\n            root-&gt;left &#x3D; deleteNode(root-&gt;left, key);\n        &#125; else &#123;\n            &#x2F;&#x2F; 要删除的值大于当前节点的值，递归在右子树中删除\n            root-&gt;right &#x3D; deleteNode(root-&gt;right, key);\n        &#125;\n\n        return root;\n    &#125;\n\nprivate:\n    &#x2F;&#x2F; 在二叉搜索树中找到最小节点\n    TreeNode* findMin(TreeNode* node) &#123;\n        while (node-&gt;left !&#x3D; nullptr) &#123;\n            node &#x3D; node-&gt;left;\n        &#125;\n        return node;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3\n输出：[5,4,6,2,null,null,7]\n解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n另一个正确答案是 [5,2,6,null,4,null,7]。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0\n输出: [5,3,6,2,4,null,7]\n解释: 二叉树不包含值为 0 的节点</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: root &#x3D; [], key &#x3D; 0\n输出: []</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li>节点数的范围 <code>[0, 104]</code>.</li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n<li>节点值唯一</li>\n<li><code>root</code> 是合法的二叉搜索树</li>\n<li><code>-105 &lt;= key &lt;= 105</code></li>\n</ul>\n<p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>直接上代码：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) &#123;\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            return nullptr;\n        &#125;\n\n        if (root-&gt;val &#x3D;&#x3D; key) &#123;\n            &#x2F;&#x2F; 当前节点需要删除\n            if (root-&gt;left &#x3D;&#x3D; nullptr) &#123;\n                &#x2F;&#x2F; 没有左子树，返回右子树\n                return root-&gt;right;\n            &#125; else if (root-&gt;right &#x3D;&#x3D; nullptr) &#123;\n                &#x2F;&#x2F; 没有右子树，返回左子树\n                return root-&gt;left;\n            &#125; else &#123;\n                &#x2F;&#x2F; 左右子树都存在，找到右子树中的最小节点\n                TreeNode* minNode &#x3D; findMin(root-&gt;right);\n                &#x2F;&#x2F; 将最小节点的值赋给当前节点\n                root-&gt;val &#x3D; minNode-&gt;val;\n                &#x2F;&#x2F; 在右子树中递归删除最小节点\n                root-&gt;right &#x3D; deleteNode(root-&gt;right, minNode-&gt;val);\n            &#125;\n        &#125; else if (root-&gt;val &gt; key) &#123;\n            &#x2F;&#x2F; 要删除的值小于当前节点的值，递归在左子树中删除\n            root-&gt;left &#x3D; deleteNode(root-&gt;left, key);\n        &#125; else &#123;\n            &#x2F;&#x2F; 要删除的值大于当前节点的值，递归在右子树中删除\n            root-&gt;right &#x3D; deleteNode(root-&gt;right, key);\n        &#125;\n\n        return root;\n    &#125;\n\nprivate:\n    &#x2F;&#x2F; 在二叉搜索树中找到最小节点\n    TreeNode* findMin(TreeNode* node) &#123;\n        while (node-&gt;left !&#x3D; nullptr) &#123;\n            node &#x3D; node-&gt;left;\n        &#125;\n        return node;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}