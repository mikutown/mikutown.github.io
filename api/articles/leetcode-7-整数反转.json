{"title":"leetcode:7.整数反转","slug":"leetcode-7-整数反转","date":"2023-01-10T06:59:15.000Z","updated":"2023-01-10T07:19:49.598Z","comments":true,"path":"api/articles/leetcode-7-整数反转.json","excerpt":"题目给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>\n<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p>\n<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：x &#x3D; 123\n输出：321</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：x &#x3D; -123\n输出：-321</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：x &#x3D; 120\n输出：21</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：x &#x3D; 0\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>将数字的每位分别提取并进行字符串拼接，最终将字符串转为int型数字，思路如下：</li>\n</ol>\n<p>因为负数对10取余数得到的结果依然为负数，所以如果x为负数，则将minus标记设置为true，并且将x转化为正数，如果x为正数，则minus标记为false，进行x的正负判断之后可以将string类型的ans_str变量进行初始化，接着进行x的特殊值的判断，因为int型的范围是$-2^{31} 到  2^{31}-1$，所以当<code>x=-2147483648</code>时，它无法被转化为正数进行计算，因此需要单独判断，需要单独判断的还有<code>x=0</code>的情况。接着在while循环中进行倒置的过程。倒置结束后对倒置结果进行判断，如果超过范围的话直接返回0（因为无法通过C++的stoi方法转化为int型结果。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int reverse(int x) &#123;\n        bool minus &#x3D; false;\n        string ans_str &#x3D; &quot;0&quot;;\n        &#x2F;&#x2F;特例判断\n        if(x &#x3D;&#x3D; -2147483648)&#123;\n            return 0;\n        &#125;\n        if(x &#x3D;&#x3D; 0)\n        &#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;对负数的处理\n        if(x &lt; 0)\n        &#123;\n            ans_str &#x3D; &quot;-0&quot;;\n            x &#x3D; x * -1;\n            minus &#x3D; true;\n        &#125;\n        &#x2F;&#x2F;在while循环中进行倒置操作，倒置结果储存在ans_str变量中。\n        while(x !&#x3D; 0)&#123;\n            int temp_num &#x3D; x % 10;\n            x &#x3D; x &#x2F; 10;\n            string temp_str &#x3D; to_string(temp_num);\n            ans_str &#x3D; ans_str + temp_str;\n        &#125;\n        &#x2F;&#x2F;2^31-1 &#x3D; 2147483647\n        &#x2F;&#x2F;-2^31 &#x3D; -2147483648\n        &#x2F;&#x2F;通过int型范围设置两个对比的string类型，防止倒置结果超过范围。\n        string upper &#x3D; &quot;02147483647&quot;;\n        string lower &#x3D; &quot;-02147483648&quot;;\n        &#x2F;&#x2F;倒置结果是否超限的判断\n        if(minus &#x3D;&#x3D; true &amp;&amp; ans_str.length() &#x3D;&#x3D; 12)&#123;\n            for(int i &#x3D; 0; i &lt; 12; i++)&#123;\n                if(ans_str[i] &lt; lower[i])&#123;\n                    break;\n                &#125;\n                if(ans_str[i] &gt; lower[i])&#123;\n                    return 0; \n                &#125;\n            &#125;\n        &#125;\n        if(minus &#x3D;&#x3D; false &amp;&amp; ans_str.length() &#x3D;&#x3D; 11)&#123;\n            for(int i &#x3D; 0; i &lt; 11; i++)&#123;\n                if(ans_str[i] &lt; upper[i])&#123;\n                    break;\n                &#125;\n                if(ans_str[i] &gt; upper[i])&#123;\n                    return 0;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;最终结果的转化\n        &#x2F;&#x2F;stoi函数：string -&gt; int\n        &#x2F;&#x2F;to_string函数：int -&gt; string\n        int ans &#x3D; stoi(ans_str);\n        return ans;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：x &#x3D; 123\n输出：321</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：x &#x3D; -123\n输出：-321</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：x &#x3D; 120\n输出：21</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：x &#x3D; 0\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>将数字的每位分别提取并进行字符串拼接，最终将字符串转为int型数字，思路如下：</li>\n</ol>\n<p>因为负数对10取余数得到的结果依然为负数，所以如果x为负数，则将minus标记设置为true，并且将x转化为正数，如果x为正数，则minus标记为false，进行x的正负判断之后可以将string类型的ans_str变量进行初始化，接着进行x的特殊值的判断，因为int型的范围是$-2^{31} 到  2^{31}-1$，所以当<code>x=-2147483648</code>时，它无法被转化为正数进行计算，因此需要单独判断，需要单独判断的还有<code>x=0</code>的情况。接着在while循环中进行倒置的过程。倒置结束后对倒置结果进行判断，如果超过范围的话直接返回0（因为无法通过C++的stoi方法转化为int型结果。C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int reverse(int x) &#123;\n        bool minus &#x3D; false;\n        string ans_str &#x3D; &quot;0&quot;;\n        &#x2F;&#x2F;特例判断\n        if(x &#x3D;&#x3D; -2147483648)&#123;\n            return 0;\n        &#125;\n        if(x &#x3D;&#x3D; 0)\n        &#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;对负数的处理\n        if(x &lt; 0)\n        &#123;\n            ans_str &#x3D; &quot;-0&quot;;\n            x &#x3D; x * -1;\n            minus &#x3D; true;\n        &#125;\n        &#x2F;&#x2F;在while循环中进行倒置操作，倒置结果储存在ans_str变量中。\n        while(x !&#x3D; 0)&#123;\n            int temp_num &#x3D; x % 10;\n            x &#x3D; x &#x2F; 10;\n            string temp_str &#x3D; to_string(temp_num);\n            ans_str &#x3D; ans_str + temp_str;\n        &#125;\n        &#x2F;&#x2F;2^31-1 &#x3D; 2147483647\n        &#x2F;&#x2F;-2^31 &#x3D; -2147483648\n        &#x2F;&#x2F;通过int型范围设置两个对比的string类型，防止倒置结果超过范围。\n        string upper &#x3D; &quot;02147483647&quot;;\n        string lower &#x3D; &quot;-02147483648&quot;;\n        &#x2F;&#x2F;倒置结果是否超限的判断\n        if(minus &#x3D;&#x3D; true &amp;&amp; ans_str.length() &#x3D;&#x3D; 12)&#123;\n            for(int i &#x3D; 0; i &lt; 12; i++)&#123;\n                if(ans_str[i] &lt; lower[i])&#123;\n                    break;\n                &#125;\n                if(ans_str[i] &gt; lower[i])&#123;\n                    return 0; \n                &#125;\n            &#125;\n        &#125;\n        if(minus &#x3D;&#x3D; false &amp;&amp; ans_str.length() &#x3D;&#x3D; 11)&#123;\n            for(int i &#x3D; 0; i &lt; 11; i++)&#123;\n                if(ans_str[i] &lt; upper[i])&#123;\n                    break;\n                &#125;\n                if(ans_str[i] &gt; upper[i])&#123;\n                    return 0;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;最终结果的转化\n        &#x2F;&#x2F;stoi函数：string -&gt; int\n        &#x2F;&#x2F;to_string函数：int -&gt; string\n        int ans &#x3D; stoi(ans_str);\n        return ans;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}