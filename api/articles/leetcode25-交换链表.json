{"title":"leetcode25.交换链表","slug":"leetcode25-交换链表","date":"2023-03-01T07:15:42.000Z","updated":"2023-03-06T07:16:29.514Z","comments":true,"path":"api/articles/leetcode25-交换链表.json","excerpt":"题目给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。","covers":["http://cdn.leafii.top/img/swap_ex1.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/swap_ex1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4]\n输出：[2,1,4,3]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1]\n输出：[1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>直接进行交换，思路如下：</li>\n</ol>\n<p>当链表为空或者只有一个节点时，无需任何操作，直接返回<code>head</code>，否则就定义指针<code>cur</code>和<code>before</code>，初始值分别为<code>head</code>和<code>NULL</code>。当链表中至少有两个节点时进行循环，在循环里定义一个指针<code>tmp</code>，用于指向<code>cur</code>的下一个节点，接下来进行两个节点的交换操作，此时判断before指针是否为空，若不为空则将before的next指向交换完毕的<code>tmp</code>指针，然后更新<code>cur</code>指针的值，继续循环直到链表中未得到交换的元素数小于2停止，最后返回头节点<code>head</code>。C++实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* swapPairs(ListNode* head) &#123;\n        &#x2F;&#x2F; 如果链表为空或只有一个节点，直接返回头指针\n        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return head;\n\n        &#x2F;&#x2F; 定义指针 cur 和 before，初始值分别为 head 和 NULL\n        ListNode* cur &#x3D; head;\n        ListNode* before &#x3D; NULL;\n\n        &#x2F;&#x2F; 当链表中至少有两个节点时进行循环\n        while(cur !&#x3D; NULL &amp;&amp; cur-&gt;next !&#x3D; NULL) &#123;\n            &#x2F;&#x2F; 定义指针 tmp，将其指向 cur 的下一个节点\n            ListNode* tmp &#x3D; cur-&gt;next;\n\n            &#x2F;&#x2F; 将 cur 的下一个节点指向 tmp 的下一个节点\n            cur-&gt;next &#x3D; tmp-&gt;next;\n\n            &#x2F;&#x2F; 将 tmp 的下一个节点指向 cur，完成交换\n            tmp-&gt;next &#x3D; cur;\n\n            &#x2F;&#x2F; 如果不是第一次交换，则将 before 的下一个节点指向 tmp\n            if (before !&#x3D; NULL) before-&gt;next &#x3D; tmp;\n\n            &#x2F;&#x2F; 如果 cur 是链表头节点，则将 head 指向 tmp\n            if (cur &#x3D;&#x3D; head) head &#x3D; tmp;\n\n            &#x2F;&#x2F; 将 before 指向 cur，cur 指向下一个节点，进行下一次循环\n            before &#x3D; cur;\n            cur &#x3D; cur-&gt;next;\n        &#125;\n\n        &#x2F;&#x2F; 返回交换后的链表头指针\n        return head;\n    &#125;\n&#125;;</code></pre>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/swap_ex1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4]\n输出：[2,1,4,3]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1]\n输出：[1]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>直接进行交换，思路如下：</li>\n</ol>\n<p>当链表为空或者只有一个节点时，无需任何操作，直接返回<code>head</code>，否则就定义指针<code>cur</code>和<code>before</code>，初始值分别为<code>head</code>和<code>NULL</code>。当链表中至少有两个节点时进行循环，在循环里定义一个指针<code>tmp</code>，用于指向<code>cur</code>的下一个节点，接下来进行两个节点的交换操作，此时判断before指针是否为空，若不为空则将before的next指向交换完毕的<code>tmp</code>指针，然后更新<code>cur</code>指针的值，继续循环直到链表中未得到交换的元素数小于2停止，最后返回头节点<code>head</code>。C++实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* swapPairs(ListNode* head) &#123;\n        &#x2F;&#x2F; 如果链表为空或只有一个节点，直接返回头指针\n        if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return head;\n\n        &#x2F;&#x2F; 定义指针 cur 和 before，初始值分别为 head 和 NULL\n        ListNode* cur &#x3D; head;\n        ListNode* before &#x3D; NULL;\n\n        &#x2F;&#x2F; 当链表中至少有两个节点时进行循环\n        while(cur !&#x3D; NULL &amp;&amp; cur-&gt;next !&#x3D; NULL) &#123;\n            &#x2F;&#x2F; 定义指针 tmp，将其指向 cur 的下一个节点\n            ListNode* tmp &#x3D; cur-&gt;next;\n\n            &#x2F;&#x2F; 将 cur 的下一个节点指向 tmp 的下一个节点\n            cur-&gt;next &#x3D; tmp-&gt;next;\n\n            &#x2F;&#x2F; 将 tmp 的下一个节点指向 cur，完成交换\n            tmp-&gt;next &#x3D; cur;\n\n            &#x2F;&#x2F; 如果不是第一次交换，则将 before 的下一个节点指向 tmp\n            if (before !&#x3D; NULL) before-&gt;next &#x3D; tmp;\n\n            &#x2F;&#x2F; 如果 cur 是链表头节点，则将 head 指向 tmp\n            if (cur &#x3D;&#x3D; head) head &#x3D; tmp;\n\n            &#x2F;&#x2F; 将 before 指向 cur，cur 指向下一个节点，进行下一次循环\n            before &#x3D; cur;\n            cur &#x3D; cur-&gt;next;\n        &#125;\n\n        &#x2F;&#x2F; 返回交换后的链表头指针\n        return head;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}