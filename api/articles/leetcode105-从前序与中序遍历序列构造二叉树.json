{"title":"leetcode105.从前序与中序遍历序列构造二叉树","slug":"leetcode105-从前序与中序遍历序列构造二叉树","date":"2023-03-16T06:24:30.000Z","updated":"2023-03-16T06:27:34.358Z","comments":true,"path":"api/articles/leetcode105-从前序与中序遍历序列构造二叉树.json","excerpt":"题目给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。","covers":["http://cdn.leafii.top/img/tree-20230316142527347.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree-20230316142527347.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]\n输出: [3,9,20,null,null,15,7]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]\n输出: [-1]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>\n<li><code>inorder.length == preorder.length</code></li>\n<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>\n<li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li>\n<li><code>inorder</code> 均出现在 <code>preorder</code></li>\n<li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li>\n<li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>同<a href=\"https://leafii.top/2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/\">106的解法</a>相似,因此在这里只提供代码.</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\n\nclass Solution &#123;\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;\n        &#x2F;&#x2F; 创建根节点\n        TreeNode* root &#x3D; build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);\n        return root;\n    &#125;\n    \n    TreeNode* build(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd, vector&lt;int&gt;&amp; inorder, int inStart, int inEnd) &#123;\n        &#x2F;&#x2F; 特判：preStart &gt; preEnd 时，已经没有节点需要处理，返回 NULL\n        if (preStart &gt; preEnd) &#123;\n            return nullptr;\n        &#125;\n        \n        &#x2F;&#x2F; 创建当前子树的根节点\n        TreeNode* root &#x3D; new TreeNode(preorder[preStart]);\n        \n        &#x2F;&#x2F; 在中序遍历序列中查找当前子树根节点的位置\n        int inRootIndex &#x3D; inStart;\n        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;\n            inRootIndex++;\n        &#125;\n        \n        &#x2F;&#x2F; 计算当前子树左子树的大小\n        int leftTreeSize &#x3D; inRootIndex - inStart;\n        \n        &#x2F;&#x2F; 递归构建当前子树的左子树和右子树\n        root-&gt;left &#x3D; build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inRootIndex - 1);\n        root-&gt;right &#x3D; build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inRootIndex + 1, inEnd);\n        \n        &#x2F;&#x2F; 返回当前子树的根节点\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree-20230316142527347.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]\n输出: [3,9,20,null,null,15,7]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]\n输出: [-1]</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>\n<li><code>inorder.length == preorder.length</code></li>\n<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>\n<li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li>\n<li><code>inorder</code> 均出现在 <code>preorder</code></li>\n<li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li>\n<li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>同<a href=\"https://leafii.top/2023/03/15/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/\">106的解法</a>相似,因此在这里只提供代码.</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\n\nclass Solution &#123;\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;\n        &#x2F;&#x2F; 创建根节点\n        TreeNode* root &#x3D; build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);\n        return root;\n    &#125;\n    \n    TreeNode* build(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd, vector&lt;int&gt;&amp; inorder, int inStart, int inEnd) &#123;\n        &#x2F;&#x2F; 特判：preStart &gt; preEnd 时，已经没有节点需要处理，返回 NULL\n        if (preStart &gt; preEnd) &#123;\n            return nullptr;\n        &#125;\n        \n        &#x2F;&#x2F; 创建当前子树的根节点\n        TreeNode* root &#x3D; new TreeNode(preorder[preStart]);\n        \n        &#x2F;&#x2F; 在中序遍历序列中查找当前子树根节点的位置\n        int inRootIndex &#x3D; inStart;\n        while (inorder[inRootIndex] !&#x3D; root-&gt;val) &#123;\n            inRootIndex++;\n        &#125;\n        \n        &#x2F;&#x2F; 计算当前子树左子树的大小\n        int leftTreeSize &#x3D; inRootIndex - inStart;\n        \n        &#x2F;&#x2F; 递归构建当前子树的左子树和右子树\n        root-&gt;left &#x3D; build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inRootIndex - 1);\n        root-&gt;right &#x3D; build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inRootIndex + 1, inEnd);\n        \n        &#x2F;&#x2F; 返回当前子树的根节点\n        return root;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}