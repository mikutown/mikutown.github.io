{"title":"leetcode674.最长连续递增序列","slug":"leetcode674-最长连续递增序列","date":"2023-08-30T08:13:58.000Z","updated":"2023-08-30T08:26:57.630Z","comments":true,"path":"api/articles/leetcode674-最长连续递增序列.json","excerpt":"题目给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>\n<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,3,5,4,7]\n输出：3\n解释：最长连续递增序列是 [1,3,5], 长度为3。\n尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [2,2,2,2,2]\n输出：1\n解释：最长连续递增序列是 [2], 长度为1。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>直接看代码</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        \n        int maxLength &#x3D; 1; &#x2F;&#x2F; 初始化最大长度为1，因为至少有一个元素存在\n        int currentLength &#x3D; 1; &#x2F;&#x2F; 当前递增序列的长度，初始为1\n\n        for (int i &#x3D; 1; i &lt; n; ++i) &#123;\n            if (nums[i] &gt; nums[i - 1]) &#123;\n                currentLength++; &#x2F;&#x2F; 如果当前元素大于前一个元素，则当前递增序列长度加一\n                maxLength &#x3D; max(maxLength, currentLength); &#x2F;&#x2F; 更新最大长度\n            &#125; else &#123;\n                currentLength &#x3D; 1; &#x2F;&#x2F; 重置当前递增序列长度为1，因为递增中断\n            &#125;\n        &#125;\n        \n        return maxLength;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,3,5,4,7]\n输出：3\n解释：最长连续递增序列是 [1,3,5], 长度为3。\n尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [2,2,2,2,2]\n输出：1\n解释：最长连续递增序列是 [2], 长度为1。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>直接看代码</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        \n        int maxLength &#x3D; 1; &#x2F;&#x2F; 初始化最大长度为1，因为至少有一个元素存在\n        int currentLength &#x3D; 1; &#x2F;&#x2F; 当前递增序列的长度，初始为1\n\n        for (int i &#x3D; 1; i &lt; n; ++i) &#123;\n            if (nums[i] &gt; nums[i - 1]) &#123;\n                currentLength++; &#x2F;&#x2F; 如果当前元素大于前一个元素，则当前递增序列长度加一\n                maxLength &#x3D; max(maxLength, currentLength); &#x2F;&#x2F; 更新最大长度\n            &#125; else &#123;\n                currentLength &#x3D; 1; &#x2F;&#x2F; 重置当前递增序列长度为1，因为递增中断\n            &#125;\n        &#125;\n        \n        return maxLength;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"序列","path":"api/tags/序列.json"}]}