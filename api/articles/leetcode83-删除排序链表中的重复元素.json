{"title":"leetcode83.删除排序链表中的重复元素","slug":"leetcode83-删除排序链表中的重复元素","date":"2023-10-10T06:42:51.000Z","updated":"2023-10-10T06:46:43.120Z","comments":true,"path":"api/articles/leetcode83-删除排序链表中的重复元素.json","excerpt":"题目给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。","covers":["http://cdn.leafii.top/img/list1.jpg","http://cdn.leafii.top/img/list2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/list1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,1,2]\n输出：[1,2]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/list2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,1,2,3,3]\n输出：[1,2,3]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n<li>题目数据保证链表已经按升序 <strong>排列</strong></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>双指针</li>\n</ul>\n<p>思路与第一个题目类似，只是链表与数组的去重方式不同，C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        if (!head || !head-&gt;next) &#123;\n            &#x2F;&#x2F;如果仅有一个元素或者一个元素都没有，直接返回head本身\n            return head;\n        &#125;\n        &#x2F;&#x2F; 初始化指针p，q\n        ListNode* p &#x3D; head; \n        ListNode* q &#x3D; head-&gt;next;\n        while (q) &#123;\n            &#x2F;&#x2F; 当q未指到链表结尾时进行判断\n            if (p-&gt;val &#x3D;&#x3D; q-&gt;val) &#123;\n                &#x2F;&#x2F;相等元素执行断链操作\n                ListNode* temp &#x3D; q;\n                p-&gt;next &#x3D; q-&gt;next;\n                q &#x3D; q-&gt;next;\n                delete temp;\n            &#125;\n            else &#123;\n                &#x2F;&#x2F; 不相等两个指针全都后移\n                p &#x3D; p-&gt;next;\n                q &#x3D; q-&gt;next;\n            &#125;\n        &#125;\n        return head;\n\n    &#125;\n&#125;;</code></pre>\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/list1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,1,2]\n输出：[1,2]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/list2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,1,2,3,3]\n输出：[1,2,3]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n<li>题目数据保证链表已经按升序 <strong>排列</strong></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>双指针</li>\n</ul>\n<p>思路与第一个题目类似，只是链表与数组的去重方式不同，C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        if (!head || !head-&gt;next) &#123;\n            &#x2F;&#x2F;如果仅有一个元素或者一个元素都没有，直接返回head本身\n            return head;\n        &#125;\n        &#x2F;&#x2F; 初始化指针p，q\n        ListNode* p &#x3D; head; \n        ListNode* q &#x3D; head-&gt;next;\n        while (q) &#123;\n            &#x2F;&#x2F; 当q未指到链表结尾时进行判断\n            if (p-&gt;val &#x3D;&#x3D; q-&gt;val) &#123;\n                &#x2F;&#x2F;相等元素执行断链操作\n                ListNode* temp &#x3D; q;\n                p-&gt;next &#x3D; q-&gt;next;\n                q &#x3D; q-&gt;next;\n                delete temp;\n            &#125;\n            else &#123;\n                &#x2F;&#x2F; 不相等两个指针全都后移\n                p &#x3D; p-&gt;next;\n                q &#x3D; q-&gt;next;\n            &#125;\n        &#125;\n        return head;\n\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}