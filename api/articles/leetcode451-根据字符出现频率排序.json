{"title":"leetcode451.根据字符出现频率排序","slug":"leetcode451-根据字符出现频率排序","date":"2023-09-12T13:03:45.000Z","updated":"2023-09-12T13:10:08.684Z","comments":true,"path":"api/articles/leetcode451-根据字符出现频率排序.json","excerpt":"题目给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。返回 已排序的字符串 。如果有多个答案，返回其中任何一个。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串 <code>s</code> ，根据字符出现的 <strong>频率</strong> 对其进行 <strong>降序排序</strong> 。一个字符出现的 <strong>频率</strong> 是它出现在字符串中的次数。</p>\n<p>返回 <em>已排序的字符串</em> 。如果有多个答案，返回其中任何一个。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;tree&quot;\n输出: &quot;eert&quot;\n解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。\n因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;cccaaa&quot;\n输出: &quot;cccaaa&quot;\n解释: &#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。\n注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;Aabb&quot;\n输出: &quot;bbAa&quot;\n解释: 此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。\n注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 5 * 105</code></li>\n<li><code>s</code> 由大小写英文字母和数字组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>思路：首先使用hashmap对字符串中的字符进行计数，然后使用vector数组将hashmap的元素进行拷贝，将vector以计数的从大到小进行排序。最后对排序后的vector进行遍历，得到最终的字符串，C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string frequencySort(string s) &#123;\n        unordered_map&lt;char, int&gt; s_count_map;\n        for (char c:s) &#123;\n            s_count_map[c]++;\n        &#125;\n        &#x2F;&#x2F; 复制\n        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector(s_count_map.begin(), s_count_map.end());\n        &#x2F;&#x2F;从大到小排序\n        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123;return a.second &gt; b.second;&#125;);\n        string result;\n        for(auto cnt:s_count_vector) &#123;\n            int cnt_second &#x3D; cnt.second;\n            while (cnt_second--) &#123;\n                result+&#x3D;cnt.first;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>一些细节优化后的代码（成绩没变）</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string frequencySort(string s) &#123;\n        unordered_map&lt;char, int&gt; s_count_map;\n\n        &#x2F;&#x2F; 统计字符频率\n        for (char c : s) &#123;\n            s_count_map[c]++;\n        &#125;\n\n        &#x2F;&#x2F; 构建结果字符串\n        string result;\n        result.reserve(s.size()); &#x2F;&#x2F; 预分配足够的内存\n\n        &#x2F;&#x2F; 构建频率字符对，并按频率降序排序\n        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector;\n        for (const auto&amp; kv : s_count_map) &#123;\n            s_count_vector.emplace_back(kv);\n        &#125;\n        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123; return a.second &gt; b.second; &#125;);\n\n        &#x2F;&#x2F; 构建结果字符串\n        for (const auto&amp; cnt : s_count_vector) &#123;\n            result.append(cnt.second, cnt.first); &#x2F;&#x2F; 使用append方法\n        &#125;\n\n        return result;\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;tree&quot;\n输出: &quot;eert&quot;\n解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。\n因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;cccaaa&quot;\n输出: &quot;cccaaa&quot;\n解释: &#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。\n注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: s &#x3D; &quot;Aabb&quot;\n输出: &quot;bbAa&quot;\n解释: 此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。\n注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 5 * 105</code></li>\n<li><code>s</code> 由大小写英文字母和数字组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>思路：首先使用hashmap对字符串中的字符进行计数，然后使用vector数组将hashmap的元素进行拷贝，将vector以计数的从大到小进行排序。最后对排序后的vector进行遍历，得到最终的字符串，C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string frequencySort(string s) &#123;\n        unordered_map&lt;char, int&gt; s_count_map;\n        for (char c:s) &#123;\n            s_count_map[c]++;\n        &#125;\n        &#x2F;&#x2F; 复制\n        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector(s_count_map.begin(), s_count_map.end());\n        &#x2F;&#x2F;从大到小排序\n        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123;return a.second &gt; b.second;&#125;);\n        string result;\n        for(auto cnt:s_count_vector) &#123;\n            int cnt_second &#x3D; cnt.second;\n            while (cnt_second--) &#123;\n                result+&#x3D;cnt.first;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>一些细节优化后的代码（成绩没变）</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string frequencySort(string s) &#123;\n        unordered_map&lt;char, int&gt; s_count_map;\n\n        &#x2F;&#x2F; 统计字符频率\n        for (char c : s) &#123;\n            s_count_map[c]++;\n        &#125;\n\n        &#x2F;&#x2F; 构建结果字符串\n        string result;\n        result.reserve(s.size()); &#x2F;&#x2F; 预分配足够的内存\n\n        &#x2F;&#x2F; 构建频率字符对，并按频率降序排序\n        vector&lt;pair&lt;char, int&gt;&gt; s_count_vector;\n        for (const auto&amp; kv : s_count_map) &#123;\n            s_count_vector.emplace_back(kv);\n        &#125;\n        sort(s_count_vector.begin(), s_count_vector.end(), [](pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)&#123; return a.second &gt; b.second; &#125;);\n\n        &#x2F;&#x2F; 构建结果字符串\n        for (const auto&amp; cnt : s_count_vector) &#123;\n            result.append(cnt.second, cnt.first); &#x2F;&#x2F; 使用append方法\n        &#125;\n\n        return result;\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[]}