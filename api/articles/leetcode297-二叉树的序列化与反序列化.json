{"title":"leetcode297.二叉树的序列化与反序列化","slug":"leetcode297-二叉树的序列化与反序列化","date":"2023-06-02T10:13:21.000Z","updated":"2023-06-02T10:15:07.416Z","comments":true,"path":"api/articles/leetcode297-二叉树的序列化与反序列化.json","excerpt":null,"covers":["http://cdn.leafii.top/img/serdeser.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n<p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href=\"https://support.leetcode.cn/hc/kb/article/1567641/\">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/serdeser.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,null,null,4,5]\n输出：[1,2,3,null,null,4,5]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2]\n输出：[1,2]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中结点数在范围 <code>[0, 104]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>层序遍历序列化</li>\n</ul>\n<p>解题思路：</p>\n<p>对于序列化操作，我们使用层序遍历将二叉树转化为字符串。使用队列辅助遍历，从根节点开始，依次处理每个节点，若节点为空则用字符串”null”表示，否则将节点值转化为字符串，并将其左右子节点加入队列。最后去掉最后一个多余的分隔符”,”并返回结果字符串。</p>\n<p>对于反序列化操作，我们使用stringstream来分割字符串，并依次处理每个节点。首先根据第一个值创建根节点，并加入队列。然后依次处理队列中的节点，每次从字符串中读取两个值，分别表示当前节点的左右子节点的值。若值为”null”，则表示该节点为空，否则创建相应的节点，并加入队列。重复上述过程直到队列为空。最后返回根节点即可。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Codec &#123;\npublic:\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    string serialize(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            return &quot;null&quot;;\n        &#125;\n        \n        &#x2F;&#x2F; 使用层序遍历将二叉树转化为字符串\n        string result;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        \n        while (!q.empty()) &#123;\n            TreeNode* node &#x3D; q.front();\n            q.pop();\n            \n            if (node !&#x3D; nullptr) &#123;\n                &#x2F;&#x2F; 非空节点，将节点值转化为字符串\n                result +&#x3D; to_string(node-&gt;val);\n                \n                &#x2F;&#x2F; 将左右子节点加入队列\n                q.push(node-&gt;left);\n                q.push(node-&gt;right);\n            &#125; else &#123;\n                &#x2F;&#x2F; 空节点，用&quot;null&quot;表示\n                result +&#x3D; &quot;null&quot;;\n            &#125;\n            \n            &#x2F;&#x2F; 每个节点值后面加上分隔符&quot;,&quot;\n            result +&#x3D; &quot;,&quot;;\n        &#125;\n        \n        &#x2F;&#x2F; 去掉最后一个多余的分隔符&quot;,&quot;\n        result.pop_back();\n        \n        return result;\n    &#125;\n\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) &#123;\n        if (data &#x3D;&#x3D; &quot;null&quot;) &#123;\n            return nullptr;\n        &#125;\n        \n        &#x2F;&#x2F; 使用stringstream分割字符串\n        stringstream ss(data);\n        string item;\n        queue&lt;TreeNode*&gt; q;\n        \n        &#x2F;&#x2F; 获取根节点值\n        getline(ss, item, &#39;,&#39;);\n        int rootVal &#x3D; stoi(item);\n        TreeNode* root &#x3D; new TreeNode(rootVal);\n        q.push(root);\n        \n        while (!q.empty()) &#123;\n            TreeNode* node &#x3D; q.front();\n            q.pop();\n            \n            &#x2F;&#x2F; 依次获取当前节点的左右子节点值\n            &#x2F;&#x2F; 并创建相应的节点\n            &#x2F;&#x2F; 左右子节点值为&quot;null&quot;时表示为空节点\n            getline(ss, item, &#39;,&#39;);\n            if (item !&#x3D; &quot;null&quot;) &#123;\n                int leftVal &#x3D; stoi(item);\n                TreeNode* leftNode &#x3D; new TreeNode(leftVal);\n                node-&gt;left &#x3D; leftNode;\n                q.push(leftNode);\n            &#125;\n            \n            getline(ss, item, &#39;,&#39;);\n            if (item !&#x3D; &quot;null&quot;) &#123;\n                int rightVal &#x3D; stoi(item);\n                TreeNode* rightNode &#x3D; new TreeNode(rightVal);\n                node-&gt;right &#x3D; rightNode;\n                q.push(rightNode);\n            &#125;\n        &#125;\n        \n        return root;\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n<p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href=\"https://support.leetcode.cn/hc/kb/article/1567641/\">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/serdeser.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,null,null,4,5]\n输出：[1,2,3,null,null,4,5]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p><strong>示例 4：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2]\n输出：[1,2]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中结点数在范围 <code>[0, 104]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>层序遍历序列化</li>\n</ul>\n<p>解题思路：</p>\n<p>对于序列化操作，我们使用层序遍历将二叉树转化为字符串。使用队列辅助遍历，从根节点开始，依次处理每个节点，若节点为空则用字符串”null”表示，否则将节点值转化为字符串，并将其左右子节点加入队列。最后去掉最后一个多余的分隔符”,”并返回结果字符串。</p>\n<p>对于反序列化操作，我们使用stringstream来分割字符串，并依次处理每个节点。首先根据第一个值创建根节点，并加入队列。然后依次处理队列中的节点，每次从字符串中读取两个值，分别表示当前节点的左右子节点的值。若值为”null”，则表示该节点为空，否则创建相应的节点，并加入队列。重复上述过程直到队列为空。最后返回根节点即可。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Codec &#123;\npublic:\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    string serialize(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; nullptr) &#123;\n            return &quot;null&quot;;\n        &#125;\n        \n        &#x2F;&#x2F; 使用层序遍历将二叉树转化为字符串\n        string result;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        \n        while (!q.empty()) &#123;\n            TreeNode* node &#x3D; q.front();\n            q.pop();\n            \n            if (node !&#x3D; nullptr) &#123;\n                &#x2F;&#x2F; 非空节点，将节点值转化为字符串\n                result +&#x3D; to_string(node-&gt;val);\n                \n                &#x2F;&#x2F; 将左右子节点加入队列\n                q.push(node-&gt;left);\n                q.push(node-&gt;right);\n            &#125; else &#123;\n                &#x2F;&#x2F; 空节点，用&quot;null&quot;表示\n                result +&#x3D; &quot;null&quot;;\n            &#125;\n            \n            &#x2F;&#x2F; 每个节点值后面加上分隔符&quot;,&quot;\n            result +&#x3D; &quot;,&quot;;\n        &#125;\n        \n        &#x2F;&#x2F; 去掉最后一个多余的分隔符&quot;,&quot;\n        result.pop_back();\n        \n        return result;\n    &#125;\n\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) &#123;\n        if (data &#x3D;&#x3D; &quot;null&quot;) &#123;\n            return nullptr;\n        &#125;\n        \n        &#x2F;&#x2F; 使用stringstream分割字符串\n        stringstream ss(data);\n        string item;\n        queue&lt;TreeNode*&gt; q;\n        \n        &#x2F;&#x2F; 获取根节点值\n        getline(ss, item, &#39;,&#39;);\n        int rootVal &#x3D; stoi(item);\n        TreeNode* root &#x3D; new TreeNode(rootVal);\n        q.push(root);\n        \n        while (!q.empty()) &#123;\n            TreeNode* node &#x3D; q.front();\n            q.pop();\n            \n            &#x2F;&#x2F; 依次获取当前节点的左右子节点值\n            &#x2F;&#x2F; 并创建相应的节点\n            &#x2F;&#x2F; 左右子节点值为&quot;null&quot;时表示为空节点\n            getline(ss, item, &#39;,&#39;);\n            if (item !&#x3D; &quot;null&quot;) &#123;\n                int leftVal &#x3D; stoi(item);\n                TreeNode* leftNode &#x3D; new TreeNode(leftVal);\n                node-&gt;left &#x3D; leftNode;\n                q.push(leftNode);\n            &#125;\n            \n            getline(ss, item, &#39;,&#39;);\n            if (item !&#x3D; &quot;null&quot;) &#123;\n                int rightVal &#x3D; stoi(item);\n                TreeNode* rightNode &#x3D; new TreeNode(rightVal);\n                node-&gt;right &#x3D; rightNode;\n                q.push(rightNode);\n            &#125;\n        &#125;\n        \n        return root;\n    &#125;\n&#125;;\n</code></pre>\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}