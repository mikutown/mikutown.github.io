{"title":"leetcode401.二进制手表","slug":"leetcode401-二进制手表","date":"2023-07-17T12:39:41.000Z","updated":"2023-07-17T12:54:24.942Z","comments":true,"path":"api/articles/leetcode401-二进制手表.json","excerpt":null,"covers":["http://cdn.leafii.top/img/binary_clock_samui_moon.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>二进制手表顶部有 4 个 LED 代表 <strong>小时（0-11）</strong>，底部的 6 个 LED 代表 <strong>分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p>\n<ul>\n<li>例如，下面的二进制手表读取 <code>&quot;3:25&quot;</code> 。</li>\n</ul>\n<p><img src=\"http://cdn.leafii.top/img/binary_clock_samui_moon.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<p><em>（图源：<a href=\"https://commons.m.wikimedia.org/wiki/File:Binary_clock_samui_moon.jpg\">WikiMedia - Binary clock samui moon.jpg</a> ，许可协议：<a href=\"https://creativecommons.org/licenses/by-sa/3.0/deed.en\">Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)</a> ）</em></p>\n<p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n<p>小时不会以零开头：</p>\n<ul>\n<li>例如，<code>&quot;01:00&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;1:00&quot;</code> 。</li>\n</ul>\n<p>分钟必须由两位数组成，可能会以零开头：</p>\n<ul>\n<li>例如，<code>&quot;10:2&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;10:02&quot;</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：turnedOn &#x3D; 1\n输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：turnedOn &#x3D; 9\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= turnedOn &lt;= 10</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>基础的解法：</li>\n</ul>\n<p>思路：</p>\n<ol>\n<li>创建一个函数 <code>countBits</code>，用于计算一个整数中二进制表示中 1 的个数。该函数可以使用位运算的技巧来进行计算，例如通过不断将数字右移并与 1 进行按位与操作来判断最低位是否为 1。</li>\n<li>在 <code>readBinaryWatch</code> 函数内部，创建一个空的结果数组 <code>result</code>。</li>\n<li>使用两个嵌套的循环，外层循环遍历小时的取值范围从 0 到 11，内层循环遍历分钟的取值范围从 0 到 59。</li>\n<li>对于每个小时和分钟的组合，计算二进制表示中 1 的个数。如果小时的二进制表示中 1 的个数加上分钟的二进制表示中 1 的个数等于给定的 <code>turnedOn</code>，则该组合满足要求。</li>\n<li>如果满足要求，将小时和分钟格式化为时间字符串，并将其添加到结果数组 <code>result</code> 中。</li>\n<li>循环结束后，返回结果数组 <code>result</code>。</li>\n</ol>\n<p>C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;string&gt; readBinaryWatch(int turnedOn) &#123;\n        vector&lt;string&gt; result;\n        for (int hour &#x3D; 0; hour &lt; 12; hour++) &#123;\n            int hourCount &#x3D; countBits(hour);\n            for (int min &#x3D; 0; min &lt;&#x3D; 59; min++) &#123;\n                int minCount &#x3D; countBits(min);\n                if (hourCount + minCount &#x3D;&#x3D; turnedOn) &#123; \n                    &#x2F;&#x2F; 如果时间符合要求\n                    result.push_back(makeTime(hour, min));\n                &#125;\n            &#125;\n        &#125;\n        return result;\n\n    &#125;\n    int countBits(int num) &#123; \n        &#x2F;&#x2F; 计算一个整数中二进制表示中 1 的个数\n        int count &#x3D; 0;\n        while (num !&#x3D; 0) &#123;\n            count +&#x3D; num &amp; 1;\n            num &gt;&gt;&#x3D; 1;\n        &#125;\n        return count;\n    &#125;\n    string makeTime(int hour, int min) &#123;\n        &#x2F;&#x2F; 用于将符合条件的时间组装成符合要求的字符串并返回\n        string answer  &#x3D; to_string(hour) + &quot;:&quot; + (min &lt; 10 ? &quot;0&quot; : &quot;&quot;) + to_string(min);\n        return answer;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>二进制手表顶部有 4 个 LED 代表 <strong>小时（0-11）</strong>，底部的 6 个 LED 代表 <strong>分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p>\n<ul>\n<li>例如，下面的二进制手表读取 <code>&quot;3:25&quot;</code> 。</li>\n</ul>\n<p><img src=\"http://cdn.leafii.top/img/binary_clock_samui_moon.jpg\" alt=\"img\"></p>\n<p><em>（图源：<a href=\"https://commons.m.wikimedia.org/wiki/File:Binary_clock_samui_moon.jpg\">WikiMedia - Binary clock samui moon.jpg</a> ，许可协议：<a href=\"https://creativecommons.org/licenses/by-sa/3.0/deed.en\">Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)</a> ）</em></p>\n<p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n<p>小时不会以零开头：</p>\n<ul>\n<li>例如，<code>&quot;01:00&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;1:00&quot;</code> 。</li>\n</ul>\n<p>分钟必须由两位数组成，可能会以零开头：</p>\n<ul>\n<li>例如，<code>&quot;10:2&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;10:02&quot;</code> 。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：turnedOn &#x3D; 1\n输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：turnedOn &#x3D; 9\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= turnedOn &lt;= 10</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>基础的解法：</li>\n</ul>\n<p>思路：</p>\n<ol>\n<li>创建一个函数 <code>countBits</code>，用于计算一个整数中二进制表示中 1 的个数。该函数可以使用位运算的技巧来进行计算，例如通过不断将数字右移并与 1 进行按位与操作来判断最低位是否为 1。</li>\n<li>在 <code>readBinaryWatch</code> 函数内部，创建一个空的结果数组 <code>result</code>。</li>\n<li>使用两个嵌套的循环，外层循环遍历小时的取值范围从 0 到 11，内层循环遍历分钟的取值范围从 0 到 59。</li>\n<li>对于每个小时和分钟的组合，计算二进制表示中 1 的个数。如果小时的二进制表示中 1 的个数加上分钟的二进制表示中 1 的个数等于给定的 <code>turnedOn</code>，则该组合满足要求。</li>\n<li>如果满足要求，将小时和分钟格式化为时间字符串，并将其添加到结果数组 <code>result</code> 中。</li>\n<li>循环结束后，返回结果数组 <code>result</code>。</li>\n</ol>\n<p>C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;string&gt; readBinaryWatch(int turnedOn) &#123;\n        vector&lt;string&gt; result;\n        for (int hour &#x3D; 0; hour &lt; 12; hour++) &#123;\n            int hourCount &#x3D; countBits(hour);\n            for (int min &#x3D; 0; min &lt;&#x3D; 59; min++) &#123;\n                int minCount &#x3D; countBits(min);\n                if (hourCount + minCount &#x3D;&#x3D; turnedOn) &#123; \n                    &#x2F;&#x2F; 如果时间符合要求\n                    result.push_back(makeTime(hour, min));\n                &#125;\n            &#125;\n        &#125;\n        return result;\n\n    &#125;\n    int countBits(int num) &#123; \n        &#x2F;&#x2F; 计算一个整数中二进制表示中 1 的个数\n        int count &#x3D; 0;\n        while (num !&#x3D; 0) &#123;\n            count +&#x3D; num &amp; 1;\n            num &gt;&gt;&#x3D; 1;\n        &#125;\n        return count;\n    &#125;\n    string makeTime(int hour, int min) &#123;\n        &#x2F;&#x2F; 用于将符合条件的时间组装成符合要求的字符串并返回\n        string answer  &#x3D; to_string(hour) + &quot;:&quot; + (min &lt; 10 ? &quot;0&quot; : &quot;&quot;) + to_string(min);\n        return answer;\n    &#125;\n&#125;;</code></pre>\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}