{"title":"leetcode:51.N皇后","slug":"leetcode-51-N皇后","date":"2023-01-17T08:52:01.000Z","updated":"2023-01-17T09:08:56.103Z","comments":true,"path":"api/articles/leetcode-51-N皇后.json","excerpt":"题目按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。","covers":["https://assets.leetcode.com/uploads/2020/11/13/queens.jpg","http://cdn.leafii.top/img/20210130182532303.jpg","https://img-blog.csdnimg.cn/20210130182532303.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>\n<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>\n<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 4\n输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1\n输出：[[&quot;Q&quot;]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>首先来看一下皇后们的约束条件：</p>\n<ol>\n<li>不能同行</li>\n<li>不能同列</li>\n<li>不能同斜线</li>\n</ol>\n<p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p>\n<p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p>\n<p><img src=\"http://cdn.leafii.top/img/20210130182532303.jpg\" alt=\"51.N皇后\" loading=\"lazy\"></p>\n<p>从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p>\n<p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p>\n<p>按照我总结的如下回溯模板，我们来依次分析：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">void backtracking(参数) &#123;\n    if (终止条件) &#123;\n        存放结果;\n        return;\n    &#125;\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;\n        处理节点;\n        backtracking(路径，选择列表); &#x2F;&#x2F; 递归\n        回溯，撤销处理结果\n    &#125;\n&#125;</code></pre>\n\n\n\n<ul>\n<li>递归函数参数</li>\n</ul>\n<p>我依然是定义全局变量二维数组result来记录最终结果。</p>\n<p>参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。</p>\n<p>代码如下：</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> result<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> row<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> chessboard<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></code></pre>\n\n\n\n<ul>\n<li>递归终止条件</li>\n</ul>\n<p>在如下树形结构中： <img src=\"https://img-blog.csdnimg.cn/20210130182532303.jpg\" alt=\"51.N皇后\" loading=\"lazy\"></p>\n<p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。</p>\n<p>代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">if (row &#x3D;&#x3D; n) &#123;\n    result.push_back(chessboard);\n    return;\n&#125;</code></pre>\n\n<ul>\n<li>单层搜索的逻辑</li>\n</ul>\n<p>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</p>\n<p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p>\n<p>代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">for (int col &#x3D; 0; col &lt; n; col++) &#123;\n    if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放\n        chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后\n        backtracking(n, row + 1, chessboard);\n        chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>验证棋盘是否合法</li>\n</ul>\n<p>按照如下标准去重：</p>\n<ol>\n<li>不能同行</li>\n<li>不能同列</li>\n<li>不能同斜线 （45度和135度角）</li>\n</ol>\n<p>代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;\n    &#x2F;&#x2F; 检查列\n    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝\n        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 检查 45度角是否有皇后\n    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;\n        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 检查 135度角是否有皇后\n    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;\n        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;</code></pre>\n\n<p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p>\n<p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p>\n<p>那么按照这个模板不难写出如下C++代码：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\nvector&lt;vector&lt;string&gt;&gt; result;\n&#x2F;&#x2F; n 为输入的棋盘大小\n&#x2F;&#x2F; row 是当前递归到棋盘的第几行了\nvoid backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;\n    if (row &#x3D;&#x3D; n) &#123;\n        result.push_back(chessboard);\n        return;\n    &#125;\n    for (int col &#x3D; 0; col &lt; n; col++) &#123;\n        if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放\n            chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后\n            backtracking(n, row + 1, chessboard);\n            chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后\n        &#125;\n    &#125;\n&#125;\nbool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;\n    &#x2F;&#x2F; 检查列\n    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝\n        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 检查 45度角是否有皇后\n    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;\n        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 检查 135度角是否有皇后\n    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;\n        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;\n        result.clear();\n        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#39;.&#39;));\n        backtracking(n, 0, chessboard);\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 4\n输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1\n输出：[[&quot;Q&quot;]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>首先来看一下皇后们的约束条件：</p>\n<ol>\n<li>不能同行</li>\n<li>不能同列</li>\n<li>不能同斜线</li>\n</ol>\n<p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p>\n<p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p>\n<p><img src=\"http://cdn.leafii.top/img/20210130182532303.jpg\" alt=\"51.N皇后\"></p>\n<p>从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p>\n<p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p>\n<p>按照我总结的如下回溯模板，我们来依次分析：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">void backtracking(参数) &#123;\n    if (终止条件) &#123;\n        存放结果;\n        return;\n    &#125;\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;\n        处理节点;\n        backtracking(路径，选择列表); &#x2F;&#x2F; 递归\n        回溯，撤销处理结果\n    &#125;\n&#125;</code></pre>\n\n\n\n<ul>\n<li>递归函数参数</li>\n</ul>\n<p>我依然是定义全局变量二维数组result来记录最终结果。</p>\n<p>参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。</p>\n<p>代码如下：</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> result<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> row<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> chessboard<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></code></pre>\n\n\n\n<ul>\n<li>递归终止条件</li>\n</ul>\n<p>在如下树形结构中： <img src=\"https://img-blog.csdnimg.cn/20210130182532303.jpg\" alt=\"51.N皇后\"></p>\n<p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。</p>\n<p>代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">if (row &#x3D;&#x3D; n) &#123;\n    result.push_back(chessboard);\n    return;\n&#125;</code></pre>\n\n<ul>\n<li>单层搜索的逻辑</li>\n</ul>\n<p>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</p>\n<p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p>\n<p>代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">for (int col &#x3D; 0; col &lt; n; col++) &#123;\n    if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放\n        chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后\n        backtracking(n, row + 1, chessboard);\n        chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>验证棋盘是否合法</li>\n</ul>\n<p>按照如下标准去重：</p>\n<ol>\n<li>不能同行</li>\n<li>不能同列</li>\n<li>不能同斜线 （45度和135度角）</li>\n</ol>\n<p>代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;\n    &#x2F;&#x2F; 检查列\n    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝\n        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 检查 45度角是否有皇后\n    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;\n        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 检查 135度角是否有皇后\n    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;\n        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;</code></pre>\n\n<p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p>\n<p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p>\n<p>那么按照这个模板不难写出如下C++代码：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\nvector&lt;vector&lt;string&gt;&gt; result;\n&#x2F;&#x2F; n 为输入的棋盘大小\n&#x2F;&#x2F; row 是当前递归到棋盘的第几行了\nvoid backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;\n    if (row &#x3D;&#x3D; n) &#123;\n        result.push_back(chessboard);\n        return;\n    &#125;\n    for (int col &#x3D; 0; col &lt; n; col++) &#123;\n        if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放\n            chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后\n            backtracking(n, row + 1, chessboard);\n            chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后\n        &#125;\n    &#125;\n&#125;\nbool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;\n    &#x2F;&#x2F; 检查列\n    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝\n        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 检查 45度角是否有皇后\n    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;\n        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 检查 135度角是否有皇后\n    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;\n        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;\n        result.clear();\n        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#39;.&#39;));\n        backtracking(n, 0, chessboard);\n        return result;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}