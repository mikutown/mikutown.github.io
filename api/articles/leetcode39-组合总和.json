{"title":"leetcode39.组合总和","slug":"leetcode39-组合总和","date":"2023-10-11T00:52:11.000Z","updated":"2023-10-11T01:59:16.987Z","comments":true,"path":"api/articles/leetcode39-组合总和.json","excerpt":"题目给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。","covers":["http://cdn.leafii.top/img/20201223170730367.png"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>\n<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>\n<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 &#x3D; 7 。\n仅有这两种组合。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: candidates &#x3D; [2,3,5], target &#x3D; 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: candidates &#x3D; [2], target &#x3D; 1\n输出: []</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>\n<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>\n<li><code>1 &lt;= target &lt;= 40</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>基础回溯法</li>\n</ul>\n<p>本题的搜索过程可以抽象成如下树形结构：</p>\n<p><img src=\"http://cdn.leafii.top/img/20201223170730367.png\" alt=\"39.组合总和\" loading=\"lazy\"></p>\n<p>使用回溯三步曲：</p>\n<ol>\n<li>递归函数的参数</li>\n</ol>\n<p>定义一个二维数组results用于存储最终的组合，定义一个一维数组用于存储单次组合。这两个变量为全局变量，然后定义一个递归函数traceback,它的参数为题目自带的候选数组canditate，target，以及path元素的和sum，以及开始遍历的索引startIndex</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> result<span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> path<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> candidates<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> sum<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> startIndex<span class=\"token punctuation\">)</span></code></pre>\n\n<ol start=\"2\">\n<li>递归终止条件</li>\n</ol>\n<p>当<code>sum&gt;target</code>时，没有继续遍历下去的必要，当<code>sum==target</code>时将当前的path放进results中，并退出当前递归函数。</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<ol start=\"3\">\n<li>单层搜索逻辑</li>\n</ol>\n<p>从startIndex开始遍历candidates数组，搜索组合</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> startIndex<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> candidates<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    sum <span class=\"token operator\">+=</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">,</span> sum<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 关键点:不用i+1了，表示可以重复读取当前的数</span>\n    sum <span class=\"token operator\">-=</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 回溯</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">pop_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 回溯</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>整个代码：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; results;\n    vector&lt;int&gt; path;\n    void tracebacking(vector&lt;int&gt; candidates, int target, int sumValue,int startIndex) &#123;\n        &#x2F;&#x2F;参数分别为候选数组，目标值，path中元素的和sumValue，最终结果results，单个组合path，开始遍历的索引startIndex\n        if (sumValue &gt; target) return; &#x2F;&#x2F; 如果sumValue比target大，直接剪枝\n        &#x2F;&#x2F; 终止条件\n        if (sumValue &#x3D;&#x3D; target) &#123;\n            &#x2F;&#x2F; 符合一个组合的条件\n            results.push_back(path);\n            return;\n        &#125;\n        for (int i &#x3D; startIndex; i &lt; candidates.size();i++) &#123;\n            path.push_back(candidates[i]);\n            sumValue +&#x3D; candidates[i];\n            tracebacking(candidates, target, sumValue, i);\n            &#x2F;&#x2F; 回溯\n            path.pop_back();\n            sumValue -&#x3D; candidates[i];\n        &#125;\n    &#125;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        results.clear();\n        path.clear();\n        tracebacking(candidates, target, 0, 0);\n        return results;   \n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>剪枝优化</li>\n</ul>\n<p>对数组进行排序，在for循环中的判断中增加一个判断，可以进行有效的剪枝。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; results;\n    vector&lt;int&gt; path;\n    void tracebacking(vector&lt;int&gt; candidates, int target, int sumValue,int startIndex) &#123;\n        &#x2F;&#x2F;参数分别为候选数组，目标值，path中元素的和sumValue，最终结果results，单个组合path，开始遍历的索引startIndex\n        if (sumValue &gt; target) return; &#x2F;&#x2F; 如果sumValue比target大，直接剪枝\n        &#x2F;&#x2F; 终止条件\n        if (sumValue &#x3D;&#x3D; target) &#123;\n            &#x2F;&#x2F; 符合一个组合的条件\n            results.push_back(path);\n            return;\n        &#125;\n        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sumValue + candidates[i] &lt;&#x3D; target;i++) &#123;\n            &#x2F;&#x2F; for循环中的判断条件做了剪枝优化\n            path.push_back(candidates[i]);\n            sumValue +&#x3D; candidates[i];\n            tracebacking(candidates, target, sumValue, i);\n            &#x2F;&#x2F; 回溯\n            path.pop_back();\n            sumValue -&#x3D; candidates[i];\n        &#125;\n    &#125;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        results.clear();\n        path.clear();\n        sort(candidates.begin(), candidates.end()); &#x2F;&#x2F; 排序，减少不必要的计算\n        tracebacking(candidates, target, 0, 0);\n        return results;   \n    &#125;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p>代码随想录：<a href=\"https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html\">https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html</a></p>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 &#x3D; 7 。\n仅有这两种组合。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: candidates &#x3D; [2,3,5], target &#x3D; 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: candidates &#x3D; [2], target &#x3D; 1\n输出: []</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>\n<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>\n<li><code>1 &lt;= target &lt;= 40</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>基础回溯法</li>\n</ul>\n<p>本题的搜索过程可以抽象成如下树形结构：</p>\n<p><img src=\"http://cdn.leafii.top/img/20201223170730367.png\" alt=\"39.组合总和\"></p>\n<p>使用回溯三步曲：</p>\n<ol>\n<li>递归函数的参数</li>\n</ol>\n<p>定义一个二维数组results用于存储最终的组合，定义一个一维数组用于存储单次组合。这两个变量为全局变量，然后定义一个递归函数traceback,它的参数为题目自带的候选数组canditate，target，以及path元素的和sum，以及开始遍历的索引startIndex</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> result<span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> path<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> candidates<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> sum<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> startIndex<span class=\"token punctuation\">)</span></code></pre>\n\n<ol start=\"2\">\n<li>递归终止条件</li>\n</ol>\n<p>当<code>sum&gt;target</code>时，没有继续遍历下去的必要，当<code>sum==target</code>时将当前的path放进results中，并退出当前递归函数。</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sum <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<ol start=\"3\">\n<li>单层搜索逻辑</li>\n</ol>\n<p>从startIndex开始遍历candidates数组，搜索组合</p>\n<pre class=\"language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> startIndex<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> candidates<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    sum <span class=\"token operator\">+=</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">backtracking</span><span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">,</span> sum<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 关键点:不用i+1了，表示可以重复读取当前的数</span>\n    sum <span class=\"token operator\">-=</span> candidates<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 回溯</span>\n    path<span class=\"token punctuation\">.</span><span class=\"token function\">pop_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 回溯</span>\n<span class=\"token punctuation\">&#125;</span></code></pre>\n\n<p>整个代码：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; results;\n    vector&lt;int&gt; path;\n    void tracebacking(vector&lt;int&gt; candidates, int target, int sumValue,int startIndex) &#123;\n        &#x2F;&#x2F;参数分别为候选数组，目标值，path中元素的和sumValue，最终结果results，单个组合path，开始遍历的索引startIndex\n        if (sumValue &gt; target) return; &#x2F;&#x2F; 如果sumValue比target大，直接剪枝\n        &#x2F;&#x2F; 终止条件\n        if (sumValue &#x3D;&#x3D; target) &#123;\n            &#x2F;&#x2F; 符合一个组合的条件\n            results.push_back(path);\n            return;\n        &#125;\n        for (int i &#x3D; startIndex; i &lt; candidates.size();i++) &#123;\n            path.push_back(candidates[i]);\n            sumValue +&#x3D; candidates[i];\n            tracebacking(candidates, target, sumValue, i);\n            &#x2F;&#x2F; 回溯\n            path.pop_back();\n            sumValue -&#x3D; candidates[i];\n        &#125;\n    &#125;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        results.clear();\n        path.clear();\n        tracebacking(candidates, target, 0, 0);\n        return results;   \n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>剪枝优化</li>\n</ul>\n<p>对数组进行排序，在for循环中的判断中增加一个判断，可以进行有效的剪枝。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; results;\n    vector&lt;int&gt; path;\n    void tracebacking(vector&lt;int&gt; candidates, int target, int sumValue,int startIndex) &#123;\n        &#x2F;&#x2F;参数分别为候选数组，目标值，path中元素的和sumValue，最终结果results，单个组合path，开始遍历的索引startIndex\n        if (sumValue &gt; target) return; &#x2F;&#x2F; 如果sumValue比target大，直接剪枝\n        &#x2F;&#x2F; 终止条件\n        if (sumValue &#x3D;&#x3D; target) &#123;\n            &#x2F;&#x2F; 符合一个组合的条件\n            results.push_back(path);\n            return;\n        &#125;\n        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sumValue + candidates[i] &lt;&#x3D; target;i++) &#123;\n            &#x2F;&#x2F; for循环中的判断条件做了剪枝优化\n            path.push_back(candidates[i]);\n            sumValue +&#x3D; candidates[i];\n            tracebacking(candidates, target, sumValue, i);\n            &#x2F;&#x2F; 回溯\n            path.pop_back();\n            sumValue -&#x3D; candidates[i];\n        &#125;\n    &#125;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        results.clear();\n        path.clear();\n        sort(candidates.begin(), candidates.end()); &#x2F;&#x2F; 排序，减少不必要的计算\n        tracebacking(candidates, target, 0, 0);\n        return results;   \n    &#125;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p>代码随想录：<a href=\"https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html\">https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html</a></p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}