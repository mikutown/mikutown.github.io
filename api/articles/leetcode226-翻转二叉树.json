{"title":"leetcode226.翻转二叉树","slug":"leetcode226-翻转二叉树","date":"2023-06-28T02:09:48.000Z","updated":"2023-06-28T02:15:06.489Z","comments":true,"path":"api/articles/leetcode226-翻转二叉树.json","excerpt":"题目给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。","covers":["http://cdn.leafii.top/img/invert1-tree.jpg","http://cdn.leafii.top/img/invert2-tree.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/invert1-tree.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/invert2-tree.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [2,1,3]\n输出：[2,3,1]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>深度优先遍历</li>\n</ul>\n<p>使用dfs函数辅助遍历过程。代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* invertTree(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; NULL || (root-&gt;left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;right &#x3D;&#x3D; NULL)) &#123; \n            &#x2F;&#x2F; 如果root为空或者root左右子树都为空，则直接返回root\n            return root;\n        &#125;\n        dfs(root); &#x2F;&#x2F; 否则，则对root进行深度优先遍历\n        return root;\n    &#125;\n    void dfs(TreeNode* node) &#123;\n        if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123;\n            return; &#x2F;&#x2F; 如果被遍历的结点左右子树都为空，则直接跳出\n        &#125;\n        TreeNode* rightCopy &#x3D; node-&gt;right; &#x2F;&#x2F; 新建一个节点rightCopy用于复制当前被遍历结点的右子树\n        node-&gt;right &#x3D; node-&gt;left; &#x2F;&#x2F; 将节点的左子树直接赋值给右子树\n        node-&gt;left &#x3D; rightCopy; &#x2F;&#x2F; 将rightCopy赋值给左子树，完成当前结点的交换\n        if (node-&gt;left !&#x3D; NULL) &#123; &#x2F;&#x2F; 如果当前结点的左子树不为空，则对该子树进行遍历\n            dfs(node-&gt;left);\n        &#125;\n        if (node-&gt;right !&#x3D; NULL) &#123; &#x2F;&#x2F; 如果当前结点的右子树不为空，则对该子树进行遍历\n            dfs(node-&gt;right);\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/invert1-tree.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/invert2-tree.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [2,1,3]\n输出：[2,3,1]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>深度优先遍历</li>\n</ul>\n<p>使用dfs函数辅助遍历过程。代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* invertTree(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; NULL || (root-&gt;left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;right &#x3D;&#x3D; NULL)) &#123; \n            &#x2F;&#x2F; 如果root为空或者root左右子树都为空，则直接返回root\n            return root;\n        &#125;\n        dfs(root); &#x2F;&#x2F; 否则，则对root进行深度优先遍历\n        return root;\n    &#125;\n    void dfs(TreeNode* node) &#123;\n        if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123;\n            return; &#x2F;&#x2F; 如果被遍历的结点左右子树都为空，则直接跳出\n        &#125;\n        TreeNode* rightCopy &#x3D; node-&gt;right; &#x2F;&#x2F; 新建一个节点rightCopy用于复制当前被遍历结点的右子树\n        node-&gt;right &#x3D; node-&gt;left; &#x2F;&#x2F; 将节点的左子树直接赋值给右子树\n        node-&gt;left &#x3D; rightCopy; &#x2F;&#x2F; 将rightCopy赋值给左子树，完成当前结点的交换\n        if (node-&gt;left !&#x3D; NULL) &#123; &#x2F;&#x2F; 如果当前结点的左子树不为空，则对该子树进行遍历\n            dfs(node-&gt;left);\n        &#125;\n        if (node-&gt;right !&#x3D; NULL) &#123; &#x2F;&#x2F; 如果当前结点的右子树不为空，则对该子树进行遍历\n            dfs(node-&gt;right);\n        &#125;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}