{"title":"leetcode115.不同的子序列","slug":"leetcode115-不同的子序列","date":"2023-08-04T08:53:00.000Z","updated":"2023-08-04T08:54:47.139Z","comments":true,"path":"api/articles/leetcode115-不同的子序列.json","excerpt":"题目给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。题目数据保证答案符合 32 位带符号整数范围。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数。</p>\n<p>题目数据保证答案符合 32 位带符号整数范围。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;rabbbit&quot;, t &#x3D; &quot;rabbit&quot;\n输出：3\n解释：\n如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。\nrabbbit\nrabbbit\nrabbbit</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;babgbag&quot;, t &#x3D; &quot;bag&quot;\n输出：5\n解释：\n如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 \nbabgbag\nbabgbag\nbabgbag\nbabgbag\nbabgbag</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>\n<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>解题思路：</p>\n<p>题目要求计算字符串 s 变换为字符串 t 的不同子序列数量。这类问题可以使用动态规划来解决。</p>\n<p>我们使用 dp<code>[i][j]</code> 表示字符串 s 的前 i 个字符和字符串 t 的前 j 个字符之间的不同子序列数量。初始时，任何字符串变换为空字符串的方式都只有一种，即不选取任何字符，因此我们将 dp<code>[i][0] </code>设置为 1。</p>\n<p>然后，我们遍历字符串 s 和字符串 t 的所有字符组合，逐步计算 dp 数组。当 s[i-1] 和 t[j-1] 相等时，我们可以选择当前字符匹配或者不匹配。如果匹配，那么当前字符可以贡献 <code>dp[i-1][j-1] </code>个子序列；如果不匹配，那么当前字符不会贡献新的子序列，继续使用<code> dp[i-1][j]</code>。如果 s[i-1] 和 t[j-1] 不相等，那么当前字符不能匹配，只能选择不匹配，即使用<code> dp[i-1][j]</code>。</p>\n<p>最终，dp<code>[m][n]</code> 就是字符串 s 变换为字符串 t 的不同子序列数量，其中 m 是字符串 s 的长度，n 是字符串 t 的长度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int numDistinct(string s, string t) &#123;\n        int m &#x3D; s.length();\n        int n &#x3D; t.length();\n        \n        &#x2F;&#x2F; dp[i][j] 表示 s 的前 i 个字符和 t 的前 j 个字符之间的不同子序列数量\n        vector&lt;vector&lt;unsigned int&gt;&gt; dp(m + 1, vector&lt;unsigned int&gt;(n + 1, 0));\n        \n        &#x2F;&#x2F; 初始化：任何字符串变换为空字符串的方式都只有一种，即不选取任何字符\n        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;\n            dp[i][0] &#x3D; 1;\n        &#125;\n        \n        &#x2F;&#x2F; 状态转移\n        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;\n            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;\n                &#x2F;&#x2F; 如果 s[i-1] 和 t[j-1] 相等，则可以选择当前字符匹配或者不匹配\n                if (s[i - 1] &#x3D;&#x3D; t[j - 1]) &#123;\n                    dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j];\n                &#125; else &#123;\n                    &#x2F;&#x2F; 如果不相等，则只能选择不匹配\n                    dp[i][j] &#x3D; dp[i - 1][j];\n                &#125;\n            &#125;\n        &#125;\n        \n        return dp[m][n];\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;rabbbit&quot;, t &#x3D; &quot;rabbit&quot;\n输出：3\n解释：\n如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。\nrabbbit\nrabbbit\nrabbbit</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;babgbag&quot;, t &#x3D; &quot;bag&quot;\n输出：5\n解释：\n如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 \nbabgbag\nbabgbag\nbabgbag\nbabgbag\nbabgbag</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>\n<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>动态规划</li>\n</ul>\n<p>解题思路：</p>\n<p>题目要求计算字符串 s 变换为字符串 t 的不同子序列数量。这类问题可以使用动态规划来解决。</p>\n<p>我们使用 dp<code>[i][j]</code> 表示字符串 s 的前 i 个字符和字符串 t 的前 j 个字符之间的不同子序列数量。初始时，任何字符串变换为空字符串的方式都只有一种，即不选取任何字符，因此我们将 dp<code>[i][0] </code>设置为 1。</p>\n<p>然后，我们遍历字符串 s 和字符串 t 的所有字符组合，逐步计算 dp 数组。当 s[i-1] 和 t[j-1] 相等时，我们可以选择当前字符匹配或者不匹配。如果匹配，那么当前字符可以贡献 <code>dp[i-1][j-1] </code>个子序列；如果不匹配，那么当前字符不会贡献新的子序列，继续使用<code> dp[i-1][j]</code>。如果 s[i-1] 和 t[j-1] 不相等，那么当前字符不能匹配，只能选择不匹配，即使用<code> dp[i-1][j]</code>。</p>\n<p>最终，dp<code>[m][n]</code> 就是字符串 s 变换为字符串 t 的不同子序列数量，其中 m 是字符串 s 的长度，n 是字符串 t 的长度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int numDistinct(string s, string t) &#123;\n        int m &#x3D; s.length();\n        int n &#x3D; t.length();\n        \n        &#x2F;&#x2F; dp[i][j] 表示 s 的前 i 个字符和 t 的前 j 个字符之间的不同子序列数量\n        vector&lt;vector&lt;unsigned int&gt;&gt; dp(m + 1, vector&lt;unsigned int&gt;(n + 1, 0));\n        \n        &#x2F;&#x2F; 初始化：任何字符串变换为空字符串的方式都只有一种，即不选取任何字符\n        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;\n            dp[i][0] &#x3D; 1;\n        &#125;\n        \n        &#x2F;&#x2F; 状态转移\n        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;\n            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;\n                &#x2F;&#x2F; 如果 s[i-1] 和 t[j-1] 相等，则可以选择当前字符匹配或者不匹配\n                if (s[i - 1] &#x3D;&#x3D; t[j - 1]) &#123;\n                    dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j];\n                &#125; else &#123;\n                    &#x2F;&#x2F; 如果不相等，则只能选择不匹配\n                    dp[i][j] &#x3D; dp[i - 1][j];\n                &#125;\n            &#125;\n        &#125;\n        \n        return dp[m][n];\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}