{"title":"leetcode509.斐波那契数","slug":"leetcode509-斐波那契数","date":"2023-04-09T06:41:47.000Z","updated":"2023-04-09T07:17:20.505Z","comments":true,"path":"api/articles/leetcode509-斐波那契数.json","excerpt":"题目斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：F(0) &#x3D; 0，F(1) &#x3D; 1F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1给定 n ，请计算 F(n) 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>\n<pre class=\"language-none\"><code class=\"language-none\">F(0) &#x3D; 0，F(1) &#x3D; 1\nF(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</code></pre>\n\n<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2\n输出：1\n解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3\n输出：2\n解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 4\n输出：3\n解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= n &lt;= 30</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>递归求解</li>\n</ol>\n<p>在递归函数里初始化<code>f(0) = 0,f(1) = 1</code>,对于大于1的函数值，递归调用<code>f(n - 2) + f(n - 1)</code>;</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int fib(int n) &#123;\n        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; f(0)的初始化\n        if (n &#x3D;&#x3D; 1) return 1; &#x2F;&#x2F; f(1)的初始化\n        return fib(n - 1) + fib(n - 2); &#x2F;&#x2F; 递归调用\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>迭代求解</li>\n</ol>\n<p>C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int fib(int n) &#123;\n        if (n &lt;&#x3D; 1) return n; &#x2F;&#x2F; 如果n为0或者1 直接返回它本身\n        int pre0 &#x3D; 0, pre1 &#x3D; 1; &#x2F;&#x2F; 初始化pre0和pre1\n        int answer &#x3D; 0; &#x2F;&#x2F; 初始化答案\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n            answer &#x3D; pre0 + pre1; &#x2F;&#x2F; 答案为f(n-2) + f(n-1)\n            pre0 &#x3D; pre1; &#x2F;&#x2F; pre0的值更新\n            pre1 &#x3D; answer; &#x2F;&#x2F; pre1的值更新\n        &#125;\n        return answer; &#x2F;&#x2F; 计算完毕返回答案\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li>矩阵快速幂求解</li>\n</ol>\n<p>核心思路是将斐波那契数列的递推式转化为矩阵的乘法，然后使用矩阵快速幂的方法快速计算出矩阵的幂次，进而得到第 n 个斐波那契数。</p>\n<p>首先，我们知道斐波那契数列的递推式为：</p>\n<p>$F(n) &#x3D; F(n-1) + F(n-2)，其中 F(0) &#x3D; 0，F(1) &#x3D; 1。$</p>\n<p>我们可以将这个递推式转化为矩阵的乘法形式：</p>\n<p>$ \\begin{bmatrix} F(n) \\ F(n-1) \\end{bmatrix} &#x3D; \\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\end{bmatrix} \\begin{bmatrix} F(n-1) \\ F(n-2) \\end{bmatrix} $</p>\n<p>根据这个式子，我们可以构造出初始矩阵 base 和单位矩阵 res，然后使用矩阵快速幂的方法快速计算出 base 的 n 次幂，最终得到 res。</p>\n<p>最后，我们可以直接返回<code> res[0][1]</code>，这个值就是第 n 个斐波那契数。</p>\n<p>总的来说，这种解法虽然比较高级，但可以在 O(log n) 的时间复杂度内计算出第 n 个斐波那契数，而且不需要使用数组或者递归来存储之前的结果，空间复杂度为 O(1)。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int fib(int n) &#123;\n        &#x2F;&#x2F; 如果n小于等于1，直接返回n\n        if (n &lt;&#x3D; 1) &#123;\n            return n;\n        &#125;\n        &#x2F;&#x2F; 定义初始矩阵\n        vector&lt;vector&lt;int&gt;&gt; base&#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;\n        &#x2F;&#x2F; 定义单位矩阵\n        vector&lt;vector&lt;int&gt;&gt; res&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;\n        &#x2F;&#x2F; 矩阵快速幂\n        while (n) &#123;\n            if (n &amp; 1) &#123;\n                res &#x3D; multiply(res, base);\n            &#125;\n            base &#x3D; multiply(base, base);\n            n &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 将变量 n 的二进制表示向右移动一位，并将移位后的结果赋值给 n。相当于n&#x2F;&#x3D;2\n        &#125;\n        &#x2F;&#x2F; 返回结果\n        return res[0][1];\n    &#125;\n\n    &#x2F;&#x2F; 定义矩阵乘法函数\n    vector&lt;vector&lt;int&gt;&gt; multiply(const vector&lt;vector&lt;int&gt;&gt;&amp; A, const vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123;\n        int m &#x3D; A.size(), n &#x3D; A[0].size(), l &#x3D; B[0].size();\n        vector&lt;vector&lt;int&gt;&gt; C(m, vector&lt;int&gt;(l));\n        for (int i &#x3D; 0; i &lt; m; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; l; ++j) &#123;\n                for (int k &#x3D; 0; k &lt; n; ++k) &#123;\n                    C[i][j] +&#x3D; A[i][k] * B[k][j];\n                &#125;\n            &#125;\n        &#125;\n        return C;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 2\n输出：1\n解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3\n输出：2\n解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 4\n输出：3\n解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= n &lt;= 30</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>递归求解</li>\n</ol>\n<p>在递归函数里初始化<code>f(0) = 0,f(1) = 1</code>,对于大于1的函数值，递归调用<code>f(n - 2) + f(n - 1)</code>;</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int fib(int n) &#123;\n        if (n &#x3D;&#x3D; 0) return 0; &#x2F;&#x2F; f(0)的初始化\n        if (n &#x3D;&#x3D; 1) return 1; &#x2F;&#x2F; f(1)的初始化\n        return fib(n - 1) + fib(n - 2); &#x2F;&#x2F; 递归调用\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>迭代求解</li>\n</ol>\n<p>C++代码实现如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int fib(int n) &#123;\n        if (n &lt;&#x3D; 1) return n; &#x2F;&#x2F; 如果n为0或者1 直接返回它本身\n        int pre0 &#x3D; 0, pre1 &#x3D; 1; &#x2F;&#x2F; 初始化pre0和pre1\n        int answer &#x3D; 0; &#x2F;&#x2F; 初始化答案\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n            answer &#x3D; pre0 + pre1; &#x2F;&#x2F; 答案为f(n-2) + f(n-1)\n            pre0 &#x3D; pre1; &#x2F;&#x2F; pre0的值更新\n            pre1 &#x3D; answer; &#x2F;&#x2F; pre1的值更新\n        &#125;\n        return answer; &#x2F;&#x2F; 计算完毕返回答案\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li>矩阵快速幂求解</li>\n</ol>\n<p>核心思路是将斐波那契数列的递推式转化为矩阵的乘法，然后使用矩阵快速幂的方法快速计算出矩阵的幂次，进而得到第 n 个斐波那契数。</p>\n<p>首先，我们知道斐波那契数列的递推式为：</p>\n<p>$F(n) &#x3D; F(n-1) + F(n-2)，其中 F(0) &#x3D; 0，F(1) &#x3D; 1。$</p>\n<p>我们可以将这个递推式转化为矩阵的乘法形式：</p>\n<p>$ \\begin{bmatrix} F(n) \\ F(n-1) \\end{bmatrix} &#x3D; \\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\end{bmatrix} \\begin{bmatrix} F(n-1) \\ F(n-2) \\end{bmatrix} $</p>\n<p>根据这个式子，我们可以构造出初始矩阵 base 和单位矩阵 res，然后使用矩阵快速幂的方法快速计算出 base 的 n 次幂，最终得到 res。</p>\n<p>最后，我们可以直接返回<code> res[0][1]</code>，这个值就是第 n 个斐波那契数。</p>\n<p>总的来说，这种解法虽然比较高级，但可以在 O(log n) 的时间复杂度内计算出第 n 个斐波那契数，而且不需要使用数组或者递归来存储之前的结果，空间复杂度为 O(1)。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int fib(int n) &#123;\n        &#x2F;&#x2F; 如果n小于等于1，直接返回n\n        if (n &lt;&#x3D; 1) &#123;\n            return n;\n        &#125;\n        &#x2F;&#x2F; 定义初始矩阵\n        vector&lt;vector&lt;int&gt;&gt; base&#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;\n        &#x2F;&#x2F; 定义单位矩阵\n        vector&lt;vector&lt;int&gt;&gt; res&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;\n        &#x2F;&#x2F; 矩阵快速幂\n        while (n) &#123;\n            if (n &amp; 1) &#123;\n                res &#x3D; multiply(res, base);\n            &#125;\n            base &#x3D; multiply(base, base);\n            n &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 将变量 n 的二进制表示向右移动一位，并将移位后的结果赋值给 n。相当于n&#x2F;&#x3D;2\n        &#125;\n        &#x2F;&#x2F; 返回结果\n        return res[0][1];\n    &#125;\n\n    &#x2F;&#x2F; 定义矩阵乘法函数\n    vector&lt;vector&lt;int&gt;&gt; multiply(const vector&lt;vector&lt;int&gt;&gt;&amp; A, const vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123;\n        int m &#x3D; A.size(), n &#x3D; A[0].size(), l &#x3D; B[0].size();\n        vector&lt;vector&lt;int&gt;&gt; C(m, vector&lt;int&gt;(l));\n        for (int i &#x3D; 0; i &lt; m; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; l; ++j) &#123;\n                for (int k &#x3D; 0; k &lt; n; ++k) &#123;\n                    C[i][j] +&#x3D; A[i][k] * B[k][j];\n                &#125;\n            &#125;\n        &#125;\n        return C;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}