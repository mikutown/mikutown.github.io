{"title":"leetcode101.对称二叉树","slug":"leetcode101-对称二叉树","date":"2023-02-14T07:18:47.000Z","updated":"2023-02-14T07:39:03.891Z","comments":true,"path":"api/articles/leetcode101-对称二叉树.json","excerpt":"题目给你一个二叉树的根节点 root ， 检查它是否轴对称。","covers":["http://cdn.leafii.top/img/symtree1.jpg","http://cdn.leafii.top/img/symtree2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/symtree1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,2,3,4,4,3]\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/symtree2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,2,null,3,null,3]\n输出：false</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>初见思路（<strong>无法通过</strong>）：</li>\n</ol>\n<p>本来是想直接通过中序遍历获得一个数组，然后从数组的两端向中间进行判断，最后样例通过数为192&#x2F;199，原因是如果输入为<code>[1,2,2,2,null,2]</code>时，中序遍历得到的数组是对称的，但是实际上这个二叉树不是对称的。因此该思路被我放弃了。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\n &#x2F;&#x2F; 3241423 中序遍历 先左再中间最后右子树\nclass Solution &#123;\npublic:\n    void Middle_order_traversal(TreeNode* rootNode, vector&lt;int&gt;&amp; rst) &#123;\n        if (rootNode) &#123;\n            Middle_order_traversal(rootNode -&gt; left, rst);\n            rst.push_back(rootNode -&gt; val);\n            Middle_order_traversal(rootNode -&gt; right, rst);\n        &#125;\n        else &#123;\n            rst.push_back(-1);\n        &#125;\n    &#125;\n    bool isSymmetric(TreeNode* root) &#123;\n        vector&lt;int&gt; rst;\n        Middle_order_traversal(root, rst);\n        if (rst.size()%2&#x3D;&#x3D;0) &#123;\n            return false;\n        &#125;\n        int left &#x3D; 0, right &#x3D; rst.size() - 1;\n        while(left &lt; right) &#123;\n            if (rst[left] !&#x3D; rst[right]) &#123;\n                return false;\n            &#125;\n            left++;\n            right--;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ol start=\"2\">\n<li>使用递归：</li>\n</ol>\n<p>在对root进行判断之后，就使用一个辅助函数对root的左子树和右子树进行判断，判断完成后分别对左子树的左子树和右子树的右子树；左子树的右子树以及右子树的左子树进行判断，两个判断结果进行与运算，递归得到最终结果。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isSymmetric(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若根节点为空，则返回true\n\n        return isSymmetricHelper(root-&gt;left, root-&gt;right);\n    &#125;\n    bool isSymmetricHelper(TreeNode* left, TreeNode* right) &#123;\n        if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若左右都为空，则返回true\n      \t&#x2F;&#x2F; if ((left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) || (left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL)) return false; &#x2F;&#x2F; 左右子树一个空一个不空，返回false (下面这行更简练)\n        if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;若左右节点有一个不为空，则返回false\n        if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F;若左右节点的值不相等，则返回false\n\n        &#x2F;&#x2F;递归检查左右子树是否对称\n        return isSymmetricHelper(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetricHelper(left-&gt;right, right-&gt;left);\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li>使用迭代</li>\n</ol>\n<p>该解决方案使用队列来存储树的节点，首先将左子树和右子树的根节点加入队列中。然后在循环中，每次取出队列的头两个节点，并比较它们是否对称，如果不对称则返回false。如果对称，则将左节点的左子树节点和右节点的右子树节点加入队列，再将左节点的右子树节点和右节点的左子树节点加入队列。如果队列为空，则说明树是对称的，返回true。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isSymmetric(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;节点为空，返回true\n\n        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 定义一个队列存储节点\n        q.push(root-&gt;left);\n        q.push(root-&gt;right);\n\n        while (!q.empty()) &#123;\n            TreeNode* left &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为左节点\n            TreeNode* right &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为右节点\n            if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) continue; &#x2F;&#x2F;如果左右节点都为空，则继续迭代\n            if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;左右节点只有一个不为空，直接返回false\n            if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F; 左右节点值不等，直接返回false\n\n            q.push(left-&gt;left);\n            q.push(right-&gt;right);\n            q.push(left-&gt;right);\n            q.push(right-&gt;left); &#x2F;&#x2F; 注意push的顺序！！！\n        &#125; \n        return true; &#x2F;&#x2F;若队列为空，则说明该二叉树是对称的。\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/symtree1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,2,3,4,4,3]\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/symtree2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,2,null,3,null,3]\n输出：false</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>初见思路（<strong>无法通过</strong>）：</li>\n</ol>\n<p>本来是想直接通过中序遍历获得一个数组，然后从数组的两端向中间进行判断，最后样例通过数为192&#x2F;199，原因是如果输入为<code>[1,2,2,2,null,2]</code>时，中序遍历得到的数组是对称的，但是实际上这个二叉树不是对称的。因此该思路被我放弃了。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\n &#x2F;&#x2F; 3241423 中序遍历 先左再中间最后右子树\nclass Solution &#123;\npublic:\n    void Middle_order_traversal(TreeNode* rootNode, vector&lt;int&gt;&amp; rst) &#123;\n        if (rootNode) &#123;\n            Middle_order_traversal(rootNode -&gt; left, rst);\n            rst.push_back(rootNode -&gt; val);\n            Middle_order_traversal(rootNode -&gt; right, rst);\n        &#125;\n        else &#123;\n            rst.push_back(-1);\n        &#125;\n    &#125;\n    bool isSymmetric(TreeNode* root) &#123;\n        vector&lt;int&gt; rst;\n        Middle_order_traversal(root, rst);\n        if (rst.size()%2&#x3D;&#x3D;0) &#123;\n            return false;\n        &#125;\n        int left &#x3D; 0, right &#x3D; rst.size() - 1;\n        while(left &lt; right) &#123;\n            if (rst[left] !&#x3D; rst[right]) &#123;\n                return false;\n            &#125;\n            left++;\n            right--;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ol start=\"2\">\n<li>使用递归：</li>\n</ol>\n<p>在对root进行判断之后，就使用一个辅助函数对root的左子树和右子树进行判断，判断完成后分别对左子树的左子树和右子树的右子树；左子树的右子树以及右子树的左子树进行判断，两个判断结果进行与运算，递归得到最终结果。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isSymmetric(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若根节点为空，则返回true\n\n        return isSymmetricHelper(root-&gt;left, root-&gt;right);\n    &#125;\n    bool isSymmetricHelper(TreeNode* left, TreeNode* right) &#123;\n        if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;若左右都为空，则返回true\n      \t&#x2F;&#x2F; if ((left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) || (left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL)) return false; &#x2F;&#x2F; 左右子树一个空一个不空，返回false (下面这行更简练)\n        if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;若左右节点有一个不为空，则返回false\n        if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F;若左右节点的值不相等，则返回false\n\n        &#x2F;&#x2F;递归检查左右子树是否对称\n        return isSymmetricHelper(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetricHelper(left-&gt;right, right-&gt;left);\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li>使用迭代</li>\n</ol>\n<p>该解决方案使用队列来存储树的节点，首先将左子树和右子树的根节点加入队列中。然后在循环中，每次取出队列的头两个节点，并比较它们是否对称，如果不对称则返回false。如果对称，则将左节点的左子树节点和右节点的右子树节点加入队列，再将左节点的右子树节点和右节点的左子树节点加入队列。如果队列为空，则说明树是对称的，返回true。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isSymmetric(TreeNode* root) &#123;\n        if (root &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;节点为空，返回true\n\n        queue&lt;TreeNode*&gt; q; &#x2F;&#x2F; 定义一个队列存储节点\n        q.push(root-&gt;left);\n        q.push(root-&gt;right);\n\n        while (!q.empty()) &#123;\n            TreeNode* left &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为左节点\n            TreeNode* right &#x3D; q.front(); q.pop(); &#x2F;&#x2F; 取出队列的头节点作为右节点\n            if (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) continue; &#x2F;&#x2F;如果左右节点都为空，则继续迭代\n            if (left &#x3D;&#x3D; NULL || right &#x3D;&#x3D; NULL) return false; &#x2F;&#x2F;左右节点只有一个不为空，直接返回false\n            if (left-&gt;val !&#x3D; right-&gt;val) return false; &#x2F;&#x2F; 左右节点值不等，直接返回false\n\n            q.push(left-&gt;left);\n            q.push(right-&gt;right);\n            q.push(left-&gt;right);\n            q.push(right-&gt;left); &#x2F;&#x2F; 注意push的顺序！！！\n        &#125; \n        return true; &#x2F;&#x2F;若队列为空，则说明该二叉树是对称的。\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}