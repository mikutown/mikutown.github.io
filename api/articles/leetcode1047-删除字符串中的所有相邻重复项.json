{"title":"leetcode1047.删除字符串中的所有相邻重复项","slug":"leetcode1047-删除字符串中的所有相邻重复项","date":"2023-12-11T13:16:29.000Z","updated":"2023-12-11T13:28:00.465Z","comments":true,"path":"api/articles/leetcode1047-删除字符串中的所有相邻重复项.json","excerpt":"题目给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>\n<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>\n<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：&quot;abbaca&quot;\n输出：&quot;ca&quot;\n解释：\n例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li><code>1 &lt;= S.length &lt;= 20000</code></li>\n<li><code>S</code> 仅由小写英文字母组成。</li>\n</ol>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用栈</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string removeDuplicates(string S) &#123;\n        stack&lt;char&gt; charStack;  &#x2F;&#x2F; 使用栈来存储字符\n\n        for (char c : S) &#123;\n            &#x2F;&#x2F; 如果栈不为空且栈顶字符与当前字符相同，则移除栈顶字符\n            if (!charStack.empty() &amp;&amp; charStack.top() &#x3D;&#x3D; c) &#123;\n                charStack.pop();\n            &#125; else &#123;\n                &#x2F;&#x2F; 否则，将当前字符压入栈\n                charStack.push(c);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 将栈中字符组合成最终的结果字符串\n        string result &#x3D; &quot;&quot;;\n        while (!charStack.empty()) &#123;\n            result &#x3D; charStack.top() + result;\n            charStack.pop();\n        &#125;\n\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string removeDuplicates(string S) &#123;\n        int slow &#x3D; 0; &#x2F;&#x2F; 慢指针，指向当前处理的位置\n        for (int fast &#x3D; 0; fast &lt; S.size(); ++fast) &#123;\n            &#x2F;&#x2F; 如果慢指针不为零，且当前字符与慢指针前一个字符相同，表示发现相邻重复\n            if (slow !&#x3D; 0 &amp;&amp; S[fast] &#x3D;&#x3D; S[slow - 1]) &#123;\n                slow--;\n            &#125; else &#123;\n                &#x2F;&#x2F; 否则，将当前字符加入到慢指针指向的位置\n                S[slow++] &#x3D; S[fast];\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 截断字符串，保留有效部分\n        return S.substr(0, slow);\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：&quot;abbaca&quot;\n输出：&quot;ca&quot;\n解释：\n例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li><code>1 &lt;= S.length &lt;= 20000</code></li>\n<li><code>S</code> 仅由小写英文字母组成。</li>\n</ol>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用栈</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string removeDuplicates(string S) &#123;\n        stack&lt;char&gt; charStack;  &#x2F;&#x2F; 使用栈来存储字符\n\n        for (char c : S) &#123;\n            &#x2F;&#x2F; 如果栈不为空且栈顶字符与当前字符相同，则移除栈顶字符\n            if (!charStack.empty() &amp;&amp; charStack.top() &#x3D;&#x3D; c) &#123;\n                charStack.pop();\n            &#125; else &#123;\n                &#x2F;&#x2F; 否则，将当前字符压入栈\n                charStack.push(c);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 将栈中字符组合成最终的结果字符串\n        string result &#x3D; &quot;&quot;;\n        while (!charStack.empty()) &#123;\n            result &#x3D; charStack.top() + result;\n            charStack.pop();\n        &#125;\n\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string removeDuplicates(string S) &#123;\n        int slow &#x3D; 0; &#x2F;&#x2F; 慢指针，指向当前处理的位置\n        for (int fast &#x3D; 0; fast &lt; S.size(); ++fast) &#123;\n            &#x2F;&#x2F; 如果慢指针不为零，且当前字符与慢指针前一个字符相同，表示发现相邻重复\n            if (slow !&#x3D; 0 &amp;&amp; S[fast] &#x3D;&#x3D; S[slow - 1]) &#123;\n                slow--;\n            &#125; else &#123;\n                &#x2F;&#x2F; 否则，将当前字符加入到慢指针指向的位置\n                S[slow++] &#x3D; S[fast];\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 截断字符串，保留有效部分\n        return S.substr(0, slow);\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}