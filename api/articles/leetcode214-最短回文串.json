{"title":"leetcode214.最短回文串","slug":"leetcode214-最短回文串","date":"2023-03-23T06:14:31.000Z","updated":"2023-03-23T06:27:13.948Z","comments":true,"path":"api/articles/leetcode214-最短回文串.json","excerpt":"题目给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串 <em><strong>s</strong></em>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;aacecaaa&quot;\n输出：&quot;aaacecaaa&quot;</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;abcd&quot;\n输出：&quot;dcbabcd&quot;</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>\n<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>KMP算法求解</li>\n</ul>\n<p>本题可以通过将原字符串翻转后与原字符串拼接，然后在新的字符串中找到以原字符串开头的最长回文子串，最后将翻转字符串的前缀加到原字符串前面即可得到新的字符串。为了找到以原字符串开头的最长回文子串，可以使用KMP算法中的next数组，将新的字符串l的next数组求出来，那么l.size() - 1位置处的值就是以原字符串开头的最长回文子串的长度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string shortestPalindrome(string s) &#123;\n        &#x2F;&#x2F; 将字符串s翻转并存储在rev_s中\n        string rev_s &#x3D; s;\n        reverse(rev_s.begin(), rev_s.end());\n        &#x2F;&#x2F; 将s和rev_s拼接，并用“#”分割\n        string l &#x3D; s + &quot;#&quot; + rev_s;\n        &#x2F;&#x2F; 初始化一个大小为l.size()的数组p\n        vector&lt;int&gt; p(l.size(), 0);\n        &#x2F;&#x2F; 通过循环遍历l，求出p数组\n        for (int i &#x3D; 1; i &lt; l.size(); i++) &#123;\n            int j &#x3D; p[i - 1];\n            while (j &gt; 0 &amp;&amp; l[i] !&#x3D; l[j]) j &#x3D; p[j - 1];\n            p[i] &#x3D; (j +&#x3D; l[i] &#x3D;&#x3D; l[j]);\n        &#125;\n        &#x2F;&#x2F; 返回一个由rev_s的前缀和s组成的新字符串\n        return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>以输入<code>s=&quot;aacecaaa&quot;</code>为例，说明代码的运行过程：</p>\n<p>首先将字符串s翻转得到rev_s&#x3D;”aaacecaa”，然后将s和rev_s用”#”分割拼接起来得到l&#x3D;”aacecaaa#aaacecaa”。</p>\n<p>然后初始化一个大小为l.size()的数组p，数组中每个元素表示对应位置之前的字符串的最长相同前缀后缀的长度。</p>\n<p>接下来使用KMP算法的思想，通过遍历l来求得数组p的所有元素。从i&#x3D;1开始，依次比较l[i]和l[p[i-1]]，如果不相同，则令j&#x3D;p[i-1]，并循环将j更新为p[j-1]，直到j&#x3D;0或者找到一个位置k使得l[i]和l[k]相等。如果找到了k，则令p[i]&#x3D;k+1，否则令p[i]&#x3D;0。</p>\n<p>经过上述循环遍历后，p数组的最后一个元素p[l.size()-1]表示以原字符串开头的最长回文子串的长度，即3。因此，可以将rev_s的前缀”aa”加到s的前面，得到新的字符串为”aaacecaaa”，这个字符串是由原字符串”aacecaaa”通过添加最少字符得到的回文串。</p>\n</blockquote>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;aacecaaa&quot;\n输出：&quot;aaacecaaa&quot;</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;abcd&quot;\n输出：&quot;dcbabcd&quot;</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>\n<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>KMP算法求解</li>\n</ul>\n<p>本题可以通过将原字符串翻转后与原字符串拼接，然后在新的字符串中找到以原字符串开头的最长回文子串，最后将翻转字符串的前缀加到原字符串前面即可得到新的字符串。为了找到以原字符串开头的最长回文子串，可以使用KMP算法中的next数组，将新的字符串l的next数组求出来，那么l.size() - 1位置处的值就是以原字符串开头的最长回文子串的长度。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    string shortestPalindrome(string s) &#123;\n        &#x2F;&#x2F; 将字符串s翻转并存储在rev_s中\n        string rev_s &#x3D; s;\n        reverse(rev_s.begin(), rev_s.end());\n        &#x2F;&#x2F; 将s和rev_s拼接，并用“#”分割\n        string l &#x3D; s + &quot;#&quot; + rev_s;\n        &#x2F;&#x2F; 初始化一个大小为l.size()的数组p\n        vector&lt;int&gt; p(l.size(), 0);\n        &#x2F;&#x2F; 通过循环遍历l，求出p数组\n        for (int i &#x3D; 1; i &lt; l.size(); i++) &#123;\n            int j &#x3D; p[i - 1];\n            while (j &gt; 0 &amp;&amp; l[i] !&#x3D; l[j]) j &#x3D; p[j - 1];\n            p[i] &#x3D; (j +&#x3D; l[i] &#x3D;&#x3D; l[j]);\n        &#125;\n        &#x2F;&#x2F; 返回一个由rev_s的前缀和s组成的新字符串\n        return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;\n    &#125;\n&#125;;</code></pre>\n\n<blockquote>\n<p>以输入<code>s=&quot;aacecaaa&quot;</code>为例，说明代码的运行过程：</p>\n<p>首先将字符串s翻转得到rev_s&#x3D;”aaacecaa”，然后将s和rev_s用”#”分割拼接起来得到l&#x3D;”aacecaaa#aaacecaa”。</p>\n<p>然后初始化一个大小为l.size()的数组p，数组中每个元素表示对应位置之前的字符串的最长相同前缀后缀的长度。</p>\n<p>接下来使用KMP算法的思想，通过遍历l来求得数组p的所有元素。从i&#x3D;1开始，依次比较l[i]和l[p[i-1]]，如果不相同，则令j&#x3D;p[i-1]，并循环将j更新为p[j-1]，直到j&#x3D;0或者找到一个位置k使得l[i]和l[k]相等。如果找到了k，则令p[i]&#x3D;k+1，否则令p[i]&#x3D;0。</p>\n<p>经过上述循环遍历后，p数组的最后一个元素p[l.size()-1]表示以原字符串开头的最长回文子串的长度，即3。因此，可以将rev_s的前缀”aa”加到s的前面，得到新的字符串为”aaacecaaa”，这个字符串是由原字符串”aacecaaa”通过添加最少字符得到的回文串。</p>\n</blockquote>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}