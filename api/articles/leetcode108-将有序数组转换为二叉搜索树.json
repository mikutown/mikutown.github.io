{"title":"leetcode108.将有序数组转换为二叉搜索树","slug":"leetcode108-将有序数组转换为二叉搜索树","date":"2023-03-26T11:19:20.000Z","updated":"2023-03-26T11:27:07.977Z","comments":true,"path":"api/articles/leetcode108-将有序数组转换为二叉搜索树.json","excerpt":"题目给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。","covers":["http://cdn.leafii.top/img/btree1.jpg","http://cdn.leafii.top/img/btree.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>\n<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/btree1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [-10,-3,0,5,9]\n输出：[0,-3,9,-10,null,5]\n解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/btree.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,3]\n输出：[3,1]\n解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归构造树</li>\n</ul>\n<p>在这个实现中，我们采用了递归的方法构建高度平衡的二叉搜索树。在每次递归中，我们找到当前子数组的中间元素作为根节点，然后递归构建左右子树，最后将根节点返回。在递归过程中，我们使用两个指针 <code>left</code> 和 <code>right</code> 分别表示当前子数组的左右边界。如果 <code>left &gt; right</code>，则说明当前子数组为空，递归结束，返回 <code>nullptr</code>。C++实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; 调用buildBST函数\n        return buildBST(nums, 0, nums.size() - 1);\n    &#125;\nprivate:\n    TreeNode* buildBST(vector&lt;int&gt;&amp; nums, int left, int right) &#123;\n        if (left &gt; right) &#123;\n            &#x2F;&#x2F; 若left &gt; right 则直接返回空指针\n            return nullptr; \n        &#125;\n\n        int mid &#x3D; left + (right - left) &#x2F; 2; &#x2F;&#x2F; 寻找mid的大小，将nums[mid]作为树的根节点\n        TreeNode* root &#x3D; new TreeNode(nums[mid]); &#x2F;&#x2F; 新建根节点，节点的值为nums[mid]\n\n        &#x2F;&#x2F; 递归调用buildBST函数构造left和right树，并将其赋值给root-&gt;left和root-&gt;right\n        root-&gt;left &#x3D; buildBST(nums, left, mid - 1); \n        root-&gt;right &#x3D; buildBST(nums, mid + 1, right);\n\n        &#x2F;&#x2F; 返回根节点\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/btree1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [-10,-3,0,5,9]\n输出：[0,-3,9,-10,null,5]\n解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/btree.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,3]\n输出：[3,1]\n解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>递归构造树</li>\n</ul>\n<p>在这个实现中，我们采用了递归的方法构建高度平衡的二叉搜索树。在每次递归中，我们找到当前子数组的中间元素作为根节点，然后递归构建左右子树，最后将根节点返回。在递归过程中，我们使用两个指针 <code>left</code> 和 <code>right</code> 分别表示当前子数组的左右边界。如果 <code>left &gt; right</code>，则说明当前子数组为空，递归结束，返回 <code>nullptr</code>。C++实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; 调用buildBST函数\n        return buildBST(nums, 0, nums.size() - 1);\n    &#125;\nprivate:\n    TreeNode* buildBST(vector&lt;int&gt;&amp; nums, int left, int right) &#123;\n        if (left &gt; right) &#123;\n            &#x2F;&#x2F; 若left &gt; right 则直接返回空指针\n            return nullptr; \n        &#125;\n\n        int mid &#x3D; left + (right - left) &#x2F; 2; &#x2F;&#x2F; 寻找mid的大小，将nums[mid]作为树的根节点\n        TreeNode* root &#x3D; new TreeNode(nums[mid]); &#x2F;&#x2F; 新建根节点，节点的值为nums[mid]\n\n        &#x2F;&#x2F; 递归调用buildBST函数构造left和right树，并将其赋值给root-&gt;left和root-&gt;right\n        root-&gt;left &#x3D; buildBST(nums, left, mid - 1); \n        root-&gt;right &#x3D; buildBST(nums, mid + 1, right);\n\n        &#x2F;&#x2F; 返回根节点\n        return root;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}