{"title":"leetcode188.买卖股票的最佳时机IV","slug":"leetcode188-买卖股票的最佳时机IV","date":"2023-05-24T08:54:22.000Z","updated":"2023-05-24T08:54:54.618Z","comments":true,"path":"api/articles/leetcode188-买卖股票的最佳时机IV.json","excerpt":"题目给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格，和一个整型 k 。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格，和一个整型 <code>k</code> 。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p>\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：k &#x3D; 2, prices &#x3D; [2,4,1]\n输出：2\n解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]\n输出：7\n解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。\n     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= k &lt;= 100</code></li>\n<li><code>0 &lt;= prices.length &lt;= 1000</code></li>\n<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>使用buy和sale数组进行动态规划，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数），sale[i] 表示进行第 i 次卖出操作后的最大利润，代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;\n        int n &#x3D; prices.size();\n        vector&lt;int&gt; buy(k, -prices[0]); &#x2F;&#x2F; 定义买入的数组，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数）\n        vector&lt;int&gt; sale(k); &#x2F;&#x2F; 定义卖出的数组，sale[i] 表示进行第 i 次卖出操作后的最大利润\n\n        for(int i &#x3D; 1; i &lt; n; ++i) &#123;\n            buy[0] &#x3D; max(buy[0], -prices[i]); &#x2F;&#x2F; 更新第一次买入的最大利润，取当前买入的最大利润和前一天的最大利润中较大的值\n            sale[0] &#x3D; max(sale[0], prices[i] + buy[0]); &#x2F;&#x2F; 更新第一次卖出的最大利润，取当前卖出的最大利润和前一天的最大利润加上当前股票价格的较大值\n\n            for(int j &#x3D; 1; j &lt; k; ++j) &#123;\n                buy[j] &#x3D; max(buy[j], sale[j - 1] - prices[i]); &#x2F;&#x2F; 更新第 j 次买入的最大利润，取当前买入的最大利润和前一次卖出的最大利润减去当前股票价格的较大值\n                sale[j] &#x3D; max(sale[j], buy[j] + prices[i]); &#x2F;&#x2F; 更新第 j 次卖出的最大利润，取当前卖出的最大利润和当前买入的最大利润加上当前股票价格的较大值\n            &#125;\n        &#125;\n\n        return sale[k - 1]; &#x2F;&#x2F; 返回最后一次卖出的最大利润\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：k &#x3D; 2, prices &#x3D; [2,4,1]\n输出：2\n解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]\n输出：7\n解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。\n     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= k &lt;= 100</code></li>\n<li><code>0 &lt;= prices.length &lt;= 1000</code></li>\n<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>使用buy和sale数组进行动态规划，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数），sale[i] 表示进行第 i 次卖出操作后的最大利润，代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;\n        int n &#x3D; prices.size();\n        vector&lt;int&gt; buy(k, -prices[0]); &#x2F;&#x2F; 定义买入的数组，buy[i] 表示进行第 i 次买入操作后的最大利润（初始值为第一天的股票价格的相反数）\n        vector&lt;int&gt; sale(k); &#x2F;&#x2F; 定义卖出的数组，sale[i] 表示进行第 i 次卖出操作后的最大利润\n\n        for(int i &#x3D; 1; i &lt; n; ++i) &#123;\n            buy[0] &#x3D; max(buy[0], -prices[i]); &#x2F;&#x2F; 更新第一次买入的最大利润，取当前买入的最大利润和前一天的最大利润中较大的值\n            sale[0] &#x3D; max(sale[0], prices[i] + buy[0]); &#x2F;&#x2F; 更新第一次卖出的最大利润，取当前卖出的最大利润和前一天的最大利润加上当前股票价格的较大值\n\n            for(int j &#x3D; 1; j &lt; k; ++j) &#123;\n                buy[j] &#x3D; max(buy[j], sale[j - 1] - prices[i]); &#x2F;&#x2F; 更新第 j 次买入的最大利润，取当前买入的最大利润和前一次卖出的最大利润减去当前股票价格的较大值\n                sale[j] &#x3D; max(sale[j], buy[j] + prices[i]); &#x2F;&#x2F; 更新第 j 次卖出的最大利润，取当前卖出的最大利润和当前买入的最大利润加上当前股票价格的较大值\n            &#125;\n        &#125;\n\n        return sale[k - 1]; &#x2F;&#x2F; 返回最后一次卖出的最大利润\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]}