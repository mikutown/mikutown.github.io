{"title":"leetcode:59.螺旋矩阵II","slug":"leetcode-59-螺旋矩阵II","date":"2023-02-08T16:53:16.000Z","updated":"2023-02-08T16:56:58.490Z","comments":true,"path":"api/articles/leetcode-59-螺旋矩阵II.json","excerpt":"题目给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。","covers":["https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1\n输出：[[1]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>定义四个变量<code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>，分别代表矩阵的上下左右边界。</li>\n<li>定义一个变量 <code>count</code> 表示当前元素的值，初始值为1。</li>\n<li>只要 <code>top &lt;= bottom &amp;&amp; left &lt;= right</code> ，循环执行以下步骤：<ol>\n<li>先向右填充 <code>top</code> 行的元素，元素的值递增，并将 <code>top</code> 向下移动1。</li>\n<li>向下填充 <code>right</code> 列的元素，元素的值递增，并将 <code>right</code> 向左移动1。</li>\n<li>如果 <code>top &lt;= bottom</code> ，向左填充 <code>bottom</code> 行的元素，元素的值递增，并将 <code>bottom</code> 向上移动1。</li>\n<li>如果 <code>left &lt;= right</code> ，向上填充 <code>left</code> 列的元素，元素的值递增，并将 <code>left</code> 向右移动1。</li>\n</ol>\n</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 0));\n        int top &#x3D; 0, bottom &#x3D; n - 1, left &#x3D; 0, right &#x3D; n - 1;\n        int count &#x3D; 1;\n        while (top &lt;&#x3D; bottom &amp;&amp; left &lt;&#x3D; right) &#123;\n            for (int j &#x3D; left; j &lt;&#x3D; right; j++) &#123;\n                matrix[top][j] &#x3D; count++;\n            &#125;\n            top++;\n            for (int i &#x3D; top; i &lt;&#x3D; bottom; i++) &#123;\n                matrix[i][right] &#x3D; count++;\n            &#125;\n            right--;\n            if (top &lt;&#x3D; bottom) &#123;\n                for (int j &#x3D; right; j &gt;&#x3D; left; j--) &#123;\n                    matrix[bottom][j] &#x3D; count++;\n                &#125;\n                bottom--;\n            &#125;\n            if (left &lt;&#x3D; right) &#123;\n                for (int i &#x3D; bottom; i &gt;&#x3D; top; i--) &#123;\n                    matrix[i][left] &#x3D; count++;\n                &#125;\n                left++;\n            &#125;\n        &#125;\n        return matrix;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 1\n输出：[[1]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>定义四个变量<code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>，分别代表矩阵的上下左右边界。</li>\n<li>定义一个变量 <code>count</code> 表示当前元素的值，初始值为1。</li>\n<li>只要 <code>top &lt;= bottom &amp;&amp; left &lt;= right</code> ，循环执行以下步骤：<ol>\n<li>先向右填充 <code>top</code> 行的元素，元素的值递增，并将 <code>top</code> 向下移动1。</li>\n<li>向下填充 <code>right</code> 列的元素，元素的值递增，并将 <code>right</code> 向左移动1。</li>\n<li>如果 <code>top &lt;= bottom</code> ，向左填充 <code>bottom</code> 行的元素，元素的值递增，并将 <code>bottom</code> 向上移动1。</li>\n<li>如果 <code>left &lt;= right</code> ，向上填充 <code>left</code> 列的元素，元素的值递增，并将 <code>left</code> 向右移动1。</li>\n</ol>\n</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 0));\n        int top &#x3D; 0, bottom &#x3D; n - 1, left &#x3D; 0, right &#x3D; n - 1;\n        int count &#x3D; 1;\n        while (top &lt;&#x3D; bottom &amp;&amp; left &lt;&#x3D; right) &#123;\n            for (int j &#x3D; left; j &lt;&#x3D; right; j++) &#123;\n                matrix[top][j] &#x3D; count++;\n            &#125;\n            top++;\n            for (int i &#x3D; top; i &lt;&#x3D; bottom; i++) &#123;\n                matrix[i][right] &#x3D; count++;\n            &#125;\n            right--;\n            if (top &lt;&#x3D; bottom) &#123;\n                for (int j &#x3D; right; j &gt;&#x3D; left; j--) &#123;\n                    matrix[bottom][j] &#x3D; count++;\n                &#125;\n                bottom--;\n            &#125;\n            if (left &lt;&#x3D; right) &#123;\n                for (int i &#x3D; bottom; i &gt;&#x3D; top; i--) &#123;\n                    matrix[i][left] &#x3D; count++;\n                &#125;\n                left++;\n            &#125;\n        &#125;\n        return matrix;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}