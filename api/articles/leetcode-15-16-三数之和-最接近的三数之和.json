{"title":"leetcode:15/16.三数之和/最接近的三数之和","slug":"leetcode-15-16-三数之和-最接近的三数之和","date":"2023-01-28T07:53:18.000Z","updated":"2023-01-30T11:04:00.798Z","comments":true,"path":"api/articles/leetcode-15-16-三数之和-最接近的三数之和.json","excerpt":"15. 三数之和给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。","covers":null,"content":"<h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a>15. 三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>\n<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。\nnums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。\nnums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"16-最接近的三数之和\"><a href=\"#16-最接近的三数之和\" class=\"headerlink\" title=\"16. 最接近的三数之和\"></a>16. 最接近的三数之和</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p>\n<p>返回这三个数的和。</p>\n<p>假定每组输入只存在恰好一个解。</p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1\n输出：2\n解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,0,0], target &#x3D; 1\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 1000</code></li>\n<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n<li><code>-104 &lt;= target &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><blockquote>\n<p>这两道题目求解思路很相似，只是第一个题目需要返回所有满足求和条件的组合，第二个题目返回最接近target的sum值。</p>\n</blockquote>\n<p><strong>方法一：排序 + 双指针</strong></p>\n<p>题目要求找到与目标值 $target$ 最接近的三元组，这里的「最接近」即为差值的绝对值最小。我们可以考虑直接使用三重循环枚举三元组，找出与目标值最接近的作为答案，时间复杂度为 $O(N^3)$。然而本题的 $N$ 最大为 $1000$，会超出时间限制。</p>\n<p>那么如何进行优化呢？我们首先考虑枚举第一个元素 $a$，对于剩下的两个元素 $b$ 和 $c$，我们希望它们的和最接近 $target-a$。对于 $b$ 和 $c$，如果它们在原数组中枚举的范围（既包括下标的范围，也包括元素值的范围）没有任何规律可言，那么我们还是只能使用两重循环来枚举所有的可能情况。因此，我们可以考虑对整个数组进行升序排序，这样一来：</p>\n<p>假设数组的长度为 $N$，我们先枚举 $a$，它在数组中的位置为 $i$；</p>\n<p>为了防止重复枚举，我们在位置$[i+1,n)$的范围内枚举 $b$ 和 $c$。</p>\n<p>当我们知道了 $b$ 和 $c$ 可以枚举的下标范围，并且知道这一范围对应的数组元素是有序（升序）的，那么我们是否可以对枚举的过程进行优化呢？</p>\n<p>答案是可以的。借助双指针，我们就可以对枚举的过程进行优化。我们用 $p_b$和 $p_c$分别表示指向 $b$ 和 $c$ 的指针，初始时，$p_b$指向位置$i+1$，即左边界；$p_c$指向位置 $n-1$，即右边界。在每一步枚举的过程中，我们用 $a+b+c$ 来更新答案，并且：</p>\n<p>如果 $a+b+c \\ge target$，那么就将 $p_c$向左移动一个位置；</p>\n<p>如果 $a+b+c \\le target$，那么就将 $p_b$向右移动一个位置。</p>\n<p>这是为什么呢？我们对 $a+b+c \\ge target$ 的情况进行一个详细的分析：</p>\n<p>如果 $a+b+c \\ge target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_c$不变而 $p_b$向右移动，那么 $a+b+c$ 的值就会不断地增加，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_c$的情况下，此时的 $p_b$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_c$了，就可以将 $p_c$向左移动一个位置。</p>\n<p>同样地，在 $a+b+c \\le target$ 时：</p>\n<p>如果 $a+b+c \\le target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_b$不变而 $p_c$向左移动，那么 $a+b+c$ 的值就会不断地减小，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_b$的情况下，此时的 $p_c$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_b$了，就可以将 $p_b$向右移动一个位置。</p>\n<p>实际上，$p_b$和 $p_c$就表示了我们当前可以选择的数的范围，而每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 $target$ 的值的关系，选择「抛弃」左边界的元素还是右边界的元素，从而减少了枚举的范围。这种思路与 11. 盛最多水的容器 中的双指针解法也是类似的。</p>\n<p><strong>小优化</strong></p>\n<p>本题也有一些可以减少运行时间（但不会减少时间复杂度）的小优化。当我们枚举到恰好等于 $target$ 的 $a+b+c$ 时，可以直接返回 $target$ 作为答案，因为不会有再比这个更接近的值了。</p>\n<p>另一个优化与 15. 三数之和的官方题解 中提到的类似。当我们枚举 $a,b,c$中任意元素并移动指针时，可以直接将其移动到下一个与这次枚举到的不相同的元素，减少枚举的次数。</p>\n<h3 id=\"15题C-实现：\"><a href=\"#15题C-实现：\" class=\"headerlink\" title=\"15题C++实现：\"></a>15题C++实现：</h3><pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        &#x2F;&#x2F;对数组进行排序\n        sort(nums.begin(), nums.end());\n        int n &#x3D; nums.size();\n        &#x2F;&#x2F;枚举a\n        for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n            &#x2F;&#x2F;保证和上一次枚举的元素不相等\n            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;\n                continue;\n            &#125;\n            int target &#x3D; -nums[i];\n            &#x2F;&#x2F;使用双指针枚举b和c\n            int j &#x3D; i + 1, k &#x3D; n - 1;\n            while (j &lt; k) &#123;\n                int sum &#x3D;  nums[j] + nums[k];\n                &#x2F;&#x2F; 如果和为target则直接返回答案 \n                if (sum &#x3D;&#x3D; target) &#123;\n                    result.push_back(&#123;nums[i], nums[j], nums[k]&#125;);\n                &#125;\n                if (sum &gt; target) &#123;\n                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针\n                    int k0 &#x3D; k - 1;\n                    &#x2F;&#x2F;移动到下一个不相等的元素\n                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;\n                        --k0;\n                    &#125;\n                    k &#x3D; k0;\n                &#125; else &#123;\n                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针\n                    int j0 &#x3D; j + 1;\n                    &#x2F;&#x2F;移动到下一个不相等的元素\n                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;\n                        ++j0;\n                    &#125;\n                    j &#x3D; j0;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<h3 id=\"16题C-实现：\"><a href=\"#16题C-实现：\" class=\"headerlink\" title=\"16题C++实现：\"></a>16题C++实现：</h3><pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;\n        &#x2F;&#x2F;对数组进行排序\n        sort(nums.begin(), nums.end());\n        int n &#x3D; nums.size();\n        int best &#x3D; 1e7;&#x2F;&#x2F; initial\n        \n        &#x2F;&#x2F;根据差值的绝对值来更新答案\n        &#x2F;*\n            auto toNumber &#x3D; [&amp;](string const&amp; s) -&gt; unsigned &#123;\n                ...\n            &#125;\n            []：定义匿名函数\n            [&amp;]：以引用形式捕获所有外部变量，也就是外部变量均可用\n            (string const &amp;s) ：匿名函数的参数\n            -&gt;：定义匿名函数\n            unsigned：函数返回值类型\n            &#123;...&#125;：函数实现体\n        *&#x2F;\n        \n        auto update &#x3D; [&amp;](int cur) &#123;\n            if (abs(cur - target) &lt; abs(best - target)) &#123;\n                best &#x3D; cur;\n            &#125;\n        &#125;;\n\n        &#x2F;&#x2F;枚举 a\n        for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n            &#x2F;&#x2F;保证和上一次枚举的元素不相等\n            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;\n                continue;\n            &#125;\n\n            &#x2F;&#x2F;使用双指针枚举b和c\n            int j &#x3D; i + 1, k &#x3D; n - 1;\n            while (j &lt; k) &#123;\n                int sum &#x3D; nums[i] + nums[j] + nums[k];\n                &#x2F;&#x2F; 如果和为target则直接返回答案 \n                if (sum &#x3D;&#x3D; target) &#123;\n                    return target;\n                &#125;\n                update(sum);\n                if (sum &gt; target) &#123;\n                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针\n                    int k0 &#x3D; k - 1;\n                    &#x2F;&#x2F;移动到下一个不相等的元素\n                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;\n                        --k0;\n                    &#125;\n                    k &#x3D; k0;\n                &#125; else &#123;\n                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针\n                    int j0 &#x3D; j + 1;\n                    &#x2F;&#x2F;移动到下一个不相等的元素\n                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;\n                        ++j0;\n                    &#125;\n                    j &#x3D; j0;\n                &#125;\n            &#125;\n        &#125;\n        return best;\n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>力扣官方题解：<a href=\"https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/\">https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/</a></p>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。\nnums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。\nnums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h2 id=\"16-最接近的三数之和\"><a href=\"#16-最接近的三数之和\" class=\"headerlink\" title=\"16. 最接近的三数之和\"></a>16. 最接近的三数之和</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p>\n<p>返回这三个数的和。</p>\n<p>假定每组输入只存在恰好一个解。</p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1\n输出：2\n解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,0,0], target &#x3D; 1\n输出：0</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 1000</code></li>\n<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n<li><code>-104 &lt;= target &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><blockquote>\n<p>这两道题目求解思路很相似，只是第一个题目需要返回所有满足求和条件的组合，第二个题目返回最接近target的sum值。</p>\n</blockquote>\n<p><strong>方法一：排序 + 双指针</strong></p>\n<p>题目要求找到与目标值 $target$ 最接近的三元组，这里的「最接近」即为差值的绝对值最小。我们可以考虑直接使用三重循环枚举三元组，找出与目标值最接近的作为答案，时间复杂度为 $O(N^3)$。然而本题的 $N$ 最大为 $1000$，会超出时间限制。</p>\n<p>那么如何进行优化呢？我们首先考虑枚举第一个元素 $a$，对于剩下的两个元素 $b$ 和 $c$，我们希望它们的和最接近 $target-a$。对于 $b$ 和 $c$，如果它们在原数组中枚举的范围（既包括下标的范围，也包括元素值的范围）没有任何规律可言，那么我们还是只能使用两重循环来枚举所有的可能情况。因此，我们可以考虑对整个数组进行升序排序，这样一来：</p>\n<p>假设数组的长度为 $N$，我们先枚举 $a$，它在数组中的位置为 $i$；</p>\n<p>为了防止重复枚举，我们在位置$[i+1,n)$的范围内枚举 $b$ 和 $c$。</p>\n<p>当我们知道了 $b$ 和 $c$ 可以枚举的下标范围，并且知道这一范围对应的数组元素是有序（升序）的，那么我们是否可以对枚举的过程进行优化呢？</p>\n<p>答案是可以的。借助双指针，我们就可以对枚举的过程进行优化。我们用 $p_b$和 $p_c$分别表示指向 $b$ 和 $c$ 的指针，初始时，$p_b$指向位置$i+1$，即左边界；$p_c$指向位置 $n-1$，即右边界。在每一步枚举的过程中，我们用 $a+b+c$ 来更新答案，并且：</p>\n<p>如果 $a+b+c \\ge target$，那么就将 $p_c$向左移动一个位置；</p>\n<p>如果 $a+b+c \\le target$，那么就将 $p_b$向右移动一个位置。</p>\n<p>这是为什么呢？我们对 $a+b+c \\ge target$ 的情况进行一个详细的分析：</p>\n<p>如果 $a+b+c \\ge target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_c$不变而 $p_b$向右移动，那么 $a+b+c$ 的值就会不断地增加，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_c$的情况下，此时的 $p_b$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_c$了，就可以将 $p_c$向左移动一个位置。</p>\n<p>同样地，在 $a+b+c \\le target$ 时：</p>\n<p>如果 $a+b+c \\le target$，并且我们知道 $p_b$到 $p_c$这个范围内的所有数是按照升序排序的，那么如果 $p_b$不变而 $p_c$向左移动，那么 $a+b+c$ 的值就会不断地减小，显然就不会成为最接近 $target$ 的值了。因此，我们可以知道在固定了 $p_b$的情况下，此时的 $p_c$就可以得到一个最接近 $target$ 的值，那么我们以后就不用再考虑 $p_b$了，就可以将 $p_b$向右移动一个位置。</p>\n<p>实际上，$p_b$和 $p_c$就表示了我们当前可以选择的数的范围，而每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 $target$ 的值的关系，选择「抛弃」左边界的元素还是右边界的元素，从而减少了枚举的范围。这种思路与 11. 盛最多水的容器 中的双指针解法也是类似的。</p>\n<p><strong>小优化</strong></p>\n<p>本题也有一些可以减少运行时间（但不会减少时间复杂度）的小优化。当我们枚举到恰好等于 $target$ 的 $a+b+c$ 时，可以直接返回 $target$ 作为答案，因为不会有再比这个更接近的值了。</p>\n<p>另一个优化与 15. 三数之和的官方题解 中提到的类似。当我们枚举 $a,b,c$中任意元素并移动指针时，可以直接将其移动到下一个与这次枚举到的不相同的元素，减少枚举的次数。</p>\n<h3 id=\"15题C-实现：\"><a href=\"#15题C-实现：\" class=\"headerlink\" title=\"15题C++实现：\"></a>15题C++实现：</h3><pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        &#x2F;&#x2F;对数组进行排序\n        sort(nums.begin(), nums.end());\n        int n &#x3D; nums.size();\n        &#x2F;&#x2F;枚举a\n        for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n            &#x2F;&#x2F;保证和上一次枚举的元素不相等\n            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;\n                continue;\n            &#125;\n            int target &#x3D; -nums[i];\n            &#x2F;&#x2F;使用双指针枚举b和c\n            int j &#x3D; i + 1, k &#x3D; n - 1;\n            while (j &lt; k) &#123;\n                int sum &#x3D;  nums[j] + nums[k];\n                &#x2F;&#x2F; 如果和为target则直接返回答案 \n                if (sum &#x3D;&#x3D; target) &#123;\n                    result.push_back(&#123;nums[i], nums[j], nums[k]&#125;);\n                &#125;\n                if (sum &gt; target) &#123;\n                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针\n                    int k0 &#x3D; k - 1;\n                    &#x2F;&#x2F;移动到下一个不相等的元素\n                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;\n                        --k0;\n                    &#125;\n                    k &#x3D; k0;\n                &#125; else &#123;\n                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针\n                    int j0 &#x3D; j + 1;\n                    &#x2F;&#x2F;移动到下一个不相等的元素\n                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;\n                        ++j0;\n                    &#125;\n                    j &#x3D; j0;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<h3 id=\"16题C-实现：\"><a href=\"#16题C-实现：\" class=\"headerlink\" title=\"16题C++实现：\"></a>16题C++实现：</h3><pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;\n        &#x2F;&#x2F;对数组进行排序\n        sort(nums.begin(), nums.end());\n        int n &#x3D; nums.size();\n        int best &#x3D; 1e7;&#x2F;&#x2F; initial\n        \n        &#x2F;&#x2F;根据差值的绝对值来更新答案\n        &#x2F;*\n            auto toNumber &#x3D; [&amp;](string const&amp; s) -&gt; unsigned &#123;\n                ...\n            &#125;\n            []：定义匿名函数\n            [&amp;]：以引用形式捕获所有外部变量，也就是外部变量均可用\n            (string const &amp;s) ：匿名函数的参数\n            -&gt;：定义匿名函数\n            unsigned：函数返回值类型\n            &#123;...&#125;：函数实现体\n        *&#x2F;\n        \n        auto update &#x3D; [&amp;](int cur) &#123;\n            if (abs(cur - target) &lt; abs(best - target)) &#123;\n                best &#x3D; cur;\n            &#125;\n        &#125;;\n\n        &#x2F;&#x2F;枚举 a\n        for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n            &#x2F;&#x2F;保证和上一次枚举的元素不相等\n            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;\n                continue;\n            &#125;\n\n            &#x2F;&#x2F;使用双指针枚举b和c\n            int j &#x3D; i + 1, k &#x3D; n - 1;\n            while (j &lt; k) &#123;\n                int sum &#x3D; nums[i] + nums[j] + nums[k];\n                &#x2F;&#x2F; 如果和为target则直接返回答案 \n                if (sum &#x3D;&#x3D; target) &#123;\n                    return target;\n                &#125;\n                update(sum);\n                if (sum &gt; target) &#123;\n                    &#x2F;&#x2F;如果和大于target， 移动c对应的指针\n                    int k0 &#x3D; k - 1;\n                    &#x2F;&#x2F;移动到下一个不相等的元素\n                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;\n                        --k0;\n                    &#125;\n                    k &#x3D; k0;\n                &#125; else &#123;\n                    &#x2F;&#x2F;如果和小于target, 移动b对应的指针\n                    int j0 &#x3D; j + 1;\n                    &#x2F;&#x2F;移动到下一个不相等的元素\n                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;\n                        ++j0;\n                    &#125;\n                    j &#x3D; j0;\n                &#125;\n            &#125;\n        &#125;\n        return best;\n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>力扣官方题解：<a href=\"https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/\">https://leetcode.cn/problems/3sum-closest/solutions/301382/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/</a></p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}