{"title":"leetcode321.拼接最大数","slug":"leetcode321-拼接最大数","date":"2023-07-28T10:32:30.000Z","updated":"2023-07-28T10:41:04.347Z","comments":true,"path":"api/articles/leetcode321-拼接最大数.json","excerpt":"题目给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。说明: 请尽可能地优化你算法的时间和空间复杂度。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定长度分别为 <code>m</code> 和 <code>n</code> 的两个数组，其元素由 <code>0-9</code> 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 <code>k (k &lt;= m + n)</code> 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p>\n<p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 <code>k</code> 的数组。</p>\n<p><strong>说明:</strong> 请尽可能地优化你算法的时间和空间复杂度。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入:\nnums1 &#x3D; [3, 4, 6, 5]\nnums2 &#x3D; [9, 1, 2, 5, 8, 3]\nk &#x3D; 5\n输出:\n[9, 8, 6, 5, 3]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入:\nnums1 &#x3D; [6, 7]\nnums2 &#x3D; [6, 0, 4]\nk &#x3D; 5\n输出:\n[6, 7, 6, 0, 4]</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入:\nnums1 &#x3D; [3, 9]\nnums2 &#x3D; [8, 9]\nk &#x3D; 3\n输出:\n[9, 8, 9]</code></pre>\n\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>单调栈</li>\n</ul>\n<p>为了找到长度为 kkk 的最大数，需要从两个数组中分别选出最大的子序列，这两个子序列的长度之和为 kkk，然后将这两个子序列合并得到最大数。两个子序列的长度最小为 000，最大不能超过 kkk 且不能超过对应的数组长度。</p>\n<p>令数组 $\\textit{nums}_1$ 的长度为 m，数组 $\\textit{nums}_2$的长度为 n，则需要从数组 $\\textit{nums}_1$中选出长度为 x 的子序列，以及从数组$\\textit{nums}_2$ 中选出长度为 yyy 的子序列，其中$x+y&#x3D;k$，且满足$0 \\le x \\le m$和$0 \\le y \\le n$。需要遍历所有可能的 $x$ 和 $y$ 的值，对于每一组$x$ 和 $y$ 的值，得到最大数。在整个过程中维护可以通过拼接得到的最大数。</p>\n<p>对于每一组 $x$ 和 $y$ 的值，得到最大数的过程分成两步，第一步是分别从两个数组中得到指定长度的最大子序列，第二步是将两个最大子序列合并。</p>\n<p>第一步可以通过单调栈实现。单调栈满足从栈底到栈顶的元素单调递减，从左到右遍历数组，遍历过程中维护单调栈内的元素，需要保证遍历结束之后单调栈内的元素个数等于指定的最大子序列的长度。遍历结束之后，将从栈底到栈顶的元素依次拼接，即得到最大子序列。</p>\n<p>第二步需要自定义比较方法。首先比较两个子序列的当前元素，如果两个当前元素不同，则选其中较大的元素作为下一个合并的元素，否则需要比较后面的所有元素才能决定选哪个元素作为下一个合并的元素。</p>\n<p>在下面的代码中，单调栈使用数组实现，数组最左侧为栈底。使用数组实现，可以直接从左到右遍历数组得到最大子序列。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123;\n        int m &#x3D; nums1.size(), n &#x3D; nums2.size();\n        vector&lt;int&gt; maxSubsequence(k, 0); &#x2F;&#x2F; 存储最大的子序列结果\n        int start &#x3D; max(0, k - n), end &#x3D; min(k, m); &#x2F;&#x2F; 确定子序列长度的起始和结束范围\n        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;\n            vector&lt;int&gt; subsequence1(MaxSubsequence(nums1, i)); &#x2F;&#x2F; 从nums1中取i个数字组成的最大子序列\n            vector&lt;int&gt; subsequence2(MaxSubsequence(nums2, k - i)); &#x2F;&#x2F; 从nums2中取k-i个数字组成的最大子序列\n            vector&lt;int&gt; curMaxSubsequence(merge(subsequence1, subsequence2)); &#x2F;&#x2F; 合并两个子序列得到当前最大结果\n            if (compare(curMaxSubsequence, 0, maxSubsequence, 0) &gt; 0) &#123;\n                maxSubsequence.swap(curMaxSubsequence); &#x2F;&#x2F; 如果当前最大结果更大，则更新maxSubsequence\n            &#125;\n        &#125;\n        return maxSubsequence; &#x2F;&#x2F; 返回最终的最大子序列结果\n    &#125;\n\n    vector&lt;int&gt; MaxSubsequence(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int length &#x3D; nums.size();\n        vector&lt;int&gt; stack(k, 0); &#x2F;&#x2F; 使用stack来构建最大子序列\n        int top &#x3D; -1;\n        int remain &#x3D; length - k; &#x2F;&#x2F; 记录还需要丢弃的数字个数\n        for (int i &#x3D; 0; i &lt; length; i++) &#123;\n            int num &#x3D; nums[i];\n            while (top &gt;&#x3D; 0 &amp;&amp; stack[top] &lt; num &amp;&amp; remain &gt; 0) &#123;\n                top--; &#x2F;&#x2F; 当前数字比栈顶元素大，可以丢弃栈顶元素，继续判断下一个栈顶元素\n                remain--; &#x2F;&#x2F; 更新需要丢弃的数字个数\n            &#125;\n            if (top &lt; k - 1) &#123;\n                stack[++top] &#x3D; num; &#x2F;&#x2F; 将当前数字加入栈中\n            &#125; else &#123;\n                remain--; &#x2F;&#x2F; 否则，当前数字比栈顶元素小，丢弃当前数字，继续判断下一个数字\n            &#125;\n        &#125;\n        return stack; &#x2F;&#x2F; 返回最终构建的最大子序列\n    &#125;\n\n    vector&lt;int&gt; merge(vector&lt;int&gt;&amp; subsequence1, vector&lt;int&gt;&amp; subsequence2) &#123;\n        int x &#x3D; subsequence1.size(), y &#x3D; subsequence2.size();\n        if (x &#x3D;&#x3D; 0) &#123;\n            return subsequence2; &#x2F;&#x2F; 如果subsequence1为空，则直接返回subsequence2\n        &#125;\n        if (y &#x3D;&#x3D; 0) &#123;\n            return subsequence1; &#x2F;&#x2F; 如果subsequence2为空，则直接返回subsequence1\n        &#125;\n        int mergeLength &#x3D; x + y;\n        vector&lt;int&gt; merged(mergeLength); &#x2F;&#x2F; 合并结果的数组\n        int index1 &#x3D; 0, index2 &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; mergeLength; i++) &#123;\n            if (compare(subsequence1, index1, subsequence2, index2) &gt; 0) &#123;\n                merged[i] &#x3D; subsequence1[index1++]; &#x2F;&#x2F; 如果subsequence1的当前元素较大，则加入到合并结果中\n            &#125; else &#123;\n                merged[i] &#x3D; subsequence2[index2++]; &#x2F;&#x2F; 否则，加入subsequence2的当前元素到合并结果中\n            &#125;\n        &#125;\n        return merged; &#x2F;&#x2F; 返回合并的结果\n    &#125;\n\n    int compare(vector&lt;int&gt;&amp; subsequence1, int index1, vector&lt;int&gt;&amp; subsequence2, int index2) &#123;\n        int x &#x3D; subsequence1.size(), y &#x3D; subsequence2.size();\n        while (index1 &lt; x &amp;&amp; index2 &lt; y) &#123;\n            int difference &#x3D; subsequence1[index1] - subsequence2[index2];\n            if (difference !&#x3D; 0) &#123;\n                return difference; &#x2F;&#x2F; 比较两个子序列当前位置的元素，不相等则直接返回差值\n            &#125;\n            index1++; &#x2F;&#x2F; 继续比较下一个位置\n            index2++;\n        &#125;\n        return (x - index1) - (y - index2); &#x2F;&#x2F; 返回长度较长的子序列对应位置多出的元素个数\n    &#125;\n&#125;;</code></pre>\n\n\n\n<hr>\n<p>作者：力扣官方题解<br>链接：<a href=\"https://leetcode.cn/problems/create-maximum-number/solutions/505931/pin-jie-zui-da-shu-by-leetcode-solution/\">https://leetcode.cn/problems/create-maximum-number/solutions/505931/pin-jie-zui-da-shu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入:\nnums1 &#x3D; [3, 4, 6, 5]\nnums2 &#x3D; [9, 1, 2, 5, 8, 3]\nk &#x3D; 5\n输出:\n[9, 8, 6, 5, 3]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入:\nnums1 &#x3D; [6, 7]\nnums2 &#x3D; [6, 0, 4]\nk &#x3D; 5\n输出:\n[6, 7, 6, 0, 4]</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入:\nnums1 &#x3D; [3, 9]\nnums2 &#x3D; [8, 9]\nk &#x3D; 3\n输出:\n[9, 8, 9]</code></pre>\n\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>单调栈</li>\n</ul>\n<p>为了找到长度为 kkk 的最大数，需要从两个数组中分别选出最大的子序列，这两个子序列的长度之和为 kkk，然后将这两个子序列合并得到最大数。两个子序列的长度最小为 000，最大不能超过 kkk 且不能超过对应的数组长度。</p>\n<p>令数组 $\\textit{nums}_1$ 的长度为 m，数组 $\\textit{nums}_2$的长度为 n，则需要从数组 $\\textit{nums}_1$中选出长度为 x 的子序列，以及从数组$\\textit{nums}_2$ 中选出长度为 yyy 的子序列，其中$x+y&#x3D;k$，且满足$0 \\le x \\le m$和$0 \\le y \\le n$。需要遍历所有可能的 $x$ 和 $y$ 的值，对于每一组$x$ 和 $y$ 的值，得到最大数。在整个过程中维护可以通过拼接得到的最大数。</p>\n<p>对于每一组 $x$ 和 $y$ 的值，得到最大数的过程分成两步，第一步是分别从两个数组中得到指定长度的最大子序列，第二步是将两个最大子序列合并。</p>\n<p>第一步可以通过单调栈实现。单调栈满足从栈底到栈顶的元素单调递减，从左到右遍历数组，遍历过程中维护单调栈内的元素，需要保证遍历结束之后单调栈内的元素个数等于指定的最大子序列的长度。遍历结束之后，将从栈底到栈顶的元素依次拼接，即得到最大子序列。</p>\n<p>第二步需要自定义比较方法。首先比较两个子序列的当前元素，如果两个当前元素不同，则选其中较大的元素作为下一个合并的元素，否则需要比较后面的所有元素才能决定选哪个元素作为下一个合并的元素。</p>\n<p>在下面的代码中，单调栈使用数组实现，数组最左侧为栈底。使用数组实现，可以直接从左到右遍历数组得到最大子序列。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123;\n        int m &#x3D; nums1.size(), n &#x3D; nums2.size();\n        vector&lt;int&gt; maxSubsequence(k, 0); &#x2F;&#x2F; 存储最大的子序列结果\n        int start &#x3D; max(0, k - n), end &#x3D; min(k, m); &#x2F;&#x2F; 确定子序列长度的起始和结束范围\n        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;\n            vector&lt;int&gt; subsequence1(MaxSubsequence(nums1, i)); &#x2F;&#x2F; 从nums1中取i个数字组成的最大子序列\n            vector&lt;int&gt; subsequence2(MaxSubsequence(nums2, k - i)); &#x2F;&#x2F; 从nums2中取k-i个数字组成的最大子序列\n            vector&lt;int&gt; curMaxSubsequence(merge(subsequence1, subsequence2)); &#x2F;&#x2F; 合并两个子序列得到当前最大结果\n            if (compare(curMaxSubsequence, 0, maxSubsequence, 0) &gt; 0) &#123;\n                maxSubsequence.swap(curMaxSubsequence); &#x2F;&#x2F; 如果当前最大结果更大，则更新maxSubsequence\n            &#125;\n        &#125;\n        return maxSubsequence; &#x2F;&#x2F; 返回最终的最大子序列结果\n    &#125;\n\n    vector&lt;int&gt; MaxSubsequence(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int length &#x3D; nums.size();\n        vector&lt;int&gt; stack(k, 0); &#x2F;&#x2F; 使用stack来构建最大子序列\n        int top &#x3D; -1;\n        int remain &#x3D; length - k; &#x2F;&#x2F; 记录还需要丢弃的数字个数\n        for (int i &#x3D; 0; i &lt; length; i++) &#123;\n            int num &#x3D; nums[i];\n            while (top &gt;&#x3D; 0 &amp;&amp; stack[top] &lt; num &amp;&amp; remain &gt; 0) &#123;\n                top--; &#x2F;&#x2F; 当前数字比栈顶元素大，可以丢弃栈顶元素，继续判断下一个栈顶元素\n                remain--; &#x2F;&#x2F; 更新需要丢弃的数字个数\n            &#125;\n            if (top &lt; k - 1) &#123;\n                stack[++top] &#x3D; num; &#x2F;&#x2F; 将当前数字加入栈中\n            &#125; else &#123;\n                remain--; &#x2F;&#x2F; 否则，当前数字比栈顶元素小，丢弃当前数字，继续判断下一个数字\n            &#125;\n        &#125;\n        return stack; &#x2F;&#x2F; 返回最终构建的最大子序列\n    &#125;\n\n    vector&lt;int&gt; merge(vector&lt;int&gt;&amp; subsequence1, vector&lt;int&gt;&amp; subsequence2) &#123;\n        int x &#x3D; subsequence1.size(), y &#x3D; subsequence2.size();\n        if (x &#x3D;&#x3D; 0) &#123;\n            return subsequence2; &#x2F;&#x2F; 如果subsequence1为空，则直接返回subsequence2\n        &#125;\n        if (y &#x3D;&#x3D; 0) &#123;\n            return subsequence1; &#x2F;&#x2F; 如果subsequence2为空，则直接返回subsequence1\n        &#125;\n        int mergeLength &#x3D; x + y;\n        vector&lt;int&gt; merged(mergeLength); &#x2F;&#x2F; 合并结果的数组\n        int index1 &#x3D; 0, index2 &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; mergeLength; i++) &#123;\n            if (compare(subsequence1, index1, subsequence2, index2) &gt; 0) &#123;\n                merged[i] &#x3D; subsequence1[index1++]; &#x2F;&#x2F; 如果subsequence1的当前元素较大，则加入到合并结果中\n            &#125; else &#123;\n                merged[i] &#x3D; subsequence2[index2++]; &#x2F;&#x2F; 否则，加入subsequence2的当前元素到合并结果中\n            &#125;\n        &#125;\n        return merged; &#x2F;&#x2F; 返回合并的结果\n    &#125;\n\n    int compare(vector&lt;int&gt;&amp; subsequence1, int index1, vector&lt;int&gt;&amp; subsequence2, int index2) &#123;\n        int x &#x3D; subsequence1.size(), y &#x3D; subsequence2.size();\n        while (index1 &lt; x &amp;&amp; index2 &lt; y) &#123;\n            int difference &#x3D; subsequence1[index1] - subsequence2[index2];\n            if (difference !&#x3D; 0) &#123;\n                return difference; &#x2F;&#x2F; 比较两个子序列当前位置的元素，不相等则直接返回差值\n            &#125;\n            index1++; &#x2F;&#x2F; 继续比较下一个位置\n            index2++;\n        &#125;\n        return (x - index1) - (y - index2); &#x2F;&#x2F; 返回长度较长的子序列对应位置多出的元素个数\n    &#125;\n&#125;;</code></pre>\n\n\n\n<hr>\n<p>作者：力扣官方题解<br>链接：<a href=\"https://leetcode.cn/problems/create-maximum-number/solutions/505931/pin-jie-zui-da-shu-by-leetcode-solution/\">https://leetcode.cn/problems/create-maximum-number/solutions/505931/pin-jie-zui-da-shu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}