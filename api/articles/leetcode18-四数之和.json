{"title":"leetcode18.四数之和","slug":"leetcode18-四数之和","date":"2023-10-20T01:34:41.000Z","updated":"2023-10-20T01:36:18.371Z","comments":true,"path":"api/articles/leetcode18-四数之和.json","excerpt":"题目给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：0 &lt;= a, b, c, d &lt; na、b、c 和 d 互不相同nums[a] + nums[b] + nums[c] + nums[d] == target你可以按 任意顺序 返回答案 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>\n<ul>\n<li><code>0 &lt;= a, b, c, d &lt; n</code></li>\n<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>\n<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8\n输出：[[2,2,2,2]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>双指针法</li>\n</ul>\n<p>双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是<code>O(n^2)</code>，四数之和的时间复杂度是<code>O(n^3) </code>。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        sort(nums.begin(), nums.end());\n        for (int k &#x3D; 0; k &lt; nums.size(); k++) &#123;\n            &#x2F;&#x2F; 剪枝处理\n            if (nums[k] &gt; target &amp;&amp; nums[k] &gt;&#x3D; 0) &#123;\n            \tbreak; &#x2F;&#x2F; 这里使用break，统一通过最后的return返回\n            &#125;\n            &#x2F;&#x2F; 对nums[k]去重\n            if (k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) &#123;\n                continue;\n            &#125;\n            for (int i &#x3D; k + 1; i &lt; nums.size(); i++) &#123;\n                &#x2F;&#x2F; 2级剪枝处理\n                if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;&#x3D; 0) &#123;\n                    break;\n                &#125;\n\n                &#x2F;&#x2F; 对nums[i]去重\n                if (i &gt; k + 1 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;\n                    continue;\n                &#125;\n                int left &#x3D; i + 1;\n                int right &#x3D; nums.size() - 1;\n                while (right &gt; left) &#123;\n                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出\n                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;\n                        right--;\n                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出\n                    &#125; else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;\n                        left++;\n                    &#125; else &#123;\n                        result.push_back(vector&lt;int&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);\n                        &#x2F;&#x2F; 对nums[left]和nums[right]去重\n                        while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;\n                        while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;\n\n                        &#x2F;&#x2F; 找到答案时，双指针同时收缩\n                        right--;\n                        left++;\n                    &#125;\n                &#125;\n\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8\n输出：[[2,2,2,2]]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>双指针法</li>\n</ul>\n<p>双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是<code>O(n^2)</code>，四数之和的时间复杂度是<code>O(n^3) </code>。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        sort(nums.begin(), nums.end());\n        for (int k &#x3D; 0; k &lt; nums.size(); k++) &#123;\n            &#x2F;&#x2F; 剪枝处理\n            if (nums[k] &gt; target &amp;&amp; nums[k] &gt;&#x3D; 0) &#123;\n            \tbreak; &#x2F;&#x2F; 这里使用break，统一通过最后的return返回\n            &#125;\n            &#x2F;&#x2F; 对nums[k]去重\n            if (k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) &#123;\n                continue;\n            &#125;\n            for (int i &#x3D; k + 1; i &lt; nums.size(); i++) &#123;\n                &#x2F;&#x2F; 2级剪枝处理\n                if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;&#x3D; 0) &#123;\n                    break;\n                &#125;\n\n                &#x2F;&#x2F; 对nums[i]去重\n                if (i &gt; k + 1 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;\n                    continue;\n                &#125;\n                int left &#x3D; i + 1;\n                int right &#x3D; nums.size() - 1;\n                while (right &gt; left) &#123;\n                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出\n                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;\n                        right--;\n                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出\n                    &#125; else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;\n                        left++;\n                    &#125; else &#123;\n                        result.push_back(vector&lt;int&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);\n                        &#x2F;&#x2F; 对nums[left]和nums[right]去重\n                        while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;\n                        while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;\n\n                        &#x2F;&#x2F; 找到答案时，双指针同时收缩\n                        right--;\n                        left++;\n                    &#125;\n                &#125;\n\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}