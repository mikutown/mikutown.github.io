{"title":"leetcode191.位1的个数","slug":"leetcode191-位1的个数","date":"2023-07-17T11:57:38.000Z","updated":"2023-07-17T12:01:54.536Z","comments":true,"path":"api/articles/leetcode191-位1的个数.json","excerpt":"题目编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F\">汉明重量</a>）。</p>\n <span id=\"more\"></span>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n<li>在 Java 中，编译器使用<a href=\"https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284\">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>\n</ul>\n<p><strong>进阶</strong>：</p>\n<ul>\n<li>如果多次调用这个函数，你将如何优化你的算法？</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>循环求解</li>\n</ul>\n<p>思路：当输入的数字为n时，我们想判断它的二进制数字的最后一位是否为1，可以使用<code>n &amp; 1</code>得到，如果结果为1，则说明他的最后一位是1，否则则为0，当判断完最后一位时，我们直接使用<code>&gt;&gt;</code>对n进行除以2的操作。C++代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int hammingWeight(uint32_t n) &#123;\n        int count &#x3D; 0; &#x2F;&#x2F; 初始化答案\n        while (n !&#x3D; 0) &#123;\n            count +&#x3D; n &amp; 1; &#x2F;&#x2F; 检查最低位是否为 1\n            n &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 将数字右移一位，相当于除以 2\n        &#125;\n        return count; &#x2F;&#x2F; 返回count值\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>提示：</strong></p>\n<ul>\n<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n<li>在 Java 中，编译器使用<a href=\"https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284\">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：n &#x3D; 11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>\n</ul>\n<p><strong>进阶</strong>：</p>\n<ul>\n<li>如果多次调用这个函数，你将如何优化你的算法？</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>循环求解</li>\n</ul>\n<p>思路：当输入的数字为n时，我们想判断它的二进制数字的最后一位是否为1，可以使用<code>n &amp; 1</code>得到，如果结果为1，则说明他的最后一位是1，否则则为0，当判断完最后一位时，我们直接使用<code>&gt;&gt;</code>对n进行除以2的操作。C++代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int hammingWeight(uint32_t n) &#123;\n        int count &#x3D; 0; &#x2F;&#x2F; 初始化答案\n        while (n !&#x3D; 0) &#123;\n            count +&#x3D; n &amp; 1; &#x2F;&#x2F; 检查最低位是否为 1\n            n &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 将数字右移一位，相当于除以 2\n        &#125;\n        return count; &#x2F;&#x2F; 返回count值\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}