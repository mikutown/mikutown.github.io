{"title":"leetcode976.三角形的最大周长","slug":"leetcode976-三角形的最大周长","date":"2023-09-12T12:29:18.000Z","updated":"2023-09-12T12:30:16.478Z","comments":true,"path":"api/articles/leetcode976-三角形的最大周长.json","excerpt":"题目给定由一些正数（代表长度）组成的数组 nums ，返回 由其中三个长度组成的、面积不为零的三角形的最大周长 。如果不能形成任何面积不为零的三角形，返回 0。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定由一些正数（代表长度）组成的数组 <code>nums</code> ，返回 <em>由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长</em> 。如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [2,1,2]\n输出：5\n解释：你可以用三个边长组成一个三角形:1 2 2。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,2,1,10]\n输出：0\n解释：\n你不能用边长 1,1,2 来组成三角形。\n不能用边长 1,1,10 来构成三角形。\n不能用边长 1、2 和 10 来构成三角形。\n因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 104</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 106</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>排序解答</li>\n</ul>\n<ol>\n<li>首先对输入数组 <code>nums</code> 进行排序，按照从大到小的顺序排列。</li>\n<li>然后，遍历排序后的数组，从大到小依次选取三个数 <code>a</code>, <code>b</code>, <code>c</code>，判断是否满足组成三角形的条件，即 <code>a + b &gt; c</code> 和 <code>a - b &lt; c</code>。如果满足条件，就找到了最大周长的三角形，直接返回 <code>a + b + c</code>。</li>\n<li>如果遍历完整个数组都没有找到满足条件的三角形，说明不存在符合条件的三角形，返回0。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    \n    int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; 将数组从大到小排序\n        sort(nums.begin(), nums.end(), [](int a, int b) &#123;\n            return a &gt; b;\n        &#125;);\n        int n &#x3D; nums.size();\n        &#x2F;&#x2F; 开始遍历寻找最大的能组成三角形的三个数\n        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;\n            if (nums[i] &lt; nums[i + 1] + nums[i + 2]) return nums[i] + nums[i + 1] + nums[i + 2];\n        &#125;\n        return 0;\n    &#125;\n    \n&#125;;</code></pre>\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [2,1,2]\n输出：5\n解释：你可以用三个边长组成一个三角形:1 2 2。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,2,1,10]\n输出：0\n解释：\n你不能用边长 1,1,2 来组成三角形。\n不能用边长 1,1,10 来构成三角形。\n不能用边长 1、2 和 10 来构成三角形。\n因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 104</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 106</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>排序解答</li>\n</ul>\n<ol>\n<li>首先对输入数组 <code>nums</code> 进行排序，按照从大到小的顺序排列。</li>\n<li>然后，遍历排序后的数组，从大到小依次选取三个数 <code>a</code>, <code>b</code>, <code>c</code>，判断是否满足组成三角形的条件，即 <code>a + b &gt; c</code> 和 <code>a - b &lt; c</code>。如果满足条件，就找到了最大周长的三角形，直接返回 <code>a + b + c</code>。</li>\n<li>如果遍历完整个数组都没有找到满足条件的三角形，说明不存在符合条件的三角形，返回0。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    \n    int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; 将数组从大到小排序\n        sort(nums.begin(), nums.end(), [](int a, int b) &#123;\n            return a &gt; b;\n        &#125;);\n        int n &#x3D; nums.size();\n        &#x2F;&#x2F; 开始遍历寻找最大的能组成三角形的三个数\n        for (int i &#x3D; 0; i &lt; n - 2; i++) &#123;\n            if (nums[i] &lt; nums[i + 1] + nums[i + 2]) return nums[i] + nums[i + 1] + nums[i + 2];\n        &#125;\n        return 0;\n    &#125;\n    \n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}