{"title":"leetcode102.二叉树的层序遍历","slug":"leetcode102-二叉树的层序遍历","date":"2023-03-14T01:57:14.000Z","updated":"2023-03-14T02:16:31.959Z","comments":true,"path":"api/articles/leetcode102-二叉树的层序遍历.json","excerpt":null,"covers":["http://cdn.leafii.top/img/tree1.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：[[3],[9,20],[15,7]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[[1]]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用队列辅助层序遍历</li>\n</ol>\n<p>注意看这个题的输入与输出，输出的动态数组的元素是元素为整型的数组，比如<code>[[3],[9,20],[15,7]]</code>.因此如果只定义一个队列辅助遍历，无法清晰的区分每层的元素应该插入到哪个数组中，比如如果只使用一个队列进行层次遍历，得到的结果只能是<code>[3,9,20,15,7]</code>，无法从这个结果中得知清晰的二叉树层次结构，所以在这里定义两个队列，首先向一个队列中塞入元素，接着对队首元素进行pop并且将队首元素的左右子树节点分别塞入另一队列中，再将结果数组并入result数组中，再将另一个队列进行同样的遍历操作，具体的C++实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;\n        &#x2F;&#x2F; 定义两个队列 分别为q和another_q 用于层次遍历\n        queue&lt;TreeNode*&gt; q;\n        queue&lt;TreeNode*&gt; another_q;\n        &#x2F;&#x2F; 定义结果数组 其元素为元素为int类型的数组\n        vector&lt;vector&lt;int&gt;&gt; result;    \n        &#x2F;&#x2F; 若根节点非空 则将根节点push进队列q中 \n        if (root !&#x3D; nullptr) &#123;\n            q.push(root);\n        &#125;\n        &#x2F;&#x2F; 当q或者another_q队列非空时 进行遍历操作\n        while (!q.empty()|| !another_q.empty()) &#123;\n            &#x2F;&#x2F; 定义元素为int的临时数组 用于存储每一层的元素\n            vector&lt;int&gt; temp_vector;\n            &#x2F;&#x2F; 当队列q非空时 将队列q的元素逐个出队\n            while (!q.empty()) &#123;\n                TreeNode* temp_node &#x3D; q.front();\n                &#x2F;&#x2F; 向临时数组中塞入节点的值\n                temp_vector.push_back(temp_node-&gt;val);\n                &#x2F;&#x2F; 塞入之后 将对应元素出队\n                q.pop();\n                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中\n                if (temp_node-&gt;left !&#x3D; nullptr) &#123;\n                    another_q.push(temp_node-&gt;left);\n                &#125;\n                if (temp_node-&gt;right !&#x3D; nullptr) &#123;\n                    another_q.push(temp_node-&gt;right);\n                &#125;\n            &#125;\n            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组\n            if (temp_vector.size() !&#x3D; 0) &#123;\n                result.push_back(temp_vector);\n                temp_vector.clear();\n            &#125;\n            &#x2F;&#x2F; 当另一个队列another_q非空时 将队列another_q的元素逐个出队\n            while (!another_q.empty()) &#123;\n                TreeNode* temp_node &#x3D; another_q.front();\n                &#x2F;&#x2F; 向临时数组中塞入节点的值\n                temp_vector.push_back(temp_node-&gt;val);\n                &#x2F;&#x2F; 塞入之后 将对应元素出队\n                another_q.pop();\n                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中\n                if (temp_node-&gt;left !&#x3D; nullptr) &#123;\n                    q.push(temp_node-&gt;left);\n                &#125;\n                if (temp_node-&gt;right !&#x3D; nullptr) &#123;\n                    q.push(temp_node-&gt;right);\n                &#125;\n            &#125;\n            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组\n            if (temp_vector.size() !&#x3D; 0) &#123;\n                result.push_back(temp_vector);\n                temp_vector.clear();\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 返回结果数组\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n\n\n","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/tree1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：[[3],[9,20],[15,7]]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[[1]]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>使用队列辅助层序遍历</li>\n</ol>\n<p>注意看这个题的输入与输出，输出的动态数组的元素是元素为整型的数组，比如<code>[[3],[9,20],[15,7]]</code>.因此如果只定义一个队列辅助遍历，无法清晰的区分每层的元素应该插入到哪个数组中，比如如果只使用一个队列进行层次遍历，得到的结果只能是<code>[3,9,20,15,7]</code>，无法从这个结果中得知清晰的二叉树层次结构，所以在这里定义两个队列，首先向一个队列中塞入元素，接着对队首元素进行pop并且将队首元素的左右子树节点分别塞入另一队列中，再将结果数组并入result数组中，再将另一个队列进行同样的遍历操作，具体的C++实现代码如下：</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;\n        &#x2F;&#x2F; 定义两个队列 分别为q和another_q 用于层次遍历\n        queue&lt;TreeNode*&gt; q;\n        queue&lt;TreeNode*&gt; another_q;\n        &#x2F;&#x2F; 定义结果数组 其元素为元素为int类型的数组\n        vector&lt;vector&lt;int&gt;&gt; result;    \n        &#x2F;&#x2F; 若根节点非空 则将根节点push进队列q中 \n        if (root !&#x3D; nullptr) &#123;\n            q.push(root);\n        &#125;\n        &#x2F;&#x2F; 当q或者another_q队列非空时 进行遍历操作\n        while (!q.empty()|| !another_q.empty()) &#123;\n            &#x2F;&#x2F; 定义元素为int的临时数组 用于存储每一层的元素\n            vector&lt;int&gt; temp_vector;\n            &#x2F;&#x2F; 当队列q非空时 将队列q的元素逐个出队\n            while (!q.empty()) &#123;\n                TreeNode* temp_node &#x3D; q.front();\n                &#x2F;&#x2F; 向临时数组中塞入节点的值\n                temp_vector.push_back(temp_node-&gt;val);\n                &#x2F;&#x2F; 塞入之后 将对应元素出队\n                q.pop();\n                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中\n                if (temp_node-&gt;left !&#x3D; nullptr) &#123;\n                    another_q.push(temp_node-&gt;left);\n                &#125;\n                if (temp_node-&gt;right !&#x3D; nullptr) &#123;\n                    another_q.push(temp_node-&gt;right);\n                &#125;\n            &#125;\n            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组\n            if (temp_vector.size() !&#x3D; 0) &#123;\n                result.push_back(temp_vector);\n                temp_vector.clear();\n            &#125;\n            &#x2F;&#x2F; 当另一个队列another_q非空时 将队列another_q的元素逐个出队\n            while (!another_q.empty()) &#123;\n                TreeNode* temp_node &#x3D; another_q.front();\n                &#x2F;&#x2F; 向临时数组中塞入节点的值\n                temp_vector.push_back(temp_node-&gt;val);\n                &#x2F;&#x2F; 塞入之后 将对应元素出队\n                another_q.pop();\n                &#x2F;&#x2F; 判断出队的元素是否有左右节点并将其塞入另一个队列中\n                if (temp_node-&gt;left !&#x3D; nullptr) &#123;\n                    q.push(temp_node-&gt;left);\n                &#125;\n                if (temp_node-&gt;right !&#x3D; nullptr) &#123;\n                    q.push(temp_node-&gt;right);\n                &#125;\n            &#125;\n            &#x2F;&#x2F; 若临时数组非空 则将其插入结果数组中 并清空临时数组\n            if (temp_vector.size() !&#x3D; 0) &#123;\n                result.push_back(temp_vector);\n                temp_vector.clear();\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 返回结果数组\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n\n\n","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}