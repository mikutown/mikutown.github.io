{"title":"leetcode845.数组中的最长山脉","slug":"leetcode845-数组中的最长山脉","date":"2023-05-15T23:54:56.000Z","updated":"2023-05-16T00:02:54.205Z","comments":true,"path":"api/articles/leetcode845-数组中的最长山脉.json","excerpt":"题目把符合下列属性的数组 arr 称为 山脉数组 ：arr.length &gt;= 3存在下标i（0 &lt; i &lt; arr.length - 1），满足arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>把符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：</p>\n<ul>\n<li><code>arr.length &gt;= 3</code></li>\n<li>存在下标<code>i（0 &lt; i &lt; arr.length - 1），</code>满足<ul>\n<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>\n<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n</ul>\n</li>\n</ul>\n<p>给出一个整数数组 <code>arr</code>，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 <code>0</code> 。</p>\n<span id=\"more\"></span> \n\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [2,1,4,7,3,2,5]\n输出：5\n解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [2,2,2]\n输出：0\n解释：不存在山脉子数组。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= arr.length &lt;= 104</code></li>\n<li><code>0 &lt;= arr[i] &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>三指针法</li>\n</ul>\n<ol>\n<li>首先，我们可以初始化三个指针：left、right和peak。<ul>\n<li>left指针指向山脉数组的起点，即数组的第一个元素。</li>\n<li>right指针指向山脉数组的终点，即数组的最后一个元素。</li>\n<li>peak指针指向山脉数组的顶峰。</li>\n</ul>\n</li>\n<li>我们可以通过移动right指针来找到山脉数组的终点。当数组的下一个元素比当前元素大的时候，我们可以继续移动right指针。如果下一个元素比当前元素小，我们将找到了山脉数组的终点。</li>\n<li>一旦我们找到了山脉数组的终点，我们需要移动left指针。我们需要找到山脉数组的起点，即数组的第一个元素。我们可以通过移动left指针来找到山脉数组的起点。当数组的下一个元素比当前元素大的时候，我们可以继续移动left指针。</li>\n<li>当我们找到山脉数组的起点和终点后，我们需要更新peak指针的位置。我们可以通过遍历山脉数组的起点到终点之间的元素，找到最大的元素，并更新peak指针的位置。</li>\n<li>最后，我们可以计算山脉数组的长度，即右边界(right)减去左边界(left)再加1。如果山脉数组的长度大于等于3，就返回该长度；否则，返回0。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int longestMountain(vector&lt;int&gt;&amp; A) &#123;\n        int n &#x3D; A.size();\n        int left &#x3D; 0, right &#x3D; 0, peak &#x3D; 0;\n        int longestMountainLength &#x3D; 0;\n\n        while (left &lt; n) &#123;\n            right &#x3D; left;\n            &#x2F;&#x2F; 找到山脉数组的终点\n            if (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;\n                while (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;\n                    right++;\n                &#125;\n                &#x2F;&#x2F; 找到山脉数组的起点\n                if (right + 1 &lt; n &amp;&amp; A[right] &gt; A[right + 1]) &#123;\n                    peak &#x3D; right;\n                    while (peak + 1 &lt; n &amp;&amp; A[peak] &gt; A[peak + 1]) &#123;\n                        peak++;\n                    &#125;\n                    &#x2F;&#x2F; 更新最长山脉的长度\n                    longestMountainLength &#x3D; max(longestMountainLength, peak - left + 1);\n                &#125;\n            &#125;\n            left &#x3D; max(right, left + 1);\n        &#125;\n\n        return longestMountainLength &gt;&#x3D; 3 ? longestMountainLength : 0;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>仅用一趟扫描,并仅用O(1)空间复杂度解决问题</li>\n</ul>\n<p>解题思路：</p>\n<ol>\n<li><p>初始化变量：</p>\n<ul>\n<li><code>up</code>：表示上升的长度（山脉的左半边）</li>\n<li><code>down</code>：表示下降的长度（山脉的右半边）</li>\n<li><code>maxLen</code>：表示最长山脉数组的长度</li>\n</ul>\n</li>\n<li><p>从数组的第二个元素开始遍历：</p>\n<ul>\n<li><p>如果当前元素 <code>A[i]</code> 大于前一个元素 <code>A[i-1]</code>，则表示处于上升阶段，递增 <code>up</code> 的值，同时重置 <code>down</code> 的值为0。</p>\n</li>\n<li><p>如果当前元素 </p>\n<pre class=\"language-none\"><code class=\"language-none\">A[i]</code></pre>\n\n<p> 小于前一个元素 </p>\n<pre class=\"language-none\"><code class=\"language-none\">A[i-1]</code></pre>\n\n<p>：</p>\n<ul>\n<li>如果 <code>up</code> 大于0，表示已经处于山脉的下降阶段，递增 <code>down</code> 的值。</li>\n<li>如果 <code>up</code> 等于0，表示还没有开始上升阶段，不进行任何操作。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>当 <code>down</code> 大于0时，表示找到了山脉数组的终点，更新 <code>maxLen</code> 的值。然后将指针移动到山脉数组的下一个元素，即 <code>i</code> 加1，并重置 <code>up</code> 和 <code>down</code> 的值为0。</p>\n</li>\n<li><p>最后返回 <code>maxLen</code>，即为最长山脉数组的长度。</p>\n</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int longestMountain(vector&lt;int&gt;&amp; A) &#123;\n        int n &#x3D; A.size();\n        int up &#x3D; 0, down &#x3D; 0;  &#x2F;&#x2F; 上升和下降的长度\n        int maxLen &#x3D; 0;  &#x2F;&#x2F; 最长山脉数组的长度\n\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            if (A[i] &gt; A[i-1]) &#123;  &#x2F;&#x2F; 上升阶段\n                if (down &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于下降阶段，则重置上升和下降长度\n                    up &#x3D; 0;\n                    down &#x3D; 0;\n                &#125;\n                up++;  &#x2F;&#x2F; 递增上升长度\n            &#125; else if (A[i] &lt; A[i-1]) &#123;  &#x2F;&#x2F; 下降阶段\n                if (up &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于上升阶段\n                    down++;  &#x2F;&#x2F; 递增下降长度\n                    maxLen &#x3D; max(maxLen, up + down + 1);  &#x2F;&#x2F; 更新最长山脉数组的长度\n                &#125;\n            &#125; else &#123;  &#x2F;&#x2F; 平稳阶段，重置上升和下降长度\n                up &#x3D; 0;\n                down &#x3D; 0;\n            &#125;\n        &#125;\n\n        return maxLen;\n    &#125;\n\n&#125;;</code></pre>\n\n\n\n","more":"<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [2,1,4,7,3,2,5]\n输出：5\n解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：arr &#x3D; [2,2,2]\n输出：0\n解释：不存在山脉子数组。</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= arr.length &lt;= 104</code></li>\n<li><code>0 &lt;= arr[i] &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>三指针法</li>\n</ul>\n<ol>\n<li>首先，我们可以初始化三个指针：left、right和peak。<ul>\n<li>left指针指向山脉数组的起点，即数组的第一个元素。</li>\n<li>right指针指向山脉数组的终点，即数组的最后一个元素。</li>\n<li>peak指针指向山脉数组的顶峰。</li>\n</ul>\n</li>\n<li>我们可以通过移动right指针来找到山脉数组的终点。当数组的下一个元素比当前元素大的时候，我们可以继续移动right指针。如果下一个元素比当前元素小，我们将找到了山脉数组的终点。</li>\n<li>一旦我们找到了山脉数组的终点，我们需要移动left指针。我们需要找到山脉数组的起点，即数组的第一个元素。我们可以通过移动left指针来找到山脉数组的起点。当数组的下一个元素比当前元素大的时候，我们可以继续移动left指针。</li>\n<li>当我们找到山脉数组的起点和终点后，我们需要更新peak指针的位置。我们可以通过遍历山脉数组的起点到终点之间的元素，找到最大的元素，并更新peak指针的位置。</li>\n<li>最后，我们可以计算山脉数组的长度，即右边界(right)减去左边界(left)再加1。如果山脉数组的长度大于等于3，就返回该长度；否则，返回0。</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int longestMountain(vector&lt;int&gt;&amp; A) &#123;\n        int n &#x3D; A.size();\n        int left &#x3D; 0, right &#x3D; 0, peak &#x3D; 0;\n        int longestMountainLength &#x3D; 0;\n\n        while (left &lt; n) &#123;\n            right &#x3D; left;\n            &#x2F;&#x2F; 找到山脉数组的终点\n            if (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;\n                while (right + 1 &lt; n &amp;&amp; A[right] &lt; A[right + 1]) &#123;\n                    right++;\n                &#125;\n                &#x2F;&#x2F; 找到山脉数组的起点\n                if (right + 1 &lt; n &amp;&amp; A[right] &gt; A[right + 1]) &#123;\n                    peak &#x3D; right;\n                    while (peak + 1 &lt; n &amp;&amp; A[peak] &gt; A[peak + 1]) &#123;\n                        peak++;\n                    &#125;\n                    &#x2F;&#x2F; 更新最长山脉的长度\n                    longestMountainLength &#x3D; max(longestMountainLength, peak - left + 1);\n                &#125;\n            &#125;\n            left &#x3D; max(right, left + 1);\n        &#125;\n\n        return longestMountainLength &gt;&#x3D; 3 ? longestMountainLength : 0;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>仅用一趟扫描,并仅用O(1)空间复杂度解决问题</li>\n</ul>\n<p>解题思路：</p>\n<ol>\n<li><p>初始化变量：</p>\n<ul>\n<li><code>up</code>：表示上升的长度（山脉的左半边）</li>\n<li><code>down</code>：表示下降的长度（山脉的右半边）</li>\n<li><code>maxLen</code>：表示最长山脉数组的长度</li>\n</ul>\n</li>\n<li><p>从数组的第二个元素开始遍历：</p>\n<ul>\n<li><p>如果当前元素 <code>A[i]</code> 大于前一个元素 <code>A[i-1]</code>，则表示处于上升阶段，递增 <code>up</code> 的值，同时重置 <code>down</code> 的值为0。</p>\n</li>\n<li><p>如果当前元素 </p>\n<pre class=\"language-none\"><code class=\"language-none\">A[i]</code></pre>\n\n<p> 小于前一个元素 </p>\n<pre class=\"language-none\"><code class=\"language-none\">A[i-1]</code></pre>\n\n<p>：</p>\n<ul>\n<li>如果 <code>up</code> 大于0，表示已经处于山脉的下降阶段，递增 <code>down</code> 的值。</li>\n<li>如果 <code>up</code> 等于0，表示还没有开始上升阶段，不进行任何操作。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>当 <code>down</code> 大于0时，表示找到了山脉数组的终点，更新 <code>maxLen</code> 的值。然后将指针移动到山脉数组的下一个元素，即 <code>i</code> 加1，并重置 <code>up</code> 和 <code>down</code> 的值为0。</p>\n</li>\n<li><p>最后返回 <code>maxLen</code>，即为最长山脉数组的长度。</p>\n</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int longestMountain(vector&lt;int&gt;&amp; A) &#123;\n        int n &#x3D; A.size();\n        int up &#x3D; 0, down &#x3D; 0;  &#x2F;&#x2F; 上升和下降的长度\n        int maxLen &#x3D; 0;  &#x2F;&#x2F; 最长山脉数组的长度\n\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            if (A[i] &gt; A[i-1]) &#123;  &#x2F;&#x2F; 上升阶段\n                if (down &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于下降阶段，则重置上升和下降长度\n                    up &#x3D; 0;\n                    down &#x3D; 0;\n                &#125;\n                up++;  &#x2F;&#x2F; 递增上升长度\n            &#125; else if (A[i] &lt; A[i-1]) &#123;  &#x2F;&#x2F; 下降阶段\n                if (up &gt; 0) &#123;  &#x2F;&#x2F; 如果之前处于上升阶段\n                    down++;  &#x2F;&#x2F; 递增下降长度\n                    maxLen &#x3D; max(maxLen, up + down + 1);  &#x2F;&#x2F; 更新最长山脉数组的长度\n                &#125;\n            &#125; else &#123;  &#x2F;&#x2F; 平稳阶段，重置上升和下降长度\n                up &#x3D; 0;\n                down &#x3D; 0;\n            &#125;\n        &#125;\n\n        return maxLen;\n    &#125;\n\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}