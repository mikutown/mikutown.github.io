{"title":"leetcode:35.搜索插入位置","slug":"leetcode-35-搜索插入位置","date":"2023-01-16T07:04:57.000Z","updated":"2023-01-16T07:11:18.777Z","comments":true,"path":"api/articles/leetcode-35-搜索插入位置.json","excerpt":"题目给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,3,5,6], target &#x3D; 5\n输出: 2</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,3,5,6], target &#x3D; 2\n输出: 1</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,3,5,6], target &#x3D; 7\n输出: 4</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li>\n<li><code>-104 &lt;= target &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>顺序遍历整个数组的暴力解法</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)\n        &#123;\n            if(nums[i] &#x3D;&#x3D; target)\n            &#123;\n                return i;\n            &#125;\n            else if(nums[i] &gt; target)&#123;\n                return i;\n            &#125;\n        &#125;\n        return nums.size();\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ol start=\"2\">\n<li>使用二分查找法进行位置的查找</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int l&#x3D;0,r&#x3D;nums.size()-1;\n&#x2F;&#x2F; 我们定义target在左闭右闭的区间里，[left, right] ，当left&#x3D;&#x3D;right，区间[left, right]依然有效\n        while(l&lt;&#x3D;r)\n        &#123;\n            int mid&#x3D;l+(r-l)&#x2F;2;\n            if(nums[mid]&lt;target)\n            &#123;\n                l&#x3D;mid+1;&#x2F;&#x2F; target 在右区间，所以[middle + 1, right]\n            &#125;\n            else if(nums[mid]&#x3D;&#x3D;target)\n            &#123;\n                return mid;\n            &#125;\n            else\n            &#123;\n                r&#x3D;mid-1;&#x2F;&#x2F; target 在左区间，所以[left, middle - 1]\n            &#125;\n        &#125;\n        return r+1;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,3,5,6], target &#x3D; 5\n输出: 2</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,3,5,6], target &#x3D; 2\n输出: 1</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [1,3,5,6], target &#x3D; 7\n输出: 4</code></pre>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li>\n<li><code>-104 &lt;= target &lt;= 104</code></li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>顺序遍历整个数组的暴力解法</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)\n        &#123;\n            if(nums[i] &#x3D;&#x3D; target)\n            &#123;\n                return i;\n            &#125;\n            else if(nums[i] &gt; target)&#123;\n                return i;\n            &#125;\n        &#125;\n        return nums.size();\n    &#125;\n&#125;;</code></pre>\n\n\n\n<ol start=\"2\">\n<li>使用二分查找法进行位置的查找</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int l&#x3D;0,r&#x3D;nums.size()-1;\n&#x2F;&#x2F; 我们定义target在左闭右闭的区间里，[left, right] ，当left&#x3D;&#x3D;right，区间[left, right]依然有效\n        while(l&lt;&#x3D;r)\n        &#123;\n            int mid&#x3D;l+(r-l)&#x2F;2;\n            if(nums[mid]&lt;target)\n            &#123;\n                l&#x3D;mid+1;&#x2F;&#x2F; target 在右区间，所以[middle + 1, right]\n            &#125;\n            else if(nums[mid]&#x3D;&#x3D;target)\n            &#123;\n                return mid;\n            &#125;\n            else\n            &#123;\n                r&#x3D;mid-1;&#x2F;&#x2F; target 在左区间，所以[left, middle - 1]\n            &#125;\n        &#125;\n        return r+1;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}