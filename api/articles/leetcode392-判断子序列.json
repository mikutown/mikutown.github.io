{"title":"leetcode392.判断子序列","slug":"leetcode392-判断子序列","date":"2023-08-02T01:06:17.000Z","updated":"2023-08-02T01:25:24.844Z","comments":true,"path":"api/articles/leetcode392-判断子序列.json","excerpt":"题目给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>\n<span id=\"more\"></span>\n\n<p><strong>进阶：</strong></p>\n<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>\n<p><strong>致谢：</strong></p>\n<p>特别感谢 <a href=\"https://leetcode.com/pbrother/\">@pbrother </a>添加此问题并且创建所有测试用例。</p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：false</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 100</code></li>\n<li><code>0 &lt;= t.length &lt;= 10^4</code></li>\n<li>两个字符串都只由小写字符组成。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法：</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isSubsequence(string s, string t) &#123;\n        if (s.size() &#x3D;&#x3D; 0 &amp;&amp; t.size() &#x3D;&#x3D; 0) &#123;\n            return true; &#x2F;&#x2F; 如果 s 和 t 均为空，则 s 是 t 的子序列，返回 true\n        &#125;\n        int i &#x3D; 0; &#x2F;&#x2F; 定义 s 的指针 i，用于遍历 s 的字符\n        int temp &#x3D; -1; &#x2F;&#x2F; 定义 temp 变量，用于记录上一次匹配的 t 中的位置\n        int j &#x3D; 0; &#x2F;&#x2F; 定义 t 的指针 j，用于遍历 t 的字符\n        for (i &#x3D; 0; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 遍历 s 中的字符\n            for (j &#x3D; temp + 1; j &lt; t.size(); j++) &#123; &#x2F;&#x2F; 从上一次匹配的位置之后开始遍历 t 中的字符\n                if(s[i] &#x3D;&#x3D; t[j]) &#123; &#x2F;&#x2F; 如果当前 s 中的字符与 t 中的字符匹配\n                    temp &#x3D; j; &#x2F;&#x2F; 更新 temp 为当前匹配的 t 中的位置\n                    break; &#x2F;&#x2F; 跳出当前循环，继续下一个字符的匹配\n                &#125; else if (j &#x3D;&#x3D; t.size() - 1) &#123;\n                    return false; &#x2F;&#x2F; 如果 t 中没有字符与 s 中的字符匹配，返回 false\n                &#125;\n            &#125;\n        &#125;\n        if (i &#x3D;&#x3D; s.size() &amp;&amp; j &lt; t.size()) &#123;\n            return true; &#x2F;&#x2F; 如果 s 已经遍历完毕，而 t 还有剩余字符，则 s 是 t 的子序列，返回 true\n        &#125;\n        return false; &#x2F;&#x2F; 其他情况下，返回 false\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>更高效的方法</li>\n</ul>\n<p>我们可以通过一次遍历字符串 t 来判断字符串 s 是否为 t 的子序列。</p>\n<p>思路如下：对于字符串 s 和 t，我们维护两个指针 i 和 j，分别指向 s 和 t 的开头。然后，我们逐个比较 s[i] 和 t[j]，如果相等，则将两个指针都向后移动一位，如果不相等，则只移动 t 的指针 j。最终，如果 s 的指针 i 移动到末尾，说明 s 是 t 的子序列，返回 true，否则返回 false。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isSubsequence(string s, string t) &#123;\n        int i &#x3D; 0;\n        int j &#x3D; 0;\n        while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;\n            if (s[i] &#x3D;&#x3D; t[j]) &#123;\n                i++; &#x2F;&#x2F; 如果当前字符匹配，移动 s 的指针\n            &#125;\n            j++; &#x2F;&#x2F; 不论当前字符是否匹配，移动 t 的指针\n        &#125;\n        return i &#x3D;&#x3D; s.size(); &#x2F;&#x2F; 如果 s 的指针移动到末尾，说明 s 是 t 的子序列，返回 true；否则返回 false\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>进阶：</strong></p>\n<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>\n<p><strong>致谢：</strong></p>\n<p>特别感谢 <a href=\"https://leetcode.com/pbrother/\">@pbrother </a>添加此问题并且创建所有测试用例。</p>\n<p><strong>示例 1：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：true</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：false</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= s.length &lt;= 100</code></li>\n<li><code>0 &lt;= t.length &lt;= 10^4</code></li>\n<li>两个字符串都只由小写字符组成。</li>\n</ul>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ul>\n<li>暴力解法：</li>\n</ul>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isSubsequence(string s, string t) &#123;\n        if (s.size() &#x3D;&#x3D; 0 &amp;&amp; t.size() &#x3D;&#x3D; 0) &#123;\n            return true; &#x2F;&#x2F; 如果 s 和 t 均为空，则 s 是 t 的子序列，返回 true\n        &#125;\n        int i &#x3D; 0; &#x2F;&#x2F; 定义 s 的指针 i，用于遍历 s 的字符\n        int temp &#x3D; -1; &#x2F;&#x2F; 定义 temp 变量，用于记录上一次匹配的 t 中的位置\n        int j &#x3D; 0; &#x2F;&#x2F; 定义 t 的指针 j，用于遍历 t 的字符\n        for (i &#x3D; 0; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 遍历 s 中的字符\n            for (j &#x3D; temp + 1; j &lt; t.size(); j++) &#123; &#x2F;&#x2F; 从上一次匹配的位置之后开始遍历 t 中的字符\n                if(s[i] &#x3D;&#x3D; t[j]) &#123; &#x2F;&#x2F; 如果当前 s 中的字符与 t 中的字符匹配\n                    temp &#x3D; j; &#x2F;&#x2F; 更新 temp 为当前匹配的 t 中的位置\n                    break; &#x2F;&#x2F; 跳出当前循环，继续下一个字符的匹配\n                &#125; else if (j &#x3D;&#x3D; t.size() - 1) &#123;\n                    return false; &#x2F;&#x2F; 如果 t 中没有字符与 s 中的字符匹配，返回 false\n                &#125;\n            &#125;\n        &#125;\n        if (i &#x3D;&#x3D; s.size() &amp;&amp; j &lt; t.size()) &#123;\n            return true; &#x2F;&#x2F; 如果 s 已经遍历完毕，而 t 还有剩余字符，则 s 是 t 的子序列，返回 true\n        &#125;\n        return false; &#x2F;&#x2F; 其他情况下，返回 false\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>更高效的方法</li>\n</ul>\n<p>我们可以通过一次遍历字符串 t 来判断字符串 s 是否为 t 的子序列。</p>\n<p>思路如下：对于字符串 s 和 t，我们维护两个指针 i 和 j，分别指向 s 和 t 的开头。然后，我们逐个比较 s[i] 和 t[j]，如果相等，则将两个指针都向后移动一位，如果不相等，则只移动 t 的指针 j。最终，如果 s 的指针 i 移动到末尾，说明 s 是 t 的子序列，返回 true，否则返回 false。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool isSubsequence(string s, string t) &#123;\n        int i &#x3D; 0;\n        int j &#x3D; 0;\n        while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;\n            if (s[i] &#x3D;&#x3D; t[j]) &#123;\n                i++; &#x2F;&#x2F; 如果当前字符匹配，移动 s 的指针\n            &#125;\n            j++; &#x2F;&#x2F; 不论当前字符是否匹配，移动 t 的指针\n        &#125;\n        return i &#x3D;&#x3D; s.size(); &#x2F;&#x2F; 如果 s 的指针移动到末尾，说明 s 是 t 的子序列，返回 true；否则返回 false\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}