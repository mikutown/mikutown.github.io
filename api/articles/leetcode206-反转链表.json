{"title":"leetcode206.反转链表","slug":"leetcode206-反转链表","date":"2023-02-27T07:20:51.000Z","updated":"2023-02-27T08:32:07.054Z","comments":true,"path":"api/articles/leetcode206-反转链表.json","excerpt":"题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。","covers":["http://cdn.leafii.top/img/rev1ex1.jpg","http://cdn.leafii.top/img/rev1ex2.jpg"],"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>\n <span id=\"more\"></span>\n\n<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/rev1ex1.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4,5]\n输出：[5,4,3,2,1]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/rev1ex2.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2]\n输出：[2,1]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>递归方式</li>\n</ol>\n<p>在这个实现中，我们首先检查链表是否为空或只有一个节点。如果是这样，我们直接返回该节点，因为没有必要反转链表。</p>\n<p>如果链表中有多个节点，我们将递归调用 <code>reverseList</code> 函数来反转链表的后半部分。然后，我们将当前节点连接到反转后的链表的末尾，将当前节点作为新的尾节点，连接到 NULL。最后，返回新的头节点。</p>\n<p>这个递归方法的时间复杂度是 O(n)，其中 n 是链表的长度。虽然它可能需要使用堆栈来存储递归调用的上下文，但它通常比迭代方法更简洁易懂。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * 以链表1-&gt;2-&gt;3-&gt;4-&gt;5举例\n * @param head\n * @return\n *&#x2F;\nListNode* reverseList(ListNode* head) &#123;\n    if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#123;\n        &#x2F;*\n            直到当前节点的下一个节点为空时返回当前节点\n            由于5没有下一个节点了，所以此处返回节点5\n         *&#x2F;\n        return head;\n    &#125;\n    &#x2F;&#x2F;递归传入下一个节点，目的是为了到达最后一个节点\n    ListNode* newHead &#x3D; reverseList(head-&gt;next);\n    &#x2F;*\n        第一轮出栈，head为5，head-&gt;next为空，返回5\n        第二轮出栈，head为4，head-&gt;next为5，执行head-&gt;next-&gt;next&#x3D;head也就是5-&gt;next&#x3D;4，\n                  把当前节点的子节点的子节点指向当前节点\n                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4-&gt;next&#x3D;null\n                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5\n                  返回节点5\n        第三轮出栈，head为3，head-&gt;next为4，执行head-&gt;next-&gt;next&#x3D;head也就是4-&gt;next&#x3D;3，\n                  此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3-&gt;next&#x3D;null\n                  此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5\n                  返回节点5\n        第四轮出栈，head为2，head-&gt;next为3，执行head-&gt;next-&gt;next&#x3D;head也就是3-&gt;next&#x3D;2，\n                  此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2-&gt;next&#x3D;null\n                  此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5\n                  返回节点5\n        第五轮出栈，head为1，head-&gt;next为2，执行head-&gt;next-&gt;next&#x3D;head也就是2-&gt;next&#x3D;1，\n                  此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1-&gt;next&#x3D;null\n                  此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5\n                  返回节点5\n        出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1\n     *&#x2F;\n    head-&gt;next-&gt;next &#x3D; head;\n    head-&gt;next &#x3D; nullptr;\n    return newHead;\n&#125;\n</code></pre>\n\n<ol start=\"2\">\n<li>迭代方式（头插法）</li>\n</ol>\n<p>头插法的基本思路是，将链表的每个节点插入到新链表的头部。由于头插法是从头部开始插入，因此我们需要一个指针来跟踪新链表的头部。</p>\n<p>在这个实现中，我们首先定义一个新链表的头部指针 <code>newHead</code>，并将其初始化为 NULL。</p>\n<p>然后，我们遍历原链表中的每个节点。在每个迭代中，我们先记录当前节点的下一个节点，然后将当前节点插入到新链表的头部。为此，我们将当前节点的 <code>next</code> 指针指向新链表的头部，然后将新链表的头部指针指向当前节点。</p>\n<p>最后，我们将当前节点更新为原链表中的下一个节点，并重复这个过程，直到我们遍历完整个链表。</p>\n<p>这个方法的时间复杂度是 O(n)，其中 n 是链表的长度。它不需要额外的空间来存储递归调用的上下文，因此它通常比递归方法更快。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        &#x2F;&#x2F; 新链表的头节点指针，初始为 NULL\n        ListNode* newHead &#x3D; NULL;\n\n        &#x2F;&#x2F; 依次遍历原链表中的每个节点\n        while (head !&#x3D; NULL) &#123;\n            &#x2F;&#x2F; 记录当前节点的下一个节点\n            ListNode* next &#x3D; head-&gt;next;\n\n            &#x2F;&#x2F; 将当前节点插入到新链表的头部\n            head-&gt;next &#x3D; newHead;\n            newHead &#x3D; head;\n\n            &#x2F;&#x2F; 处理下一个节点\n            head &#x3D; next;\n        &#125;\n\n        &#x2F;&#x2F; 返回新链表的头节点指针\n        return newHead;\n    &#125;\n&#125;;\n</code></pre>\n\n","more":"<p><strong>示例 1：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/rev1ex1.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2,3,4,5]\n输出：[5,4,3,2,1]</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"http://cdn.leafii.top/img/rev1ex2.jpg\" alt=\"img\"></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; [1,2]\n输出：[2,1]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入：head &#x3D; []\n输出：[]</code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>递归方式</li>\n</ol>\n<p>在这个实现中，我们首先检查链表是否为空或只有一个节点。如果是这样，我们直接返回该节点，因为没有必要反转链表。</p>\n<p>如果链表中有多个节点，我们将递归调用 <code>reverseList</code> 函数来反转链表的后半部分。然后，我们将当前节点连接到反转后的链表的末尾，将当前节点作为新的尾节点，连接到 NULL。最后，返回新的头节点。</p>\n<p>这个递归方法的时间复杂度是 O(n)，其中 n 是链表的长度。虽然它可能需要使用堆栈来存储递归调用的上下文，但它通常比迭代方法更简洁易懂。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * 以链表1-&gt;2-&gt;3-&gt;4-&gt;5举例\n * @param head\n * @return\n *&#x2F;\nListNode* reverseList(ListNode* head) &#123;\n    if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#123;\n        &#x2F;*\n            直到当前节点的下一个节点为空时返回当前节点\n            由于5没有下一个节点了，所以此处返回节点5\n         *&#x2F;\n        return head;\n    &#125;\n    &#x2F;&#x2F;递归传入下一个节点，目的是为了到达最后一个节点\n    ListNode* newHead &#x3D; reverseList(head-&gt;next);\n    &#x2F;*\n        第一轮出栈，head为5，head-&gt;next为空，返回5\n        第二轮出栈，head为4，head-&gt;next为5，执行head-&gt;next-&gt;next&#x3D;head也就是5-&gt;next&#x3D;4，\n                  把当前节点的子节点的子节点指向当前节点\n                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4-&gt;next&#x3D;null\n                  此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5\n                  返回节点5\n        第三轮出栈，head为3，head-&gt;next为4，执行head-&gt;next-&gt;next&#x3D;head也就是4-&gt;next&#x3D;3，\n                  此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3-&gt;next&#x3D;null\n                  此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5\n                  返回节点5\n        第四轮出栈，head为2，head-&gt;next为3，执行head-&gt;next-&gt;next&#x3D;head也就是3-&gt;next&#x3D;2，\n                  此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2-&gt;next&#x3D;null\n                  此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5\n                  返回节点5\n        第五轮出栈，head为1，head-&gt;next为2，执行head-&gt;next-&gt;next&#x3D;head也就是2-&gt;next&#x3D;1，\n                  此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1-&gt;next&#x3D;null\n                  此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5\n                  返回节点5\n        出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1\n     *&#x2F;\n    head-&gt;next-&gt;next &#x3D; head;\n    head-&gt;next &#x3D; nullptr;\n    return newHead;\n&#125;\n</code></pre>\n\n<ol start=\"2\">\n<li>迭代方式（头插法）</li>\n</ol>\n<p>头插法的基本思路是，将链表的每个节点插入到新链表的头部。由于头插法是从头部开始插入，因此我们需要一个指针来跟踪新链表的头部。</p>\n<p>在这个实现中，我们首先定义一个新链表的头部指针 <code>newHead</code>，并将其初始化为 NULL。</p>\n<p>然后，我们遍历原链表中的每个节点。在每个迭代中，我们先记录当前节点的下一个节点，然后将当前节点插入到新链表的头部。为此，我们将当前节点的 <code>next</code> 指针指向新链表的头部，然后将新链表的头部指针指向当前节点。</p>\n<p>最后，我们将当前节点更新为原链表中的下一个节点，并重复这个过程，直到我们遍历完整个链表。</p>\n<p>这个方法的时间复杂度是 O(n)，其中 n 是链表的长度。它不需要额外的空间来存储递归调用的上下文，因此它通常比递归方法更快。</p>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        &#x2F;&#x2F; 新链表的头节点指针，初始为 NULL\n        ListNode* newHead &#x3D; NULL;\n\n        &#x2F;&#x2F; 依次遍历原链表中的每个节点\n        while (head !&#x3D; NULL) &#123;\n            &#x2F;&#x2F; 记录当前节点的下一个节点\n            ListNode* next &#x3D; head-&gt;next;\n\n            &#x2F;&#x2F; 将当前节点插入到新链表的头部\n            head-&gt;next &#x3D; newHead;\n            newHead &#x3D; head;\n\n            &#x2F;&#x2F; 处理下一个节点\n            head &#x3D; next;\n        &#125;\n\n        &#x2F;&#x2F; 返回新链表的头节点指针\n        return newHead;\n    &#125;\n&#125;;\n</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}