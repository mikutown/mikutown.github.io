{"title":"leetcode:704.二分查找","slug":"leetcode-704-二分查找","date":"2023-02-05T04:46:18.000Z","updated":"2023-02-05T04:49:24.967Z","comments":true,"path":"api/articles/leetcode-704-二分查找.json","excerpt":"题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。","covers":null,"content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>\n<span id=\"more\"></span>\n\n<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>\n<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>\n<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>\n</ol>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>如题目所示，直接使用二分查找即可。C++代码实现如下：</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int size &#x3D; nums.size();\n        int left &#x3D; 0;\n        int right &#x3D; size - 1;\n        int mid &#x3D; (left + (right - left) &#x2F; 2);\n        while(nums[mid] !&#x3D; target &amp;&amp; left &lt; right) &#123;\n            if (nums[mid] &gt; target) &#123;\n                right &#x3D; mid - 1;\n            &#125;\n            else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n            mid &#x3D; (left + (right - left) &#x2F; 2);\n        &#125;\n        if (nums[mid] &#x3D;&#x3D; target) &#123;\n            return mid;\n        &#125;\n        return -1;\n    &#125;\n&#125;;</code></pre>\n\n","more":"<p><strong>示例 1:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"language-none\"><code class=\"language-none\">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1</code></pre>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>\n<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>\n<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>\n</ol>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><ol>\n<li>如题目所示，直接使用二分查找即可。C++代码实现如下：</li>\n</ol>\n<pre class=\"language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int size &#x3D; nums.size();\n        int left &#x3D; 0;\n        int right &#x3D; size - 1;\n        int mid &#x3D; (left + (right - left) &#x2F; 2);\n        while(nums[mid] !&#x3D; target &amp;&amp; left &lt; right) &#123;\n            if (nums[mid] &gt; target) &#123;\n                right &#x3D; mid - 1;\n            &#125;\n            else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n            mid &#x3D; (left + (right - left) &#x2F; 2);\n        &#125;\n        if (nums[mid] &#x3D;&#x3D; target) &#123;\n            return mid;\n        &#125;\n        return -1;\n    &#125;\n&#125;;</code></pre>","categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"}]}