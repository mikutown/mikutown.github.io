<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Leafii"><meta name="copyright" content="Leafii"><meta name="generator" content="Hexo 6.2.0"><meta name="theme" content="hexo-theme-yun"><title>DeepMAG-使用多智能体图进行深度强化学习以实现灵活的作业车间调度 | LeafiiのBlog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://fastly.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="../../../../favicon.ico"><link rel="mask-icon" href="../../../../favicon.ico" color="#0078E7"><link rel="preload" href="../../../../css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="../../../../js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"leafii.top","root":"/","title":["Leafii","の","博","客"],"version":"1.9.3","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"local_search":{"path":"/search.xml"},"fireworks":{"colors":null},"vendors":{"darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="../../../../css/hexo-theme-yun.css"><script src="../../../../js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="../../../../atom.xml" title="LeafiiのBlog" type="application/atom+xml"><meta name="description" content="DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop schedulingAbstract一般的柔性车间调度执行基于两个决策步骤：任务次序（比如在一个机器上任务的执行顺序）以及任务路由（比如一个任务到一个机器的路径）。大多数现有的研究利用DRL或者MARL在大的搜索空间进行调度。但是这些">
<meta property="og:type" content="article">
<meta property="og:title" content="DeepMAG-使用多智能体图进行深度强化学习以实现灵活的作业车间调度">
<meta property="og:url" content="2023/05/31/DeepMAG-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%9B%BE%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BD%9C%E4%B8%9A%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6/index.html">
<meta property="og:site_name" content="LeafiiのBlog">
<meta property="og:description" content="DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop schedulingAbstract一般的柔性车间调度执行基于两个决策步骤：任务次序（比如在一个机器上任务的执行顺序）以及任务路由（比如一个任务到一个机器的路径）。大多数现有的研究利用DRL或者MARL在大的搜索空间进行调度。但是这些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230525205309249.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230529180040531.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230529180231978.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230531161425827.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230531162203905.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230531163034639.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230531171254007.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230531171419329.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230531171452175.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230531171525518.png">
<meta property="og:image" content="http://cdn.leafii.top/img/image-20230531171559090.png">
<meta property="article:published_time" content="2023-05-31T09:20:59.000Z">
<meta property="article:modified_time" content="2023-05-31T09:34:09.569Z">
<meta property="article:author" content="Leafii">
<meta property="article:tag" content="知识图谱">
<meta property="article:tag" content="车间调度">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cdn.leafii.top/img/image-20230525205309249.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head><body><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="../../../../js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="../../../../js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="../../../../about/" title="Leafii"><img width="96" loading="lazy" src="../../../../images/avatar.jpg" alt="Leafii"></a><div class="site-author-name"><a href="../../../../about/">Leafii</a></div><a class="site-name" href="../../../../about/site.html">LeafiiのBlog</a><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="../../../../index.html" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="../../../../archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">180</span></a></div><div class="site-state-item"><a href="../../../../categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="../../../../tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">34</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="主题文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/mikutown" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:yunsenye@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=299583310" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="../../../../links/" title="友情链接" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling"><span class="toc-number">1.</span> <span class="toc-text">DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract"><span class="toc-number">1.1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Related-work"><span class="toc-number">1.3.</span> <span class="toc-text">Related work</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Problem-statement"><span class="toc-number">1.4.</span> <span class="toc-text">Problem statement</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Preliminaries"><span class="toc-number">1.4.1.</span> <span class="toc-text">Preliminaries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Problem-definition"><span class="toc-number">1.4.2.</span> <span class="toc-text">Problem definition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-proposed-DeepMAG"><span class="toc-number">1.5.</span> <span class="toc-text">The proposed DeepMAG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview-of-DeepMAG"><span class="toc-number">1.5.1.</span> <span class="toc-text">Overview of DeepMAG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multi-agent-graphs"><span class="toc-number">1.5.2.</span> <span class="toc-text">Multi-agent graphs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Feature-extraction"><span class="toc-number">1.5.3.</span> <span class="toc-text">Feature extraction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Machine-centric-features"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Machine-centric features</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Job-centric-features"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">Job-centric features</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Representations-of-states-and-actions"><span class="toc-number">1.5.4.</span> <span class="toc-text">Representations of states and actions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Machine-associated-agents"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">Machine-associated agents</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Job-associated-agents"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">Job-associated agents</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Learning-on-DQNs"><span class="toc-number">1.5.5.</span> <span class="toc-text">Learning on DQNs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Training-optimization"><span class="toc-number">1.5.6.</span> <span class="toc-text">Training optimization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Experiments"><span class="toc-number">1.6.</span> <span class="toc-text">Experiments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Experimental-setting"><span class="toc-number">1.6.1.</span> <span class="toc-text">Experimental setting</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Emulated-data"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">Emulated data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Evaluated-methods"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">Evaluated methods</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Performance-metrics"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">Performance metrics</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Implementation-details"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">Implementation details</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Experimental-results"><span class="toc-number">1.6.2.</span> <span class="toc-text">Experimental results</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Method-comparison"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">Method comparison</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Effect-of-replay-memory-ratios"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">Effect of replay memory ratios</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Effect-of-target-network-update-times"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">Effect of target network update times</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Effect-of-neuron-numbers"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">Effect of neuron numbers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Convergence-analysis"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">Convergence analysis</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion-and-future-work"><span class="toc-number">1.7.</span> <span class="toc-text">Conclusion and future work</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-availability"><span class="toc-number">1.8.</span> <span class="toc-text">Data availability</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https:/leafii.top"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Leafii"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="LeafiiのBlog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">DeepMAG-使用多智能体图进行深度强化学习以实现灵活的作业车间调度</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2023-05-31 17:20:59" itemprop="dateCreated datePublished" datetime="2023-05-31T17:20:59+08:00">2023-05-31</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">11.9k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">44m</span></span></span><div class="post-classify"><span class="post-tag"><a class="tag-item" href="../../../../tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">知识图谱</span></a><a class="tag-item" href="../../../../tags/%E8%BD%A6%E9%97%B4%E8%B0%83%E5%BA%A6/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">车间调度</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling"><a href="#DeepMAG-Deep-reinforcement-learning-with-multi-agent-graphs-for-flexible-job-shop-scheduling" class="headerlink" title="DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling"></a>DeepMAG: Deep reinforcement learning with multi-agent graphs for flexible job shop scheduling</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>一般的柔性车间调度执行基于两个决策步骤：任务次序（比如在一个机器上任务的执行顺序）以及任务路由（比如一个任务到一个机器的路径）。大多数现有的研究利用DRL或者MARL在大的搜索空间进行调度。<strong>但是</strong>这些研究有两个主要的限制：在DRL和MARL之间没有进行结合，独立的智能体之间没有合作。DeepMAG有两个关键贡献：1. DRL和MARL之间的结合。DeepMAG 通过将不同的智能体与每台机器和作业相关联，将 DRL 与 MARL 集成。每个智能体都利用 DRL 来找到有关作业排序和路由的最佳操作。在作业关联智能体选择最佳机器后，该作业成为机器进行下一个操作的作业候选者，而机器关联智能体从其作业候选集中选择下一个作业进行处理。2. 合作智能体。基于机器和作业之间的操作关系构建多智能体图。一个智能体与其相邻的智能体合作采取一个合作行动。最后，我们进行实验来评估 DeepMAG 的性能，实验结果表明它优于最先进的技术。</p>
<span id="more"></span>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>作业车间调度 (JSS) 是最流行的调度问题之一，由于其在实际工厂中的广泛适用性，已被研究了几十年 [1]。 JSS 的决策步骤是通过在特定时间在特定机器上执行作业来对作业进行排序，其中 (1) 每个作业的操作需要按给定顺序（即<strong>优先约束</strong>）处理，(2) 每台机器只能处理一个任何时候作业的操作（即排除约束），以及（3）每个作业操作都有一台唯一的机器（即唯一约束）。而FJSS满足<strong>优先和排除约束</strong>但将<strong>唯一约束</strong>放宽为<strong>常量约束</strong>，其中作业的每个操作都可以在给定的常量机器集(Set)中的任何机器上处理，而不是在一台唯一的机器上处理。除了 JSS 中的作业排序（即作业在机器上执行的顺序）之外，FJSS 在作业路由上还有一个额外的决策步骤（即作业的每个操作到给定恒定机器集中的机器的路线） .</p>
<p><img src="http://cdn.leafii.top/img/image-20230525205309249.png" alt="image-20230525205309249" loading="lazy"></p>
<p>在现有的近似计算方法中，调度规则（Dispatching rules）很难得到满足真实生活应用的调度解；启发式搜索方法可以有效地到达可能的解，但是容易陷入局部最优；强化学习方法表现出了潜力，并且相较于其他方法更有到达精确最优解的潜能。但是这些方法有两个主要的缺陷：</p>
<ol>
<li><p>没有把DRL和MARL进行结合。</p>
<p>大多数研究工作将 DRL 用于大型状态空间 或将 MARL 用于大型动作空间。他们没有将 DRL 与 MARL 集成来解决 FJSS 中同时具有大状态和动作空间的难题。</p>
</li>
<li><p>独立的智能体。</p>
<p>当前的研究利用多个智能体来管理大的动作空间，但这些智能体彼此独立。结果，每个智能体都为一个子空间找到了自己的最优阶乘动作，而来自所有智能体的这些阶乘动作不一定构成一个最优联合动作。</p>
</li>
</ol>
<p>为了解决这两个限制，本文提出了一种基于深度强化学习和多智能体图的 FJSS 新模型，称为 DeepMAG，它具有两个重要特征。 </p>
<ol>
<li>DRL与MARL的融合。 DeepMAG 通过将每台机器或作业与一个独特的智能体相关联，将 DRL 集成到 MARL 中，该智能体利用 DQN 为机器关联的智能体找到作业排序的最佳操作，以选择下一个要处理的作业（如果可用）或作业路由作业相关的智能体在当前操作完成时选择一台机器进行下一个操作。此外，所有与机器相关的智能体共享一个 DQN，而所有与作业相关的智能体共享另一个。 </li>
<li>合作智能体。 DeepMAG 构建了一个多智能体图，由作为节点的智能体组成，节点基于机器处理作业操作的顺序和可以处理的作业的可能操作。每个智能体通过观察它们的操作关系并在每一步聚合相邻信息以采取一个合作行动来与其相邻智能体合作。</li>
</ol>
<p>本文的主要贡献可以概括为：</p>
<ul>
<li>我们通过将 DRL 与 MARL 集成，为 FJSS 开发了一个新模型 DeepMAG。 DRL 利用 DQN 来处理大状态空间，而 MARL 利用多个智能体来管理大动作空间。</li>
<li>我们设计了一个多智能体图，该图源自机器和作业之间的操作关系，包括机器的处理顺序和当前时间步正在机器上处理的作业的操作。所有智能体合作寻找最佳行动，以保证 DeepMAG 的良好回报。 </li>
<li>我们进行了广泛的实验，使用来自真实制造工厂的设置的模拟数据来评估 DeepMAG 的性能。实验结果表明，DeepMAG 明显优于其他竞争技术。</li>
</ul>
<h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>将对JSS和FJSS的研究分为四类：计算优化方法(Operational optimization methods)，调度规则(Dispatching rules)，启发式搜索方法(Heuristic search methods)，强化学习(Reinforcement learning (RL) methods)；具体介绍略</p>
<h2 id="Problem-statement"><a href="#Problem-statement" class="headerlink" title="Problem statement"></a>Problem statement</h2><p>我们在第 3.1 节介绍了预备知识，并在第 3.2 节定义了 DeepMAG 的研究问题。在接下来的问题定义中，（1）大写字母表示一个随机变量，它相应的小写字母表示一个随机值，比如S是状态变量，s是S的状态值；（2）粗体字母表示向量，例如，<strong>S</strong>是状态变量向量，s是<strong>S</strong>的状态值向量。(3) 书法字母表示一组值，例如，S 表示一组状态值 s的集合。 (4) 黑板上的粗体字母表示函数，例如$\mathbb{P}$ 表示概率函数。 (5) 打字机字母表示一个常数，例如，p 表示生产率。</p>
<h3 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h3><p>Definition 3.1 (Markov Decision Process (MDP)).有限 MDP 是一个 4 元组 (S, A, R, P)，其中 S 是状态的有限集，A 是动作的有限集，R 是数字奖励的有限集，P 是四元组参数条件概率质量函数：</p>
<p>$\mathbb{P}(s’,r|s,a) &#x3D; Pr{S_{t+1} &#x3D; s’, R_{t+1} &#x3D; r|S_t &#x3D;s, A_t &#x3D; a}, (1)$</p>
<p>对于所有 s，s′ ∈ S，r ∈ R，a ∈ A。P(s′, r|s, a) 表示状态 s′ 和奖励 r 在时间步 t + 1 发生的概率，给定前面的状态 s 和动作 a 在时间步 t，它完全体现了有限 MDP 的动态。</p>
<p>在 MDP 中，智能体在每个连续的离散时间步与环境交互。在每个时间步 t，智能体接收环境的状态 St，从中选择一个动作 At。一个时间步之后，作为其选择 At 的结果，智能体收到数字奖励 Rt+1，并发现自己处于新状态 St+1。智能体选择动作 At 来最大化它在未来收到的折扣奖励的总和，这称为回报(return)。</p>
<p>Definition 3.2 (Return).回报 Gt 定义为在时间步 t 后收到的折扣奖励的总和：</p>
<p>$G_t &#x3D; R_{t+1} + \gamma R_{t+2} + \gamma^2R_{t+3} + … &#x3D; \sum_{n&#x3D;1}^{\infty}\gamma^{n-1}R_{t+n}(2)$，其中$\gamma$为折扣率。</p>
<p>智能体的目标是最大化其奖励的总量，这意味着最大化的不是即时奖励，而是长期的累积奖励。贴现率决定未来奖励的现值：在第 n 个未来时间步收到的奖励 Rt+n 乘以贴现率的 n-1 次方，即 γ n−1Rt+n。现实世界的问题，例如 JSS 和 FJSS，对于集中式智能体来说往往太大而无法解决。因此，研究人员研究了一个分布式多智能体系统，其中多个智能体在同一环境中行动以完成特定任务。因此，MDP 的定义可以扩展到这样的多智能体系统（定义 3.3）。</p>
<p>Definition 3.3 (Multi-agent MDP).多智能体 MDP 是一个 5 元组$ (\mathcal{I, S, A, R}, \mathbb{P})$，其中 I 是一组智能体，S 是可以分解为 $\mathcal{I}$的状态集。分量 $S &#x3D; S_1 × · · · × S_{|I|}$，$A &#x3D; A_1 × · · · × A_{|I|}$因此，共享相同奖励集 R 的智能体要执行的联合动作集，条件概率质量函数 P 由下式给出</p>
<p>$\mathbb{P}(s’,r|s,a) &#x3D; Pr{S_{t+1} &#x3D; s’, R_{t+1}&#x3D;r|S_t &#x3D; s, A_t &#x3D; a},(3)$，其中的s是所有智能体的状态$s_i$，A是所有智能体的动作$A_i$；</p>
<p>在多智能体 MDP 中，所有智能体在环境中观察自己的局部状态，采取各自的行动，并获得相同的奖励以相互合作完成相同的任务。 MARL 基于多智能体 MDP，通过将联合行动空间划分为多个具有阶乘行动的子空间来解决具有大联合行动空间的问题。每个智能体都可以直接应用各种 RL 方法将每个状态映射到最佳动作。具体来说，基于智能体 i ∈ I 的策略 π，使用 DQN 对具有大状态空间 Si 的状态-动作值函数 Q(si, ai) 进行参数化。</p>
<p>Definition 3.4 (Value Function).智能体 i ∈ I 在策略 π 下在状态 si 采取行动 ai 的值，表示为 Q(si, ai)，是在时间步 t 从 si 开始采取行动 ai，然后跟随 π 的预期回报，给定经过</p>
<p>$\mathbb{Q}(s_i, a_i) &#x3D; \mathbb{E}[G_t|S_t^i &#x3D; s_i, A_t^i &#x3D; a_i]$;在 DQN 中，π 是关于学习到的状态-动作值函数 Q(si, ai) 的贪心策略。</p>
<p>Definition 3.5 (Greedy Policy).对于任何状态-动作值函数 Q，相应的贪心策略 π 是确定性地选择具有最大值的动作 $a_i^*$ 的策略：</p>
<p>$a_i^* &#x3D; \pi(s_i) &#x3D; arg max \mathbb{Q}(s_i, a_i), for each s_i \in S_i$</p>
<h3 id="Problem-definition"><a href="#Problem-definition" class="headerlink" title="Problem definition"></a>Problem definition</h3><p>在本节中，我们定义了 MARL 框架中针对 FJSS 研究问题的重要概念。</p>
<p>环境(Environment)。 FJSS 的环境包括一组机器和一组作业，其中作业被路由到特定机器并在特定时间顺序处理。特别地，FJSS 环境包含第 1 节中提到的三个重要约束：（1）优先约束给出每个作业中操作的处理顺序，（2）排除约束要求在任何机器上处理的作业中最多有一个操作时间，以及（3）常量约束为作业的每个操作指定一个常量机器集。</p>
<p>智能体(Agents).每个智能体与环境交互，从中学习，然后做出决定。为了处理具有大动作空间的 FJSS，每台机器都与一个作业排序智能体相关联，方法是从机器的本地等待队列（即其作业候选集）中选择下一个作业，以便在可用时进行处理，而每个作业都是通过在当前操作完成时选择一台机器来处理其下一个操作，与作业路由的智能体相关联，然后该作业成为该机器的作业候选者。这些智能体一起工作，根据当前环境状态确定它们的最佳行动。</p>
<p>状态(States).状态是指环境的表示，包括机器和作业的各种特征，例如，机器的生产率及其关系、正在执行和可用于每个操作的机器数量，以及作业的工作量已完成或保留在不同的操作中。环境有一个全局状态，但每个智能体可能会观察到不同的局部状态。智能体在每个时间步采取行动后，全局状态会转换为新状态。</p>
<p>动作(Actions).有两种类型的智能体用于不同的操作。 与机器相关的智能体负责作业排序，并在相应机器可用时决定选择哪个作业进行处理。 与作业相关的智能体负责作业路由，并决定在当前操作完成时选择哪台机器来处理相应作业的下一个操作。 换句话说，机器相关智能体的动作是从工作候选集中选择一个工作，而工作相关智能体的动作是从一组固定的机器中选择一台机器。 重要的是要注意，智能体不会在每个时间步都采取行动； 该动作仅在机器可用或作业的当前操作在特定时间步完成时触发。</p>
<p>奖励(Rewards).在智能体人在时间步 t 采取行动后，他们从环境中收到相同的数字奖励 Rt+1。在每个时间步，奖励设置为 $R_{t+1} &#x3D; r &#x3D; −1$。在 FJSS 中，RL 的目标是最大化作为折扣奖励总和的回报，比如：最小化 makespan，即完成所有工作的总时间步数。</p>
<p>研究问题(Research problem).给定一组机器 M 和一组作业 J，每台机器 m ∈ M 在任何时候都只处理作业的一个操作（<strong>排除约束</strong>），并且具有指定每个时间步长完成的工作负载的生产率 pm；每个作业 j ∈ J 由 K 个有序操作组成 (oj,1, . . ., oj,K)（<strong>优先约束</strong>）；每个操作 oj,k 只能由一组常量机器 Mj,k ⊂ M（<strong>常量约束</strong>）处理，并且包含工作负载量 qj,k，表示 Mj,k 中给定机器上所需的时间步长。目标是在适当的时间段为特定机器的作业操作找到最佳计划，以最大限度地减少总处理时间，即完工时间。</p>
<h2 id="The-proposed-DeepMAG"><a href="#The-proposed-DeepMAG" class="headerlink" title="The proposed DeepMAG"></a>The proposed DeepMAG</h2><h3 id="Overview-of-DeepMAG"><a href="#Overview-of-DeepMAG" class="headerlink" title="Overview of DeepMAG"></a>Overview of DeepMAG</h3><p>简要的介绍了用于求解FJSS问题的DeepMAG，其通过两个DQN去进行job routing和job sequencing的决策。对于每一个时间步，DeepMAG按照以下的顺序进行执行。</p>
<ul>
<li><strong>Update agent graphs.</strong> DeepMAG 根据机器和作业之间的操作关系（第 4.2 节）<strong>更新</strong>多智能体图及其两种类型的变体（特定于机器的智能体图和特定于作业的智能体图）。</li>
<li>**Update features for each agent.**根据更新的智能体图，它提取基本特征、以机器为中心的特征和以作业为中心的特征（第 4.3 节）。</li>
<li>**Update the DQN for job routing.**对于每个准备好处理其对应作业的下一个操作的作业关联智能体，首先提取当前状态和所有候选动作（机器）的表示（第 4.4.2 节），然后深度 Q 学习算法用于从候选机器中选择一个动作来处理作业的下一个操作，更新重放内存，并通过随机梯度下降优化 DQN 的参数（第 4.5 和 4.6 节）。</li>
<li><strong>Update the other DQN for job sequencing.</strong> 对于每个可用的机器相关智能体，首先提取当前状态和所有候选动作（作业）的表示（第 4.4.1 节），然后应用深度 Q 学习从其候选作业中选择一个动作进行处理，更新回放内存，并通过随机梯度下降优化 DQN 的参数（第 4.5 和 4.6 节）。</li>
</ul>
<p>完成所有作业后，将为 FJSS 实例生成一个作业计划。通过在大量的 FJSS 实例上训练 DeepMAG，我们可以得到 DeepMAG 的近似最优参数。</p>
<h3 id="Multi-agent-graphs"><a href="#Multi-agent-graphs" class="headerlink" title="Multi-agent graphs"></a>Multi-agent graphs</h3><p>为了在job sequencing 和 job routing上大的连续动作空间去掌握FJSS，DeepMAG通过将每个机器或者任务用智能体联系起来来使用MARL。此外，这些智能体能够通过基于机器和作业之间的操作关系（即机器的处理顺序和当前时间步在机器上正在处理的作业的操作）来构建多智能体图的相互协作。需要注意DeepMAG并没有假定有固定数量的operation，并且自然而然地适应具有不同操作数量的场景。以下是多智能体图的定义。</p>
<p><strong>Definition 4.1</strong> (Multi-agent Graph).给定一组机器 M、一组作业 J 和一组机器 Mj,k ⊂ M 对于每个作业 j ∈ J 的每个操作 k，它们构成一个多智能体图 G &#x3D; (I, Es, Eu, Ev, Ew) 在一个时间步长，其中 I 是一组节点（即智能体）：</p>
<p>$I &#x3D; M \cup J \ \ \ \ \ \ \ \ (6)$</p>
<p>Es是机器之间在连续操作方面（例如，从 k 到 k + 1）静态关系的一组有向边：</p>
<p>$\varepsilon_s &#x3D; {m \rightarrow m’ |\exists j\in J, m \in M_{j,k}\and m’ \in M_{j, k+1}} \ \ \ \ \ \ \ (7)$</p>
<p>Eu是是机器在一个时间步处理的作业的动态关系上的一组无向边：</p>
<p>$\varepsilon_u &#x3D; {(j,m)|j\in J \ executing \ at \ m\in M} \ \ \ \ (8)$</p>
<p>Ev是作业的动态关系上的一组有向边，这些作业刚刚完成第 (k − 1) 次操作，并准备好在某个时间步路由到机器进行第 k 次操作：</p>
<p>$\varepsilon_v &#x3D; {m \rightarrow j|j \in J routing to m \in M_{j, k}} \ \ \ \ \ (9)$</p>
<p>Ew是在一个时间步等待在机器上的作业的动态关系的一组有向边：</p>
<p>$\varepsilon_w &#x3D; {j \rightarrow m|j \in J \ waiting\ at \ m \in M} \ \ \ \ (10)$</p>
<p>其中有向边 i → i’ 表示父子关系，i 是父节点，i’ 是子节点。</p>
<p>需要强调的是，在多智能体图中，所有与作业相连的边都是<strong>动态</strong>的，并且取决于在当前时间步可以处理的可能操作。此外，每个作业最多有一种类型的边，用于随时在机器上执行、等待或路由到机器。当一个作业完成时，其关联的智能体成为一个孤立的节点。此后，智能体和节点可互换地用于机器或作业。</p>
<p><img src="http://cdn.leafii.top/img/image-20230529180040531.png" alt="image-20230529180040531" loading="lazy"></p>
<p><img src="http://cdn.leafii.top/img/image-20230529180231978.png" alt="image-20230529180231978" loading="lazy"></p>
<p>以图3为例：图3描述了一个多智能体图的例子，其中的M&#x3D;{1,2,3,4,5,6}, J &#x3D; {7,8,9,10,11,12},表1显示了每个任务的每个操作的机器集合。在图3中，黑色的结点表示同机器有关的智能体，白色结点表示和job有关的智能体。根据式7，结点1和结点3之间有一个有向边，因为job&#x3D;7（8，9 或10）在机器m&#x3D;1上有两个连续的操作。结点3和结点7由无向边进行连接，这表示job j&#x3D;7在现在的时间步在机器m&#x3D;3上正在执行。此外，job&#x3D;8和9都在第二个操作刚刚完成而且等待着路由第三个操作到机器m&#x3D;5或者6上，所以由式9可知结点5和6到结点8和9需要被连接起来。最后，基于式10，从结点10，11到结点4的有向边表明job j&#x3D;10和job j&#x3D;11正在机器m&#x3D;4上进行等待，此时的机器4正在执行job j &#x3D; 12。</p>
<p>在FJSS中，总会有一些在所有operation中拥有相同固定机器集合的job，比如在表1中的job8，9，10.考虑到现实世界中的job的不同operation会有不同的需要，所以不同的job的相同的operation可能会需要不同的机器来执行。比如说，表1中的job 7和11在前两个操作中需要的机器是完全不同的。这意味着这两个job在执行前两个操作时并没有竞争关系。这个特性在智能体执行动作时应该被考虑到。接下来我们定义一些重要且相关的定义。</p>
<p>Definition 4.2 (Equivalent Jobs).给定一个机器集合M，一个任务集合J，以及一系列固定的机器$M_{j,k}$，它表示每一个$job \ j \in J$的操作k需要的机器集合。当且仅当两个job的每一个操作都有相同的固定机器集合时，这两个job就是相等的。 </p>
<p>job相等的例子：表1中的$J &#x3D; {7,8,9,10,11,12}$有子集({7},{8,9,10},{11,12}).这几个子集都是每一个操作的固定机器集合都相同的相等任务。因此，我们可以将相等的任务形成一个特定任务的智能体图(Job-specific Agent Graph)。</p>
<p>Definition 4.3 (Job-specific Agent Graph).给定一系列的机器M，一系列的任务J，以及对每一个job j的operation k的一系列固定的机器集合$M_{j,k} \subset M$，特定于作业 j ∈ J 的智能体图 G(j) 和定义 4.1 中的多智能体图 G 的子图由作业 j 的节点、其等效作业及其每个操作的机器集，以及这些节点之间的边组成。</p>
<p>以表1为例，G(8)就是job j &#x3D; 8的特定任务智能体图，它由包括结点8，它的相等任务（9和10）以及固定的机器（1，3，4，5和6），以及这些结点之间的边组成。因此，我们可以通过移除结点2，7，11和12以及在图3中与他们相关的边构建G(8)。请注意，所有相等任务的特定任务的智能体图是一样的。举例来说，就是G(8) &#x3D; G(9) &#x3D; G(10).同样的，我们定义一个特定机器的智能体图。</p>
<p>Definition 4.4 (Machine-specific Agent Graph).给你一系列的机器集合M，一系列任务集合J，以及一系列固定机器集合$M_{j,k} \subset M$对于每一个任务j的每一个操作k，特定于机器 m ∈ M 的智能体图 $G(m)&#x3D;{I(m),\varepsilon_s(m),\varepsilon_u(m),\varepsilon_v(m),\varepsilon_w(m)}$和多智能体的子图定义 4.1 中的图 G 是所有作业 $G(j)&#x3D;{I(j),\varepsilon_s(j),\varepsilon_u(j),\varepsilon_v(j),\varepsilon_w(j)}$的作业特定智能体图的并集机器m可以处理的：$G(m) &#x3D; \bigcup_{j \in {j’|\exist k, m\in M_{j’,k}}}G(j)$</p>
<p>其中图并集在节点集 I(j) 和边集 Es(j)、Eu(j)、Ev(j) 和 Ew(j) 上执行。</p>
<p>举例说明：在结点4上的特定机器的智能体图G(4)就是在结点8，9，10，11和12上特定任务的智能体图的并集。因此，我们可以通过移除结点7以及跟他相关的边来得到智能体图G(4).</p>
<h3 id="Feature-extraction"><a href="#Feature-extraction" class="headerlink" title="Feature extraction"></a>Feature extraction</h3><p>有两种动作，供两类智能体使用。一个同机器相关的智能体的动作就是在它的本地等待执行队列里选取一个任务来执行。同任务相关的智能体的动作就是在一系列的机器中选择一个机器，将它的下一个等待执行的operation放进这个机器对应的本地等待执行队列中。换言之，机器和工作的可交换性构成了两类智能体的状态和动作。因此，机器和作业的特征对于这些智能体人做出决定很重要。</p>
<p>**Basic features.**我们强调一些已知的基本特征，包括机器 m 的生产率 $p_m$ 和作业 j 在操作 k 的工作量 $q_{j,k}$ 。为了表述方便，我们还用 $q_j$ 表示作业 j 在当前操作的工作量，用 $q_{j,m}$ 表示作业 j 在机器 m 上的工作量，因为当前操作或机器 m 表示一个确定的操作 k，它可以很容易推断出来。此外，设 $x_{j,m}$ 为作业 j 在机器 m 上在当前时间步完成的工作量。则剩余工作量为 $y_{j,m} &#x3D; q_{j,m} − x_{j,m}$。除了这些基本特征外，DeepMAG 还根据 4.2 节中定义的多智能体图提取机器和作业的特征。</p>
<h4 id="Machine-centric-features"><a href="#Machine-centric-features" class="headerlink" title="Machine-centric features"></a>Machine-centric features</h4><p>在不失一般性的情况下，我们关注机器 m 的特性，其关联智能体负责作业排序，当机器可用时，它会从等待队列中选择一个作业进行处理。</p>
<p><strong>Four types of machine-centric static relationships</strong></p>
<p>我们在机器m和其他机器之间定义了四种静态关系。</p>
<p>父集合由拥有从m’指向m的有向边的每个机器m’组成。它的含义就是m’可能会发送任务的下一个operation给m。</p>
<p>$M_e(m) &#x3D; {m’|m’ \in M \and (m’ \rightarrow m}\ \ \ \ \ \ \ (12)$</p>
<p>子集合由拥有从m指向m’的有向边的每个机器m‘组成。它的含义就是m’可能会接受来自机器m的job的operation。</p>
<p>$M_d(m) &#x3D; {m’|m’ \in  M \and (m \rightarrow m’)}\ \ \ \ \ \ \ \ \ (13)$</p>
<p>双亲集合是由至少与机器m‘拥有一个公共孩子的机器m的集合。它的含义就是机器m与机器 m’在普通孩子的资源上为竞争关系。</p>
<p>$M_c(m) &#x3D; {m’|m’ \in M \and (M_d(m’) \cap M_d(m) \neq \emptyset} \ \ \ \ \ (14)$</p>
<p>兄弟集由每台机器 m’ 组成，这些机器至少有一个与 m 有共同的父代。它的含义就是与机器 m 合作完成共同父结点上即将发送来的的工作。</p>
<p>$M_b(m) &#x3D; {m’|m’ \in M \and (M_e(m’) \cap M_e(m)\neq \emptyset}\ \ \ \ \ (15)$</p>
<p>以图3来说明刚才定义的四种静态关系。$M_e(4) &#x3D; {1, 2}, M_d(4) &#x3D; {5, 6}, M_c (4) &#x3D; {3} , M_b(4) &#x3D; {3}$ 在节点4上。</p>
<p><strong>Two types of machine-centric dynamic relationships</strong></p>
<p>接着，我们定义了在机器m和任务之间在一个时间步的两种动态关系。</p>
<p>正在执行的集合由拥有无向边(j,m)的job j组成。需要注意的是由于exclusion constraint的存在，在每一个时间步，$J_u(m)$至多拥有一个任务。</p>
<p>$J_u(m) &#x3D; {j|j \in J \and (j,m} \ \ \ \ \ \ (16)$</p>
<p>正在等待执行的任务集合由拥有从j到m的有向边的job j组成。这个集合中的job将通过在未来消耗一定的时间的方式为机器m带来负担。</p>
<p>$J_w(m) &#x3D; {j|j \in J \and (j \rightarrow m} \ \ \ \ \ \ (17)$</p>
<p>在图3中，这两种动态关系的举例如下：对于结点4，$J_u(4) &#x3D;{12}, J_w(4) &#x3D; {10,11}$。</p>
<p><strong>Seven types of machine-centric numeric features.</strong></p>
<p>基于机器的静态和动态提取一些数量特征。</p>
<p>具有不同关系的机器的数量（或度（入度出度））的特征 $f_{deg}$ 由下式给出：</p>
<p>$f_{deg}(m) &#x3D; [|M_{(.)}(m)|] \ \ \ \ \ \ (18)$</p>
<p>其中的[]表示一个向量聚合，(.)是从式12到式15得到的b,c,d和e的集合，后文的式子中的符号也是如此表示。</p>
<p>在生产力值的总和上的特征$f_{prod}$由下式给出：</p>
<p>$f_{prod}(m) &#x3D; [\sum_{m’\in M(.)(m)}p_{m’}] \ \ \ \ \ \ \ \ \ \ \ (19)$</p>
<p>在正在执行的任务的数量特征$f_{exe}(m)$由下式给出：</p>
<p>$f_{exe}(m) &#x3D; [|J_u(m)|, \sum_{m’ \in M(.)(m)}|J_u(m’)|] \ \ \ \ \ \ \ \ \ (20)$</p>
<p>它们相应的已完成和剩余工作量的总和由下式给出:</p>
<p>$f_{exe}^{finish}(m) &#x3D; [\sum_{m’ \in M(.)(m)} \sum_{j \in J_u(m’)}x_{j, m’}]\ \ \ \ \ \ \ \ (21)$</p>
<p>$f_{exe}^{remain}(m) &#x3D; [\sum_{m’ \in M(.)(m)} \sum_{j \in J_u(m’)}y_{j, m’}]\ \ \ \ \ \ \ \ (22)$</p>
<p>相对的，正在等待的任务的数量特征$f_{wait}(m)$由下式给出：</p>
<p>$f_{wait}(m) &#x3D; [|J_w(m)|, \sum_{m’ \in M_{(.)}(m)}|J_w(m’)|] \ \ \ \ \ \ (23)$</p>
<p>它的负载数量由下式给出：</p>
<p>$f_{wait}^{qty}(m) &#x3D; [\sum_{j \in J_w(m)}q_{j, m}, \sum_{m’ \in M_{(.)}(m)}\sum_{j\in J_w(m’)q_{j,m’}}] \ \ \ \ \ \ (24)$</p>
<p>这些特征表示在机器m周围复杂的环境，并且它们对与机器相关的智能体决策很重要。</p>
<h4 id="Job-centric-features"><a href="#Job-centric-features" class="headerlink" title="Job-centric features"></a>Job-centric features</h4><p>在不失一般性的情况下，我们通过选择一台机器来处理作业的下一个操作来关注作业 j 的特征，其关联智能体已准备好进行作业路由。</p>
<p><strong>Three types of job-centric dynamic relationships.</strong></p>
<p>我们定义了三种在任务j和机器m之间的动态关系。</p>
<p>路由机器集合$M_v(j)$由从机器m指向任务j的有向边的机器m组成，它能够为下一个操作处理作业 j。</p>
<p>$M_v(j) &#x3D; {m|m \in M \and(m \rightarrow j)} \ \ \ \ \ (25)$</p>
<p>拥有相同的路由机器的任务j’的路由任务集合$J_v(j)$由下式表示，它与相同路由机器上的作业j竞争。</p>
<p>$J_v(j) &#x3D; {j’|j’ \in J \and (M_v(j’)\cap M_v(j)\neq \emptyset} \ \ \ \ \ \ (26)$</p>
<p>任务j的祖先集合$J_g(j)$是拥有到job j的路径的所有job $j’ \in J$的集合，式子中的虚线箭头表示一条路径，它是具有无向边$(j′, m_1)$ 或有向边 $j′ → m_1$，有向边 $m_l → m_{l+1}$ 的不同节点序列$(j’, m_1, . . . , m_n, j)$ 以及$m_n → j (l &#x3D; 1, . . ., n−1)$。</p>
<p>$J_g(j) &#x3D; {j’|j’ \dashrightarrow j} \ \ \ \ \ \ \ \ (27)$</p>
<p>祖先结点将会在未来对任务j的路由机器$m_n$带来负载。例如，在图3中，结点8上的$M_v(8) &#x3D; {5,6}, J_v(8) &#x3D; {9},J_g(8) &#x3D; {7,10,11,12}$.</p>
<p><strong>Four types of job-centric numeric features.</strong></p>
<p>我们基于任务j的路由任务集合$J_v(j)$和祖先集合$J_g(j)$提取了四种数量特征。</p>
<p>和任务j有不同关系的任务数量$f_{num}$由下式表示，其中[]表示一个向量聚合，(.)由式26，27得到的v和g来设定，之后的符号也是这样的含义。</p>
<p>$f_{num}(j) &#x3D; [|J_{(.)}(j)|]\ \ \ \ \ \ \ (28)$</p>
<p>这些任务的负载上的三个统计量由下式表示：</p>
<p>$f_{sum}(j) &#x3D; [\sum_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ (29)$</p>
<p>$f_{max}(j) &#x3D; [max_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ \ \ (30)$</p>
<p>$f_{min}(j) &#x3D; [min_{j’\in J_{(.)}(j)}q_{j’}]\ \ \ \ \ \ \ \ (31)$</p>
<p>任务j的复杂环境由这些特征表示，这些特征在同任务相关的智能体采取最优动作时有重要作用。</p>
<h3 id="Representations-of-states-and-actions"><a href="#Representations-of-states-and-actions" class="headerlink" title="Representations of states and actions"></a>Representations of states and actions</h3><p>在FJSS的大型状态空间中，将每个状态表示为标识符并学习每个状态的每个动作的状态-动作值是不可行的，就像在经典的 Q-learning 算法中一样。我们的DeepMAG通过代表状态和动作作为4.3节描述的一系列特征去估计状态动作值函数$\mathbb Q(s_i,a_i)$。机器相关和任务相关的智能体拥有不同的表示。</p>
<h4 id="Machine-associated-agents"><a href="#Machine-associated-agents" class="headerlink" title="Machine-associated agents"></a>Machine-associated agents</h4><p>让同机器有关的智能体$i&#x3D;m\in M$处于可用状态（用式16表示的话就是$J_u(m) &#x3D; \emptyset$），并且在一个时间步有一个正在等待的任务集合$J_w(m)$（由式17表示）。状态$s_i$应该反映智能体的特征和周围环境以及应该能够使每一个动作$a_i&#x3D;J\in J_w(m)$同其他动作区分开。</p>
<p>**State representations.**状态由向量$s_i$表示，它通过链接生产力$p_m$以及其中机器独有的数量特征（由式18～24表示）。此外，这些从式18～24提取出的向量是由定义4.1得到的多智能体图以及定义4.4的特定机器智能体图$g(m)$提取出来的.所有提取的特征对于智能体i或者机器m都是非常特别的，它们中的大多数都是依赖机器同相邻机器以及任务之间的关系。因此，智能体可以通过观察不同的状态来和其他的智能体合作去做出动作。</p>
<p>**Action representations.**一个可能的动作$a_i&#x3D;j\in J_w(m)$被表示为一个向量$a_i$，这个向量是由基于定义4.3得到的特定任务的智能体图得到的工作数量$q_{j,m}$和由式18到24得到的七种以机器为中心的数量特征。所有的这些特征对于正在等待的任务j来说是特别的，并且不同于其他的任务或者正在等待的任务。值得注意的是四种以任务为中心的数量特征不适用于提取任务j的特征，因为根据式25，在机器m上等待的任务j以及它的路由机器集合式空的。</p>
<h4 id="Job-associated-agents"><a href="#Job-associated-agents" class="headerlink" title="Job-associated agents"></a>Job-associated agents</h4><p>相反，假设一个与工作相关的智能体 i &#x3D; j ∈ J 准备就绪并且在一个时间步,由式25得知它中有一个路由机器集 $M_v(j)$。类似地，需要用任务 j 自身和周围的特征来表示状态 $s_j$，并表征每个可能的动作 $a_i &#x3D; m ∈ M_v(j)$。</p>
<p>**State representations.**由一个向量$s_i$组成状态$s_i$，这个向量是通过将工作数量$q_j$和通过式28到31的四种以任务为中心的数量特征表示。这些特征由任务j和其他任务在多智能体图以及特定任务图之间提取得出。所有的特征依赖智能体i或者任务j，但是他的任何动作都是独立的。</p>
<p>**Action representations.**一个候选动作$a_i&#x3D;m\in M_v(j)$由一个向量$a_i$表示，它通过将生产力$p_m$和七种类型的以机器为中心的数量特征，这些特征由多智能体图，特定任务的智能体图以及特定机器的智能体图得到。需要注意，等式18到24的定义是基于机器m，而不是这些种类的智能体图。</p>
<p>总的来说，无论什么样的智能体，表现出的状态或者动作都包含他们独特特征以及周围特征。接下来，这些智能体就能够一同工作以发现一个最优的连续动作(optimail joint action)。</p>
<h3 id="Learning-on-DQNs"><a href="#Learning-on-DQNs" class="headerlink" title="Learning on DQNs"></a>Learning on DQNs</h3><p>与单独的智能体分别学习各自的DQN的简单方法不同，DeepMAG为每一种做出不同动作的智能体学习一个DQN以降低成本，增加可扩展性并且能够去改变FJSS环境中的智能体个数。所有同机器相关的智能体共享一个DQN，它们在相应的机器到达可用状态时做出任务排序的动作。所有同任务相关的智能体共享另一个DQN，它们在机器现有的操作结束时，选择一个符合条件的机器去进行它的下一个操作。此外，两个DQN拥有同样的学习算法，比如deep Q-learning，只是在状态和动作上拥有不同的输入。deep Q-learning基于经验回放，他的目标是估计状态动作值函数$\mathbb Q(s_i, a_i)$.通常这种函数被建模为深度神经网络（如DQN）。智能体的经验就是根据马尔可夫过程将得到的$(s_i,a_i,s_i’,r)$进行存储。在学习过程中，Q-learning更新被应用在经验的mini-batches上。Q-learning的更新使用如下的损失函数:</p>
<p>$\mathbb L(\theta_n) &#x3D; \mathbb E[\left(r + \gamma \ max_{a’_i\in A_i}\hat{\mathbb Q}(s_i’,a_i’|\hat \theta_n) - \hat{\mathbb Q}(s_i, a_i|\theta_n)\right)^2 ] \ \ \ \ \ \ \ (32)$</p>
<p>其中$\gamma$是折扣率，$\theta_n$是DQN的参数。$\hat \theta_n$是用来计算目标的参数。目标网络的参数只有每N步才会进行更新。参数$\theta_n$由随机梯度下降算法进行学习。</p>
<h3 id="Training-optimization"><a href="#Training-optimization" class="headerlink" title="Training optimization"></a>Training optimization</h3><p>标准的深度 Q 学习算法是无模型的，它通过直接使用来自模拟器的样本训练 DQN 来估计方程式中的值函数 Q(si, ai)。 （4），而不是等式 (1)中的条件概率质量函数 P（s’，r | s，a）。通过学习等式中的贪心策略 a∗ i &#x3D; π (si) 也是一种off-policy。 (5) 同时遵循确保对状态空间进行充分探索的行为分布。在实践中，行为分布通常由 ε-greedy policy 确定，该 ε-greedy policy 遵循概率为 1−ε 的贪婪策略并选择概率为 ε 的随机动作。 DeepMAG 将此算法扩展到多智能体系统，如算法 1 所示。</p>
<p><img src="http://cdn.leafii.top/img/image-20230531161425827.png" alt="image-20230531161425827" loading="lazy"></p>
<p>在FJSS环境中，智能体的动作次序是重要的，这对他们知道其他智能体的表现以及互相合作很重要。所以，同任务相关的智能体的动作应该先进行执行，以确保在机器的等待执行队列中有已经被路由去的待执行任务的操作存在。此外，应该根据任务和机器的工作量数量递减排序，因为有大的负载的任务或者机器都对makespan有着很大的影响， 需要更多的关注。最后，两种智能体使用算法2去学习他们自己的DQN。</p>
<p><img src="http://cdn.leafii.top/img/image-20230531162203905.png" alt="image-20230531162203905" loading="lazy"></p>
<p>**Computational complexity.**略</p>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>在5.1定义了实验设置，在5.2分析了实验结果。</p>
<h3 id="Experimental-setting"><a href="#Experimental-setting" class="headerlink" title="Experimental setting"></a>Experimental setting</h3><h4 id="Emulated-data"><a href="#Emulated-data" class="headerlink" title="Emulated data"></a>Emulated data</h4><p>模拟了在现实世界工厂里用63，50，35，34个机器实现四个有序操作的场景。他们的生产力范围从每小时2400到8400不等。有四种任务，每一种都有一个相等的关系，也就是这些拥有相同类型的任务是相等的，并且构成了相等的类。每种任务在每一个操作上有固定的机器集合，这些数据在表2中被展示。需要注意的是这些数据都是真实工厂中的数据。</p>
<p><img src="http://cdn.leafii.top/img/image-20230531163034639.png" alt="image-20230531163034639" loading="lazy"></p>
<p>为了训练DQN，在每一个episode的开始，我们通过均匀分布得到机器U(16,64),任务的数量$|J|\sim U(10, 100)$来生成FJSS实例。每个人物和负载的数量$q \sim U(1,4) \times 10,000$。这些均匀分布是根据现实世界工厂的离散的值，请注意，机器 M 是从给定的常量机器集中为 J 中的每对作业类型和操作挑选的。 DQN 在 10,000 个实例上进行训练并在三个场景中进行测试。每个场景包含 100 个具有相同作业数量（即 20、60 和 100）的不同实例，并取这 100 个实例的平均性能。</p>
<h4 id="Evaluated-methods"><a href="#Evaluated-methods" class="headerlink" title="Evaluated methods"></a>Evaluated methods</h4><p>我们将提出的DeepMAG同竞争的分发规则，因为其他的方法对于JSS或者FJSS来说没有可扩展性。大多数现有的方法只能解决少于20个机器或者任务。尽管RL方法可以处理大量的机器或者任务，但没有现有的工作用语FJSS。我们开发了四种复合调度方法。</p>
<ul>
<li>$J_W M_{max}$：作业关联智能体选择剩余工作量最小的机器，机器关联智能体选择工作负载最大的作业。</li>
<li>$J_T M_{max}$：与作业相关的智能体选择剩余处理时间最少的机器，与机器相关的智能体选择工作量最大的作业。</li>
<li>$J_W M_{min}$：作业关联智能体选择剩余工作量最小的机器，机器关联智能体选择工作负载最小的作业。</li>
<li>$J_T M_{min}$：与作业相关的智能体选择剩余处理时间最少的机器，与机器相关的智能体选择工作量最小的作业。</li>
</ul>
<p>四个复合调度规则始终将较高的优先级分配给负担较低的机器，即与作业相关的智能体的最小剩余工作量或处理时间。选择负担很重的机器显然是不合适的，这会成为制造时间的瓶颈。此外，这些规则总是根据作业的工作量为机器相关智能体选择作业，因为工作量与机器上的处理时间成正比，即工作量和处理时间都会导致相同的结果。</p>
<h4 id="Performance-metrics"><a href="#Performance-metrics" class="headerlink" title="Performance metrics"></a>Performance metrics</h4><p>为了比较 FJSS 上评估方法的性能，我们采用标准指标，即完成所有作业的时间步长总数。请注意，我们报告了每个场景中具有相同作业数量的 100 个测试实例的平均完工时间。</p>
<h4 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h4><p>我们的实验平台是一个计算服务器，配备 Interl(R) Xeon (R) CPU E5-2699 v4 2.20 GHz 和 Nvidia V100 GPU (16 GB)。 OpenAI 的 Gym 和谷歌的 TensorFlow 是分别用于强化学习和深度学习的开源软件库。我们基于Gym 0.17.3 实现了FJSS 环境，通过指定环境与agent 交互的标准接口。我们基于 TensorFlow 1.14 使用 DQN 实现智能体。每个 DQN 都是一个多层感知器，其中隐藏层数设置为三层，三层神经元数设置为 64、32 和 16。折扣率设置为 γ &#x3D; 0.9，ε-greedy探索从开始时的 ε &#x3D; 1 衰减到结束时的 ε &#x3D; 0.05。为了适应 FJSS 中具有不同机器和作业分布的各种环境，我们根据训练实例估计了预期的转换和步骤总数。然后，重放内存大小 |D|由与转换总数的比率（默认为 0.25）确定，而目标网络更新频率 N 是通过将总步数除以更新次数（默认为 10）来计算的。我们基于 Adam 优化器训练两个 DQN，批量大小为 64，学习率为 0.0001。</p>
<h3 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h3><h4 id="Method-comparison"><a href="#Method-comparison" class="headerlink" title="Method comparison"></a>Method comparison</h4><p>表 3 比较了三种不同场景下所有评估方法的完工时间。我们可以得出以下三个重要发现。 (1) 我们的 DeepMAG 始终在所有三种场景中实现最佳性能，包括小型、中型和大量作业。与第二好的相反，根据 JT Mmax 给出的性能，DeepMAG 平均将完工时间缩短了 3.6%。这些结果证明了 DeepMAG 对于具有大搜索空间的 FJSS 的有效性，因为它充分利用了 DRL 和 MARL 之间的集成以及智能体在根据机器和作业之间的操作关系构建的各种图中的合作。 (2) JT Mmax 优于其他评估的调度规则，因为在 JT Mmax 中，作业相关智能体根据其处理时间而不是工作量来选择机器，以考虑其生产力的影响。此外，在 JT Mmax 中，与机器相关的智能体通过选择具有最大工作负载而不是最小工作负载的作业来更加关注具有较大工作负载的作业以减少完工时间，其中具有大工作负载的作业主导完工时间。 (3) 相比之下，JW Mmin 在所有三种情况下始终记录最长的 makespan，因为它根据工作量选择机器而不考虑机器生产率，并通过更多地关注工作量小的工作来选择工作。</p>
<p><img src="http://cdn.leafii.top/img/image-20230531171254007.png" alt="image-20230531171254007" loading="lazy"></p>
<h4 id="Effect-of-replay-memory-ratios"><a href="#Effect-of-replay-memory-ratios" class="headerlink" title="Effect of replay memory ratios"></a>Effect of replay memory ratios</h4><p>图 4 描绘了不同重放内存比率对 DeepMAG 上预期转换总数的影响，其中该比率与重放内存大小 |D| 成正比。重放内存比率对完工时间的影响很小。由于这三种场景的预期转换总数很大，因此较小的比率会在回放内存中贡献足够的转换，以减轻观察序列中的相关性并平滑模拟数据中的变化，从而解决 DRL 中的不稳定性（甚至发散）和 MARL 在某种程度上。尽管较大的比率提供了更多的回放转换以进一步减少不稳定性，但更多的历史转换会降低学习效率并抵消对不稳定性的改进。在实践中，采用较小的比率来节省内存成本，例如，在我们的实验中默认为 0.25。</p>
<p><img src="http://cdn.leafii.top/img/image-20230531171419329.png" alt="image-20230531171419329" loading="lazy"></p>
<h4 id="Effect-of-target-network-update-times"><a href="#Effect-of-target-network-update-times" class="headerlink" title="Effect of target network update times"></a>Effect of target network update times</h4><p>图 5 显示了 DeepMAG 中目标网络更新次数的影响，即目标网络在整个训练过程中更新了多少次。最好的结果是更新目标网络 10 次。当更新时间从 10 次减少到 5 次时，性能变差；原因是目标网络更新太慢，Eq.中的估计目标值。 (32) 经常过时。相反，随着更新时间从 10 次增加到 80 次，性能也变得更差；这个结果是由于状态-动作值和目标值之间的相关性导致的不稳定性增加造成的。因此，应该使用适当数量的目标网络更新次数来平衡不稳定性和过时的目标值。</p>
<p><img src="http://cdn.leafii.top/img/image-20230531171452175.png" alt="image-20230531171452175" loading="lazy"></p>
<h4 id="Effect-of-neuron-numbers"><a href="#Effect-of-neuron-numbers" class="headerlink" title="Effect of neuron numbers"></a>Effect of neuron numbers</h4><p>图 6 描绘了关于改变 DQN 的第一个隐藏层中的神经元数量的影响，其中每个连续的隐藏层在前一个隐藏层中具有一半数量的神经元。具有 32 个神经元的设置产生最差的性能，因为神经元数量少导致 FJSS 学习模型的表达力非常有限。当神经元数量从 32 个增加到 64 个时，性能显着提高。原因是模型的表达能力增强了，有利于发现各种状态下更好的动作。随着神经元数量从 64 变为 128，makespan 变长了一点，因为学习的模型可能会出现过度拟合数据的问题。在实践中，应采用适度的神经元数来平衡模型的表达性、泛化性、专业化和计算成本，包括 CPU 时间和内存使用。</p>
<p><img src="http://cdn.leafii.top/img/image-20230531171525518.png" alt="image-20230531171525518" loading="lazy"></p>
<h4 id="Convergence-analysis"><a href="#Convergence-analysis" class="headerlink" title="Convergence analysis"></a>Convergence analysis</h4><p>图 7 分别说明了 DeepMAG 在具有 20、60 和 100 个作业的三个测试场景中的奖励曲线，其中 x 轴是训练集的数量，y 轴是 100 个测试实例的平均奖励，如前所述在第 5.1.1 节中。从图.图.从图7可以看出，一开始曲线波动较大，因为DeepMAG的模型参数更新很大。重要的是，在大约 7,000 次训练后，这些曲线收敛到与时间步数相反的接近最大的奖励。这种收敛特性使 DeepMAG 能够在真实的制造工厂中学习 FJSS 的可行解决方案。</p>
<p><img src="http://cdn.leafii.top/img/image-20230531171559090.png" alt="image-20230531171559090" loading="lazy"></p>
<h2 id="Conclusion-and-future-work"><a href="#Conclusion-and-future-work" class="headerlink" title="Conclusion and future work"></a>Conclusion and future work</h2><p>在本文中，我们形式化了灵活的作业车间调度（FJSS）问题，包括基于作业排序和路由的基于马尔可夫决策过程的框架，并据此定义了 FJSS 中的环境、智能体、状态、动作和奖励五个重要概念。然后，我们提出了一种基于 DRL 的 FJSS 新模型 DeepMAG，该模型具有多智能体图，该图是根据机器和作业之间的操作关系构建的，即机器的操作顺序和可以处理的作业的可能操作。 DeepMAG 将 DRL 与 MARL 相结合，解决了 FJSS 在状态和动作上空间过大的问题。一方面，DeepMAG 利用两个 DQN 分别为机器相关智能体的作业排序和作业相关智能体的作业路由找到最佳操作。另一方面，DeepMAG 利用各种多智能体图使每个智能体能够与其相邻智能体合作并采取一个合作行动。最后，仿真实验结果表明，与其他最先进的方法相比，DeepMAG 在 FJSS 的三种场景下实现了最佳性能。</p>
<p>将来，我们将考虑更先进的方法作为基线，例如，通过升级基于启发式的方法以适应大量机器和作业。本文重点研究静态 FJSS 问题，而一些动态事件，如机器故障、新工作插入和工作取消，在现实世界的制造环境中是不可避免的。因此，在 FJSS 中结合动态事件的特征来设计方法是我们未来的研究方向之一。</p>
<h2 id="Data-availability"><a href="#Data-availability" class="headerlink" title="Data availability"></a>Data availability</h2><p>作者无权共享数据。</p>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Leafii</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="2023/05/31/DeepMAG-使用多智能体图进行深度强化学习以实现灵活的作业车间调度/" title="DeepMAG-使用多智能体图进行深度强化学习以实现灵活的作业车间调度">2023/05/31/DeepMAG-使用多智能体图进行深度强化学习以实现灵活的作业车间调度/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="../../../06/01/leetcode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="prev" title="leetcode236.二叉树的最近公共祖先"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">leetcode236.二叉树的最近公共祖先</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="../leetcode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="next" title="leetcode98.验证二叉搜索树"><span class="post-nav-text">leetcode98.验证二叉搜索树</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Leafii</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.2.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.9.3</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="../../../../js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></div></body></html>